int	O
facilities_seen	int
;	O
const	O
char	O
*	O
ConfFile	*(char)
=	O
PATH_LOGCONF	O
;	O
const	O
char	O
*	O
PidFile	*(char)
=	O
PATH_LOGPID	O
;	O
char	O
ctty	array(char)
[	O
]	O
=	O
PATH_CONSOLE	O
;	O
static	O
int	O
dbg_output	int
;	O
static	O
int	O
restart	int
;	O
struct	O
funix	struct(*(char),int)
{	O
const	O
char	O
*	O
name	*(char)
;	O
int	O
fd	int
;	O
}	O
*	O
funix	struct(*(char),int)
;	O
size_t	long
nfunix	long
;	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
{	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
*	O
f_next	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
short	O
f_type	short
;	O
short	O
f_file	short
;	O
time_t	long
f_time	long
;	O
unsigned	O
char	O
f_pmask	array(char)
[	O
LOG_NFACILITIES	int
+	O
1	int
]	O
;	O
union	O
{	O
struct	O
{	O
int	O
f_nusers	int
;	O
char	O
*	O
*	O
f_unames	*(*(char))
;	O
}	O
f_user	struct(int,*(*(char)))
;	O
struct	O
{	O
char	O
*	O
f_hname	*(char)
;	O
struct	O
sockaddr_storage	struct(short,array(char),long)
f_addr	struct(short,array(char),long)
;	O
socklen_t	int
f_addrlen	int
;	O
}	O
f_forw	struct(*(char),struct(short,array(char),long),int)
;	O
char	O
*	O
f_fname	*(char)
;	O
}	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
;	O
char	O
f_prevline	array(char)
[	O
MAXSVLINE	int
]	O
;	O
char	O
f_lasttime	array(char)
[	O
16	int
]	O
;	O
char	O
*	O
f_prevhost	*(char)
;	O
int	O
f_prevpri	int
;	O
int	O
f_prevlen	int
;	O
int	O
f_prevcount	int
;	O
size_t	long
f_repeatcount	long
;	O
int	O
f_flags	int
;	O
}	O
;	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
*	O
Files	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
consfile	struct(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
;	O
const	O
char	O
*	O
TypeNames	array(*(char))
[	O
]	O
=	O
{	O
"UNUSED"	*(char)
,	O
"FILE"	*(char)
,	O
"TTY"	*(char)
,	O
"CONSOLE"	*(char)
,	O
"FORW"	*(char)
,	O
"USERS"	*(char)
,	O
"WALL"	*(char)
,	O
"FORW(SUSPENDED)"	*(char)
,	O
"FORW(UNKNOWN)"	*(char)
,	O
"PIPE"	*(char)
}	O
;	O
int	O
repeatinterval	array(int)
[	O
]	O
=	O
{	O
30	int
,	O
60	int
}	O
;	O
extern	O
int	O
waitdaemon	(int,int,int)->(int)
(	O
int	O
nochdir	int
,	O
int	O
noclose	int
,	O
int	O
maxwait	int
)	O
;	O
void	O
cfline	(*(char),*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)))->(void)
(	O
const	O
char	O
*	O
,	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
*	O
)	O
;	O
const	O
char	O
*	O
cvthname	(*(struct(short,array(char))),int)->(*(char))
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
,	O
socklen_t	int
)	O
;	O
int	O
decode	(*(char),*(struct(*(char),int)))->(int)
(	O
const	O
char	O
*	O
,	O
CODE	struct(*(char),int)
*	O
)	O
;	O
void	O
die	(int)->(void)
(	O
int	O
)	O
;	O
void	O
doexit	(int)->(void)
(	O
int	O
)	O
;	O
void	O
domark	(int)->(void)
(	O
int	O
)	O
;	O
void	O
fprintlog	(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),*(char),int,*(char))->(void)
(	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
*	O
,	O
const	O
char	O
*	O
,	O
int	O
,	O
const	O
char	O
*	O
)	O
;	O
void	O
init	(int)->(void)
(	O
int	O
)	O
;	O
void	O
logerror	(*(char))->(void)
(	O
const	O
char	O
*	O
)	O
;	O
void	O
logmsg	(int,*(char),*(char),int)->(void)
(	O
int	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
void	O
printline	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
void	O
printsys	(*(char))->(void)
(	O
const	O
char	O
*	O
)	O
;	O
char	O
*	O
ttymsg	(*(struct(*(void),long)),int,*(char),int)->(*(char))
(	O
struct	O
iovec	struct(*(void),long)
*	O
,	O
int	O
,	O
char	O
*	O
,	O
int	O
)	O
;	O
void	O
wallmsg	(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),*(struct(*(void),long)))->(void)
(	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
*	O
,	O
struct	O
iovec	struct(*(void),long)
*	O
)	O
;	O
char	O
*	O
*	O
crunch_list	(*(*(char)),*(char))->(*(*(char)))
(	O
char	O
*	O
*	O
oldlist	*(*(char))
,	O
char	O
*	O
list	*(char)
)	O
;	O
char	O
*	O
textpri	(int)->(*(char))
(	O
int	O
pri	int
)	O
;	O
void	O
dbg_toggle	(int)->(void)
(	O
int	O
)	O
;	O
static	O
void	O
dbg_printf	(*(char))->(void)
(	O
const	O
char	O
*	O
,	O
...	O
)	O
;	O
void	O
trigger_restart	(int)->(void)
(	O
int	O
)	O
;	O
static	O
void	O
add_funix	(*(char))->(void)
(	O
const	O
char	O
*	O
path	*(char)
)	O
;	O
static	O
int	O
create_unix_socket	(*(char))->(int)
(	O
const	O
char	O
*	O
path	*(char)
)	O
;	O
static	O
void	O
create_inet_socket	(int,array(int))->(void)
(	O
int	O
af	int
,	O
int	O
fd46	array(int)
[	O
2	int
]	O
)	O
;	O
char	O
*	O
LocalHostName	*(char)
;	O
char	O
*	O
LocalDomain	*(char)
;	O
char	O
*	O
BindAddress	*(char)
=	O
NULL	O
;	O
char	O
addrstr	array(char)
[	O
INET6_ADDRSTRLEN	int
]	O
;	O
char	O
addrname	array(char)
[	O
NI_MAXHOST	int
]	O
;	O
int	O
usefamily	int
=	O
AF_INET	O
;	O
int	O
finet	array(int)
[	O
2	int
]	O
=	O
{	O
-	O
1	int
,	O
-	O
1	int
}	O
;	O
int	O
fklog	int
=	O
-	O
1	int
;	O
char	O
*	O
LogPortText	*(char)
=	O
"syslog"	*(char)
;	O
int	O
Initialized	int
;	O
int	O
MarkInterval	int
=	O
20	int
*	O
60	int
;	O
int	O
MarkSeq	int
;	O
int	O
Debug	int
;	O
int	O
AcceptRemote	int
;	O
char	O
*	O
*	O
StripDomains	*(*(char))
;	O
char	O
*	O
*	O
LocalHosts	*(*(char))
;	O
int	O
NoDetach	int
;	O
int	O
NoHops	int
=	O
1	int
;	O
int	O
NoKLog	int
;	O
int	O
NoUnixAF	int
;	O
int	O
NoForward	int
;	O
time_t	long
now	long
;	O
int	O
force_sync	int
;	O
const	O
char	O
args_doc	*(char)
[	O
]	O
=	O
""	*(char)
;	O
const	O
char	O
doc	*(char)
[	O
]	O
=	O
"Log system messages."	*(char)
;	O
enum	O
{	O
OPT_NO_FORWARD	int
=	O
256	int
,	O
OPT_NO_KLOG	int
,	O
OPT_NO_UNIXAF	int
,	O
OPT_PIDFILE	int
,	O
OPT_IPANY	int
}	O
;	O
static	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
argp_options	array(struct(*(char),int,*(char),int,*(char),int))
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
'a'	O
,	O
"SOCKET"	*(char)
,	O
0	int
,	O
"add unix socket to listen to (up to 19)"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
'l'	O
,	O
"HOSTLIST"	*(char)
,	O
0	int
,	O
"log hosts in HOSTLIST by their hostname"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
's'	O
,	O
"DOMAINLIST"	*(char)
,	O
0	int
,	O
"list of domains which should be stripped "	*(char)
"from the FQDN of hosts before logging their name"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"debug"	*(char)
,	O
'd'	O
,	O
NULL	O
,	O
0	int
,	O
"print debug information (implies --no-detach)"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"hop"	*(char)
,	O
'h'	O
,	O
NULL	O
,	O
0	int
,	O
"forward messages from remote hosts"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"inet"	*(char)
,	O
'r'	O
,	O
NULL	O
,	O
0	int
,	O
"receive remote messages via internet domain socket"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"ipv4"	*(char)
,	O
'4'	O
,	O
NULL	O
,	O
0	int
,	O
"restrict to IPv4 transport (default)"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"ipv6"	*(char)
,	O
'6'	O
,	O
NULL	O
,	O
0	int
,	O
"restrict to IPv6 transport"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"ipany"	*(char)
,	O
OPT_IPANY	int
,	O
NULL	O
,	O
0	int
,	O
"allow transport with IPv4 and IPv6"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"bind"	*(char)
,	O
'b'	O
,	O
"ADDR"	*(char)
,	O
0	int
,	O
"bind listener to this address/name"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"mark"	*(char)
,	O
'm'	O
,	O
"INTVL"	*(char)
,	O
0	int
,	O
"specify timestamp interval in logs (0 for no "	*(char)
"timestamps)"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"no-detach"	*(char)
,	O
'n'	O
,	O
NULL	O
,	O
0	int
,	O
"do not enter daemon mode"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"no-forward"	*(char)
,	O
OPT_NO_FORWARD	int
,	O
NULL	O
,	O
0	int
,	O
"do not forward any messages "	*(char)
"(overrides --hop)"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"no-klog"	*(char)
,	O
OPT_NO_KLOG	int
,	O
NULL	O
,	O
0	int
,	O
"do not listen to kernel log device "	*(char)
PATH_KLOG	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"no-unixaf"	*(char)
,	O
OPT_NO_UNIXAF	int
,	O
NULL	O
,	O
0	int
,	O
"do not listen on unix domain "	*(char)
"sockets (overrides -a and -p)"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"pidfile"	*(char)
,	O
OPT_PIDFILE	int
,	O
"FILE"	*(char)
,	O
0	int
,	O
"override pidfile (default: "	*(char)
PATH_LOGPID	O
")"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"rcfile"	*(char)
,	O
'f'	O
,	O
"FILE"	*(char)
,	O
0	int
,	O
"override configuration file (default: "	*(char)
PATH_LOGCONF	O
")"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"socket"	*(char)
,	O
'p'	O
,	O
"FILE"	*(char)
,	O
0	int
,	O
"override default unix domain socket "	*(char)
PATH_LOG	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"sync"	*(char)
,	O
'S'	O
,	O
NULL	O
,	O
0	int
,	O
"force a file sync on every line"	*(char)
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
error_t	int
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(struct)
)	O
{	O
char	O
*	O
endptr	*(char)
;	O
int	O
v	int
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
'a'	O
:	O
add_funix	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
LocalHosts	*(*(char))
=	O
crunch_list	(*(*(char)),*(char))->(*(*(char)))
(	O
LocalHosts	*(*(char))
,	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
StripDomains	*(*(char))
=	O
crunch_list	(*(*(char)),*(char))->(*(*(char)))
(	O
StripDomains	*(*(char))
,	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
Debug	int
=	O
1	int
;	O
NoDetach	int
=	O
1	int
;	O
break	O
;	O
case	O
'h'	O
:	O
NoHops	int
=	O
0	int
;	O
break	O
;	O
case	O
'r'	O
:	O
AcceptRemote	int
=	O
1	int
;	O
break	O
;	O
case	O
'4'	O
:	O
usefamily	int
=	O
AF_INET	O
;	O
break	O
;	O
case	O
'6'	O
:	O
usefamily	int
=	O
AF_INET6	O
;	O
break	O
;	O
case	O
OPT_IPANY	int
:	O
usefamily	int
=	O
AF_UNSPEC	O
;	O
break	O
;	O
case	O
'b'	O
:	O
BindAddress	*(char)
=	O
arg	*(char)
;	O
break	O
;	O
case	O
'm'	O
:	O
v	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
,	O
&	O
endptr	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
endptr	*(char)
)	O
argp_error	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(char))->(void)
(	O
state	*(struct)
,	O
"invalid value (`%s' near `%s')"	*(char)
,	O
arg	*(char)
,	O
endptr	*(char)
)	O
;	O
MarkInterval	int
=	O
v	int
*	O
60	int
;	O
break	O
;	O
case	O
'n'	O
:	O
NoDetach	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_FORWARD	int
:	O
NoForward	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_KLOG	int
:	O
NoKLog	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_UNIXAF	int
:	O
NoUnixAF	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_PIDFILE	int
:	O
PidFile	*(char)
=	O
arg	*(char)
;	O
break	O
;	O
case	O
'f'	O
:	O
ConfFile	*(char)
=	O
arg	*(char)
;	O
break	O
;	O
case	O
'p'	O
:	O
funix	struct(*(char),int)
[	O
0	int
]	O
.	O
name	*(char)
=	O
arg	*(char)
;	O
funix	struct(*(char),int)
[	O
0	int
]	O
.	O
fd	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
force_sync	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
{	O
argp_options	array(struct(*(char),int,*(char),int,*(char),int))
,	O
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
,	O
args_doc	*(char)
,	O
doc	*(char)
}	O
;	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
size_t	long
i	long
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
p	*(char)
;	O
char	O
line	*(char)
[	O
MAXLINE	int
+	O
1	int
]	O
;	O
char	O
kline	array(char)
[	O
MAXLINE	int
+	O
1	int
]	O
;	O
int	O
kline_len	int
=	O
0	int
;	O
pid_t	int
ppid	int
=	O
0	int
;	O
struct	O
pollfd	struct(int,short,short)
*	O
fdarray	*(struct(int,short,short))
;	O
unsigned	O
long	O
nfds	long
=	O
0	int
;	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
add_funix	(*(char))->(void)
(	O
PATH_LOG	O
)	O
;	O
iu_argp_init	O
(	O
"syslogd"	*(char)
,	O
default_program_authors	array(*(char))
)	O
;	O
argp_parse	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,*(int),*(void))->(int)
(	O
&	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
NoDetach	int
)	O
{	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGTERM	int
,	O
doexit	(int)->(void)
)	O
;	O
ppid	int
=	O
waitdaemon	(int,int,int)->(int)
(	O
0	int
,	O
0	int
,	O
30	int
)	O
;	O
if	O
(	O
ppid	int
<	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"could not become daemon"	*(char)
)	O
;	O
}	O
else	O
{	O
dbg_output	int
=	O
1	int
;	O
setvbuf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,long)->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
0	int
,	O
_IOLBF	int
,	O
0	int
)	O
;	O
}	O
LocalHostName	*(char)
=	O
localhost	()->(*(char))
(	O
)	O
;	O
if	O
(	O
LocalHostName	*(char)
==	O
NULL	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"can't get local host name"	*(char)
)	O
;	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
LocalHostName	*(char)
,	O
'.'	O
)	O
;	O
if	O
(	O
p	*(char)
!=	O
NULL	O
)	O
{	O
*	O
p	*(char)
++	O
=	O
'\0'	O
;	O
LocalDomain	*(char)
=	O
p	*(char)
;	O
}	O
else	O
{	O
struct	O
addrinfo	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`))))))
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
*	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
int	O
err	long
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
0	int
,	O
sizeof	O
(	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
)	O
)	O
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_family	int
=	O
AF_UNSPEC	O
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_flags	int
=	O
AI_CANONNAME	int
;	O
err	long
=	O
getaddrinfo	(*(char),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))),*(*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))->(int)
(	O
LocalHostName	*(char)
,	O
NULL	O
,	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
&	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
err	long
==	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
LocalHostName	*(char)
)	O
;	O
LocalHostName	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_canonname	*(char)
)	O
;	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
LocalHostName	*(char)
,	O
'.'	O
)	O
;	O
if	O
(	O
p	*(char)
!=	O
NULL	O
)	O
{	O
*	O
p	*(char)
++	O
=	O
'\0'	O
;	O
LocalDomain	*(char)
=	O
p	*(char)
;	O
}	O
freeaddrinfo	(*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
}	O
if	O
(	O
LocalDomain	*(char)
==	O
NULL	O
)	O
LocalDomain	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
""	*(char)
)	O
;	O
}	O
consfile	struct(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
.	O
f_type	short
=	O
F_CONSOLE	int
;	O
consfile	struct(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
.	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
ctty	array(char)
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGTERM	int
,	O
die	(int)->(void)
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGINT	int
,	O
Debug	int
?	O
die	(int)->(void)
:	O
SIG_IGN	O
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGQUIT	int
,	O
Debug	int
?	O
die	(int)->(void)
:	O
SIG_IGN	O
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGALRM	int
,	O
domark	(int)->(void)
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGUSR1	int
,	O
Debug	int
?	O
dbg_toggle	(int)->(void)
:	O
SIG_IGN	O
)	O
;	O
alarm	(int)->(int)
(	O
TIMERINTVL	int
)	O
;	O
fdarray	*(struct(int,short,short))
=	O
(	O
struct	O
pollfd	struct(int,short,short)
*	O
)	O
malloc	(long)->(*(void))
(	O
(	O
nfunix	long
+	O
3	int
)	O
*	O
sizeof	O
(	O
*	O
fdarray	*(struct(int,short,short))
)	O
)	O
;	O
if	O
(	O
fdarray	*(struct(int,short,short))
==	O
NULL	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"can't allocate fd table"	*(char)
)	O
;	O
init	(int)->(void)
(	O
0	int
)	O
;	O
if	O
(	O
!	O
NoKLog	int
)	O
{	O
fklog	int
=	O
open	(*(char),int)->(int)
(	O
PATH_KLOG	O
,	O
O_RDONLY	int
,	O
0	int
)	O
;	O
if	O
(	O
fklog	int
>=	O
0	int
)	O
{	O
fdarray	*(struct(int,short,short))
[	O
nfds	long
]	O
.	O
fd	int
=	O
fklog	int
;	O
fdarray	*(struct(int,short,short))
[	O
nfds	long
]	O
.	O
events	short
=	O
POLLIN	int
|	O
POLLPRI	int
;	O
nfds	long
++	O
;	O
dbg_printf	(*(char))->(void)
(	O
"Klog open %s\n"	*(char)
,	O
PATH_KLOG	O
)	O
;	O
}	O
else	O
dbg_printf	(*(char))->(void)
(	O
"Can't open %s: %s\n"	*(char)
,	O
PATH_KLOG	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
NoUnixAF	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nfunix	long
;	O
i	long
++	O
)	O
{	O
funix	struct(*(char),int)
[	O
i	long
]	O
.	O
fd	int
=	O
create_unix_socket	(*(char))->(int)
(	O
funix	struct(*(char),int)
[	O
i	long
]	O
.	O
name	*(char)
)	O
;	O
if	O
(	O
funix	struct(*(char),int)
[	O
i	long
]	O
.	O
fd	int
>=	O
0	int
)	O
{	O
fdarray	*(struct(int,short,short))
[	O
nfds	long
]	O
.	O
fd	int
=	O
funix	struct(*(char),int)
[	O
i	long
]	O
.	O
fd	int
;	O
fdarray	*(struct(int,short,short))
[	O
nfds	long
]	O
.	O
events	short
=	O
POLLIN	int
|	O
POLLPRI	int
;	O
nfds	long
++	O
;	O
dbg_printf	(*(char))->(void)
(	O
"Opened UNIX socket `%s'.\n"	*(char)
,	O
funix	struct(*(char),int)
[	O
i	long
]	O
.	O
name	*(char)
)	O
;	O
}	O
else	O
dbg_printf	(*(char))->(void)
(	O
"Can't open %s: %s\n"	*(char)
,	O
funix	struct(*(char),int)
[	O
i	long
]	O
.	O
name	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
AcceptRemote	int
)	O
{	O
create_inet_socket	(int,array(int))->(void)
(	O
usefamily	int
,	O
finet	array(int)
)	O
;	O
if	O
(	O
finet	array(int)
[	O
IU_FD_IP4	int
]	O
>=	O
0	int
)	O
{	O
fdarray	*(struct(int,short,short))
[	O
nfds	long
]	O
.	O
fd	int
=	O
finet	array(int)
[	O
IU_FD_IP4	int
]	O
;	O
fdarray	*(struct(int,short,short))
[	O
nfds	long
]	O
.	O
events	short
=	O
POLLIN	int
|	O
POLLPRI	int
;	O
nfds	long
++	O
;	O
dbg_printf	(*(char))->(void)
(	O
"Opened syslog UDP/IPv4 port.\n"	*(char)
)	O
;	O
}	O
if	O
(	O
finet	array(int)
[	O
IU_FD_IP6	int
]	O
>=	O
0	int
)	O
{	O
fdarray	*(struct(int,short,short))
[	O
nfds	long
]	O
.	O
fd	int
=	O
finet	array(int)
[	O
IU_FD_IP6	int
]	O
;	O
fdarray	*(struct(int,short,short))
[	O
nfds	long
]	O
.	O
events	short
=	O
POLLIN	int
|	O
POLLPRI	int
;	O
nfds	long
++	O
;	O
dbg_printf	(*(char))->(void)
(	O
"Opened syslog UDP/IPv6 port.\n"	*(char)
)	O
;	O
}	O
if	O
(	O
finet	array(int)
[	O
IU_FD_IP4	int
]	O
<	O
0	int
&&	O
finet	array(int)
[	O
IU_FD_IP6	int
]	O
<	O
0	int
)	O
dbg_printf	(*(char))->(void)
(	O
"Can't open UDP port: %s\n"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
PidFile	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d\n"	*(char)
,	O
getpid	()->(int)
(	O
)	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
dbg_printf	(*(char))->(void)
(	O
"off & running....\n"	*(char)
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGHUP	int
,	O
trigger_restart	(int)->(void)
)	O
;	O
if	O
(	O
Debug	int
)	O
{	O
dbg_printf	(*(char))->(void)
(	O
"Debugging disabled, send SIGUSR1 to turn on debugging.\n"	*(char)
)	O
;	O
dbg_output	int
=	O
0	int
;	O
}	O
if	O
(	O
ppid	int
)	O
kill	(int,int)->(int)
(	O
ppid	int
,	O
SIGTERM	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
nready	int
;	O
nready	int
=	O
poll	(*(struct(int,short,short)),long,int)->(int)
(	O
fdarray	*(struct(int,short,short))
,	O
nfds	long
,	O
-	O
1	int
)	O
;	O
if	O
(	O
nready	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
restart	int
)	O
{	O
dbg_printf	(*(char))->(void)
(	O
"\nReceived SIGHUP, restarting syslogd.\n"	*(char)
)	O
;	O
init	(int)->(void)
(	O
0	int
)	O
;	O
restart	int
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
nready	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EINTR	int
)	O
logerror	(*(char))->(void)
(	O
"poll"	*(char)
)	O
;	O
continue	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nfds	long
;	O
i	long
++	O
)	O
if	O
(	O
fdarray	*(struct(int,short,short))
[	O
i	long
]	O
.	O
revents	short
&	O
(	O
POLLIN	int
|	O
POLLPRI	int
)	O
)	O
{	O
int	O
result	int
;	O
socklen_t	int
len	int
;	O
if	O
(	O
fdarray	*(struct(int,short,short))
[	O
i	long
]	O
.	O
fd	int
==	O
-	O
1	int
)	O
continue	O
;	O
else	O
if	O
(	O
fdarray	*(struct(int,short,short))
[	O
i	long
]	O
.	O
fd	int
==	O
fklog	int
)	O
{	O
result	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
fdarray	*(struct(int,short,short))
[	O
i	long
]	O
.	O
fd	int
,	O
&	O
kline	array(char)
[	O
kline_len	int
]	O
,	O
sizeof	O
(	O
kline	array(char)
)	O
-	O
kline_len	int
-	O
1	int
)	O
;	O
if	O
(	O
result	int
>	O
0	int
)	O
{	O
kline_len	int
+=	O
result	int
;	O
}	O
else	O
if	O
(	O
result	int
<	O
0	int
&&	O
errno	O
!=	O
EINTR	int
)	O
{	O
logerror	(*(char))->(void)
(	O
"klog"	*(char)
)	O
;	O
fdarray	*(struct(int,short,short))
[	O
i	long
]	O
.	O
fd	int
=	O
fklog	int
=	O
-	O
1	int
;	O
}	O
while	O
(	O
1	int
)	O
{	O
char	O
*	O
bol	*(char)
,	O
*	O
eol	*(char)
;	O
kline	array(char)
[	O
kline_len	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
bol	*(char)
=	O
kline	array(char)
,	O
eol	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
kline	array(char)
,	O
'\n'	O
)	O
;	O
eol	*(char)
;	O
bol	*(char)
=	O
eol	*(char)
,	O
eol	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
bol	*(char)
,	O
'\n'	O
)	O
)	O
{	O
*	O
(	O
eol	*(char)
++	O
)	O
=	O
'\0'	O
;	O
kline_len	int
-=	O
(	O
eol	*(char)
-	O
bol	*(char)
)	O
;	O
printsys	(*(char))->(void)
(	O
bol	*(char)
)	O
;	O
}	O
while	O
(	O
kline_len	int
&&	O
!	O
*	O
bol	*(char)
)	O
{	O
bol	*(char)
++	O
;	O
kline_len	int
--	O
;	O
}	O
if	O
(	O
!	O
kline_len	int
)	O
break	O
;	O
if	O
(	O
bol	*(char)
!=	O
kline	array(char)
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
kline	array(char)
,	O
bol	*(char)
,	O
kline_len	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
kline_len	int
<	O
MAXLINE	int
)	O
break	O
;	O
printsys	(*(char))->(void)
(	O
kline	array(char)
)	O
;	O
if	O
(	O
kline	array(char)
[	O
0	int
]	O
==	O
'<'	O
&&	O
isdigit	(int)->(int)
(	O
kline	array(char)
[	O
1	int
]	O
)	O
&&	O
kline	array(char)
[	O
2	int
]	O
==	O
'>'	O
)	O
kline_len	int
=	O
3	int
;	O
else	O
kline_len	int
=	O
0	int
;	O
}	O
}	O
}	O
else	O
if	O
(	O
fdarray	*(struct(int,short,short))
[	O
i	long
]	O
.	O
fd	int
==	O
finet	array(int)
[	O
IU_FD_IP4	int
]	O
||	O
fdarray	*(struct(int,short,short))
[	O
i	long
]	O
.	O
fd	int
==	O
finet	array(int)
[	O
IU_FD_IP6	int
]	O
)	O
{	O
struct	O
sockaddr_storage	struct(short,array(char),long)
frominet	struct(short,array(char),long)
;	O
len	int
=	O
sizeof	O
(	O
frominet	struct(short,array(char),long)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
line	*(char)
,	O
'\0'	O
,	O
sizeof	O
(	O
line	*(char)
)	O
)	O
;	O
result	int
=	O
recvfrom	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(long)
(	O
fdarray	*(struct(int,short,short))
[	O
i	long
]	O
.	O
fd	int
,	O
line	*(char)
,	O
MAXLINE	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
frominet	struct(short,array(char),long)
,	O
&	O
len	int
)	O
;	O
if	O
(	O
result	int
>	O
0	int
)	O
{	O
line	*(char)
[	O
result	int
]	O
=	O
'\0'	O
;	O
printline	(*(char),*(char))->(void)
(	O
cvthname	(*(struct(short,array(char))),int)->(*(char))
(	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
frominet	struct(short,array(char),long)
,	O
len	int
)	O
,	O
line	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
result	int
<	O
0	int
&&	O
errno	O
!=	O
EINTR	int
)	O
logerror	(*(char))->(void)
(	O
"recvfrom inet"	*(char)
)	O
;	O
}	O
else	O
{	O
struct	O
sockaddr_un	struct(short,array(char))
fromunix	struct(short,array(char))
;	O
len	int
=	O
sizeof	O
(	O
fromunix	struct(short,array(char))
)	O
;	O
result	int
=	O
recvfrom	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(long)
(	O
fdarray	*(struct(int,short,short))
[	O
i	long
]	O
.	O
fd	int
,	O
line	*(char)
,	O
MAXLINE	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
fromunix	struct(short,array(char))
,	O
&	O
len	int
)	O
;	O
if	O
(	O
result	int
>	O
0	int
)	O
{	O
line	*(char)
[	O
result	int
]	O
=	O
'\0'	O
;	O
printline	(*(char),*(char))->(void)
(	O
LocalHostName	*(char)
,	O
line	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
result	int
<	O
0	int
&&	O
errno	O
!=	O
EINTR	int
)	O
logerror	(*(char))->(void)
(	O
"recvfrom unix"	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
fdarray	*(struct(int,short,short))
[	O
i	long
]	O
.	O
revents	short
&	O
POLLNVAL	int
)	O
{	O
logerror	(*(char))->(void)
(	O
"poll nval\n"	*(char)
)	O
;	O
fdarray	*(struct(int,short,short))
[	O
i	long
]	O
.	O
fd	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
fdarray	*(struct(int,short,short))
[	O
i	long
]	O
.	O
revents	short
&	O
POLLERR	int
)	O
logerror	(*(char))->(void)
(	O
"poll err\n"	*(char)
)	O
;	O
else	O
if	O
(	O
fdarray	*(struct(int,short,short))
[	O
i	long
]	O
.	O
revents	short
&	O
POLLHUP	int
)	O
logerror	(*(char))->(void)
(	O
"poll hup\n"	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
add_funix	(*(char))->(void)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
funix	struct(*(char),int)
=	O
realloc	(*(void),long)->(*(void))
(	O
funix	struct(*(char),int)
,	O
(	O
nfunix	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
funix	struct(*(char),int)
)	O
)	O
;	O
if	O
(	O
funix	struct(*(char),int)
==	O
NULL	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot allocate space for unix sockets"	*(char)
)	O
;	O
funix	struct(*(char),int)
[	O
nfunix	long
]	O
.	O
name	*(char)
=	O
name	*(char)
;	O
funix	struct(*(char),int)
[	O
nfunix	long
]	O
.	O
fd	int
=	O
-	O
1	int
;	O
nfunix	long
++	O
;	O
}	O
static	O
int	O
create_unix_socket	(*(char))->(int)
(	O
const	O
char	O
*	O
path	*(char)
)	O
{	O
int	O
fd	int
;	O
struct	O
sockaddr_un	struct(short,array(char))
sunx	struct(short,array(char))
;	O
char	O
line	*(char)
[	O
MAXLINE	int
+	O
1	int
]	O
;	O
if	O
(	O
path	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
path	*(char)
)	O
>=	O
sizeof	O
(	O
sunx	struct(short,array(char))
.	O
sun_path	array(char)
)	O
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
line	*(char)
,	O
sizeof	O
(	O
line	*(char)
)	O
,	O
"UNIX socket name too long: %s"	*(char)
,	O
path	*(char)
)	O
;	O
logerror	(*(char))->(void)
(	O
line	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
unlink	(*(char))->(int)
(	O
path	*(char)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
sunx	struct(short,array(char))
,	O
0	int
,	O
sizeof	O
(	O
sunx	struct(short,array(char))
)	O
)	O
;	O
sunx	struct(short,array(char))
.	O
sun_family	short
=	O
AF_UNIX	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
sunx	struct(short,array(char))
.	O
sun_path	array(char)
,	O
path	*(char)
,	O
sizeof	O
(	O
sunx	struct(short,array(char))
.	O
sun_path	array(char)
)	O
-	O
1	int
)	O
;	O
fd	int
=	O
socket	(int,int,int)->(int)
(	O
AF_UNIX	O
,	O
SOCK_DGRAM	int
,	O
0	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
||	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
fd	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
sunx	struct(short,array(char))
,	O
SUN_LEN	O
(	O
&	O
sunx	struct(short,array(char))
)	O
)	O
<	O
0	int
||	O
chmod	(*(char),int)->(int)
(	O
path	*(char)
,	O
0666	int
)	O
<	O
0	int
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
line	*(char)
,	O
sizeof	O
(	O
line	*(char)
)	O
,	O
"cannot create %s"	*(char)
,	O
path	*(char)
)	O
;	O
logerror	(*(char))->(void)
(	O
line	*(char)
)	O
;	O
dbg_printf	(*(char))->(void)
(	O
"cannot create %s: %s\n"	*(char)
,	O
path	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
fd	int
=	O
-	O
1	int
;	O
}	O
return	O
fd	int
;	O
}	O
static	O
void	O
create_inet_socket	(int,array(int))->(void)
(	O
int	O
af	int
,	O
int	O
fd46	array(int)
[	O
2	int
]	O
)	O
{	O
int	O
err	long
,	O
fd	int
=	O
-	O
1	int
;	O
struct	O
addrinfo	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`))))))
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
*	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
,	O
*	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
fd46	array(int)
[	O
IU_FD_IP4	int
]	O
=	O
fd46	array(int)
[	O
IU_FD_IP6	int
]	O
=	O
-	O
1	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
0	int
,	O
sizeof	O
(	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
)	O
)	O
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_family	int
=	O
af	int
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_socktype	int
=	O
SOCK_DGRAM	int
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_flags	int
=	O
AI_PASSIVE	int
;	O
err	long
=	O
getaddrinfo	(*(char),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))),*(*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))->(int)
(	O
BindAddress	*(char)
,	O
LogPortText	*(char)
,	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
&	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
err	long
)	O
{	O
logerror	(*(char))->(void)
(	O
"lookup error, suspending inet service"	*(char)
)	O
;	O
return	O
;	O
}	O
for	O
(	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
=	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
=	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_next	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
{	O
fd	int
=	O
socket	(int,int,int)->(int)
(	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_family	int
,	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_socktype	int
,	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_protocol	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
continue	O
;	O
if	O
(	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_family	int
==	O
AF_INET6	O
)	O
{	O
int	O
yes	int
=	O
1	int
;	O
(	O
void	O
)	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
fd	int
,	O
IPPROTO_IPV6	int
,	O
IPV6_V6ONLY	int
,	O
&	O
yes	int
,	O
sizeof	O
(	O
yes	int
)	O
)	O
;	O
}	O
if	O
(	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
fd	int
,	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addr	*(struct(short,array(char)))
,	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addrlen	int
)	O
<	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
fd	int
=	O
-	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_family	int
==	O
AF_INET	O
&&	O
fd46	array(int)
[	O
IU_FD_IP4	int
]	O
<	O
0	int
)	O
fd46	array(int)
[	O
IU_FD_IP4	int
]	O
=	O
fd	int
;	O
else	O
if	O
(	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_family	int
==	O
AF_INET6	O
&&	O
fd46	array(int)
[	O
IU_FD_IP6	int
]	O
<	O
0	int
)	O
fd46	array(int)
[	O
IU_FD_IP6	int
]	O
=	O
fd	int
;	O
}	O
freeaddrinfo	(*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
fd46	array(int)
[	O
IU_FD_IP4	int
]	O
<	O
0	int
&&	O
fd46	array(int)
[	O
IU_FD_IP6	int
]	O
<	O
0	int
)	O
{	O
logerror	(*(char))->(void)
(	O
"inet service, failed lookup."	*(char)
)	O
;	O
return	O
;	O
}	O
return	O
;	O
}	O
char	O
*	O
*	O
crunch_list	(*(*(char)),*(char))->(*(*(char)))
(	O
char	O
*	O
*	O
oldlist	*(*(char))
,	O
char	O
*	O
list	*(char)
)	O
{	O
int	O
count	int
,	O
i	long
;	O
char	O
*	O
p	*(char)
,	O
*	O
q	*(char)
;	O
p	*(char)
=	O
list	*(char)
;	O
while	O
(	O
p	*(char)
[	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
-	O
1	int
]	O
==	O
LIST_DELIMITER	char
)	O
{	O
p	*(char)
[	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
while	O
(	O
p	*(char)
[	O
0	int
]	O
==	O
LIST_DELIMITER	char
)	O
{	O
p	*(char)
++	O
;	O
}	O
if	O
(	O
*	O
p	*(char)
==	O
'\0'	O
)	O
return	O
oldlist	*(*(char))
;	O
for	O
(	O
count	int
=	O
1	int
,	O
i	long
=	O
0	int
;	O
p	*(char)
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
p	*(char)
[	O
i	long
]	O
==	O
LIST_DELIMITER	char
)	O
count	int
++	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
oldlist	*(*(char))
&&	O
oldlist	*(*(char))
[	O
i	long
]	O
;	O
i	long
++	O
)	O
;	O
oldlist	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
realloc	(*(void),long)->(*(void))
(	O
oldlist	*(*(char))
,	O
(	O
i	long
+	O
count	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
oldlist	*(*(char))
)	O
)	O
;	O
if	O
(	O
oldlist	*(*(char))
==	O
NULL	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"can't allocate memory"	*(char)
)	O
;	O
for	O
(	O
count	int
=	O
i	long
;	O
(	O
q	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(char)
,	O
LIST_DELIMITER	char
)	O
)	O
!=	O
NULL	O
;	O
count	int
++	O
,	O
p	*(char)
=	O
q	*(char)
,	O
p	*(char)
++	O
)	O
{	O
oldlist	*(*(char))
[	O
count	int
]	O
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
(	O
q	*(char)
-	O
p	*(char)
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
if	O
(	O
oldlist	*(*(char))
[	O
count	int
]	O
==	O
NULL	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"can't allocate memory"	*(char)
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
oldlist	*(*(char))
[	O
count	int
]	O
,	O
p	*(char)
,	O
q	*(char)
-	O
p	*(char)
)	O
;	O
oldlist	*(*(char))
[	O
count	int
]	O
[	O
q	*(char)
-	O
p	*(char)
]	O
=	O
'\0'	O
;	O
}	O
oldlist	*(*(char))
[	O
count	int
]	O
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
(	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
if	O
(	O
oldlist	*(*(char))
[	O
count	int
]	O
==	O
NULL	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"can't allocate memory"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
oldlist	*(*(char))
[	O
count	int
]	O
,	O
p	*(char)
)	O
;	O
oldlist	*(*(char))
[	O
++	O
count	int
]	O
=	O
NULL	O
;	O
if	O
(	O
Debug	int
)	O
{	O
for	O
(	O
count	int
=	O
0	int
;	O
oldlist	*(*(char))
[	O
count	int
]	O
;	O
count	int
++	O
)	O
printf	(*(char))->(int)
(	O
"#%d: %s\n"	*(char)
,	O
count	int
,	O
oldlist	*(*(char))
[	O
count	int
]	O
)	O
;	O
}	O
return	O
oldlist	*(*(char))
;	O
}	O
void	O
printline	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
hname	*(char)
,	O
const	O
char	O
*	O
msg	*(char)
)	O
{	O
int	O
c	int
,	O
pri	int
;	O
const	O
char	O
*	O
p	*(char)
;	O
char	O
*	O
q	*(char)
,	O
line	*(char)
[	O
MAXLINE	int
+	O
1	int
]	O
;	O
pri	int
=	O
DEFUPRI	O
;	O
p	*(char)
=	O
msg	*(char)
;	O
if	O
(	O
*	O
p	*(char)
==	O
'<'	O
)	O
{	O
pri	int
=	O
0	int
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
*	O
++	O
p	*(char)
)	O
)	O
pri	int
=	O
10	int
*	O
pri	int
+	O
(	O
*	O
p	*(char)
-	O
'0'	O
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
'>'	O
)	O
++	O
p	*(char)
;	O
}	O
if	O
(	O
pri	int
&	O
~	O
(	O
LOG_FACMASK	int
|	O
LOG_PRIMASK	int
)	O
)	O
pri	int
=	O
DEFUPRI	O
;	O
if	O
(	O
LOG_FAC	O
(	O
pri	int
)	O
==	O
LOG_KERN	O
)	O
pri	int
=	O
LOG_MAKEPRI	O
(	O
LOG_USER	O
,	O
LOG_PRI	O
(	O
pri	int
)	O
)	O
;	O
q	*(char)
=	O
line	*(char)
;	O
while	O
(	O
(	O
c	int
=	O
*	O
p	*(char)
++	O
)	O
!=	O
'\0'	O
&&	O
q	*(char)
<	O
&	O
line	*(char)
[	O
sizeof	O
(	O
line	*(char)
)	O
-	O
1	int
]	O
)	O
if	O
(	O
iscntrl	(int)->(int)
(	O
c	int
)	O
)	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
*	O
q	*(char)
++	O
=	O
' '	O
;	O
else	O
if	O
(	O
c	int
==	O
'\t'	O
)	O
*	O
q	*(char)
++	O
=	O
'\t'	O
;	O
else	O
if	O
(	O
c	int
>=	O
0177	int
)	O
*	O
q	*(char)
++	O
=	O
c	int
;	O
else	O
{	O
*	O
q	*(char)
++	O
=	O
'^'	O
;	O
*	O
q	*(char)
++	O
=	O
c	int
^	O
0100	int
;	O
}	O
else	O
*	O
q	*(char)
++	O
=	O
c	int
;	O
*	O
q	*(char)
=	O
'\0'	O
;	O
if	O
(	O
force_sync	int
)	O
logmsg	(int,*(char),*(char),int)->(void)
(	O
pri	int
,	O
line	*(char)
,	O
hname	*(char)
,	O
SYNC_FILE	int
)	O
;	O
logmsg	(int,*(char),*(char),int)->(void)
(	O
pri	int
,	O
line	*(char)
,	O
hname	*(char)
,	O
0	int
)	O
;	O
}	O
void	O
printsys	(*(char))->(void)
(	O
const	O
char	O
*	O
msg	*(char)
)	O
{	O
int	O
c	int
,	O
pri	int
,	O
flags	int
;	O
char	O
*	O
lp	*(char)
,	O
*	O
q	*(char)
,	O
line	*(char)
[	O
MAXLINE	int
+	O
1	int
]	O
;	O
const	O
char	O
*	O
p	*(char)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
line	*(char)
,	O
"vmunix: "	*(char)
)	O
;	O
lp	*(char)
=	O
line	*(char)
+	O
strlen	(*(char))->(long)
(	O
line	*(char)
)	O
;	O
for	O
(	O
p	*(char)
=	O
msg	*(char)
;	O
*	O
p	*(char)
!=	O
'\0'	O
;	O
)	O
{	O
flags	int
=	O
SYNC_FILE	int
|	O
ADDDATE	int
;	O
pri	int
=	O
DEFSPRI	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
'<'	O
)	O
{	O
pri	int
=	O
0	int
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
*	O
++	O
p	*(char)
)	O
)	O
pri	int
=	O
10	int
*	O
pri	int
+	O
(	O
*	O
p	*(char)
-	O
'0'	O
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
'>'	O
)	O
++	O
p	*(char)
;	O
}	O
else	O
{	O
flags	int
|=	O
IGN_CONS	int
;	O
}	O
if	O
(	O
pri	int
&	O
~	O
(	O
LOG_FACMASK	int
|	O
LOG_PRIMASK	int
)	O
)	O
pri	int
=	O
DEFSPRI	O
;	O
q	*(char)
=	O
lp	*(char)
;	O
while	O
(	O
*	O
p	*(char)
!=	O
'\0'	O
&&	O
(	O
c	int
=	O
*	O
p	*(char)
++	O
)	O
!=	O
'\n'	O
&&	O
q	*(char)
<	O
&	O
line	*(char)
[	O
MAXLINE	int
]	O
)	O
*	O
q	*(char)
++	O
=	O
c	int
;	O
*	O
q	*(char)
=	O
'\0'	O
;	O
logmsg	(int,*(char),*(char),int)->(void)
(	O
pri	int
,	O
line	*(char)
,	O
LocalHostName	*(char)
,	O
flags	int
)	O
;	O
}	O
}	O
char	O
*	O
textpri	(int)->(*(char))
(	O
int	O
pri	int
)	O
{	O
static	O
char	O
res	array(char)
[	O
20	int
]	O
;	O
CODE	struct(*(char),int)
*	O
c_pri	*(struct(*(char),int))
,	O
*	O
c_fac	*(struct(*(char),int))
;	O
for	O
(	O
c_fac	*(struct(*(char),int))
=	O
facilitynames	array(struct(*(char),int))
;	O
c_fac	*(struct(*(char),int))
->	O
c_name	*(char)
&&	O
!	O
(	O
c_fac	*(struct(*(char),int))
->	O
c_val	int
==	O
LOG_FAC	O
(	O
pri	int
)	O
<<	O
3	int
)	O
;	O
c_fac	*(struct(*(char),int))
++	O
)	O
;	O
for	O
(	O
c_pri	*(struct(*(char),int))
=	O
prioritynames	array(struct(*(char),int))
;	O
c_pri	*(struct(*(char),int))
->	O
c_name	*(char)
&&	O
!	O
(	O
c_pri	*(struct(*(char),int))
->	O
c_val	int
==	O
LOG_PRI	O
(	O
pri	int
)	O
)	O
;	O
c_pri	*(struct(*(char),int))
++	O
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
res	array(char)
,	O
sizeof	O
(	O
res	array(char)
)	O
,	O
"%s.%s"	*(char)
,	O
c_fac	*(struct(*(char),int))
->	O
c_name	*(char)
,	O
c_pri	*(struct(*(char),int))
->	O
c_name	*(char)
)	O
;	O
return	O
res	array(char)
;	O
}	O
void	O
logmsg	(int,*(char),*(char),int)->(void)
(	O
int	O
pri	int
,	O
const	O
char	O
*	O
msg	*(char)
,	O
const	O
char	O
*	O
from	*(char)
,	O
int	O
flags	int
)	O
{	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
*	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
int	O
fac	int
,	O
msglen	int
,	O
prilev	int
;	O
sigset_t	struct(array(long))
sigs	struct(array(long))
,	O
osigs	struct(array(long))
;	O
const	O
char	O
*	O
timestamp	*(char)
;	O
dbg_printf	(*(char))->(void)
(	O
"(logmsg): %s (%d), flags %x, from %s, msg %s\n"	*(char)
,	O
textpri	(int)->(*(char))
(	O
pri	int
)	O
,	O
pri	int
,	O
flags	int
,	O
from	*(char)
,	O
msg	*(char)
)	O
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
sigs	struct(array(long))
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
sigs	struct(array(long))
,	O
SIGHUP	int
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
sigs	struct(array(long))
,	O
SIGALRM	int
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_BLOCK	int
,	O
&	O
sigs	struct(array(long))
,	O
&	O
osigs	struct(array(long))
)	O
;	O
msglen	int
=	O
strlen	(*(char))->(long)
(	O
msg	*(char)
)	O
;	O
if	O
(	O
msglen	int
<	O
16	int
||	O
msg	*(char)
[	O
3	int
]	O
!=	O
' '	O
||	O
msg	*(char)
[	O
6	int
]	O
!=	O
' '	O
||	O
msg	*(char)
[	O
9	int
]	O
!=	O
':'	O
||	O
msg	*(char)
[	O
12	int
]	O
!=	O
':'	O
||	O
msg	*(char)
[	O
15	int
]	O
!=	O
' '	O
)	O
flags	int
|=	O
ADDDATE	int
;	O
time	struct(long,long)
(	O
&	O
now	long
)	O
;	O
if	O
(	O
flags	int
&	O
ADDDATE	int
)	O
timestamp	*(char)
=	O
ctime	(*(long))->(*(char))
(	O
&	O
now	long
)	O
+	O
4	int
;	O
else	O
{	O
timestamp	*(char)
=	O
msg	*(char)
;	O
msg	*(char)
+=	O
16	int
;	O
msglen	int
-=	O
16	int
;	O
}	O
if	O
(	O
flags	int
&	O
MARK	int
)	O
fac	int
=	O
LOG_NFACILITIES	int
;	O
else	O
fac	int
=	O
LOG_FAC	O
(	O
pri	int
)	O
;	O
prilev	int
=	O
LOG_PRI	O
(	O
pri	int
)	O
;	O
if	O
(	O
!	O
Initialized	int
)	O
{	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
=	O
&	O
consfile	struct(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_file	short
=	O
open	(*(char),int)->(int)
(	O
ctty	array(char)
,	O
O_WRONLY	int
,	O
0	int
)	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevhost	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
LocalHostName	*(char)
)	O
;	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_file	short
>=	O
0	int
)	O
{	O
fprintlog	(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),*(char),int,*(char))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
from	*(char)
,	O
flags	int
,	O
msg	*(char)
)	O
;	O
close	*((*(void))->(int))
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_file	short
)	O
;	O
}	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_SETMASK	int
,	O
&	O
osigs	struct(array(long))
,	O
0	int
)	O
;	O
return	O
;	O
}	O
for	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
=	O
Files	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
=	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_next	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
{	O
if	O
(	O
!	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_pmask	array(char)
[	O
fac	int
]	O
&	O
LOG_MASK	O
(	O
prilev	int
)	O
)	O
)	O
continue	O
;	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
==	O
F_CONSOLE	int
&&	O
(	O
flags	int
&	O
IGN_CONS	int
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
flags	int
&	O
MARK	int
)	O
&&	O
(	O
now	long
-	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_time	long
)	O
<	O
MarkInterval	int
/	O
2	int
)	O
continue	O
;	O
if	O
(	O
(	O
flags	int
&	O
MARK	int
)	O
==	O
0	int
&&	O
msglen	int
==	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevlen	int
&&	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevhost	*(char)
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
msg	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevline	array(char)
)	O
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
from	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevhost	*(char)
)	O
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_lasttime	array(char)
,	O
timestamp	*(char)
,	O
sizeof	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_lasttime	array(char)
)	O
-	O
1	int
)	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevcount	int
++	O
;	O
dbg_printf	(*(char))->(void)
(	O
"msg repeated %d times, %ld sec of %d\n"	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevcount	int
,	O
now	long
-	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_time	long
,	O
repeatinterval	array(int)
[	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_repeatcount	long
]	O
)	O
;	O
if	O
(	O
now	long
>	O
REPEATTIME	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
)	O
{	O
fprintlog	(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),*(char),int,*(char))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
from	*(char)
,	O
flags	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
BACKOFF	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevcount	int
)	O
fprintlog	(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),*(char),int,*(char))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
from	*(char)
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_repeatcount	long
=	O
0	int
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_lasttime	array(char)
,	O
timestamp	*(char)
,	O
sizeof	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_lasttime	array(char)
)	O
-	O
1	int
)	O
;	O
free	(*(void))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevhost	*(char)
)	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevhost	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
from	*(char)
)	O
;	O
if	O
(	O
msglen	int
<	O
MAXSVLINE	int
)	O
{	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevlen	int
=	O
msglen	int
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevpri	int
=	O
pri	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevline	array(char)
,	O
msg	*(char)
)	O
;	O
fprintlog	(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),*(char),int,*(char))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
from	*(char)
,	O
flags	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
else	O
{	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevline	array(char)
[	O
0	int
]	O
=	O
0	int
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevlen	int
=	O
0	int
;	O
fprintlog	(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),*(char),int,*(char))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
from	*(char)
,	O
flags	int
,	O
msg	*(char)
)	O
;	O
}	O
}	O
}	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_SETMASK	int
,	O
&	O
osigs	struct(array(long))
,	O
0	int
)	O
;	O
}	O
void	O
fprintlog	(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),*(char),int,*(char))->(void)
(	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
*	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
const	O
char	O
*	O
from	*(char)
,	O
int	O
flags	int
,	O
const	O
char	O
*	O
msg	*(char)
)	O
{	O
struct	O
iovec	struct(*(void),long)
iov	array(struct(*(void),long))
[	O
IOVCNT	int
]	O
;	O
struct	O
iovec	struct(*(void),long)
*	O
v	int
;	O
int	O
l	int
;	O
char	O
line	*(char)
[	O
MAXLINE	int
+	O
1	int
]	O
,	O
repbuf	array(char)
[	O
80	int
]	O
,	O
greetings	array(char)
[	O
200	int
]	O
;	O
time_t	long
fwd_suspend	long
;	O
v	int
=	O
iov	array(struct(*(void),long))
;	O
memset	(*(void),int,long)->(*(void))
(	O
v	int
,	O
0	int
,	O
sizeof	O
(	O
struct	O
iovec	struct(*(void),long)
)	O
*	O
IOVCNT	int
)	O
;	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
==	O
F_WALL	int
)	O
{	O
v	int
->	O
iov_base	*(void)
=	O
greetings	array(char)
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
greetings	array(char)
,	O
sizeof	O
(	O
greetings	array(char)
)	O
,	O
"\r\n\7Message from syslogd@%s at %.24s ...\r\n"	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevhost	*(char)
,	O
ctime	(*(long))->(*(char))
(	O
&	O
now	long
)	O
)	O
;	O
v	int
->	O
iov_len	long
=	O
strlen	(*(char))->(long)
(	O
greetings	array(char)
)	O
;	O
v	int
++	O
;	O
v	int
->	O
iov_base	*(void)
=	O
(	O
char	O
*	O
)	O
""	*(char)
;	O
v	int
->	O
iov_len	long
=	O
0	int
;	O
v	int
++	O
;	O
}	O
else	O
{	O
v	int
->	O
iov_base	*(void)
=	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_lasttime	array(char)
;	O
v	int
->	O
iov_len	long
=	O
sizeof	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_lasttime	array(char)
)	O
-	O
1	int
;	O
v	int
++	O
;	O
v	int
->	O
iov_base	*(void)
=	O
(	O
char	O
*	O
)	O
" "	*(char)
;	O
v	int
->	O
iov_len	long
=	O
1	int
;	O
v	int
++	O
;	O
}	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevhost	*(char)
)	O
{	O
v	int
->	O
iov_base	*(void)
=	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevhost	*(char)
;	O
v	int
->	O
iov_len	long
=	O
strlen	(*(char))->(long)
(	O
v	int
->	O
iov_base	*(void)
)	O
;	O
v	int
++	O
;	O
}	O
v	int
->	O
iov_base	*(void)
=	O
(	O
char	O
*	O
)	O
" "	*(char)
;	O
v	int
->	O
iov_len	long
=	O
1	int
;	O
v	int
++	O
;	O
if	O
(	O
msg	*(char)
)	O
{	O
v	int
->	O
iov_base	*(void)
=	O
(	O
char	O
*	O
)	O
msg	*(char)
;	O
v	int
->	O
iov_len	long
=	O
strlen	(*(char))->(long)
(	O
msg	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevcount	int
>	O
1	int
)	O
{	O
v	int
->	O
iov_base	*(void)
=	O
repbuf	array(char)
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
repbuf	array(char)
,	O
sizeof	O
(	O
repbuf	array(char)
)	O
,	O
"last message repeated %d times"	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevcount	int
)	O
;	O
v	int
->	O
iov_len	long
=	O
strlen	(*(char))->(long)
(	O
repbuf	array(char)
)	O
;	O
}	O
else	O
{	O
v	int
->	O
iov_base	*(void)
=	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevline	array(char)
;	O
v	int
->	O
iov_len	long
=	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevlen	int
;	O
}	O
v	int
++	O
;	O
dbg_printf	(*(char))->(void)
(	O
"Logging to %s"	*(char)
,	O
TypeNames	array(*(char))
[	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
]	O
)	O
;	O
switch	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
)	O
{	O
case	O
F_UNUSED	int
:	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_time	long
=	O
now	long
;	O
dbg_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
break	O
;	O
case	O
F_FORW_SUSP	int
:	O
fwd_suspend	long
=	O
time	struct(long,long)
(	O
(	O
time_t	long
*	O
)	O
0	int
)	O
-	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_time	long
;	O
if	O
(	O
fwd_suspend	long
>=	O
INET_SUSPEND_TIME	int
)	O
{	O
dbg_printf	(*(char))->(void)
(	O
"\nForwarding suspension over, retrying FORW "	*(char)
)	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_FORW	int
;	O
goto	O
f_forw	struct(*(char),struct(short,array(char),long),int)
;	O
}	O
else	O
{	O
dbg_printf	(*(char))->(void)
(	O
" %s\n"	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_hname	*(char)
)	O
;	O
dbg_printf	(*(char))->(void)
(	O
"Forwarding suspension not over, time left: %d.\n"	*(char)
,	O
INET_SUSPEND_TIME	int
-	O
fwd_suspend	long
)	O
;	O
}	O
break	O
;	O
case	O
F_FORW_UNKN	int
:	O
dbg_printf	(*(char))->(void)
(	O
" %s\n"	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_hname	*(char)
)	O
;	O
fwd_suspend	long
=	O
time	struct(long,long)
(	O
(	O
time_t	long
*	O
)	O
0	int
)	O
-	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_time	long
;	O
if	O
(	O
fwd_suspend	long
>=	O
INET_SUSPEND_TIME	int
)	O
{	O
struct	O
addrinfo	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`))))))
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
*	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
int	O
err	long
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
0	int
,	O
sizeof	O
(	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
)	O
)	O
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_family	int
=	O
usefamily	int
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_flags	int
=	O
AI_ADDRCONFIG	int
;	O
err	long
=	O
getaddrinfo	(*(char),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))),*(*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))->(int)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_hname	*(char)
,	O
LogPortText	*(char)
,	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
&	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
err	long
)	O
{	O
dbg_printf	(*(char))->(void)
(	O
"Failure: %s\n"	*(char)
,	O
gai_strerror	(int)->(*(char))
(	O
err	long
)	O
)	O
;	O
dbg_printf	(*(char))->(void)
(	O
"Retries: %d\n"	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevcount	int
)	O
;	O
if	O
(	O
--	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevcount	int
<	O
0	int
)	O
{	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_UNUSED	int
;	O
free	(*(void))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_hname	*(char)
)	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_hname	*(char)
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
dbg_printf	(*(char))->(void)
(	O
"%s found, resuming.\n"	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_hname	*(char)
)	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_addrlen	int
=	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addrlen	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_addr	struct(short,array(char),long)
,	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addr	*(struct(short,array(char)))
,	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addrlen	int
)	O
;	O
freeaddrinfo	(*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevcount	int
=	O
0	int
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_FORW	int
;	O
goto	O
f_forw	struct(*(char),struct(short,array(char),long),int)
;	O
}	O
}	O
else	O
dbg_printf	(*(char))->(void)
(	O
"Forwarding suspension not over, time left: %d\n"	*(char)
,	O
INET_SUSPEND_TIME	int
-	O
fwd_suspend	long
)	O
;	O
break	O
;	O
case	O
F_FORW	int
:	O
f_forw	struct(*(char),struct(short,array(char),long),int)
:	O
dbg_printf	(*(char))->(void)
(	O
" %s\n"	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_hname	*(char)
)	O
;	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
from	*(char)
,	O
LocalHostName	*(char)
)	O
&&	O
NoHops	int
)	O
dbg_printf	(*(char))->(void)
(	O
"Not forwarding remote message.\n"	*(char)
)	O
;	O
else	O
if	O
(	O
NoForward	int
)	O
dbg_printf	(*(char))->(void)
(	O
"Not forwarding because forwarding is disabled.\n"	*(char)
)	O
;	O
else	O
{	O
int	O
temp_finet	int
,	O
*	O
pfinet	*(int)
;	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_addr	struct(short,array(char),long)
.	O
ss_family	short
==	O
AF_INET	O
)	O
pfinet	*(int)
=	O
&	O
finet	array(int)
[	O
IU_FD_IP4	int
]	O
;	O
else	O
pfinet	*(int)
=	O
&	O
finet	array(int)
[	O
IU_FD_IP6	int
]	O
;	O
temp_finet	int
=	O
*	O
pfinet	*(int)
;	O
if	O
(	O
temp_finet	int
<	O
0	int
)	O
{	O
int	O
err	long
;	O
struct	O
addrinfo	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`))))))
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
*	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
0	int
,	O
sizeof	O
(	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
)	O
)	O
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_family	int
=	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_addr	struct(short,array(char),long)
.	O
ss_family	short
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_socktype	int
=	O
SOCK_DGRAM	int
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_flags	int
=	O
AI_PASSIVE	int
;	O
err	long
=	O
getaddrinfo	(*(char),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))),*(*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))->(int)
(	O
NULL	O
,	O
LogPortText	*(char)
,	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
&	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
err	long
)	O
{	O
dbg_printf	(*(char))->(void)
(	O
"Not forwarding due to lookup failure: %s.\n"	*(char)
,	O
gai_strerror	(int)->(*(char))
(	O
err	long
)	O
)	O
;	O
break	O
;	O
}	O
temp_finet	int
=	O
socket	(int,int,int)->(int)
(	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_family	int
,	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_socktype	int
,	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_protocol	int
)	O
;	O
if	O
(	O
temp_finet	int
<	O
0	int
)	O
{	O
dbg_printf	(*(char))->(void)
(	O
"Not forwarding due to socket failure.\n"	*(char)
)	O
;	O
freeaddrinfo	(*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
break	O
;	O
}	O
err	long
=	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
temp_finet	int
,	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addr	*(struct(short,array(char)))
,	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addrlen	int
)	O
;	O
freeaddrinfo	(*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
err	long
)	O
{	O
dbg_printf	(*(char))->(void)
(	O
"Not forwarding due to bind error: %s.\n"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
break	O
;	O
}	O
}	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_time	long
=	O
now	long
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
line	*(char)
,	O
sizeof	O
(	O
line	*(char)
)	O
,	O
"<%d>%.15s %s"	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevpri	int
,	O
(	O
char	O
*	O
)	O
iov	array(struct(*(void),long))
[	O
0	int
]	O
.	O
iov_base	*(void)
,	O
(	O
char	O
*	O
)	O
iov	array(struct(*(void),long))
[	O
4	int
]	O
.	O
iov_base	*(void)
)	O
;	O
l	int
=	O
strlen	(*(char))->(long)
(	O
line	*(char)
)	O
;	O
if	O
(	O
l	int
>	O
MAXLINE	int
)	O
l	int
=	O
MAXLINE	int
;	O
if	O
(	O
sendto	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(long)
(	O
temp_finet	int
,	O
line	*(char)
,	O
l	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_addr	struct(short,array(char),long)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_addrlen	int
)	O
!=	O
l	int
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
dbg_printf	(*(char))->(void)
(	O
"INET sendto error: %d = %s.\n"	*(char)
,	O
e	int
,	O
strerror	(int)->(*(char))
(	O
e	int
)	O
)	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_FORW_SUSP	int
;	O
errno	O
=	O
e	int
;	O
logerror	(*(char))->(void)
(	O
"sendto"	*(char)
)	O
;	O
}	O
if	O
(	O
*	O
pfinet	*(int)
<	O
0	int
)	O
close	*((*(void))->(int))
(	O
temp_finet	int
)	O
;	O
}	O
break	O
;	O
case	O
F_CONSOLE	int
:	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_time	long
=	O
now	long
;	O
if	O
(	O
flags	int
&	O
IGN_CONS	int
)	O
{	O
dbg_printf	(*(char))->(void)
(	O
" (ignored)\n"	*(char)
)	O
;	O
break	O
;	O
}	O
case	O
F_TTY	int
:	O
case	O
F_FILE	int
:	O
case	O
F_PIPE	int
:	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_time	long
=	O
now	long
;	O
dbg_printf	(*(char))->(void)
(	O
" %s\n"	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
)	O
;	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
==	O
F_TTY	int
||	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
==	O
F_CONSOLE	int
)	O
{	O
v	int
->	O
iov_base	*(void)
=	O
(	O
char	O
*	O
)	O
"\r\n"	*(char)
;	O
v	int
->	O
iov_len	long
=	O
2	int
;	O
}	O
else	O
{	O
v	int
->	O
iov_base	*(void)
=	O
(	O
char	O
*	O
)	O
"\n"	*(char)
;	O
v	int
->	O
iov_len	long
=	O
1	int
;	O
}	O
again	O
:	O
if	O
(	O
writev	(int,*(struct(*(void),long)),int)->(long)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_file	short
,	O
iov	array(struct(*(void),long))
,	O
IOVCNT	int
)	O
<	O
0	int
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
==	O
F_PIPE	int
&&	O
e	int
==	O
EAGAIN	int
)	O
break	O
;	O
close	*((*(void))->(int))
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_file	short
)	O
;	O
if	O
(	O
(	O
e	int
==	O
EIO	int
||	O
e	int
==	O
EBADF	int
)	O
&&	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
==	O
F_TTY	int
||	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
==	O
F_CONSOLE	int
)	O
)	O
{	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_file	short
=	O
open	(*(char),int)->(int)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
,	O
O_WRONLY	int
|	O
O_APPEND	int
,	O
0	int
)	O
;	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_file	short
<	O
0	int
)	O
{	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_UNUSED	int
;	O
logerror	(*(char))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
)	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
=	O
NULL	O
;	O
}	O
else	O
goto	O
again	O
;	O
}	O
else	O
{	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_UNUSED	int
;	O
errno	O
=	O
e	int
;	O
logerror	(*(char))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
)	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
=	O
NULL	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
flags	int
&	O
SYNC_FILE	int
)	O
&&	O
!	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_flags	int
&	O
OMIT_SYNC	int
)	O
)	O
fsync	(int)->(int)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_file	short
)	O
;	O
break	O
;	O
case	O
F_USERS	int
:	O
case	O
F_WALL	int
:	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_time	long
=	O
now	long
;	O
dbg_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
v	int
->	O
iov_base	*(void)
=	O
(	O
char	O
*	O
)	O
"\r\n"	*(char)
;	O
v	int
->	O
iov_len	long
=	O
2	int
;	O
wallmsg	(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),*(struct(*(void),long)))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
iov	array(struct(*(void),long))
)	O
;	O
break	O
;	O
}	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
!=	O
F_FORW_UNKN	int
)	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevcount	int
=	O
0	int
;	O
}	O
void	O
wallmsg	(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),*(struct(*(void),long)))->(void)
(	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
*	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
struct	O
iovec	struct(*(void),long)
*	O
iov	array(struct(*(void),long))
)	O
{	O
static	O
int	O
reenter	int
;	O
STRUCT_UTMP	struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char))
*	O
utmpbuf	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
,	O
*	O
utp	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
;	O
size_t	long
utmp_count	long
;	O
int	O
i	long
;	O
char	O
*	O
p	*(char)
;	O
char	O
line	*(char)
[	O
sizeof	O
(	O
utp	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
->	O
ut_line	array(char)
)	O
+	O
1	int
]	O
;	O
if	O
(	O
reenter	int
++	O
)	O
return	O
;	O
read_utmp	(*(char),*(long),*(*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))),int)->(int)
(	O
PATH_UTMP	O
,	O
&	O
utmp_count	long
,	O
&	O
utmpbuf	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
,	O
READ_UTMP_USER_PROCESS	int
|	O
READ_UTMP_CHECK_PIDS	int
)	O
;	O
for	O
(	O
utp	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
=	O
utmpbuf	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
;	O
utp	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
<	O
utmpbuf	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
+	O
utmp_count	long
;	O
utp	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
++	O
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
line	*(char)
,	O
utp	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
->	O
ut_line	array(char)
,	O
sizeof	O
(	O
utp	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
->	O
ut_line	array(char)
)	O
)	O
;	O
line	*(char)
[	O
sizeof	O
(	O
utp	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
->	O
ut_line	array(char)
)	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
==	O
F_WALL	int
)	O
{	O
p	*(char)
=	O
ttymsg	(*(struct(*(void),long)),int,*(char),int)->(*(char))
(	O
iov	array(struct(*(void),long))
,	O
IOVCNT	int
,	O
line	*(char)
,	O
TTYMSGTIME	int
)	O
;	O
if	O
(	O
p	*(char)
!=	O
NULL	O
)	O
{	O
errno	O
=	O
0	int
;	O
logerror	(*(char))->(void)
(	O
p	*(char)
)	O
;	O
}	O
continue	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_user	struct(int,*(*(char)))
.	O
f_nusers	int
;	O
i	long
++	O
)	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_user	struct(int,*(*(char)))
.	O
f_unames	*(*(char))
[	O
i	long
]	O
,	O
UT_USER	O
(	O
utp	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
)	O
,	O
sizeof	O
(	O
UT_USER	O
(	O
utp	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
)	O
)	O
)	O
)	O
{	O
p	*(char)
=	O
ttymsg	(*(struct(*(void),long)),int,*(char),int)->(*(char))
(	O
iov	array(struct(*(void),long))
,	O
IOVCNT	int
,	O
line	*(char)
,	O
TTYMSGTIME	int
)	O
;	O
if	O
(	O
p	*(char)
!=	O
NULL	O
)	O
{	O
errno	O
=	O
0	int
;	O
logerror	(*(char))->(void)
(	O
p	*(char)
)	O
;	O
}	O
break	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
utmpbuf	*(struct(short,int,array(char),array(char),array(char),array(char),struct(short,short),int,struct(int,int),array(int),array(char)))
)	O
;	O
reenter	int
=	O
0	int
;	O
}	O
const	O
char	O
*	O
cvthname	(*(struct(short,array(char))),int)->(*(char))
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
socklen_t	int
len	int
)	O
{	O
int	O
err	long
;	O
char	O
*	O
p	*(char)
;	O
err	long
=	O
getnameinfo	(*(struct(short,array(char))),int,*(char),int,*(char),int,int)->(int)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
len	int
,	O
addrstr	array(char)
,	O
sizeof	O
(	O
addrstr	array(char)
)	O
,	O
NULL	O
,	O
0	int
,	O
NI_NUMERICHOST	int
)	O
;	O
if	O
(	O
err	long
)	O
{	O
dbg_printf	(*(char))->(void)
(	O
"Malformed from address: %s.\n"	*(char)
,	O
gai_strerror	(int)->(*(char))
(	O
err	long
)	O
)	O
;	O
return	O
"???"	*(char)
;	O
}	O
dbg_printf	(*(char))->(void)
(	O
"cvthname(%s)\n"	*(char)
,	O
addrstr	array(char)
)	O
;	O
err	long
=	O
getnameinfo	(*(struct(short,array(char))),int,*(char),int,*(char),int,int)->(int)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
len	int
,	O
addrname	array(char)
,	O
sizeof	O
(	O
addrname	array(char)
)	O
,	O
NULL	O
,	O
0	int
,	O
NI_NAMEREQD	int
)	O
;	O
if	O
(	O
err	long
)	O
{	O
dbg_printf	(*(char))->(void)
(	O
"Host name for your address (%s) unknown.\n"	*(char)
,	O
addrstr	array(char)
)	O
;	O
return	O
addrstr	array(char)
;	O
}	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
addrname	array(char)
,	O
'.'	O
)	O
;	O
if	O
(	O
p	*(char)
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
p	*(char)
+	O
1	int
,	O
LocalDomain	*(char)
)	O
==	O
0	int
)	O
*	O
p	*(char)
=	O
'\0'	O
;	O
else	O
{	O
int	O
count	int
;	O
if	O
(	O
StripDomains	*(*(char))
)	O
{	O
count	int
=	O
0	int
;	O
while	O
(	O
StripDomains	*(*(char))
[	O
count	int
]	O
)	O
{	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
p	*(char)
+	O
1	int
,	O
StripDomains	*(*(char))
[	O
count	int
]	O
)	O
==	O
0	int
)	O
{	O
*	O
p	*(char)
=	O
'\0'	O
;	O
return	O
addrname	array(char)
;	O
}	O
count	int
++	O
;	O
}	O
}	O
if	O
(	O
LocalHosts	*(*(char))
)	O
{	O
count	int
=	O
0	int
;	O
while	O
(	O
LocalHosts	*(*(char))
[	O
count	int
]	O
)	O
{	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
addrname	array(char)
,	O
LocalHosts	*(*(char))
[	O
count	int
]	O
)	O
==	O
0	int
)	O
{	O
*	O
p	*(char)
=	O
'\0'	O
;	O
return	O
addrname	array(char)
;	O
}	O
count	int
++	O
;	O
}	O
}	O
}	O
}	O
return	O
addrname	array(char)
;	O
}	O
void	O
domark	(int)->(void)
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
*	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
now	long
=	O
time	struct(long,long)
(	O
(	O
time_t	long
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
MarkInterval	int
>	O
0	int
)	O
{	O
MarkSeq	int
+=	O
TIMERINTVL	int
;	O
if	O
(	O
MarkSeq	int
>=	O
MarkInterval	int
)	O
{	O
logmsg	(int,*(char),*(char),int)->(void)
(	O
LOG_INFO	int
,	O
"-- MARK --"	*(char)
,	O
LocalHostName	*(char)
,	O
ADDDATE	int
|	O
MARK	int
)	O
;	O
MarkSeq	int
=	O
0	int
;	O
}	O
}	O
for	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
=	O
Files	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
=	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_next	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
{	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevcount	int
&&	O
now	long
>=	O
REPEATTIME	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
)	O
{	O
dbg_printf	(*(char))->(void)
(	O
"flush %s: repeated %d times, %d sec.\n"	*(char)
,	O
TypeNames	array(*(char))
[	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
]	O
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevcount	int
,	O
repeatinterval	array(int)
[	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_repeatcount	long
]	O
)	O
;	O
fprintlog	(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),*(char),int,*(char))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
LocalHostName	*(char)
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
BACKOFF	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
;	O
}	O
}	O
alarm	(int)->(int)
(	O
TIMERINTVL	int
)	O
;	O
}	O
void	O
logerror	(*(char))->(void)
(	O
const	O
char	O
*	O
type	enum(int,int,int,int)
)	O
{	O
char	O
buf	array(char)
[	O
100	int
]	O
;	O
if	O
(	O
errno	O
)	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	array(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
,	O
"syslogd: %s: %s"	*(char)
,	O
type	enum(int,int,int,int)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
else	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	array(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
,	O
"syslogd: %s"	*(char)
,	O
type	enum(int,int,int,int)
)	O
;	O
errno	O
=	O
0	int
;	O
dbg_printf	(*(char))->(void)
(	O
"%s\n"	*(char)
,	O
buf	array(char)
)	O
;	O
logmsg	(int,*(char),*(char),int)->(void)
(	O
LOG_SYSLOG	O
|	O
LOG_ERR	int
,	O
buf	array(char)
,	O
LocalHostName	*(char)
,	O
ADDDATE	int
)	O
;	O
}	O
void	O
doexit	(int)->(void)
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
_exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
void	O
die	(int)->(void)
(	O
int	O
signo	int
)	O
{	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
*	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
int	O
was_initialized	int
=	O
Initialized	int
;	O
char	O
buf	array(char)
[	O
100	int
]	O
;	O
size_t	long
i	long
;	O
Initialized	int
=	O
0	int
;	O
for	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
=	O
Files	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
!=	O
NULL	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
=	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_next	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
{	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevcount	int
)	O
fprintlog	(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),*(char),int,*(char))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
LocalHostName	*(char)
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
Initialized	int
=	O
was_initialized	int
;	O
if	O
(	O
signo	int
)	O
{	O
dbg_printf	(*(char))->(void)
(	O
"%s: exiting on signal %d\n"	*(char)
,	O
program_invocation_name	*(char)
,	O
signo	int
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	array(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
,	O
"exiting on signal %d"	*(char)
,	O
signo	int
)	O
;	O
errno	O
=	O
0	int
;	O
logerror	(*(char))->(void)
(	O
buf	array(char)
)	O
;	O
}	O
if	O
(	O
fklog	int
>=	O
0	int
)	O
close	*((*(void))->(int))
(	O
fklog	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nfunix	long
;	O
i	long
++	O
)	O
if	O
(	O
funix	struct(*(char),int)
[	O
i	long
]	O
.	O
fd	int
>=	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
funix	struct(*(char),int)
[	O
i	long
]	O
.	O
fd	int
)	O
;	O
if	O
(	O
funix	struct(*(char),int)
[	O
i	long
]	O
.	O
name	*(char)
)	O
unlink	(*(char))->(int)
(	O
funix	struct(*(char),int)
[	O
i	long
]	O
.	O
name	*(char)
)	O
;	O
}	O
if	O
(	O
finet	array(int)
[	O
IU_FD_IP4	int
]	O
>=	O
0	int
)	O
close	*((*(void))->(int))
(	O
finet	array(int)
[	O
IU_FD_IP4	int
]	O
)	O
;	O
if	O
(	O
finet	array(int)
[	O
IU_FD_IP6	int
]	O
>=	O
0	int
)	O
close	*((*(void))->(int))
(	O
finet	array(int)
[	O
IU_FD_IP6	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
void	O
init	(int)->(void)
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
FILE	struct
*	O
cf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
*	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
*	O
next	int
,	O
*	O
*	O
nextp	*(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)))
;	O
char	O
*	O
p	*(char)
;	O
size_t	long
line_max	long
=	O
LINE_MAX	O
;	O
char	O
*	O
cbuf	*(char)
;	O
char	O
*	O
cline	*(char)
;	O
int	O
cont_line	int
=	O
0	int
;	O
dbg_printf	(*(char))->(void)
(	O
"init\n"	*(char)
)	O
;	O
Initialized	int
=	O
0	int
;	O
for	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
=	O
Files	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
!=	O
NULL	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
=	O
next	int
)	O
{	O
int	O
j	int
;	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevcount	int
)	O
fprintlog	(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),*(char),int,*(char))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
LocalHostName	*(char)
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
switch	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
)	O
{	O
case	O
F_FILE	int
:	O
case	O
F_TTY	int
:	O
case	O
F_CONSOLE	int
:	O
case	O
F_PIPE	int
:	O
free	(*(void))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
)	O
;	O
close	*((*(void))->(int))
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_file	short
)	O
;	O
break	O
;	O
case	O
F_FORW	int
:	O
case	O
F_FORW_SUSP	int
:	O
case	O
F_FORW_UNKN	int
:	O
free	(*(void))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_hname	*(char)
)	O
;	O
break	O
;	O
case	O
F_USERS	int
:	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_user	struct(int,*(*(char)))
.	O
f_nusers	int
;	O
++	O
j	int
)	O
free	(*(void))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_user	struct(int,*(*(char)))
.	O
f_unames	*(*(char))
[	O
j	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_user	struct(int,*(*(char)))
.	O
f_unames	*(*(char))
)	O
;	O
break	O
;	O
}	O
free	(*(void))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevhost	*(char)
)	O
;	O
next	int
=	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_next	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
free	(*(void))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
;	O
}	O
Files	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
=	O
NULL	O
;	O
nextp	*(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)))
=	O
&	O
Files	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
facilities_seen	int
=	O
0	int
;	O
cf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
ConfFile	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
cf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
dbg_printf	(*(char))->(void)
(	O
"cannot open %s\n"	*(char)
,	O
ConfFile	*(char)
)	O
;	O
*	O
nextp	*(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)))
=	O
(	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
*	O
)	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
)	O
;	O
cfline	(*(char),*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)))->(void)
(	O
"*.ERR\t"	*(char)
PATH_CONSOLE	O
,	O
*	O
nextp	*(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)))
)	O
;	O
(	O
*	O
nextp	*(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)))
)	O
->	O
f_next	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
=	O
(	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
*	O
)	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
)	O
;	O
cfline	(*(char),*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)))->(void)
(	O
"*.PANIC\t*"	*(char)
,	O
(	O
*	O
nextp	*(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)))
)	O
->	O
f_next	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
;	O
Initialized	int
=	O
1	int
;	O
return	O
;	O
}	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
=	O
NULL	O
;	O
cbuf	*(char)
=	O
malloc	(long)->(*(void))
(	O
line_max	long
)	O
;	O
if	O
(	O
cbuf	*(char)
==	O
NULL	O
)	O
{	O
dbg_printf	(*(char))->(void)
(	O
"cannot allocate space for configuration\n"	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
cf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
;	O
}	O
cline	*(char)
=	O
cbuf	*(char)
;	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
cline	*(char)
,	O
line_max	long
-	O
(	O
cline	*(char)
-	O
cbuf	*(char)
)	O
,	O
cf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
NULL	O
)	O
{	O
size_t	long
len	int
=	O
strlen	(*(char))->(long)
(	O
cline	*(char)
)	O
;	O
if	O
(	O
cont_line	int
)	O
{	O
char	O
*	O
start	*(char)
=	O
cline	*(char)
;	O
while	O
(	O
*	O
start	*(char)
==	O
' '	O
||	O
*	O
start	*(char)
==	O
'\t'	O
)	O
start	*(char)
++	O
;	O
len	int
=	O
len	int
-	O
(	O
start	*(char)
-	O
cline	*(char)
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
cline	*(char)
,	O
start	*(char)
,	O
len	int
+	O
1	int
)	O
;	O
cont_line	int
=	O
0	int
;	O
}	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
cline	*(char)
,	O
'\n'	O
)	O
==	O
NULL	O
)	O
{	O
size_t	long
offset	long
=	O
cline	*(char)
-	O
cbuf	*(char)
;	O
char	O
*	O
tmp	*(char)
;	O
tmp	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
cbuf	*(char)
,	O
line_max	long
*	O
2	int
)	O
;	O
if	O
(	O
tmp	*(char)
==	O
NULL	O
)	O
{	O
dbg_printf	(*(char))->(void)
(	O
"cannot allocate space configuration\n"	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
cf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
cbuf	*(char)
)	O
;	O
return	O
;	O
}	O
else	O
cbuf	*(char)
=	O
tmp	*(char)
;	O
line_max	long
*=	O
2	int
;	O
cline	*(char)
=	O
cbuf	*(char)
+	O
offset	long
+	O
len	int
-	O
1	int
;	O
continue	O
;	O
}	O
else	O
cline	*(char)
=	O
cbuf	*(char)
;	O
for	O
(	O
p	*(char)
=	O
cline	*(char)
;	O
isspace	(int)->(int)
(	O
*	O
p	*(char)
)	O
;	O
++	O
p	*(char)
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
'\0'	O
||	O
*	O
p	*(char)
==	O
'#'	O
)	O
continue	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
cline	*(char)
,	O
p	*(char)
)	O
;	O
for	O
(	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
cline	*(char)
,	O
'\0'	O
)	O
;	O
isspace	(int)->(int)
(	O
*	O
--	O
p	*(char)
)	O
;	O
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
'\\'	O
)	O
{	O
*	O
p	*(char)
=	O
'\0'	O
;	O
cline	*(char)
=	O
p	*(char)
;	O
cont_line	int
=	O
1	int
;	O
continue	O
;	O
}	O
*	O
++	O
p	*(char)
=	O
'\0'	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
=	O
(	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
*	O
)	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
)	O
;	O
*	O
nextp	*(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)))
=	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
nextp	*(*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)))
=	O
&	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_next	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
cfline	(*(char),*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)))->(void)
(	O
cbuf	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
cf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
cbuf	*(char)
)	O
;	O
Initialized	int
=	O
1	int
;	O
if	O
(	O
Debug	int
)	O
{	O
for	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
=	O
Files	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
=	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_next	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
LOG_NFACILITIES	int
;	O
i	long
++	O
)	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_pmask	array(char)
[	O
i	long
]	O
==	O
0	int
)	O
dbg_printf	(*(char))->(void)
(	O
" X "	*(char)
)	O
;	O
else	O
dbg_printf	(*(char))->(void)
(	O
"%2x "	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_pmask	array(char)
[	O
i	long
]	O
)	O
;	O
dbg_printf	(*(char))->(void)
(	O
"%s: "	*(char)
,	O
TypeNames	array(*(char))
[	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
]	O
)	O
;	O
switch	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
)	O
{	O
case	O
F_FILE	int
:	O
case	O
F_TTY	int
:	O
case	O
F_CONSOLE	int
:	O
case	O
F_PIPE	int
:	O
dbg_printf	(*(char))->(void)
(	O
"%s"	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
)	O
;	O
break	O
;	O
case	O
F_FORW	int
:	O
case	O
F_FORW_SUSP	int
:	O
case	O
F_FORW_UNKN	int
:	O
dbg_printf	(*(char))->(void)
(	O
"%s"	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_hname	*(char)
)	O
;	O
break	O
;	O
case	O
F_USERS	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_user	struct(int,*(*(char)))
.	O
f_nusers	int
;	O
i	long
++	O
)	O
dbg_printf	(*(char))->(void)
(	O
"%s, "	*(char)
,	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_user	struct(int,*(*(char)))
.	O
f_unames	*(*(char))
[	O
i	long
]	O
)	O
;	O
break	O
;	O
}	O
dbg_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
AcceptRemote	int
)	O
logmsg	(int,*(char),*(char),int)->(void)
(	O
LOG_SYSLOG	O
|	O
LOG_INFO	int
,	O
"syslogd ("	*(char)
PACKAGE_NAME	*(char)
" "	*(char)
PACKAGE_VERSION	*(char)
"): restart (remote reception)"	*(char)
,	O
LocalHostName	*(char)
,	O
ADDDATE	int
)	O
;	O
else	O
logmsg	(int,*(char),*(char),int)->(void)
(	O
LOG_SYSLOG	O
|	O
LOG_INFO	int
,	O
"syslogd ("	*(char)
PACKAGE_NAME	*(char)
" "	*(char)
PACKAGE_VERSION	*(char)
"): restart"	*(char)
,	O
LocalHostName	*(char)
,	O
ADDDATE	int
)	O
;	O
dbg_printf	(*(char))->(void)
(	O
"syslogd: restarted\n"	*(char)
)	O
;	O
}	O
void	O
cfline	(*(char),*(struct(*(struct(*`,short,short,long,array(char),union`,array(char),array(char),*`,int,int,int,long,int)),short,short,long,array(char),union(struct(int,*`),struct(*`,struct`,int),*(char)),array(char),array(char),*(char),int,int,int,long,int)))->(void)
(	O
const	O
char	O
*	O
line	*(char)
,	O
struct	O
filed	struct(*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int)
*	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
{	O
struct	O
addrinfo	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`))))))
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
*	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
int	O
i	long
,	O
pri	int
,	O
negate_pri	int
,	O
excl_pri	int
,	O
err	long
;	O
unsigned	O
int	O
pri_set	int
,	O
pri_clear	int
;	O
char	O
*	O
bp	*(char)
;	O
const	O
char	O
*	O
p	*(char)
,	O
*	O
q	*(char)
;	O
char	O
buf	array(char)
[	O
MAXLINE	int
]	O
,	O
ebuf	array(char)
[	O
200	int
]	O
;	O
dbg_printf	(*(char))->(void)
(	O
"cfline(%s)\n"	*(char)
,	O
line	*(char)
)	O
;	O
errno	O
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
,	O
0	int
,	O
sizeof	O
(	O
*	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
LOG_NFACILITIES	int
;	O
i	long
++	O
)	O
{	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_pmask	array(char)
[	O
i	long
]	O
=	O
0	int
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_flags	int
=	O
0	int
;	O
}	O
for	O
(	O
p	*(char)
=	O
line	*(char)
;	O
*	O
p	*(char)
&&	O
*	O
p	*(char)
!=	O
'\t'	O
&&	O
*	O
p	*(char)
!=	O
' '	O
;	O
)	O
{	O
for	O
(	O
q	*(char)
=	O
p	*(char)
;	O
*	O
q	*(char)
&&	O
*	O
q	*(char)
!=	O
'\t'	O
&&	O
*	O
q	*(char)
++	O
!=	O
'.'	O
;	O
)	O
continue	O
;	O
for	O
(	O
bp	*(char)
=	O
buf	array(char)
;	O
*	O
q	*(char)
&&	O
!	O
strchr	(*(char),int)->(*(char))
(	O
"\t ,;"	*(char)
,	O
*	O
q	*(char)
)	O
;	O
)	O
*	O
bp	*(char)
++	O
=	O
*	O
q	*(char)
++	O
;	O
*	O
bp	*(char)
=	O
'\0'	O
;	O
while	O
(	O
*	O
q	*(char)
&&	O
strchr	(*(char),int)->(*(char))
(	O
",;"	*(char)
,	O
*	O
q	*(char)
)	O
)	O
q	*(char)
++	O
;	O
bp	*(char)
=	O
buf	array(char)
;	O
negate_pri	int
=	O
excl_pri	int
=	O
0	int
;	O
while	O
(	O
*	O
bp	*(char)
==	O
'!'	O
||	O
*	O
bp	*(char)
==	O
'='	O
)	O
switch	O
(	O
*	O
bp	*(char)
++	O
)	O
{	O
case	O
'!'	O
:	O
negate_pri	int
=	O
1	int
;	O
break	O
;	O
case	O
'='	O
:	O
excl_pri	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
*	O
bp	*(char)
==	O
'*'	O
)	O
{	O
pri_clear	int
=	O
0	int
;	O
pri_set	int
=	O
LOG_UPTO	O
(	O
LOG_PRIMASK	int
)	O
;	O
}	O
else	O
{	O
pri	int
=	O
decode	(*(char),*(struct(*(char),int)))->(int)
(	O
bp	*(char)
,	O
prioritynames	array(struct(*(char),int))
)	O
;	O
if	O
(	O
pri	int
<	O
0	int
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
ebuf	array(char)
,	O
sizeof	O
(	O
ebuf	array(char)
)	O
,	O
"unknown priority name \"%s\""	*(char)
,	O
bp	*(char)
)	O
;	O
logerror	(*(char))->(void)
(	O
ebuf	array(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
pri	int
==	O
INTERNAL_NOPRI	int
)	O
{	O
pri_clear	int
=	O
255	int
;	O
pri_set	int
=	O
0	int
;	O
}	O
else	O
{	O
pri_clear	int
=	O
0	int
;	O
pri_set	int
=	O
excl_pri	int
?	O
LOG_MASK	O
(	O
pri	int
)	O
:	O
LOG_UPTO	O
(	O
pri	int
)	O
;	O
}	O
}	O
if	O
(	O
negate_pri	int
)	O
{	O
unsigned	O
int	O
exchange	int
=	O
pri_set	int
;	O
pri_set	int
=	O
pri_clear	int
;	O
pri_clear	int
=	O
exchange	int
;	O
}	O
while	O
(	O
*	O
p	*(char)
&&	O
!	O
strchr	(*(char),int)->(*(char))
(	O
"\t .;"	*(char)
,	O
*	O
p	*(char)
)	O
)	O
{	O
for	O
(	O
bp	*(char)
=	O
buf	array(char)
;	O
*	O
p	*(char)
&&	O
!	O
strchr	(*(char),int)->(*(char))
(	O
"\t ,;."	*(char)
,	O
*	O
p	*(char)
)	O
;	O
)	O
*	O
bp	*(char)
++	O
=	O
*	O
p	*(char)
++	O
;	O
*	O
bp	*(char)
=	O
'\0'	O
;	O
if	O
(	O
*	O
buf	array(char)
==	O
'*'	O
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
LOG_NFACILITIES	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
buf	array(char)
[	O
1	int
]	O
==	O
'*'	O
&&	O
(	O
(	O
1	int
<<	O
i	long
)	O
&	O
facilities_seen	int
)	O
)	O
continue	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_pmask	array(char)
[	O
i	long
]	O
&=	O
~	O
pri_clear	int
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_pmask	array(char)
[	O
i	long
]	O
|=	O
pri_set	int
;	O
}	O
else	O
{	O
i	long
=	O
decode	(*(char),*(struct(*(char),int)))->(int)
(	O
buf	array(char)
,	O
facilitynames	array(struct(*(char),int))
)	O
;	O
facilities_seen	int
|=	O
(	O
1	int
<<	O
LOG_FAC	O
(	O
i	long
)	O
)	O
;	O
if	O
(	O
i	long
<	O
0	int
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
ebuf	array(char)
,	O
sizeof	O
(	O
ebuf	array(char)
)	O
,	O
"unknown facility name \"%s\""	*(char)
,	O
buf	array(char)
)	O
;	O
logerror	(*(char))->(void)
(	O
ebuf	array(char)
)	O
;	O
return	O
;	O
}	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_pmask	array(char)
[	O
LOG_FAC	O
(	O
i	long
)	O
]	O
&=	O
~	O
pri_clear	int
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_pmask	array(char)
[	O
LOG_FAC	O
(	O
i	long
)	O
]	O
|=	O
pri_set	int
;	O
}	O
while	O
(	O
*	O
p	*(char)
==	O
','	O
||	O
*	O
p	*(char)
==	O
' '	O
)	O
p	*(char)
++	O
;	O
}	O
p	*(char)
=	O
q	*(char)
;	O
}	O
while	O
(	O
*	O
p	*(char)
==	O
'\t'	O
||	O
*	O
p	*(char)
==	O
' '	O
)	O
p	*(char)
++	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
'-'	O
)	O
{	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_flags	int
|=	O
OMIT_SYNC	int
;	O
p	*(char)
++	O
;	O
}	O
if	O
(	O
!	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
)	O
{	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_UNUSED	int
;	O
logerror	(*(char))->(void)
(	O
"empty action field"	*(char)
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
*	O
p	*(char)
)	O
{	O
case	O
'@'	O
:	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_hname	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
++	O
p	*(char)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
0	int
,	O
sizeof	O
(	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
)	O
)	O
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_family	int
=	O
usefamily	int
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_socktype	int
=	O
SOCK_DGRAM	int
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_flags	int
=	O
AI_ADDRCONFIG	int
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_addrlen	int
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_addr	struct(short,array(char),long)
,	O
0	int
,	O
sizeof	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_addr	struct(short,array(char),long)
)	O
)	O
;	O
err	long
=	O
getaddrinfo	(*(char),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))),*(*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))->(int)
(	O
p	*(char)
,	O
LogPortText	*(char)
,	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
&	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
err	long
)	O
{	O
switch	O
(	O
err	long
)	O
{	O
case	O
EAI_AGAIN	O
:	O
case	O
EAI_MEMORY	O
:	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_FORW_UNKN	int
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_prevcount	int
=	O
INET_RETRY_MAX	int
;	O
break	O
;	O
case	O
EAI_NONAME	O
:	O
case	O
EAI_NODATA	O
:	O
case	O
EAI_ADDRFAMILY	O
:	O
default	O
:	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_UNUSED	int
;	O
}	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_time	long
=	O
time	struct(long,long)
(	O
(	O
time_t	long
*	O
)	O
0	int
)	O
;	O
}	O
else	O
{	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_FORW	int
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_addrlen	int
=	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addrlen	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_forw	struct(*(char),struct(short,array(char),long),int)
.	O
f_addr	struct(short,array(char),long)
,	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addr	*(struct(short,array(char)))
,	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addrlen	int
)	O
;	O
freeaddrinfo	(*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
rp	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
}	O
break	O
;	O
case	O
'|'	O
:	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
if	O
(	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_file	short
=	O
open	(*(char),int)->(int)
(	O
++	O
p	*(char)
,	O
O_RDWR	int
|	O
O_NONBLOCK	int
)	O
)	O
<	O
0	int
)	O
{	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_UNUSED	int
;	O
logerror	(*(char))->(void)
(	O
p	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
)	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(char)
,	O
ctty	array(char)
)	O
==	O
0	int
)	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_CONSOLE	int
;	O
else	O
if	O
(	O
isatty	(int)->(int)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_file	short
)	O
)	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_TTY	int
;	O
else	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_PIPE	int
;	O
break	O
;	O
case	O
'/'	O
:	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
if	O
(	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_file	short
=	O
open	(*(char),int)->(int)
(	O
p	*(char)
,	O
O_WRONLY	int
|	O
O_APPEND	int
|	O
O_CREAT	int
,	O
0644	int
)	O
)	O
<	O
0	int
)	O
{	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_UNUSED	int
;	O
logerror	(*(char))->(void)
(	O
p	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
)	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_fname	*(char)
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(char)
,	O
ctty	array(char)
)	O
==	O
0	int
)	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_CONSOLE	int
;	O
else	O
if	O
(	O
isatty	(int)->(int)
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_file	short
)	O
)	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_TTY	int
;	O
else	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_FILE	int
;	O
break	O
;	O
case	O
'*'	O
:	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_WALL	int
;	O
break	O
;	O
default	O
:	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_user	struct(int,*(*(char)))
.	O
f_nusers	int
=	O
1	int
;	O
for	O
(	O
q	*(char)
=	O
p	*(char)
;	O
*	O
q	*(char)
;	O
q	*(char)
++	O
)	O
if	O
(	O
*	O
q	*(char)
==	O
','	O
)	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_user	struct(int,*(*(char)))
.	O
f_nusers	int
++	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_user	struct(int,*(*(char)))
.	O
f_unames	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
malloc	(long)->(*(void))
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_user	struct(int,*(*(char)))
.	O
f_nusers	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
*	O
p	*(char)
;	O
i	long
++	O
)	O
{	O
for	O
(	O
q	*(char)
=	O
p	*(char)
;	O
*	O
q	*(char)
&&	O
*	O
q	*(char)
!=	O
','	O
;	O
)	O
q	*(char)
++	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_user	struct(int,*(*(char)))
.	O
f_unames	*(*(char))
[	O
i	long
]	O
=	O
malloc	(long)->(*(void))
(	O
q	*(char)
-	O
p	*(char)
+	O
1	int
)	O
;	O
if	O
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_user	struct(int,*(*(char)))
.	O
f_unames	*(*(char))
[	O
i	long
]	O
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_user	struct(int,*(*(char)))
.	O
f_unames	*(*(char))
[	O
i	long
]	O
,	O
p	*(char)
,	O
q	*(char)
-	O
p	*(char)
)	O
;	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_un	union(struct(int,*(*(char))),struct(*(char),struct(short,array(char),long),int),*(char))
.	O
f_user	struct(int,*(*(char)))
.	O
f_unames	*(*(char))
[	O
i	long
]	O
[	O
q	*(char)
-	O
p	*(char)
]	O
=	O
'\0'	O
;	O
}	O
while	O
(	O
*	O
q	*(char)
==	O
','	O
||	O
*	O
q	*(char)
==	O
' '	O
)	O
q	*(char)
++	O
;	O
p	*(char)
=	O
q	*(char)
;	O
}	O
f	*(struct(*(struct(*(struct`),short,short,long,array(char),union(struct`,struct`,*`),array(char),array(char),*(char),int,int,int,long,int)),short,short,long,array(char),union(struct(int,*(*`)),struct(*(char),struct(short,array(char),long),int),*(char)),array(char),array(char),*(char),int,int,int,long,int))
->	O
f_type	short
=	O
F_USERS	int
;	O
break	O
;	O
}	O
}	O
int	O
decode	(*(char),*(struct(*(char),int)))->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
CODE	struct(*(char),int)
*	O
codetab	*(struct(*(char),int))
)	O
{	O
CODE	struct(*(char),int)
*	O
c	int
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
name	*(char)
)	O
)	O
return	O
atoi	(*(char))->(int)
(	O
name	*(char)
)	O
;	O
for	O
(	O
c	int
=	O
codetab	*(struct(*(char),int))
;	O
c	int
->	O
c_name	*(char)
;	O
c	int
++	O
)	O
if	O
(	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
c	int
->	O
c_name	*(char)
)	O
)	O
return	O
c	int
->	O
c_val	int
;	O
return	O
-	O
1	int
;	O
}	O
void	O
dbg_toggle	(int)->(void)
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
int	O
dbg_save	int
=	O
dbg_output	int
;	O
dbg_output	int
=	O
1	int
;	O
dbg_printf	(*(char))->(void)
(	O
"Switching dbg_output to %s.\n"	*(char)
,	O
dbg_save	int
==	O
0	int
?	O
"true"	*(char)
:	O
"false"	*(char)
)	O
;	O
dbg_output	int
=	O
(	O
dbg_save	int
==	O
0	int
)	O
?	O
1	int
:	O
0	int
;	O
}	O
static	O
void	O
dbg_printf	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
if	O
(	O
!	O
(	O
Debug	int
&&	O
dbg_output	int
)	O
)	O
return	O
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
void	O
trigger_restart	(int)->(void)
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
restart	int
=	O
1	int
;	O
}	O
