static	O
int	O
hyperg_2F1_series	(double,double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
c	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
sum_pos	double
=	O
1.0	int
;	O
double	O
sum_neg	double
=	O
0.0	int
;	O
double	O
del_pos	double
=	O
1.0	int
;	O
double	O
del_neg	double
=	O
0.0	int
;	O
double	O
del	double
=	O
1.0	int
;	O
double	O
del_prev	double
;	O
double	O
k	double
=	O
0.0	int
;	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
fabs	(double)->(double)
(	O
c	double
)	O
<	O
GSL_DBL_EPSILON	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
1.0	int
;	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EDOM	int
)	O
;	O
}	O
do	O
{	O
if	O
(	O
++	O
i	int
>	O
30000	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
sum_pos	double
-	O
sum_neg	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
del_pos	double
+	O
del_neg	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
sum_pos	double
+	O
sum_neg	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
2.0	int
*	O
sqrt	(double)->(double)
(	O
k	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
}	O
del_prev	double
=	O
del	double
;	O
del	double
*=	O
(	O
a	double
+	O
k	double
)	O
*	O
(	O
b	double
+	O
k	double
)	O
*	O
x	double
/	O
(	O
(	O
c	double
+	O
k	double
)	O
*	O
(	O
k	double
+	O
1.0	int
)	O
)	O
;	O
if	O
(	O
del	double
>	O
0.0	int
)	O
{	O
del_pos	double
=	O
del	double
;	O
sum_pos	double
+=	O
del	double
;	O
}	O
else	O
if	O
(	O
del	double
==	O
0.0	int
)	O
{	O
del_pos	double
=	O
0.0	int
;	O
del_neg	double
=	O
0.0	int
;	O
break	O
;	O
}	O
else	O
{	O
del_neg	double
=	O
-	O
del	double
;	O
sum_neg	double
-=	O
del	double
;	O
}	O
if	O
(	O
fabs	(double)->(double)
(	O
del_prev	double
/	O
(	O
sum_pos	double
-	O
sum_neg	double
)	O
)	O
<	O
GSL_DBL_EPSILON	int
&&	O
fabs	(double)->(double)
(	O
del	double
/	O
(	O
sum_pos	double
-	O
sum_neg	double
)	O
)	O
<	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
k	double
+=	O
1.0	int
;	O
}	O
while	O
(	O
fabs	(double)->(double)
(	O
(	O
del_pos	double
+	O
del_neg	double
)	O
/	O
(	O
sum_pos	double
-	O
sum_neg	double
)	O
)	O
>	O
GSL_DBL_EPSILON	int
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
sum_pos	double
-	O
sum_neg	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
del_pos	double
+	O
del_neg	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
sum_pos	double
+	O
sum_neg	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
2.0	int
*	O
sqrt	(double)->(double)
(	O
k	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
hyperg_2F1_conj_series	(double,double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
aR	double
,	O
const	O
double	O
aI	double
,	O
const	O
double	O
c	double
,	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
c	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
{	O
double	O
sum_pos	double
=	O
1.0	int
;	O
double	O
sum_neg	double
=	O
0.0	int
;	O
double	O
del_pos	double
=	O
1.0	int
;	O
double	O
del_neg	double
=	O
0.0	int
;	O
double	O
del	double
=	O
1.0	int
;	O
double	O
k	double
=	O
0.0	int
;	O
do	O
{	O
del	double
*=	O
(	O
(	O
aR	double
+	O
k	double
)	O
*	O
(	O
aR	double
+	O
k	double
)	O
+	O
aI	double
*	O
aI	double
)	O
/	O
(	O
(	O
k	double
+	O
1.0	int
)	O
*	O
(	O
c	double
+	O
k	double
)	O
)	O
*	O
x	double
;	O
if	O
(	O
del	double
>=	O
0.0	int
)	O
{	O
del_pos	double
=	O
del	double
;	O
sum_pos	double
+=	O
del	double
;	O
}	O
else	O
{	O
del_neg	double
=	O
-	O
del	double
;	O
sum_neg	double
-=	O
del	double
;	O
}	O
if	O
(	O
k	double
>	O
30000	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
sum_pos	double
-	O
sum_neg	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
del_pos	double
+	O
del_neg	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
sum_pos	double
+	O
sum_neg	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
2.0	int
*	O
sqrt	(double)->(double)
(	O
k	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
}	O
k	double
+=	O
1.0	int
;	O
}	O
while	O
(	O
fabs	(double)->(double)
(	O
(	O
del_pos	double
+	O
del_neg	double
)	O
/	O
(	O
sum_pos	double
-	O
sum_neg	double
)	O
)	O
>	O
GSL_DBL_EPSILON	int
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
sum_pos	double
-	O
sum_neg	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
del_pos	double
+	O
del_neg	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
sum_pos	double
+	O
sum_neg	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
2.0	int
*	O
sqrt	(double)->(double)
(	O
k	double
)	O
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
hyperg_2F1_luke	(double,double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
c	double
,	O
const	O
double	O
xin	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
int	O
stat_iter	int
;	O
const	O
double	O
RECUR_BIG	double
=	O
1.0e+50	int
;	O
const	O
int	O
nmax	int
=	O
20000	int
;	O
int	O
n	int
=	O
3	int
;	O
const	O
double	O
x	double
=	O
-	O
xin	double
;	O
const	O
double	O
x3	double
=	O
x	double
*	O
x	double
*	O
x	double
;	O
const	O
double	O
t0	double
=	O
a	double
*	O
b	double
/	O
c	double
;	O
const	O
double	O
t1	double
=	O
(	O
a	double
+	O
1.0	int
)	O
*	O
(	O
b	double
+	O
1.0	int
)	O
/	O
(	O
2.0	int
*	O
c	double
)	O
;	O
const	O
double	O
t2	double
=	O
(	O
a	double
+	O
2.0	int
)	O
*	O
(	O
b	double
+	O
2.0	int
)	O
/	O
(	O
2.0	int
*	O
(	O
c	double
+	O
1.0	int
)	O
)	O
;	O
double	O
F	double
=	O
1.0	int
;	O
double	O
prec	double
;	O
double	O
Bnm3	double
=	O
1.0	int
;	O
double	O
Bnm2	double
=	O
1.0	int
+	O
t1	double
*	O
x	double
;	O
double	O
Bnm1	double
=	O
1.0	int
+	O
t2	double
*	O
x	double
*	O
(	O
1.0	int
+	O
t1	double
/	O
3.0	int
*	O
x	double
)	O
;	O
double	O
Anm3	double
=	O
1.0	int
;	O
double	O
Anm2	double
=	O
Bnm2	double
-	O
t0	double
*	O
x	double
;	O
double	O
Anm1	double
=	O
Bnm1	double
-	O
t0	double
*	O
(	O
1.0	int
+	O
t2	double
*	O
x	double
)	O
*	O
x	double
+	O
t0	double
*	O
t1	double
*	O
(	O
c	double
/	O
(	O
c	double
+	O
1.0	int
)	O
)	O
*	O
x	double
*	O
x	double
;	O
while	O
(	O
1	int
)	O
{	O
double	O
npam1	double
=	O
n	int
+	O
a	double
-	O
1	int
;	O
double	O
npbm1	double
=	O
n	int
+	O
b	double
-	O
1	int
;	O
double	O
npcm1	double
=	O
n	int
+	O
c	double
-	O
1	int
;	O
double	O
npam2	double
=	O
n	int
+	O
a	double
-	O
2	int
;	O
double	O
npbm2	double
=	O
n	int
+	O
b	double
-	O
2	int
;	O
double	O
npcm2	double
=	O
n	int
+	O
c	double
-	O
2	int
;	O
double	O
tnm1	double
=	O
2	int
*	O
n	int
-	O
1	int
;	O
double	O
tnm3	double
=	O
2	int
*	O
n	int
-	O
3	int
;	O
double	O
tnm5	double
=	O
2	int
*	O
n	int
-	O
5	int
;	O
double	O
n2	double
=	O
n	int
*	O
n	int
;	O
double	O
F1	double
=	O
(	O
3.0	int
*	O
n2	double
+	O
(	O
a	double
+	O
b	double
-	O
6	int
)	O
*	O
n	int
+	O
2	int
-	O
a	double
*	O
b	double
-	O
2	int
*	O
(	O
a	double
+	O
b	double
)	O
)	O
/	O
(	O
2	int
*	O
tnm3	double
*	O
npcm1	double
)	O
;	O
double	O
F2	double
=	O
-	O
(	O
3.0	int
*	O
n2	double
-	O
(	O
a	double
+	O
b	double
+	O
6	int
)	O
*	O
n	int
+	O
2	int
-	O
a	double
*	O
b	double
)	O
*	O
npam1	double
*	O
npbm1	double
/	O
(	O
4	int
*	O
tnm1	double
*	O
tnm3	double
*	O
npcm2	double
*	O
npcm1	double
)	O
;	O
double	O
F3	double
=	O
(	O
npam2	double
*	O
npam1	double
*	O
npbm2	double
*	O
npbm1	double
*	O
(	O
n	int
-	O
a	double
-	O
2	int
)	O
*	O
(	O
n	int
-	O
b	double
-	O
2	int
)	O
)	O
/	O
(	O
8	int
*	O
tnm3	double
*	O
tnm3	double
*	O
tnm5	double
*	O
(	O
n	int
+	O
c	double
-	O
3	int
)	O
*	O
npcm2	double
*	O
npcm1	double
)	O
;	O
double	O
E	double
=	O
-	O
npam1	double
*	O
npbm1	double
*	O
(	O
n	int
-	O
c	double
-	O
1	int
)	O
/	O
(	O
2	int
*	O
tnm3	double
*	O
npcm2	double
*	O
npcm1	double
)	O
;	O
double	O
An	double
=	O
(	O
1.0	int
+	O
F1	double
*	O
x	double
)	O
*	O
Anm1	double
+	O
(	O
E	double
+	O
F2	double
*	O
x	double
)	O
*	O
x	double
*	O
Anm2	double
+	O
F3	double
*	O
x3	double
*	O
Anm3	double
;	O
double	O
Bn	double
=	O
(	O
1.0	int
+	O
F1	double
*	O
x	double
)	O
*	O
Bnm1	double
+	O
(	O
E	double
+	O
F2	double
*	O
x	double
)	O
*	O
x	double
*	O
Bnm2	double
+	O
F3	double
*	O
x3	double
*	O
Bnm3	double
;	O
double	O
r	*(struct(double,double))
=	O
An	double
/	O
Bn	double
;	O
prec	double
=	O
fabs	(double)->(double)
(	O
(	O
F	double
-	O
r	*(struct(double,double))
)	O
/	O
F	double
)	O
;	O
F	double
=	O
r	*(struct(double,double))
;	O
if	O
(	O
prec	double
<	O
GSL_DBL_EPSILON	int
||	O
n	int
>	O
nmax	int
)	O
break	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
An	double
)	O
>	O
RECUR_BIG	double
||	O
fabs	(double)->(double)
(	O
Bn	double
)	O
>	O
RECUR_BIG	double
)	O
{	O
An	double
/=	O
RECUR_BIG	double
;	O
Bn	double
/=	O
RECUR_BIG	double
;	O
Anm1	double
/=	O
RECUR_BIG	double
;	O
Bnm1	double
/=	O
RECUR_BIG	double
;	O
Anm2	double
/=	O
RECUR_BIG	double
;	O
Bnm2	double
/=	O
RECUR_BIG	double
;	O
Anm3	double
/=	O
RECUR_BIG	double
;	O
Bnm3	double
/=	O
RECUR_BIG	double
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
An	double
)	O
<	O
1.0	int
/	O
RECUR_BIG	double
||	O
fabs	(double)->(double)
(	O
Bn	double
)	O
<	O
1.0	int
/	O
RECUR_BIG	double
)	O
{	O
An	double
*=	O
RECUR_BIG	double
;	O
Bn	double
*=	O
RECUR_BIG	double
;	O
Anm1	double
*=	O
RECUR_BIG	double
;	O
Bnm1	double
*=	O
RECUR_BIG	double
;	O
Anm2	double
*=	O
RECUR_BIG	double
;	O
Bnm2	double
*=	O
RECUR_BIG	double
;	O
Anm3	double
*=	O
RECUR_BIG	double
;	O
Bnm3	double
*=	O
RECUR_BIG	double
;	O
}	O
n	int
++	O
;	O
Bnm3	double
=	O
Bnm2	double
;	O
Bnm2	double
=	O
Bnm1	double
;	O
Bnm1	double
=	O
Bn	double
;	O
Anm3	double
=	O
Anm2	double
;	O
Anm2	double
=	O
Anm1	double
;	O
Anm1	double
=	O
An	double
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
F	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
fabs	(double)->(double)
(	O
prec	double
*	O
F	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
n	int
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
F	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
*=	O
8.0	int
*	O
(	O
fabs	(double)->(double)
(	O
a	double
)	O
+	O
fabs	(double)->(double)
(	O
b	double
)	O
+	O
1.0	int
)	O
;	O
stat_iter	int
=	O
(	O
n	int
>=	O
nmax	int
?	O
GSL_EMAXITER	int
:	O
GSL_SUCCESS	int
)	O
;	O
return	O
stat_iter	int
;	O
}	O
static	O
int	O
hyperg_2F1_conj_luke	(double,double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
aR	double
,	O
const	O
double	O
aI	double
,	O
const	O
double	O
c	double
,	O
const	O
double	O
xin	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
int	O
stat_iter	int
;	O
const	O
double	O
RECUR_BIG	double
=	O
1.0e+50	int
;	O
const	O
int	O
nmax	int
=	O
10000	int
;	O
int	O
n	int
=	O
3	int
;	O
const	O
double	O
x	double
=	O
-	O
xin	double
;	O
const	O
double	O
x3	double
=	O
x	double
*	O
x	double
*	O
x	double
;	O
const	O
double	O
atimesb	double
=	O
aR	double
*	O
aR	double
+	O
aI	double
*	O
aI	double
;	O
const	O
double	O
apb	double
=	O
2.0	int
*	O
aR	double
;	O
const	O
double	O
t0	double
=	O
atimesb	double
/	O
c	double
;	O
const	O
double	O
t1	double
=	O
(	O
atimesb	double
+	O
apb	double
+	O
1.0	int
)	O
/	O
(	O
2.0	int
*	O
c	double
)	O
;	O
const	O
double	O
t2	double
=	O
(	O
atimesb	double
+	O
2.0	int
*	O
apb	double
+	O
4.0	int
)	O
/	O
(	O
2.0	int
*	O
(	O
c	double
+	O
1.0	int
)	O
)	O
;	O
double	O
F	double
=	O
1.0	int
;	O
double	O
prec	double
;	O
double	O
Bnm3	double
=	O
1.0	int
;	O
double	O
Bnm2	double
=	O
1.0	int
+	O
t1	double
*	O
x	double
;	O
double	O
Bnm1	double
=	O
1.0	int
+	O
t2	double
*	O
x	double
*	O
(	O
1.0	int
+	O
t1	double
/	O
3.0	int
*	O
x	double
)	O
;	O
double	O
Anm3	double
=	O
1.0	int
;	O
double	O
Anm2	double
=	O
Bnm2	double
-	O
t0	double
*	O
x	double
;	O
double	O
Anm1	double
=	O
Bnm1	double
-	O
t0	double
*	O
(	O
1.0	int
+	O
t2	double
*	O
x	double
)	O
*	O
x	double
+	O
t0	double
*	O
t1	double
*	O
(	O
c	double
/	O
(	O
c	double
+	O
1.0	int
)	O
)	O
*	O
x	double
*	O
x	double
;	O
while	O
(	O
1	int
)	O
{	O
double	O
nm1	double
=	O
n	int
-	O
1	int
;	O
double	O
nm2	double
=	O
n	int
-	O
2	int
;	O
double	O
npam1_npbm1	double
=	O
atimesb	double
+	O
nm1	double
*	O
apb	double
+	O
nm1	double
*	O
nm1	double
;	O
double	O
npam2_npbm2	double
=	O
atimesb	double
+	O
nm2	double
*	O
apb	double
+	O
nm2	double
*	O
nm2	double
;	O
double	O
npcm1	double
=	O
nm1	double
+	O
c	double
;	O
double	O
npcm2	double
=	O
nm2	double
+	O
c	double
;	O
double	O
tnm1	double
=	O
2	int
*	O
n	int
-	O
1	int
;	O
double	O
tnm3	double
=	O
2	int
*	O
n	int
-	O
3	int
;	O
double	O
tnm5	double
=	O
2	int
*	O
n	int
-	O
5	int
;	O
double	O
n2	double
=	O
n	int
*	O
n	int
;	O
double	O
F1	double
=	O
(	O
3.0	int
*	O
n2	double
+	O
(	O
apb	double
-	O
6	int
)	O
*	O
n	int
+	O
2	int
-	O
atimesb	double
-	O
2	int
*	O
apb	double
)	O
/	O
(	O
2	int
*	O
tnm3	double
*	O
npcm1	double
)	O
;	O
double	O
F2	double
=	O
-	O
(	O
3.0	int
*	O
n2	double
-	O
(	O
apb	double
+	O
6	int
)	O
*	O
n	int
+	O
2	int
-	O
atimesb	double
)	O
*	O
npam1_npbm1	double
/	O
(	O
4	int
*	O
tnm1	double
*	O
tnm3	double
*	O
npcm2	double
*	O
npcm1	double
)	O
;	O
double	O
F3	double
=	O
(	O
npam2_npbm2	double
*	O
npam1_npbm1	double
*	O
(	O
nm2	double
*	O
nm2	double
-	O
nm2	double
*	O
apb	double
+	O
atimesb	double
)	O
)	O
/	O
(	O
8	int
*	O
tnm3	double
*	O
tnm3	double
*	O
tnm5	double
*	O
(	O
n	int
+	O
c	double
-	O
3	int
)	O
*	O
npcm2	double
*	O
npcm1	double
)	O
;	O
double	O
E	double
=	O
-	O
npam1_npbm1	double
*	O
(	O
n	int
-	O
c	double
-	O
1	int
)	O
/	O
(	O
2	int
*	O
tnm3	double
*	O
npcm2	double
*	O
npcm1	double
)	O
;	O
double	O
An	double
=	O
(	O
1.0	int
+	O
F1	double
*	O
x	double
)	O
*	O
Anm1	double
+	O
(	O
E	double
+	O
F2	double
*	O
x	double
)	O
*	O
x	double
*	O
Anm2	double
+	O
F3	double
*	O
x3	double
*	O
Anm3	double
;	O
double	O
Bn	double
=	O
(	O
1.0	int
+	O
F1	double
*	O
x	double
)	O
*	O
Bnm1	double
+	O
(	O
E	double
+	O
F2	double
*	O
x	double
)	O
*	O
x	double
*	O
Bnm2	double
+	O
F3	double
*	O
x3	double
*	O
Bnm3	double
;	O
double	O
r	*(struct(double,double))
=	O
An	double
/	O
Bn	double
;	O
prec	double
=	O
fabs	(double)->(double)
(	O
F	double
-	O
r	*(struct(double,double))
)	O
/	O
fabs	(double)->(double)
(	O
F	double
)	O
;	O
F	double
=	O
r	*(struct(double,double))
;	O
if	O
(	O
prec	double
<	O
GSL_DBL_EPSILON	int
||	O
n	int
>	O
nmax	int
)	O
break	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
An	double
)	O
>	O
RECUR_BIG	double
||	O
fabs	(double)->(double)
(	O
Bn	double
)	O
>	O
RECUR_BIG	double
)	O
{	O
An	double
/=	O
RECUR_BIG	double
;	O
Bn	double
/=	O
RECUR_BIG	double
;	O
Anm1	double
/=	O
RECUR_BIG	double
;	O
Bnm1	double
/=	O
RECUR_BIG	double
;	O
Anm2	double
/=	O
RECUR_BIG	double
;	O
Bnm2	double
/=	O
RECUR_BIG	double
;	O
Anm3	double
/=	O
RECUR_BIG	double
;	O
Bnm3	double
/=	O
RECUR_BIG	double
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
An	double
)	O
<	O
1.0	int
/	O
RECUR_BIG	double
||	O
fabs	(double)->(double)
(	O
Bn	double
)	O
<	O
1.0	int
/	O
RECUR_BIG	double
)	O
{	O
An	double
*=	O
RECUR_BIG	double
;	O
Bn	double
*=	O
RECUR_BIG	double
;	O
Anm1	double
*=	O
RECUR_BIG	double
;	O
Bnm1	double
*=	O
RECUR_BIG	double
;	O
Anm2	double
*=	O
RECUR_BIG	double
;	O
Bnm2	double
*=	O
RECUR_BIG	double
;	O
Anm3	double
*=	O
RECUR_BIG	double
;	O
Bnm3	double
*=	O
RECUR_BIG	double
;	O
}	O
n	int
++	O
;	O
Bnm3	double
=	O
Bnm2	double
;	O
Bnm2	double
=	O
Bnm1	double
;	O
Bnm1	double
=	O
Bn	double
;	O
Anm3	double
=	O
Anm2	double
;	O
Anm2	double
=	O
Anm1	double
;	O
Anm1	double
=	O
An	double
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
F	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
fabs	(double)->(double)
(	O
prec	double
*	O
F	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
n	int
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
F	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
*=	O
8.0	int
*	O
(	O
fabs	(double)->(double)
(	O
aR	double
)	O
+	O
fabs	(double)->(double)
(	O
aI	double
)	O
+	O
1.0	int
)	O
;	O
stat_iter	int
=	O
(	O
n	int
>=	O
nmax	int
?	O
GSL_EMAXITER	int
:	O
GSL_SUCCESS	int
)	O
;	O
return	O
stat_iter	int
;	O
}	O
static	O
int	O
hyperg_2F1_reflect	(double,double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
c	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
d	double
=	O
c	double
-	O
a	double
-	O
b	double
;	O
const	O
int	O
intd	int
=	O
floor	(double)->(double)
(	O
d	double
+	O
0.5	int
)	O
;	O
const	O
int	O
d_integer	int
=	O
(	O
fabs	(double)->(double)
(	O
d	double
-	O
intd	int
)	O
<	O
locEPS	O
)	O
;	O
if	O
(	O
d_integer	int
)	O
{	O
const	O
double	O
ln_omx	double
=	O
log	(double)->(double)
(	O
1.0	int
-	O
x	double
)	O
;	O
const	O
double	O
ad	double
=	O
fabs	(double)->(double)
(	O
d	double
)	O
;	O
int	O
stat_F2	int
=	O
GSL_SUCCESS	int
;	O
double	O
sgn_2	double
;	O
gsl_sf_result	struct(double,double)
F1	double
;	O
gsl_sf_result	struct(double,double)
F2	double
;	O
double	O
d1	double
,	O
d2	double
;	O
gsl_sf_result	struct(double,double)
lng_c	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
lng_ad2	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
lng_bd2	struct(double,double)
;	O
int	O
stat_c	int
;	O
int	O
stat_ad2	int
;	O
int	O
stat_bd2	int
;	O
if	O
(	O
d	double
>=	O
0.0	int
)	O
{	O
d1	double
=	O
d	double
;	O
d2	double
=	O
0.0	int
;	O
}	O
else	O
{	O
d1	double
=	O
0.0	int
;	O
d2	double
=	O
d	double
;	O
}	O
stat_ad2	int
=	O
gsl_sf_lngamma_e	(double,*(struct(double,double)))->(int)
(	O
a	double
+	O
d2	double
,	O
&	O
lng_ad2	struct(double,double)
)	O
;	O
stat_bd2	int
=	O
gsl_sf_lngamma_e	(double,*(struct(double,double)))->(int)
(	O
b	double
+	O
d2	double
,	O
&	O
lng_bd2	struct(double,double)
)	O
;	O
stat_c	int
=	O
gsl_sf_lngamma_e	(double,*(struct(double,double)))->(int)
(	O
c	double
,	O
&	O
lng_c	struct(double,double)
)	O
;	O
if	O
(	O
ad	double
<	O
GSL_DBL_EPSILON	int
)	O
{	O
F1	double
.	O
val	double
=	O
0.0	int
;	O
F1	double
.	O
err	double
=	O
0.0	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
lng_ad	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
lng_ad1	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
lng_bd1	struct(double,double)
;	O
int	O
stat_ad	int
=	O
gsl_sf_lngamma_e	(double,*(struct(double,double)))->(int)
(	O
ad	double
,	O
&	O
lng_ad	struct(double,double)
)	O
;	O
int	O
stat_ad1	int
=	O
gsl_sf_lngamma_e	(double,*(struct(double,double)))->(int)
(	O
a	double
+	O
d1	double
,	O
&	O
lng_ad1	struct(double,double)
)	O
;	O
int	O
stat_bd1	int
=	O
gsl_sf_lngamma_e	(double,*(struct(double,double)))->(int)
(	O
b	double
+	O
d1	double
,	O
&	O
lng_bd1	struct(double,double)
)	O
;	O
if	O
(	O
stat_ad1	int
==	O
GSL_SUCCESS	int
&&	O
stat_bd1	int
==	O
GSL_SUCCESS	int
&&	O
stat_ad	int
==	O
GSL_SUCCESS	int
)	O
{	O
int	O
i	int
;	O
double	O
sum1	double
=	O
1.0	int
;	O
double	O
term	double
=	O
1.0	int
;	O
double	O
ln_pre1_val	double
=	O
lng_ad	struct(double,double)
.	O
val	double
+	O
lng_c	struct(double,double)
.	O
val	double
+	O
d2	double
*	O
ln_omx	double
-	O
lng_ad1	struct(double,double)
.	O
val	double
-	O
lng_bd1	struct(double,double)
.	O
val	double
;	O
double	O
ln_pre1_err	double
=	O
lng_ad	struct(double,double)
.	O
err	double
+	O
lng_c	struct(double,double)
.	O
err	double
+	O
lng_ad1	struct(double,double)
.	O
err	double
+	O
lng_bd1	struct(double,double)
.	O
err	double
+	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
ln_pre1_val	double
)	O
;	O
int	O
stat_e	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
ad	double
;	O
i	int
++	O
)	O
{	O
int	O
j	int
=	O
i	int
-	O
1	int
;	O
term	double
*=	O
(	O
a	double
+	O
d2	double
+	O
j	int
)	O
*	O
(	O
b	double
+	O
d2	double
+	O
j	int
)	O
/	O
(	O
1.0	int
+	O
d2	double
+	O
j	int
)	O
/	O
i	int
*	O
(	O
1.0	int
-	O
x	double
)	O
;	O
sum1	double
+=	O
term	double
;	O
}	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
ln_pre1_val	double
,	O
ln_pre1_err	double
,	O
sum1	double
,	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
sum1	double
)	O
,	O
&	O
F1	double
)	O
;	O
if	O
(	O
stat_e	int
==	O
GSL_EOVRFLW	int
)	O
{	O
OVERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
else	O
{	O
F1	double
.	O
val	double
=	O
0.0	int
;	O
F1	double
.	O
err	double
=	O
0.0	int
;	O
}	O
}	O
if	O
(	O
stat_ad2	int
==	O
GSL_SUCCESS	int
&&	O
stat_bd2	int
==	O
GSL_SUCCESS	int
)	O
{	O
const	O
int	O
maxiter	int
=	O
2000	int
;	O
double	O
psi_1	double
=	O
-	O
M_EULER	int
;	O
gsl_sf_result	struct(double,double)
psi_1pd	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
psi_apd1	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
psi_bpd1	struct(double,double)
;	O
int	O
stat_1pd	int
=	O
gsl_sf_psi_e	(double,*(struct(double,double)))->(int)
(	O
1.0	int
+	O
ad	double
,	O
&	O
psi_1pd	struct(double,double)
)	O
;	O
int	O
stat_apd1	int
=	O
gsl_sf_psi_e	(double,*(struct(double,double)))->(int)
(	O
a	double
+	O
d1	double
,	O
&	O
psi_apd1	struct(double,double)
)	O
;	O
int	O
stat_bpd1	int
=	O
gsl_sf_psi_e	(double,*(struct(double,double)))->(int)
(	O
b	double
+	O
d1	double
,	O
&	O
psi_bpd1	struct(double,double)
)	O
;	O
int	O
stat_dall	int
=	O
GSL_ERROR_SELECT_3	O
(	O
stat_1pd	int
,	O
stat_apd1	int
,	O
stat_bpd1	int
)	O
;	O
double	O
psi_val	double
=	O
psi_1	double
+	O
psi_1pd	struct(double,double)
.	O
val	double
-	O
psi_apd1	struct(double,double)
.	O
val	double
-	O
psi_bpd1	struct(double,double)
.	O
val	double
-	O
ln_omx	double
;	O
double	O
psi_err	double
=	O
psi_1pd	struct(double,double)
.	O
err	double
+	O
psi_apd1	struct(double,double)
.	O
err	double
+	O
psi_bpd1	struct(double,double)
.	O
err	double
+	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
psi_val	double
)	O
;	O
double	O
fact	double
=	O
1.0	int
;	O
double	O
sum2_val	double
=	O
psi_val	double
;	O
double	O
sum2_err	double
=	O
psi_err	double
;	O
double	O
ln_pre2_val	double
=	O
lng_c	struct(double,double)
.	O
val	double
+	O
d1	double
*	O
ln_omx	double
-	O
lng_ad2	struct(double,double)
.	O
val	double
-	O
lng_bd2	struct(double,double)
.	O
val	double
;	O
double	O
ln_pre2_err	double
=	O
lng_c	struct(double,double)
.	O
err	double
+	O
lng_ad2	struct(double,double)
.	O
err	double
+	O
lng_bd2	struct(double,double)
.	O
err	double
+	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
ln_pre2_val	double
)	O
;	O
int	O
stat_e	int
;	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
maxiter	int
;	O
j	int
++	O
)	O
{	O
double	O
term1	double
=	O
1.0	int
/	O
(	O
double	O
)	O
j	int
+	O
1.0	int
/	O
(	O
ad	double
+	O
j	int
)	O
;	O
double	O
term2	double
=	O
1.0	int
/	O
(	O
a	double
+	O
d1	double
+	O
j	int
-	O
1.0	int
)	O
+	O
1.0	int
/	O
(	O
b	double
+	O
d1	double
+	O
j	int
-	O
1.0	int
)	O
;	O
double	O
delta	double
=	O
0.0	int
;	O
psi_val	double
+=	O
term1	double
-	O
term2	double
;	O
psi_err	double
+=	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
term1	double
)	O
+	O
fabs	(double)->(double)
(	O
term2	double
)	O
)	O
;	O
fact	double
*=	O
(	O
a	double
+	O
d1	double
+	O
j	int
-	O
1.0	int
)	O
*	O
(	O
b	double
+	O
d1	double
+	O
j	int
-	O
1.0	int
)	O
/	O
(	O
(	O
ad	double
+	O
j	int
)	O
*	O
j	int
)	O
*	O
(	O
1.0	int
-	O
x	double
)	O
;	O
delta	double
=	O
fact	double
*	O
psi_val	double
;	O
sum2_val	double
+=	O
delta	double
;	O
sum2_err	double
+=	O
fabs	(double)->(double)
(	O
fact	double
*	O
psi_err	double
)	O
+	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
delta	double
)	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
delta	double
)	O
<	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
sum2_val	double
)	O
)	O
break	O
;	O
}	O
if	O
(	O
j	int
==	O
maxiter	int
)	O
stat_F2	int
=	O
GSL_EMAXITER	int
;	O
if	O
(	O
sum2_val	double
==	O
0.0	int
)	O
{	O
F2	double
.	O
val	double
=	O
0.0	int
;	O
F2	double
.	O
err	double
=	O
0.0	int
;	O
}	O
else	O
{	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
ln_pre2_val	double
,	O
ln_pre2_err	double
,	O
sum2_val	double
,	O
sum2_err	double
,	O
&	O
F2	double
)	O
;	O
if	O
(	O
stat_e	int
==	O
GSL_EOVRFLW	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EOVRFLW	int
)	O
;	O
}	O
}	O
stat_F2	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_F2	int
,	O
stat_dall	int
)	O
;	O
}	O
else	O
{	O
F2	double
.	O
val	double
=	O
0.0	int
;	O
F2	double
.	O
err	double
=	O
0.0	int
;	O
}	O
sgn_2	double
=	O
(	O
GSL_IS_ODD	O
(	O
intd	int
)	O
?	O
-	O
1.0	int
:	O
1.0	int
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
F1	double
.	O
val	double
+	O
sgn_2	double
*	O
F2	double
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
F1	double
.	O
err	double
+	O
F2	double
.	O
err	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
F1	double
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
F2	double
.	O
val	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
stat_F2	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
pre1	struct(double,double)
,	O
pre2	struct(double,double)
;	O
double	O
sgn1	double
,	O
sgn2	double
;	O
gsl_sf_result	struct(double,double)
F1	double
,	O
F2	double
;	O
int	O
status_F1	int
,	O
status_F2	int
;	O
gsl_sf_result	struct(double,double)
ln_g1ca	struct(double,double)
,	O
ln_g1cb	struct(double,double)
,	O
ln_g2a	struct(double,double)
,	O
ln_g2b	struct(double,double)
;	O
double	O
sgn_g1ca	double
,	O
sgn_g1cb	double
,	O
sgn_g2a	double
,	O
sgn_g2b	double
;	O
int	O
stat_1ca	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
c	double
-	O
a	double
,	O
&	O
ln_g1ca	struct(double,double)
,	O
&	O
sgn_g1ca	double
)	O
;	O
int	O
stat_1cb	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
c	double
-	O
b	double
,	O
&	O
ln_g1cb	struct(double,double)
,	O
&	O
sgn_g1cb	double
)	O
;	O
int	O
stat_2a	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
a	double
,	O
&	O
ln_g2a	struct(double,double)
,	O
&	O
sgn_g2a	double
)	O
;	O
int	O
stat_2b	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
b	double
,	O
&	O
ln_g2b	struct(double,double)
,	O
&	O
sgn_g2b	double
)	O
;	O
int	O
ok1	int
=	O
(	O
stat_1ca	int
==	O
GSL_SUCCESS	int
&&	O
stat_1cb	int
==	O
GSL_SUCCESS	int
)	O
;	O
int	O
ok2	int
=	O
(	O
stat_2a	int
==	O
GSL_SUCCESS	int
&&	O
stat_2b	int
==	O
GSL_SUCCESS	int
)	O
;	O
gsl_sf_result	struct(double,double)
ln_gc	struct(double,double)
,	O
ln_gd	struct(double,double)
,	O
ln_gmd	struct(double,double)
;	O
double	O
sgn_gc	double
,	O
sgn_gd	double
,	O
sgn_gmd	double
;	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
c	double
,	O
&	O
ln_gc	struct(double,double)
,	O
&	O
sgn_gc	double
)	O
;	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
d	double
,	O
&	O
ln_gd	struct(double,double)
,	O
&	O
sgn_gd	double
)	O
;	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
-	O
d	double
,	O
&	O
ln_gmd	struct(double,double)
,	O
&	O
sgn_gmd	double
)	O
;	O
sgn1	double
=	O
sgn_gc	double
*	O
sgn_gd	double
*	O
sgn_g1ca	double
*	O
sgn_g1cb	double
;	O
sgn2	double
=	O
sgn_gc	double
*	O
sgn_gmd	double
*	O
sgn_g2a	double
*	O
sgn_g2b	double
;	O
if	O
(	O
ok1	int
&&	O
ok2	int
)	O
{	O
double	O
ln_pre1_val	double
=	O
ln_gc	struct(double,double)
.	O
val	double
+	O
ln_gd	struct(double,double)
.	O
val	double
-	O
ln_g1ca	struct(double,double)
.	O
val	double
-	O
ln_g1cb	struct(double,double)
.	O
val	double
;	O
double	O
ln_pre2_val	double
=	O
ln_gc	struct(double,double)
.	O
val	double
+	O
ln_gmd	struct(double,double)
.	O
val	double
-	O
ln_g2a	struct(double,double)
.	O
val	double
-	O
ln_g2b	struct(double,double)
.	O
val	double
+	O
d	double
*	O
log	(double)->(double)
(	O
1.0	int
-	O
x	double
)	O
;	O
double	O
ln_pre1_err	double
=	O
ln_gc	struct(double,double)
.	O
err	double
+	O
ln_gd	struct(double,double)
.	O
err	double
+	O
ln_g1ca	struct(double,double)
.	O
err	double
+	O
ln_g1cb	struct(double,double)
.	O
err	double
;	O
double	O
ln_pre2_err	double
=	O
ln_gc	struct(double,double)
.	O
err	double
+	O
ln_gmd	struct(double,double)
.	O
err	double
+	O
ln_g2a	struct(double,double)
.	O
err	double
+	O
ln_g2b	struct(double,double)
.	O
err	double
;	O
if	O
(	O
ln_pre1_val	double
<	O
GSL_LOG_DBL_MAX	int
&&	O
ln_pre2_val	double
<	O
GSL_LOG_DBL_MAX	int
)	O
{	O
gsl_sf_exp_err_e	(double,double,*(struct(double,double)))->(int)
(	O
ln_pre1_val	double
,	O
ln_pre1_err	double
,	O
&	O
pre1	struct(double,double)
)	O
;	O
gsl_sf_exp_err_e	(double,double,*(struct(double,double)))->(int)
(	O
ln_pre2_val	double
,	O
ln_pre2_err	double
,	O
&	O
pre2	struct(double,double)
)	O
;	O
pre1	struct(double,double)
.	O
val	double
*=	O
sgn1	double
;	O
pre2	struct(double,double)
.	O
val	double
*=	O
sgn2	double
;	O
}	O
else	O
{	O
OVERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
ok1	int
&&	O
!	O
ok2	int
)	O
{	O
double	O
ln_pre1_val	double
=	O
ln_gc	struct(double,double)
.	O
val	double
+	O
ln_gd	struct(double,double)
.	O
val	double
-	O
ln_g1ca	struct(double,double)
.	O
val	double
-	O
ln_g1cb	struct(double,double)
.	O
val	double
;	O
double	O
ln_pre1_err	double
=	O
ln_gc	struct(double,double)
.	O
err	double
+	O
ln_gd	struct(double,double)
.	O
err	double
+	O
ln_g1ca	struct(double,double)
.	O
err	double
+	O
ln_g1cb	struct(double,double)
.	O
err	double
;	O
if	O
(	O
ln_pre1_val	double
<	O
GSL_LOG_DBL_MAX	int
)	O
{	O
gsl_sf_exp_err_e	(double,double,*(struct(double,double)))->(int)
(	O
ln_pre1_val	double
,	O
ln_pre1_err	double
,	O
&	O
pre1	struct(double,double)
)	O
;	O
pre1	struct(double,double)
.	O
val	double
*=	O
sgn1	double
;	O
pre2	struct(double,double)
.	O
val	double
=	O
0.0	int
;	O
pre2	struct(double,double)
.	O
err	double
=	O
0.0	int
;	O
}	O
else	O
{	O
OVERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
ok1	int
&&	O
ok2	int
)	O
{	O
double	O
ln_pre2_val	double
=	O
ln_gc	struct(double,double)
.	O
val	double
+	O
ln_gmd	struct(double,double)
.	O
val	double
-	O
ln_g2a	struct(double,double)
.	O
val	double
-	O
ln_g2b	struct(double,double)
.	O
val	double
+	O
d	double
*	O
log	(double)->(double)
(	O
1.0	int
-	O
x	double
)	O
;	O
double	O
ln_pre2_err	double
=	O
ln_gc	struct(double,double)
.	O
err	double
+	O
ln_gmd	struct(double,double)
.	O
err	double
+	O
ln_g2a	struct(double,double)
.	O
err	double
+	O
ln_g2b	struct(double,double)
.	O
err	double
;	O
if	O
(	O
ln_pre2_val	double
<	O
GSL_LOG_DBL_MAX	int
)	O
{	O
pre1	struct(double,double)
.	O
val	double
=	O
0.0	int
;	O
pre1	struct(double,double)
.	O
err	double
=	O
0.0	int
;	O
gsl_sf_exp_err_e	(double,double,*(struct(double,double)))->(int)
(	O
ln_pre2_val	double
,	O
ln_pre2_err	double
,	O
&	O
pre2	struct(double,double)
)	O
;	O
pre2	struct(double,double)
.	O
val	double
*=	O
sgn2	double
;	O
}	O
else	O
{	O
OVERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
else	O
{	O
pre1	struct(double,double)
.	O
val	double
=	O
0.0	int
;	O
pre2	struct(double,double)
.	O
val	double
=	O
0.0	int
;	O
UNDERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
status_F1	int
=	O
hyperg_2F1_series	(double,double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
1.0	int
-	O
d	double
,	O
1.0	int
-	O
x	double
,	O
&	O
F1	double
)	O
;	O
status_F2	int
=	O
hyperg_2F1_series	(double,double,double,double,*(struct(double,double)))->(int)
(	O
c	double
-	O
a	double
,	O
c	double
-	O
b	double
,	O
1.0	int
+	O
d	double
,	O
1.0	int
-	O
x	double
,	O
&	O
F2	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
pre1	struct(double,double)
.	O
val	double
*	O
F1	double
.	O
val	double
+	O
pre2	struct(double,double)
.	O
val	double
*	O
F2	double
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
fabs	(double)->(double)
(	O
pre1	struct(double,double)
.	O
val	double
*	O
F1	double
.	O
err	double
)	O
+	O
fabs	(double)->(double)
(	O
pre2	struct(double,double)
.	O
val	double
*	O
F2	double
.	O
err	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
fabs	(double)->(double)
(	O
pre1	struct(double,double)
.	O
err	double
*	O
F1	double
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
pre2	struct(double,double)
.	O
err	double
*	O
F2	double
.	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
pre1	struct(double,double)
.	O
val	double
*	O
F1	double
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
pre2	struct(double,double)
.	O
val	double
*	O
F2	double
.	O
val	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
if	O
(	O
status_F1	int
)	O
return	O
status_F1	int
;	O
if	O
(	O
status_F2	int
)	O
return	O
status_F2	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
pow_omx	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
x	double
,	O
const	O
double	O
p	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
ln_omx	double
;	O
double	O
ln_result	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
x	double
)	O
<	O
GSL_ROOT5_DBL_EPSILON	int
)	O
{	O
ln_omx	double
=	O
-	O
x	double
*	O
(	O
1.0	int
+	O
x	double
*	O
(	O
1.0	int
/	O
2.0	int
+	O
x	double
*	O
(	O
1.0	int
/	O
3.0	int
+	O
x	double
/	O
4.0	int
+	O
x	double
*	O
x	double
/	O
5.0	int
)	O
)	O
)	O
;	O
}	O
else	O
{	O
ln_omx	double
=	O
log	(double)->(double)
(	O
1.0	int
-	O
x	double
)	O
;	O
}	O
ln_result	double
=	O
p	double
*	O
ln_omx	double
;	O
return	O
gsl_sf_exp_err_e	(double,double,*(struct(double,double)))->(int)
(	O
ln_result	double
,	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
ln_result	double
)	O
,	O
result	*(struct(double,double))
)	O
;	O
}	O
int	O
gsl_sf_hyperg_2F1_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
double	O
a	double
,	O
double	O
b	double
,	O
const	O
double	O
c	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
d	double
=	O
c	double
-	O
a	double
-	O
b	double
;	O
const	O
double	O
rinta	double
=	O
floor	(double)->(double)
(	O
a	double
+	O
0.5	int
)	O
;	O
const	O
double	O
rintb	double
=	O
floor	(double)->(double)
(	O
b	double
+	O
0.5	int
)	O
;	O
const	O
double	O
rintc	double
=	O
floor	(double)->(double)
(	O
c	double
+	O
0.5	int
)	O
;	O
const	O
int	O
a_neg_integer	int
=	O
(	O
a	double
<	O
0.0	int
&&	O
fabs	(double)->(double)
(	O
a	double
-	O
rinta	double
)	O
<	O
locEPS	O
)	O
;	O
const	O
int	O
b_neg_integer	int
=	O
(	O
b	double
<	O
0.0	int
&&	O
fabs	(double)->(double)
(	O
b	double
-	O
rintb	double
)	O
<	O
locEPS	O
)	O
;	O
const	O
int	O
c_neg_integer	int
=	O
(	O
c	double
<	O
0.0	int
&&	O
fabs	(double)->(double)
(	O
c	double
-	O
rintc	double
)	O
<	O
locEPS	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
if	O
(	O
fabs	(double)->(double)
(	O
x	double
-	O
1.0	int
)	O
<	O
locEPS	O
&&	O
(	O
c	double
-	O
a	double
-	O
b	double
)	O
>	O
0	int
&&	O
c	double
!=	O
0	int
&&	O
!	O
c_neg_integer	int
)	O
{	O
gsl_sf_result	struct(double,double)
lngamc	struct(double,double)
,	O
lngamcab	struct(double,double)
,	O
lngamca	struct(double,double)
,	O
lngamcb	struct(double,double)
;	O
double	O
lngamc_sgn	double
,	O
lngamca_sgn	double
,	O
lngamcb_sgn	double
;	O
int	O
status	int
;	O
int	O
stat1	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
c	double
,	O
&	O
lngamc	struct(double,double)
,	O
&	O
lngamc_sgn	double
)	O
;	O
int	O
stat2	int
=	O
gsl_sf_lngamma_e	(double,*(struct(double,double)))->(int)
(	O
c	double
-	O
a	double
-	O
b	double
,	O
&	O
lngamcab	struct(double,double)
)	O
;	O
int	O
stat3	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
c	double
-	O
a	double
,	O
&	O
lngamca	struct(double,double)
,	O
&	O
lngamca_sgn	double
)	O
;	O
int	O
stat4	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
c	double
-	O
b	double
,	O
&	O
lngamcb	struct(double,double)
,	O
&	O
lngamcb_sgn	double
)	O
;	O
if	O
(	O
stat1	int
!=	O
GSL_SUCCESS	int
||	O
stat2	int
!=	O
GSL_SUCCESS	int
||	O
stat3	int
!=	O
GSL_SUCCESS	int
||	O
stat4	int
!=	O
GSL_SUCCESS	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
status	int
=	O
gsl_sf_exp_err_e	(double,double,*(struct(double,double)))->(int)
(	O
lngamc	struct(double,double)
.	O
val	double
+	O
lngamcab	struct(double,double)
.	O
val	double
-	O
lngamca	struct(double,double)
.	O
val	double
-	O
lngamcb	struct(double,double)
.	O
val	double
,	O
lngamc	struct(double,double)
.	O
err	double
+	O
lngamcab	struct(double,double)
.	O
err	double
+	O
lngamca	struct(double,double)
.	O
err	double
+	O
lngamcb	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
result	*(struct(double,double))
->	O
val	double
*=	O
lngamc_sgn	double
/	O
(	O
lngamca_sgn	double
*	O
lngamcb_sgn	double
)	O
;	O
return	O
status	int
;	O
}	O
if	O
(	O
x	double
<	O
-	O
1.0	int
||	O
1.0	int
<=	O
x	double
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
if	O
(	O
c_neg_integer	int
)	O
{	O
if	O
(	O
!	O
(	O
a_neg_integer	int
&&	O
a	double
>	O
c	double
+	O
0.1	int
)	O
&&	O
!	O
(	O
b_neg_integer	int
&&	O
b	double
>	O
c	double
+	O
0.1	int
)	O
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
if	O
(	O
fabs	(double)->(double)
(	O
c	double
-	O
b	double
)	O
<	O
locEPS	O
||	O
fabs	(double)->(double)
(	O
c	double
-	O
a	double
)	O
<	O
locEPS	O
)	O
{	O
return	O
pow_omx	(double,double,*(struct(double,double)))->(int)
(	O
x	double
,	O
d	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
if	O
(	O
a	double
>=	O
0.0	int
&&	O
b	double
>=	O
0.0	int
&&	O
c	double
>=	O
0.0	int
&&	O
x	double
>=	O
0.0	int
&&	O
x	double
<	O
0.995	int
)	O
{	O
return	O
hyperg_2F1_series	(double,double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
c	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
if	O
(	O
fabs	(double)->(double)
(	O
a	double
)	O
<	O
10.0	int
&&	O
fabs	(double)->(double)
(	O
b	double
)	O
<	O
10.0	int
)	O
{	O
if	O
(	O
a_neg_integer	int
)	O
{	O
return	O
hyperg_2F1_series	(double,double,double,double,*(struct(double,double)))->(int)
(	O
rinta	double
,	O
b	double
,	O
c	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
if	O
(	O
b_neg_integer	int
)	O
{	O
return	O
hyperg_2F1_series	(double,double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
rintb	double
,	O
c	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
if	O
(	O
x	double
<	O
-	O
0.25	int
)	O
{	O
return	O
hyperg_2F1_luke	(double,double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
c	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
0.5	int
)	O
{	O
return	O
hyperg_2F1_series	(double,double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
c	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
fabs	(double)->(double)
(	O
c	double
)	O
>	O
10.0	int
)	O
{	O
return	O
hyperg_2F1_series	(double,double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
c	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
return	O
hyperg_2F1_reflect	(double,double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
c	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
}	O
else	O
{	O
double	O
ap	double
,	O
bp	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
a	double
)	O
>	O
fabs	(double)->(double)
(	O
b	double
)	O
)	O
{	O
bp	double
=	O
a	double
;	O
ap	double
=	O
b	double
;	O
}	O
else	O
{	O
bp	double
=	O
b	double
;	O
ap	double
=	O
a	double
;	O
}	O
if	O
(	O
x	double
<	O
0.0	int
)	O
{	O
return	O
hyperg_2F1_luke	(double,double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
c	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
if	O
(	O
GSL_MAX_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
ap	double
)	O
,	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
bp	double
)	O
*	O
fabs	(double)->(double)
(	O
x	double
)	O
<	O
2.0	int
*	O
fabs	(double)->(double)
(	O
c	double
)	O
)	O
{	O
return	O
hyperg_2F1_series	(double,double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
c	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
if	O
(	O
fabs	(double)->(double)
(	O
bp	double
*	O
bp	double
*	O
x	double
*	O
x	double
)	O
<	O
0.001	int
*	O
fabs	(double)->(double)
(	O
bp	double
)	O
&&	O
fabs	(double)->(double)
(	O
ap	double
)	O
<	O
10.0	int
)	O
{	O
int	O
stat	int
=	O
gsl_sf_hyperg_1F1_e	(double,double,double,*(struct(double,double)))->(int)
(	O
ap	double
,	O
c	double
,	O
bp	double
*	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.001	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
stat	int
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EUNIMPL	int
)	O
;	O
}	O
}	O
int	O
gsl_sf_hyperg_2F1_conj_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
aR	double
,	O
const	O
double	O
aI	double
,	O
const	O
double	O
c	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
ax	double
=	O
fabs	(double)->(double)
(	O
x	double
)	O
;	O
const	O
double	O
rintc	double
=	O
floor	(double)->(double)
(	O
c	double
+	O
0.5	int
)	O
;	O
const	O
int	O
c_neg_integer	int
=	O
(	O
c	double
<	O
0.0	int
&&	O
fabs	(double)->(double)
(	O
c	double
-	O
rintc	double
)	O
<	O
locEPS	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
if	O
(	O
ax	double
>=	O
1.0	int
||	O
c_neg_integer	int
||	O
c	double
==	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
if	O
(	O
(	O
ax	double
<	O
0.25	int
&&	O
fabs	(double)->(double)
(	O
aR	double
)	O
<	O
20.0	int
&&	O
fabs	(double)->(double)
(	O
aI	double
)	O
<	O
20.0	int
)	O
||	O
(	O
c	double
>	O
0.0	int
&&	O
x	double
>	O
0.0	int
)	O
)	O
{	O
return	O
hyperg_2F1_conj_series	(double,double,double,double,*(struct(double,double)))->(int)
(	O
aR	double
,	O
aI	double
,	O
c	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
aR	double
)	O
<	O
10.0	int
&&	O
fabs	(double)->(double)
(	O
aI	double
)	O
<	O
10.0	int
)	O
{	O
if	O
(	O
x	double
<	O
-	O
0.25	int
)	O
{	O
return	O
hyperg_2F1_conj_luke	(double,double,double,double,*(struct(double,double)))->(int)
(	O
aR	double
,	O
aI	double
,	O
c	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
return	O
hyperg_2F1_conj_series	(double,double,double,double,*(struct(double,double)))->(int)
(	O
aR	double
,	O
aI	double
,	O
c	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
x	double
<	O
0.0	int
)	O
{	O
return	O
hyperg_2F1_conj_luke	(double,double,double,double,*(struct(double,double)))->(int)
(	O
aR	double
,	O
aI	double
,	O
c	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EUNIMPL	int
)	O
;	O
}	O
}	O
int	O
gsl_sf_hyperg_2F1_renorm_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
const	O
double	O
c	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
rinta	double
=	O
floor	(double)->(double)
(	O
a	double
+	O
0.5	int
)	O
;	O
const	O
double	O
rintb	double
=	O
floor	(double)->(double)
(	O
b	double
+	O
0.5	int
)	O
;	O
const	O
double	O
rintc	double
=	O
floor	(double)->(double)
(	O
c	double
+	O
0.5	int
)	O
;	O
const	O
int	O
a_neg_integer	int
=	O
(	O
a	double
<	O
0.0	int
&&	O
fabs	(double)->(double)
(	O
a	double
-	O
rinta	double
)	O
<	O
locEPS	O
)	O
;	O
const	O
int	O
b_neg_integer	int
=	O
(	O
b	double
<	O
0.0	int
&&	O
fabs	(double)->(double)
(	O
b	double
-	O
rintb	double
)	O
<	O
locEPS	O
)	O
;	O
const	O
int	O
c_neg_integer	int
=	O
(	O
c	double
<	O
0.0	int
&&	O
fabs	(double)->(double)
(	O
c	double
-	O
rintc	double
)	O
<	O
locEPS	O
)	O
;	O
if	O
(	O
c_neg_integer	int
)	O
{	O
if	O
(	O
(	O
a_neg_integer	int
&&	O
a	double
>	O
c	double
+	O
0.1	int
)	O
||	O
(	O
b_neg_integer	int
&&	O
b	double
>	O
c	double
+	O
0.1	int
)	O
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
g1	struct(double,double)
,	O
g2	struct(double,double)
,	O
g3	struct(double,double)
,	O
g4	struct(double,double)
,	O
g5	struct(double,double)
;	O
double	O
s1	double
,	O
s2	double
,	O
s3	double
,	O
s4	double
,	O
s5	double
;	O
int	O
stat	int
=	O
0	int
;	O
stat	int
+=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
a	double
-	O
c	double
+	O
1	int
,	O
&	O
g1	struct(double,double)
,	O
&	O
s1	double
)	O
;	O
stat	int
+=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
b	double
-	O
c	double
+	O
1	int
,	O
&	O
g2	struct(double,double)
,	O
&	O
s2	double
)	O
;	O
stat	int
+=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
a	double
,	O
&	O
g3	struct(double,double)
,	O
&	O
s3	double
)	O
;	O
stat	int
+=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
b	double
,	O
&	O
g4	struct(double,double)
,	O
&	O
s4	double
)	O
;	O
stat	int
+=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
-	O
c	double
+	O
2	int
,	O
&	O
g5	struct(double,double)
,	O
&	O
s5	double
)	O
;	O
if	O
(	O
stat	int
!=	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
F	double
;	O
int	O
stat_F	int
=	O
gsl_sf_hyperg_2F1_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
a	double
-	O
c	double
+	O
1	int
,	O
b	double
-	O
c	double
+	O
1	int
,	O
-	O
c	double
+	O
2	int
,	O
x	double
,	O
&	O
F	double
)	O
;	O
double	O
ln_pre_val	double
=	O
g1	struct(double,double)
.	O
val	double
+	O
g2	struct(double,double)
.	O
val	double
-	O
g3	struct(double,double)
.	O
val	double
-	O
g4	struct(double,double)
.	O
val	double
-	O
g5	struct(double,double)
.	O
val	double
;	O
double	O
ln_pre_err	double
=	O
g1	struct(double,double)
.	O
err	double
+	O
g2	struct(double,double)
.	O
err	double
+	O
g3	struct(double,double)
.	O
err	double
+	O
g4	struct(double,double)
.	O
err	double
+	O
g5	struct(double,double)
.	O
err	double
;	O
double	O
sg	double
=	O
s1	double
*	O
s2	double
*	O
s3	double
*	O
s4	double
*	O
s5	double
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
ln_pre_val	double
,	O
ln_pre_err	double
,	O
sg	double
*	O
F	double
.	O
val	double
,	O
F	double
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_F	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
F	double
;	O
gsl_sf_result	struct(double,double)
lng	struct(double,double)
;	O
double	O
sgn	*(double)
;	O
int	O
stat_g	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
c	double
,	O
&	O
lng	struct(double,double)
,	O
&	O
sgn	*(double)
)	O
;	O
int	O
stat_F	int
=	O
gsl_sf_hyperg_2F1_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
c	double
,	O
x	double
,	O
&	O
F	double
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
-	O
lng	struct(double,double)
.	O
val	double
,	O
lng	struct(double,double)
.	O
err	double
,	O
sgn	*(double)
*	O
F	double
.	O
val	double
,	O
F	double
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_e	int
,	O
stat_F	int
,	O
stat_g	int
)	O
;	O
}	O
}	O
int	O
gsl_sf_hyperg_2F1_conj_renorm_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
aR	double
,	O
const	O
double	O
aI	double
,	O
const	O
double	O
c	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
rintc	double
=	O
floor	(double)->(double)
(	O
c	double
+	O
0.5	int
)	O
;	O
const	O
double	O
rinta	double
=	O
floor	(double)->(double)
(	O
aR	double
+	O
0.5	int
)	O
;	O
const	O
int	O
a_neg_integer	int
=	O
(	O
aR	double
<	O
0.0	int
&&	O
fabs	(double)->(double)
(	O
aR	double
-	O
rinta	double
)	O
<	O
locEPS	O
&&	O
aI	double
==	O
0.0	int
)	O
;	O
const	O
int	O
c_neg_integer	int
=	O
(	O
c	double
<	O
0.0	int
&&	O
fabs	(double)->(double)
(	O
c	double
-	O
rintc	double
)	O
<	O
locEPS	O
)	O
;	O
if	O
(	O
c_neg_integer	int
)	O
{	O
if	O
(	O
a_neg_integer	int
&&	O
aR	double
>	O
c	double
+	O
0.1	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
g1	struct(double,double)
,	O
g2	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
g3	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
a1	struct(double,double)
,	O
a2	struct(double,double)
;	O
int	O
stat	int
=	O
0	int
;	O
stat	int
+=	O
gsl_sf_lngamma_complex_e	(double,double,*(struct(double,double)),*(struct(double,double)))->(int)
(	O
aR	double
-	O
c	double
+	O
1	int
,	O
aI	double
,	O
&	O
g1	struct(double,double)
,	O
&	O
a1	struct(double,double)
)	O
;	O
stat	int
+=	O
gsl_sf_lngamma_complex_e	(double,double,*(struct(double,double)),*(struct(double,double)))->(int)
(	O
aR	double
,	O
aI	double
,	O
&	O
g2	struct(double,double)
,	O
&	O
a2	struct(double,double)
)	O
;	O
stat	int
+=	O
gsl_sf_lngamma_e	(double,*(struct(double,double)))->(int)
(	O
-	O
c	double
+	O
2.0	int
,	O
&	O
g3	struct(double,double)
)	O
;	O
if	O
(	O
stat	int
!=	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
F	double
;	O
int	O
stat_F	int
=	O
gsl_sf_hyperg_2F1_conj_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
aR	double
-	O
c	double
+	O
1	int
,	O
aI	double
,	O
-	O
c	double
+	O
2	int
,	O
x	double
,	O
&	O
F	double
)	O
;	O
double	O
ln_pre_val	double
=	O
2.0	int
*	O
(	O
g1	struct(double,double)
.	O
val	double
-	O
g2	struct(double,double)
.	O
val	double
)	O
-	O
g3	struct(double,double)
.	O
val	double
;	O
double	O
ln_pre_err	double
=	O
2.0	int
*	O
(	O
g1	struct(double,double)
.	O
err	double
+	O
g2	struct(double,double)
.	O
err	double
)	O
+	O
g3	struct(double,double)
.	O
err	double
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
ln_pre_val	double
,	O
ln_pre_err	double
,	O
F	double
.	O
val	double
,	O
F	double
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_F	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
F	double
;	O
gsl_sf_result	struct(double,double)
lng	struct(double,double)
;	O
double	O
sgn	*(double)
;	O
int	O
stat_g	int
=	O
gsl_sf_lngamma_sgn_e	(double,*(struct(double,double)),*(double))->(int)
(	O
c	double
,	O
&	O
lng	struct(double,double)
,	O
&	O
sgn	*(double)
)	O
;	O
int	O
stat_F	int
=	O
gsl_sf_hyperg_2F1_conj_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
aR	double
,	O
aI	double
,	O
c	double
,	O
x	double
,	O
&	O
F	double
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
-	O
lng	struct(double,double)
.	O
val	double
,	O
lng	struct(double,double)
.	O
err	double
,	O
sgn	*(double)
*	O
F	double
.	O
val	double
,	O
F	double
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_e	int
,	O
stat_F	int
,	O
stat_g	int
)	O
;	O
}	O
}	O
double	O
gsl_sf_hyperg_2F1	(double,double,double,double)->(double)
(	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
c	double
,	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hyperg_2F1_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
c	double
,	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_hyperg_2F1_conj	(double,double,double,double)->(double)
(	O
double	O
aR	double
,	O
double	O
aI	double
,	O
double	O
c	double
,	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hyperg_2F1_conj_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
aR	double
,	O
aI	double
,	O
c	double
,	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_hyperg_2F1_renorm	(double,double,double,double)->(double)
(	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
c	double
,	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hyperg_2F1_renorm_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
a	double
,	O
b	double
,	O
c	double
,	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_hyperg_2F1_conj_renorm	(double,double,double,double)->(double)
(	O
double	O
aR	double
,	O
double	O
aI	double
,	O
double	O
c	double
,	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hyperg_2F1_conj_renorm_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
aR	double
,	O
aI	double
,	O
c	double
,	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
