static	O
Hash_data	struct(array(long))
white_hash	array(struct(array(long)))
[	O
BOARDMAX	O
]	O
;	O
static	O
Hash_data	struct(array(long))
black_hash	array(struct(array(long)))
[	O
BOARDMAX	O
]	O
;	O
static	O
Hash_data	struct(array(long))
ko_hash	array(struct(array(long)))
[	O
BOARDMAX	O
]	O
;	O
static	O
Hash_data	struct(array(long))
komaster_hash	array(struct(array(long)))
[	O
NUM_KOMASTER_STATES	int
]	O
;	O
static	O
Hash_data	struct(array(long))
kom_pos_hash	array(struct(array(long)))
[	O
BOARDMAX	O
]	O
;	O
static	O
Hash_data	struct(array(long))
goal_hash	array(struct(array(long)))
[	O
BOARDMAX	O
]	O
;	O
static	O
Hashvalue	long
hash_rand	()->(long)
(	O
void	O
)	O
{	O
int	O
i	int
;	O
Hashvalue	long
h	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
32	int
*	O
i	int
<	O
(	O
int	O
)	O
(	O
CHAR_BIT	O
*	O
sizeof	O
(	O
Hashvalue	long
)	O
)	O
;	O
i	int
++	O
)	O
h	long
|=	O
(	O
Hashvalue	long
)	O
gg_urand	()->(int)
(	O
)	O
<<	O
32	int
*	O
i	int
;	O
return	O
h	long
;	O
}	O
void	O
hash_init_zobrist_array	(*(struct(array(long))),int)->(void)
(	O
Hash_data	struct(array(long))
*	O
array	*(struct(array(long)))
,	O
int	O
size	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
NUM_HASHVALUES	O
;	O
j	int
++	O
)	O
array	*(struct(array(long)))
[	O
i	int
]	O
.	O
hashval	array(long)
[	O
j	int
]	O
=	O
hash_rand	()->(long)
(	O
)	O
;	O
}	O
void	O
hash_init	()->(void)
(	O
void	O
)	O
{	O
static	O
int	O
is_initialized	int
=	O
0	int
;	O
if	O
(	O
is_initialized	int
)	O
return	O
;	O
INIT_ZOBRIST_ARRAY	O
(	O
black_hash	array(struct(array(long)))
)	O
;	O
INIT_ZOBRIST_ARRAY	O
(	O
white_hash	array(struct(array(long)))
)	O
;	O
INIT_ZOBRIST_ARRAY	O
(	O
ko_hash	array(struct(array(long)))
)	O
;	O
INIT_ZOBRIST_ARRAY	O
(	O
komaster_hash	array(struct(array(long)))
)	O
;	O
INIT_ZOBRIST_ARRAY	O
(	O
kom_pos_hash	array(struct(array(long)))
)	O
;	O
INIT_ZOBRIST_ARRAY	O
(	O
goal_hash	array(struct(array(long)))
)	O
;	O
is_initialized	int
=	O
1	int
;	O
}	O
void	O
hashdata_recalc	(*(struct(array(long))),*(char),int)->(void)
(	O
Hash_data	struct(array(long))
*	O
hd	*(struct(array(long)))
,	O
Intersection	char
*	O
p	*(char)
,	O
int	O
ko_pos	int
)	O
{	O
int	O
pos	int
;	O
hashdata_clear	(*(struct(array(long))))->(void)
(	O
hd	*(struct(array(long)))
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
p	*(char)
[	O
pos	int
]	O
==	O
WHITE	int
)	O
hashdata_xor	O
(	O
*	O
hd	*(struct(array(long)))
,	O
white_hash	array(struct(array(long)))
[	O
pos	int
]	O
)	O
;	O
else	O
if	O
(	O
p	*(char)
[	O
pos	int
]	O
==	O
BLACK	int
)	O
hashdata_xor	O
(	O
*	O
hd	*(struct(array(long)))
,	O
black_hash	array(struct(array(long)))
[	O
pos	int
]	O
)	O
;	O
}	O
if	O
(	O
ko_pos	int
!=	O
0	int
)	O
hashdata_xor	O
(	O
*	O
hd	*(struct(array(long)))
,	O
ko_hash	array(struct(array(long)))
[	O
ko_pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_clear	(*(struct(array(long))))->(void)
(	O
Hash_data	struct(array(long))
*	O
hd	*(struct(array(long)))
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_HASHVALUES	O
;	O
i	int
++	O
)	O
hd	*(struct(array(long)))
->	O
hashval	array(long)
[	O
i	int
]	O
=	O
0	int
;	O
}	O
void	O
hashdata_invert_ko	(*(struct(array(long))),int)->(void)
(	O
Hash_data	struct(array(long))
*	O
hd	*(struct(array(long)))
,	O
int	O
pos	int
)	O
{	O
hashdata_xor	O
(	O
*	O
hd	*(struct(array(long)))
,	O
ko_hash	array(struct(array(long)))
[	O
pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_invert_stone	(*(struct(array(long))),int,int)->(void)
(	O
Hash_data	struct(array(long))
*	O
hd	*(struct(array(long)))
,	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
if	O
(	O
color	int
==	O
BLACK	int
)	O
hashdata_xor	O
(	O
*	O
hd	*(struct(array(long)))
,	O
black_hash	array(struct(array(long)))
[	O
pos	int
]	O
)	O
;	O
else	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
hashdata_xor	O
(	O
*	O
hd	*(struct(array(long)))
,	O
white_hash	array(struct(array(long)))
[	O
pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_invert_komaster	(*(struct(array(long))),int)->(void)
(	O
Hash_data	struct(array(long))
*	O
hd	*(struct(array(long)))
,	O
int	O
komaster	int
)	O
{	O
hashdata_xor	O
(	O
*	O
hd	*(struct(array(long)))
,	O
komaster_hash	array(struct(array(long)))
[	O
komaster	int
]	O
)	O
;	O
}	O
void	O
hashdata_invert_kom_pos	(*(struct(array(long))),int)->(void)
(	O
Hash_data	struct(array(long))
*	O
hd	*(struct(array(long)))
,	O
int	O
kom_pos	int
)	O
{	O
hashdata_xor	O
(	O
*	O
hd	*(struct(array(long)))
,	O
kom_pos_hash	array(struct(array(long)))
[	O
kom_pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_calc_orientation_invariant	(*(struct(array(long))),*(char),int)->(void)
(	O
Hash_data	struct(array(long))
*	O
hd	*(struct(array(long)))
,	O
Intersection	char
*	O
p	*(char)
,	O
int	O
ko_pos	int
)	O
{	O
int	O
pos	int
;	O
int	O
rot	int
;	O
Hash_data	struct(array(long))
hd_rot	struct(array(long))
;	O
for	O
(	O
rot	int
=	O
0	int
;	O
rot	int
<	O
8	int
;	O
rot	int
++	O
)	O
{	O
hashdata_clear	(*(struct(array(long))))->(void)
(	O
&	O
hd_rot	struct(array(long))
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
p	*(char)
[	O
pos	int
]	O
==	O
WHITE	int
)	O
hashdata_xor	O
(	O
hd_rot	struct(array(long))
,	O
white_hash	array(struct(array(long)))
[	O
rotate1	(int,int)->(int)
(	O
pos	int
,	O
rot	int
)	O
]	O
)	O
;	O
else	O
if	O
(	O
p	*(char)
[	O
pos	int
]	O
==	O
BLACK	int
)	O
hashdata_xor	O
(	O
hd_rot	struct(array(long))
,	O
black_hash	array(struct(array(long)))
[	O
rotate1	(int,int)->(int)
(	O
pos	int
,	O
rot	int
)	O
]	O
)	O
;	O
}	O
if	O
(	O
ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_xor	O
(	O
hd_rot	struct(array(long))
,	O
ko_hash	array(struct(array(long)))
[	O
rotate1	(int,int)->(int)
(	O
ko_pos	int
,	O
rot	int
)	O
]	O
)	O
;	O
if	O
(	O
rot	int
==	O
0	int
||	O
hashdata_is_smaller	O
(	O
hd_rot	struct(array(long))
,	O
*	O
hd	*(struct(array(long)))
)	O
)	O
*	O
hd	*(struct(array(long)))
=	O
hd_rot	struct(array(long))
;	O
}	O
}	O
Hash_data	struct(array(long))
goal_to_hashvalue	(*(char))->(struct(array(long)))
(	O
const	O
signed	O
char	O
*	O
goal	*(char)
)	O
{	O
int	O
pos	int
;	O
Hash_data	struct(array(long))
return_value	struct(array(long))
;	O
hashdata_clear	(*(struct(array(long))))->(void)
(	O
&	O
return_value	struct(array(long))
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
goal	*(char)
[	O
pos	int
]	O
)	O
hashdata_xor	O
(	O
return_value	struct(array(long))
,	O
goal_hash	array(struct(array(long)))
[	O
pos	int
]	O
)	O
;	O
return	O
return_value	struct(array(long))
;	O
}	O
char	O
*	O
hashdata_to_string	(*(struct(array(long))))->(*(char))
(	O
Hash_data	struct(array(long))
*	O
hashdata	*(struct(array(long)))
)	O
{	O
static	O
char	O
buffer	array(char)
[	O
BUFFER_SIZE	O
]	O
;	O
int	O
n	int
=	O
0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
NUM_HASHVALUES	O
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
n	int
+=	O
sprintf	(*(char),*(char))->(int)
(	O
buffer	array(char)
+	O
n	int
,	O
HASHVALUE_PRINT_FORMAT	*(char)
,	O
HASHVALUE_NUM_DIGITS	O
,	O
hashdata	*(struct(array(long)))
->	O
hashval	array(long)
[	O
k	int
]	O
)	O
;	O
gg_assert	O
(	O
n	int
<	O
BUFFER_SIZE	O
)	O
;	O
}	O
return	O
buffer	array(char)
;	O
}	O
