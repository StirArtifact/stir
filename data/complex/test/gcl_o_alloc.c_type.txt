static	O
int	O
t_from_type	()->(int)
(	O
object	O
)	O
;	O
DEFVAR	()->(int)
(	O
"*AFTER-GBC-HOOK*"	*(char)
,	O
sSAafter_gbc_hookA	O
,	O
SI	O
,	O
sLnil	O
,	O
""	*(char)
)	O
;	O
DEFVAR	()->(int)
(	O
"*IGNORE-MAXIMUM-PAGES*"	*(char)
,	O
sSAignore_maximum_pagesA	O
,	O
SI	O
,	O
sLt	O
,	O
""	*(char)
)	O
;	O
static	O
void	O
call_after_gbc_hook	(int)->(void)
(	O
int	O
t	int
)	O
;	O
long	O
starting_hole_div	long
=	O
10	int
;	O
long	O
starting_relb_heap_mult	long
=	O
2	int
;	O
long	O
new_holepage	long
;	O
long	O
resv_pages	long
=	O
40	int
;	O
inline	O
void	O
add_page_to_contblock_list	(*(void),int)->(void)
(	O
void	O
*	O
p	*(void)
,	O
fixnum	int
m	int
)	O
{	O
struct	O
pageinfo	()->(int)
*	O
pp	*(struct)
=	O
pageinfo	()->(int)
(	O
p	*(void)
)	O
;	O
bzero	(*(void),long)->(void)
(	O
pp	*(struct)
,	O
sizeof	O
(	O
*	O
pp	*(struct)
)	O
)	O
;	O
pp	*(struct)
->	O
type	int
=	O
t_contiguous	O
;	O
pp	*(struct)
->	O
in_use	O
=	O
m	int
;	O
massert	()->(int)
(	O
pp	*(struct)
->	O
in_use	O
==	O
m	int
)	O
;	O
pp	*(struct)
->	O
magic	O
=	O
PAGE_MAGIC	O
;	O
if	O
(	O
contblock_list_head	*(struct)
==	O
NULL	O
)	O
contblock_list_tail	*(struct)
=	O
contblock_list_head	*(struct)
=	O
p	*(void)
;	O
else	O
if	O
(	O
pp	*(struct)
>	O
contblock_list_tail	*(struct)
)	O
{	O
contblock_list_tail	*(struct)
->	O
next	O
=	O
p	*(void)
;	O
contblock_list_tail	*(struct)
=	O
p	*(void)
;	O
}	O
bzero	(*(void),long)->(void)
(	O
pagetochar	()->(int)
(	O
page	()->(int)
(	O
pp	*(struct)
)	O
)	O
,	O
CB_DATA_START	()->(int)
(	O
pp	*(struct)
)	O
-	O
(	O
void	O
*	O
)	O
pagetochar	()->(int)
(	O
page	()->(int)
(	O
pp	*(struct)
)	O
)	O
)	O
;	O
ncbpage	O
+=	O
m	int
;	O
insert_contblock	()->(int)
(	O
CB_DATA_START	()->(int)
(	O
pp	*(struct)
)	O
,	O
CB_DATA_END	()->(int)
(	O
pp	*(struct)
)	O
-	O
CB_DATA_START	()->(int)
(	O
pp	*(struct)
)	O
)	O
;	O
}	O
int	O
icomp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
v1	*(void)
,	O
const	O
void	O
*	O
v2	*(void)
)	O
{	O
const	O
fixnum	int
*	O
f1	*(int)
=	O
v1	*(void)
,	O
*	O
f2	O
=	O
v2	*(void)
;	O
return	O
*	O
f1	*(int)
<	O
*	O
f2	O
?	O
-	O
1	int
:	O
*	O
f1	*(int)
==	O
*	O
f2	O
?	O
0	int
:	O
+	O
1	int
;	O
}	O
inline	O
void	O
maybe_reallocate_page	(*(struct),int)->(void)
(	O
struct	O
typemanager	O
*	O
ntm	*(struct)
,	O
ufixnum	O
count	int
)	O
{	O
void	O
*	O
*	O
y	*(*(void))
,	O
*	O
*	O
n	*(*(void))
;	O
fixnum	int
*	O
pp	*(struct)
,	O
*	O
pp1	O
,	O
*	O
ppe	O
,	O
yp	O
;	O
struct	O
typemanager	O
*	O
tm	*(struct)
;	O
fixnum	int
i	long
,	O
j	int
,	O
e	*(void)
[	O
t_end	O
]	O
;	O
struct	O
pageinfo	()->(int)
*	O
v	*(struct)
;	O
massert	()->(int)
(	O
pp1	O
=	O
pp	*(struct)
=	O
alloca	(long)->(*(void))
(	O
count	int
*	O
sizeof	O
(	O
*	O
pp1	O
)	O
)	O
)	O
;	O
ppe	O
=	O
pp1	O
+	O
count	int
;	O
for	O
(	O
v	*(struct)
=	O
cell_list_head	*(struct)
;	O
v	*(struct)
&&	O
pp	*(struct)
<	O
ppe	O
;	O
v	*(struct)
=	O
v	*(struct)
->	O
next	O
)	O
{	O
if	O
(	O
v	*(struct)
->	O
type	int
>=	O
t_end	O
||	O
(	O
tm	*(struct)
=	O
tm_of	()->(int)
(	O
v	*(struct)
->	O
type	int
)	O
)	O
==	O
ntm	*(struct)
||	O
v	*(struct)
->	O
in_use	O
)	O
continue	O
;	O
count	int
--	O
;	O
*	O
pp	*(struct)
++	O
=	O
page	()->(int)
(	O
v	*(struct)
)	O
;	O
}	O
ppe	O
=	O
pp	*(struct)
;	O
bzero	(*(void),long)->(void)
(	O
e	*(void)
,	O
sizeof	O
(	O
e	*(void)
)	O
)	O
;	O
for	O
(	O
pp	*(struct)
=	O
pp1	O
;	O
pp	*(struct)
<	O
ppe	O
;	O
pp	*(struct)
++	O
)	O
e	*(void)
[	O
pagetoinfo	()->(int)
(	O
*	O
pp	*(struct)
)	O
->	O
type	int
]	O
++	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
sizeof	O
(	O
e	*(void)
)	O
/	O
sizeof	O
(	O
*	O
e	*(void)
)	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
!	O
e	*(void)
[	O
i	long
]	O
)	O
continue	O
;	O
tm	*(struct)
=	O
tm_of	()->(int)
(	O
i	long
)	O
;	O
tm	*(struct)
->	O
tm_nfree	O
-=	O
(	O
j	int
=	O
tm	*(struct)
->	O
tm_nppage	O
*	O
e	*(void)
[	O
i	long
]	O
)	O
;	O
tm	*(struct)
->	O
tm_npage	O
-=	O
e	*(void)
[	O
i	long
]	O
;	O
set_tm_maxpage	()->(int)
(	O
tm	*(struct)
,	O
tm	*(struct)
->	O
tm_maxpage	O
-	O
e	*(void)
[	O
i	long
]	O
)	O
;	O
set_tm_maxpage	()->(int)
(	O
ntm	*(struct)
,	O
ntm	*(struct)
->	O
tm_maxpage	O
+	O
e	*(void)
[	O
i	long
]	O
)	O
;	O
for	O
(	O
y	*(*(void))
=	O
(	O
void	O
*	O
)	O
&	O
tm	*(struct)
->	O
tm_free	O
;	O
*	O
y	*(*(void))
!=	O
OBJNULL	O
&&	O
j	int
;	O
)	O
{	O
for	O
(	O
;	O
*	O
y	*(*(void))
!=	O
OBJNULL	O
&&	O
(	O
yp	O
=	O
page	()->(int)
(	O
*	O
y	*(*(void))
)	O
)	O
&&	O
!	O
FREE_PAGE_P	O
(	O
yp	O
)	O
;	O
y	*(*(void))
=	O
NEXT_LINK	O
(	O
y	*(*(void))
)	O
)	O
;	O
if	O
(	O
*	O
y	*(*(void))
!=	O
OBJNULL	O
)	O
{	O
for	O
(	O
n	*(*(void))
=	O
NEXT_LINK	O
(	O
y	*(*(void))
)	O
,	O
j	int
--	O
;	O
*	O
n	*(*(void))
!=	O
OBJNULL	O
&&	O
(	O
yp	O
=	O
page	()->(int)
(	O
*	O
n	*(*(void))
)	O
)	O
&&	O
FREE_PAGE_P	O
(	O
yp	O
)	O
;	O
n	*(*(void))
=	O
NEXT_LINK	O
(	O
n	*(*(void))
)	O
,	O
j	int
--	O
)	O
;	O
*	O
y	*(*(void))
=	O
*	O
n	*(*(void))
;	O
}	O
}	O
massert	()->(int)
(	O
!	O
j	int
)	O
;	O
}	O
for	O
(	O
pp	*(struct)
=	O
pp1	O
;	O
pp	*(struct)
<	O
ppe	O
;	O
pp	*(struct)
++	O
)	O
{	O
struct	O
pageinfo	()->(int)
*	O
pn	*(struct)
=	O
pagetoinfo	()->(int)
(	O
*	O
pp	*(struct)
)	O
->	O
next	O
;	O
add_page_to_freelist	()->(int)
(	O
pagetochar	()->(int)
(	O
*	O
pp	*(struct)
)	O
,	O
ntm	*(struct)
)	O
;	O
pagetoinfo	()->(int)
(	O
*	O
pp	*(struct)
)	O
->	O
next	O
=	O
pn	*(struct)
;	O
}	O
}	O
int	O
reserve_pages_for_signal_handler	int
=	O
30	int
;	O
inline	O
void	O
*	O
alloc_page	(long)->(*(void))
(	O
long	O
n	*(*(void))
)	O
{	O
void	O
*	O
e	*(void)
=	O
heap_end	O
;	O
fixnum	int
d	int
,	O
m	int
;	O
if	O
(	O
n	*(*(void))
>=	O
0	int
)	O
{	O
if	O
(	O
n	*(*(void))
>	O
(	O
holepage	O
-	O
(	O
in_signal_handler	O
?	O
0	int
:	O
available_pages	O
-	O
n	*(*(void))
<=	O
reserve_pages_for_signal_handler	int
?	O
0	int
:	O
reserve_pages_for_signal_handler	int
)	O
)	O
)	O
{	O
if	O
(	O
in_signal_handler	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Cant do relocatable gc in signal handler. Try to allocate more space to save for allocation during signals: eg to add 20 more do (si::set-hole-size %ld %d)\n...start over "	*(char)
,	O
new_holepage	long
,	O
20	int
+	O
reserve_pages_for_signal_handler	int
)	O
;	O
fflush	()->(int)
(	O
stderr	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
d	int
=	O
available_pages	O
-	O
n	*(*(void))
;	O
d	int
*=	O
0.2	int
;	O
d	int
=	O
d	int
<	O
0.01	int
*	O
real_maxpage	O
?	O
available_pages	O
-	O
n	*(*(void))
:	O
d	int
;	O
d	int
=	O
d	int
<	O
0	int
?	O
0	int
:	O
d	int
;	O
d	int
=	O
new_holepage	long
<	O
d	int
?	O
new_holepage	long
:	O
d	int
;	O
holepage	O
=	O
d	int
+	O
n	*(*(void))
;	O
GBC	()->(int)
(	O
t_relocatable	O
)	O
;	O
tm_table	O
[	O
t_relocatable	O
]	O
.	O
tm_adjgbccnt	O
--	O
;	O
}	O
holepage	O
-=	O
n	*(*(void))
;	O
if	O
(	O
heap_end	O
==	O
core_end	O
)	O
{	O
sbrk	(long)->(*(void))
(	O
PAGESIZE	O
*	O
n	*(*(void))
)	O
;	O
core_end	O
+=	O
PAGESIZE	O
*	O
n	*(*(void))
;	O
}	O
heap_end	O
+=	O
PAGESIZE	O
*	O
n	*(*(void))
;	O
return	O
(	O
e	*(void)
)	O
;	O
}	O
n	*(*(void))
=	O
-	O
n	*(*(void))
;	O
m	int
=	O
(	O
core_end	O
-	O
heap_end	O
)	O
/	O
PAGESIZE	O
;	O
if	O
(	O
n	*(*(void))
<=	O
m	int
)	O
return	O
(	O
e	*(void)
)	O
;	O
IF_ALLOCATE_ERR	O
error	O
(	O
"Can't allocate.  Good-bye!"	*(char)
)	O
;	O
core_end	O
+=	O
PAGESIZE	O
*	O
(	O
n	*(*(void))
-	O
m	int
)	O
;	O
return	O
(	O
e	*(void)
)	O
;	O
}	O
struct	O
pageinfo	()->(int)
*	O
cell_list_head	*(struct)
=	O
NULL	O
,	O
*	O
cell_list_tail	*(struct)
=	O
NULL	O
;	O
;	O
inline	O
fixnum	int
set_tm_maxpage	()->(int)
(	O
struct	O
typemanager	O
*	O
tm	*(struct)
,	O
fixnum	int
n	*(*(void))
)	O
{	O
fixnum	int
r	double
=	O
tm	*(struct)
->	O
tm_type	O
==	O
t_relocatable	O
,	O
j	int
=	O
tm	*(struct)
->	O
tm_maxpage	O
,	O
z	double
=	O
(	O
n	*(*(void))
-	O
j	int
)	O
*	O
(	O
r	double
?	O
2	int
:	O
1	int
)	O
;	O
if	O
(	O
z	double
>	O
available_pages	O
)	O
return	O
0	int
;	O
if	O
(	O
r	double
&&	O
2	int
*	O
n	*(*(void))
+	O
page	()->(int)
(	O
REAL_RB_START	O
)	O
>	O
real_maxpage	O
)	O
return	O
0	int
;	O
available_pages	O
-=	O
z	double
;	O
tm	*(struct)
->	O
tm_adjgbccnt	O
*=	O
(	O
(	O
double	O
)	O
j	int
)	O
/	O
n	*(*(void))
;	O
tm	*(struct)
->	O
tm_maxpage	O
=	O
n	*(*(void))
;	O
return	O
n	*(*(void))
;	O
}	O
inline	O
void	O
add_page_to_freelist	()->(int)
(	O
char	O
*	O
p	*(void)
,	O
struct	O
typemanager	O
*	O
tm	*(struct)
)	O
{	O
short	O
t	int
,	O
size	short
;	O
long	O
i	long
=	O
tm	*(struct)
->	O
tm_nppage	O
,	O
fw	long
;	O
object	O
x	double
,	O
f	O
;	O
struct	O
pageinfo	()->(int)
*	O
pp	*(struct)
;	O
t	int
=	O
tm	*(struct)
->	O
tm_type	O
;	O
size	short
=	O
tm	*(struct)
->	O
tm_size	O
;	O
f	O
=	O
tm	*(struct)
->	O
tm_free	O
;	O
pp	*(struct)
=	O
pageinfo	()->(int)
(	O
p	*(void)
)	O
;	O
bzero	(*(void),long)->(void)
(	O
pp	*(struct)
,	O
sizeof	O
(	O
*	O
pp	*(struct)
)	O
)	O
;	O
pp	*(struct)
->	O
type	int
=	O
t	int
;	O
pp	*(struct)
->	O
magic	O
=	O
PAGE_MAGIC	O
;	O
if	O
(	O
cell_list_head	*(struct)
==	O
NULL	O
)	O
cell_list_tail	*(struct)
=	O
cell_list_head	*(struct)
=	O
pp	*(struct)
;	O
else	O
if	O
(	O
pp	*(struct)
>	O
cell_list_tail	*(struct)
)	O
{	O
cell_list_tail	*(struct)
->	O
next	O
=	O
pp	*(struct)
;	O
cell_list_tail	*(struct)
=	O
pp	*(struct)
;	O
}	O
x	double
=	O
(	O
object	O
)	O
pagetochar	()->(int)
(	O
page	()->(int)
(	O
p	*(void)
)	O
)	O
;	O
make_free	()->(int)
(	O
x	double
)	O
;	O
fw	long
=	O
*	O
(	O
fixnum	int
*	O
)	O
x	double
;	O
while	O
(	O
--	O
i	long
>=	O
0	int
)	O
{	O
*	O
(	O
fixnum	int
*	O
)	O
x	double
=	O
fw	long
;	O
SET_LINK	()->(int)
(	O
x	double
,	O
f	O
)	O
;	O
f	O
=	O
x	double
;	O
x	double
=	O
(	O
object	O
)	O
(	O
(	O
char	O
*	O
)	O
x	double
+	O
size	short
)	O
;	O
}	O
tm	*(struct)
->	O
tm_free	O
=	O
f	O
;	O
tm	*(struct)
->	O
tm_nfree	O
+=	O
tm	*(struct)
->	O
tm_nppage	O
;	O
tm	*(struct)
->	O
tm_npage	O
++	O
;	O
}	O
object	O
type_name	(int)->(int)
(	O
int	O
t	int
)	O
{	O
return	O
make_simple_string	()->(int)
(	O
tm_table	O
[	O
(	O
int	O
)	O
t	int
]	O
.	O
tm_name	O
+	O
1	int
)	O
;	O
}	O
static	O
void	O
call_after_gbc_hook	(int)->(void)
(	O
t	int
)	O
{	O
if	O
(	O
sSAafter_gbc_hookA	O
&&	O
sSAafter_gbc_hookA	O
->	O
s	int
.	O
s_dbind	O
!=	O
Cnil	O
)	O
{	O
set_up_string_register	()->(int)
(	O
tm_table	O
[	O
(	O
int	O
)	O
t	int
]	O
.	O
tm_name	O
+	O
1	int
)	O
;	O
ifuncall1	()->(int)
(	O
sSAafter_gbc_hookA	O
->	O
s	int
.	O
s_dbind	O
,	O
intern	()->(int)
(	O
string_register	O
,	O
system_package	O
)	O
)	O
;	O
}	O
}	O
static	O
fixnum	int
grow_linear	(int,int,int,int,int)->(int)
(	O
fixnum	int
old	int
,	O
fixnum	int
fract	int
,	O
fixnum	int
grow_min	int
,	O
fixnum	int
grow_max	int
,	O
fixnum	int
max_delt	int
)	O
{	O
fixnum	int
delt	O
;	O
delt	O
=	O
(	O
old	int
*	O
(	O
fract	int
?	O
fract	int
:	O
50	int
)	O
)	O
/	O
100	int
;	O
delt	O
=	O
(	O
grow_min	int
&&	O
delt	O
<	O
grow_min	int
?	O
grow_min	int
:	O
grow_max	int
&&	O
delt	O
>	O
grow_max	int
?	O
grow_max	int
:	O
delt	O
)	O
;	O
delt	O
=	O
delt	O
>	O
max_delt	int
?	O
max_delt	int
:	O
delt	O
;	O
return	O
old	int
+	O
delt	O
;	O
}	O
DEFVAR	()->(int)
(	O
"*OPTIMIZE-MAXIMUM-PAGES*"	*(char)
,	O
sSAoptimize_maximum_pagesA	O
,	O
SI	O
,	O
sLnil	O
,	O
""	*(char)
)	O
;	O
DEFVAR	()->(int)
(	O
"*NOTIFY-OPTIMIZE-MAXIMUM-PAGES*"	*(char)
,	O
sSAnotify_optimize_maximum_pagesA	O
,	O
SI	O
,	O
sLnil	O
,	O
""	*(char)
)	O
;	O
inline	O
long	O
opt_maxpage	(*(struct))->(long)
(	O
struct	O
typemanager	O
*	O
my_tm	*(struct)
)	O
{	O
double	O
x	double
=	O
0.0	int
,	O
y	*(*(void))
=	O
0.0	int
,	O
z	double
,	O
r	double
;	O
long	O
mmax_page	long
;	O
struct	O
typemanager	O
*	O
tm	*(struct)
,	O
*	O
tme	*(struct)
;	O
long	O
mro	long
=	O
0	int
,	O
tro	long
=	O
0	int
;	O
if	O
(	O
phys_pages	O
>	O
0	int
&&	O
page	()->(int)
(	O
heap_end	O
)	O
-	O
first_data_page	O
+	O
nrbpage	O
>=	O
phys_pages	O
)	O
return	O
0	int
;	O
if	O
(	O
page	()->(int)
(	O
core_end	O
)	O
>	O
0.8	int
*	O
real_maxpage	O
)	O
return	O
0	int
;	O
for	O
(	O
tm	*(struct)
=	O
tm_table	O
,	O
tme	*(struct)
=	O
tm	*(struct)
+	O
sizeof	O
(	O
tm_table	O
)	O
/	O
sizeof	O
(	O
*	O
tm_table	O
)	O
;	O
tm	*(struct)
<	O
tme	*(struct)
;	O
tm	*(struct)
++	O
)	O
{	O
x	double
+=	O
tm	*(struct)
->	O
tm_adjgbccnt	O
;	O
y	*(*(void))
+=	O
MMAX_PG	O
(	O
tm	*(struct)
)	O
;	O
}	O
mmax_page	long
=	O
MMAX_PG	O
(	O
my_tm	*(struct)
)	O
;	O
z	double
=	O
my_tm	*(struct)
->	O
tm_adjgbccnt	O
-	O
1	int
;	O
z	double
/=	O
(	O
1	int
+	O
x	double
-	O
0.9	int
*	O
my_tm	*(struct)
->	O
tm_adjgbccnt	O
)	O
;	O
z	double
*=	O
(	O
y	*(*(void))
-	O
mmax_page	long
)	O
*	O
mmax_page	long
;	O
z	double
=	O
sqrt	O
(	O
z	double
)	O
;	O
z	double
=	O
z	double
-	O
mmax_page	long
>	O
available_pages	O
?	O
mmax_page	long
+	O
available_pages	O
:	O
z	double
;	O
my_tm	*(struct)
->	O
tm_opt_maxpage	O
=	O
(	O
long	O
)	O
z	double
>	O
my_tm	*(struct)
->	O
tm_opt_maxpage	O
?	O
(	O
long	O
)	O
z	double
:	O
my_tm	*(struct)
->	O
tm_opt_maxpage	O
;	O
if	O
(	O
z	double
<=	O
mmax_page	long
)	O
return	O
0	int
;	O
r	double
=	O
(	O
(	O
x	double
-	O
my_tm	*(struct)
->	O
tm_adjgbccnt	O
)	O
+	O
my_tm	*(struct)
->	O
tm_adjgbccnt	O
*	O
mmax_page	long
/	O
z	double
)	O
*	O
(	O
y	*(*(void))
-	O
mmax_page	long
+	O
z	double
)	O
;	O
r	double
/=	O
x	double
*	O
y	*(*(void))
;	O
if	O
(	O
sSAnotify_optimize_maximum_pagesA	O
->	O
s	int
.	O
s_dbind	O
!=	O
sLnil	O
)	O
printf	O
(	O
"[type %u max %lu(%lu) opt %lu   y %lu(%lu) gbcrat %f sav %f]\n"	*(char)
,	O
my_tm	*(struct)
->	O
tm_type	O
,	O
mmax_page	long
,	O
mro	long
,	O
(	O
long	O
)	O
z	double
,	O
(	O
long	O
)	O
y	*(*(void))
,	O
tro	long
,	O
(	O
my_tm	*(struct)
->	O
tm_adjgbccnt	O
-	O
1	int
)	O
/	O
(	O
1	int
+	O
x	double
-	O
0.9	int
*	O
my_tm	*(struct)
->	O
tm_adjgbccnt	O
)	O
,	O
r	double
)	O
;	O
return	O
r	double
<=	O
0.95	int
&&	O
set_tm_maxpage	()->(int)
(	O
my_tm	*(struct)
,	O
z	double
+	O
mro	long
)	O
?	O
1	int
:	O
0	int
;	O
}	O
static	O
object	O
exhausted_report	(enum,*(struct))->(int)
(	O
enum	O
type	int
t	int
,	O
struct	O
typemanager	O
*	O
tm	*(struct)
)	O
{	O
available_pages	O
+=	O
resv_pages	long
;	O
resv_pages	long
=	O
0	int
;	O
vs_push	()->(int)
(	O
type_name	(int)->(int)
(	O
t	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
tm	*(struct)
->	O
tm_npage	O
)	O
)	O
;	O
CEerror	()->(int)
(	O
"The storage for ~A is exhausted.~%Currently, ~D pages are allocated.~%	     Use ALLOCATE to expand the space."	*(char)
,	O
"Continues execution."	*(char)
,	O
2	int
,	O
vs_top	O
[	O
-	O
2	int
]	O
,	O
vs_top	O
[	O
-	O
1	int
]	O
,	O
Cnil	O
,	O
Cnil	O
)	O
;	O
vs_popp	O
;	O
vs_popp	O
;	O
call_after_gbc_hook	(int)->(void)
(	O
t	int
)	O
;	O
return	O
alloc_object	()->(int)
(	O
t	int
)	O
;	O
}	O
bool	O
prefer_low_mem_contblock	int
=	O
FALSE	O
;	O
inline	O
void	O
*	O
alloc_from_freelist	(*(struct),int)->(*(void))
(	O
struct	O
typemanager	O
*	O
tm	*(struct)
,	O
fixnum	int
n	*(*(void))
)	O
{	O
void	O
*	O
p	*(void)
,	O
*	O
v	*(struct)
,	O
*	O
vp	*(void)
;	O
struct	O
contblock	O
*	O
*	O
cbpp	*(*(struct))
;	O
fixnum	int
i	long
;	O
switch	O
(	O
tm	*(struct)
->	O
tm_type	O
)	O
{	O
case	O
t_contiguous	O
:	O
for	O
(	O
cbpp	*(*(struct))
=	O
&	O
cb_pointer	O
,	O
v	*(struct)
=	O
(	O
void	O
*	O
)	O
-	O
1	int
,	O
vp	*(void)
=	O
NULL	O
;	O
(	O
*	O
cbpp	*(*(struct))
)	O
!=	O
NULL	O
;	O
cbpp	*(*(struct))
=	O
&	O
(	O
*	O
cbpp	*(*(struct))
)	O
->	O
cb_link	O
)	O
if	O
(	O
(	O
*	O
cbpp	*(*(struct))
)	O
->	O
cb_size	O
>=	O
n	*(*(void))
)	O
{	O
if	O
(	O
!	O
prefer_low_mem_contblock	int
)	O
{	O
vp	*(void)
=	O
cbpp	*(*(struct))
;	O
break	O
;	O
}	O
else	O
if	O
(	O
(	O
void	O
*	O
)	O
(	O
*	O
cbpp	*(*(struct))
)	O
<	O
v	*(struct)
)	O
{	O
v	*(struct)
=	O
*	O
cbpp	*(*(struct))
;	O
vp	*(void)
=	O
cbpp	*(*(struct))
;	O
}	O
}	O
if	O
(	O
vp	*(void)
)	O
{	O
cbpp	*(*(struct))
=	O
vp	*(void)
;	O
p	*(void)
=	O
(	O
void	O
*	O
)	O
(	O
*	O
cbpp	*(*(struct))
)	O
;	O
i	long
=	O
(	O
*	O
cbpp	*(*(struct))
)	O
->	O
cb_size	O
-	O
n	*(*(void))
;	O
*	O
cbpp	*(*(struct))
=	O
(	O
*	O
cbpp	*(*(struct))
)	O
->	O
cb_link	O
;	O
--	O
ncb	O
;	O
insert_contblock	()->(int)
(	O
p	*(void)
+	O
n	*(*(void))
,	O
i	long
)	O
;	O
return	O
(	O
p	*(void)
)	O
;	O
}	O
break	O
;	O
case	O
t_relocatable	O
:	O
if	O
(	O
rb_limit	O
-	O
rb_pointer	O
>=	O
n	*(*(void))
)	O
return	O
(	O
(	O
rb_pointer	O
+=	O
n	*(*(void))
)	O
-	O
n	*(*(void))
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
p	*(void)
=	O
tm	*(struct)
->	O
tm_free	O
)	O
!=	O
OBJNULL	O
)	O
{	O
tm	*(struct)
->	O
tm_free	O
=	O
OBJ_LINK	()->(int)
(	O
p	*(void)
)	O
;	O
tm	*(struct)
->	O
tm_nfree	O
--	O
;	O
return	O
(	O
p	*(void)
)	O
;	O
}	O
break	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
inline	O
void	O
grow_linear1	(*(struct))->(void)
(	O
struct	O
typemanager	O
*	O
tm	*(struct)
)	O
{	O
fixnum	int
maxgro	O
=	O
resv_pages	long
?	O
available_pages	O
:	O
0	int
;	O
if	O
(	O
tm	*(struct)
->	O
tm_type	O
==	O
t_relocatable	O
)	O
maxgro	O
>>=	O
1	int
;	O
set_tm_maxpage	()->(int)
(	O
tm	*(struct)
,	O
grow_linear	(int,int,int,int,int)->(int)
(	O
tm	*(struct)
->	O
tm_npage	O
,	O
tm	*(struct)
->	O
tm_growth_percent	O
,	O
tm	*(struct)
->	O
tm_min_grow	O
,	O
tm	*(struct)
->	O
tm_max_grow	O
,	O
maxgro	O
)	O
)	O
;	O
}	O
static	O
inline	O
int	O
too_full_p	(*(struct))->(int)
(	O
struct	O
typemanager	O
*	O
tm	*(struct)
)	O
{	O
fixnum	int
j	int
,	O
k	O
,	O
pf	O
=	O
tm	*(struct)
->	O
tm_percent_free	O
?	O
tm	*(struct)
->	O
tm_percent_free	O
:	O
30	int
;	O
struct	O
contblock	O
*	O
cbp	*(struct)
;	O
struct	O
pageinfo	()->(int)
*	O
pi	*(struct)
;	O
switch	O
(	O
tm	*(struct)
->	O
tm_type	O
)	O
{	O
case	O
t_relocatable	O
:	O
return	O
100	int
*	O
(	O
rb_limit	O
-	O
rb_pointer	O
)	O
<	O
pf	O
*	O
(	O
rb_limit	O
-	O
rb_start	O
)	O
;	O
break	O
;	O
case	O
t_contiguous	O
:	O
for	O
(	O
cbp	*(struct)
=	O
cb_pointer	O
,	O
k	O
=	O
0	int
;	O
cbp	*(struct)
;	O
cbp	*(struct)
=	O
cbp	*(struct)
->	O
cb_link	O
)	O
k	O
+=	O
cbp	*(struct)
->	O
cb_size	O
;	O
for	O
(	O
pi	*(struct)
=	O
contblock_list_head	*(struct)
,	O
j	int
=	O
0	int
;	O
pi	*(struct)
;	O
pi	*(struct)
=	O
pi	*(struct)
->	O
next	O
)	O
j	int
+=	O
pi	*(struct)
->	O
in_use	O
;	O
return	O
100	int
*	O
k	O
<	O
pf	O
*	O
j	int
*	O
PAGESIZE	O
;	O
break	O
;	O
default	O
:	O
return	O
100	int
*	O
tm	*(struct)
->	O
tm_nfree	O
<	O
pf	O
*	O
TOTAL_THIS_TYPE	O
(	O
tm	*(struct)
)	O
;	O
break	O
;	O
}	O
}	O
inline	O
void	O
*	O
alloc_after_gc	(*(struct),int)->(*(void))
(	O
struct	O
typemanager	O
*	O
tm	*(struct)
,	O
fixnum	int
n	*(*(void))
)	O
{	O
if	O
(	O
tm	*(struct)
->	O
tm_npage	O
+	O
tpage	()->(int)
(	O
tm	*(struct)
,	O
n	*(*(void))
)	O
>=	O
tm	*(struct)
->	O
tm_maxpage	O
&&	O
GBC_enable	O
)	O
{	O
switch	O
(	O
jmp_gmp	O
)	O
{	O
case	O
0	int
:	O
GBC	()->(int)
(	O
tm	*(struct)
->	O
tm_type	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
longjmp	()->(int)
(	O
gmp_jmp	O
,	O
tm	*(struct)
->	O
tm_type	O
)	O
;	O
break	O
;	O
case	O
-	O
1	int
:	O
jmp_gmp	O
=	O
-	O
tm	*(struct)
->	O
tm_type	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
IGNORE_MAX_PAGES	O
&&	O
too_full_p	(*(struct))->(int)
(	O
tm	*(struct)
)	O
)	O
grow_linear1	(*(struct))->(void)
(	O
tm	*(struct)
)	O
;	O
call_after_gbc_hook	(int)->(void)
(	O
tm	*(struct)
->	O
tm_type	O
)	O
;	O
return	O
alloc_from_freelist	(*(struct),int)->(*(void))
(	O
tm	*(struct)
,	O
n	*(*(void))
)	O
;	O
}	O
else	O
return	O
NULL	O
;	O
}	O
struct	O
pageinfo	()->(int)
*	O
contblock_list_head	*(struct)
=	O
NULL	O
,	O
*	O
contblock_list_tail	*(struct)
=	O
NULL	O
;	O
inline	O
void	O
add_pages	(*(struct),int)->(void)
(	O
struct	O
typemanager	O
*	O
tm	*(struct)
,	O
fixnum	int
m	int
)	O
{	O
switch	O
(	O
tm	*(struct)
->	O
tm_type	O
)	O
{	O
case	O
t_contiguous	O
:	O
add_page_to_contblock_list	(*(void),int)->(void)
(	O
alloc_page	(long)->(*(void))
(	O
m	int
)	O
,	O
m	int
)	O
;	O
break	O
;	O
case	O
t_relocatable	O
:	O
nrbpage	O
+=	O
m	int
;	O
rb_end	O
=	O
heap_end	O
+	O
(	O
holepage	O
+	O
nrbpage	O
)	O
*	O
PAGESIZE	O
;	O
rb_limit	O
=	O
rb_end	O
-	O
2	int
*	O
RB_GETA	O
;	O
alloc_page	(long)->(*(void))
(	O
-	O
(	O
nrbpage	O
+	O
holepage	O
)	O
)	O
;	O
break	O
;	O
default	O
:	O
{	O
void	O
*	O
p	*(void)
=	O
alloc_page	(long)->(*(void))
(	O
m	int
)	O
,	O
*	O
pe	*(void)
=	O
p	*(void)
+	O
m	int
*	O
PAGESIZE	O
;	O
for	O
(	O
;	O
p	*(void)
<	O
pe	*(void)
;	O
p	*(void)
+=	O
PAGESIZE	O
)	O
add_page_to_freelist	()->(int)
(	O
p	*(void)
,	O
tm	*(struct)
)	O
;	O
}	O
break	O
;	O
}	O
}	O
inline	O
void	O
*	O
alloc_after_adding_pages	(*(struct),int)->(*(void))
(	O
struct	O
typemanager	O
*	O
tm	*(struct)
,	O
fixnum	int
n	*(*(void))
)	O
{	O
fixnum	int
m	int
=	O
tpage	()->(int)
(	O
tm	*(struct)
,	O
n	*(*(void))
)	O
;	O
if	O
(	O
tm	*(struct)
->	O
tm_npage	O
+	O
m	int
>	O
tm	*(struct)
->	O
tm_maxpage	O
)	O
{	O
if	O
(	O
!	O
IGNORE_MAX_PAGES	O
)	O
return	O
NULL	O
;	O
grow_linear1	(*(struct))->(void)
(	O
tm	*(struct)
)	O
;	O
if	O
(	O
tm	*(struct)
->	O
tm_npage	O
+	O
m	int
>	O
tm	*(struct)
->	O
tm_maxpage	O
&&	O
!	O
set_tm_maxpage	()->(int)
(	O
tm	*(struct)
,	O
tm	*(struct)
->	O
tm_npage	O
+	O
m	int
)	O
)	O
return	O
NULL	O
;	O
}	O
m	int
=	O
tm	*(struct)
->	O
tm_maxpage	O
-	O
tm	*(struct)
->	O
tm_npage	O
;	O
add_pages	(*(struct),int)->(void)
(	O
tm	*(struct)
,	O
m	int
)	O
;	O
return	O
alloc_from_freelist	(*(struct),int)->(*(void))
(	O
tm	*(struct)
,	O
n	*(*(void))
)	O
;	O
}	O
inline	O
void	O
*	O
alloc_after_reclaiming_pages	(*(struct),int)->(*(void))
(	O
struct	O
typemanager	O
*	O
tm	*(struct)
,	O
fixnum	int
n	*(*(void))
)	O
{	O
fixnum	int
m	int
=	O
tpage	()->(int)
(	O
tm	*(struct)
,	O
n	*(*(void))
)	O
,	O
reloc_min	O
;	O
if	O
(	O
tm	*(struct)
->	O
tm_type	O
>=	O
t_end	O
)	O
return	O
NULL	O
;	O
reloc_min	O
=	O
npage	()->(int)
(	O
rb_pointer	O
-	O
REAL_RB_START	O
)	O
;	O
if	O
(	O
m	int
<	O
2	int
*	O
(	O
nrbpage	O
-	O
reloc_min	O
)	O
)	O
{	O
set_tm_maxpage	()->(int)
(	O
tm_table	O
+	O
t_relocatable	O
,	O
reloc_min	O
)	O
;	O
nrbpage	O
=	O
reloc_min	O
;	O
GBC	()->(int)
(	O
t_relocatable	O
)	O
;	O
tm_table	O
[	O
t_relocatable	O
]	O
.	O
tm_adjgbccnt	O
--	O
;	O
return	O
alloc_after_adding_pages	(*(struct),int)->(*(void))
(	O
tm	*(struct)
,	O
n	*(*(void))
)	O
;	O
}	O
maybe_reallocate_page	(*(struct),int)->(void)
(	O
tm	*(struct)
,	O
tm	*(struct)
->	O
tm_percent_free	O
*	O
tm	*(struct)
->	O
tm_npage	O
)	O
;	O
return	O
alloc_from_freelist	(*(struct),int)->(*(void))
(	O
tm	*(struct)
,	O
n	*(*(void))
)	O
;	O
}	O
inline	O
void	O
*	O
alloc_mem	(*(struct),int)->(*(void))
(	O
struct	O
typemanager	O
*	O
,	O
fixnum	int
)	O
;	O
inline	O
void	O
*	O
alloc_mem	(*(struct),int)->(*(void))
(	O
struct	O
typemanager	O
*	O
tm	*(struct)
,	O
fixnum	int
n	*(*(void))
)	O
{	O
void	O
*	O
p	*(void)
;	O
CHECK_INTERRUPT	O
;	O
if	O
(	O
(	O
p	*(void)
=	O
alloc_from_freelist	(*(struct),int)->(*(void))
(	O
tm	*(struct)
,	O
n	*(*(void))
)	O
)	O
)	O
return	O
p	*(void)
;	O
if	O
(	O
(	O
p	*(void)
=	O
alloc_after_gc	(*(struct),int)->(*(void))
(	O
tm	*(struct)
,	O
n	*(*(void))
)	O
)	O
)	O
return	O
p	*(void)
;	O
if	O
(	O
(	O
p	*(void)
=	O
alloc_after_adding_pages	(*(struct),int)->(*(void))
(	O
tm	*(struct)
,	O
n	*(*(void))
)	O
)	O
)	O
return	O
p	*(void)
;	O
if	O
(	O
(	O
p	*(void)
=	O
alloc_after_reclaiming_pages	(*(struct),int)->(*(void))
(	O
tm	*(struct)
,	O
n	*(*(void))
)	O
)	O
)	O
return	O
p	*(void)
;	O
return	O
exhausted_report	(enum,*(struct))->(int)
(	O
tm	*(struct)
->	O
tm_type	O
,	O
tm	*(struct)
)	O
;	O
}	O
inline	O
object	O
alloc_object	()->(int)
(	O
enum	O
type	int
t	int
)	O
{	O
object	O
obj	O
;	O
struct	O
typemanager	O
*	O
tm	*(struct)
=	O
tm_of	()->(int)
(	O
t	int
)	O
;	O
obj	O
=	O
alloc_mem	(*(struct),int)->(*(void))
(	O
tm	*(struct)
,	O
tm	*(struct)
->	O
tm_size	O
)	O
;	O
set_type_of	()->(int)
(	O
obj	O
,	O
t	int
)	O
;	O
pageinfo	()->(int)
(	O
obj	O
)	O
->	O
in_use	O
++	O
;	O
return	O
(	O
obj	O
)	O
;	O
}	O
inline	O
void	O
*	O
alloc_contblock	(long)->(*(void))
(	O
size_t	long
n	*(*(void))
)	O
{	O
return	O
alloc_mem	(*(struct),int)->(*(void))
(	O
tm_of	()->(int)
(	O
t_contiguous	O
)	O
,	O
ROUND_UP_PTR_CONT	()->(int)
(	O
n	*(*(void))
)	O
)	O
;	O
}	O
inline	O
void	O
*	O
alloc_relblock	(long)->(*(void))
(	O
size_t	long
n	*(*(void))
)	O
{	O
return	O
alloc_mem	(*(struct),int)->(*(void))
(	O
tm_of	()->(int)
(	O
t_relocatable	O
)	O
,	O
ROUND_UP_PTR	()->(int)
(	O
n	*(*(void))
)	O
)	O
;	O
}	O
static	O
inline	O
void	O
load_cons	(int,int,int)->(void)
(	O
object	O
p	*(void)
,	O
object	O
a	int
,	O
object	O
d	int
)	O
{	O
p	*(void)
->	O
c	O
.	O
c_cdr	O
=	O
SAFE_CDR	()->(int)
(	O
d	int
)	O
;	O
p	*(void)
->	O
c	O
.	O
c_car	O
=	O
a	int
;	O
}	O
inline	O
object	O
make_cons	(int,int)->(int)
(	O
object	O
a	int
,	O
object	O
d	int
)	O
{	O
static	O
struct	O
typemanager	O
*	O
tm	*(struct)
=	O
tm_table	O
+	O
t_cons	O
;	O
object	O
obj	O
=	O
alloc_mem	(*(struct),int)->(*(void))
(	O
tm	*(struct)
,	O
tm	*(struct)
->	O
tm_size	O
)	O
;	O
load_cons	(int,int,int)->(void)
(	O
obj	O
,	O
a	int
,	O
d	int
)	O
;	O
pageinfo	()->(int)
(	O
obj	O
)	O
->	O
in_use	O
++	O
;	O
return	O
(	O
obj	O
)	O
;	O
}	O
inline	O
object	O
on_stack_cons	(int,int)->(int)
(	O
object	O
x	double
,	O
object	O
y	*(*(void))
)	O
{	O
object	O
p	*(void)
=	O
(	O
object	O
)	O
alloca_val	O
;	O
load_cons	(int,int,int)->(void)
(	O
p	*(void)
,	O
x	double
,	O
y	*(*(void))
)	O
;	O
return	O
p	*(void)
;	O
}	O
DEFUNM_NEW	()->(int)
(	O
"ALLOCATED"	*(char)
,	O
object	O
,	O
fSallocated	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
typ	O
)	O
,	O
""	*(char)
)	O
{	O
struct	O
typemanager	O
*	O
tm	*(struct)
=	O
(	O
&	O
tm_table	O
[	O
t_from_type	()->(int)
(	O
typ	O
)	O
]	O
)	O
;	O
tm	*(struct)
=	O
&	O
tm_table	O
[	O
tm	*(struct)
->	O
tm_type	O
]	O
;	O
if	O
(	O
tm	*(struct)
->	O
tm_type	O
==	O
t_relocatable	O
)	O
{	O
tm	*(struct)
->	O
tm_npage	O
=	O
(	O
rb_end	O
-	O
rb_start	O
)	O
/	O
PAGESIZE	O
;	O
tm	*(struct)
->	O
tm_nfree	O
=	O
rb_end	O
-	O
rb_pointer	O
;	O
}	O
else	O
if	O
(	O
tm	*(struct)
->	O
tm_type	O
==	O
t_contiguous	O
)	O
{	O
int	O
cbfree	int
=	O
0	int
;	O
struct	O
contblock	O
*	O
*	O
cbpp	*(*(struct))
;	O
for	O
(	O
cbpp	*(*(struct))
=	O
&	O
cb_pointer	O
;	O
(	O
*	O
cbpp	*(*(struct))
)	O
!=	O
NULL	O
;	O
cbpp	*(*(struct))
=	O
&	O
(	O
*	O
cbpp	*(*(struct))
)	O
->	O
cb_link	O
)	O
cbfree	int
+=	O
(	O
*	O
cbpp	*(*(struct))
)	O
->	O
cb_size	O
;	O
tm	*(struct)
->	O
tm_nfree	O
=	O
cbfree	int
;	O
}	O
RETURN	()->(int)
(	O
6	int
,	O
object	O
,	O
make_fixnum	()->(int)
(	O
tm	*(struct)
->	O
tm_nfree	O
)	O
,	O
(	O
RV	()->(int)
(	O
make_fixnum	()->(int)
(	O
tm	*(struct)
->	O
tm_npage	O
)	O
)	O
,	O
RV	()->(int)
(	O
make_fixnum	()->(int)
(	O
tm	*(struct)
->	O
tm_maxpage	O
)	O
)	O
,	O
RV	()->(int)
(	O
make_fixnum	()->(int)
(	O
tm	*(struct)
->	O
tm_nppage	O
)	O
)	O
,	O
RV	()->(int)
(	O
make_fixnum	()->(int)
(	O
tm	*(struct)
->	O
tm_gbccount	O
)	O
)	O
,	O
RV	()->(int)
(	O
make_fixnum	()->(int)
(	O
tm	*(struct)
->	O
tm_npage	O
*	O
tm	*(struct)
->	O
tm_nppage	O
-	O
tm	*(struct)
->	O
tm_nfree	O
)	O
)	O
)	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"PRINT-FREE-CONTBLOCK-LIST"	*(char)
,	O
object	O
,	O
fSprint_free_contblock_list	O
,	O
SI	O
,	O
0	int
,	O
0	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
void	O
)	O
,	O
""	*(char)
)	O
{	O
struct	O
contblock	O
*	O
cbp	*(struct)
,	O
*	O
cbp1	*(struct)
;	O
for	O
(	O
cbp	*(struct)
=	O
cb_pointer	O
;	O
cbp	*(struct)
;	O
cbp	*(struct)
=	O
cbp	*(struct)
->	O
cb_link	O
)	O
{	O
printf	O
(	O
"%p %d\n"	*(char)
,	O
cbp	*(struct)
,	O
cbp	*(struct)
->	O
cb_size	O
)	O
;	O
for	O
(	O
cbp1	*(struct)
=	O
cbp	*(struct)
;	O
cbp1	*(struct)
;	O
cbp1	*(struct)
=	O
cbp1	*(struct)
->	O
cb_link	O
)	O
if	O
(	O
(	O
void	O
*	O
)	O
cbp	*(struct)
+	O
cbp	*(struct)
->	O
cb_size	O
==	O
(	O
void	O
*	O
)	O
cbp1	*(struct)
||	O
(	O
void	O
*	O
)	O
cbp1	*(struct)
+	O
cbp1	*(struct)
->	O
cb_size	O
==	O
(	O
void	O
*	O
)	O
cbp	*(struct)
)	O
printf	O
(	O
"  adjacent to %p %d\n"	*(char)
,	O
cbp1	*(struct)
,	O
cbp1	*(struct)
->	O
cb_size	O
)	O
;	O
}	O
return	O
Cnil	O
;	O
}	O
void	O
insert_contblock	()->(int)
(	O
char	O
*	O
p	*(void)
,	O
int	O
s	int
)	O
{	O
struct	O
contblock	O
*	O
*	O
cbpp	*(*(struct))
,	O
*	O
cbp	*(struct)
;	O
if	O
(	O
s	int
<=	O
0	int
)	O
return	O
;	O
ncb	O
++	O
;	O
cbp	*(struct)
=	O
(	O
struct	O
contblock	O
*	O
)	O
p	*(void)
;	O
cbp	*(struct)
->	O
cb_size	O
=	O
ROUND_UP_PTR_CONT	()->(int)
(	O
s	int
)	O
;	O
for	O
(	O
cbpp	*(*(struct))
=	O
&	O
cb_pointer	O
;	O
*	O
cbpp	*(*(struct))
;	O
)	O
{	O
if	O
(	O
(	O
void	O
*	O
)	O
(	O
*	O
cbpp	*(*(struct))
)	O
+	O
(	O
*	O
cbpp	*(*(struct))
)	O
->	O
cb_size	O
==	O
(	O
void	O
*	O
)	O
cbp	*(struct)
)	O
{	O
(	O
*	O
cbpp	*(*(struct))
)	O
->	O
cb_size	O
+=	O
cbp	*(struct)
->	O
cb_size	O
;	O
cbp	*(struct)
=	O
*	O
cbpp	*(*(struct))
;	O
*	O
cbpp	*(*(struct))
=	O
(	O
*	O
cbpp	*(*(struct))
)	O
->	O
cb_link	O
;	O
}	O
else	O
if	O
(	O
(	O
void	O
*	O
)	O
(	O
*	O
cbpp	*(*(struct))
)	O
==	O
(	O
void	O
*	O
)	O
cbp	*(struct)
+	O
cbp	*(struct)
->	O
cb_size	O
)	O
{	O
cbp	*(struct)
->	O
cb_size	O
+=	O
(	O
*	O
cbpp	*(*(struct))
)	O
->	O
cb_size	O
;	O
*	O
cbpp	*(*(struct))
=	O
(	O
*	O
cbpp	*(*(struct))
)	O
->	O
cb_link	O
;	O
}	O
else	O
cbpp	*(*(struct))
=	O
&	O
(	O
*	O
cbpp	*(*(struct))
)	O
->	O
cb_link	O
;	O
}	O
s	int
=	O
cbp	*(struct)
->	O
cb_size	O
;	O
for	O
(	O
cbpp	*(*(struct))
=	O
&	O
cb_pointer	O
;	O
*	O
cbpp	*(*(struct))
;	O
cbpp	*(*(struct))
=	O
&	O
(	O
(	O
*	O
cbpp	*(*(struct))
)	O
->	O
cb_link	O
)	O
)	O
if	O
(	O
(	O
*	O
cbpp	*(*(struct))
)	O
->	O
cb_size	O
>=	O
s	int
)	O
{	O
cbp	*(struct)
->	O
cb_link	O
=	O
*	O
cbpp	*(*(struct))
;	O
*	O
cbpp	*(*(struct))
=	O
cbp	*(struct)
;	O
return	O
;	O
}	O
cbp	*(struct)
->	O
cb_link	O
=	O
NULL	O
;	O
*	O
cbpp	*(*(struct))
=	O
cbp	*(struct)
;	O
}	O
static	O
void	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
enum	O
type	int
t	int
,	O
char	O
*	O
name	*(char)
,	O
int	O
elsize	int
,	O
int	O
nelts	int
,	O
int	O
sgc	int
,	O
int	O
distinct	int
)	O
{	O
int	O
i	long
,	O
j	int
;	O
int	O
maxpage	int
;	O
maxpage	int
=	O
(	O
(	O
(	O
nelts	int
*	O
elsize	int
)	O
+	O
PAGESIZE	O
-	O
1	int
)	O
/	O
PAGESIZE	O
)	O
;	O
tm_table	O
[	O
(	O
int	O
)	O
t	int
]	O
.	O
tm_name	O
=	O
name	*(char)
;	O
j	int
=	O
-	O
1	int
;	O
if	O
(	O
!	O
distinct	int
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
t_end	O
;	O
i	long
++	O
)	O
if	O
(	O
tm_table	O
[	O
i	long
]	O
.	O
tm_size	O
!=	O
0	int
&&	O
tm_table	O
[	O
i	long
]	O
.	O
tm_size	O
>=	O
elsize	int
&&	O
!	O
tm_table	O
[	O
i	long
]	O
.	O
tm_distinct	O
&&	O
(	O
j	int
<	O
0	int
||	O
tm_table	O
[	O
j	int
]	O
.	O
tm_size	O
>	O
tm_table	O
[	O
i	long
]	O
.	O
tm_size	O
)	O
)	O
j	int
=	O
i	long
;	O
if	O
(	O
j	int
>=	O
0	int
)	O
{	O
tm_table	O
[	O
(	O
int	O
)	O
t	int
]	O
.	O
tm_type	O
=	O
(	O
enum	O
type	int
)	O
j	int
;	O
set_tm_maxpage	()->(int)
(	O
tm_table	O
+	O
j	int
,	O
tm_table	O
[	O
j	int
]	O
.	O
tm_maxpage	O
+	O
maxpage	int
)	O
;	O
return	O
;	O
}	O
tm_table	O
[	O
(	O
int	O
)	O
t	int
]	O
.	O
tm_type	O
=	O
t	int
;	O
tm_table	O
[	O
(	O
int	O
)	O
t	int
]	O
.	O
tm_size	O
=	O
elsize	int
?	O
ROUND_UP_PTR	()->(int)
(	O
elsize	int
)	O
:	O
1	int
;	O
tm_table	O
[	O
(	O
int	O
)	O
t	int
]	O
.	O
tm_nppage	O
=	O
(	O
PAGESIZE	O
-	O
sizeof	O
(	O
struct	O
pageinfo	()->(int)
)	O
)	O
/	O
tm_table	O
[	O
(	O
int	O
)	O
t	int
]	O
.	O
tm_size	O
;	O
tm_table	O
[	O
(	O
int	O
)	O
t	int
]	O
.	O
tm_free	O
=	O
OBJNULL	O
;	O
tm_table	O
[	O
(	O
int	O
)	O
t	int
]	O
.	O
tm_nfree	O
=	O
0	int
;	O
set_tm_maxpage	()->(int)
(	O
tm_table	O
+	O
t	int
,	O
maxpage	int
)	O
;	O
tm_table	O
[	O
(	O
int	O
)	O
t	int
]	O
.	O
tm_gbccount	O
=	O
0	int
;	O
tm_table	O
[	O
(	O
int	O
)	O
t	int
]	O
.	O
tm_adjgbccnt	O
=	O
0	int
;	O
tm_table	O
[	O
(	O
int	O
)	O
t	int
]	O
.	O
tm_opt_maxpage	O
=	O
0	int
;	O
tm_table	O
[	O
(	O
int	O
)	O
t	int
]	O
.	O
tm_distinct	O
=	O
distinct	int
;	O
}	O
static	O
int	O
gcl_alloc_initialized	int
;	O
object	O
malloc_list	int
=	O
Cnil	O
;	O
void	O
gcl_init_alloc	(*(void))->(void)
(	O
void	O
*	O
cs_start	*(void)
)	O
{	O
fixnum	int
cssize	O
=	O
(	O
1L	int
<<	O
23	int
)	O
;	O
prelink_init	()->(int)
(	O
)	O
;	O
cs_org	O
=	O
cs_base	O
=	O
cs_start	*(void)
;	O
cs_limit	O
=	O
cs_org	O
+	O
CSTACK_DIRECTION	O
*	O
cssize	O
;	O
install_segmentation_catcher	()->(int)
(	O
)	O
;	O
update_real_maxpage	()->(int)
(	O
)	O
;	O
if	O
(	O
gcl_alloc_initialized	int
)	O
return	O
;	O
data_start	O
=	O
heap_end	O
;	O
first_data_page	O
=	O
page	()->(int)
(	O
data_start	O
)	O
;	O
holepage	O
=	O
new_holepage	long
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_cons	O
,	O
".CONS"	*(char)
,	O
sizeof	O
(	O
struct	O
cons	O
)	O
,	O
65536	int
,	O
50	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_fixnum	O
,	O
"NFIXNUM"	*(char)
,	O
sizeof	O
(	O
struct	O
fixnum_struct	O
)	O
,	O
8192	int
,	O
20	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_structure	O
,	O
"SSTRUCTURE"	*(char)
,	O
sizeof	O
(	O
struct	O
structure	O
)	O
,	O
5461	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_cfun	O
,	O
"fCFUN"	*(char)
,	O
sizeof	O
(	O
struct	O
cfun	O
)	O
,	O
4096	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_sfun	O
,	O
"gSFUN"	*(char)
,	O
sizeof	O
(	O
struct	O
sfun	O
)	O
,	O
409	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_string	O
,	O
"\"STRING"	*(char)
,	O
sizeof	O
(	O
struct	O
string	O
)	O
,	O
5461	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_array	O
,	O
"aARRAY"	*(char)
,	O
sizeof	O
(	O
struct	O
array	O
)	O
,	O
4681	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_symbol	O
,	O
"|SYMBOL"	*(char)
,	O
sizeof	O
(	O
struct	O
symbol	O
)	O
,	O
3640	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_bignum	O
,	O
"BBIGNUM"	*(char)
,	O
sizeof	O
(	O
struct	O
bignum	O
)	O
,	O
2730	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_ratio	O
,	O
"RRATIONAL"	*(char)
,	O
sizeof	O
(	O
struct	O
ratio	O
)	O
,	O
170	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_shortfloat	O
,	O
"FSHORT-FLOAT"	*(char)
,	O
sizeof	O
(	O
struct	O
shortfloat_struct	O
)	O
,	O
256	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_longfloat	O
,	O
"LLONG-FLOAT"	*(char)
,	O
sizeof	O
(	O
struct	O
longfloat_struct	O
)	O
,	O
170	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_complex	O
,	O
"CCOMPLEX"	*(char)
,	O
sizeof	O
(	O
struct	O
ocomplex	O
)	O
,	O
170	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_character	O
,	O
"#CHARACTER"	*(char)
,	O
sizeof	O
(	O
struct	O
character	O
)	O
,	O
256	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_package	O
,	O
":PACKAGE"	*(char)
,	O
sizeof	O
(	O
struct	O
package	O
)	O
,	O
2	int
*	O
PAGESIZE	O
/	O
sizeof	O
(	O
struct	O
package	O
)	O
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_hashtable	O
,	O
"hHASH-TABLE"	*(char)
,	O
sizeof	O
(	O
struct	O
hashtable	O
)	O
,	O
78	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_vector	O
,	O
"vVECTOR"	*(char)
,	O
sizeof	O
(	O
struct	O
vector	O
)	O
,	O
146	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_bitvector	O
,	O
"bBIT-VECTOR"	*(char)
,	O
sizeof	O
(	O
struct	O
bitvector	O
)	O
,	O
73	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_stream	O
,	O
"sSTREAM"	*(char)
,	O
sizeof	O
(	O
struct	O
stream	O
)	O
,	O
78	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_random	O
,	O
"$RANDOM-STATE"	*(char)
,	O
sizeof	O
(	O
struct	O
random	()->(long)
)	O
,	O
256	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_readtable	O
,	O
"rREADTABLE"	*(char)
,	O
sizeof	O
(	O
struct	O
readtable	O
)	O
,	O
256	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_pathname	O
,	O
"pPATHNAME"	*(char)
,	O
sizeof	O
(	O
struct	O
pathname	O
)	O
,	O
73	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_cclosure	O
,	O
"cCCLOSURE"	*(char)
,	O
sizeof	O
(	O
struct	O
cclosure	O
)	O
,	O
85	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_closure	O
,	O
"cCLOSURE"	*(char)
,	O
sizeof	O
(	O
struct	O
cclosure	O
)	O
,	O
85	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_vfun	O
,	O
"VVFUN"	*(char)
,	O
sizeof	O
(	O
struct	O
vfun	O
)	O
,	O
102	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_gfun	O
,	O
"gGFUN"	*(char)
,	O
sizeof	O
(	O
struct	O
sfun	O
)	O
,	O
0	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_afun	O
,	O
"AAFUN"	*(char)
,	O
sizeof	O
(	O
struct	O
sfun	O
)	O
,	O
0	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_cfdata	O
,	O
"cCFDATA"	*(char)
,	O
sizeof	O
(	O
struct	O
cfdata	O
)	O
,	O
102	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_spice	O
,	O
"!SPICE"	*(char)
,	O
sizeof	O
(	O
struct	O
spice	O
)	O
,	O
4096	int
,	O
1	int
,	O
0	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_relocatable	O
,	O
"%RELOCATABLE-BLOCKS"	*(char)
,	O
0	int
,	O
0	int
,	O
20	int
,	O
1	int
)	O
;	O
init_tm	(enum,*(char),int,int,int,int)->(void)
(	O
t_contiguous	O
,	O
"_CONTIGUOUS-BLOCKS"	*(char)
,	O
0	int
,	O
0	int
,	O
20	int
,	O
1	int
)	O
;	O
ncb	O
=	O
0	int
;	O
ncbpage	O
=	O
0	int
;	O
set_tm_maxpage	()->(int)
(	O
tm_table	O
+	O
t_contiguous	O
,	O
1	int
)	O
;	O
set_tm_maxpage	()->(int)
(	O
tm_table	O
+	O
t_relocatable	O
,	O
1	int
)	O
;	O
nrbpage	O
=	O
0	int
;	O
alloc_page	(long)->(*(void))
(	O
-	O
(	O
holepage	O
+	O
nrbpage	O
)	O
)	O
;	O
rb_start	O
=	O
rb_pointer	O
=	O
heap_end	O
+	O
PAGESIZE	O
*	O
holepage	O
;	O
rb_end	O
=	O
rb_start	O
+	O
PAGESIZE	O
*	O
nrbpage	O
;	O
rb_limit	O
=	O
rb_end	O
-	O
2	int
*	O
RB_GETA	O
;	O
gcl_alloc_initialized	int
=	O
1	int
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"STATICP"	*(char)
,	O
object	O
,	O
fSstaticp	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x	double
)	O
,	O
"Tell if the string or vector is static"	*(char)
)	O
{	O
RETURN1	()->(int)
(	O
(	O
inheap	()->(int)
(	O
x	double
->	O
ust	O
.	O
ust_self	O
)	O
?	O
sLt	O
:	O
sLnil	O
)	O
)	O
;	O
}	O
static	O
int	O
t_from_type	()->(int)
(	O
object	O
type	int
)	O
{	O
int	O
i	long
;	O
check_type_or_symbol_string	()->(int)
(	O
&	O
type	int
)	O
;	O
for	O
(	O
i	long
=	O
t_start	O
;	O
i	long
<	O
t_other	O
;	O
i	long
++	O
)	O
{	O
struct	O
typemanager	O
*	O
tm	*(struct)
=	O
&	O
tm_table	O
[	O
i	long
]	O
;	O
if	O
(	O
tm	*(struct)
->	O
tm_name	O
&&	O
0	int
==	O
strncmp	(*(char),*(char),long)->(int)
(	O
(	O
tm	*(struct)
->	O
tm_name	O
)	O
+	O
1	int
,	O
type	int
->	O
st	O
.	O
st_self	O
,	O
type	int
->	O
st	O
.	O
st_fillp	O
)	O
)	O
return	O
i	long
;	O
}	O
FEerror	()->(int)
(	O
"Unrecognized type"	*(char)
,	O
0	int
)	O
;	O
return	O
i	long
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"ALLOCATE-SGC"	*(char)
,	O
object	O
,	O
fSallocate_sgc	O
,	O
SI	O
,	O
4	int
,	O
4	int
,	O
NONE	O
,	O
OO	O
,	O
II	O
,	O
II	O
,	O
OO	O
,	O
(	O
object	O
type	int
,	O
fixnum	int
min	O
,	O
fixnum	int
max	O
,	O
fixnum	int
free_percent	O
)	O
,	O
""	*(char)
)	O
{	O
int	O
t	int
=	O
t_from_type	()->(int)
(	O
type	int
)	O
;	O
struct	O
typemanager	O
*	O
tm	*(struct)
;	O
object	O
res	O
,	O
x	double
,	O
x1	O
,	O
x2	O
;	O
tm	*(struct)
=	O
tm_of	()->(int)
(	O
t	int
)	O
;	O
x	double
=	O
make_fixnum	()->(int)
(	O
tm	*(struct)
->	O
tm_sgc	O
)	O
;	O
x1	O
=	O
make_fixnum	()->(int)
(	O
tm	*(struct)
->	O
tm_sgc_max	O
)	O
;	O
x2	O
=	O
make_fixnum	()->(int)
(	O
(	O
100	int
*	O
tm	*(struct)
->	O
tm_sgc_minfree	O
)	O
/	O
tm	*(struct)
->	O
tm_nppage	O
)	O
;	O
res	O
=	O
list	()->(int)
(	O
3	int
,	O
x	double
,	O
x1	O
,	O
x2	O
)	O
;	O
if	O
(	O
min	O
<	O
0	int
||	O
max	O
<	O
min	O
||	O
free_percent	O
<	O
0	int
||	O
free_percent	O
>	O
100	int
)	O
goto	O
END	O
;	O
tm	*(struct)
->	O
tm_sgc_max	O
=	O
max	O
;	O
tm	*(struct)
->	O
tm_sgc	O
=	O
min	O
;	O
tm	*(struct)
->	O
tm_sgc_minfree	O
=	O
(	O
tm	*(struct)
->	O
tm_nppage	O
*	O
free_percent	O
)	O
/	O
100	int
;	O
END	O
:	O
RETURN1	()->(int)
(	O
res	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"ALLOCATE-GROWTH"	*(char)
,	O
object	O
,	O
fSallocate_growth	O
,	O
SI	O
,	O
5	int
,	O
5	int
,	O
NONE	O
,	O
OO	O
,	O
II	O
,	O
II	O
,	O
OO	O
,	O
(	O
object	O
type	int
,	O
fixnum	int
min	O
,	O
fixnum	int
max	O
,	O
fixnum	int
percent	O
,	O
fixnum	int
percent_free	O
)	O
,	O
""	*(char)
)	O
{	O
int	O
t	int
=	O
t_from_type	()->(int)
(	O
type	int
)	O
;	O
struct	O
typemanager	O
*	O
tm	*(struct)
=	O
tm_of	()->(int)
(	O
t	int
)	O
;	O
object	O
res	O
,	O
x	double
,	O
x1	O
,	O
x2	O
,	O
x3	O
;	O
x	double
=	O
make_fixnum	()->(int)
(	O
tm	*(struct)
->	O
tm_min_grow	O
)	O
;	O
x1	O
=	O
make_fixnum	()->(int)
(	O
tm	*(struct)
->	O
tm_max_grow	O
)	O
;	O
x2	O
=	O
make_fixnum	()->(int)
(	O
tm	*(struct)
->	O
tm_growth_percent	O
)	O
;	O
x3	O
=	O
make_fixnum	()->(int)
(	O
tm	*(struct)
->	O
tm_percent_free	O
)	O
;	O
res	O
=	O
list	()->(int)
(	O
4	int
,	O
x	double
,	O
x1	O
,	O
x2	O
,	O
x3	O
)	O
;	O
if	O
(	O
min	O
<	O
0	int
||	O
max	O
<	O
min	O
||	O
min	O
>	O
3000	int
||	O
percent	O
<	O
0	int
||	O
percent	O
>	O
500	int
||	O
percent_free	O
<	O
0	int
||	O
percent_free	O
>	O
100	int
)	O
goto	O
END	O
;	O
tm	*(struct)
->	O
tm_max_grow	O
=	O
max	O
;	O
tm	*(struct)
->	O
tm_min_grow	O
=	O
min	O
;	O
tm	*(struct)
->	O
tm_growth_percent	O
=	O
percent	O
;	O
tm	*(struct)
->	O
tm_percent_free	O
=	O
percent_free	O
;	O
END	O
:	O
RETURN1	()->(int)
(	O
res	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"ALLOCATE-CONTIGUOUS-PAGES"	*(char)
,	O
object	O
,	O
fSallocate_contiguous_pages	O
,	O
SI	O
,	O
1	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
onpages	O
,	O
...	O
)	O
,	O
""	*(char)
)	O
{	O
int	O
nargs	int
=	O
VFUN_NARGS	O
;	O
object	O
really_do	O
;	O
va_list	O
ap	O
;	O
fixnum	int
npages	O
=	O
fixint	O
(	O
onpages	O
)	O
;	O
really_do	O
=	O
Cnil	O
;	O
if	O
(	O
nargs	int
>=	O
2	int
)	O
{	O
va_start	O
(	O
ap	O
,	O
onpages	O
)	O
;	O
really_do	O
=	O
va_arg	()->(int)
(	O
ap	O
,	O
object	O
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
}	O
CHECK_ARG_RANGE	()->(int)
(	O
1	int
,	O
2	int
)	O
;	O
if	O
(	O
npages	O
<	O
0	int
)	O
FEerror	()->(int)
(	O
"Allocate requires positive argument."	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
ncbpage	O
>	O
npages	O
)	O
npages	O
=	O
ncbpage	O
;	O
if	O
(	O
!	O
set_tm_maxpage	()->(int)
(	O
tm_table	O
+	O
t_contiguous	O
,	O
npages	O
)	O
)	O
FEerror	()->(int)
(	O
"Can't allocate ~D pages for contiguous blocks."	*(char)
,	O
1	int
,	O
make_fixnum	()->(int)
(	O
npages	O
)	O
)	O
;	O
if	O
(	O
really_do	O
==	O
Cnil	O
)	O
RETURN1	()->(int)
(	O
Ct	O
)	O
;	O
add_pages	(*(struct),int)->(void)
(	O
tm_of	()->(int)
(	O
t_contiguous	O
)	O
,	O
npages	O
-	O
ncbpage	O
)	O
;	O
RETURN1	()->(int)
(	O
make_fixnum	()->(int)
(	O
npages	O
)	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"ALLOCATED-CONTIGUOUS-PAGES"	*(char)
,	O
object	O
,	O
fSallocated_contiguous_pages	O
,	O
SI	O
,	O
0	int
,	O
0	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
void	O
)	O
,	O
""	*(char)
)	O
{	O
RETURN1	()->(int)
(	O
(	O
make_fixnum	()->(int)
(	O
ncbpage	O
)	O
)	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"MAXIMUM-CONTIGUOUS-PAGES"	*(char)
,	O
object	O
,	O
fSmaximum_contiguous_pages	O
,	O
SI	O
,	O
0	int
,	O
0	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
void	O
)	O
,	O
""	*(char)
)	O
{	O
RETURN1	()->(int)
(	O
(	O
make_fixnum	()->(int)
(	O
maxcbpage	O
)	O
)	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"ALLOCATE-RELOCATABLE-PAGES"	*(char)
,	O
object	O
,	O
fSallocate_relocatable_pages	O
,	O
SI	O
,	O
1	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
onpages	O
,	O
...	O
)	O
,	O
""	*(char)
)	O
{	O
int	O
nargs	int
=	O
VFUN_NARGS	O
;	O
object	O
really_do	O
;	O
va_list	O
ap	O
;	O
fixnum	int
npages	O
=	O
fixint	O
(	O
onpages	O
)	O
;	O
really_do	O
=	O
Cnil	O
;	O
if	O
(	O
nargs	int
>=	O
2	int
)	O
{	O
va_start	O
(	O
ap	O
,	O
onpages	O
)	O
;	O
really_do	O
=	O
va_arg	()->(int)
(	O
ap	O
,	O
object	O
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
}	O
CHECK_ARG_RANGE	()->(int)
(	O
1	int
,	O
2	int
)	O
;	O
if	O
(	O
npages	O
<=	O
0	int
)	O
FEerror	()->(int)
(	O
"Requires positive arg"	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
npages	O
<	O
nrbpage	O
)	O
npages	O
=	O
nrbpage	O
;	O
if	O
(	O
!	O
set_tm_maxpage	()->(int)
(	O
tm_table	O
+	O
t_relocatable	O
,	O
npages	O
)	O
)	O
FEerror	()->(int)
(	O
"Can't set the limit for relocatable blocks to ~D."	*(char)
,	O
1	int
,	O
make_fixnum	()->(int)
(	O
npages	O
)	O
)	O
;	O
if	O
(	O
really_do	O
==	O
Cnil	O
)	O
RETURN1	()->(int)
(	O
Ct	O
)	O
;	O
add_pages	(*(struct),int)->(void)
(	O
tm_of	()->(int)
(	O
t_relocatable	O
)	O
,	O
npages	O
-	O
nrbpage	O
)	O
;	O
RETURN1	()->(int)
(	O
make_fixnum	()->(int)
(	O
npages	O
)	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"ALLOCATE"	*(char)
,	O
object	O
,	O
fSallocate	O
,	O
SI	O
,	O
2	int
,	O
3	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
type	int
,	O
object	O
onpages	O
,	O
...	O
)	O
,	O
""	*(char)
)	O
{	O
int	O
nargs	int
=	O
VFUN_NARGS	O
;	O
object	O
really_do	O
;	O
va_list	O
ap	O
;	O
struct	O
typemanager	O
*	O
tm	*(struct)
;	O
fixnum	int
npages	O
=	O
fixint	O
(	O
onpages	O
)	O
;	O
int	O
t	int
;	O
really_do	O
=	O
Cnil	O
;	O
if	O
(	O
nargs	int
>=	O
3	int
)	O
{	O
va_start	O
(	O
ap	O
,	O
onpages	O
)	O
;	O
really_do	O
=	O
va_arg	()->(int)
(	O
ap	O
,	O
object	O
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
}	O
CHECK_ARG_RANGE	()->(int)
(	O
2	int
,	O
3	int
)	O
;	O
t	int
=	O
t_from_type	()->(int)
(	O
type	int
)	O
;	O
if	O
(	O
t	int
==	O
t_contiguous	O
)	O
RETURN1	()->(int)
(	O
FUNCALL	()->(int)
(	O
2	int
,	O
FFN	()->(int)
(	O
fSallocate_contiguous_pages	O
)	O
(	O
make_fixnum	()->(int)
(	O
npages	O
)	O
,	O
really_do	O
)	O
)	O
)	O
;	O
else	O
if	O
(	O
t	int
==	O
t_relocatable	O
)	O
RETURN1	()->(int)
(	O
FUNCALL	()->(int)
(	O
2	int
,	O
FFN	()->(int)
(	O
fSallocate_relocatable_pages	O
)	O
(	O
make_fixnum	()->(int)
(	O
npages	O
)	O
,	O
really_do	O
)	O
)	O
)	O
;	O
if	O
(	O
npages	O
<=	O
0	int
)	O
FEerror	()->(int)
(	O
"Allocate takes positive argument."	*(char)
,	O
1	int
,	O
make_fixnum	()->(int)
(	O
npages	O
)	O
)	O
;	O
tm	*(struct)
=	O
tm_of	()->(int)
(	O
t	int
)	O
;	O
if	O
(	O
tm	*(struct)
->	O
tm_npage	O
>	O
npages	O
)	O
{	O
npages	O
=	O
tm	*(struct)
->	O
tm_npage	O
;	O
}	O
if	O
(	O
!	O
set_tm_maxpage	()->(int)
(	O
tm	*(struct)
,	O
npages	O
)	O
)	O
FEerror	()->(int)
(	O
"Can't allocate ~D pages for ~A."	*(char)
,	O
2	int
,	O
make_fixnum	()->(int)
(	O
npages	O
)	O
,	O
(	O
make_simple_string	()->(int)
(	O
tm	*(struct)
->	O
tm_name	O
+	O
1	int
)	O
)	O
)	O
;	O
if	O
(	O
really_do	O
==	O
Cnil	O
)	O
RETURN1	()->(int)
(	O
Ct	O
)	O
;	O
add_pages	(*(struct),int)->(void)
(	O
tm	*(struct)
,	O
npages	O
-	O
tm	*(struct)
->	O
tm_npage	O
)	O
;	O
RETURN1	()->(int)
(	O
make_fixnum	()->(int)
(	O
npages	O
)	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"ALLOCATED-RELOCATABLE-PAGES"	*(char)
,	O
object	O
,	O
fSallocated_relocatable_pages	O
,	O
SI	O
,	O
0	int
,	O
0	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
void	O
)	O
,	O
""	*(char)
)	O
{	O
RETURN1	()->(int)
(	O
make_fixnum	()->(int)
(	O
nrbpage	O
)	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"GET-HOLE-SIZE"	*(char)
,	O
object	O
,	O
fSget_hole_size	O
,	O
SI	O
,	O
0	int
,	O
0	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
void	O
)	O
,	O
""	*(char)
)	O
{	O
RETURN1	()->(int)
(	O
(	O
make_fixnum	()->(int)
(	O
new_holepage	long
)	O
)	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"SET-STARTING-HOLE-DIVISOR"	*(char)
,	O
object	O
,	O
fSset_starting_hole_divisor	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
II	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	int
div	(int,int)->(struct(int,int))
)	O
,	O
""	*(char)
)	O
{	O
if	O
(	O
div	(int,int)->(struct(int,int))
>	O
0	int
&&	O
div	(int,int)->(struct(int,int))
<	O
100	int
)	O
starting_hole_div	long
=	O
div	(int,int)->(struct(int,int))
;	O
return	O
(	O
object	O
)	O
starting_hole_div	long
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"SET-STARTING-RELBLOCK-HEAP-MULTIPLE"	*(char)
,	O
object	O
,	O
fSset_starting_relb_heap_multiple	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
II	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	int
mult	O
)	O
,	O
""	*(char)
)	O
{	O
if	O
(	O
mult	O
>=	O
0	int
)	O
starting_relb_heap_mult	long
=	O
mult	O
;	O
return	O
(	O
object	O
)	O
starting_relb_heap_mult	long
;	O
}	O
DEFUNM_NEW	()->(int)
(	O
"SET-HOLE-SIZE"	*(char)
,	O
object	O
,	O
fSset_hole_size	O
,	O
SI	O
,	O
1	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
onpages	O
,	O
...	O
)	O
,	O
""	*(char)
)	O
{	O
printf	O
(	O
"This function is obsolete -- use SET-STARTING-HOLE-DIVISOR instead\n"	*(char)
)	O
;	O
RETURN2	()->(int)
(	O
make_fixnum	()->(int)
(	O
new_holepage	long
)	O
,	O
make_fixnum	()->(int)
(	O
reserve_pages_for_signal_handler	int
)	O
)	O
;	O
}	O
void	O
gcl_init_alloc_function	()->(void)
(	O
void	O
)	O
{	O
enter_mark_origin	()->(int)
(	O
&	O
malloc_list	int
)	O
;	O
}	O
bool	O
writable_malloc	int
=	O
0	int
;	O
void	O
*	O
malloc	(long)->(*(void))
(	O
size_t	long
size	short
)	O
{	O
static	O
bool	O
in_malloc	int
;	O
if	O
(	O
in_malloc	int
)	O
return	O
NULL	O
;	O
in_malloc	int
=	O
1	int
;	O
if	O
(	O
!	O
gcl_alloc_initialized	int
)	O
gcl_init_alloc	(*(void))->(void)
(	O
&	O
size	short
)	O
;	O
CHECK_INTERRUPT	O
;	O
malloc_list	int
=	O
make_cons	(int,int)->(int)
(	O
alloc_simple_string	()->(int)
(	O
size	short
)	O
,	O
malloc_list	int
)	O
;	O
malloc_list	int
->	O
c	O
.	O
c_car	O
->	O
st	O
.	O
st_self	O
=	O
alloc_contblock	(long)->(*(void))
(	O
size	short
)	O
;	O
malloc_list	int
->	O
c	O
.	O
c_car	O
->	O
st	O
.	O
st_adjustable	O
=	O
writable_malloc	int
;	O
in_malloc	int
=	O
0	int
;	O
return	O
(	O
malloc_list	int
->	O
c	O
.	O
c_car	O
->	O
st	O
.	O
st_self	O
)	O
;	O
}	O
void	O
free	(*(void))->(void)
(	O
void	O
*	O
ptr	*(void)
)	O
{	O
object	O
*	O
p	*(void)
,	O
pp	*(struct)
;	O
if	O
(	O
ptr	*(void)
==	O
0	int
)	O
return	O
;	O
for	O
(	O
p	*(void)
=	O
&	O
malloc_list	int
,	O
pp	*(struct)
=	O
*	O
p	*(void)
;	O
pp	*(struct)
&&	O
!	O
endp	()->(int)
(	O
pp	*(struct)
)	O
;	O
p	*(void)
=	O
&	O
(	O
(	O
pp	*(struct)
)	O
->	O
c	O
.	O
c_cdr	O
)	O
,	O
pp	*(struct)
=	O
pp	*(struct)
->	O
c	O
.	O
c_cdr	O
)	O
if	O
(	O
(	O
pp	*(struct)
)	O
->	O
c	O
.	O
c_car	O
->	O
st	O
.	O
st_self	O
==	O
ptr	*(void)
)	O
{	O
insert_contblock	()->(int)
(	O
(	O
pp	*(struct)
)	O
->	O
c	O
.	O
c_car	O
->	O
st	O
.	O
st_self	O
,	O
(	O
pp	*(struct)
)	O
->	O
c	O
.	O
c_car	O
->	O
st	O
.	O
st_dim	O
)	O
;	O
(	O
pp	*(struct)
)	O
->	O
c	O
.	O
c_car	O
->	O
st	O
.	O
st_self	O
=	O
NULL	O
;	O
*	O
p	*(void)
=	O
pp	*(struct)
->	O
c	O
.	O
c_cdr	O
;	O
return	O
;	O
}	O
if	O
(	O
core_end	O
-	O
heap_end	O
<	O
sizeof	O
(	O
ptr	*(void)
)	O
||	O
ptr	*(void)
!=	O
*	O
(	O
void	O
*	O
*	O
)	O
heap_end	O
)	O
{	O
static	O
void	O
*	O
old_ptr	*(void)
;	O
if	O
(	O
old_ptr	*(void)
==	O
ptr	*(void)
)	O
return	O
;	O
old_ptr	*(void)
=	O
ptr	*(void)
;	O
FEerror	()->(int)
(	O
"free(3) error."	*(char)
,	O
0	int
)	O
;	O
}	O
return	O
;	O
}	O
void	O
*	O
realloc	(*(void),long)->(*(void))
(	O
void	O
*	O
ptr	*(void)
,	O
size_t	long
size	short
)	O
{	O
object	O
x	double
;	O
int	O
i	long
,	O
j	int
;	O
if	O
(	O
ptr	*(void)
==	O
NULL	O
)	O
return	O
malloc	(long)->(*(void))
(	O
size	short
)	O
;	O
for	O
(	O
x	double
=	O
malloc_list	int
;	O
!	O
endp	()->(int)
(	O
x	double
)	O
;	O
x	double
=	O
x	double
->	O
c	O
.	O
c_cdr	O
)	O
if	O
(	O
x	double
->	O
c	O
.	O
c_car	O
->	O
st	O
.	O
st_self	O
==	O
ptr	*(void)
)	O
{	O
x	double
=	O
x	double
->	O
c	O
.	O
c_car	O
;	O
if	O
(	O
x	double
->	O
st	O
.	O
st_dim	O
>=	O
size	short
)	O
{	O
x	double
->	O
st	O
.	O
st_fillp	O
=	O
size	short
;	O
return	O
(	O
ptr	*(void)
)	O
;	O
}	O
else	O
{	O
j	int
=	O
x	double
->	O
st	O
.	O
st_dim	O
;	O
x	double
->	O
st	O
.	O
st_self	O
=	O
alloc_contblock	(long)->(*(void))
(	O
size	short
)	O
;	O
x	double
->	O
st	O
.	O
st_fillp	O
=	O
x	double
->	O
st	O
.	O
st_dim	O
=	O
size	short
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
size	short
;	O
i	long
++	O
)	O
x	double
->	O
st	O
.	O
st_self	O
[	O
i	long
]	O
=	O
(	O
(	O
char	O
*	O
)	O
ptr	*(void)
)	O
[	O
i	long
]	O
;	O
insert_contblock	()->(int)
(	O
ptr	*(void)
,	O
j	int
)	O
;	O
return	O
(	O
x	double
->	O
st	O
.	O
st_self	O
)	O
;	O
}	O
}	O
FEerror	()->(int)
(	O
"realloc(3) error."	*(char)
,	O
0	int
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
*	O
calloc	(long,long)->(*(void))
(	O
size_t	long
nelem	long
,	O
size_t	long
elsize	int
)	O
{	O
char	O
*	O
ptr	*(void)
;	O
long	O
i	long
;	O
ptr	*(void)
=	O
malloc	(long)->(*(void))
(	O
i	long
=	O
nelem	long
*	O
elsize	int
)	O
;	O
while	O
(	O
--	O
i	long
>=	O
0	int
)	O
ptr	*(void)
[	O
i	long
]	O
=	O
0	int
;	O
return	O
(	O
ptr	*(void)
)	O
;	O
}	O
void	O
cfree	(*(void))->(void)
(	O
void	O
*	O
ptr	*(void)
)	O
{	O
free	(*(void))->(void)
(	O
ptr	*(void)
)	O
;	O
}	O
