char	O
*	O
hostname	*(char)
=	O
0	int
;	O
extern	O
char	O
*	O
getenv	(*(char))->(*(char))
(	O
const	O
char	O
*	O
)	O
;	O
extern	O
int	O
isprefix	(*(char),*(char))->(int)
(	O
register	O
char	O
*	O
s1	*(char)
,	O
register	O
char	O
*	O
s2	*(char)
)	O
;	O
extern	O
char	O
*	O
*	O
genget	(*(char),*(*(char)),int)->(*(*(char)))
(	O
char	O
*	O
,	O
char	O
*	O
*	O
,	O
int	O
)	O
;	O
extern	O
int	O
Ambiguous	()->(int)
(	O
)	O
;	O
typedef	O
int	O
(	O
*	O
intrtn_t	*((int,array(*(char)))->(int))
)	O
(	O
int	O
,	O
char	O
*	O
[	O
]	O
)	O
;	O
static	O
int	O
call	(*((int,array(*(char)))->(int)))->(int)
(	O
intrtn_t	*((int,array(*(char)))->(int))
,	O
...	O
)	O
;	O
typedef	O
struct	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
const	O
char	O
*	O
help	*(char)
;	O
int	O
(	O
*	O
handler	*(()->(int))
)	O
(	O
)	O
;	O
int	O
needconnect	int
;	O
}	O
Command	struct(*(char),*(char),*(()->(int)),int)
;	O
static	O
char	O
line	*(char)
[	O
256	int
]	O
;	O
static	O
char	O
saveline	array(char)
[	O
256	int
]	O
;	O
static	O
int	O
margc	int
;	O
static	O
char	O
*	O
margv	array(*(char))
[	O
20	int
]	O
;	O
static	O
void	O
makeargv	()->(void)
(	O
void	O
)	O
{	O
register	O
char	O
*	O
cp	*(char)
,	O
*	O
cp2	*(char)
,	O
c	int
;	O
register	O
char	O
*	O
*	O
argp	*(*(char))
=	O
margv	array(*(char))
;	O
margc	int
=	O
0	int
;	O
cp	*(char)
=	O
line	*(char)
;	O
if	O
(	O
*	O
cp	*(char)
==	O
'!'	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
saveline	array(char)
,	O
line	*(char)
)	O
;	O
*	O
argp	*(*(char))
++	O
=	O
"!"	*(char)
;	O
margc	int
++	O
;	O
cp	*(char)
++	O
;	O
}	O
while	O
(	O
(	O
c	int
=	O
*	O
cp	*(char)
)	O
)	O
{	O
register	O
int	O
inquote	int
=	O
0	int
;	O
while	O
(	O
isspace	(int)->(int)
(	O
c	int
)	O
)	O
c	int
=	O
*	O
++	O
cp	*(char)
;	O
if	O
(	O
c	int
==	O
'\0'	O
)	O
break	O
;	O
*	O
argp	*(*(char))
++	O
=	O
cp	*(char)
;	O
margc	int
+=	O
1	int
;	O
for	O
(	O
cp2	*(char)
=	O
cp	*(char)
;	O
c	int
!=	O
'\0'	O
;	O
c	int
=	O
*	O
++	O
cp	*(char)
)	O
{	O
if	O
(	O
inquote	int
)	O
{	O
if	O
(	O
c	int
==	O
inquote	int
)	O
{	O
inquote	int
=	O
0	int
;	O
continue	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
if	O
(	O
(	O
c	int
=	O
*	O
++	O
cp	*(char)
)	O
==	O
'\0'	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'"'	O
)	O
{	O
inquote	int
=	O
'"'	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\''	O
)	O
{	O
inquote	int
=	O
'\''	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
isspace	(int)->(int)
(	O
c	int
)	O
)	O
break	O
;	O
}	O
*	O
cp2	*(char)
++	O
=	O
c	int
;	O
}	O
*	O
cp2	*(char)
=	O
'\0'	O
;	O
if	O
(	O
c	int
==	O
'\0'	O
)	O
break	O
;	O
cp	*(char)
++	O
;	O
}	O
*	O
argp	*(*(char))
++	O
=	O
0	int
;	O
}	O
static	O
int	O
special	(*(char))->(int)
(	O
register	O
char	O
*	O
s	long
)	O
{	O
register	O
char	O
c	int
;	O
char	O
b	char
;	O
switch	O
(	O
*	O
s	long
)	O
{	O
case	O
'^'	O
:	O
b	char
=	O
*	O
++	O
s	long
;	O
if	O
(	O
b	char
==	O
'?'	O
)	O
{	O
c	int
=	O
b	char
|	O
0x40	int
;	O
}	O
else	O
{	O
c	int
=	O
b	char
&	O
0x1f	int
;	O
}	O
break	O
;	O
default	O
:	O
c	int
=	O
*	O
s	long
;	O
break	O
;	O
}	O
return	O
c	int
;	O
}	O
static	O
const	O
char	O
*	O
control	(char)->(*(char))
(	O
register	O
cc_t	char
c	int
)	O
{	O
static	O
char	O
buf	*(char)
[	O
5	int
]	O
;	O
register	O
unsigned	O
int	O
uic	int
=	O
(	O
unsigned	O
int	O
)	O
c	int
;	O
if	O
(	O
uic	int
==	O
0x7f	int
)	O
return	O
(	O
"^?"	*(char)
)	O
;	O
if	O
(	O
c	int
==	O
(	O
cc_t	char
)	O
_POSIX_VDISABLE	char
)	O
{	O
return	O
"off"	*(char)
;	O
}	O
if	O
(	O
uic	int
>=	O
0x80	int
)	O
{	O
buf	*(char)
[	O
0	int
]	O
=	O
'\\'	O
;	O
buf	*(char)
[	O
1	int
]	O
=	O
(	O
(	O
c	int
>>	O
6	int
)	O
&	O
07	int
)	O
+	O
'0'	O
;	O
buf	*(char)
[	O
2	int
]	O
=	O
(	O
(	O
c	int
>>	O
3	int
)	O
&	O
07	int
)	O
+	O
'0'	O
;	O
buf	*(char)
[	O
3	int
]	O
=	O
(	O
c	int
&	O
07	int
)	O
+	O
'0'	O
;	O
buf	*(char)
[	O
4	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
uic	int
>=	O
0x20	int
)	O
{	O
buf	*(char)
[	O
0	int
]	O
=	O
c	int
;	O
buf	*(char)
[	O
1	int
]	O
=	O
0	int
;	O
}	O
else	O
{	O
buf	*(char)
[	O
0	int
]	O
=	O
'^'	O
;	O
buf	*(char)
[	O
1	int
]	O
=	O
'@'	O
+	O
c	int
;	O
buf	*(char)
[	O
2	int
]	O
=	O
0	int
;	O
}	O
return	O
(	O
buf	*(char)
)	O
;	O
}	O
struct	O
sendlist	struct(*(char),*(char),int,int,*(()->(int)),int,int)
{	O
const	O
char	O
*	O
name	*(char)
;	O
const	O
char	O
*	O
help	*(char)
;	O
int	O
needconnect	int
;	O
int	O
narg	int
;	O
int	O
(	O
*	O
handler	*(()->(int))
)	O
(	O
)	O
;	O
int	O
nbyte	int
;	O
int	O
what	int
;	O
}	O
;	O
static	O
int	O
send_esc	()->(int)
(	O
void	O
)	O
,	O
send_help	()->(int)
(	O
void	O
)	O
,	O
send_docmd	(*(char))->(int)
(	O
char	O
*	O
)	O
,	O
send_dontcmd	(*(char))->(int)
(	O
char	O
*	O
)	O
,	O
send_willcmd	(*(char))->(int)
(	O
char	O
*	O
)	O
,	O
send_wontcmd	(*(char))->(int)
(	O
char	O
*	O
)	O
;	O
static	O
struct	O
sendlist	struct(*(char),*(char),int,int,*(()->(int)),int,int)
Sendlist	array(struct(*(char),*(char),int,int,*(()->(int)),int,int))
[	O
]	O
=	O
{	O
{	O
"ao"	*(char)
,	O
"Send Telnet Abort output"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
AO	int
}	O
,	O
{	O
"ayt"	*(char)
,	O
"Send Telnet 'Are You There'"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
AYT	int
}	O
,	O
{	O
"brk"	*(char)
,	O
"Send Telnet Break"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
BREAK	int
}	O
,	O
{	O
"break"	*(char)
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
BREAK	int
}	O
,	O
{	O
"ec"	*(char)
,	O
"Send Telnet Erase Character"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
EC	int
}	O
,	O
{	O
"el"	*(char)
,	O
"Send Telnet Erase Line"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
EL	int
}	O
,	O
{	O
"escape"	*(char)
,	O
"Send current escape character"	*(char)
,	O
1	int
,	O
0	int
,	O
send_esc	()->(int)
,	O
1	int
,	O
0	int
}	O
,	O
{	O
"ga"	*(char)
,	O
"Send Telnet 'Go Ahead' sequence"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
GA	int
}	O
,	O
{	O
"ip"	*(char)
,	O
"Send Telnet Interrupt Process"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
IP	int
}	O
,	O
{	O
"intp"	*(char)
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
IP	int
}	O
,	O
{	O
"interrupt"	*(char)
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
IP	int
}	O
,	O
{	O
"intr"	*(char)
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
IP	int
}	O
,	O
{	O
"nop"	*(char)
,	O
"Send Telnet 'No operation'"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
NOP	int
}	O
,	O
{	O
"eor"	*(char)
,	O
"Send Telnet 'End of Record'"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
EOR	int
}	O
,	O
{	O
"abort"	*(char)
,	O
"Send Telnet 'Abort Process'"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
ABORT	int
}	O
,	O
{	O
"susp"	*(char)
,	O
"Send Telnet 'Suspend Process'"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
SUSP	int
}	O
,	O
{	O
"eof"	*(char)
,	O
"Send Telnet End of File Character"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
xEOF	int
}	O
,	O
{	O
"synch"	*(char)
,	O
"Perform Telnet 'Synch operation'"	*(char)
,	O
1	int
,	O
0	int
,	O
dosynch	()->(int)
,	O
2	int
,	O
0	int
}	O
,	O
{	O
"getstatus"	*(char)
,	O
"Send request for STATUS"	*(char)
,	O
1	int
,	O
0	int
,	O
get_status	()->(int)
,	O
6	int
,	O
0	int
}	O
,	O
{	O
"?"	*(char)
,	O
"Display send options"	*(char)
,	O
0	int
,	O
0	int
,	O
send_help	()->(int)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"help"	*(char)
,	O
0	int
,	O
0	int
,	O
0	int
,	O
send_help	()->(int)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"do"	*(char)
,	O
0	int
,	O
0	int
,	O
1	int
,	O
send_docmd	(*(char))->(int)
,	O
3	int
,	O
0	int
}	O
,	O
{	O
"dont"	*(char)
,	O
0	int
,	O
0	int
,	O
1	int
,	O
send_dontcmd	(*(char))->(int)
,	O
3	int
,	O
0	int
}	O
,	O
{	O
"will"	*(char)
,	O
0	int
,	O
0	int
,	O
1	int
,	O
send_willcmd	(*(char))->(int)
,	O
3	int
,	O
0	int
}	O
,	O
{	O
"wont"	*(char)
,	O
0	int
,	O
0	int
,	O
1	int
,	O
send_wontcmd	(*(char))->(int)
,	O
3	int
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
int	O
sendcmd	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
count	int
;	O
int	O
i	int
;	O
struct	O
sendlist	struct(*(char),*(char),int,int,*(()->(int)),int,int)
*	O
s	long
;	O
int	O
success	int
=	O
0	int
;	O
int	O
needconnect	int
=	O
0	int
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
printf	(*(char))->(int)
(	O
"need at least one argument for 'send' command\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"'send ?' for help\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
count	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
s	long
=	O
GETSEND	O
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
s	long
==	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Unknown send argument '%s'\n'send ?' for help.\n"	*(char)
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
Ambiguous	()->(int)
(	O
s	long
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Ambiguous send argument '%s'\n'send ?' for help.\n"	*(char)
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
i	int
+	O
s	long
->	O
narg	int
>=	O
argc	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Need %d argument%s to 'send %s' command.  'send %s ?' for help.\n"	*(char)
,	O
s	long
->	O
narg	int
,	O
s	long
->	O
narg	int
==	O
1	int
?	O
""	*(char)
:	O
"s"	*(char)
,	O
s	long
->	O
name	*(char)
,	O
s	long
->	O
name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
count	int
+=	O
s	long
->	O
nbyte	int
;	O
if	O
(	O
s	long
->	O
handler	*(()->(int))
==	O
send_help	()->(int)
)	O
{	O
send_help	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
i	int
+=	O
s	long
->	O
narg	int
;	O
needconnect	int
+=	O
s	long
->	O
needconnect	int
;	O
}	O
if	O
(	O
!	O
connected	int
&&	O
needconnect	int
)	O
{	O
printf	(*(char))->(int)
(	O
"?Need to be connected first.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"'send ?' for help\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
NETROOM	O
(	O
)	O
<	O
count	int
)	O
{	O
printf	(*(char))->(int)
(	O
"There is not enough room in the buffer TO the network\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"to process your request.  Nothing will be done.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"('send synch' will throw away most data in the network\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"buffer, if this might help.)\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
count	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
s	long
=	O
GETSEND	O
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
)	O
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Telnet 'send' error - argument disappeared!\n"	*(char)
)	O
;	O
quit	()->(int)
(	O
)	O
;	O
}	O
if	O
(	O
s	long
->	O
handler	*(()->(int))
)	O
{	O
count	int
++	O
;	O
success	int
+=	O
(	O
*	O
s	long
->	O
handler	*(()->(int))
)	O
(	O
(	O
s	long
->	O
narg	int
>	O
0	int
)	O
?	O
argv	*(*(char))
[	O
i	int
+	O
1	int
]	O
:	O
0	int
,	O
(	O
s	long
->	O
narg	int
>	O
1	int
)	O
?	O
argv	*(*(char))
[	O
i	int
+	O
2	int
]	O
:	O
0	int
)	O
;	O
i	int
+=	O
s	long
->	O
narg	int
;	O
}	O
else	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
s	long
->	O
what	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
IAC	int
,	O
s	long
->	O
what	int
)	O
;	O
}	O
}	O
return	O
(	O
count	int
==	O
success	int
)	O
;	O
}	O
static	O
int	O
send_esc	()->(int)
(	O
void	O
)	O
{	O
NETADD	O
(	O
escape	char
)	O
;	O
return	O
1	int
;	O
}	O
int	O
send_tncmd	(*(()->(void)),*(char),*(char))->(int)
(	O
void	O
(	O
*	O
func	*(()->(void))
)	O
(	O
)	O
,	O
char	O
*	O
cmd	*(char)
,	O
char	O
*	O
name	*(char)
)	O
{	O
char	O
*	O
*	O
cpp	*(*(char))
;	O
extern	O
char	O
*	O
telopts	array(*(char))
[	O
]	O
;	O
register	O
int	O
val	array(int)
=	O
0	int
;	O
if	O
(	O
isprefix	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"help"	*(char)
)	O
||	O
isprefix	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"?"	*(char)
)	O
)	O
{	O
register	O
int	O
col	int
,	O
len	char
;	O
printf	(*(char))->(int)
(	O
"Usage: send %s <value|option>\n"	*(char)
,	O
cmd	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\"value\" must be from 0 to 255\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Valid options are:\n\t"	*(char)
)	O
;	O
col	int
=	O
8	int
;	O
for	O
(	O
cpp	*(*(char))
=	O
telopts	array(*(char))
;	O
*	O
cpp	*(*(char))
;	O
cpp	*(*(char))
++	O
)	O
{	O
len	char
=	O
strlen	(*(char))->(long)
(	O
*	O
cpp	*(*(char))
)	O
+	O
3	int
;	O
if	O
(	O
col	int
+	O
len	char
>	O
65	int
)	O
{	O
printf	(*(char))->(int)
(	O
"\n\t"	*(char)
)	O
;	O
col	int
=	O
8	int
;	O
}	O
printf	(*(char))->(int)
(	O
" \"%s\""	*(char)
,	O
*	O
cpp	*(*(char))
)	O
;	O
col	int
+=	O
len	char
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
cpp	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
genget	(*(char),*(*(char)),int)->(*(*(char)))
(	O
name	*(char)
,	O
telopts	array(*(char))
,	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
Ambiguous	()->(int)
(	O
cpp	*(*(char))
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"'%s': ambiguous argument ('send %s ?' for help).\n"	*(char)
,	O
name	*(char)
,	O
cmd	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
cpp	*(*(char))
)	O
{	O
val	array(int)
=	O
cpp	*(*(char))
-	O
telopts	array(*(char))
;	O
}	O
else	O
{	O
register	O
char	O
*	O
cp	*(char)
=	O
name	*(char)
;	O
while	O
(	O
*	O
cp	*(char)
>=	O
'0'	O
&&	O
*	O
cp	*(char)
<=	O
'9'	O
)	O
{	O
val	array(int)
*=	O
10	int
;	O
val	array(int)
+=	O
*	O
cp	*(char)
-	O
'0'	O
;	O
cp	*(char)
++	O
;	O
}	O
if	O
(	O
*	O
cp	*(char)
!=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"'%s': unknown argument ('send %s ?' for help).\n"	*(char)
,	O
name	*(char)
,	O
cmd	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
val	array(int)
<	O
0	int
||	O
val	array(int)
>	O
255	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"'%s': bad value ('send %s ?' for help).\n"	*(char)
,	O
name	*(char)
,	O
cmd	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
!	O
connected	int
)	O
{	O
printf	(*(char))->(int)
(	O
"?Need to be connected first.\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
(	O
*	O
func	*(()->(void))
)	O
(	O
val	array(int)
,	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
send_docmd	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
(	O
send_tncmd	(*(()->(void)),*(char),*(char))->(int)
(	O
send_do	(int,int)->(void)
,	O
"do"	*(char)
,	O
name	*(char)
)	O
)	O
;	O
}	O
static	O
int	O
send_dontcmd	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
(	O
send_tncmd	(*(()->(void)),*(char),*(char))->(int)
(	O
send_dont	(int,int)->(void)
,	O
"dont"	*(char)
,	O
name	*(char)
)	O
)	O
;	O
}	O
static	O
int	O
send_willcmd	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
(	O
send_tncmd	(*(()->(void)),*(char),*(char))->(int)
(	O
send_will	(int,int)->(void)
,	O
"will"	*(char)
,	O
name	*(char)
)	O
)	O
;	O
}	O
static	O
int	O
send_wontcmd	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
(	O
send_tncmd	(*(()->(void)),*(char),*(char))->(int)
(	O
send_wont	(int,int)->(void)
,	O
"wont"	*(char)
,	O
name	*(char)
)	O
)	O
;	O
}	O
static	O
int	O
send_help	()->(int)
(	O
void	O
)	O
{	O
struct	O
sendlist	struct(*(char),*(char),int,int,*(()->(int)),int,int)
*	O
s	long
;	O
for	O
(	O
s	long
=	O
Sendlist	array(struct(*(char),*(char),int,int,*(()->(int)),int,int))
;	O
s	long
->	O
name	*(char)
;	O
s	long
++	O
)	O
{	O
if	O
(	O
s	long
->	O
help	*(char)
)	O
printf	(*(char))->(int)
(	O
"%-15s %s\n"	*(char)
,	O
s	long
->	O
name	*(char)
,	O
s	long
->	O
help	*(char)
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
lclchars	()->(int)
(	O
void	O
)	O
{	O
donelclchars	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
togdebug	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
net	int
>	O
0	int
&&	O
(	O
SetSockOpt	(int,int,int,int)->(int)
(	O
net	int
,	O
SOL_SOCKET	int
,	O
SO_DEBUG	int
,	O
debug	int
)	O
)	O
<	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
"setsockopt (SO_DEBUG)"	*(char)
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
togcrlf	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
crlf	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Will send carriage returns as telnet <CR><LF>.\n"	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Will send carriage returns as telnet <CR><NUL>.\n"	*(char)
)	O
;	O
}	O
return	O
1	int
;	O
}	O
int	O
binmode	int
;	O
static	O
int	O
togbinary	(int)->(int)
(	O
int	O
val	array(int)
)	O
{	O
donebinarytoggle	int
=	O
1	int
;	O
if	O
(	O
val	array(int)
>=	O
0	int
)	O
{	O
binmode	int
=	O
val	array(int)
;	O
}	O
else	O
{	O
if	O
(	O
my_want_state_is_will	O
(	O
TELOPT_BINARY	int
)	O
&&	O
my_want_state_is_do	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
binmode	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_BINARY	int
)	O
&&	O
my_want_state_is_dont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
binmode	int
=	O
0	int
;	O
}	O
val	array(int)
=	O
binmode	int
?	O
0	int
:	O
1	int
;	O
}	O
if	O
(	O
val	array(int)
==	O
1	int
)	O
{	O
if	O
(	O
my_want_state_is_will	O
(	O
TELOPT_BINARY	int
)	O
&&	O
my_want_state_is_do	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Already operating in binary mode with remote host.\n"	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Negotiating binary mode with remote host.\n"	*(char)
)	O
;	O
tel_enter_binary	(int)->(void)
(	O
3	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_BINARY	int
)	O
&&	O
my_want_state_is_dont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Already in network ascii mode with remote host.\n"	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Negotiating network ascii mode with remote host.\n"	*(char)
)	O
;	O
tel_leave_binary	(int)->(void)
(	O
3	int
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
togrbinary	(int)->(int)
(	O
int	O
val	array(int)
)	O
{	O
donebinarytoggle	int
=	O
1	int
;	O
if	O
(	O
val	array(int)
==	O
-	O
1	int
)	O
val	array(int)
=	O
my_want_state_is_do	O
(	O
TELOPT_BINARY	int
)	O
?	O
0	int
:	O
1	int
;	O
if	O
(	O
val	array(int)
==	O
1	int
)	O
{	O
if	O
(	O
my_want_state_is_do	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Already receiving in binary mode.\n"	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Negotiating binary mode on input.\n"	*(char)
)	O
;	O
tel_enter_binary	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
my_want_state_is_dont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Already receiving in network ascii mode.\n"	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Negotiating network ascii mode on input.\n"	*(char)
)	O
;	O
tel_leave_binary	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
togxbinary	(int)->(int)
(	O
int	O
val	array(int)
)	O
{	O
donebinarytoggle	int
=	O
1	int
;	O
if	O
(	O
val	array(int)
==	O
-	O
1	int
)	O
val	array(int)
=	O
my_want_state_is_will	O
(	O
TELOPT_BINARY	int
)	O
?	O
0	int
:	O
1	int
;	O
if	O
(	O
val	array(int)
==	O
1	int
)	O
{	O
if	O
(	O
my_want_state_is_will	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Already transmitting in binary mode.\n"	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Negotiating binary mode on output.\n"	*(char)
)	O
;	O
tel_enter_binary	(int)->(void)
(	O
2	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Already transmitting in network ascii mode.\n"	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Negotiating network ascii mode on output.\n"	*(char)
)	O
;	O
tel_leave_binary	(int)->(void)
(	O
2	int
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
togglehelp	()->(int)
(	O
void	O
)	O
;	O
struct	O
togglelist	struct(*(char),*(char),*(()->(int)),*(int),*(char))
{	O
const	O
char	O
*	O
name	*(char)
;	O
const	O
char	O
*	O
help	*(char)
;	O
int	O
(	O
*	O
handler	*(()->(int))
)	O
(	O
)	O
;	O
int	O
*	O
variable	*(int)
;	O
const	O
char	O
*	O
actionexplanation	*(char)
;	O
}	O
;	O
static	O
struct	O
togglelist	struct(*(char),*(char),*(()->(int)),*(int),*(char))
Togglelist	array(struct(*(char),*(char),*(()->(int)),*(int),*(char)))
[	O
]	O
=	O
{	O
{	O
"autoflush"	*(char)
,	O
"flushing of output when sending interrupt characters"	*(char)
,	O
0	int
,	O
&	O
autoflush	int
,	O
"flush output when sending interrupt characters"	*(char)
}	O
,	O
{	O
"autosynch"	*(char)
,	O
"automatic sending of interrupt characters in urgent mode"	*(char)
,	O
0	int
,	O
&	O
autosynch	int
,	O
"send interrupt characters in urgent mode"	*(char)
}	O
,	O
{	O
"skiprc"	*(char)
,	O
"don't read ~/.telnetrc file"	*(char)
,	O
0	int
,	O
&	O
skiprc	int
,	O
"skip reading of ~/.telnetrc file"	*(char)
}	O
,	O
{	O
"binary"	*(char)
,	O
"sending and receiving of binary data"	*(char)
,	O
togbinary	(int)->(int)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"inbinary"	*(char)
,	O
"receiving of binary data"	*(char)
,	O
togrbinary	(int)->(int)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"outbinary"	*(char)
,	O
"sending of binary data"	*(char)
,	O
togxbinary	(int)->(int)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"crlf"	*(char)
,	O
"sending carriage returns as telnet <CR><LF>"	*(char)
,	O
togcrlf	()->(int)
,	O
&	O
crlf	int
,	O
0	int
}	O
,	O
{	O
"crmod"	*(char)
,	O
"mapping of received carriage returns"	*(char)
,	O
0	int
,	O
&	O
crmod	int
,	O
"map carriage return on output"	*(char)
}	O
,	O
{	O
"localchars"	*(char)
,	O
"local recognition of certain control characters"	*(char)
,	O
lclchars	()->(int)
,	O
&	O
localchars	int
,	O
"recognize certain control characters"	*(char)
}	O
,	O
{	O
" "	*(char)
,	O
""	*(char)
,	O
0	int
}	O
,	O
{	O
"debug"	*(char)
,	O
"debugging"	*(char)
,	O
togdebug	()->(int)
,	O
&	O
debug	int
,	O
"turn on socket level debugging"	*(char)
}	O
,	O
{	O
"netdata"	*(char)
,	O
"printing of hexadecimal network data (debugging)"	*(char)
,	O
0	int
,	O
&	O
netdata	int
,	O
"print hexadecimal representation of network traffic"	*(char)
}	O
,	O
{	O
"prettydump"	*(char)
,	O
"output of \"netdata\" to user readable format (debugging)"	*(char)
,	O
0	int
,	O
&	O
prettydump	int
,	O
"print user readable output for \"netdata\""	*(char)
}	O
,	O
{	O
"options"	*(char)
,	O
"viewing of options processing (debugging)"	*(char)
,	O
0	int
,	O
&	O
showoptions	int
,	O
"show option processing"	*(char)
}	O
,	O
{	O
"termdata"	*(char)
,	O
"(debugging) toggle printing of hexadecimal terminal data"	*(char)
,	O
0	int
,	O
&	O
termdata	int
,	O
"print hexadecimal representation of terminal traffic"	*(char)
}	O
,	O
{	O
"?"	*(char)
,	O
0	int
,	O
togglehelp	()->(int)
}	O
,	O
{	O
"help"	*(char)
,	O
0	int
,	O
togglehelp	()->(int)
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
int	O
togglehelp	()->(int)
(	O
void	O
)	O
{	O
struct	O
togglelist	struct(*(char),*(char),*(()->(int)),*(int),*(char))
*	O
c	int
;	O
for	O
(	O
c	int
=	O
Togglelist	array(struct(*(char),*(char),*(()->(int)),*(int),*(char)))
;	O
c	int
->	O
name	*(char)
;	O
c	int
++	O
)	O
{	O
if	O
(	O
c	int
->	O
help	*(char)
)	O
{	O
if	O
(	O
*	O
c	int
->	O
help	*(char)
)	O
printf	(*(char))->(int)
(	O
"%-15s toggle %s\n"	*(char)
,	O
c	int
->	O
name	*(char)
,	O
c	int
->	O
help	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"%-15s %s\n"	*(char)
,	O
"?"	*(char)
,	O
"display help information"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
settogglehelp	(int)->(void)
(	O
int	O
set	int
)	O
{	O
struct	O
togglelist	struct(*(char),*(char),*(()->(int)),*(int),*(char))
*	O
c	int
;	O
for	O
(	O
c	int
=	O
Togglelist	array(struct(*(char),*(char),*(()->(int)),*(int),*(char)))
;	O
c	int
->	O
name	*(char)
;	O
c	int
++	O
)	O
{	O
if	O
(	O
c	int
->	O
help	*(char)
)	O
{	O
if	O
(	O
*	O
c	int
->	O
help	*(char)
)	O
printf	(*(char))->(int)
(	O
"%-15s %s %s\n"	*(char)
,	O
c	int
->	O
name	*(char)
,	O
set	int
?	O
"enable"	*(char)
:	O
"disable"	*(char)
,	O
c	int
->	O
help	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
}	O
}	O
static	O
int	O
toggle	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
int	O
retval	int
=	O
1	int
;	O
char	O
*	O
name	*(char)
;	O
struct	O
togglelist	struct(*(char),*(char),*(()->(int)),*(int),*(char))
*	O
c	int
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Need an argument to 'toggle' command.  'toggle ?' for help.\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
argc	int
--	O
;	O
argv	*(*(char))
++	O
;	O
while	O
(	O
argc	int
--	O
)	O
{	O
name	*(char)
=	O
*	O
argv	*(*(char))
++	O
;	O
c	int
=	O
GETTOGGLE	O
(	O
name	*(char)
)	O
;	O
if	O
(	O
Ambiguous	()->(int)
(	O
c	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"'%s': ambiguous argument ('toggle ?' for help).\n"	*(char)
,	O
name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"'%s': unknown argument ('toggle ?' for help).\n"	*(char)
,	O
name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
c	int
->	O
variable	*(int)
)	O
{	O
*	O
c	int
->	O
variable	*(int)
=	O
!	O
*	O
c	int
->	O
variable	*(int)
;	O
if	O
(	O
c	int
->	O
actionexplanation	*(char)
)	O
{	O
printf	(*(char))->(int)
(	O
"%s %s.\n"	*(char)
,	O
*	O
c	int
->	O
variable	*(int)
?	O
"Will"	*(char)
:	O
"Won't"	*(char)
,	O
c	int
->	O
actionexplanation	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
c	int
->	O
handler	*(()->(int))
)	O
{	O
retval	int
&=	O
(	O
*	O
c	int
->	O
handler	*(()->(int))
)	O
(	O
-	O
1	int
)	O
;	O
}	O
}	O
}	O
return	O
retval	int
;	O
}	O
struct	O
termio	struct(short,short,short,short,char,array(char))
new_tc	struct(int,int,int,int,char,array(char),int,int)
=	O
{	O
0	int
}	O
;	O
struct	O
setlist	struct(*(char),*(char),*(()->(void)),*(char))
{	O
const	O
char	O
*	O
name	*(char)
;	O
const	O
char	O
*	O
help	*(char)
;	O
void	O
(	O
*	O
handler	*(()->(int))
)	O
(	O
)	O
;	O
cc_t	char
*	O
charp	*(char)
;	O
}	O
;	O
static	O
struct	O
setlist	struct(*(char),*(char),*(()->(void)),*(char))
Setlist	array(struct(*(char),*(char),*(()->(void)),*(char)))
[	O
]	O
=	O
{	O
{	O
"echo"	*(char)
,	O
"character to toggle local echoing on/off"	*(char)
,	O
0	int
,	O
&	O
echoc	char
}	O
,	O
{	O
"escape"	*(char)
,	O
"character to escape back to telnet command mode"	*(char)
,	O
0	int
,	O
&	O
escape	char
}	O
,	O
{	O
"rlogin"	*(char)
,	O
"rlogin escape character"	*(char)
,	O
0	int
,	O
&	O
rlogin	char
}	O
,	O
{	O
"tracefile"	*(char)
,	O
"file to write trace information to"	*(char)
,	O
SetNetTrace	(*(char))->(void)
,	O
(	O
cc_t	char
*	O
)	O
NetTraceFile	array(char)
}	O
,	O
{	O
" "	*(char)
,	O
""	*(char)
}	O
,	O
{	O
" "	*(char)
,	O
"The following need 'localchars' to be toggled true"	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"flushoutput"	*(char)
,	O
"character to cause an Abort Output"	*(char)
,	O
0	int
,	O
termFlushCharp	O
}	O
,	O
{	O
"interrupt"	*(char)
,	O
"character to cause an Interrupt Process"	*(char)
,	O
0	int
,	O
termIntCharp	O
}	O
,	O
{	O
"quit"	*(char)
,	O
"character to cause an Abort process"	*(char)
,	O
0	int
,	O
termQuitCharp	O
}	O
,	O
{	O
"eof"	*(char)
,	O
"character to cause an EOF "	*(char)
,	O
0	int
,	O
termEofCharp	O
}	O
,	O
{	O
" "	*(char)
,	O
""	*(char)
}	O
,	O
{	O
" "	*(char)
,	O
"The following are for local editing in linemode"	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"erase"	*(char)
,	O
"character to use to erase a character"	*(char)
,	O
0	int
,	O
termEraseCharp	O
}	O
,	O
{	O
"kill"	*(char)
,	O
"character to use to erase a line"	*(char)
,	O
0	int
,	O
termKillCharp	O
}	O
,	O
{	O
"lnext"	*(char)
,	O
"character to use for literal next"	*(char)
,	O
0	int
,	O
termLiteralNextCharp	O
}	O
,	O
{	O
"susp"	*(char)
,	O
"character to cause a Suspend Process"	*(char)
,	O
0	int
,	O
termSuspCharp	O
}	O
,	O
{	O
"reprint"	*(char)
,	O
"character to use for line reprint"	*(char)
,	O
0	int
,	O
termRprntCharp	O
}	O
,	O
{	O
"worderase"	*(char)
,	O
"character to use to erase a word"	*(char)
,	O
0	int
,	O
termWerasCharp	O
}	O
,	O
{	O
"start"	*(char)
,	O
"character to use for XON"	*(char)
,	O
0	int
,	O
termStartCharp	O
}	O
,	O
{	O
"stop"	*(char)
,	O
"character to use for XOFF"	*(char)
,	O
0	int
,	O
termStopCharp	O
}	O
,	O
{	O
"forw1"	*(char)
,	O
"alternate end of line character"	*(char)
,	O
0	int
,	O
termForw1Charp	O
}	O
,	O
{	O
"forw2"	*(char)
,	O
"alternate end of line character"	*(char)
,	O
0	int
,	O
termForw2Charp	O
}	O
,	O
{	O
"ayt"	*(char)
,	O
"alternate AYT character"	*(char)
,	O
0	int
,	O
termAytCharp	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
struct	O
setlist	struct(*(char),*(char),*(()->(void)),*(char))
*	O
getset	(*(char))->(*(struct(*(char),*(char),*(()->(void)),*(char))))
(	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
(	O
struct	O
setlist	struct(*(char),*(char),*(()->(void)),*(char))
*	O
)	O
genget	(*(char),*(*(char)),int)->(*(*(char)))
(	O
name	*(char)
,	O
(	O
char	O
*	O
*	O
)	O
Setlist	array(struct(*(char),*(char),*(()->(void)),*(char)))
,	O
sizeof	O
(	O
struct	O
setlist	struct(*(char),*(char),*(()->(void)),*(char))
)	O
)	O
;	O
}	O
void	O
set_escape_char	(*(char))->(void)
(	O
char	O
*	O
s	long
)	O
{	O
if	O
(	O
rlogin	char
!=	O
_POSIX_VDISABLE	char
)	O
{	O
rlogin	char
=	O
(	O
s	long
&&	O
*	O
s	long
)	O
?	O
special	(*(char))->(int)
(	O
s	long
)	O
:	O
_POSIX_VDISABLE	char
;	O
printf	(*(char))->(int)
(	O
"Telnet rlogin escape character is '%s'.\n"	*(char)
,	O
control	(char)->(*(char))
(	O
rlogin	char
)	O
)	O
;	O
}	O
else	O
{	O
escape	char
=	O
(	O
s	long
&&	O
*	O
s	long
)	O
?	O
special	(*(char))->(int)
(	O
s	long
)	O
:	O
_POSIX_VDISABLE	char
;	O
printf	(*(char))->(int)
(	O
"Telnet escape character is '%s'.\n"	*(char)
,	O
control	(char)->(*(char))
(	O
escape	char
)	O
)	O
;	O
}	O
}	O
static	O
int	O
setcmd	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
int	O
value	int
;	O
struct	O
setlist	struct(*(char),*(char),*(()->(void)),*(char))
*	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
;	O
struct	O
togglelist	struct(*(char),*(char),*(()->(int)),*(int),*(char))
*	O
c	int
;	O
if	O
(	O
argc	int
<	O
2	int
||	O
argc	int
>	O
3	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Format is 'set Name Value'\n'set ?' for help.\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
(	O
argc	int
==	O
2	int
)	O
&&	O
(	O
isprefix	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
"?"	*(char)
)	O
||	O
isprefix	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
"help"	*(char)
)	O
)	O
)	O
{	O
for	O
(	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
=	O
Setlist	array(struct(*(char),*(char),*(()->(void)),*(char)))
;	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
name	*(char)
;	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
++	O
)	O
printf	(*(char))->(int)
(	O
"%-15s %s\n"	*(char)
,	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
name	*(char)
,	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
help	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
settogglehelp	(int)->(void)
(	O
1	int
)	O
;	O
printf	(*(char))->(int)
(	O
"%-15s %s\n"	*(char)
,	O
"?"	*(char)
,	O
"display help information"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
=	O
getset	(*(char))->(*(struct(*(char),*(char),*(()->(void)),*(char))))
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
==	O
0	int
)	O
{	O
c	int
=	O
GETTOGGLE	O
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"'%s': unknown argument ('set ?' for help).\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
Ambiguous	()->(int)
(	O
c	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"'%s': ambiguous argument ('set ?' for help).\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
c	int
->	O
variable	*(int)
)	O
{	O
if	O
(	O
(	O
argc	int
==	O
2	int
)	O
||	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
"on"	*(char)
,	O
argv	*(*(char))
[	O
2	int
]	O
)	O
==	O
0	int
)	O
)	O
*	O
c	int
->	O
variable	*(int)
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
"off"	*(char)
,	O
argv	*(*(char))
[	O
2	int
]	O
)	O
==	O
0	int
)	O
*	O
c	int
->	O
variable	*(int)
=	O
0	int
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Format is 'set togglename [on|off]'\n'set ?' for help.\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
c	int
->	O
actionexplanation	*(char)
)	O
{	O
printf	(*(char))->(int)
(	O
"%s %s.\n"	*(char)
,	O
*	O
c	int
->	O
variable	*(int)
?	O
"Will"	*(char)
:	O
"Won't"	*(char)
,	O
c	int
->	O
actionexplanation	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
c	int
->	O
handler	*(()->(int))
)	O
(	O
*	O
c	int
->	O
handler	*(()->(int))
)	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
argc	int
!=	O
3	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Format is 'set Name Value'\n'set ?' for help.\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
Ambiguous	()->(int)
(	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"'%s': ambiguous argument ('set ?' for help).\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
handler	*(()->(int))
)	O
{	O
(	O
*	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
handler	*(()->(int))
)	O
(	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%s set to \"%s\".\n"	*(char)
,	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
name	*(char)
,	O
(	O
char	O
*	O
)	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
charp	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
"off"	*(char)
,	O
argv	*(*(char))
[	O
2	int
]	O
)	O
)	O
{	O
value	int
=	O
special	(*(char))->(int)
(	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
}	O
else	O
{	O
value	int
=	O
_POSIX_VDISABLE	char
;	O
}	O
*	O
(	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
charp	*(char)
)	O
=	O
(	O
cc_t	char
)	O
value	int
;	O
printf	(*(char))->(int)
(	O
"%s character is '%s'.\n"	*(char)
,	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
name	*(char)
,	O
control	(char)->(*(char))
(	O
*	O
(	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
charp	*(char)
)	O
)	O
)	O
;	O
}	O
slc_check	()->(void)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
unsetcmd	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
struct	O
setlist	struct(*(char),*(char),*(()->(void)),*(char))
*	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
;	O
struct	O
togglelist	struct(*(char),*(char),*(()->(int)),*(int),*(char))
*	O
c	int
;	O
register	O
char	O
*	O
name	*(char)
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Need an argument to 'unset' command.  'unset ?' for help.\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
isprefix	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
"?"	*(char)
)	O
||	O
isprefix	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
"help"	*(char)
)	O
)	O
{	O
for	O
(	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
=	O
Setlist	array(struct(*(char),*(char),*(()->(void)),*(char)))
;	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
name	*(char)
;	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
++	O
)	O
printf	(*(char))->(int)
(	O
"%-15s %s\n"	*(char)
,	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
name	*(char)
,	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
help	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
settogglehelp	(int)->(void)
(	O
0	int
)	O
;	O
printf	(*(char))->(int)
(	O
"%-15s %s\n"	*(char)
,	O
"?"	*(char)
,	O
"display help information"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
argc	int
--	O
;	O
argv	*(*(char))
++	O
;	O
while	O
(	O
argc	int
--	O
)	O
{	O
name	*(char)
=	O
*	O
argv	*(*(char))
++	O
;	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
=	O
getset	(*(char))->(*(struct(*(char),*(char),*(()->(void)),*(char))))
(	O
name	*(char)
)	O
;	O
if	O
(	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
==	O
0	int
)	O
{	O
c	int
=	O
GETTOGGLE	O
(	O
name	*(char)
)	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"'%s': unknown argument ('unset ?' for help).\n"	*(char)
,	O
name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
Ambiguous	()->(int)
(	O
c	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"'%s': ambiguous argument ('unset ?' for help).\n"	*(char)
,	O
name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
c	int
->	O
variable	*(int)
)	O
{	O
*	O
c	int
->	O
variable	*(int)
=	O
0	int
;	O
if	O
(	O
c	int
->	O
actionexplanation	*(char)
)	O
{	O
printf	(*(char))->(int)
(	O
"%s %s.\n"	*(char)
,	O
*	O
c	int
->	O
variable	*(int)
?	O
"Will"	*(char)
:	O
"Won't"	*(char)
,	O
c	int
->	O
actionexplanation	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
c	int
->	O
handler	*(()->(int))
)	O
(	O
*	O
c	int
->	O
handler	*(()->(int))
)	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
Ambiguous	()->(int)
(	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"'%s': ambiguous argument ('unset ?' for help).\n"	*(char)
,	O
name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
handler	*(()->(int))
)	O
{	O
(	O
*	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
handler	*(()->(int))
)	O
(	O
0	int
)	O
;	O
printf	(*(char))->(int)
(	O
"%s reset to \"%s\".\n"	*(char)
,	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
name	*(char)
,	O
(	O
char	O
*	O
)	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
charp	*(char)
)	O
;	O
}	O
else	O
{	O
*	O
(	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
charp	*(char)
)	O
=	O
_POSIX_VDISABLE	char
;	O
printf	(*(char))->(int)
(	O
"%s character is '%s'.\n"	*(char)
,	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
name	*(char)
,	O
control	(char)->(*(char))
(	O
*	O
(	O
ct	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
charp	*(char)
)	O
)	O
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
extern	O
int	O
kludgelinemode	int
;	O
static	O
int	O
dokludgemode	()->(int)
(	O
void	O
)	O
{	O
kludgelinemode	int
=	O
1	int
;	O
send_wont	(int,int)->(void)
(	O
TELOPT_LINEMODE	int
,	O
1	int
)	O
;	O
send_dont	(int,int)->(void)
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
send_dont	(int,int)->(void)
(	O
TELOPT_ECHO	int
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dolinemode	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
kludgelinemode	int
)	O
send_dont	(int,int)->(void)
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
send_will	(int,int)->(void)
(	O
TELOPT_LINEMODE	int
,	O
1	int
)	O
;	O
send_dont	(int,int)->(void)
(	O
TELOPT_ECHO	int
,	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
docharmode	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
kludgelinemode	int
)	O
send_do	(int,int)->(void)
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
else	O
send_wont	(int,int)->(void)
(	O
TELOPT_LINEMODE	int
,	O
1	int
)	O
;	O
send_do	(int,int)->(void)
(	O
TELOPT_ECHO	int
,	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
dolmmode	(int,int)->(int)
(	O
int	O
bit	int
,	O
int	O
on	int
)	O
{	O
unsigned	O
char	O
c	int
;	O
extern	O
int	O
linemode	int
;	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"?Need to have LINEMODE option enabled first.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"'mode ?' for help.\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
on	int
)	O
c	int
=	O
(	O
linemode	int
|	O
bit	int
)	O
;	O
else	O
c	int
=	O
(	O
linemode	int
&	O
~	O
bit	int
)	O
;	O
lm_mode	(*(char),int,int)->(void)
(	O
&	O
c	int
,	O
1	int
,	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
int	O
set_mode	(int)->(int)
(	O
int	O
bit	int
)	O
{	O
return	O
dolmmode	(int,int)->(int)
(	O
bit	int
,	O
1	int
)	O
;	O
}	O
int	O
clear_mode	(int)->(int)
(	O
int	O
bit	int
)	O
{	O
return	O
dolmmode	(int,int)->(int)
(	O
bit	int
,	O
0	int
)	O
;	O
}	O
struct	O
modelist	array(struct(*(char),char))
{	O
const	O
char	O
*	O
name	*(char)
;	O
const	O
char	O
*	O
help	*(char)
;	O
int	O
(	O
*	O
handler	*(()->(int))
)	O
(	O
)	O
;	O
int	O
needconnect	int
;	O
int	O
arg1	int
;	O
}	O
;	O
extern	O
int	O
modehelp	()->(int)
(	O
void	O
)	O
;	O
static	O
struct	O
modelist	array(struct(*(char),char))
ModeList	array(struct(*(char),*(char),*(()->(int)),int,int))
[	O
]	O
=	O
{	O
{	O
"character"	*(char)
,	O
"Disable LINEMODE option"	*(char)
,	O
docharmode	()->(int)
,	O
1	int
}	O
,	O
{	O
""	*(char)
,	O
"(or disable obsolete line-by-line mode)"	*(char)
,	O
0	int
}	O
,	O
{	O
"line"	*(char)
,	O
"Enable LINEMODE option"	*(char)
,	O
dolinemode	()->(int)
,	O
1	int
}	O
,	O
{	O
""	*(char)
,	O
"(or enable obsolete line-by-line mode)"	*(char)
,	O
0	int
}	O
,	O
{	O
""	*(char)
,	O
""	*(char)
,	O
0	int
}	O
,	O
{	O
""	*(char)
,	O
"These require the LINEMODE option to be enabled"	*(char)
,	O
0	int
}	O
,	O
{	O
"isig"	*(char)
,	O
"Enable signal trapping"	*(char)
,	O
set_mode	(int)->(int)
,	O
1	int
,	O
MODE_TRAPSIG	int
}	O
,	O
{	O
"+isig"	*(char)
,	O
0	int
,	O
set_mode	(int)->(int)
,	O
1	int
,	O
MODE_TRAPSIG	int
}	O
,	O
{	O
"-isig"	*(char)
,	O
"Disable signal trapping"	*(char)
,	O
clear_mode	(int)->(int)
,	O
1	int
,	O
MODE_TRAPSIG	int
}	O
,	O
{	O
"edit"	*(char)
,	O
"Enable character editing"	*(char)
,	O
set_mode	(int)->(int)
,	O
1	int
,	O
MODE_EDIT	int
}	O
,	O
{	O
"+edit"	*(char)
,	O
0	int
,	O
set_mode	(int)->(int)
,	O
1	int
,	O
MODE_EDIT	int
}	O
,	O
{	O
"-edit"	*(char)
,	O
"Disable character editing"	*(char)
,	O
clear_mode	(int)->(int)
,	O
1	int
,	O
MODE_EDIT	int
}	O
,	O
{	O
"softtabs"	*(char)
,	O
"Enable tab expansion"	*(char)
,	O
set_mode	(int)->(int)
,	O
1	int
,	O
MODE_SOFT_TAB	int
}	O
,	O
{	O
"+softtabs"	*(char)
,	O
0	int
,	O
set_mode	(int)->(int)
,	O
1	int
,	O
MODE_SOFT_TAB	int
}	O
,	O
{	O
"-softtabs"	*(char)
,	O
"Disable character editing"	*(char)
,	O
clear_mode	(int)->(int)
,	O
1	int
,	O
MODE_SOFT_TAB	int
}	O
,	O
{	O
"litecho"	*(char)
,	O
"Enable literal character echo"	*(char)
,	O
set_mode	(int)->(int)
,	O
1	int
,	O
MODE_LIT_ECHO	int
}	O
,	O
{	O
"+litecho"	*(char)
,	O
0	int
,	O
set_mode	(int)->(int)
,	O
1	int
,	O
MODE_LIT_ECHO	int
}	O
,	O
{	O
"-litecho"	*(char)
,	O
"Disable literal character echo"	*(char)
,	O
clear_mode	(int)->(int)
,	O
1	int
,	O
MODE_LIT_ECHO	int
}	O
,	O
{	O
"help"	*(char)
,	O
0	int
,	O
modehelp	()->(int)
,	O
0	int
}	O
,	O
{	O
"kludgeline"	*(char)
,	O
0	int
,	O
dokludgemode	()->(int)
,	O
1	int
}	O
,	O
{	O
""	*(char)
,	O
""	*(char)
,	O
0	int
}	O
,	O
{	O
"?"	*(char)
,	O
"Print help information"	*(char)
,	O
modehelp	()->(int)
,	O
0	int
}	O
,	O
{	O
0	int
}	O
,	O
}	O
;	O
int	O
modehelp	()->(int)
(	O
void	O
)	O
{	O
struct	O
modelist	array(struct(*(char),char))
*	O
mt	*(struct(*(char),*(char),*(()->(int)),int,int))
;	O
printf	(*(char))->(int)
(	O
"format is:  'mode Mode', where 'Mode' is one of:\n\n"	*(char)
)	O
;	O
for	O
(	O
mt	*(struct(*(char),*(char),*(()->(int)),int,int))
=	O
ModeList	array(struct(*(char),*(char),*(()->(int)),int,int))
;	O
mt	*(struct(*(char),*(char),*(()->(int)),int,int))
->	O
name	*(char)
;	O
mt	*(struct(*(char),*(char),*(()->(int)),int,int))
++	O
)	O
{	O
if	O
(	O
mt	*(struct(*(char),*(char),*(()->(int)),int,int))
->	O
help	*(char)
)	O
{	O
if	O
(	O
*	O
mt	*(struct(*(char),*(char),*(()->(int)),int,int))
->	O
help	*(char)
)	O
printf	(*(char))->(int)
(	O
"%-15s %s\n"	*(char)
,	O
mt	*(struct(*(char),*(char),*(()->(int)),int,int))
->	O
name	*(char)
,	O
mt	*(struct(*(char),*(char),*(()->(int)),int,int))
->	O
help	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
modecmd	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
struct	O
modelist	array(struct(*(char),char))
*	O
mt	*(struct(*(char),*(char),*(()->(int)),int,int))
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
printf	(*(char))->(int)
(	O
"'mode' command requires an argument\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"'mode ?' for help.\n"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
(	O
mt	*(struct(*(char),*(char),*(()->(int)),int,int))
=	O
GETMODECMD	O
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
)	O
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Unknown mode '%s' ('mode ?' for help).\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
Ambiguous	()->(int)
(	O
mt	*(struct(*(char),*(char),*(()->(int)),int,int))
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Ambiguous mode '%s' ('mode ?' for help).\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
mt	*(struct(*(char),*(char),*(()->(int)),int,int))
->	O
needconnect	int
&&	O
!	O
connected	int
)	O
{	O
printf	(*(char))->(int)
(	O
"?Need to be connected first.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"'mode ?' for help.\n"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
mt	*(struct(*(char),*(char),*(()->(int)),int,int))
->	O
handler	*(()->(int))
)	O
{	O
return	O
(	O
*	O
mt	*(struct(*(char),*(char),*(()->(int)),int,int))
->	O
handler	*(()->(int))
)	O
(	O
mt	*(struct(*(char),*(char),*(()->(int)),int,int))
->	O
arg1	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
display	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
struct	O
togglelist	struct(*(char),*(char),*(()->(int)),*(int),*(char))
*	O
tl	*(struct(*(char),*(char),*(()->(int)),*(int),*(char)))
;	O
struct	O
setlist	struct(*(char),*(char),*(()->(void)),*(char))
*	O
sl	*(struct(*(char),*(char),*(()->(void)),*(char)))
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
for	O
(	O
tl	*(struct(*(char),*(char),*(()->(int)),*(int),*(char)))
=	O
Togglelist	array(struct(*(char),*(char),*(()->(int)),*(int),*(char)))
;	O
tl	*(struct(*(char),*(char),*(()->(int)),*(int),*(char)))
->	O
name	*(char)
;	O
tl	*(struct(*(char),*(char),*(()->(int)),*(int),*(char)))
++	O
)	O
{	O
dotog	O
(	O
tl	*(struct(*(char),*(char),*(()->(int)),*(int),*(char)))
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
for	O
(	O
sl	*(struct(*(char),*(char),*(()->(void)),*(char)))
=	O
Setlist	array(struct(*(char),*(char),*(()->(void)),*(char)))
;	O
sl	*(struct(*(char),*(char),*(()->(void)),*(char)))
->	O
name	*(char)
;	O
sl	*(struct(*(char),*(char),*(()->(void)),*(char)))
++	O
)	O
{	O
doset	O
(	O
sl	*(struct(*(char),*(char),*(()->(void)),*(char)))
)	O
;	O
}	O
}	O
else	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
sl	*(struct(*(char),*(char),*(()->(void)),*(char)))
=	O
getset	(*(char))->(*(struct(*(char),*(char),*(()->(void)),*(char))))
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
tl	*(struct(*(char),*(char),*(()->(int)),*(int),*(char)))
=	O
GETTOGGLE	O
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
Ambiguous	()->(int)
(	O
sl	*(struct(*(char),*(char),*(()->(void)),*(char)))
)	O
||	O
Ambiguous	()->(int)
(	O
tl	*(struct(*(char),*(char),*(()->(int)),*(int),*(char)))
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"?Ambiguous argument '%s'.\n"	*(char)
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
sl	*(struct(*(char),*(char),*(()->(void)),*(char)))
&&	O
!	O
tl	*(struct(*(char),*(char),*(()->(int)),*(int),*(char)))
)	O
{	O
printf	(*(char))->(int)
(	O
"?Unknown argument '%s'.\n"	*(char)
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
tl	*(struct(*(char),*(char),*(()->(int)),*(int),*(char)))
)	O
{	O
dotog	O
(	O
tl	*(struct(*(char),*(char),*(()->(int)),*(int),*(char)))
)	O
;	O
}	O
if	O
(	O
sl	*(struct(*(char),*(char),*(()->(void)),*(char)))
)	O
{	O
doset	O
(	O
sl	*(struct(*(char),*(char),*(()->(void)),*(char)))
)	O
;	O
}	O
}	O
}	O
}	O
optionstatus	()->(void)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
setescape	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
register	O
char	O
*	O
arg	*(char)
;	O
char	O
buf	*(char)
[	O
50	int
]	O
;	O
printf	(*(char))->(int)
(	O
"Deprecated usage - please use 'set escape%s%s' in the future.\n"	*(char)
,	O
(	O
argc	int
>	O
2	int
)	O
?	O
" "	*(char)
:	O
""	*(char)
,	O
(	O
argc	int
>	O
2	int
)	O
?	O
argv	*(*(char))
[	O
1	int
]	O
:	O
""	*(char)
)	O
;	O
if	O
(	O
argc	int
>	O
2	int
)	O
arg	*(char)
=	O
argv	*(*(char))
[	O
1	int
]	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"new escape character: "	*(char)
)	O
;	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
arg	*(char)
=	O
buf	*(char)
;	O
}	O
if	O
(	O
arg	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
escape	char
=	O
arg	*(char)
[	O
0	int
]	O
;	O
if	O
(	O
!	O
In3270	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Escape character is '%s'.\n"	*(char)
,	O
control	(char)->(*(char))
(	O
escape	char
)	O
)	O
;	O
}	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
togcrmod	()->(int)
(	O
void	O
)	O
{	O
crmod	int
=	O
!	O
crmod	int
;	O
printf	(*(char))->(int)
(	O
"Deprecated usage - please use 'toggle crmod' in the future.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"%s map carriage return on output.\n"	*(char)
,	O
crmod	int
?	O
"Will"	*(char)
:	O
"Won't"	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
1	int
;	O
}	O
int	O
suspend	()->(int)
(	O
void	O
)	O
{	O
setcommandmode	()->(void)
(	O
)	O
;	O
{	O
long	O
oldrows	long
,	O
oldcols	long
,	O
newrows	long
,	O
newcols	long
,	O
err	long
;	O
err	long
=	O
(	O
TerminalWindowSize	(*(long),*(long))->(int)
(	O
&	O
oldrows	long
,	O
&	O
oldcols	long
)	O
==	O
0	int
)	O
?	O
1	int
:	O
0	int
;	O
kill	(int,int)->(int)
(	O
0	int
,	O
SIGTSTP	int
)	O
;	O
if	O
(	O
TerminalWindowSize	(*(long),*(long))->(int)
(	O
&	O
newrows	long
,	O
&	O
newcols	long
)	O
&&	O
connected	int
&&	O
(	O
err	long
||	O
(	O
(	O
oldrows	long
!=	O
newrows	long
)	O
||	O
(	O
oldcols	long
!=	O
newcols	long
)	O
)	O
)	O
)	O
{	O
sendnaws	()->(void)
(	O
)	O
;	O
}	O
}	O
TerminalSaveState	()->(void)
(	O
)	O
;	O
setconnmode	(int)->(void)
(	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
int	O
shell	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
long	O
oldrows	long
,	O
oldcols	long
,	O
newrows	long
,	O
newcols	long
,	O
err	long
;	O
setcommandmode	()->(void)
(	O
)	O
;	O
err	long
=	O
(	O
TerminalWindowSize	(*(long),*(long))->(int)
(	O
&	O
oldrows	long
,	O
&	O
oldcols	long
)	O
==	O
0	int
)	O
?	O
1	int
:	O
0	int
;	O
switch	O
(	O
vfork	()->(int)
(	O
)	O
)	O
{	O
case	O
-	O
1	int
:	O
perror	(*(char))->(void)
(	O
"Fork failed\n"	*(char)
)	O
;	O
break	O
;	O
case	O
0	int
:	O
{	O
register	O
char	O
*	O
shellp	*(char)
,	O
*	O
shellname	*(char)
;	O
extern	O
char	O
*	O
strrchr	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
shellp	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"SHELL"	*(char)
)	O
;	O
if	O
(	O
shellp	*(char)
==	O
NULL	O
)	O
shellp	*(char)
=	O
"/bin/sh"	*(char)
;	O
if	O
(	O
(	O
shellname	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
shellp	*(char)
,	O
'/'	O
)	O
)	O
==	O
0	int
)	O
shellname	*(char)
=	O
shellp	*(char)
;	O
else	O
shellname	*(char)
++	O
;	O
if	O
(	O
argc	int
>	O
1	int
)	O
execl	(*(char),*(char))->(int)
(	O
shellp	*(char)
,	O
shellname	*(char)
,	O
"-c"	*(char)
,	O
&	O
saveline	array(char)
[	O
1	int
]	O
,	O
NULL	O
)	O
;	O
else	O
execl	(*(char),*(char))->(int)
(	O
shellp	*(char)
,	O
shellname	*(char)
,	O
NULL	O
)	O
;	O
perror	(*(char))->(void)
(	O
"Execl"	*(char)
)	O
;	O
_exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
default	O
:	O
wait	(*(int))->(int)
(	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
TerminalWindowSize	(*(long),*(long))->(int)
(	O
&	O
newrows	long
,	O
&	O
newcols	long
)	O
&&	O
connected	int
&&	O
(	O
err	long
||	O
(	O
(	O
oldrows	long
!=	O
newrows	long
)	O
||	O
(	O
oldcols	long
!=	O
newcols	long
)	O
)	O
)	O
)	O
{	O
sendnaws	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
bye	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
extern	O
int	O
resettermname	int
;	O
if	O
(	O
connected	int
)	O
{	O
shutdown	(int,int)->(int)
(	O
net	int
,	O
2	int
)	O
;	O
printf	(*(char))->(int)
(	O
"Connection closed.\n"	*(char)
)	O
;	O
NetClose	(int)->(int)
(	O
net	int
)	O
;	O
connected	int
=	O
0	int
;	O
resettermname	int
=	O
1	int
;	O
tninit	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
(	O
argc	int
!=	O
2	int
)	O
||	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
"fromquit"	*(char)
)	O
!=	O
0	int
)	O
)	O
{	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
toplevel	array(struct(array(long),int,struct(array(long))))
,	O
1	int
)	O
;	O
}	O
return	O
1	int
;	O
}	O
int	O
quit	()->(int)
(	O
void	O
)	O
{	O
call	(*((int,array(*(char)))->(int)))->(int)
(	O
bye	(int,array(*(char)))->(int)
,	O
"bye"	*(char)
,	O
"fromquit"	*(char)
,	O
0	int
)	O
;	O
Exit	(int)->(void)
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
logout	()->(int)
(	O
void	O
)	O
{	O
send_do	(int,int)->(void)
(	O
TELOPT_LOGOUT	int
,	O
1	int
)	O
;	O
netflush	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
struct	O
slclist	struct(*(char),*(char),*(()->(void)),int)
{	O
const	O
char	O
*	O
name	*(char)
;	O
const	O
char	O
*	O
help	*(char)
;	O
void	O
(	O
*	O
handler	*(()->(int))
)	O
(	O
)	O
;	O
int	O
arg	*(char)
;	O
}	O
;	O
static	O
void	O
slc_help	()->(void)
(	O
void	O
)	O
;	O
struct	O
slclist	struct(*(char),*(char),*(()->(void)),int)
SlcList	array(struct(*(char),*(char),*(()->(void)),int))
[	O
]	O
=	O
{	O
{	O
"export"	*(char)
,	O
"Use local special character definitions"	*(char)
,	O
slc_mode_export	()->(void)
,	O
0	int
}	O
,	O
{	O
"import"	*(char)
,	O
"Use remote special character definitions"	*(char)
,	O
slc_mode_import	(int)->(void)
,	O
1	int
}	O
,	O
{	O
"check"	*(char)
,	O
"Verify remote special character definitions"	*(char)
,	O
slc_mode_import	(int)->(void)
,	O
0	int
}	O
,	O
{	O
"help"	*(char)
,	O
0	int
,	O
slc_help	()->(void)
,	O
0	int
}	O
,	O
{	O
"?"	*(char)
,	O
"Print help information"	*(char)
,	O
slc_help	()->(void)
,	O
0	int
}	O
,	O
{	O
0	int
}	O
,	O
}	O
;	O
static	O
void	O
slc_help	()->(void)
(	O
void	O
)	O
{	O
struct	O
slclist	struct(*(char),*(char),*(()->(void)),int)
*	O
c	int
;	O
for	O
(	O
c	int
=	O
SlcList	array(struct(*(char),*(char),*(()->(void)),int))
;	O
c	int
->	O
name	*(char)
;	O
c	int
++	O
)	O
{	O
if	O
(	O
c	int
->	O
help	*(char)
)	O
{	O
if	O
(	O
*	O
c	int
->	O
help	*(char)
)	O
printf	(*(char))->(int)
(	O
"%-15s %s\n"	*(char)
,	O
c	int
->	O
name	*(char)
,	O
c	int
->	O
help	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
}	O
}	O
static	O
struct	O
slclist	struct(*(char),*(char),*(()->(void)),int)
*	O
getslc	(*(char))->(*(struct(*(char),*(char),*(()->(void)),int)))
(	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
(	O
struct	O
slclist	struct(*(char),*(char),*(()->(void)),int)
*	O
)	O
genget	(*(char),*(*(char)),int)->(*(*(char)))
(	O
name	*(char)
,	O
(	O
char	O
*	O
*	O
)	O
SlcList	array(struct(*(char),*(char),*(()->(void)),int))
,	O
sizeof	O
(	O
struct	O
slclist	struct(*(char),*(char),*(()->(void)),int)
)	O
)	O
;	O
}	O
static	O
int	O
slccmd	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
struct	O
slclist	struct(*(char),*(char),*(()->(void)),int)
*	O
c	int
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Need an argument to 'slc' command.  'slc ?' for help.\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
c	int
=	O
getslc	(*(char))->(*(struct(*(char),*(char),*(()->(void)),int)))
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"'%s': unknown argument ('slc ?' for help).\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
Ambiguous	()->(int)
(	O
c	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"'%s': ambiguous argument ('slc ?' for help).\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
(	O
*	O
c	int
->	O
handler	*(()->(int))
)	O
(	O
c	int
->	O
arg	*(char)
)	O
;	O
slcstate	()->(void)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
struct	O
envlist	struct(*(char),*(char),*(()->(void)),int)
{	O
const	O
char	O
*	O
name	*(char)
;	O
const	O
char	O
*	O
help	*(char)
;	O
void	O
(	O
*	O
handler	*(()->(int))
)	O
(	O
)	O
;	O
int	O
narg	int
;	O
}	O
;	O
extern	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
env_define	(*(char),*(char))->(*(struct))
(	O
const	O
char	O
*	O
,	O
unsigned	O
char	O
*	O
)	O
;	O
extern	O
void	O
env_undefine	(*(char))->(void)
(	O
const	O
char	O
*	O
)	O
,	O
env_export	(*(char))->(void)
(	O
const	O
char	O
*	O
)	O
,	O
env_unexport	(*(char))->(void)
(	O
const	O
char	O
*	O
)	O
,	O
env_send	(*(char))->(void)
(	O
const	O
char	O
*	O
)	O
,	O
env_list	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
env_help	()->(void)
(	O
void	O
)	O
;	O
struct	O
envlist	struct(*(char),*(char),*(()->(void)),int)
EnvList	array(struct(*(char),*(char),*(()->(void)),int))
[	O
]	O
=	O
{	O
{	O
"define"	*(char)
,	O
"Define an environment variable"	*(char)
,	O
(	O
void	O
(	O
*	O
)	O
(	O
)	O
)	O
env_define	(*(char),*(char))->(*(struct))
,	O
2	int
}	O
,	O
{	O
"undefine"	*(char)
,	O
"Undefine an environment variable"	*(char)
,	O
env_undefine	(*(char))->(void)
,	O
1	int
}	O
,	O
{	O
"export"	*(char)
,	O
"Mark an environment variable for automatic export"	*(char)
,	O
env_export	(*(char))->(void)
,	O
1	int
}	O
,	O
{	O
"unexport"	*(char)
,	O
"Don't mark an environment variable for automatic export"	*(char)
,	O
env_unexport	(*(char))->(void)
,	O
1	int
}	O
,	O
{	O
"send"	*(char)
,	O
"Send an environment variable"	*(char)
,	O
env_send	(*(char))->(void)
,	O
1	int
}	O
,	O
{	O
"list"	*(char)
,	O
"List the current environment variables"	*(char)
,	O
env_list	()->(void)
,	O
0	int
}	O
,	O
{	O
"help"	*(char)
,	O
0	int
,	O
env_help	()->(void)
,	O
0	int
}	O
,	O
{	O
"?"	*(char)
,	O
"Print help information"	*(char)
,	O
env_help	()->(void)
,	O
0	int
}	O
,	O
{	O
0	int
}	O
,	O
}	O
;	O
static	O
void	O
env_help	()->(void)
(	O
void	O
)	O
{	O
struct	O
envlist	struct(*(char),*(char),*(()->(void)),int)
*	O
c	int
;	O
for	O
(	O
c	int
=	O
EnvList	array(struct(*(char),*(char),*(()->(void)),int))
;	O
c	int
->	O
name	*(char)
;	O
c	int
++	O
)	O
{	O
if	O
(	O
c	int
->	O
help	*(char)
)	O
{	O
if	O
(	O
*	O
c	int
->	O
help	*(char)
)	O
printf	(*(char))->(int)
(	O
"%-15s %s\n"	*(char)
,	O
c	int
->	O
name	*(char)
,	O
c	int
->	O
help	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
}	O
}	O
static	O
struct	O
envlist	struct(*(char),*(char),*(()->(void)),int)
*	O
getenvcmd	(*(char))->(*(struct(*(char),*(char),*(()->(void)),int)))
(	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
(	O
struct	O
envlist	struct(*(char),*(char),*(()->(void)),int)
*	O
)	O
genget	(*(char),*(*(char)),int)->(*(*(char)))
(	O
name	*(char)
,	O
(	O
char	O
*	O
*	O
)	O
EnvList	array(struct(*(char),*(char),*(()->(void)),int))
,	O
sizeof	O
(	O
struct	O
envlist	struct(*(char),*(char),*(()->(void)),int)
)	O
)	O
;	O
}	O
int	O
env_cmd	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
struct	O
envlist	struct(*(char),*(char),*(()->(void)),int)
*	O
c	int
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Need an argument to 'environ' command.  'environ ?' for help.\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
c	int
=	O
getenvcmd	(*(char))->(*(struct(*(char),*(char),*(()->(void)),int)))
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"'%s': unknown argument ('environ ?' for help).\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
Ambiguous	()->(int)
(	O
c	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"'%s': ambiguous argument ('environ ?' for help).\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
c	int
->	O
narg	int
+	O
2	int
!=	O
argc	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Need %s%d argument%s to 'environ %s' command.  'environ ?' for help.\n"	*(char)
,	O
c	int
->	O
narg	int
<	O
argc	int
+	O
2	int
?	O
"only "	*(char)
:	O
""	*(char)
,	O
c	int
->	O
narg	int
,	O
c	int
->	O
narg	int
==	O
1	int
?	O
""	*(char)
:	O
"s"	*(char)
,	O
c	int
->	O
name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
(	O
*	O
c	int
->	O
handler	*(()->(int))
)	O
(	O
argv	*(*(char))
[	O
2	int
]	O
,	O
argv	*(*(char))
[	O
3	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
{	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
;	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
;	O
unsigned	O
char	O
*	O
var	*(char)
;	O
unsigned	O
char	O
*	O
value	int
;	O
int	O
export	int
;	O
int	O
welldefined	int
;	O
}	O
;	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
envlisthead	struct(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)),*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
;	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
env_find	(*(char))->(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)))
(	O
const	O
char	O
*	O
var	*(char)
)	O
{	O
register	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
;	O
for	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
envlisthead	struct(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)),*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
.	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
(	O
char	O
*	O
)	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
var	*(char)
,	O
var	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
)	O
;	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
void	O
env_init	()->(void)
(	O
void	O
)	O
{	O
extern	O
char	O
*	O
*	O
environ	*(*(char))
;	O
register	O
char	O
*	O
*	O
epp	*(*(char))
,	O
*	O
cp	*(char)
;	O
register	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
;	O
extern	O
char	O
*	O
strchr	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
for	O
(	O
epp	*(*(char))
=	O
environ	*(*(char))
;	O
*	O
epp	*(*(char))
;	O
epp	*(*(char))
++	O
)	O
{	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
*	O
epp	*(*(char))
,	O
'='	O
)	O
;	O
if	O
(	O
cp	*(char)
)	O
{	O
*	O
cp	*(char)
=	O
'\0'	O
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
env_define	(*(char),*(char))->(*(struct))
(	O
*	O
epp	*(*(char))
,	O
(	O
unsigned	O
char	O
*	O
)	O
cp	*(char)
+	O
1	int
)	O
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
export	int
=	O
0	int
;	O
*	O
cp	*(char)
=	O
'='	O
;	O
}	O
}	O
if	O
(	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
env_find	(*(char))->(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)))
(	O
"DISPLAY"	*(char)
)	O
)	O
&&	O
(	O
(	O
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
value	int
==	O
':'	O
)	O
||	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
(	O
char	O
*	O
)	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
value	int
,	O
"unix:"	*(char)
,	O
5	int
)	O
==	O
0	int
)	O
)	O
)	O
{	O
char	O
*	O
hostname	*(char)
=	O
localhost	()->(*(char))
(	O
)	O
;	O
char	O
*	O
cp2	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
(	O
char	O
*	O
)	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
value	int
,	O
':'	O
)	O
;	O
cp	*(char)
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
hostname	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
cp2	*(char)
)	O
+	O
1	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
cp	*(char)
,	O
"%s%s"	*(char)
,	O
hostname	*(char)
,	O
cp2	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
value	int
)	O
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
value	int
=	O
(	O
unsigned	O
char	O
*	O
)	O
cp	*(char)
;	O
free	(*(void))->(void)
(	O
hostname	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
env_find	(*(char))->(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)))
(	O
"USER"	*(char)
)	O
==	O
NULL	O
)	O
&&	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
env_find	(*(char))->(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)))
(	O
"LOGNAME"	*(char)
)	O
)	O
)	O
{	O
env_define	(*(char),*(char))->(*(struct))
(	O
"USER"	*(char)
,	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
value	int
)	O
;	O
env_unexport	(*(char))->(void)
(	O
"USER"	*(char)
)	O
;	O
}	O
env_export	(*(char))->(void)
(	O
"DISPLAY"	*(char)
)	O
;	O
env_export	(*(char))->(void)
(	O
"PRINTER"	*(char)
)	O
;	O
}	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
env_define	(*(char),*(char))->(*(struct))
(	O
const	O
char	O
*	O
var	*(char)
,	O
unsigned	O
char	O
*	O
value	int
)	O
{	O
register	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
env_find	(*(char))->(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)))
(	O
var	*(char)
)	O
;	O
if	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
)	O
{	O
free	(*(void))->(void)
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
var	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
value	int
)	O
;	O
}	O
else	O
{	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
(	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
)	O
)	O
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
envlisthead	struct(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)),*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
.	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
;	O
envlisthead	struct(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)),*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
.	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
&	O
envlisthead	struct(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)),*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
;	O
if	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
)	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
;	O
}	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
welldefined	int
=	O
opt_welldefined	(*(char))->(int)
(	O
(	O
char	O
*	O
)	O
var	*(char)
)	O
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
export	int
=	O
1	int
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
var	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
strdup	(*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
var	*(char)
)	O
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
value	int
=	O
(	O
unsigned	O
char	O
*	O
)	O
strdup	(*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
value	int
)	O
;	O
return	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
)	O
;	O
}	O
void	O
env_undefine	(*(char))->(void)
(	O
const	O
char	O
*	O
var	*(char)
)	O
{	O
register	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
env_find	(*(char))->(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)))
(	O
var	*(char)
)	O
;	O
if	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
)	O
{	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
;	O
if	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
)	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
;	O
free	(*(void))->(void)
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
var	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
value	int
)	O
;	O
free	(*(void))->(void)
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
)	O
;	O
}	O
}	O
void	O
env_export	(*(char))->(void)
(	O
const	O
char	O
*	O
var	*(char)
)	O
{	O
register	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
env_find	(*(char))->(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)))
(	O
var	*(char)
)	O
;	O
if	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
)	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
export	int
=	O
1	int
;	O
}	O
void	O
env_unexport	(*(char))->(void)
(	O
const	O
char	O
*	O
var	*(char)
)	O
{	O
register	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
env_find	(*(char))->(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)))
(	O
var	*(char)
)	O
;	O
if	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
)	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
export	int
=	O
0	int
;	O
}	O
void	O
env_send	(*(char))->(void)
(	O
const	O
char	O
*	O
var	*(char)
)	O
{	O
register	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
;	O
if	O
(	O
my_state_is_wont	O
(	O
TELOPT_NEW_ENVIRON	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Cannot send '%s': Telnet ENVIRON option not enabled\n"	*(char)
,	O
var	*(char)
)	O
;	O
return	O
;	O
}	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
env_find	(*(char))->(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)))
(	O
var	*(char)
)	O
;	O
if	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Cannot send '%s': variable not defined\n"	*(char)
,	O
var	*(char)
)	O
;	O
return	O
;	O
}	O
env_opt_start_info	()->(void)
(	O
)	O
;	O
env_opt_add	(*(char))->(void)
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
var	*(char)
)	O
;	O
env_opt_end	(int)->(void)
(	O
0	int
)	O
;	O
}	O
void	O
env_list	()->(void)
(	O
void	O
)	O
{	O
register	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
;	O
for	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
envlisthead	struct(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)),*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
.	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
)	O
{	O
printf	(*(char))->(int)
(	O
"%c %-20s %s\n"	*(char)
,	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
export	int
?	O
'*'	O
:	O
' '	O
,	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
var	*(char)
,	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
value	int
)	O
;	O
}	O
}	O
unsigned	O
char	O
*	O
env_default	(int,int)->(*(char))
(	O
int	O
init	int
,	O
int	O
welldefined	int
)	O
{	O
static	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
nep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
NULL	O
;	O
if	O
(	O
init	int
)	O
{	O
nep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
&	O
envlisthead	struct(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)),*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
nep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
)	O
{	O
while	O
(	O
(	O
nep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
nep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
)	O
)	O
{	O
if	O
(	O
nep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
export	int
&&	O
(	O
nep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
welldefined	int
==	O
welldefined	int
)	O
)	O
return	O
(	O
nep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
var	*(char)
)	O
;	O
}	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
unsigned	O
char	O
*	O
env_getvalue	(*(char))->(*(char))
(	O
const	O
char	O
*	O
var	*(char)
)	O
{	O
register	O
struct	O
env_lst	struct(*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int)),*(char),*(char),int,int)
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
=	O
env_find	(*(char))->(*(struct(*(struct(*`,*`,*`,*`,int,int)),*(struct(*`,*`,*`,*`,int,int)),*(char),*(char),int,int)))
(	O
var	*(char)
)	O
;	O
if	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
)	O
return	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(struct(*(struct`),*(struct`),*(char),*(char),int,int)),*(char),*(char),int,int))
->	O
value	int
)	O
;	O
return	O
(	O
NULL	O
)	O
;	O
}	O
static	O
int	O
status	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
if	O
(	O
connected	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Connected to %s.\n"	*(char)
,	O
hostname	*(char)
)	O
;	O
if	O
(	O
(	O
argc	int
<	O
2	int
)	O
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
"notmuch"	*(char)
)	O
)	O
{	O
int	O
mode	int
=	O
getconnmode	()->(int)
(	O
)	O
;	O
if	O
(	O
my_want_state_is_will	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Operating with LINEMODE option\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"%s line editing\n"	*(char)
,	O
(	O
mode	int
&	O
MODE_EDIT	int
)	O
?	O
"Local"	*(char)
:	O
"No"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"%s catching of signals\n"	*(char)
,	O
(	O
mode	int
&	O
MODE_TRAPSIG	int
)	O
?	O
"Local"	*(char)
:	O
"No"	*(char)
)	O
;	O
slcstate	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
kludgelinemode	int
&&	O
my_want_state_is_dont	O
(	O
TELOPT_SGA	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Operating in obsolete linemode\n"	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Operating in single character mode\n"	*(char)
)	O
;	O
if	O
(	O
localchars	int
)	O
printf	(*(char))->(int)
(	O
"Catching signals locally\n"	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"%s character echo\n"	*(char)
,	O
(	O
mode	int
&	O
MODE_ECHO	int
)	O
?	O
"Local"	*(char)
:	O
"Remote"	*(char)
)	O
;	O
if	O
(	O
my_want_state_is_will	O
(	O
TELOPT_LFLOW	int
)	O
)	O
printf	(*(char))->(int)
(	O
"%s flow control\n"	*(char)
,	O
(	O
mode	int
&	O
MODE_FLOW	int
)	O
?	O
"Local"	*(char)
:	O
"No"	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"No connection.\n"	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"Escape character is '%s'.\n"	*(char)
,	O
control	(char)->(*(char))
(	O
escape	char
)	O
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
cmdrc	(*(char),*(char))->(void)
(	O
char	O
*	O
m1	*(char)
,	O
char	O
*	O
m2	*(char)
)	O
;	O
int	O
tn	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
struct	O
addrinfo	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`))))))
*	O
result	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
,	O
*	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
,	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
;	O
const	O
int	O
on	int
=	O
1	int
;	O
int	O
err	long
;	O
char	O
*	O
cmd	*(char)
,	O
*	O
hostp	*(char)
=	O
0	int
,	O
*	O
portp	*(char)
=	O
0	int
,	O
*	O
user	*(char)
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
0	int
,	O
sizeof	O
(	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
)	O
)	O
;	O
if	O
(	O
connected	int
)	O
{	O
printf	(*(char))->(int)
(	O
"?Already connected to %s\n"	*(char)
,	O
hostname	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
line	*(char)
,	O
"open "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"(to) "	*(char)
)	O
;	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
&	O
line	*(char)
[	O
strlen	(*(char))->(long)
(	O
line	*(char)
)	O
]	O
,	O
sizeof	O
(	O
line	*(char)
)	O
-	O
strlen	(*(char))->(long)
(	O
line	*(char)
)	O
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
makeargv	()->(void)
(	O
)	O
;	O
argc	int
=	O
margc	int
;	O
argv	*(*(char))
=	O
margv	array(*(char))
;	O
}	O
cmd	*(char)
=	O
*	O
argv	*(*(char))
;	O
--	O
argc	int
;	O
++	O
argv	*(*(char))
;	O
while	O
(	O
argc	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
argv	*(*(char))
,	O
"help"	*(char)
)	O
==	O
0	int
||	O
isprefix	(*(char),*(char))->(int)
(	O
*	O
argv	*(*(char))
,	O
"?"	*(char)
)	O
)	O
goto	O
usage	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
argv	*(*(char))
,	O
"-l"	*(char)
)	O
==	O
0	int
)	O
{	O
--	O
argc	int
;	O
++	O
argv	*(*(char))
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
goto	O
usage	O
;	O
user	*(char)
=	O
*	O
argv	*(*(char))
++	O
;	O
--	O
argc	int
;	O
continue	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
argv	*(*(char))
,	O
"-a"	*(char)
)	O
==	O
0	int
)	O
{	O
--	O
argc	int
;	O
++	O
argv	*(*(char))
;	O
autologin	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
argv	*(*(char))
,	O
"-6"	*(char)
)	O
==	O
0	int
)	O
{	O
--	O
argc	int
;	O
++	O
argv	*(*(char))
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_family	int
=	O
AF_INET6	O
;	O
continue	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
argv	*(*(char))
,	O
"-4"	*(char)
)	O
==	O
0	int
)	O
{	O
--	O
argc	int
;	O
++	O
argv	*(*(char))
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_family	int
=	O
AF_INET	O
;	O
continue	O
;	O
}	O
if	O
(	O
hostp	*(char)
==	O
0	int
)	O
{	O
hostp	*(char)
=	O
*	O
argv	*(*(char))
++	O
;	O
--	O
argc	int
;	O
continue	O
;	O
}	O
if	O
(	O
portp	*(char)
==	O
0	int
)	O
{	O
portp	*(char)
=	O
*	O
argv	*(*(char))
++	O
;	O
--	O
argc	int
;	O
continue	O
;	O
}	O
usage	O
:	O
printf	(*(char))->(int)
(	O
"usage: %s [-4] [-6] [-l user] [-a] host-name [port]\n"	*(char)
,	O
cmd	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
hostp	*(char)
==	O
0	int
)	O
goto	O
usage	O
;	O
if	O
(	O
!	O
portp	*(char)
)	O
{	O
portp	*(char)
=	O
"telnet"	*(char)
;	O
telnetport	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
*	O
portp	*(char)
==	O
'-'	O
)	O
{	O
portp	*(char)
++	O
;	O
telnetport	int
=	O
1	int
;	O
}	O
else	O
telnetport	int
=	O
0	int
;	O
}	O
free	(*(void))->(void)
(	O
hostname	*(char)
)	O
;	O
hostname	*(char)
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
hostp	*(char)
)	O
+	O
1	int
)	O
;	O
if	O
(	O
hostname	*(char)
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
hostname	*(char)
,	O
hostp	*(char)
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Can't allocate memory to copy hostname\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_flags	int
=	O
AI_ADDRCONFIG	int
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_socktype	int
=	O
SOCK_STREAM	int
;	O
err	long
=	O
getaddrinfo	(*(char),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))),*(*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))->(int)
(	O
hostp	*(char)
,	O
portp	*(char)
,	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
&	O
result	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
err	long
)	O
{	O
const	O
char	O
*	O
errmsg	*(char)
;	O
if	O
(	O
err	long
==	O
EAI_SYSTEM	O
)	O
errmsg	*(char)
=	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
;	O
else	O
errmsg	*(char)
=	O
gai_strerror	(int)->(*(char))
(	O
err	long
)	O
;	O
printf	(*(char))->(int)
(	O
"%s/%s: lookup failure: %s\n"	*(char)
,	O
hostp	*(char)
,	O
portp	*(char)
,	O
errmsg	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
=	O
result	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
do	O
{	O
char	O
buf	*(char)
[	O
256	int
]	O
;	O
err	long
=	O
getnameinfo	(*(struct(short,array(char))),int,*(char),int,*(char),int,int)->(int)
(	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addr	*(struct(short,array(char)))
,	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addrlen	int
,	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
NULL	O
,	O
0	int
,	O
NI_NUMERICHOST	int
)	O
;	O
if	O
(	O
err	long
)	O
{	O
const	O
char	O
*	O
errmsg	*(char)
;	O
if	O
(	O
err	long
==	O
EAI_SYSTEM	O
)	O
errmsg	*(char)
=	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
;	O
else	O
errmsg	*(char)
=	O
gai_strerror	(int)->(*(char))
(	O
err	long
)	O
;	O
printf	(*(char))->(int)
(	O
"getnameinfo error: %s\n"	*(char)
,	O
errmsg	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
printf	(*(char))->(int)
(	O
"Trying %s...\n"	*(char)
,	O
buf	*(char)
)	O
;	O
net	int
=	O
socket	(int,int,int)->(int)
(	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_family	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
net	int
<	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
"telnet: socket"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
debug	int
)	O
{	O
err	long
=	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
net	int
,	O
SOL_SOCKET	int
,	O
SO_DEBUG	int
,	O
&	O
on	int
,	O
sizeof	O
(	O
on	int
)	O
)	O
;	O
if	O
(	O
err	long
<	O
0	int
)	O
perror	(*(char))->(void)
(	O
"setsockopt (SO_DEBUG)"	*(char)
)	O
;	O
}	O
err	long
=	O
connect	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
net	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addr	*(struct(short,array(char)))
,	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addrlen	int
)	O
;	O
if	O
(	O
err	long
<	O
0	int
)	O
{	O
if	O
(	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_next	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
{	O
perror	(*(char))->(void)
(	O
"Connection failed"	*(char)
)	O
;	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
=	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_next	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
close	(int)->(int)
(	O
net	int
)	O
;	O
continue	O
;	O
}	O
perror	(*(char))->(void)
(	O
"telnet: Unable to connect to remote host"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
connected	int
++	O
;	O
}	O
while	O
(	O
!	O
connected	int
)	O
;	O
freeaddrinfo	(*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
result	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
cmdrc	(*(char),*(char))->(void)
(	O
hostp	*(char)
,	O
hostname	*(char)
)	O
;	O
if	O
(	O
autologin	int
&&	O
user	*(char)
==	O
NULL	O
)	O
{	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
user	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"USER"	*(char)
)	O
;	O
if	O
(	O
user	*(char)
==	O
NULL	O
||	O
(	O
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
user	*(char)
)	O
)	O
&&	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_uid	int
!=	O
getuid	()->(int)
(	O
)	O
)	O
)	O
{	O
if	O
(	O
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwuid	(int)->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
getuid	()->(int)
(	O
)	O
)	O
)	O
)	O
user	*(char)
=	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_name	*(char)
;	O
else	O
user	*(char)
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
user	*(char)
)	O
{	O
env_define	(*(char),*(char))->(*(struct))
(	O
"USER"	*(char)
,	O
(	O
unsigned	O
char	O
*	O
)	O
user	*(char)
)	O
;	O
env_export	(*(char))->(void)
(	O
"USER"	*(char)
)	O
;	O
}	O
call	(*((int,array(*(char)))->(int)))->(int)
(	O
status	(int,array(*(char)))->(int)
,	O
"status"	*(char)
,	O
"notmuch"	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
peerdied	array(struct(array(long),int,struct(array(long))))
)	O
==	O
0	int
)	O
telnet	(*(char))->(void)
(	O
user	*(char)
)	O
;	O
close	(int)->(int)
(	O
net	int
)	O
;	O
ExitString	(*(char),int)->(void)
(	O
"Connection closed by foreign host.\n"	*(char)
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
char	O
openhelp	array(char)
[	O
]	O
=	O
"connect to a site"	*(char)
,	O
closehelp	array(char)
[	O
]	O
=	O
"close current connection"	*(char)
,	O
logouthelp	array(char)
[	O
]	O
=	O
"forcibly logout remote user and close the connection"	*(char)
,	O
quithelp	array(char)
[	O
]	O
=	O
"exit telnet"	*(char)
,	O
statushelp	array(char)
[	O
]	O
=	O
"print status information"	*(char)
,	O
helphelp	array(char)
[	O
]	O
=	O
"print help information"	*(char)
,	O
sendhelp	array(char)
[	O
]	O
=	O
"transmit special characters ('send ?' for more)"	*(char)
,	O
sethelp	array(char)
[	O
]	O
=	O
"set operating parameters ('set ?' for more)"	*(char)
,	O
unsethelp	array(char)
[	O
]	O
=	O
"unset operating parameters ('unset ?' for more)"	*(char)
,	O
togglestring	array(char)
[	O
]	O
=	O
"toggle operating parameters ('toggle ?' for more)"	*(char)
,	O
slchelp	array(char)
[	O
]	O
=	O
"change state of special characters ('slc ?' for more)"	*(char)
,	O
displayhelp	array(char)
[	O
]	O
=	O
"display operating parameters"	*(char)
,	O
zhelp	array(char)
[	O
]	O
=	O
"suspend telnet"	*(char)
,	O
shellhelp	array(char)
[	O
]	O
=	O
"invoke a subshell"	*(char)
,	O
envhelp	array(char)
[	O
]	O
=	O
"change environment variables ('environ ?' for more)"	*(char)
,	O
modestring	array(char)
[	O
]	O
=	O
"try to enter line or character mode ('mode ?' for more)"	*(char)
;	O
static	O
int	O
help	*(char)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
;	O
static	O
Command	struct(*(char),*(char),*(()->(int)),int)
cmdtab	array(struct(*(char),*(char),*(()->(int)),int))
[	O
]	O
=	O
{	O
{	O
"close"	*(char)
,	O
closehelp	array(char)
,	O
bye	(int,array(*(char)))->(int)
,	O
1	int
}	O
,	O
{	O
"logout"	*(char)
,	O
logouthelp	array(char)
,	O
logout	()->(int)
,	O
1	int
}	O
,	O
{	O
"display"	*(char)
,	O
displayhelp	array(char)
,	O
display	(int,array(*(char)))->(int)
,	O
0	int
}	O
,	O
{	O
"mode"	*(char)
,	O
modestring	array(char)
,	O
modecmd	(int,array(*(char)))->(int)
,	O
0	int
}	O
,	O
{	O
"open"	*(char)
,	O
openhelp	array(char)
,	O
tn	(int,*(*(char)))->(int)
,	O
0	int
}	O
,	O
{	O
"quit"	*(char)
,	O
quithelp	array(char)
,	O
quit	()->(int)
,	O
0	int
}	O
,	O
{	O
"send"	*(char)
,	O
sendhelp	array(char)
,	O
sendcmd	(int,*(*(char)))->(int)
,	O
0	int
}	O
,	O
{	O
"set"	*(char)
,	O
sethelp	array(char)
,	O
setcmd	(int,array(*(char)))->(int)
,	O
0	int
}	O
,	O
{	O
"unset"	*(char)
,	O
unsethelp	array(char)
,	O
unsetcmd	(int,array(*(char)))->(int)
,	O
0	int
}	O
,	O
{	O
"status"	*(char)
,	O
statushelp	array(char)
,	O
status	(int,array(*(char)))->(int)
,	O
0	int
}	O
,	O
{	O
"toggle"	*(char)
,	O
togglestring	array(char)
,	O
toggle	(int,array(*(char)))->(int)
,	O
0	int
}	O
,	O
{	O
"slc"	*(char)
,	O
slchelp	array(char)
,	O
slccmd	(int,*(*(char)))->(int)
,	O
0	int
}	O
,	O
{	O
"z"	*(char)
,	O
zhelp	array(char)
,	O
suspend	()->(int)
,	O
0	int
}	O
,	O
{	O
"!"	*(char)
,	O
shellhelp	array(char)
,	O
shell	(int,array(*(char)))->(int)
,	O
0	int
}	O
,	O
{	O
"environ"	*(char)
,	O
envhelp	array(char)
,	O
env_cmd	(int,array(*(char)))->(int)
,	O
0	int
}	O
,	O
{	O
"?"	*(char)
,	O
helphelp	array(char)
,	O
help	*(char)
,	O
0	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
char	O
crmodhelp	array(char)
[	O
]	O
=	O
"deprecated command -- use 'toggle crmod' instead"	*(char)
;	O
static	O
char	O
escapehelp	array(char)
[	O
]	O
=	O
"deprecated command -- use 'set escape' instead"	*(char)
;	O
static	O
Command	struct(*(char),*(char),*(()->(int)),int)
cmdtab2	array(struct(*(char),*(char),*(()->(int)),int))
[	O
]	O
=	O
{	O
{	O
"help"	*(char)
,	O
0	int
,	O
help	*(char)
,	O
0	int
}	O
,	O
{	O
"escape"	*(char)
,	O
escapehelp	array(char)
,	O
setescape	(int,array(*(char)))->(int)
,	O
0	int
}	O
,	O
{	O
"crmod"	*(char)
,	O
crmodhelp	array(char)
,	O
togcrmod	()->(int)
,	O
0	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
int	O
call	(*((int,array(*(char)))->(int)))->(int)
(	O
intrtn_t	*((int,array(*(char)))->(int))
routine	*((int,array(*(char)))->(int))
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
char	O
*	O
args	array(struct(int,int,*(void),*(void)))
[	O
100	int
]	O
;	O
int	O
argno	int
=	O
0	int
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
routine	*((int,array(*(char)))->(int))
)	O
;	O
while	O
(	O
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
argno	int
++	O
]	O
=	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
char	O
*	O
)	O
)	O
!=	O
0	int
)	O
{	O
;	O
}	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
return	O
(	O
*	O
routine	*((int,array(*(char)))->(int))
)	O
(	O
argno	int
-	O
1	int
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
static	O
Command	struct(*(char),*(char),*(()->(int)),int)
*	O
getcmd	(*(char))->(*(struct(*(char),*(char),*(()->(int)),int)))
(	O
char	O
*	O
name	*(char)
)	O
{	O
Command	struct(*(char),*(char),*(()->(int)),int)
*	O
cm	*(struct(*(char),*(char),*(()->(int)),int))
;	O
if	O
(	O
(	O
cm	*(struct(*(char),*(char),*(()->(int)),int))
=	O
(	O
Command	struct(*(char),*(char),*(()->(int)),int)
*	O
)	O
genget	(*(char),*(*(char)),int)->(*(*(char)))
(	O
name	*(char)
,	O
(	O
char	O
*	O
*	O
)	O
cmdtab	array(struct(*(char),*(char),*(()->(int)),int))
,	O
sizeof	O
(	O
Command	struct(*(char),*(char),*(()->(int)),int)
)	O
)	O
)	O
)	O
return	O
cm	*(struct(*(char),*(char),*(()->(int)),int))
;	O
return	O
(	O
Command	struct(*(char),*(char),*(()->(int)),int)
*	O
)	O
genget	(*(char),*(*(char)),int)->(*(*(char)))
(	O
name	*(char)
,	O
(	O
char	O
*	O
*	O
)	O
cmdtab2	array(struct(*(char),*(char),*(()->(int)),int))
,	O
sizeof	O
(	O
Command	struct(*(char),*(char),*(()->(int)),int)
)	O
)	O
;	O
}	O
void	O
command	(int,*(char),int)->(void)
(	O
int	O
top	*(char)
,	O
char	O
*	O
tbuf	*(char)
,	O
int	O
cnt	int
)	O
{	O
register	O
Command	struct(*(char),*(char),*(()->(int)),int)
*	O
c	int
;	O
setcommandmode	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
top	*(char)
)	O
{	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
else	O
{	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGINT	int
,	O
SIG_DFL	O
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGQUIT	int
,	O
SIG_DFL	O
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
rlogin	char
==	O
_POSIX_VDISABLE	char
)	O
printf	(*(char))->(int)
(	O
"%s> "	*(char)
,	O
prompt	*(char)
)	O
;	O
if	O
(	O
tbuf	*(char)
)	O
{	O
register	O
char	O
*	O
cp	*(char)
;	O
cp	*(char)
=	O
line	*(char)
;	O
while	O
(	O
cnt	int
>	O
0	int
&&	O
(	O
*	O
cp	*(char)
++	O
=	O
*	O
tbuf	*(char)
++	O
)	O
!=	O
'\n'	O
)	O
cnt	int
--	O
;	O
tbuf	*(char)
=	O
0	int
;	O
if	O
(	O
cp	*(char)
==	O
line	*(char)
||	O
*	O
--	O
cp	*(char)
!=	O
'\n'	O
||	O
cp	*(char)
==	O
line	*(char)
)	O
goto	O
getline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
;	O
*	O
cp	*(char)
=	O
'\0'	O
;	O
if	O
(	O
rlogin	char
==	O
_POSIX_VDISABLE	char
)	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
line	*(char)
)	O
;	O
}	O
else	O
{	O
getline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
:	O
if	O
(	O
rlogin	char
!=	O
_POSIX_VDISABLE	char
)	O
printf	(*(char))->(int)
(	O
"%s> "	*(char)
,	O
prompt	*(char)
)	O
;	O
if	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
line	*(char)
,	O
sizeof	O
(	O
line	*(char)
)	O
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
||	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
quit	()->(int)
(	O
)	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
line	*(char)
[	O
0	int
]	O
==	O
0	int
)	O
break	O
;	O
makeargv	()->(void)
(	O
)	O
;	O
if	O
(	O
margv	array(*(char))
[	O
0	int
]	O
==	O
0	int
)	O
{	O
break	O
;	O
}	O
c	int
=	O
getcmd	(*(char))->(*(struct(*(char),*(char),*(()->(int)),int)))
(	O
margv	array(*(char))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
Ambiguous	()->(int)
(	O
c	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"?Ambiguous command\n"	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"?Invalid command\n"	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
->	O
needconnect	int
&&	O
!	O
connected	int
)	O
{	O
printf	(*(char))->(int)
(	O
"?Need to be connected first.\n"	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
*	O
c	int
->	O
handler	*(()->(int))
)	O
(	O
margc	int
,	O
margv	array(*(char))
)	O
)	O
{	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
top	*(char)
)	O
{	O
if	O
(	O
!	O
connected	int
)	O
{	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
toplevel	array(struct(array(long),int,struct(array(long))))
,	O
1	int
)	O
;	O
}	O
setconnmode	(int)->(void)
(	O
0	int
)	O
;	O
}	O
}	O
static	O
int	O
help	*(char)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
register	O
Command	struct(*(char),*(char),*(()->(int)),int)
*	O
c	int
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Commands may be abbreviated.  Commands are:\n\n"	*(char)
)	O
;	O
for	O
(	O
c	int
=	O
cmdtab	array(struct(*(char),*(char),*(()->(int)),int))
;	O
c	int
->	O
name	*(char)
;	O
c	int
++	O
)	O
if	O
(	O
c	int
->	O
help	*(char)
)	O
{	O
printf	(*(char))->(int)
(	O
"%-*s\t%s\n"	*(char)
,	O
HELPINDENT	O
,	O
c	int
->	O
name	*(char)
,	O
c	int
->	O
help	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
while	O
(	O
--	O
argc	int
>	O
0	int
)	O
{	O
register	O
char	O
*	O
arg	*(char)
;	O
arg	*(char)
=	O
*	O
++	O
argv	*(*(char))
;	O
c	int
=	O
getcmd	(*(char))->(*(struct(*(char),*(char),*(()->(int)),int)))
(	O
arg	*(char)
)	O
;	O
if	O
(	O
Ambiguous	()->(int)
(	O
c	int
)	O
)	O
printf	(*(char))->(int)
(	O
"?Ambiguous help command %s\n"	*(char)
,	O
arg	*(char)
)	O
;	O
else	O
if	O
(	O
c	int
==	O
(	O
Command	struct(*(char),*(char),*(()->(int)),int)
*	O
)	O
0	int
)	O
printf	(*(char))->(int)
(	O
"?Invalid help command %s\n"	*(char)
,	O
arg	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
c	int
->	O
help	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
rcname	*(char)
=	O
0	int
;	O
static	O
void	O
cmdrc	(*(char),*(char))->(void)
(	O
char	O
*	O
m1	*(char)
,	O
char	O
*	O
m2	*(char)
)	O
{	O
register	O
Command	struct(*(char),*(char),*(()->(int)),int)
*	O
c	int
;	O
FILE	struct
*	O
rcfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
gotmachine	int
=	O
0	int
;	O
int	O
l1	int
=	O
strlen	(*(char))->(long)
(	O
m1	*(char)
)	O
;	O
int	O
l2	int
=	O
strlen	(*(char))->(long)
(	O
m2	*(char)
)	O
;	O
if	O
(	O
skiprc	int
)	O
return	O
;	O
if	O
(	O
rcname	*(char)
==	O
0	int
)	O
{	O
const	O
char	O
*	O
home	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
;	O
if	O
(	O
home	*(char)
)	O
rcname	*(char)
=	O
xasprintf	(*(char))->(*(char))
(	O
"%s/.telnetrc"	*(char)
,	O
home	*(char)
)	O
;	O
else	O
rcname	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"/.telnetrc"	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
rcfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
rcname	*(char)
,	O
"r"	*(char)
)	O
)	O
==	O
0	int
)	O
{	O
return	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
line	*(char)
,	O
sizeof	O
(	O
line	*(char)
)	O
,	O
rcfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
line	*(char)
[	O
0	int
]	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
line	*(char)
[	O
0	int
]	O
==	O
'#'	O
)	O
continue	O
;	O
if	O
(	O
gotmachine	int
)	O
{	O
if	O
(	O
!	O
isspace	(int)->(int)
(	O
line	*(char)
[	O
0	int
]	O
)	O
)	O
gotmachine	int
=	O
0	int
;	O
}	O
if	O
(	O
gotmachine	int
==	O
0	int
)	O
{	O
if	O
(	O
isspace	(int)->(int)
(	O
line	*(char)
[	O
0	int
]	O
)	O
)	O
continue	O
;	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
line	*(char)
,	O
m1	*(char)
,	O
l1	int
)	O
==	O
0	int
)	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
line	*(char)
,	O
&	O
line	*(char)
[	O
l1	int
]	O
,	O
sizeof	O
(	O
line	*(char)
)	O
-	O
l1	int
)	O
;	O
else	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
line	*(char)
,	O
m2	*(char)
,	O
l2	int
)	O
==	O
0	int
)	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
line	*(char)
,	O
&	O
line	*(char)
[	O
l2	int
]	O
,	O
sizeof	O
(	O
line	*(char)
)	O
-	O
l2	int
)	O
;	O
else	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
line	*(char)
,	O
"DEFAULT"	*(char)
,	O
7	int
)	O
==	O
0	int
)	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
line	*(char)
,	O
&	O
line	*(char)
[	O
7	int
]	O
,	O
sizeof	O
(	O
line	*(char)
)	O
-	O
7	int
)	O
;	O
else	O
continue	O
;	O
if	O
(	O
line	*(char)
[	O
0	int
]	O
!=	O
' '	O
&&	O
line	*(char)
[	O
0	int
]	O
!=	O
'\t'	O
&&	O
line	*(char)
[	O
0	int
]	O
!=	O
'\n'	O
)	O
continue	O
;	O
gotmachine	int
=	O
1	int
;	O
}	O
makeargv	()->(void)
(	O
)	O
;	O
if	O
(	O
margv	array(*(char))
[	O
0	int
]	O
==	O
0	int
)	O
continue	O
;	O
c	int
=	O
getcmd	(*(char))->(*(struct(*(char),*(char),*(()->(int)),int)))
(	O
margv	array(*(char))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
Ambiguous	()->(int)
(	O
c	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"?Ambiguous command: %s\n"	*(char)
,	O
margv	array(*(char))
[	O
0	int
]	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"?Invalid command: %s\n"	*(char)
,	O
margv	array(*(char))
[	O
0	int
]	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
->	O
needconnect	int
&&	O
!	O
connected	int
)	O
{	O
printf	(*(char))->(int)
(	O
"?Need to be connected first for %s.\n"	*(char)
,	O
margv	array(*(char))
[	O
0	int
]	O
)	O
;	O
continue	O
;	O
}	O
(	O
*	O
c	int
->	O
handler	*(()->(int))
)	O
(	O
margc	int
,	O
margv	array(*(char))
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rcfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
