void	O
DoStep_by_Step	O
(	O
)	O
{	O
}	O
void	O
TransformPred	O
(	O
PANALYSIS	O
panal	O
,	O
PMCPREDOUT	O
pMCPredOut	O
)	O
{	O
OutspecToLinearArray	O
(	O
panal	O
,	O
pMCPredOut	O
)	O
;	O
}	O
void	O
OutspecToLinearArray	O
(	O
PANALYSIS	O
panal	O
,	O
PMCPREDOUT	O
pMCPredOut	O
)	O
{	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
;	O
long	O
i	O
,	O
j	O
,	O
k	O
;	O
pMCPredOut	O
->	O
nbrdy	O
=	O
0	int
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
panal	O
->	O
expGlobal	O
.	O
iExp	O
;	O
i	O
++	O
)	O
for	O
(	O
j	O
=	O
0	int
,	O
pos	O
=	O
&	O
panal	O
->	O
rgpExps	O
[	O
i	O
]	O
->	O
os	O
;	O
j	O
<	O
pos	O
->	O
nOutputs	int
;	O
j	O
++	O
)	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
pos	O
->	O
pcOutputTimes	*(int)
[	O
j	O
]	O
;	O
k	O
++	O
)	O
pMCPredOut	O
->	O
nbrdy	O
++	O
;	O
if	O
(	O
!	O
(	O
pMCPredOut	O
->	O
pred	O
)	O
)	O
if	O
(	O
!	O
(	O
pMCPredOut	O
->	O
pred	O
=	O
InitdVector	(long)->(*(double))
(	O
pMCPredOut	O
->	O
nbrdy	O
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"OutspecToLinearArray"	*(char)
,	O
NULL	O
)	O
;	O
pMCPredOut	O
->	O
nbrdy	O
=	O
0	int
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
panal	O
->	O
expGlobal	O
.	O
iExp	O
;	O
i	O
++	O
)	O
for	O
(	O
j	O
=	O
0	int
,	O
pos	O
=	O
&	O
panal	O
->	O
rgpExps	O
[	O
i	O
]	O
->	O
os	O
;	O
j	O
<	O
pos	O
->	O
nOutputs	int
;	O
j	O
++	O
)	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
pos	O
->	O
pcOutputTimes	*(int)
[	O
j	O
]	O
;	O
k	O
++	O
)	O
pMCPredOut	O
->	O
pred	O
[	O
pMCPredOut	O
->	O
nbrdy	O
++	O
]	O
=	O
pos	O
->	O
prgdOutputVals	*(*(double))
[	O
j	O
]	O
[	O
k	O
]	O
;	O
}	O
double	O
Definite_Integral	O
(	O
double	O
(	O
*	O
Function	O
)	O
(	O
double	O
)	O
,	O
double	O
dFrom	O
,	O
double	O
dTo	O
)	O
{	O
double	O
dTotal_Area	O
,	O
dDelta_Area	O
;	O
double	O
pdArea	O
[	O
MAX_STEPS	O
+	O
2	int
]	O
,	O
pdTemp	O
[	O
MAX_STEPS	O
+	O
2	int
]	O
;	O
int	O
i	O
;	O
if	O
(	O
dFrom	O
>=	O
dTo	O
)	O
{	O
if	O
(	O
dFrom	O
==	O
dTo	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"\nError: inverted integration bounds in Definite_Integral - "	*(char)
"Exiting\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
}	O
pdTemp	O
[	O
0	int
]	O
=	O
1	int
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
MAX_STEPS	O
;	O
i	O
++	O
)	O
{	O
pdArea	O
[	O
i	O
]	O
=	O
Trapezes	O
(	O
Function	O
,	O
dFrom	O
,	O
dTo	O
,	O
i	O
+	O
1	int
)	O
;	O
if	O
(	O
i	O
>=	O
MIN_STEP	O
)	O
{	O
Interpolate_Poly	O
(	O
&	O
pdTemp	O
[	O
i	O
-	O
MIN_STEP	O
]	O
,	O
&	O
pdArea	O
[	O
i	O
-	O
MIN_STEP	O
]	O
,	O
MIN_STEP	O
+	O
1	int
,	O
0.0	int
,	O
&	O
dTotal_Area	O
,	O
&	O
dDelta_Area	O
)	O
;	O
if	O
(	O
dTotal_Area	O
==	O
0	int
)	O
{	O
if	O
(	O
fabs	(double)->(double)
(	O
dDelta_Area	O
)	O
<	O
PRECISION	O
)	O
return	O
dTotal_Area	O
;	O
}	O
else	O
{	O
if	O
(	O
fabs	(double)->(double)
(	O
dDelta_Area	O
)	O
<	O
PRECISION	O
*	O
fabs	(double)->(double)
(	O
dTotal_Area	O
)	O
)	O
return	O
dTotal_Area	O
;	O
}	O
}	O
pdArea	O
[	O
i	O
+	O
1	int
]	O
=	O
pdArea	O
[	O
i	O
]	O
;	O
pdTemp	O
[	O
i	O
+	O
1	int
]	O
=	O
0.25	int
*	O
pdTemp	O
[	O
i	O
]	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\nError: Too many steps in routine Definite_Integral "	*(char)
"- Exiting\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
void	O
Interpolate_Poly	O
(	O
double	O
rgdX	O
[	O
]	O
,	O
double	O
rgdY	O
[	O
]	O
,	O
int	O
n	int
,	O
double	O
x	*(*(double))
,	O
double	O
*	O
pdY	O
,	O
double	O
*	O
pdDY	O
)	O
{	O
int	O
i	O
,	O
j	O
,	O
nIndex	O
=	O
1	int
;	O
double	O
dDenom	O
,	O
dDiff	O
,	O
dTemp1	O
,	O
dTemp2	O
;	O
static	O
PDOUBLE	*(double)
pdTerm1	O
=	O
NULL	O
,	O
pdTerm2	O
=	O
NULL	O
;	O
if	O
(	O
!	O
pdTerm1	O
)	O
if	O
(	O
!	O
(	O
pdTerm1	O
=	O
InitdVector	(long)->(*(double))
(	O
n	int
+	O
1	int
)	O
)	O
||	O
!	O
(	O
pdTerm2	O
=	O
InitdVector	(long)->(*(double))
(	O
n	int
+	O
1	int
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"Interpolate_Poly"	*(char)
,	O
NULL	O
)	O
;	O
dDiff	O
=	O
fabs	(double)->(double)
(	O
x	*(*(double))
-	O
rgdX	O
[	O
0	int
]	O
)	O
;	O
pdTerm1	O
[	O
0	int
]	O
=	O
rgdY	O
[	O
0	int
]	O
;	O
pdTerm2	O
[	O
0	int
]	O
=	O
rgdY	O
[	O
0	int
]	O
;	O
for	O
(	O
i	O
=	O
1	int
;	O
i	O
<	O
n	int
;	O
i	O
++	O
)	O
{	O
if	O
(	O
(	O
dTemp1	O
=	O
fabs	(double)->(double)
(	O
x	*(*(double))
-	O
rgdX	O
[	O
i	O
]	O
)	O
)	O
<	O
dDiff	O
)	O
{	O
nIndex	O
=	O
i	O
;	O
dDiff	O
=	O
dTemp1	O
;	O
}	O
pdTerm1	O
[	O
i	O
]	O
=	O
rgdY	O
[	O
i	O
]	O
;	O
pdTerm2	O
[	O
i	O
]	O
=	O
rgdY	O
[	O
i	O
]	O
;	O
}	O
*	O
pdY	O
=	O
rgdY	O
[	O
nIndex	O
--	O
]	O
;	O
for	O
(	O
j	O
=	O
1	int
;	O
j	O
<	O
n	int
;	O
j	O
++	O
)	O
{	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
n	int
-	O
j	O
;	O
i	O
++	O
)	O
{	O
dTemp1	O
=	O
rgdX	O
[	O
i	O
]	O
-	O
x	*(*(double))
;	O
dTemp2	O
=	O
rgdX	O
[	O
i	O
+	O
j	O
]	O
-	O
x	*(*(double))
;	O
if	O
(	O
(	O
dDenom	O
=	O
dTemp1	O
-	O
dTemp2	O
)	O
==	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"\nError: null denominator in Interpolate_Poly - Exiting\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
dDenom	O
=	O
(	O
pdTerm1	O
[	O
i	O
+	O
1	int
]	O
-	O
pdTerm2	O
[	O
i	O
]	O
)	O
/	O
dDenom	O
;	O
pdTerm2	O
[	O
i	O
]	O
=	O
dTemp2	O
*	O
dDenom	O
;	O
pdTerm1	O
[	O
i	O
]	O
=	O
dTemp1	O
*	O
dDenom	O
;	O
}	O
*	O
pdDY	O
=	O
(	O
2	int
*	O
(	O
nIndex	O
+	O
1	int
)	O
<	O
(	O
n	int
-	O
j	O
)	O
?	O
pdTerm1	O
[	O
nIndex	O
+	O
1	int
]	O
:	O
pdTerm2	O
[	O
nIndex	O
--	O
]	O
)	O
;	O
*	O
pdY	O
=	O
*	O
pdY	O
+	O
*	O
pdDY	O
;	O
}	O
}	O
double	O
Trapezes	O
(	O
double	O
(	O
*	O
Function	O
)	O
(	O
double	O
x	*(*(double))
)	O
,	O
double	O
dFrom	O
,	O
double	O
dTo	O
,	O
int	O
nSteps	O
)	O
{	O
double	O
x	*(*(double))
,	O
dSum	O
,	O
dDelta	O
;	O
static	O
double	O
dStoredArea	O
;	O
int	O
i	O
,	O
j	O
;	O
if	O
(	O
nSteps	O
==	O
1	int
)	O
{	O
return	O
(	O
dStoredArea	O
=	O
0.5	int
*	O
(	O
dTo	O
-	O
dFrom	O
)	O
*	O
(	O
(	O
*	O
Function	O
)	O
(	O
dFrom	O
)	O
+	O
(	O
*	O
Function	O
)	O
(	O
dTo	O
)	O
)	O
)	O
;	O
}	O
else	O
{	O
i	O
=	O
1	int
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nSteps	O
-	O
2	int
;	O
j	O
++	O
)	O
i	O
=	O
i	O
<<	O
1	int
;	O
dDelta	O
=	O
(	O
dTo	O
-	O
dFrom	O
)	O
/	O
(	O
double	O
)	O
i	O
;	O
x	*(*(double))
=	O
dFrom	O
+	O
0.5	int
*	O
dDelta	O
;	O
dSum	O
=	O
0	int
;	O
while	O
(	O
x	*(*(double))
<	O
dTo	O
)	O
{	O
dSum	O
=	O
dSum	O
+	O
(	O
*	O
Function	O
)	O
(	O
x	*(*(double))
)	O
;	O
x	*(*(double))
=	O
x	*(*(double))
+	O
dDelta	O
;	O
}	O
return	O
(	O
dStoredArea	O
=	O
0.5	int
*	O
(	O
dStoredArea	O
+	O
dDelta	O
*	O
dSum	O
)	O
)	O
;	O
}	O
}	O
