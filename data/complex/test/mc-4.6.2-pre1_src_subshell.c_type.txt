static	O
char	O
tcsh_fifo	array(char)
[	O
128	int
]	O
;	O
static	O
void	O
init_raw_mode	()->(void)
(	O
void	O
)	O
;	O
static	O
int	O
feed_subshell	(int,int)->(int)
(	O
int	O
how	int
,	O
int	O
fail_on_error	int
)	O
;	O
static	O
void	O
synchronize	()->(void)
(	O
void	O
)	O
;	O
static	O
int	O
pty_open_master	(*(char))->(int)
(	O
char	O
*	O
pty_name	*(char)
)	O
;	O
static	O
int	O
pty_open_slave	(*(char))->(int)
(	O
const	O
char	O
*	O
pty_name	*(char)
)	O
;	O
static	O
int	O
resize_tty	(int)->(int)
(	O
int	O
fd	int
)	O
;	O
int	O
use_subshell	int
=	O
TRUE	O
;	O
int	O
subshell_pty	int
=	O
0	int
;	O
static	O
int	O
subshell_pty_slave	int
=	O
-	O
1	int
;	O
static	O
const	O
char	O
subshell_switch_key	char
=	O
XCTRL	O
(	O
'o'	O
)	O
&	O
255	int
;	O
enum	O
subshell_state_enum	enum(int,int,int)
subshell_state	enum(int,int,int)
;	O
char	O
*	O
subshell_prompt	*(char)
=	O
NULL	O
;	O
enum	O
{	O
READ	int
=	O
0	int
,	O
WRITE	int
=	O
1	int
}	O
;	O
static	O
char	O
*	O
pty_buffer	*(char)
;	O
static	O
int	O
pty_buffer_size	int
;	O
static	O
int	O
subshell_pipe	array(int)
[	O
2	int
]	O
;	O
static	O
pid_t	int
subshell_pid	int
=	O
1	int
;	O
static	O
char	O
subshell_cwd	array(char)
[	O
MC_MAXPATHLEN	O
+	O
1	int
]	O
;	O
static	O
enum	O
{	O
BASH	int
,	O
TCSH	int
,	O
ZSH	int
}	O
subshell_type	enum(int,int,int)
;	O
static	O
int	O
subshell_ready	int
;	O
static	O
volatile	O
int	O
subshell_alive	int
,	O
subshell_stopped	int
;	O
static	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
shell_mode	struct(int,int,int,int,char,array(char),int,int)
;	O
static	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
raw_mode	struct(int,int,int,int,char,array(char),int,int)
;	O
static	O
int	O
prompt_pos	int
;	O
static	O
ssize_t	long
write_all	(int,*(void),long)->(long)
(	O
int	O
fd	int
,	O
const	O
void	O
*	O
buf	*(char)
,	O
size_t	long
count	int
)	O
{	O
ssize_t	long
ret	long
;	O
ssize_t	long
written	long
=	O
0	int
;	O
while	O
(	O
count	int
>	O
0	int
)	O
{	O
ret	long
=	O
write	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
buf	*(char)
+	O
written	long
,	O
count	int
)	O
;	O
if	O
(	O
ret	long
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
{	O
continue	O
;	O
}	O
else	O
{	O
return	O
written	long
>	O
0	int
?	O
written	long
:	O
ret	long
;	O
}	O
}	O
count	int
-=	O
ret	long
;	O
written	long
+=	O
ret	long
;	O
}	O
return	O
written	long
;	O
}	O
static	O
void	O
init_subshell_child	(*(char))->(void)
(	O
const	O
char	O
*	O
pty_name	*(char)
)	O
{	O
const	O
char	O
*	O
init_file	*(char)
=	O
NULL	O
;	O
pid_t	int
mc_sid	int
;	O
setsid	()->(int)
(	O
)	O
;	O
ioctl	(int,long)->(int)
(	O
subshell_pty_slave	int
,	O
TIOCSCTTY	int
,	O
0	int
)	O
;	O
shell_mode	struct(int,int,int,int,char,array(char),int,int)
.	O
c_lflag	short
|=	O
TOSTOP	int
;	O
if	O
(	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
subshell_pty_slave	int
,	O
TCSANOW	int
,	O
&	O
shell_mode	struct(int,int,int,int,char,array(char),int,int)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Cannot set pty terminal modes: %s\r\n"	*(char)
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
_exit	(int)->(void)
(	O
FORK_FAILURE	int
)	O
;	O
}	O
resize_tty	(int)->(int)
(	O
subshell_pty_slave	int
)	O
;	O
chdir	(*(char))->(int)
(	O
home_dir	*(char)
)	O
;	O
mc_sid	int
=	O
getsid	(int)->(int)
(	O
0	int
)	O
;	O
if	O
(	O
mc_sid	int
!=	O
-	O
1	int
)	O
{	O
char	O
sid_str	array(char)
[	O
BUF_SMALL	int
]	O
;	O
g_snprintf	(*(char),long,*(char))->(int)
(	O
sid_str	array(char)
,	O
sizeof	O
(	O
sid_str	array(char)
)	O
,	O
"MC_SID=%ld"	*(char)
,	O
(	O
long	O
)	O
mc_sid	int
)	O
;	O
putenv	(*(char))->(int)
(	O
g_strdup	(*(char))->(*(char))
(	O
sid_str	array(char)
)	O
)	O
;	O
}	O
switch	O
(	O
subshell_type	enum(int,int,int)
)	O
{	O
case	O
BASH	int
:	O
init_file	*(char)
=	O
".mc/bashrc"	*(char)
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
init_file	*(char)
,	O
R_OK	int
)	O
==	O
-	O
1	int
)	O
init_file	*(char)
=	O
".bashrc"	*(char)
;	O
putenv	(*(char))->(int)
(	O
"HISTCONTROL=ignorespace"	*(char)
)	O
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
".mc/inputrc"	*(char)
,	O
R_OK	int
)	O
==	O
0	int
)	O
putenv	(*(char))->(int)
(	O
"INPUTRC=.mc/inputrc"	*(char)
)	O
;	O
break	O
;	O
case	O
TCSH	int
:	O
case	O
ZSH	int
:	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
__FILE__	O
": unimplemented subshell type %d\r\n"	*(char)
,	O
subshell_type	enum(int,int,int)
)	O
;	O
_exit	(int)->(void)
(	O
FORK_FAILURE	int
)	O
;	O
}	O
dup2	(int,int)->(int)
(	O
subshell_pty_slave	int
,	O
STDIN_FILENO	int
)	O
;	O
dup2	(int,int)->(int)
(	O
subshell_pty_slave	int
,	O
STDOUT_FILENO	int
)	O
;	O
dup2	(int,int)->(int)
(	O
subshell_pty_slave	int
,	O
STDERR_FILENO	int
)	O
;	O
close	*((*(void))->(int))
(	O
subshell_pipe	array(int)
[	O
READ	int
]	O
)	O
;	O
close	*((*(void))->(int))
(	O
subshell_pty_slave	int
)	O
;	O
close	*((*(void))->(int))
(	O
subshell_pty	int
)	O
;	O
switch	O
(	O
subshell_type	enum(int,int,int)
)	O
{	O
case	O
BASH	int
:	O
execl	(*(char),*(char))->(int)
(	O
shell	*(char)
,	O
"bash"	*(char)
,	O
"-rcfile"	*(char)
,	O
init_file	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
case	O
TCSH	int
:	O
execl	(*(char),*(char))->(int)
(	O
shell	*(char)
,	O
"tcsh"	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
case	O
ZSH	int
:	O
execl	(*(char),*(char))->(int)
(	O
shell	*(char)
,	O
"zsh"	*(char)
,	O
"-Z"	*(char)
,	O
"-g"	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
}	O
_exit	(int)->(void)
(	O
FORK_FAILURE	int
)	O
;	O
}	O
static	O
int	O
check_sid	()->(int)
(	O
void	O
)	O
{	O
pid_t	int
my_sid	int
,	O
old_sid	int
;	O
const	O
char	O
*	O
sid_str	array(char)
;	O
int	O
r	*(struct)
;	O
sid_str	array(char)
=	O
getenv	(*(char))->(*(char))
(	O
"MC_SID"	*(char)
)	O
;	O
if	O
(	O
!	O
sid_str	array(char)
)	O
return	O
0	int
;	O
old_sid	int
=	O
(	O
pid_t	int
)	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
sid_str	array(char)
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
old_sid	int
)	O
return	O
0	int
;	O
my_sid	int
=	O
getsid	(int)->(int)
(	O
0	int
)	O
;	O
if	O
(	O
my_sid	int
==	O
-	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
old_sid	int
!=	O
my_sid	int
)	O
return	O
0	int
;	O
r	*(struct)
=	O
query_dialog	(*(char),*(char),int,int)->(int)
(	O
_	O
(	O
"Warning"	*(char)
)	O
,	O
_	O
(	O
"GNU Midnight Commander is already\n"	*(char)
"running on this terminal.\n"	*(char)
"Subshell support will be disabled."	*(char)
)	O
,	O
D_ERROR	int
,	O
2	int
,	O
_	O
(	O
"&OK"	*(char)
)	O
,	O
_	O
(	O
"&Quit"	*(char)
)	O
)	O
;	O
if	O
(	O
r	*(struct)
!=	O
0	int
)	O
{	O
return	O
2	int
;	O
}	O
return	O
1	int
;	O
}	O
void	O
init_subshell	()->(void)
(	O
void	O
)	O
{	O
static	O
char	O
pty_name	*(char)
[	O
BUF_SMALL	int
]	O
;	O
char	O
precmd	array(char)
[	O
BUF_SMALL	int
]	O
;	O
switch	O
(	O
check_sid	()->(int)
(	O
)	O
)	O
{	O
case	O
1	int
:	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
case	O
2	int
:	O
use_subshell	int
=	O
FALSE	O
;	O
midnight_shutdown	int
=	O
1	int
;	O
return	O
;	O
}	O
init_raw_mode	()->(void)
(	O
)	O
;	O
if	O
(	O
subshell_pty	int
==	O
0	int
)	O
{	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
shell	*(char)
,	O
"/zsh"	*(char)
)	O
||	O
getenv	(*(char))->(*(char))
(	O
"ZSH_VERSION"	*(char)
)	O
)	O
subshell_type	enum(int,int,int)
=	O
ZSH	int
;	O
else	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
shell	*(char)
,	O
"/tcsh"	*(char)
)	O
)	O
subshell_type	enum(int,int,int)
=	O
TCSH	int
;	O
else	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
shell	*(char)
,	O
"/bash"	*(char)
)	O
||	O
getenv	(*(char))->(*(char))
(	O
"BASH"	*(char)
)	O
)	O
subshell_type	enum(int,int,int)
=	O
BASH	int
;	O
else	O
{	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
subshell_pty	int
=	O
pty_open_master	(*(char))->(int)
(	O
pty_name	*(char)
)	O
;	O
if	O
(	O
subshell_pty	int
==	O
-	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Cannot open master side of pty: %s\r\n"	*(char)
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
subshell_pty_slave	int
=	O
pty_open_slave	(*(char))->(int)
(	O
pty_name	*(char)
)	O
;	O
if	O
(	O
subshell_pty_slave	int
==	O
-	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Cannot open slave side of pty %s: %s\r\n"	*(char)
,	O
pty_name	*(char)
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
pty_buffer_size	int
=	O
INITIAL_PTY_BUFFER_SIZE	int
;	O
pty_buffer	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
pty_buffer_size	int
)	O
;	O
if	O
(	O
subshell_type	enum(int,int,int)
==	O
TCSH	int
)	O
{	O
g_snprintf	(*(char),long,*(char))->(int)
(	O
tcsh_fifo	array(char)
,	O
sizeof	O
(	O
tcsh_fifo	array(char)
)	O
,	O
"%s/mc.pipe.%d"	*(char)
,	O
mc_tmpdir	()->(*(char))
(	O
)	O
,	O
(	O
int	O
)	O
getpid	()->(int)
(	O
)	O
)	O
;	O
if	O
(	O
mkfifo	(*(char),int)->(int)
(	O
tcsh_fifo	array(char)
,	O
0600	int
)	O
==	O
-	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"mkfifo(%s) failed: %s\r\n"	*(char)
,	O
tcsh_fifo	array(char)
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
subshell_pipe	array(int)
[	O
READ	int
]	O
=	O
open	(*(char),int)->(int)
(	O
tcsh_fifo	array(char)
,	O
O_RDWR	int
)	O
)	O
==	O
-	O
1	int
||	O
(	O
subshell_pipe	array(int)
[	O
WRITE	int
]	O
=	O
open	(*(char),int)->(int)
(	O
tcsh_fifo	array(char)
,	O
O_RDWR	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Cannot open named pipe %s\n"	*(char)
)	O
,	O
tcsh_fifo	array(char)
)	O
;	O
perror	(*(char))->(void)
(	O
__FILE__	O
": open"	*(char)
)	O
;	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
pipe	(array(int))->(int)
(	O
subshell_pipe	array(int)
)	O
)	O
{	O
perror	(*(char))->(void)
(	O
__FILE__	O
": couldn't create pipe"	*(char)
)	O
;	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
}	O
subshell_alive	int
=	O
TRUE	O
;	O
subshell_stopped	int
=	O
FALSE	O
;	O
subshell_pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
subshell_pid	int
==	O
-	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Cannot spawn the subshell process: %s\r\n"	*(char)
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
subshell_pid	int
==	O
0	int
)	O
{	O
init_subshell_child	(*(char))->(void)
(	O
pty_name	*(char)
)	O
;	O
}	O
switch	O
(	O
subshell_type	enum(int,int,int)
)	O
{	O
case	O
BASH	int
:	O
g_snprintf	(*(char),long,*(char))->(int)
(	O
precmd	array(char)
,	O
sizeof	O
(	O
precmd	array(char)
)	O
,	O
" PROMPT_COMMAND='pwd>&%d;kill -STOP $$'\n"	*(char)
,	O
subshell_pipe	array(int)
[	O
WRITE	int
]	O
)	O
;	O
break	O
;	O
case	O
ZSH	int
:	O
g_snprintf	(*(char),long,*(char))->(int)
(	O
precmd	array(char)
,	O
sizeof	O
(	O
precmd	array(char)
)	O
,	O
" precmd(){ pwd>&%d;kill -STOP $$ }\n"	*(char)
,	O
subshell_pipe	array(int)
[	O
WRITE	int
]	O
)	O
;	O
break	O
;	O
case	O
TCSH	int
:	O
g_snprintf	(*(char),long,*(char))->(int)
(	O
precmd	array(char)
,	O
sizeof	O
(	O
precmd	array(char)
)	O
,	O
"set echo_style=both;"	*(char)
"alias precmd 'echo $cwd:q >>%s;kill -STOP $$'\n"	*(char)
,	O
tcsh_fifo	array(char)
)	O
;	O
break	O
;	O
}	O
write_all	(int,*(void),long)->(long)
(	O
subshell_pty	int
,	O
precmd	array(char)
,	O
strlen	(*(char))->(long)
(	O
precmd	array(char)
)	O
)	O
;	O
subshell_state	enum(int,int,int)
=	O
RUNNING_COMMAND	int
;	O
enable_interrupt_key	O
(	O
)	O
;	O
if	O
(	O
!	O
feed_subshell	(int,int)->(int)
(	O
QUIETLY	int
,	O
TRUE	O
)	O
)	O
{	O
use_subshell	int
=	O
FALSE	O
;	O
}	O
disable_interrupt_key	O
(	O
)	O
;	O
if	O
(	O
!	O
subshell_alive	int
)	O
use_subshell	int
=	O
FALSE	O
;	O
}	O
static	O
void	O
init_raw_mode	()->(void)
(	O
)	O
{	O
static	O
int	O
initialized	int
=	O
0	int
;	O
if	O
(	O
initialized	int
==	O
0	int
)	O
{	O
tcgetattr	(int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
STDOUT_FILENO	int
,	O
&	O
raw_mode	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
raw_mode	struct(int,int,int,int,char,array(char),int,int)
.	O
c_lflag	short
&=	O
~	O
ICANON	int
;	O
raw_mode	struct(int,int,int,int,char,array(char),int,int)
.	O
c_lflag	short
&=	O
~	O
ISIG	int
;	O
raw_mode	struct(int,int,int,int,char,array(char),int,int)
.	O
c_lflag	short
&=	O
~	O
ECHO	int
;	O
raw_mode	struct(int,int,int,int,char,array(char),int,int)
.	O
c_iflag	short
&=	O
~	O
IXON	int
;	O
raw_mode	struct(int,int,int,int,char,array(char),int,int)
.	O
c_iflag	short
&=	O
~	O
ICRNL	int
;	O
raw_mode	struct(int,int,int,int,char,array(char),int,int)
.	O
c_oflag	short
&=	O
~	O
OPOST	int
;	O
raw_mode	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VTIME	int
]	O
=	O
0	int
;	O
raw_mode	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VMIN	int
]	O
=	O
1	int
;	O
initialized	int
=	O
1	int
;	O
}	O
}	O
int	O
invoke_subshell	(*(char),int,*(*(char)))->(int)
(	O
const	O
char	O
*	O
command	*(char)
,	O
int	O
how	int
,	O
char	O
*	O
*	O
new_dir	*(char)
)	O
{	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
STDOUT_FILENO	int
,	O
TCSANOW	int
,	O
&	O
raw_mode	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
if	O
(	O
new_dir	*(char)
)	O
do_subshell_chdir	(*(char),int,int)->(void)
(	O
current_panel	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),struct(*(struct(int,*`,struct`,struct`)),int),int,int,array(char),array(char),*(struct(*(void),*(struct`),*(struct`))),*(char),int,int,int,double,int,int,int,int,int,int,int,*((*(void),*(void))->(int)),*(char),int,int,*(char),array(*(char)),*(struct),*(struct),int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,array(char)))
->	O
cwd	short
,	O
TRUE	O
,	O
1	int
)	O
;	O
if	O
(	O
command	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
subshell_state	enum(int,int,int)
==	O
INACTIVE	int
)	O
{	O
subshell_state	enum(int,int,int)
=	O
ACTIVE	int
;	O
write_all	(int,*(void),long)->(long)
(	O
subshell_pty	int
,	O
" \b"	*(char)
,	O
2	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
how	int
==	O
QUIETLY	int
)	O
write_all	(int,*(void),long)->(long)
(	O
subshell_pty	int
,	O
" "	*(char)
,	O
1	int
)	O
;	O
write_all	(int,*(void),long)->(long)
(	O
subshell_pty	int
,	O
command	*(char)
,	O
strlen	(*(char))->(long)
(	O
command	*(char)
)	O
)	O
;	O
write_all	(int,*(void),long)->(long)
(	O
subshell_pty	int
,	O
"\n"	*(char)
,	O
1	int
)	O
;	O
subshell_state	enum(int,int,int)
=	O
RUNNING_COMMAND	int
;	O
subshell_ready	int
=	O
FALSE	O
;	O
}	O
feed_subshell	(int,int)->(int)
(	O
how	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
new_dir	*(char)
&&	O
subshell_alive	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
subshell_cwd	array(char)
,	O
current_panel	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),struct(*(struct(int,*`,struct`,struct`)),int),int,int,array(char),array(char),*(struct(*(void),*(struct`),*(struct`))),*(char),int,int,int,double,int,int,int,int,int,int,int,*((*(void),*(void))->(int)),*(char),int,int,*(char),array(*(char)),*(struct),*(struct),int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,array(char)))
->	O
cwd	short
)	O
)	O
*	O
new_dir	*(char)
=	O
subshell_cwd	array(char)
;	O
while	O
(	O
!	O
subshell_alive	int
&&	O
!	O
quit	int
&&	O
use_subshell	int
)	O
init_subshell	()->(void)
(	O
)	O
;	O
prompt_pos	int
=	O
0	int
;	O
return	O
quit	int
;	O
}	O
int	O
read_subshell_prompt	()->(int)
(	O
void	O
)	O
{	O
static	O
int	O
prompt_size	int
=	O
INITIAL_PROMPT_SIZE	int
;	O
int	O
bytes	*(struct)
=	O
0	int
,	O
i	array(int)
,	O
rc	*(int)
=	O
0	int
;	O
struct	O
timeval	struct(long,long)
timeleft	struct(long,long)
=	O
{	O
0	int
,	O
0	int
}	O
;	O
fd_set	struct(array(long))
tmp	struct(array(long))
;	O
FD_ZERO	O
(	O
&	O
tmp	struct(array(long))
)	O
;	O
FD_SET	O
(	O
subshell_pty	int
,	O
&	O
tmp	struct(array(long))
)	O
;	O
if	O
(	O
subshell_prompt	*(char)
==	O
NULL	O
)	O
{	O
subshell_prompt	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
prompt_size	int
)	O
;	O
*	O
subshell_prompt	*(char)
=	O
'\0'	O
;	O
prompt_pos	int
=	O
0	int
;	O
}	O
while	O
(	O
subshell_alive	int
&&	O
(	O
rc	*(int)
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
subshell_pty	int
+	O
1	int
,	O
&	O
tmp	struct(array(long))
,	O
NULL	O
,	O
NULL	O
,	O
&	O
timeleft	struct(long,long)
)	O
)	O
)	O
{	O
if	O
(	O
rc	*(int)
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"select (FD_SETSIZE, &tmp...): %s\r\n"	*(char)
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
bytes	*(struct)
=	O
read	*((*(void),*(char),long)->(long))
(	O
subshell_pty	int
,	O
pty_buffer	*(char)
,	O
pty_buffer_size	int
)	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
bytes	*(struct)
;	O
++	O
i	array(int)
)	O
if	O
(	O
pty_buffer	*(char)
[	O
i	array(int)
]	O
==	O
'\n'	O
||	O
pty_buffer	*(char)
[	O
i	array(int)
]	O
==	O
'\r'	O
)	O
{	O
prompt_pos	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
pty_buffer	*(char)
[	O
i	array(int)
]	O
)	O
continue	O
;	O
subshell_prompt	*(char)
[	O
prompt_pos	int
++	O
]	O
=	O
pty_buffer	*(char)
[	O
i	array(int)
]	O
;	O
if	O
(	O
prompt_pos	int
==	O
prompt_size	int
)	O
subshell_prompt	*(char)
=	O
g_realloc	(*(void),long)->(*(void))
(	O
subshell_prompt	*(char)
,	O
prompt_size	int
*=	O
2	int
)	O
;	O
}	O
subshell_prompt	*(char)
[	O
prompt_pos	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
rc	*(int)
==	O
0	int
&&	O
bytes	*(struct)
==	O
0	int
)	O
return	O
FALSE	O
;	O
return	O
TRUE	O
;	O
}	O
static	O
int	O
resize_tty	(int)->(int)
(	O
int	O
fd	int
)	O
{	O
struct	O
winsize	struct(short,short,short,short)
tty_size	struct(short,short,short,short)
;	O
tty_size	struct(short,short,short,short)
.	O
ws_row	short
=	O
LINES	O
;	O
tty_size	struct(short,short,short,short)
.	O
ws_col	short
=	O
COLS	O
;	O
tty_size	struct(short,short,short,short)
.	O
ws_xpixel	short
=	O
tty_size	struct(short,short,short,short)
.	O
ws_ypixel	short
=	O
0	int
;	O
return	O
ioctl	(int,long)->(int)
(	O
fd	int
,	O
TIOCSWINSZ	int
,	O
&	O
tty_size	struct(short,short,short,short)
)	O
;	O
}	O
void	O
resize_subshell	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
use_subshell	int
==	O
0	int
)	O
return	O
;	O
resize_tty	(int)->(int)
(	O
subshell_pty	int
)	O
;	O
}	O
int	O
exit_subshell	()->(int)
(	O
void	O
)	O
{	O
int	O
quit	int
=	O
TRUE	O
;	O
if	O
(	O
subshell_state	enum(int,int,int)
!=	O
INACTIVE	int
&&	O
subshell_alive	int
)	O
quit	int
=	O
!	O
query_dialog	(*(char),*(char),int,int)->(int)
(	O
_	O
(	O
"Warning"	*(char)
)	O
,	O
_	O
(	O
" The shell is still active. Quit anyway? "	*(char)
)	O
,	O
0	int
,	O
2	int
,	O
_	O
(	O
"&Yes"	*(char)
)	O
,	O
_	O
(	O
"&No"	*(char)
)	O
)	O
;	O
if	O
(	O
quit	int
)	O
{	O
if	O
(	O
subshell_type	enum(int,int,int)
==	O
TCSH	int
)	O
{	O
if	O
(	O
unlink	(*(char))->(int)
(	O
tcsh_fifo	array(char)
)	O
==	O
-	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Cannot remove named pipe %s: %s\r\n"	*(char)
,	O
tcsh_fifo	array(char)
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
g_free	(*(void))->(void)
(	O
subshell_prompt	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
pty_buffer	*(char)
)	O
;	O
subshell_prompt	*(char)
=	O
NULL	O
;	O
pty_buffer	*(char)
=	O
NULL	O
;	O
}	O
return	O
quit	int
;	O
}	O
static	O
char	O
*	O
subshell_name_quote	(*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
char	O
*	O
ret	long
,	O
*	O
d	double
;	O
const	O
char	O
quote_cmd_start	array(char)
[	O
]	O
=	O
"\"`printf \"%b\" '"	*(char)
;	O
const	O
char	O
quote_cmd_end	array(char)
[	O
]	O
=	O
"'`\""	*(char)
;	O
d	double
=	O
ret	long
=	O
g_malloc	(long)->(*(void))
(	O
1	int
+	O
(	O
5	int
*	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
)	O
+	O
(	O
sizeof	O
(	O
quote_cmd_start	array(char)
)	O
-	O
1	int
)	O
+	O
(	O
sizeof	O
(	O
quote_cmd_end	array(char)
)	O
-	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
d	double
)	O
return	O
NULL	O
;	O
if	O
(	O
*	O
s	*(char)
==	O
'-'	O
)	O
{	O
*	O
d	double
++	O
=	O
'.'	O
;	O
*	O
d	double
++	O
=	O
'/'	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
d	double
,	O
quote_cmd_start	array(char)
)	O
;	O
d	double
+=	O
sizeof	O
(	O
quote_cmd_start	array(char)
)	O
-	O
1	int
;	O
for	O
(	O
;	O
*	O
s	*(char)
;	O
s	*(char)
++	O
)	O
{	O
if	O
(	O
isalnum	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	*(char)
)	O
)	O
{	O
*	O
d	double
++	O
=	O
(	O
unsigned	O
char	O
)	O
*	O
s	*(char)
;	O
}	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
d	double
,	O
"\\0%03o"	*(char)
,	O
(	O
unsigned	O
char	O
)	O
*	O
s	*(char)
)	O
;	O
d	double
+=	O
5	int
;	O
}	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
d	double
,	O
quote_cmd_end	array(char)
)	O
;	O
return	O
ret	long
;	O
}	O
void	O
do_subshell_chdir	(*(char),int,int)->(void)
(	O
const	O
char	O
*	O
directory	enum(int,int,int,int,int,int,int,int,int)
,	O
int	O
do_update	int
,	O
int	O
reset_prompt	int
)	O
{	O
if	O
(	O
!	O
(	O
subshell_state	enum(int,int,int)
==	O
INACTIVE	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
subshell_cwd	array(char)
,	O
current_panel	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),struct(*(struct(int,*`,struct`,struct`)),int),int,int,array(char),array(char),*(struct(*(void),*(struct`),*(struct`))),*(char),int,int,int,double,int,int,int,int,int,int,int,*((*(void),*(void))->(int)),*(char),int,int,*(char),array(*(char)),*(struct),*(struct),int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,array(char)))
->	O
cwd	short
)	O
)	O
)	O
{	O
if	O
(	O
do_update	int
)	O
do_update_prompt	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
write_all	(int,*(void),long)->(long)
(	O
subshell_pty	int
,	O
" cd "	*(char)
,	O
4	int
)	O
;	O
if	O
(	O
*	O
directory	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
char	O
*	O
temp	*(char)
=	O
subshell_name_quote	(*(char))->(*(char))
(	O
directory	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
if	O
(	O
temp	*(char)
)	O
{	O
write_all	(int,*(void),long)->(long)
(	O
subshell_pty	int
,	O
temp	*(char)
,	O
strlen	(*(char))->(long)
(	O
temp	*(char)
)	O
)	O
;	O
g_free	(*(void))->(void)
(	O
temp	*(char)
)	O
;	O
}	O
else	O
{	O
write_all	(int,*(void),long)->(long)
(	O
subshell_pty	int
,	O
"."	*(char)
,	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
write_all	(int,*(void),long)->(long)
(	O
subshell_pty	int
,	O
"/"	*(char)
,	O
1	int
)	O
;	O
}	O
write_all	(int,*(void),long)->(long)
(	O
subshell_pty	int
,	O
"\n"	*(char)
,	O
1	int
)	O
;	O
subshell_state	enum(int,int,int)
=	O
RUNNING_COMMAND	int
;	O
feed_subshell	(int,int)->(int)
(	O
QUIETLY	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
subshell_alive	int
)	O
{	O
int	O
bPathNotEq	int
=	O
strcmp	(*(char),*(char))->(int)
(	O
subshell_cwd	array(char)
,	O
current_panel	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),struct(*(struct(int,*`,struct`,struct`)),int),int,int,array(char),array(char),*(struct(*(void),*(struct`),*(struct`))),*(char),int,int,int,double,int,int,int,int,int,int,int,*((*(void),*(void))->(int)),*(char),int,int,*(char),array(*(char)),*(struct),*(struct),int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,array(char)))
->	O
cwd	short
)	O
;	O
if	O
(	O
bPathNotEq	int
&&	O
subshell_type	enum(int,int,int)
==	O
TCSH	int
)	O
{	O
char	O
rp_subshell_cwd	array(char)
[	O
PATH_MAX	int
]	O
;	O
char	O
rp_current_panel_cwd	array(char)
[	O
PATH_MAX	int
]	O
;	O
char	O
*	O
p_subshell_cwd	*(char)
=	O
mc_realpath	(*(char),array(char))->(*(char))
(	O
subshell_cwd	array(char)
,	O
rp_subshell_cwd	array(char)
)	O
;	O
char	O
*	O
p_current_panel_cwd	*(char)
=	O
mc_realpath	(*(char),array(char))->(*(char))
(	O
current_panel	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),struct(*(struct(int,*`,struct`,struct`)),int),int,int,array(char),array(char),*(struct(*(void),*(struct`),*(struct`))),*(char),int,int,int,double,int,int,int,int,int,int,int,*((*(void),*(void))->(int)),*(char),int,int,*(char),array(*(char)),*(struct),*(struct),int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,array(char)))
->	O
cwd	short
,	O
rp_current_panel_cwd	array(char)
)	O
;	O
if	O
(	O
p_subshell_cwd	*(char)
==	O
NULL	O
)	O
p_subshell_cwd	*(char)
=	O
subshell_cwd	array(char)
;	O
if	O
(	O
p_current_panel_cwd	*(char)
==	O
NULL	O
)	O
p_current_panel_cwd	*(char)
=	O
current_panel	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),struct(*(struct(int,*`,struct`,struct`)),int),int,int,array(char),array(char),*(struct(*(void),*(struct`),*(struct`))),*(char),int,int,int,double,int,int,int,int,int,int,int,*((*(void),*(void))->(int)),*(char),int,int,*(char),array(*(char)),*(struct),*(struct),int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,array(char)))
->	O
cwd	short
;	O
bPathNotEq	int
=	O
strcmp	(*(char),*(char))->(int)
(	O
p_subshell_cwd	*(char)
,	O
p_current_panel_cwd	*(char)
)	O
;	O
}	O
if	O
(	O
bPathNotEq	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
current_panel	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),struct(*(struct(int,*`,struct`,struct`)),int),int,int,array(char),array(char),*(struct(*(void),*(struct`),*(struct`))),*(char),int,int,int,double,int,int,int,int,int,int,int,*((*(void),*(void))->(int)),*(char),int,int,*(char),array(*(char)),*(struct),*(struct),int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,array(char)))
->	O
cwd	short
,	O
"."	*(char)
)	O
)	O
{	O
char	O
*	O
cwd	short
=	O
strip_password	(*(char),int)->(*(char))
(	O
g_strdup	(*(char))->(*(char))
(	O
current_panel	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),struct(*(struct(int,*`,struct`,struct`)),int),int,int,array(char),array(char),*(struct(*(void),*(struct`),*(struct`))),*(char),int,int,int,double,int,int,int,int,int,int,int,*((*(void),*(void))->(int)),*(char),int,int,*(char),array(*(char)),*(struct),*(struct),int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,array(char)))
->	O
cwd	short
)	O
,	O
1	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Warning: Cannot change to %s.\n"	*(char)
)	O
,	O
cwd	short
)	O
;	O
g_free	(*(void))->(void)
(	O
cwd	short
)	O
;	O
}	O
}	O
if	O
(	O
reset_prompt	int
)	O
prompt_pos	int
=	O
0	int
;	O
update_prompt	int
=	O
FALSE	O
;	O
}	O
void	O
subshell_get_console_attributes	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
tcgetattr	(int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
STDOUT_FILENO	int
,	O
&	O
shell_mode	struct(int,int,int,int,char,array(char),int,int)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Cannot get terminal settings: %s\r\n"	*(char)
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
}	O
void	O
sigchld_handler	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
int	O
status	int
;	O
pid_t	int
pid	int
;	O
(	O
void	O
)	O
sig	int
;	O
pid	int
=	O
waitpid	(int,*(int),int)->(int)
(	O
subshell_pid	int
,	O
&	O
status	int
,	O
WUNTRACED	int
|	O
WNOHANG	int
)	O
;	O
if	O
(	O
pid	int
==	O
subshell_pid	int
)	O
{	O
if	O
(	O
WIFSTOPPED	O
(	O
status	int
)	O
)	O
{	O
if	O
(	O
WSTOPSIG	O
(	O
status	int
)	O
==	O
SIGSTOP	int
)	O
{	O
subshell_stopped	int
=	O
TRUE	O
;	O
}	O
else	O
{	O
kill	(int,int)->(int)
(	O
subshell_pid	int
,	O
SIGCONT	int
)	O
;	O
}	O
}	O
else	O
{	O
subshell_alive	int
=	O
FALSE	O
;	O
delete_select_channel	(int)->(void)
(	O
subshell_pty	int
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
&&	O
WEXITSTATUS	O
(	O
status	int
)	O
!=	O
FORK_FAILURE	int
)	O
quit	int
|=	O
SUBSHELL_EXIT	int
;	O
}	O
}	O
pid	int
=	O
waitpid	(int,*(int),int)->(int)
(	O
cons_saver_pid	int
,	O
&	O
status	int
,	O
WUNTRACED	int
|	O
WNOHANG	int
)	O
;	O
if	O
(	O
pid	int
==	O
cons_saver_pid	int
)	O
{	O
if	O
(	O
WIFSTOPPED	O
(	O
status	int
)	O
)	O
kill	(int,int)->(int)
(	O
pid	int
,	O
SIGCONT	int
)	O
;	O
else	O
{	O
handle_console	(char)->(void)
(	O
CONSOLE_DONE	int
)	O
;	O
console_flag	char
=	O
0	int
;	O
}	O
}	O
}	O
static	O
int	O
feed_subshell	(int,int)->(int)
(	O
int	O
how	int
,	O
int	O
fail_on_error	int
)	O
{	O
fd_set	struct(array(long))
read_set	struct(array(long))
;	O
int	O
maxfdp	int
;	O
int	O
bytes	*(struct)
;	O
int	O
i	array(int)
;	O
struct	O
timeval	struct(long,long)
wtime	struct(long,long)
;	O
struct	O
timeval	struct(long,long)
*	O
wptr	*(struct(long,long))
;	O
wtime	struct(long,long)
.	O
tv_sec	long
=	O
10	int
;	O
wtime	struct(long,long)
.	O
tv_usec	long
=	O
0	int
;	O
wptr	*(struct(long,long))
=	O
fail_on_error	int
?	O
&	O
wtime	struct(long,long)
:	O
NULL	O
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
!	O
subshell_alive	int
)	O
return	O
FALSE	O
;	O
FD_ZERO	O
(	O
&	O
read_set	struct(array(long))
)	O
;	O
FD_SET	O
(	O
subshell_pty	int
,	O
&	O
read_set	struct(array(long))
)	O
;	O
FD_SET	O
(	O
subshell_pipe	array(int)
[	O
READ	int
]	O
,	O
&	O
read_set	struct(array(long))
)	O
;	O
maxfdp	int
=	O
max	long
(	O
subshell_pty	int
,	O
subshell_pipe	array(int)
[	O
READ	int
]	O
)	O
;	O
if	O
(	O
how	int
==	O
VISIBLY	int
)	O
{	O
FD_SET	O
(	O
STDIN_FILENO	int
,	O
&	O
read_set	struct(array(long))
)	O
;	O
maxfdp	int
=	O
max	long
(	O
maxfdp	int
,	O
STDIN_FILENO	int
)	O
;	O
}	O
if	O
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
maxfdp	int
+	O
1	int
,	O
&	O
read_set	struct(array(long))
,	O
NULL	O
,	O
NULL	O
,	O
wptr	*(struct(long,long))
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
STDOUT_FILENO	int
,	O
TCSANOW	int
,	O
&	O
shell_mode	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"select (FD_SETSIZE, &read_set...): %s\r\n"	*(char)
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
subshell_pty	int
,	O
&	O
read_set	struct(array(long))
)	O
)	O
{	O
bytes	*(struct)
=	O
read	*((*(void),*(char),long)->(long))
(	O
subshell_pty	int
,	O
pty_buffer	*(char)
,	O
pty_buffer_size	int
)	O
;	O
if	O
(	O
bytes	*(struct)
==	O
-	O
1	int
&&	O
errno	O
==	O
EIO	int
&&	O
!	O
subshell_alive	int
)	O
return	O
FALSE	O
;	O
if	O
(	O
bytes	*(struct)
<=	O
0	int
)	O
{	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
STDOUT_FILENO	int
,	O
TCSANOW	int
,	O
&	O
shell_mode	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"read (subshell_pty...): %s\r\n"	*(char)
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
how	int
==	O
VISIBLY	int
)	O
write_all	(int,*(void),long)->(long)
(	O
STDOUT_FILENO	int
,	O
pty_buffer	*(char)
,	O
bytes	*(struct)
)	O
;	O
}	O
else	O
if	O
(	O
FD_ISSET	O
(	O
subshell_pipe	array(int)
[	O
READ	int
]	O
,	O
&	O
read_set	struct(array(long))
)	O
)	O
{	O
bytes	*(struct)
=	O
read	*((*(void),*(char),long)->(long))
(	O
subshell_pipe	array(int)
[	O
READ	int
]	O
,	O
subshell_cwd	array(char)
,	O
MC_MAXPATHLEN	O
+	O
1	int
)	O
;	O
if	O
(	O
bytes	*(struct)
<=	O
0	int
)	O
{	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
STDOUT_FILENO	int
,	O
TCSANOW	int
,	O
&	O
shell_mode	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"read (subshell_pipe[READ]...): %s\r\n"	*(char)
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
subshell_cwd	array(char)
[	O
bytes	*(struct)
-	O
1	int
]	O
=	O
0	int
;	O
synchronize	()->(void)
(	O
)	O
;	O
subshell_ready	int
=	O
TRUE	O
;	O
if	O
(	O
subshell_state	enum(int,int,int)
==	O
RUNNING_COMMAND	int
)	O
{	O
subshell_state	enum(int,int,int)
=	O
INACTIVE	int
;	O
return	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
FD_ISSET	O
(	O
STDIN_FILENO	int
,	O
&	O
read_set	struct(array(long))
)	O
)	O
{	O
bytes	*(struct)
=	O
read	*((*(void),*(char),long)->(long))
(	O
STDIN_FILENO	int
,	O
pty_buffer	*(char)
,	O
pty_buffer_size	int
)	O
;	O
if	O
(	O
bytes	*(struct)
<=	O
0	int
)	O
{	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
STDOUT_FILENO	int
,	O
TCSANOW	int
,	O
&	O
shell_mode	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"read (STDIN_FILENO, pty_buffer...): %s\r\n"	*(char)
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
bytes	*(struct)
;	O
++	O
i	array(int)
)	O
if	O
(	O
pty_buffer	*(char)
[	O
i	array(int)
]	O
==	O
subshell_switch_key	char
)	O
{	O
write_all	(int,*(void),long)->(long)
(	O
subshell_pty	int
,	O
pty_buffer	*(char)
,	O
i	array(int)
)	O
;	O
if	O
(	O
subshell_ready	int
)	O
subshell_state	enum(int,int,int)
=	O
INACTIVE	int
;	O
return	O
TRUE	O
;	O
}	O
write_all	(int,*(void),long)->(long)
(	O
subshell_pty	int
,	O
pty_buffer	*(char)
,	O
bytes	*(struct)
)	O
;	O
subshell_ready	int
=	O
FALSE	O
;	O
}	O
else	O
{	O
return	O
FALSE	O
;	O
}	O
}	O
}	O
static	O
void	O
synchronize	()->(void)
(	O
void	O
)	O
{	O
sigset_t	struct(array(long))
sigchld_mask	struct(array(long))
,	O
old_mask	struct(array(long))
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
sigchld_mask	struct(array(long))
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
sigchld_mask	struct(array(long))
,	O
SIGCHLD	int
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_BLOCK	int
,	O
&	O
sigchld_mask	struct(array(long))
,	O
&	O
old_mask	struct(array(long))
)	O
;	O
sigdelset	(*(struct(array(long))),int)->(int)
(	O
&	O
old_mask	struct(array(long))
,	O
SIGCHLD	int
)	O
;	O
while	O
(	O
subshell_alive	int
&&	O
!	O
subshell_stopped	int
)	O
sigsuspend	(*(struct(array(long))))->(int)
(	O
&	O
old_mask	struct(array(long))
)	O
;	O
if	O
(	O
subshell_state	enum(int,int,int)
!=	O
ACTIVE	int
)	O
{	O
tcflush	(int,int)->(int)
(	O
subshell_pty_slave	int
,	O
TCIFLUSH	int
)	O
;	O
}	O
subshell_stopped	int
=	O
FALSE	O
;	O
kill	(int,int)->(int)
(	O
subshell_pid	int
,	O
SIGCONT	int
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_SETMASK	int
,	O
&	O
old_mask	struct(array(long))
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
pty_open_master	(*(char))->(int)
(	O
char	O
*	O
pty_name	*(char)
)	O
{	O
char	O
*	O
slave_name	*(char)
;	O
int	O
pty_master	int
;	O
pty_master	int
=	O
posix_openpt	(int)->(int)
(	O
O_RDWR	int
)	O
;	O
if	O
(	O
pty_master	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
grantpt	(int)->(int)
(	O
pty_master	int
)	O
==	O
-	O
1	int
||	O
unlockpt	(int)->(int)
(	O
pty_master	int
)	O
==	O
-	O
1	int
||	O
!	O
(	O
slave_name	*(char)
=	O
ptsname	(int)->(*(char))
(	O
pty_master	int
)	O
)	O
)	O
{	O
close	*((*(void))->(int))
(	O
pty_master	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
pty_name	*(char)
,	O
slave_name	*(char)
)	O
;	O
return	O
pty_master	int
;	O
}	O
static	O
int	O
pty_open_slave	(*(char))->(int)
(	O
const	O
char	O
*	O
pty_name	*(char)
)	O
{	O
int	O
pty_slave	int
=	O
open	(*(char),int)->(int)
(	O
pty_name	*(char)
,	O
O_RDWR	int
)	O
;	O
if	O
(	O
pty_slave	int
==	O
-	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"open (%s, O_RDWR): %s\r\n"	*(char)
,	O
pty_name	*(char)
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
pty_slave	int
;	O
}	O
