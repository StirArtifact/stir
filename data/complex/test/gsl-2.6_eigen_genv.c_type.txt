static	O
int	O
genv_get_right_eigenvectors	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,*`,long,long,long,double,int,double,double,double,double,*`,*`,int,int,*`,*`)))))->(int)
(	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_eigen_genv_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
static	O
void	O
genv_normalize_eigenvectors	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
alpha	long double
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
gsl_eigen_genv_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))
*	O
gsl_eigen_genv_alloc	(long)->(*(struct(long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,*`,long,long,long,double,int,double,double,double,double,*`,*`,int,int,*`,*`)))))
(	O
const	O
size_t	long
n	long
)	O
{	O
gsl_eigen_genv_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
;	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"matrix dimension must be positive integer"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
=	O
(	O
gsl_eigen_genv_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))
*	O
)	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
gsl_eigen_genv_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))
)	O
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for workspace"	*(char)
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
=	O
n	long
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
NULL	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
NULL	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
gen_workspace_p	*(struct(long,*(struct(long,long,*(double),*(struct`),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),int,int,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int))))
=	O
gsl_eigen_gen_alloc	(long)->(*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))
(	O
n	long
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
gen_workspace_p	*(struct(long,*(struct(long,long,*(double),*(struct`),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),int,int,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int))))
==	O
0	int
)	O
{	O
gsl_eigen_genv_free	(*(struct(long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,*`,long,long,long,double,int,double,double,double,double,*`,*`,int,int,*`,*`)))))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for gen workspace"	*(char)
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
gsl_eigen_gen_params	(int,int,int,*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
1	int
,	O
1	int
,	O
1	int
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
gen_workspace_p	*(struct(long,*(struct(long,long,*(double),*(struct`),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),int,int,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int))))
)	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work1	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_alloc	(long)->(*(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
n	long
)	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work2	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_alloc	(long)->(*(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
n	long
)	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_alloc	(long)->(*(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
n	long
)	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_alloc	(long)->(*(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
n	long
)	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work5	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_alloc	(long)->(*(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
n	long
)	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work6	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_alloc	(long)->(*(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
n	long
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work1	*(struct(long,long,*(double),*(struct(long,*(double))),int))
==	O
0	int
||	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work2	*(struct(long,long,*(double),*(struct(long,*(double))),int))
==	O
0	int
||	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
==	O
0	int
||	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
==	O
0	int
||	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work5	*(struct(long,long,*(double),*(struct(long,*(double))),int))
==	O
0	int
||	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work6	*(struct(long,long,*(double),*(struct(long,*(double))),int))
==	O
0	int
)	O
{	O
gsl_eigen_genv_free	(*(struct(long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,*`,long,long,long,double,int,double,double,double,double,*`,*`,int,int,*`,*`)))))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for additional workspace"	*(char)
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
return	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
}	O
void	O
gsl_eigen_genv_free	(*(struct(long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,*`,long,long,long,double,int,double,double,double,double,*`,*`,int,int,*`,*`)))))->(void)
(	O
gsl_eigen_genv_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
RETURN_IF_NULL	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
gen_workspace_p	*(struct(long,*(struct(long,long,*(double),*(struct`),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),int,int,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int))))
)	O
gsl_eigen_gen_free	(*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
gen_workspace_p	*(struct(long,*(struct(long,long,*(double),*(struct`),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),int,int,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int))))
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work1	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
gsl_vector_free	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work1	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work2	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
gsl_vector_free	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work2	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
gsl_vector_free	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
gsl_vector_free	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work5	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
gsl_vector_free	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work5	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work6	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
gsl_vector_free	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work6	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
free	(*(void))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
}	O
int	O
gsl_eigen_genv	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,*`,long,long,long,double,int,double,double,double,double,*`,*`,int,int,*`,*`)))))->(int)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
alpha	long double
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
beta	long double
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_eigen_genv_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size1	long
;	O
if	O
(	O
N	int
!=	O
A	*(float)
->	O
size2	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square to compute eigenvalues"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
N	int
!=	O
B	*(float)
->	O
size1	long
)	O
||	O
(	O
N	int
!=	O
B	*(float)
->	O
size2	long
)	O
)	O
{	O
GSL_ERROR	O
(	O
"B matrix dimensions must match A"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
alpha	long double
->	O
size	long
!=	O
N	int
||	O
beta	long double
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"eigenvalue vector must match matrix size"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix size does not match workspace"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size1	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"eigenvector matrix has wrong size"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
int	O
s	*(float)
;	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
;	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
size1	long
=	O
N	int
;	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
size2	long
=	O
N	int
;	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
tda	long
=	O
2	int
*	O
N	int
;	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
data	*(long double)
=	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
data	*(long double)
;	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
block	*(struct(long,*(long double)))
=	O
0	int
;	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
owner	int
=	O
0	int
;	O
s	*(float)
=	O
gsl_eigen_gen_QZ	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
A	*(float)
,	O
B	*(float)
,	O
alpha	long double
,	O
beta	long double
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
&	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
gen_workspace_p	*(struct(long,*(struct(long,long,*(double),*(struct`),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),int,int,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int))))
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
gsl_matrix_memcpy	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
&	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
}	O
if	O
(	O
s	*(float)
==	O
GSL_SUCCESS	int
)	O
{	O
s	*(float)
=	O
genv_get_right_eigenvectors	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,*`,long,long,long,double,int,double,double,double,double,*`,*`,int,int,*`,*`)))))->(int)
(	O
A	*(float)
,	O
B	*(float)
,	O
&	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
if	O
(	O
s	*(float)
==	O
GSL_SUCCESS	int
)	O
genv_normalize_eigenvectors	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
alpha	long double
,	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
}	O
return	O
s	*(float)
;	O
}	O
}	O
int	O
gsl_eigen_genv_QZ	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,*`,long,long,long,double,int,double,double,double,double,*`,*`,int,int,*`,*`)))))->(int)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
alpha	long double
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
beta	long double
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_eigen_genv_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
if	O
(	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
&&	O
(	O
A	*(float)
->	O
size1	long
!=	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size1	long
||	O
A	*(float)
->	O
size1	long
!=	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size2	long
)	O
)	O
{	O
GSL_ERROR	O
(	O
"Q matrix has wrong dimensions"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
&&	O
(	O
A	*(float)
->	O
size1	long
!=	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size1	long
||	O
A	*(float)
->	O
size1	long
!=	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size2	long
)	O
)	O
{	O
GSL_ERROR	O
(	O
"Z matrix has wrong dimensions"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
int	O
s	*(float)
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
;	O
s	*(float)
=	O
gsl_eigen_genv	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,*`,long,long,long,double,int,double,double,double,double,*`,*`,int,int,*`,*`)))))->(int)
(	O
A	*(float)
,	O
B	*(float)
,	O
alpha	long double
,	O
beta	long double
,	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
NULL	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
NULL	O
;	O
return	O
s	*(float)
;	O
}	O
}	O
static	O
int	O
genv_get_right_eigenvectors	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,*`,long,long,long,double,int,double,double,double,double,*`,*`,int,int,*`,*`)))))->(int)
(	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_eigen_genv_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
const	O
size_t	long
N	int
=	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
;	O
const	O
double	O
small	double
=	O
GSL_DBL_MIN	int
*	O
N	int
/	O
GSL_DBL_EPSILON	int
;	O
const	O
double	O
big	double
=	O
1.0	int
/	O
small	double
;	O
const	O
double	O
bignum	double
=	O
1.0	int
/	O
(	O
GSL_DBL_MIN	int
*	O
N	int
)	O
;	O
size_t	long
i	long
,	O
j	long
,	O
k	long
,	O
end	long
;	O
int	O
is	int
;	O
double	O
anorm	double
,	O
bnorm	double
;	O
double	O
temp	double
,	O
temp2	double
,	O
temp2r	double
,	O
temp2i	double
;	O
double	O
ascale	double
,	O
bscale	double
;	O
double	O
salfar	double
,	O
sbeta	double
;	O
double	O
acoef	double
,	O
bcoefr	double
,	O
bcoefi	double
,	O
acoefa	double
,	O
bcoefa	double
;	O
double	O
creala	double
,	O
cimaga	double
,	O
crealb	double
,	O
cimagb	double
,	O
cre2a	double
,	O
cim2a	double
,	O
cre2b	double
,	O
cim2b	double
;	O
double	O
dmin	double
,	O
xmax	double
;	O
double	O
scale	double
;	O
size_t	long
nw	long
,	O
na	long
;	O
int	O
lsa	int
,	O
lsb	int
;	O
int	O
complex_pair	int
;	O
gsl_complex	struct(array(double))
z_zero	struct(array(double))
,	O
z_one	struct(array(double))
;	O
double	O
bdiag	array(double)
[	O
2	int
]	O
=	O
{	O
0.0	int
,	O
0.0	int
}	O
;	O
double	O
sum	array(double)
[	O
4	int
]	O
;	O
int	O
il2by2	int
;	O
size_t	long
jr	long
,	O
jc	long
,	O
ja	long
;	O
double	O
xscale	double
;	O
gsl_vector_complex_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
ecol	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
re	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
im	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
re2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
im2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z_zero	struct(array(double))
,	O
0.0	int
,	O
0.0	int
)	O
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z_one	struct(array(double))
,	O
1.0	int
,	O
0.0	int
)	O
;	O
anorm	double
=	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
)	O
)	O
;	O
if	O
(	O
N	int
>	O
1	int
)	O
anorm	double
+=	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
1	int
,	O
0	int
)	O
)	O
;	O
bnorm	double
=	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
)	O
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work1	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0.0	int
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work2	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0.0	int
)	O
;	O
for	O
(	O
j	long
=	O
1	int
;	O
j	long
<	O
N	int
;	O
++	O
j	long
)	O
{	O
temp	double
=	O
temp2	double
=	O
0.0	int
;	O
if	O
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
j	long
-	O
1	int
)	O
==	O
0.0	int
)	O
end	long
=	O
j	long
;	O
else	O
end	long
=	O
j	long
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
end	long
;	O
++	O
i	long
)	O
{	O
temp	double
+=	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
j	long
)	O
)	O
;	O
temp2	double
+=	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
j	long
)	O
)	O
;	O
}	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work1	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
temp	double
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work2	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
temp2	double
)	O
;	O
for	O
(	O
i	long
=	O
end	long
;	O
i	long
<	O
GSL_MIN	O
(	O
j	long
+	O
2	int
,	O
N	int
)	O
;	O
++	O
i	long
)	O
{	O
temp	double
+=	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
j	long
)	O
)	O
;	O
temp2	double
+=	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
j	long
)	O
)	O
;	O
}	O
anorm	double
=	O
GSL_MAX	O
(	O
anorm	double
,	O
temp	double
)	O
;	O
bnorm	double
=	O
GSL_MAX	O
(	O
bnorm	double
,	O
temp2	double
)	O
;	O
}	O
ascale	double
=	O
1.0	int
/	O
GSL_MAX	O
(	O
anorm	double
,	O
GSL_DBL_MIN	int
)	O
;	O
bscale	double
=	O
1.0	int
/	O
GSL_MAX	O
(	O
bnorm	double
,	O
GSL_DBL_MIN	int
)	O
;	O
complex_pair	int
=	O
0	int
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
N	int
;	O
++	O
k	long
)	O
{	O
size_t	long
je	long
=	O
N	int
-	O
1	int
-	O
k	long
;	O
if	O
(	O
complex_pair	int
)	O
{	O
complex_pair	int
=	O
0	int
;	O
continue	O
;	O
}	O
nw	long
=	O
1	int
;	O
if	O
(	O
je	long
>	O
0	int
)	O
{	O
if	O
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
je	long
-	O
1	int
)	O
!=	O
0.0	int
)	O
{	O
complex_pair	int
=	O
1	int
;	O
nw	long
=	O
2	int
;	O
}	O
}	O
if	O
(	O
!	O
complex_pair	int
)	O
{	O
if	O
(	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
je	long
)	O
)	O
<=	O
GSL_DBL_MIN	int
&&	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
je	long
)	O
)	O
<=	O
GSL_DBL_MIN	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
N	int
;	O
++	O
i	long
)	O
gsl_matrix_complex_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,struct(array(double)))->(void)
(	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
je	long
,	O
z_zero	struct(array(double))
)	O
;	O
gsl_matrix_complex_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,struct(array(double)))->(void)
(	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
je	long
,	O
z_one	struct(array(double))
)	O
;	O
continue	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
N	int
;	O
++	O
i	long
)	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
N	int
;	O
++	O
i	long
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
0.0	int
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
0.0	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
complex_pair	int
)	O
{	O
temp	double
=	O
1.0	int
/	O
GSL_MAX	O
(	O
GSL_DBL_MIN	int
,	O
GSL_MAX	O
(	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
je	long
)	O
)	O
*	O
ascale	double
,	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
je	long
)	O
)	O
*	O
bscale	double
)	O
)	O
;	O
salfar	double
=	O
(	O
temp	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
je	long
)	O
)	O
*	O
ascale	double
;	O
sbeta	double
=	O
(	O
temp	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
je	long
)	O
)	O
*	O
bscale	double
;	O
acoef	double
=	O
sbeta	double
*	O
ascale	double
;	O
bcoefr	double
=	O
salfar	double
*	O
bscale	double
;	O
bcoefi	double
=	O
0.0	int
;	O
scale	double
=	O
1.0	int
;	O
lsa	int
=	O
fabs	(double)->(double)
(	O
sbeta	double
)	O
>=	O
GSL_DBL_MIN	int
&&	O
fabs	(double)->(double)
(	O
acoef	double
)	O
<	O
small	double
;	O
lsb	int
=	O
fabs	(double)->(double)
(	O
salfar	double
)	O
>=	O
GSL_DBL_MIN	int
&&	O
fabs	(double)->(double)
(	O
bcoefr	double
)	O
<	O
small	double
;	O
if	O
(	O
lsa	int
)	O
scale	double
=	O
(	O
small	double
/	O
fabs	(double)->(double)
(	O
sbeta	double
)	O
)	O
*	O
GSL_MIN	O
(	O
anorm	double
,	O
big	double
)	O
;	O
if	O
(	O
lsb	int
)	O
scale	double
=	O
GSL_MAX	O
(	O
scale	double
,	O
(	O
small	double
/	O
fabs	(double)->(double)
(	O
salfar	double
)	O
)	O
*	O
GSL_MIN	O
(	O
bnorm	double
,	O
big	double
)	O
)	O
;	O
if	O
(	O
lsa	int
||	O
lsb	int
)	O
{	O
scale	double
=	O
GSL_MIN	O
(	O
scale	double
,	O
1.0	int
/	O
(	O
GSL_DBL_MIN	int
*	O
GSL_MAX	O
(	O
1.0	int
,	O
GSL_MAX	O
(	O
fabs	(double)->(double)
(	O
acoef	double
)	O
,	O
fabs	(double)->(double)
(	O
bcoefr	double
)	O
)	O
)	O
)	O
)	O
;	O
if	O
(	O
lsa	int
)	O
acoef	double
=	O
ascale	double
*	O
(	O
scale	double
*	O
sbeta	double
)	O
;	O
else	O
acoef	double
*=	O
scale	double
;	O
if	O
(	O
lsb	int
)	O
bcoefr	double
=	O
bscale	double
*	O
(	O
scale	double
*	O
salfar	double
)	O
;	O
else	O
bcoefr	double
*=	O
scale	double
;	O
}	O
acoefa	double
=	O
fabs	(double)->(double)
(	O
acoef	double
)	O
;	O
bcoefa	double
=	O
fabs	(double)->(double)
(	O
bcoefr	double
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
1.0	int
)	O
;	O
xmax	double
=	O
1.0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
je	long
;	O
++	O
i	long
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
bcoefr	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
je	long
)	O
-	O
acoef	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
je	long
)	O
)	O
;	O
}	O
}	O
else	O
{	O
gsl_matrix_const_view	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
vs	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_const_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
,	O
je	long
-	O
1	int
,	O
2	int
,	O
2	int
)	O
;	O
gsl_matrix_const_view	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
vt	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_const_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
,	O
je	long
-	O
1	int
,	O
2	int
,	O
2	int
)	O
;	O
gsl_schur_gen_eigvals	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(double),*(double),*(double),*(double),*(double))->(int)
(	O
&	O
vs	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
vt	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
bcoefr	double
,	O
&	O
temp2	double
,	O
&	O
bcoefi	double
,	O
&	O
acoef	double
,	O
&	O
temp	double
)	O
;	O
if	O
(	O
bcoefi	double
==	O
0.0	int
)	O
{	O
GSL_ERROR	O
(	O
"gsl_schur_gen_eigvals failed on complex block"	*(char)
,	O
GSL_FAILURE	int
)	O
;	O
}	O
acoefa	double
=	O
fabs	(double)->(double)
(	O
acoef	double
)	O
;	O
bcoefa	double
=	O
fabs	(double)->(double)
(	O
bcoefr	double
)	O
+	O
fabs	(double)->(double)
(	O
bcoefi	double
)	O
;	O
scale	double
=	O
1.0	int
;	O
if	O
(	O
acoefa	double
*	O
GSL_DBL_EPSILON	int
<	O
GSL_DBL_MIN	int
&&	O
acoefa	double
>=	O
GSL_DBL_MIN	int
)	O
scale	double
=	O
(	O
GSL_DBL_MIN	int
/	O
GSL_DBL_EPSILON	int
)	O
/	O
acoefa	double
;	O
if	O
(	O
bcoefa	double
*	O
GSL_DBL_EPSILON	int
<	O
GSL_DBL_MIN	int
&&	O
bcoefa	double
>=	O
GSL_DBL_MIN	int
)	O
scale	double
=	O
GSL_MAX	O
(	O
scale	double
,	O
(	O
GSL_DBL_MIN	int
/	O
GSL_DBL_EPSILON	int
)	O
/	O
bcoefa	double
)	O
;	O
if	O
(	O
GSL_DBL_MIN	int
*	O
acoefa	double
>	O
ascale	double
)	O
scale	double
=	O
ascale	double
/	O
(	O
GSL_DBL_MIN	int
*	O
acoefa	double
)	O
;	O
if	O
(	O
GSL_DBL_MIN	int
*	O
bcoefa	double
>	O
bscale	double
)	O
scale	double
=	O
GSL_MIN	O
(	O
scale	double
,	O
bscale	double
/	O
(	O
GSL_DBL_MIN	int
*	O
bcoefa	double
)	O
)	O
;	O
if	O
(	O
scale	double
!=	O
1.0	int
)	O
{	O
acoef	double
*=	O
scale	double
;	O
acoefa	double
=	O
fabs	(double)->(double)
(	O
acoef	double
)	O
;	O
bcoefr	double
*=	O
scale	double
;	O
bcoefi	double
*=	O
scale	double
;	O
bcoefa	double
=	O
fabs	(double)->(double)
(	O
bcoefr	double
)	O
+	O
fabs	(double)->(double)
(	O
bcoefi	double
)	O
;	O
}	O
temp	double
=	O
acoef	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
je	long
-	O
1	int
)	O
;	O
temp2r	double
=	O
acoef	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
je	long
)	O
-	O
bcoefr	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
je	long
)	O
;	O
temp2i	double
=	O
-	O
bcoefi	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
je	long
)	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
temp	double
)	O
>=	O
fabs	(double)->(double)
(	O
temp2r	double
)	O
+	O
fabs	(double)->(double)
(	O
temp2i	double
)	O
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
1.0	int
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
0.0	int
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
,	O
-	O
temp2r	double
/	O
temp	double
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
,	O
-	O
temp2i	double
/	O
temp	double
)	O
;	O
}	O
else	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
,	O
1.0	int
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
,	O
0.0	int
)	O
;	O
temp	double
=	O
acoef	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
,	O
je	long
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
(	O
bcoefr	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
,	O
je	long
-	O
1	int
)	O
-	O
acoef	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
,	O
je	long
-	O
1	int
)	O
)	O
/	O
temp	double
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
,	O
bcoefi	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
,	O
je	long
-	O
1	int
)	O
/	O
temp	double
)	O
;	O
}	O
xmax	double
=	O
GSL_MAX	O
(	O
fabs	(double)->(double)
(	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
)	O
)	O
+	O
fabs	(double)->(double)
(	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
)	O
)	O
,	O
fabs	(double)->(double)
(	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
)	O
)	O
+	O
fabs	(double)->(double)
(	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
)	O
)	O
)	O
;	O
creala	double
=	O
acoef	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
)	O
;	O
cimaga	double
=	O
acoef	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
)	O
;	O
crealb	double
=	O
bcoefr	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
)	O
-	O
bcoefi	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
)	O
;	O
cimagb	double
=	O
bcoefi	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
)	O
+	O
bcoefr	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
)	O
;	O
cre2a	double
=	O
acoef	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
)	O
;	O
cim2a	double
=	O
acoef	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
)	O
;	O
cre2b	double
=	O
bcoefr	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
)	O
-	O
bcoefi	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
)	O
;	O
cim2b	double
=	O
bcoefi	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
)	O
+	O
bcoefr	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
je	long
-	O
1	int
;	O
++	O
i	long
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
-	O
creala	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
je	long
-	O
1	int
)	O
+	O
crealb	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
je	long
-	O
1	int
)	O
-	O
cre2a	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
je	long
)	O
+	O
cre2b	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
je	long
)	O
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
-	O
cimaga	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
je	long
-	O
1	int
)	O
+	O
cimagb	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
je	long
-	O
1	int
)	O
-	O
cim2a	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
je	long
)	O
+	O
cim2b	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
je	long
)	O
)	O
;	O
}	O
}	O
dmin	double
=	O
GSL_MAX	O
(	O
GSL_DBL_MIN	int
,	O
GSL_MAX	O
(	O
GSL_DBL_EPSILON	int
*	O
acoefa	double
*	O
anorm	double
,	O
GSL_DBL_EPSILON	int
*	O
bcoefa	double
*	O
bnorm	double
)	O
)	O
;	O
il2by2	int
=	O
0	int
;	O
for	O
(	O
is	int
=	O
(	O
int	O
)	O
je	long
-	O
(	O
int	O
)	O
nw	long
;	O
is	int
>=	O
0	int
;	O
--	O
is	int
)	O
{	O
j	long
=	O
(	O
size_t	long
)	O
is	int
;	O
if	O
(	O
!	O
il2by2	int
&&	O
j	long
>	O
0	int
)	O
{	O
if	O
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
j	long
-	O
1	int
)	O
!=	O
0.0	int
)	O
{	O
il2by2	int
=	O
1	int
;	O
continue	O
;	O
}	O
}	O
bdiag	array(double)
[	O
0	int
]	O
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
j	long
)	O
;	O
if	O
(	O
il2by2	int
)	O
{	O
na	long
=	O
2	int
;	O
bdiag	array(double)
[	O
1	int
]	O
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
+	O
1	int
)	O
;	O
}	O
else	O
na	long
=	O
1	int
;	O
if	O
(	O
nw	long
==	O
1	int
)	O
{	O
gsl_matrix_const_view	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
sv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_const_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
j	long
,	O
na	long
,	O
na	long
)	O
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
bv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
bv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_subvector	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
na	long
)	O
;	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_view_array_with_stride	(*(double),long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
sum	array(double)
,	O
2	int
,	O
na	long
)	O
;	O
gsl_schur_solve_equation	(double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),double,double,double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(double),*(double),double)->(int)
(	O
acoef	double
,	O
&	O
sv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
bcoefr	double
,	O
bdiag	array(double)
[	O
0	int
]	O
,	O
bdiag	array(double)
[	O
1	int
]	O
,	O
&	O
bv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
scale	double
,	O
&	O
temp	double
,	O
dmin	double
)	O
;	O
}	O
else	O
{	O
double	O
bdat	array(double)
[	O
4	int
]	O
;	O
gsl_matrix_const_view	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
sv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_const_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
j	long
,	O
na	long
,	O
na	long
)	O
;	O
gsl_vector_complex_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_complex_view_array	(*(double),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
sum	array(double)
,	O
na	long
)	O
;	O
gsl_vector_complex_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
bv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_complex_view_array	(*(double),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
bdat	array(double)
,	O
na	long
)	O
;	O
gsl_complex	struct(array(double))
z	struct(array(long double))
;	O
bdat	array(double)
[	O
0	int
]	O
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
)	O
;	O
bdat	array(double)
[	O
1	int
]	O
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
)	O
;	O
if	O
(	O
na	long
==	O
2	int
)	O
{	O
bdat	array(double)
[	O
2	int
]	O
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
)	O
;	O
bdat	array(double)
[	O
3	int
]	O
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
)	O
;	O
}	O
GSL_SET_COMPLEX	O
(	O
&	O
z	struct(array(long double))
,	O
bcoefr	double
,	O
bcoefi	double
)	O
;	O
gsl_schur_solve_equation_z	(double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))),double,double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(double),*(double),double)->(int)
(	O
acoef	double
,	O
&	O
sv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
z	struct(array(long double))
,	O
bdiag	array(double)
[	O
0	int
]	O
,	O
bdiag	array(double)
[	O
1	int
]	O
,	O
&	O
bv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
scale	double
,	O
&	O
temp	double
,	O
dmin	double
)	O
;	O
}	O
if	O
(	O
scale	double
<	O
1.0	int
)	O
{	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<=	O
je	long
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
scale	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
)	O
)	O
;	O
if	O
(	O
nw	long
==	O
2	int
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
scale	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
)	O
)	O
;	O
}	O
}	O
}	O
xmax	double
=	O
GSL_MAX	O
(	O
scale	double
*	O
xmax	double
,	O
temp	double
)	O
;	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<	O
na	long
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
jr	long
,	O
sum	array(double)
[	O
jr	long
*	O
na	long
]	O
)	O
;	O
if	O
(	O
nw	long
==	O
2	int
)	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
jr	long
,	O
sum	array(double)
[	O
jr	long
*	O
na	long
+	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
j	long
>	O
0	int
)	O
{	O
xscale	double
=	O
1.0	int
/	O
GSL_MAX	O
(	O
1.0	int
,	O
xmax	double
)	O
;	O
temp	double
=	O
acoefa	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work1	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
)	O
+	O
bcoefa	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work2	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
)	O
;	O
if	O
(	O
il2by2	int
)	O
{	O
temp	double
=	O
GSL_MAX	O
(	O
temp	double
,	O
acoefa	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work1	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
)	O
+	O
bcoefa	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work2	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
)	O
)	O
;	O
}	O
temp	double
=	O
GSL_MAX	O
(	O
temp	double
,	O
GSL_MAX	O
(	O
acoefa	double
,	O
bcoefa	double
)	O
)	O
;	O
if	O
(	O
temp	double
>	O
bignum	double
*	O
xscale	double
)	O
{	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<=	O
je	long
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
xscale	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
)	O
)	O
;	O
if	O
(	O
nw	long
==	O
2	int
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
xscale	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
)	O
)	O
;	O
}	O
}	O
xmax	double
*=	O
xscale	double
;	O
}	O
for	O
(	O
ja	long
=	O
0	int
;	O
ja	long
<	O
na	long
;	O
++	O
ja	long
)	O
{	O
if	O
(	O
complex_pair	int
)	O
{	O
creala	double
=	O
acoef	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
ja	long
)	O
;	O
cimaga	double
=	O
acoef	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
ja	long
)	O
;	O
crealb	double
=	O
bcoefr	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
ja	long
)	O
-	O
bcoefi	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
ja	long
)	O
;	O
cimagb	double
=	O
bcoefi	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
ja	long
)	O
+	O
bcoefr	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
ja	long
)	O
;	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<=	O
j	long
-	O
1	int
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
)	O
-	O
creala	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
j	long
+	O
ja	long
)	O
+	O
crealb	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
j	long
+	O
ja	long
)	O
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
)	O
-	O
cimaga	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
j	long
+	O
ja	long
)	O
+	O
cimagb	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
j	long
+	O
ja	long
)	O
)	O
;	O
}	O
}	O
else	O
{	O
creala	double
=	O
acoef	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
ja	long
)	O
;	O
crealb	double
=	O
bcoefr	double
*	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
ja	long
)	O
;	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<=	O
j	long
-	O
1	int
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
)	O
-	O
creala	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
j	long
+	O
ja	long
)	O
+	O
crealb	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
T	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
j	long
+	O
ja	long
)	O
)	O
;	O
}	O
}	O
}	O
}	O
il2by2	int
=	O
0	int
;	O
}	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<	O
N	int
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work5	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
)	O
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
0	int
)	O
)	O
;	O
if	O
(	O
nw	long
==	O
2	int
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work6	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
)	O
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
0	int
)	O
)	O
;	O
}	O
}	O
for	O
(	O
jc	long
=	O
1	int
;	O
jc	long
<=	O
je	long
;	O
++	O
jc	long
)	O
{	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<	O
N	int
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work5	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work5	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
)	O
+	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work3	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jc	long
)	O
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
jc	long
)	O
)	O
;	O
if	O
(	O
nw	long
==	O
2	int
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work6	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work6	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
)	O
+	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work4	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jc	long
)	O
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
,	O
jc	long
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
complex_pair	int
)	O
{	O
ecol	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_complex_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
-	O
1	int
)	O
;	O
re	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_complex_real	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
ecol	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
im	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_complex_imag	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
ecol	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
ecol	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_complex_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
)	O
;	O
re2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_complex_real	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
ecol	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
im2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_complex_imag	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
ecol	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
else	O
{	O
ecol	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_complex_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
je	long
)	O
;	O
re	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_complex_real	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
ecol	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
im	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_complex_imag	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
ecol	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<	O
N	int
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
&	O
re	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
jr	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work5	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
)	O
)	O
;	O
if	O
(	O
complex_pair	int
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
&	O
im	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
jr	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work6	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
)	O
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
&	O
re2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
jr	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work5	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
)	O
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
&	O
im2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
jr	long
,	O
-	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work6	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
jr	long
)	O
)	O
;	O
}	O
else	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
&	O
im	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
jr	long
,	O
0.0	int
)	O
;	O
}	O
}	O
xmax	double
=	O
0.0	int
;	O
if	O
(	O
complex_pair	int
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
N	int
;	O
++	O
j	long
)	O
{	O
xmax	double
=	O
GSL_MAX	O
(	O
xmax	double
,	O
fabs	(double)->(double)
(	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
re	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
j	long
)	O
)	O
+	O
fabs	(double)->(double)
(	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
im	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
j	long
)	O
)	O
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
N	int
;	O
++	O
j	long
)	O
{	O
xmax	double
=	O
GSL_MAX	O
(	O
xmax	double
,	O
fabs	(double)->(double)
(	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
re	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
j	long
)	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
xmax	double
>	O
GSL_DBL_MIN	int
)	O
{	O
xscale	double
=	O
1.0	int
/	O
xmax	double
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
N	int
;	O
++	O
j	long
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
&	O
re	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
j	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
re	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
j	long
)	O
*	O
xscale	double
)	O
;	O
if	O
(	O
complex_pair	int
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
&	O
im	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
j	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
im	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
j	long
)	O
*	O
xscale	double
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
&	O
re2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
j	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
re2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
j	long
)	O
*	O
xscale	double
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
&	O
im2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
j	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
im2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
j	long
)	O
*	O
xscale	double
)	O
;	O
}	O
}	O
}	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
void	O
genv_normalize_eigenvectors	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
alpha	long double
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
const	O
size_t	long
N	int
=	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size1	long
;	O
size_t	long
i	long
;	O
gsl_complex	struct(array(double))
ai	struct(array(double))
;	O
gsl_vector_complex_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
vi	double
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
re	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
im	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
double	O
scale	double
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
N	int
;	O
++	O
i	long
)	O
{	O
ai	struct(array(double))
=	O
gsl_vector_complex_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(struct(array(double)))
(	O
alpha	long double
,	O
i	long
)	O
;	O
vi	double
=	O
gsl_matrix_complex_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
;	O
re	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_complex_real	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
vi	double
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
if	O
(	O
GSL_IMAG	O
(	O
ai	struct(array(double))
)	O
==	O
0.0	int
)	O
{	O
scale	double
=	O
1.0	int
/	O
gsl_blas_dnrm2	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
&	O
re	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
gsl_blas_dscal	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
scale	double
,	O
&	O
re	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
else	O
if	O
(	O
GSL_IMAG	O
(	O
ai	struct(array(double))
)	O
>	O
0.0	int
)	O
{	O
im	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_complex_imag	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
vi	double
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
scale	double
=	O
1.0	int
/	O
gsl_hypot	(double,double)->(double)
(	O
gsl_blas_dnrm2	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
&	O
re	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
,	O
gsl_blas_dnrm2	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
&	O
im	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
)	O
;	O
gsl_blas_zdscal	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
scale	double
,	O
&	O
vi	double
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
vi	double
=	O
gsl_matrix_complex_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
+	O
1	int
)	O
;	O
gsl_blas_zdscal	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
scale	double
,	O
&	O
vi	double
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
}	O
}	O
