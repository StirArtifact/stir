extern	O
dataobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
]	O
;	O
extern	O
FILE	struct
*	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
extern	O
FILE	struct
*	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
extern	O
FILE	struct
*	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
extern	O
char	O
*	O
dap_dapname	*(char)
;	O
extern	O
char	O
dap_sttnm	array(array(char))
[	O
NSTATS	O
]	O
[	O
STATLEN	int
+	O
1	int
]	O
;	O
static	O
int	O
dblcmp	(*(double),*(double))->(int)
(	O
double	O
*	O
x	array(double)
,	O
double	O
*	O
y	*(double)
)	O
{	O
if	O
(	O
*	O
x	array(double)
<	O
*	O
y	*(double)
)	O
return	O
-	O
1	int
;	O
if	O
(	O
*	O
x	array(double)
>	O
*	O
y	*(double)
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ddblcmp	(*(*(double)),*(*(double)))->(int)
(	O
double	O
*	O
*	O
x	array(double)
,	O
double	O
*	O
*	O
y	*(double)
)	O
{	O
if	O
(	O
*	O
*	O
x	array(double)
<	O
*	O
*	O
y	*(double)
)	O
return	O
-	O
1	int
;	O
if	O
(	O
*	O
*	O
x	array(double)
>	O
*	O
*	O
y	*(double)
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
(	O
*	O
cmp	*(()->(int))
)	O
(	O
)	O
=	O
&	O
dblcmp	(*(double),*(double))->(int)
;	O
static	O
int	O
(	O
*	O
dcmp	*(()->(int))
)	O
(	O
)	O
=	O
&	O
ddblcmp	(*(*(double)),*(*(double)))->(int)
;	O
static	O
void	O
pctpttest	(double,double,double,*(int),int,*(int))->(void)
(	O
double	O
wtpt	double
,	O
double	O
cumwt	double
,	O
double	O
nextcum	double
,	O
int	O
*	O
pctpt	*(int)
,	O
int	O
n	int
,	O
int	O
*	O
excess	*(int)
)	O
{	O
if	O
(	O
cumwt	double
<=	O
wtpt	double
&&	O
wtpt	double
<	O
nextcum	double
)	O
{	O
*	O
pctpt	*(int)
=	O
n	int
;	O
if	O
(	O
wtpt	double
>	O
cumwt	double
)	O
*	O
excess	*(int)
=	O
1	int
;	O
}	O
}	O
static	O
void	O
pctile2	(*(*(*(double))),int,int,*(int),*(int),*(int))->(void)
(	O
double	O
*	O
*	O
*	O
val	*(*(*(double)))
,	O
int	O
nobs	int
,	O
int	O
nvar	int
,	O
int	O
*	O
varv	array(int)
,	O
int	O
*	O
wtvar	*(int)
,	O
int	O
*	O
stats	array(int)
)	O
{	O
int	O
v	int
;	O
int	O
*	O
pctptmem	*(int)
;	O
int	O
*	O
*	O
pctpt	*(int)
;	O
int	O
*	O
excessmem	*(int)
;	O
int	O
*	O
*	O
excess	*(int)
;	O
int	O
pn	int
;	O
int	O
pi	int
;	O
double	O
pct	double
;	O
static	O
double	O
sumwt	double
;	O
static	O
double	O
cumwt	double
;	O
static	O
double	O
nextcum	double
;	O
static	O
double	O
wtpt	double
;	O
double	O
upct	array(double)
[	O
MAXPCTPT	int
]	O
;	O
int	O
n	int
;	O
int	O
ptindex	int
;	O
int	O
s	int
;	O
double	O
q1	double
,	O
q3	double
;	O
int	O
typen	int
;	O
dap_swap	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
typen	int
=	O
dap_varnum	(array(char))->(int)
(	O
"_type_"	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(pctile2) missing _type_ variable\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
pctptmem	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
nvar	int
*	O
(	O
9	int
+	O
MAXPCTPT	int
)	O
,	O
""	*(char)
)	O
;	O
pctpt	*(int)
=	O
(	O
int	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
*	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
excessmem	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
nvar	int
*	O
(	O
9	int
+	O
MAXPCTPT	int
)	O
,	O
""	*(char)
)	O
;	O
excess	*(int)
=	O
(	O
int	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
*	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
pn	int
=	O
0	int
;	O
pn	int
<	O
MAXPCTPT	int
&&	O
stats	array(int)
[	O
NSTATS	O
-	O
MAXPCTPT	int
+	O
pn	int
]	O
;	O
pn	int
++	O
)	O
{	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
dap_sttnm	array(array(char))
[	O
NSTATS	O
-	O
MAXPCTPT	int
+	O
pn	int
]	O
+	O
1	int
,	O
"%lf"	*(char)
,	O
&	O
upct	array(double)
[	O
pn	int
]	O
)	O
!=	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(pctile2) invalid percentile: %s\n"	*(char)
,	O
dap_sttnm	array(array(char))
[	O
NSTATS	O
-	O
MAXPCTPT	int
+	O
pn	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
pctpt	*(int)
[	O
v	int
]	O
=	O
pctptmem	*(int)
+	O
v	int
*	O
(	O
9	int
+	O
MAXPCTPT	int
)	O
;	O
excess	*(int)
[	O
v	int
]	O
=	O
excessmem	*(int)
+	O
v	int
*	O
(	O
9	int
+	O
MAXPCTPT	int
)	O
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
(	O
void	O
*	O
)	O
val	*(*(*(double)))
[	O
v	int
]	O
,	O
(	O
size_t	long
)	O
nobs	int
,	O
(	O
size_t	long
)	O
(	O
sizeof	O
(	O
double	O
*	O
)	O
)	O
,	O
dcmp	*(()->(int))
)	O
;	O
for	O
(	O
n	int
=	O
0	int
,	O
sumwt	double
=	O
0.0	int
;	O
n	int
<	O
nobs	int
;	O
n	int
++	O
)	O
sumwt	double
+=	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
n	int
]	O
[	O
1	int
]	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
9	int
+	O
pn	int
;	O
s	int
++	O
)	O
{	O
excess	*(int)
[	O
v	int
]	O
[	O
s	int
]	O
=	O
0	int
;	O
pctpt	*(int)
[	O
v	int
]	O
[	O
s	int
]	O
=	O
nobs	int
-	O
1	int
;	O
}	O
for	O
(	O
n	int
=	O
0	int
,	O
cumwt	double
=	O
0.0	int
;	O
n	int
<	O
nobs	int
;	O
n	int
++	O
,	O
cumwt	double
=	O
nextcum	double
)	O
{	O
nextcum	double
=	O
cumwt	double
+	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
n	int
]	O
[	O
1	int
]	O
;	O
pctpttest	(double,double,double,*(int),int,*(int))->(void)
(	O
sumwt	double
/	O
100.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	*(int)
[	O
v	int
]	O
,	O
n	int
,	O
excess	*(int)
[	O
v	int
]	O
)	O
;	O
pctpttest	(double,double,double,*(int),int,*(int))->(void)
(	O
sumwt	double
/	O
20.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	*(int)
[	O
v	int
]	O
+	O
1	int
,	O
n	int
,	O
excess	*(int)
[	O
v	int
]	O
+	O
1	int
)	O
;	O
pctpttest	(double,double,double,*(int),int,*(int))->(void)
(	O
sumwt	double
/	O
10.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	*(int)
[	O
v	int
]	O
+	O
2	int
,	O
n	int
,	O
excess	*(int)
[	O
v	int
]	O
+	O
2	int
)	O
;	O
pctpttest	(double,double,double,*(int),int,*(int))->(void)
(	O
sumwt	double
/	O
4.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	*(int)
[	O
v	int
]	O
+	O
3	int
,	O
n	int
,	O
excess	*(int)
[	O
v	int
]	O
+	O
3	int
)	O
;	O
pctpttest	(double,double,double,*(int),int,*(int))->(void)
(	O
sumwt	double
/	O
2.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	*(int)
[	O
v	int
]	O
+	O
4	int
,	O
n	int
,	O
excess	*(int)
[	O
v	int
]	O
+	O
4	int
)	O
;	O
pctpttest	(double,double,double,*(int),int,*(int))->(void)
(	O
3.0	int
*	O
sumwt	double
/	O
4.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	*(int)
[	O
v	int
]	O
+	O
5	int
,	O
n	int
,	O
excess	*(int)
[	O
v	int
]	O
+	O
5	int
)	O
;	O
pctpttest	(double,double,double,*(int),int,*(int))->(void)
(	O
9.0	int
*	O
sumwt	double
/	O
10.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	*(int)
[	O
v	int
]	O
+	O
6	int
,	O
n	int
,	O
excess	*(int)
[	O
v	int
]	O
+	O
6	int
)	O
;	O
pctpttest	(double,double,double,*(int),int,*(int))->(void)
(	O
95.0	int
*	O
sumwt	double
/	O
100.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	*(int)
[	O
v	int
]	O
+	O
7	int
,	O
n	int
,	O
excess	*(int)
[	O
v	int
]	O
+	O
7	int
)	O
;	O
pctpttest	(double,double,double,*(int),int,*(int))->(void)
(	O
99.0	int
*	O
sumwt	double
/	O
100.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	*(int)
[	O
v	int
]	O
+	O
8	int
,	O
n	int
,	O
excess	*(int)
[	O
v	int
]	O
+	O
8	int
)	O
;	O
for	O
(	O
pi	int
=	O
0	int
;	O
pi	int
<	O
pn	int
;	O
pi	int
++	O
)	O
{	O
pctpttest	(double,double,double,*(int),int,*(int))->(void)
(	O
upct	array(double)
[	O
pi	int
]	O
*	O
sumwt	double
/	O
100.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	*(int)
[	O
v	int
]	O
+	O
9	int
+	O
pi	int
,	O
n	int
,	O
excess	*(int)
[	O
v	int
]	O
+	O
9	int
+	O
pi	int
)	O
;	O
}	O
}	O
}	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
9	int
+	O
pn	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
stats	array(int)
[	O
P1	O
+	O
s	int
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
ptindex	int
=	O
pctpt	*(int)
[	O
v	int
]	O
[	O
s	int
]	O
-	O
1	int
;	O
if	O
(	O
ptindex	int
<	O
0	int
)	O
ptindex	int
=	O
0	int
;	O
if	O
(	O
excess	*(int)
[	O
v	int
]	O
[	O
s	int
]	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
pctpt	*(int)
[	O
v	int
]	O
[	O
s	int
]	O
]	O
[	O
0	int
]	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.5	int
*	O
(	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
pctpt	*(int)
[	O
v	int
]	O
[	O
s	int
]	O
]	O
[	O
0	int
]	O
+	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
ptindex	int
]	O
[	O
0	int
]	O
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
dap_sttnm	array(array(char))
[	O
P1	O
+	O
s	int
]	O
)	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
stats	array(int)
[	O
N	int
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
(	O
double	O
)	O
nobs	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"N"	*(char)
)	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
MIN	O
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
0	int
]	O
[	O
0	int
]	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"MIN"	*(char)
)	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
MAX	O
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
nobs	int
-	O
1	int
]	O
[	O
0	int
]	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"MAX"	*(char)
)	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
QRANGE	O
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
ptindex	int
=	O
pctpt	*(int)
[	O
v	int
]	O
[	O
3	int
]	O
-	O
1	int
;	O
if	O
(	O
ptindex	int
<	O
0	int
)	O
ptindex	int
=	O
0	int
;	O
if	O
(	O
excess	*(int)
[	O
v	int
]	O
[	O
3	int
]	O
)	O
q1	double
=	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
pctpt	*(int)
[	O
v	int
]	O
[	O
3	int
]	O
]	O
[	O
0	int
]	O
;	O
else	O
q1	double
=	O
0.5	int
*	O
(	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
pctpt	*(int)
[	O
v	int
]	O
[	O
3	int
]	O
]	O
[	O
0	int
]	O
+	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
ptindex	int
]	O
[	O
0	int
]	O
)	O
;	O
ptindex	int
=	O
pctpt	*(int)
[	O
v	int
]	O
[	O
5	int
]	O
-	O
1	int
;	O
if	O
(	O
ptindex	int
<	O
0	int
)	O
ptindex	int
=	O
0	int
;	O
if	O
(	O
excess	*(int)
[	O
v	int
]	O
[	O
5	int
]	O
)	O
q3	double
=	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
pctpt	*(int)
[	O
v	int
]	O
[	O
5	int
]	O
]	O
[	O
0	int
]	O
;	O
else	O
q3	double
=	O
0.5	int
*	O
(	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
pctpt	*(int)
[	O
v	int
]	O
[	O
5	int
]	O
]	O
[	O
0	int
]	O
+	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
ptindex	int
]	O
[	O
0	int
]	O
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
q3	double
-	O
q1	double
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"QRANGE"	*(char)
)	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
dap_swap	()->(void)
(	O
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
pctptmem	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
pctpt	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
excessmem	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
excess	*(int)
,	O
""	*(char)
)	O
;	O
}	O
static	O
void	O
pctile1	(*(*(*(double))),int,int,*(int),*(int))->(void)
(	O
double	O
*	O
*	O
*	O
val	*(*(*(double)))
,	O
int	O
nobs	int
,	O
int	O
nvar	int
,	O
int	O
*	O
varv	array(int)
,	O
int	O
*	O
stats	array(int)
)	O
{	O
int	O
v	int
;	O
double	O
dnobs	double
;	O
static	O
int	O
pctpt	*(int)
[	O
9	int
+	O
MAXPCTPT	int
]	O
;	O
int	O
pn	int
;	O
double	O
pct	double
;	O
static	O
int	O
excess	*(int)
[	O
9	int
+	O
MAXPCTPT	int
]	O
;	O
int	O
ptindex	int
;	O
int	O
s	int
;	O
double	O
q1	double
,	O
q3	double
;	O
int	O
typen	int
;	O
dap_swap	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
typen	int
=	O
dap_varnum	(array(char))->(int)
(	O
"_type_"	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(pctile1) missing _type_ variable\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
dnobs	double
=	O
(	O
double	O
)	O
nobs	int
;	O
pctpt	*(int)
[	O
0	int
]	O
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
dnobs	double
/	O
100.0	int
)	O
;	O
excess	*(int)
[	O
0	int
]	O
=	O
(	O
(	O
dnobs	double
/	O
100.0	int
)	O
>	O
floor	(double)->(double)
(	O
dnobs	double
/	O
100.0	int
)	O
)	O
;	O
pctpt	*(int)
[	O
1	int
]	O
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
dnobs	double
/	O
20.0	int
)	O
;	O
excess	*(int)
[	O
1	int
]	O
=	O
(	O
(	O
dnobs	double
/	O
20.0	int
)	O
>	O
floor	(double)->(double)
(	O
dnobs	double
/	O
20.0	int
)	O
)	O
;	O
pctpt	*(int)
[	O
2	int
]	O
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
dnobs	double
/	O
10.0	int
)	O
;	O
excess	*(int)
[	O
2	int
]	O
=	O
(	O
(	O
dnobs	double
/	O
10.0	int
)	O
>	O
floor	(double)->(double)
(	O
dnobs	double
/	O
10.0	int
)	O
)	O
;	O
pctpt	*(int)
[	O
3	int
]	O
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
dnobs	double
/	O
4.0	int
)	O
;	O
excess	*(int)
[	O
3	int
]	O
=	O
(	O
(	O
dnobs	double
/	O
4.0	int
)	O
>	O
floor	(double)->(double)
(	O
dnobs	double
/	O
4.0	int
)	O
)	O
;	O
pctpt	*(int)
[	O
4	int
]	O
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
dnobs	double
/	O
2.0	int
)	O
;	O
excess	*(int)
[	O
4	int
]	O
=	O
(	O
(	O
dnobs	double
/	O
2.0	int
)	O
>	O
floor	(double)->(double)
(	O
dnobs	double
/	O
2.0	int
)	O
)	O
;	O
pctpt	*(int)
[	O
5	int
]	O
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
3.0	int
*	O
dnobs	double
/	O
4.0	int
)	O
;	O
excess	*(int)
[	O
5	int
]	O
=	O
(	O
(	O
3.0	int
*	O
dnobs	double
/	O
4.0	int
)	O
>	O
floor	(double)->(double)
(	O
3.0	int
*	O
dnobs	double
/	O
4.0	int
)	O
)	O
;	O
pctpt	*(int)
[	O
6	int
]	O
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
9.0	int
*	O
dnobs	double
/	O
10.0	int
)	O
;	O
excess	*(int)
[	O
6	int
]	O
=	O
(	O
(	O
9.0	int
*	O
dnobs	double
/	O
10.0	int
)	O
>	O
floor	(double)->(double)
(	O
9.0	int
*	O
dnobs	double
/	O
10.0	int
)	O
)	O
;	O
pctpt	*(int)
[	O
7	int
]	O
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
95.0	int
*	O
dnobs	double
/	O
100.0	int
)	O
;	O
excess	*(int)
[	O
7	int
]	O
=	O
(	O
(	O
95.0	int
*	O
dnobs	double
/	O
100.0	int
)	O
>	O
floor	(double)->(double)
(	O
95.0	int
*	O
dnobs	double
/	O
100.0	int
)	O
)	O
;	O
pctpt	*(int)
[	O
8	int
]	O
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
99.0	int
*	O
dnobs	double
/	O
100.0	int
)	O
;	O
excess	*(int)
[	O
8	int
]	O
=	O
(	O
(	O
99.0	int
*	O
dnobs	double
/	O
100.0	int
)	O
>	O
floor	(double)->(double)
(	O
99.0	int
*	O
dnobs	double
/	O
100.0	int
)	O
)	O
;	O
for	O
(	O
pn	int
=	O
0	int
;	O
pn	int
<	O
MAXPCTPT	int
&&	O
stats	array(int)
[	O
NSTATS	O
-	O
MAXPCTPT	int
+	O
pn	int
]	O
;	O
pn	int
++	O
)	O
{	O
sscanf	(*(char),*(char))->(int)
(	O
dap_sttnm	array(array(char))
[	O
NSTATS	O
-	O
MAXPCTPT	int
+	O
pn	int
]	O
+	O
1	int
,	O
"%lf"	*(char)
,	O
&	O
pct	double
)	O
;	O
pctpt	*(int)
[	O
9	int
+	O
pn	int
]	O
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
pct	double
*	O
dnobs	double
/	O
100.0	int
)	O
;	O
excess	*(int)
[	O
9	int
+	O
pn	int
]	O
=	O
(	O
(	O
pct	double
*	O
dnobs	double
/	O
100.0	int
)	O
>	O
floor	(double)->(double)
(	O
pct	double
*	O
dnobs	double
/	O
100.0	int
)	O
)	O
;	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
(	O
void	O
*	O
)	O
val	*(*(*(double)))
[	O
v	int
]	O
,	O
(	O
size_t	long
)	O
nobs	int
,	O
(	O
size_t	long
)	O
sizeof	O
(	O
double	O
*	O
)	O
,	O
dcmp	*(()->(int))
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
9	int
+	O
pn	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
stats	array(int)
[	O
P1	O
+	O
s	int
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
ptindex	int
=	O
pctpt	*(int)
[	O
s	int
]	O
-	O
1	int
;	O
if	O
(	O
ptindex	int
<	O
0	int
)	O
ptindex	int
=	O
0	int
;	O
if	O
(	O
excess	*(int)
[	O
s	int
]	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
pctpt	*(int)
[	O
s	int
]	O
]	O
[	O
0	int
]	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.5	int
*	O
(	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
pctpt	*(int)
[	O
s	int
]	O
]	O
[	O
0	int
]	O
+	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
ptindex	int
]	O
[	O
0	int
]	O
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
dap_sttnm	array(array(char))
[	O
P1	O
+	O
s	int
]	O
)	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
stats	array(int)
[	O
N	int
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
dnobs	double
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"N"	*(char)
)	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
MIN	O
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
0	int
]	O
[	O
0	int
]	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"MIN"	*(char)
)	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
MAX	O
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
nobs	int
-	O
1	int
]	O
[	O
0	int
]	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"MAX"	*(char)
)	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
RANGE	O
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
nobs	int
-	O
1	int
]	O
[	O
0	int
]	O
-	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
0	int
]	O
[	O
0	int
]	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"RANGE"	*(char)
)	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
QRANGE	O
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
ptindex	int
=	O
pctpt	*(int)
[	O
3	int
]	O
-	O
1	int
;	O
if	O
(	O
ptindex	int
<	O
0	int
)	O
ptindex	int
=	O
0	int
;	O
if	O
(	O
excess	*(int)
[	O
3	int
]	O
)	O
q1	double
=	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
pctpt	*(int)
[	O
3	int
]	O
]	O
[	O
0	int
]	O
;	O
else	O
q1	double
=	O
0.5	int
*	O
(	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
pctpt	*(int)
[	O
3	int
]	O
]	O
[	O
0	int
]	O
+	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
ptindex	int
]	O
[	O
0	int
]	O
)	O
;	O
ptindex	int
=	O
pctpt	*(int)
[	O
5	int
]	O
-	O
1	int
;	O
if	O
(	O
ptindex	int
<	O
0	int
)	O
ptindex	int
=	O
0	int
;	O
if	O
(	O
excess	*(int)
[	O
5	int
]	O
)	O
q3	double
=	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
pctpt	*(int)
[	O
5	int
]	O
]	O
[	O
0	int
]	O
;	O
else	O
q3	double
=	O
0.5	int
*	O
(	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
pctpt	*(int)
[	O
5	int
]	O
]	O
[	O
0	int
]	O
+	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
ptindex	int
]	O
[	O
0	int
]	O
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
q3	double
-	O
q1	double
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"QRANGE"	*(char)
)	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
dap_swap	()->(void)
(	O
)	O
;	O
}	O
void	O
pctiles	(*(char),*(char),*(char),*(char))->(void)
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
varlist	array(char)
,	O
char	O
*	O
statlist	array(char)
,	O
char	O
*	O
marks	array(char)
)	O
{	O
char	O
*	O
outname	*(char)
;	O
int	O
stats	array(int)
[	O
NSTATS	O
]	O
;	O
int	O
*	O
varv	array(int)
;	O
int	O
*	O
markv	array(int)
;	O
int	O
nvar	int
;	O
int	O
nmark	int
;	O
int	O
nobs	int
;	O
char	O
*	O
outlist	*(char)
;	O
int	O
*	O
wtvar	*(int)
;	O
int	O
v	int
;	O
double	O
*	O
valmem	*(double)
;	O
double	O
*	O
*	O
valpair	*(*(double))
;	O
double	O
*	O
*	O
*	O
val	*(*(*(double)))
;	O
int	O
weighted	int
;	O
int	O
more	int
;	O
if	O
(	O
!	O
fname	array(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(pctiles) No dataset name given.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
outname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
+	O
5	int
,	O
""	*(char)
)	O
;	O
dap_suffix	(array(char),array(char),array(char))->(void)
(	O
outname	*(char)
,	O
fname	array(char)
,	O
".pct"	*(char)
)	O
;	O
varv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
markv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
wtvar	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
outlist	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_listlen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
inset	(array(char))->(void)
(	O
fname	array(char)
)	O
;	O
dap_stats	(array(char),array(int))->(void)
(	O
statlist	array(char)
,	O
stats	array(int)
)	O
;	O
nvar	int
=	O
dap_mnsparse	(*(char),*(char),*(int),*(int),array(int))->(int)
(	O
varlist	array(char)
,	O
outlist	*(char)
,	O
varv	array(int)
,	O
wtvar	*(int)
,	O
stats	array(int)
)	O
;	O
if	O
(	O
marks	array(char)
&&	O
marks	array(char)
[	O
0	int
]	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
" "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
marks	array(char)
)	O
;	O
}	O
outset	(array(char),array(char))->(void)
(	O
outname	*(char)
,	O
outlist	*(char)
)	O
;	O
nmark	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
marks	array(char)
,	O
markv	array(int)
,	O
dap_maxvar	int
)	O
;	O
valmem	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
*	O
2	int
*	O
dap_maxval	int
,	O
""	*(char)
)	O
;	O
valpair	*(*(double))
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nvar	int
*	O
dap_maxval	int
,	O
""	*(char)
)	O
;	O
val	*(*(*(double)))
=	O
(	O
double	O
*	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
,	O
weighted	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
wtvar	*(int)
[	O
v	int
]	O
>=	O
0	int
)	O
weighted	int
=	O
1	int
;	O
}	O
for	O
(	O
nobs	int
=	O
0	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
nobs	int
++	O
)	O
{	O
more	int
=	O
step	()->(int)
(	O
)	O
;	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
markv	array(int)
,	O
nmark	int
)	O
)	O
{	O
if	O
(	O
weighted	int
)	O
pctile2	(*(*(*(double))),int,int,*(int),*(int),*(int))->(void)
(	O
val	*(*(*(double)))
,	O
nobs	int
,	O
nvar	int
,	O
varv	array(int)
,	O
wtvar	*(int)
,	O
stats	array(int)
)	O
;	O
else	O
pctile1	(*(*(*(double))),int,int,*(int),*(int))->(void)
(	O
val	*(*(*(double)))
,	O
nobs	int
,	O
nvar	int
,	O
varv	array(int)
,	O
stats	array(int)
)	O
;	O
nobs	int
=	O
0	int
;	O
}	O
if	O
(	O
more	int
)	O
{	O
if	O
(	O
nobs	int
<	O
dap_maxval	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
valpair	*(*(double))
[	O
dap_maxval	int
*	O
v	int
+	O
nobs	int
]	O
=	O
valmem	*(double)
+	O
2	int
*	O
(	O
dap_maxval	int
*	O
v	int
+	O
nobs	int
)	O
;	O
val	*(*(*(double)))
[	O
v	int
]	O
=	O
valpair	*(*(double))
+	O
v	int
*	O
dap_maxval	int
;	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
nobs	int
]	O
[	O
0	int
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
;	O
if	O
(	O
wtvar	*(int)
[	O
v	int
]	O
>=	O
0	int
)	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
nobs	int
]	O
[	O
1	int
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
wtvar	*(int)
[	O
v	int
]	O
]	O
;	O
else	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
nobs	int
]	O
[	O
1	int
]	O
=	O
1.0	int
;	O
if	O
(	O
!	O
finite	(double)->(int)
(	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
nobs	int
]	O
[	O
0	int
]	O
)	O
||	O
!	O
finite	(double)->(int)
(	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
nobs	int
]	O
[	O
1	int
]	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(pctiles) NaN value %d for %s\n"	*(char)
,	O
nobs	int
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(pctiles) Too many data.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
outname	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
varv	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
markv	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
wtvar	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
outlist	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
valmem	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
valpair	*(*(double))
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
val	*(*(*(double)))
,	O
""	*(char)
)	O
;	O
}	O
static	O
void	O
corr1	(*(int),int,*(*(double)),array(double),int)->(void)
(	O
int	O
*	O
varv	array(int)
,	O
int	O
nvar	int
,	O
double	O
*	O
*	O
cormat	*(*(double))
,	O
double	O
ss	array(double)
[	O
]	O
,	O
int	O
nobs	int
)	O
{	O
int	O
varn	array(int)
[	O
3	int
]	O
;	O
int	O
typen	int
;	O
double	O
nf	double
;	O
int	O
v	int
,	O
w	int
;	O
double	O
r	double
;	O
if	O
(	O
nobs	int
<	O
2	int
)	O
return	O
;	O
dap_swap	()->(void)
(	O
)	O
;	O
nf	double
=	O
sqrt	(double)->(double)
(	O
(	O
double	O
)	O
(	O
nobs	int
-	O
2	int
)	O
)	O
;	O
varn	array(int)
[	O
0	int
]	O
=	O
dap_varnum	(array(char))->(int)
(	O
"_var1_"	*(char)
)	O
;	O
varn	array(int)
[	O
1	int
]	O
=	O
dap_varnum	(array(char))->(int)
(	O
"_var2_"	*(char)
)	O
;	O
varn	array(int)
[	O
2	int
]	O
=	O
dap_varnum	(array(char))->(int)
(	O
"_corr_"	*(char)
)	O
;	O
typen	int
=	O
dap_varnum	(array(char))->(int)
(	O
"_type_"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
for	O
(	O
w	int
=	O
0	int
;	O
w	int
<	O
v	int
;	O
w	int
++	O
)	O
cormat	*(*(double))
[	O
v	int
]	O
[	O
w	int
]	O
=	O
cormat	*(*(double))
[	O
w	int
]	O
[	O
v	int
]	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"N"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
varn	array(int)
[	O
0	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
for	O
(	O
w	int
=	O
0	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
varn	array(int)
[	O
1	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
w	int
]	O
]	O
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varn	array(int)
[	O
2	int
]	O
]	O
=	O
(	O
double	O
)	O
nobs	int
;	O
output	()->(void)
(	O
)	O
;	O
}	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"CORR"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
varn	array(int)
[	O
0	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
for	O
(	O
w	int
=	O
0	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
varn	array(int)
[	O
1	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
w	int
]	O
]	O
)	O
;	O
if	O
(	O
w	int
==	O
v	int
)	O
cormat	*(*(double))
[	O
v	int
]	O
[	O
w	int
]	O
=	O
1.0	int
;	O
else	O
cormat	*(*(double))
[	O
v	int
]	O
[	O
w	int
]	O
/=	O
sqrt	(double)->(double)
(	O
ss	array(double)
[	O
v	int
]	O
*	O
ss	array(double)
[	O
w	int
]	O
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varn	array(int)
[	O
2	int
]	O
]	O
=	O
cormat	*(*(double))
[	O
v	int
]	O
[	O
w	int
]	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"PCORR"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
varn	array(int)
[	O
0	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
for	O
(	O
w	int
=	O
0	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
varn	array(int)
[	O
1	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
w	int
]	O
]	O
)	O
;	O
r	double
=	O
fabs	(double)->(double)
(	O
cormat	*(*(double))
[	O
v	int
]	O
[	O
w	int
]	O
)	O
;	O
if	O
(	O
r	double
==	O
1.0	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varn	array(int)
[	O
2	int
]	O
]	O
=	O
0.0	int
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varn	array(int)
[	O
2	int
]	O
]	O
=	O
2.0	int
*	O
probt	(double,int)->(double)
(	O
nf	double
*	O
r	double
/	O
sqrt	(double)->(double)
(	O
1.0	int
-	O
r	double
*	O
r	double
)	O
,	O
nobs	int
-	O
2	int
)	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
}	O
dap_swap	()->(void)
(	O
)	O
;	O
}	O
void	O
corr	(*(char),*(char),*(char))->(void)
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
varlist	array(char)
,	O
char	O
*	O
marks	array(char)
)	O
{	O
char	O
*	O
outname	*(char)
;	O
char	O
varstr	array(char)
[	O
11	int
]	O
;	O
char	O
*	O
outlist	*(char)
;	O
int	O
*	O
markv	array(int)
;	O
int	O
nmark	int
;	O
int	O
*	O
varv	array(int)
;	O
int	O
nvar	int
;	O
int	O
nobs	int
;	O
double	O
*	O
cormem	*(double)
;	O
double	O
*	O
*	O
cormat	*(*(double))
;	O
int	O
v	int
,	O
w	int
;	O
double	O
*	O
sum	*(double)
;	O
double	O
*	O
ss	array(double)
;	O
double	O
vtmp	double
;	O
double	O
tmp	double
;	O
double	O
dn	double
;	O
int	O
more	int
;	O
if	O
(	O
!	O
fname	array(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(corr) No dataset name given.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
markv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
varv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
outname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
+	O
5	int
,	O
""	*(char)
)	O
;	O
dap_suffix	(array(char),array(char),array(char))->(void)
(	O
outname	*(char)
,	O
fname	array(char)
,	O
".cor"	*(char)
)	O
;	O
outlist	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
marks	array(char)
)	O
+	O
22	int
,	O
""	*(char)
)	O
;	O
inset	(array(char))->(void)
(	O
fname	array(char)
)	O
;	O
nvar	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
varlist	array(char)
,	O
varv	array(int)
,	O
dap_maxvar	int
)	O
;	O
cormem	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
cormat	*(*(double))
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
cormat	*(*(double))
[	O
v	int
]	O
=	O
cormem	*(double)
+	O
v	int
*	O
nvar	int
;	O
sum	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
ss	array(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
marks	array(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
>=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(corr) Variable not of type dap_double: %s\n"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
varstr	array(char)
,	O
"_var1_ %d"	*(char)
,	O
dap_namelen	int
)	O
;	O
dap_vd	(array(char),int)->(int)
(	O
varstr	array(char)
,	O
0	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
varstr	array(char)
,	O
"_var2_ %d"	*(char)
,	O
dap_namelen	int
)	O
;	O
dap_vd	(array(char),int)->(int)
(	O
varstr	array(char)
,	O
0	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
varstr	array(char)
,	O
"_corr_ %d"	*(char)
,	O
DBL	O
)	O
;	O
dap_vd	(array(char),int)->(int)
(	O
varstr	array(char)
,	O
0	int
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
" _var1_ _var2_ _corr_"	*(char)
)	O
;	O
outset	(array(char),array(char))->(void)
(	O
outname	*(char)
,	O
outlist	*(char)
)	O
;	O
nmark	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
marks	array(char)
,	O
markv	array(int)
,	O
dap_maxvar	int
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
!=	O
DBL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(corr) variables must be of type double: %s\n"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
w	int
=	O
v	int
+	O
1	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
cormat	*(*(double))
[	O
v	int
]	O
[	O
w	int
]	O
=	O
0.0	int
;	O
sum	*(double)
[	O
v	int
]	O
=	O
0.0	int
;	O
ss	array(double)
[	O
v	int
]	O
=	O
0.0	int
;	O
}	O
for	O
(	O
nobs	int
=	O
0	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
nobs	int
++	O
)	O
{	O
more	int
=	O
step	()->(int)
(	O
)	O
;	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
markv	array(int)
,	O
nmark	int
)	O
)	O
{	O
corr1	(*(int),int,*(*(double)),array(double),int)->(void)
(	O
varv	array(int)
,	O
nvar	int
,	O
cormat	*(*(double))
,	O
ss	array(double)
,	O
nobs	int
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
for	O
(	O
w	int
=	O
v	int
+	O
1	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
cormat	*(*(double))
[	O
v	int
]	O
[	O
w	int
]	O
=	O
0.0	int
;	O
sum	*(double)
[	O
v	int
]	O
=	O
0.0	int
;	O
ss	array(double)
[	O
v	int
]	O
=	O
0.0	int
;	O
}	O
nobs	int
=	O
0	int
;	O
}	O
if	O
(	O
more	int
)	O
{	O
dn	double
=	O
(	O
double	O
)	O
nobs	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
vtmp	double
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
;	O
if	O
(	O
!	O
finite	(double)->(int)
(	O
vtmp	double
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(corr) NaN value %d for %s\n"	*(char)
,	O
nobs	int
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
nobs	int
)	O
{	O
tmp	double
=	O
sum	*(double)
[	O
v	int
]	O
-	O
dn	double
*	O
vtmp	double
;	O
for	O
(	O
w	int
=	O
v	int
+	O
1	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
{	O
cormat	*(*(double))
[	O
v	int
]	O
[	O
w	int
]	O
+=	O
tmp	double
*	O
(	O
sum	*(double)
[	O
w	int
]	O
-	O
dn	double
*	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
w	int
]	O
]	O
)	O
/	O
(	O
dn	double
*	O
(	O
dn	double
+	O
1.0	int
)	O
)	O
;	O
}	O
ss	array(double)
[	O
v	int
]	O
+=	O
tmp	double
*	O
tmp	double
/	O
(	O
dn	double
*	O
(	O
dn	double
+	O
1.0	int
)	O
)	O
;	O
}	O
sum	*(double)
[	O
v	int
]	O
+=	O
vtmp	double
;	O
}	O
}	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
markv	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
varv	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
outname	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
outlist	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
cormem	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
cormat	*(*(double))
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
sum	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
ss	array(double)
,	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
groupparse	(*(char),array(int),array(int))->(int)
(	O
char	O
*	O
varspec	array(char)
,	O
int	O
varv	array(int)
[	O
]	O
,	O
int	O
classtype	array(int)
[	O
]	O
)	O
{	O
int	O
s	int
;	O
int	O
i	int
;	O
int	O
v	int
;	O
char	O
*	O
varname	*(char)
;	O
int	O
n	int
;	O
int	O
nvar	int
;	O
int	O
number	int
;	O
if	O
(	O
!	O
varspec	array(char)
)	O
return	O
0	int
;	O
varname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_namelen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
varspec	array(char)
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
for	O
(	O
nvar	int
=	O
0	int
,	O
number	int
=	O
0	int
;	O
varspec	array(char)
[	O
s	int
]	O
;	O
)	O
{	O
classtype	array(int)
[	O
nvar	int
]	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
varspec	array(char)
[	O
s	int
+	O
i	int
]	O
&&	O
varspec	array(char)
[	O
s	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
varname	*(char)
[	O
i	int
]	O
=	O
varspec	array(char)
[	O
s	int
+	O
i	int
]	O
;	O
else	O
{	O
varname	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(groupparse) variable name too long: %s\n"	*(char)
,	O
varname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
varname	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
s	int
+=	O
i	int
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	(array(char))->(int)
(	O
varname	*(char)
)	O
)	O
>=	O
0	int
)	O
{	O
varv	array(int)
[	O
nvar	int
]	O
=	O
v	int
;	O
while	O
(	O
varspec	array(char)
[	O
s	int
]	O
==	O
' '	O
)	O
s	int
++	O
;	O
if	O
(	O
number	int
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
v	int
]	O
!=	O
DBL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(groupparse) grouping variable must be of type double: %s\n"	*(char)
,	O
varname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
'0'	O
<=	O
varspec	array(char)
[	O
s	int
]	O
&&	O
varspec	array(char)
[	O
s	int
]	O
<=	O
'9'	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
v	int
]	O
==	O
DBL	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
,	O
i	int
=	O
0	int
;	O
'0'	O
<=	O
varspec	array(char)
[	O
s	int
+	O
i	int
]	O
&&	O
varspec	array(char)
[	O
s	int
+	O
i	int
]	O
<=	O
'9'	O
;	O
i	int
++	O
)	O
n	int
=	O
10	int
*	O
n	int
+	O
varspec	array(char)
[	O
s	int
+	O
i	int
]	O
-	O
'0'	O
;	O
if	O
(	O
!	O
n	int
||	O
(	O
varspec	array(char)
[	O
s	int
+	O
i	int
]	O
!=	O
'#'	O
&&	O
varspec	array(char)
[	O
s	int
+	O
i	int
]	O
!=	O
'^'	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(groupparse) invalid number of groups: %s\n"	*(char)
,	O
varspec	array(char)
+	O
s	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
switch	O
(	O
varspec	array(char)
[	O
s	int
+	O
i	int
]	O
)	O
{	O
case	O
'^'	O
:	O
classtype	array(int)
[	O
nvar	int
]	O
=	O
-	O
n	int
;	O
break	O
;	O
case	O
'#'	O
:	O
classtype	array(int)
[	O
nvar	int
]	O
=	O
n	int
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(groupparse) invalid class type: %s\n"	*(char)
,	O
varspec	array(char)
+	O
s	int
+	O
i	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
s	int
+=	O
i	int
+	O
1	int
;	O
while	O
(	O
varspec	array(char)
[	O
s	int
]	O
==	O
' '	O
)	O
s	int
++	O
;	O
if	O
(	O
n	int
>	O
dap_maxbars	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(groupparse) too many classes: %d\n"	*(char)
,	O
n	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(groupparse) grouping variable must be of type double: %s\n"	*(char)
,	O
varname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(groupparse) missing number of groups for %s\n"	*(char)
,	O
varname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
nvar	int
++	O
;	O
}	O
else	O
if	O
(	O
number	int
<	O
0	int
)	O
{	O
if	O
(	O
varname	*(char)
[	O
0	int
]	O
==	O
'-'	O
)	O
classtype	array(int)
[	O
0	int
]	O
|=	O
GRPDESC	int
;	O
if	O
(	O
varname	*(char)
[	O
1	int
]	O
==	O
'0'	O
)	O
classtype	array(int)
[	O
0	int
]	O
|=	O
GRP0	int
;	O
}	O
else	O
if	O
(	O
!	O
nvar	int
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
varname	*(char)
,	O
"#"	*(char)
)	O
)	O
number	int
=	O
GRPNUMBER	O
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
varname	*(char)
,	O
"/"	*(char)
)	O
)	O
number	int
=	O
GRPFRACTION	O
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
varname	*(char)
,	O
"%"	*(char)
)	O
)	O
number	int
=	O
GRPPERCENT	O
;	O
classtype	array(int)
[	O
0	int
]	O
=	O
0	int
;	O
nvar	int
++	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(groupparse) unknown variable: %s\n"	*(char)
,	O
varname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
while	O
(	O
varspec	array(char)
[	O
s	int
]	O
==	O
' '	O
)	O
s	int
++	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
varname	*(char)
,	O
""	*(char)
)	O
;	O
if	O
(	O
number	int
<	O
0	int
)	O
return	O
-	O
4	int
*	O
nvar	int
+	O
number	int
;	O
return	O
nvar	int
;	O
}	O
static	O
void	O
getpoints	(*(*(double)),int,*(int),int,*(*(double)))->(void)
(	O
double	O
*	O
*	O
numval	*(*(double))
,	O
int	O
nonum	int
,	O
int	O
*	O
ctype	*(int)
,	O
int	O
nobs	int
,	O
double	O
*	O
*	O
point	*(*(double))
)	O
{	O
int	O
v	int
;	O
double	O
width	double
;	O
int	O
p	double
;	O
int	O
index	(*(char),int)->(*(char))
;	O
double	O
excess	*(int)
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nonum	int
;	O
v	int
++	O
)	O
{	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
(	O
void	O
*	O
)	O
numval	*(*(double))
[	O
v	int
]	O
,	O
(	O
size_t	long
)	O
nobs	int
,	O
(	O
size_t	long
)	O
sizeof	O
(	O
double	O
)	O
,	O
cmp	*(()->(int))
)	O
;	O
if	O
(	O
ctype	*(int)
[	O
v	int
]	O
<	O
0	int
)	O
{	O
width	double
=	O
(	O
numval	*(*(double))
[	O
v	int
]	O
[	O
nobs	int
-	O
1	int
]	O
-	O
numval	*(*(double))
[	O
v	int
]	O
[	O
0	int
]	O
)	O
/	O
(	O
(	O
double	O
)	O
-	O
ctype	*(int)
[	O
v	int
]	O
)	O
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
-	O
ctype	*(int)
[	O
v	int
]	O
;	O
p	double
++	O
)	O
point	*(*(double))
[	O
v	int
]	O
[	O
p	double
]	O
=	O
numval	*(*(double))
[	O
v	int
]	O
[	O
0	int
]	O
+	O
(	O
(	O
double	O
)	O
p	double
)	O
*	O
width	double
;	O
point	*(*(double))
[	O
v	int
]	O
[	O
p	double
]	O
=	O
numval	*(*(double))
[	O
v	int
]	O
[	O
nobs	int
-	O
1	int
]	O
;	O
}	O
else	O
if	O
(	O
ctype	*(int)
[	O
v	int
]	O
>	O
0	int
)	O
{	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
ctype	*(int)
[	O
v	int
]	O
;	O
p	double
++	O
)	O
{	O
index	(*(char),int)->(*(char))
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
(	O
(	O
double	O
)	O
(	O
p	double
*	O
nobs	int
)	O
)	O
/	O
(	O
(	O
double	O
)	O
ctype	*(int)
[	O
v	int
]	O
)	O
)	O
;	O
excess	*(int)
=	O
(	O
(	O
double	O
)	O
(	O
p	double
*	O
nobs	int
)	O
)	O
/	O
(	O
(	O
double	O
)	O
ctype	*(int)
[	O
v	int
]	O
)	O
-	O
(	O
double	O
)	O
index	(*(char),int)->(*(char))
;	O
if	O
(	O
excess	*(int)
>	O
0.0	int
&&	O
index	(*(char),int)->(*(char))
<	O
nobs	int
-	O
1	int
)	O
point	*(*(double))
[	O
v	int
]	O
[	O
p	double
]	O
=	O
0.5	int
*	O
(	O
numval	*(*(double))
[	O
v	int
]	O
[	O
index	(*(char),int)->(*(char))
]	O
+	O
numval	*(*(double))
[	O
v	int
]	O
[	O
index	(*(char),int)->(*(char))
+	O
1	int
]	O
)	O
;	O
else	O
point	*(*(double))
[	O
v	int
]	O
[	O
p	double
]	O
=	O
numval	*(*(double))
[	O
v	int
]	O
[	O
(	O
int	O
)	O
rint	(double)->(double)
(	O
(	O
(	O
double	O
)	O
(	O
p	double
*	O
nobs	int
)	O
)	O
/	O
(	O
(	O
double	O
)	O
ctype	*(int)
[	O
v	int
]	O
)	O
)	O
]	O
;	O
}	O
point	*(*(double))
[	O
v	int
]	O
[	O
p	double
]	O
=	O
numval	*(*(double))
[	O
v	int
]	O
[	O
nobs	int
-	O
1	int
]	O
;	O
}	O
}	O
}	O
void	O
group	(array(char),array(char),array(char))->(void)
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
varspec	array(char)
,	O
char	O
*	O
marks	array(char)
)	O
{	O
char	O
*	O
outname	*(char)
;	O
int	O
*	O
markv	array(int)
;	O
int	O
nmark	int
;	O
int	O
*	O
varv	array(int)
;	O
int	O
*	O
ctype	*(int)
;	O
double	O
*	O
nummem	*(double)
;	O
double	O
*	O
*	O
numval	*(*(double))
;	O
int	O
nvar	int
;	O
int	O
number	int
;	O
int	O
v	int
;	O
char	O
*	O
grpname	*(char)
;	O
int	O
*	O
grpv	*(int)
;	O
int	O
nobs	int
;	O
int	O
nnan	int
;	O
int	O
allgood	int
;	O
double	O
*	O
ptmem	*(double)
;	O
double	O
*	O
*	O
point	*(*(double))
;	O
double	O
dnobs	double
;	O
double	O
count	double
;	O
double	O
countinc	double
;	O
int	O
p	double
;	O
int	O
more	int
;	O
if	O
(	O
!	O
fname	array(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(group) No dataset name given.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
outname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
+	O
5	int
,	O
""	*(char)
)	O
;	O
dap_suffix	(array(char),array(char),array(char))->(void)
(	O
outname	*(char)
,	O
fname	array(char)
,	O
".grp"	*(char)
)	O
;	O
grpname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_namelen	int
+	O
3	int
,	O
""	*(char)
)	O
;	O
markv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
varv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
ctype	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
inset	(array(char))->(void)
(	O
fname	array(char)
)	O
;	O
nmark	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
marks	array(char)
,	O
markv	array(int)
,	O
dap_maxvar	int
)	O
;	O
nvar	int
=	O
groupparse	(*(char),array(int),array(int))->(int)
(	O
varspec	array(char)
,	O
varv	array(int)
,	O
ctype	*(int)
)	O
;	O
if	O
(	O
nvar	int
<	O
0	int
)	O
{	O
number	int
=	O
-	O
(	O
(	O
-	O
nvar	int
)	O
%	O
4	int
)	O
;	O
nvar	int
=	O
-	O
(	O
nvar	int
-	O
number	int
)	O
/	O
4	int
;	O
}	O
else	O
number	int
=	O
0	int
;	O
grpv	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
(	O
number	int
?	O
1	int
:	O
nvar	int
)	O
,	O
""	*(char)
)	O
;	O
if	O
(	O
!	O
number	int
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
grpname	*(char)
,	O
"_"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
grpname	*(char)
+	O
1	int
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
grpname	*(char)
[	O
dap_namelen	int
]	O
=	O
'\0'	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
grpname	*(char)
,	O
" -1"	*(char)
)	O
;	O
grpv	*(int)
[	O
v	int
]	O
=	O
dap_vd	(array(char),int)->(int)
(	O
grpname	*(char)
,	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
grpv	*(int)
[	O
0	int
]	O
=	O
dap_vd	(array(char),int)->(int)
(	O
"_N_ -1"	*(char)
,	O
0	int
)	O
;	O
varv	array(int)
[	O
0	int
]	O
=	O
grpv	*(int)
[	O
0	int
]	O
;	O
}	O
outset	(array(char),array(char))->(void)
(	O
outname	*(char)
,	O
""	*(char)
)	O
;	O
nummem	*(double)
=	O
NULL	O
;	O
numval	*(*(double))
=	O
NULL	O
;	O
if	O
(	O
!	O
number	int
)	O
{	O
nummem	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
*	O
dap_maxval	int
,	O
"dap_maxval"	*(char)
)	O
;	O
numval	*(*(double))
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
nvar	int
*	O
dap_maxval	int
*	O
sizeof	O
(	O
double	O
*	O
)	O
,	O
"dap_maxval"	*(char)
)	O
;	O
ptmem	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
*	O
(	O
dap_maxbars	int
+	O
1	int
)	O
,	O
"dap_maxbars"	*(char)
)	O
;	O
point	*(*(double))
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
numval	*(*(double))
[	O
v	int
]	O
=	O
nummem	*(double)
+	O
v	int
*	O
dap_maxval	int
;	O
point	*(*(double))
[	O
v	int
]	O
=	O
ptmem	*(double)
+	O
v	int
*	O
(	O
dap_maxbars	int
+	O
1	int
)	O
;	O
}	O
}	O
for	O
(	O
dap_mark	()->(void)
(	O
)	O
,	O
nobs	int
=	O
0	int
,	O
nnan	int
=	O
0	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
)	O
{	O
more	int
=	O
step	()->(int)
(	O
)	O
;	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
markv	array(int)
,	O
nmark	int
)	O
)	O
{	O
if	O
(	O
!	O
number	int
)	O
getpoints	(*(*(double)),int,*(int),int,*(*(double)))->(void)
(	O
numval	*(*(double))
,	O
nvar	int
,	O
ctype	*(int)
,	O
nobs	int
,	O
point	*(*(double))
)	O
;	O
dnobs	double
=	O
(	O
double	O
)	O
nobs	int
;	O
dap_rewind	()->(void)
(	O
)	O
;	O
count	double
=	O
1.0	int
;	O
countinc	double
=	O
1.0	int
;	O
if	O
(	O
nnan	int
>	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(group) %d NaNs\n"	*(char)
,	O
nnan	int
)	O
;	O
if	O
(	O
number	int
)	O
{	O
if	O
(	O
ctype	*(int)
[	O
0	int
]	O
&	O
GRP0	int
)	O
count	double
=	O
0.0	int
;	O
if	O
(	O
ctype	*(int)
[	O
0	int
]	O
&	O
GRPDESC	int
)	O
{	O
countinc	double
=	O
-	O
1.0	int
;	O
count	double
=	O
dnobs	double
-	O
1.0	int
+	O
count	double
;	O
}	O
}	O
for	O
(	O
;	O
step	()->(int)
(	O
)	O
&&	O
!	O
dap_newpart	(array(int),int)->(int)
(	O
markv	array(int)
,	O
nmark	int
)	O
;	O
)	O
{	O
if	O
(	O
number	int
)	O
{	O
for	O
(	O
v	int
=	O
1	int
,	O
allgood	int
=	O
1	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
finite	(double)->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
)	O
{	O
allgood	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
allgood	int
)	O
{	O
switch	O
(	O
number	int
)	O
{	O
case	O
GRPNUMBER	O
:	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
grpv	*(int)
[	O
0	int
]	O
]	O
=	O
count	double
;	O
break	O
;	O
case	O
GRPFRACTION	O
:	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
grpv	*(int)
[	O
0	int
]	O
]	O
=	O
count	double
/	O
dnobs	double
;	O
break	O
;	O
case	O
GRPPERCENT	O
:	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
grpv	*(int)
[	O
0	int
]	O
]	O
=	O
100.0	int
*	O
count	double
/	O
dnobs	double
;	O
break	O
;	O
}	O
count	double
+=	O
countinc	double
;	O
}	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
grpv	*(int)
[	O
0	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
else	O
{	O
for	O
(	O
v	int
=	O
0	int
,	O
allgood	int
=	O
1	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
finite	(double)->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
)	O
{	O
allgood	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
allgood	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
for	O
(	O
p	double
=	O
1	int
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
>	O
point	*(*(double))
[	O
v	int
]	O
[	O
p	double
]	O
;	O
p	double
++	O
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
grpv	*(int)
[	O
v	int
]	O
]	O
=	O
(	O
double	O
)	O
p	double
;	O
}	O
}	O
else	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
grpv	*(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
dap_mark	()->(void)
(	O
)	O
;	O
}	O
nobs	int
=	O
0	int
;	O
nnan	int
=	O
0	int
;	O
}	O
if	O
(	O
number	int
)	O
{	O
for	O
(	O
v	int
=	O
1	int
,	O
allgood	int
=	O
1	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
finite	(double)->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
)	O
{	O
allgood	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
allgood	int
)	O
nobs	int
++	O
;	O
else	O
nnan	int
++	O
;	O
}	O
else	O
{	O
if	O
(	O
nobs	int
<	O
dap_maxval	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
,	O
allgood	int
=	O
1	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
finite	(double)->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
)	O
{	O
allgood	int
=	O
0	int
;	O
break	O
;	O
}	O
numval	*(*(double))
[	O
v	int
]	O
[	O
nobs	int
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
;	O
}	O
if	O
(	O
allgood	int
)	O
nobs	int
++	O
;	O
else	O
nnan	int
++	O
;	O
}	O
else	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(group) too many data.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
number	int
)	O
{	O
dap_free	(*(void),*(char))->(void)
(	O
nummem	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
numval	*(*(double))
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
ptmem	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
point	*(*(double))
,	O
""	*(char)
)	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
outname	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
grpname	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
grpv	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
markv	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
varv	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
ctype	*(int)
,	O
""	*(char)
)	O
;	O
}	O
static	O
void	O
freq1	(*(int),int,double,double,*(int),int,int)->(void)
(	O
int	O
*	O
varv	array(int)
,	O
int	O
nvar	int
,	O
double	O
count	double
,	O
double	O
sumcount	double
,	O
int	O
*	O
statv	*(int)
,	O
int	O
typen	int
,	O
int	O
celln	int
)	O
{	O
dap_swap	()->(void)
(	O
)	O
;	O
if	O
(	O
statv	*(int)
[	O
FREQCNT	int
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"COUNT"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
celln	int
]	O
=	O
count	double
;	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
statv	*(int)
[	O
FREQPCT	int
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"PERCENT"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
celln	int
]	O
=	O
100.0	int
*	O
count	double
/	O
sumcount	double
;	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
statv	*(int)
[	O
FREQFRA	int
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"FRACTION"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
celln	int
]	O
=	O
count	double
/	O
sumcount	double
;	O
output	()->(void)
(	O
)	O
;	O
}	O
dap_swap	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
statparse	(*(char),*(int))->(void)
(	O
char	O
*	O
stats	array(int)
,	O
int	O
*	O
statv	*(int)
)	O
{	O
int	O
s	int
;	O
int	O
i	int
;	O
char	O
*	O
stat	*(char)
;	O
stat	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_namelen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
NFREQSTAT	int
;	O
s	int
++	O
)	O
statv	*(int)
[	O
s	int
]	O
=	O
0	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
stats	array(int)
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
while	O
(	O
stats	array(int)
[	O
s	int
]	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
stats	array(int)
[	O
s	int
+	O
i	int
]	O
&&	O
stats	array(int)
[	O
s	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
stat	*(char)
[	O
i	int
]	O
=	O
stats	array(int)
[	O
s	int
+	O
i	int
]	O
;	O
else	O
{	O
stat	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(statparse) Statistic name too long: %s\n"	*(char)
,	O
stat	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
stat	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
s	int
+=	O
i	int
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	*(char)
,	O
"COUNT"	*(char)
)	O
)	O
statv	*(int)
[	O
FREQCNT	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	*(char)
,	O
"PERCENT"	*(char)
)	O
)	O
statv	*(int)
[	O
FREQPCT	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	*(char)
,	O
"ROWPERC"	*(char)
)	O
)	O
statv	*(int)
[	O
FREQROW	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	*(char)
,	O
"COLPERC"	*(char)
)	O
)	O
statv	*(int)
[	O
FREQCOL	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	*(char)
,	O
"FRACTION"	*(char)
)	O
)	O
statv	*(int)
[	O
FREQFRA	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	*(char)
,	O
"EXPECTED"	*(char)
)	O
)	O
statv	*(int)
[	O
FREQEXP	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	*(char)
,	O
"CHISQ"	*(char)
)	O
)	O
statv	*(int)
[	O
FREQCHISQ	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	*(char)
,	O
"ODDSRAT"	*(char)
)	O
)	O
statv	*(int)
[	O
FREQODDRAT	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	*(char)
,	O
"ORDINAL"	*(char)
)	O
)	O
statv	*(int)
[	O
FREQORD	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	*(char)
,	O
"FISHER"	*(char)
)	O
)	O
statv	*(int)
[	O
FREQFISHER	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	*(char)
,	O
"CMH"	*(char)
)	O
)	O
statv	*(int)
[	O
FREQCMH	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	*(char)
,	O
"PAIR"	*(char)
)	O
)	O
statv	*(int)
[	O
FREQPAIR	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	*(char)
,	O
"NOMINAL"	*(char)
)	O
)	O
statv	*(int)
[	O
FREQNOM	int
]	O
=	O
1	int
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(statparse) Invalid statistic name: %s\n"	*(char)
,	O
stat	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
while	O
(	O
stats	array(int)
[	O
s	int
]	O
==	O
' '	O
)	O
s	int
++	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
stat	*(char)
,	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
findlev	(int,*(*(char)),*(int))->(int)
(	O
int	O
v	int
,	O
char	O
*	O
*	O
level	double
,	O
int	O
*	O
nlevels	*(int)
)	O
{	O
int	O
l	int
;	O
static	O
char	O
*	O
str	array(char)
=	O
NULL	O
;	O
char	O
*	O
s	int
;	O
if	O
(	O
!	O
str	array(char)
)	O
str	array(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
21	int
,	O
""	*(char)
)	O
;	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
v	int
]	O
>	O
0	int
)	O
s	int
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
;	O
else	O
{	O
s	int
=	O
str	array(char)
;	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
v	int
]	O
==	O
INT	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
str	array(char)
,	O
"%d"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_int	*(int)
[	O
v	int
]	O
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
str	array(char)
,	O
"%g"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
v	int
]	O
)	O
;	O
}	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
*	O
nlevels	*(int)
;	O
l	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
s	int
,	O
level	double
[	O
l	int
]	O
)	O
)	O
return	O
l	int
;	O
}	O
if	O
(	O
*	O
nlevels	*(int)
<	O
dap_maxlev	int
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
level	double
[	O
l	int
]	O
,	O
s	int
)	O
;	O
(	O
*	O
nlevels	*(int)
)	O
++	O
;	O
return	O
l	int
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(findlev) Too many levels at: %s\n"	*(char)
,	O
s	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
tabentry	(*(int),*(*(double)),array(*(*(char))),array(int),double)->(void)
(	O
int	O
*	O
varv	array(int)
,	O
double	O
*	O
*	O
tab	*(*(double))
,	O
char	O
*	O
*	O
level	double
[	O
2	int
]	O
,	O
int	O
nlevels	*(int)
[	O
2	int
]	O
,	O
double	O
count	double
)	O
{	O
dap_swap	()->(void)
(	O
)	O
;	O
tab	*(*(double))
[	O
findlev	(int,*(*(char)),*(int))->(int)
(	O
varv	array(int)
[	O
0	int
]	O
,	O
level	double
[	O
0	int
]	O
,	O
nlevels	*(int)
)	O
]	O
[	O
findlev	(int,*(*(char)),*(int))->(int)
(	O
varv	array(int)
[	O
1	int
]	O
,	O
level	double
[	O
1	int
]	O
,	O
nlevels	*(int)
+	O
1	int
)	O
]	O
=	O
count	double
;	O
dap_swap	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
valcpy	(int,*(char))->(void)
(	O
int	O
v	int
,	O
char	O
*	O
val	*(*(*(double)))
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
v	int
]	O
>	O
0	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
v	int
]	O
,	O
val	*(*(*(double)))
)	O
;	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
v	int
]	O
==	O
INT	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_int	*(int)
[	O
v	int
]	O
=	O
atoi	(*(char))->(int)
(	O
val	*(*(*(double)))
)	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
v	int
]	O
=	O
atof	(*(char))->(double)
(	O
val	*(*(*(double)))
)	O
;	O
}	O
static	O
void	O
freq2	(*(*(double)),array(*(*(char))),array(int),*(int),*(int),int,*(int),int,int)->(void)
(	O
double	O
*	O
*	O
tab	*(*(double))
,	O
char	O
*	O
*	O
level	double
[	O
2	int
]	O
,	O
int	O
nlevels	*(int)
[	O
2	int
]	O
,	O
int	O
*	O
statv	*(int)
,	O
int	O
*	O
markv	array(int)
,	O
int	O
nmark	int
,	O
int	O
*	O
varv	array(int)
,	O
int	O
typen	int
,	O
int	O
celln	int
)	O
{	O
int	O
v	int
;	O
int	O
l	int
;	O
double	O
*	O
expmem	*(double)
;	O
double	O
*	O
*	O
expect	*(*(double))
;	O
double	O
*	O
rowsum	*(double)
;	O
double	O
*	O
colsum	*(double)
;	O
double	O
sum	*(double)
;	O
double	O
*	O
amem	*(double)
;	O
double	O
*	O
*	O
a	double
;	O
double	O
*	O
dmem	*(double)
;	O
double	O
*	O
*	O
d	*(*(double))
;	O
double	O
p	double
,	O
q	double
;	O
double	O
tmp1	double
,	O
tmp2	double
,	O
tmp3	double
,	O
tmp4	double
;	O
double	O
w	int
;	O
double	O
t	double
;	O
double	O
var	double
;	O
int	O
r	double
,	O
c	int
;	O
double	O
diff	double
;	O
double	O
chisq	double
;	O
int	O
rr	int
,	O
cc	int
;	O
double	O
upleft	double
,	O
dnleft	double
;	O
double	O
denom	double
,	O
prob	double
,	O
oneprob	double
,	O
othprob	double
;	O
double	O
hx	double
,	O
hy	double
,	O
hxy	double
;	O
double	O
uv	double
;	O
sum	*(double)
=	O
0.0	int
;	O
oneprob	double
=	O
0.0	int
;	O
expmem	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxlev	int
*	O
dap_maxlev	int
,	O
""	*(char)
)	O
;	O
expect	*(*(double))
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
dap_maxlev	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
dap_maxlev	int
;	O
l	int
++	O
)	O
expect	*(*(double))
[	O
l	int
]	O
=	O
expmem	*(double)
+	O
l	int
*	O
dap_maxlev	int
;	O
rowsum	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxlev	int
,	O
""	*(char)
)	O
;	O
colsum	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxlev	int
,	O
""	*(char)
)	O
;	O
amem	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxlev	int
*	O
dap_maxlev	int
,	O
""	*(char)
)	O
;	O
dmem	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxlev	int
*	O
dap_maxlev	int
,	O
""	*(char)
)	O
;	O
a	double
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
dap_maxlev	int
,	O
""	*(char)
)	O
;	O
d	*(*(double))
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
dap_maxlev	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
dap_maxlev	int
;	O
l	int
++	O
)	O
{	O
a	double
[	O
l	int
]	O
=	O
amem	*(double)
+	O
l	int
*	O
dap_maxlev	int
;	O
d	*(*(double))
[	O
l	int
]	O
=	O
dmem	*(double)
+	O
l	int
*	O
dap_maxlev	int
;	O
}	O
dap_swap	()->(void)
(	O
)	O
;	O
if	O
(	O
statv	*(int)
[	O
FREQCHISQ	int
]	O
||	O
statv	*(int)
[	O
FREQODDRAT	int
]	O
||	O
statv	*(int)
[	O
FREQORD	int
]	O
||	O
statv	*(int)
[	O
FREQFISHER	int
]	O
||	O
statv	*(int)
[	O
FREQPAIR	int
]	O
||	O
statv	*(int)
[	O
FREQNOM	int
]	O
)	O
{	O
dap_head	(array(int),int)->(void)
(	O
markv	array(int)
,	O
nmark	int
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Variable: Levels\n"	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"----------------\n"	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
2	int
;	O
v	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s:"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
nlevels	*(int)
[	O
v	int
]	O
;	O
l	int
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %s"	*(char)
,	O
level	double
[	O
v	int
]	O
[	O
l	int
]	O
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
statv	*(int)
[	O
FREQEXP	int
]	O
||	O
statv	*(int)
[	O
FREQCHISQ	int
]	O
||	O
statv	*(int)
[	O
FREQORD	int
]	O
||	O
statv	*(int)
[	O
FREQFISHER	int
]	O
||	O
statv	*(int)
[	O
FREQROW	int
]	O
||	O
statv	*(int)
[	O
FREQCOL	int
]	O
||	O
statv	*(int)
[	O
FREQPAIR	int
]	O
||	O
statv	*(int)
[	O
FREQNOM	int
]	O
)	O
{	O
for	O
(	O
r	double
=	O
0	int
,	O
sum	*(double)
=	O
0.0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
{	O
rowsum	*(double)
[	O
r	double
]	O
=	O
0.0	int
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
rowsum	*(double)
[	O
r	double
]	O
+=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
;	O
sum	*(double)
+=	O
rowsum	*(double)
[	O
r	double
]	O
;	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
colsum	*(double)
[	O
c	int
]	O
=	O
0.0	int
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
colsum	*(double)
[	O
c	int
]	O
+=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
;	O
}	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
expect	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
=	O
rowsum	*(double)
[	O
r	double
]	O
*	O
colsum	*(double)
[	O
c	int
]	O
/	O
sum	*(double)
;	O
}	O
if	O
(	O
statv	*(int)
[	O
FREQEXP	int
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"EXPECTED"	*(char)
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
{	O
valcpy	(int,*(char))->(void)
(	O
varv	array(int)
[	O
0	int
]	O
,	O
level	double
[	O
0	int
]	O
[	O
r	double
]	O
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
valcpy	(int,*(char))->(void)
(	O
varv	array(int)
[	O
1	int
]	O
,	O
level	double
[	O
1	int
]	O
[	O
c	int
]	O
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
celln	int
]	O
=	O
expect	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
statv	*(int)
[	O
FREQROW	int
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"ROWPERC"	*(char)
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
{	O
valcpy	(int,*(char))->(void)
(	O
varv	array(int)
[	O
0	int
]	O
,	O
level	double
[	O
0	int
]	O
[	O
r	double
]	O
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
valcpy	(int,*(char))->(void)
(	O
varv	array(int)
[	O
1	int
]	O
,	O
level	double
[	O
1	int
]	O
[	O
c	int
]	O
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
celln	int
]	O
=	O
100.0	int
*	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
/	O
rowsum	*(double)
[	O
r	double
]	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
statv	*(int)
[	O
FREQCOL	int
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"COLPERC"	*(char)
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
{	O
valcpy	(int,*(char))->(void)
(	O
varv	array(int)
[	O
0	int
]	O
,	O
level	double
[	O
0	int
]	O
[	O
r	double
]	O
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
valcpy	(int,*(char))->(void)
(	O
varv	array(int)
[	O
1	int
]	O
,	O
level	double
[	O
1	int
]	O
[	O
c	int
]	O
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
celln	int
]	O
=	O
100.0	int
*	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
/	O
colsum	*(double)
[	O
c	int
]	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
statv	*(int)
[	O
FREQCHISQ	int
]	O
)	O
{	O
for	O
(	O
r	double
=	O
0	int
,	O
chisq	double
=	O
0.0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
diff	double
=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
-	O
expect	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
;	O
chisq	double
+=	O
diff	double
*	O
diff	double
/	O
expect	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Chisq0[%d] = %g, Prob[Chisq > Chisq0] = %.5f\n"	*(char)
,	O
(	O
nlevels	*(int)
[	O
0	int
]	O
-	O
1	int
)	O
*	O
(	O
nlevels	*(int)
[	O
1	int
]	O
-	O
1	int
)	O
,	O
chisq	double
,	O
ceil	(double)->(double)
(	O
100000.0	int
*	O
probchisq	(double,int)->(double)
(	O
chisq	double
,	O
(	O
nlevels	*(int)
[	O
0	int
]	O
-	O
1	int
)	O
*	O
(	O
nlevels	*(int)
[	O
1	int
]	O
-	O
1	int
)	O
)	O
)	O
/	O
100000.0	int
)	O
;	O
}	O
if	O
(	O
statv	*(int)
[	O
FREQODDRAT	int
]	O
)	O
{	O
if	O
(	O
nlevels	*(int)
[	O
0	int
]	O
==	O
2	int
&&	O
nlevels	*(int)
[	O
1	int
]	O
==	O
2	int
)	O
{	O
tmp1	double
=	O
(	O
tab	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
+	O
0.5	int
)	O
*	O
(	O
tab	*(*(double))
[	O
1	int
]	O
[	O
1	int
]	O
+	O
0.5	int
)	O
/	O
(	O
(	O
tab	*(*(double))
[	O
0	int
]	O
[	O
1	int
]	O
+	O
0.5	int
)	O
*	O
(	O
tab	*(*(double))
[	O
1	int
]	O
[	O
0	int
]	O
+	O
0.5	int
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Odds ratio = %g\nlog(Odds ratio) = %g, ASE = %g\n"	*(char)
,	O
tmp1	double
,	O
log	(double)->(double)
(	O
tmp1	double
)	O
,	O
sqrt	(double)->(double)
(	O
1.0	int
/	O
(	O
tab	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
+	O
0.5	int
)	O
+	O
1.0	int
/	O
(	O
tab	*(*(double))
[	O
1	int
]	O
[	O
0	int
]	O
+	O
0.5	int
)	O
+	O
1.0	int
/	O
(	O
tab	*(*(double))
[	O
0	int
]	O
[	O
1	int
]	O
+	O
0.5	int
)	O
+	O
1.0	int
/	O
(	O
tab	*(*(double))
[	O
1	int
]	O
[	O
1	int
]	O
+	O
0.5	int
)	O
)	O
)	O
;	O
}	O
else	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(freq2) Odds ratio computed for 2 x 2 tables only.\n"	*(char)
,	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
statv	*(int)
[	O
FREQFISHER	int
]	O
)	O
{	O
if	O
(	O
nlevels	*(int)
[	O
0	int
]	O
==	O
2	int
&&	O
nlevels	*(int)
[	O
1	int
]	O
==	O
2	int
)	O
{	O
if	O
(	O
tab	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
>=	O
expect	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
)	O
{	O
denom	double
=	O
dap_bincoeff	(double,double)->(double)
(	O
sum	*(double)
,	O
colsum	*(double)
[	O
0	int
]	O
)	O
;	O
for	O
(	O
upleft	double
=	O
tab	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
,	O
dnleft	double
=	O
tab	*(*(double))
[	O
1	int
]	O
[	O
0	int
]	O
,	O
prob	double
=	O
0.0	int
;	O
upleft	double
<=	O
rowsum	*(double)
[	O
0	int
]	O
&&	O
upleft	double
<=	O
colsum	*(double)
[	O
0	int
]	O
;	O
upleft	double
+=	O
1.0	int
,	O
dnleft	double
-=	O
1.0	int
)	O
{	O
if	O
(	O
prob	double
==	O
0.0	int
)	O
{	O
oneprob	double
=	O
dap_bincoeff	(double,double)->(double)
(	O
rowsum	*(double)
[	O
0	int
]	O
,	O
upleft	double
)	O
*	O
dap_bincoeff	(double,double)->(double)
(	O
rowsum	*(double)
[	O
1	int
]	O
,	O
dnleft	double
)	O
;	O
prob	double
=	O
oneprob	double
;	O
}	O
else	O
prob	double
+=	O
dap_bincoeff	(double,double)->(double)
(	O
rowsum	*(double)
[	O
0	int
]	O
,	O
upleft	double
)	O
*	O
dap_bincoeff	(double,double)->(double)
(	O
rowsum	*(double)
[	O
1	int
]	O
,	O
dnleft	double
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Fisher's exact test: right     %g\n"	*(char)
,	O
prob	double
/	O
denom	double
)	O
;	O
for	O
(	O
upleft	double
=	O
ceil	(double)->(double)
(	O
expect	*(*(double))
[	O
1	int
]	O
[	O
0	int
]	O
)	O
,	O
dnleft	double
=	O
colsum	*(double)
[	O
0	int
]	O
-	O
upleft	double
;	O
upleft	double
<=	O
rowsum	*(double)
[	O
1	int
]	O
&&	O
upleft	double
<=	O
colsum	*(double)
[	O
0	int
]	O
;	O
upleft	double
+=	O
1.0	int
,	O
dnleft	double
-=	O
1.0	int
)	O
{	O
othprob	double
=	O
dap_bincoeff	(double,double)->(double)
(	O
rowsum	*(double)
[	O
1	int
]	O
,	O
upleft	double
)	O
*	O
dap_bincoeff	(double,double)->(double)
(	O
rowsum	*(double)
[	O
0	int
]	O
,	O
dnleft	double
)	O
;	O
if	O
(	O
othprob	double
<=	O
oneprob	double
)	O
prob	double
+=	O
othprob	double
;	O
}	O
if	O
(	O
tab	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
==	O
expect	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
)	O
prob	double
=	O
1.0	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"                     2-tailed  %g\n"	*(char)
,	O
prob	double
/	O
denom	double
)	O
;	O
}	O
if	O
(	O
tab	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
<=	O
expect	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
)	O
{	O
denom	double
=	O
dap_bincoeff	(double,double)->(double)
(	O
sum	*(double)
,	O
colsum	*(double)
[	O
1	int
]	O
)	O
;	O
for	O
(	O
upleft	double
=	O
tab	*(*(double))
[	O
1	int
]	O
[	O
0	int
]	O
,	O
dnleft	double
=	O
tab	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
,	O
prob	double
=	O
0.0	int
;	O
upleft	double
<=	O
rowsum	*(double)
[	O
1	int
]	O
&&	O
upleft	double
<=	O
colsum	*(double)
[	O
0	int
]	O
;	O
upleft	double
+=	O
1.0	int
,	O
dnleft	double
-=	O
1.0	int
)	O
{	O
if	O
(	O
prob	double
==	O
0.0	int
)	O
{	O
oneprob	double
=	O
dap_bincoeff	(double,double)->(double)
(	O
rowsum	*(double)
[	O
1	int
]	O
,	O
upleft	double
)	O
*	O
dap_bincoeff	(double,double)->(double)
(	O
rowsum	*(double)
[	O
0	int
]	O
,	O
dnleft	double
)	O
;	O
prob	double
=	O
oneprob	double
;	O
}	O
else	O
prob	double
+=	O
dap_bincoeff	(double,double)->(double)
(	O
rowsum	*(double)
[	O
1	int
]	O
,	O
upleft	double
)	O
*	O
dap_bincoeff	(double,double)->(double)
(	O
rowsum	*(double)
[	O
0	int
]	O
,	O
dnleft	double
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Fisher's exact test: left      %g\n"	*(char)
,	O
prob	double
/	O
denom	double
)	O
;	O
for	O
(	O
upleft	double
=	O
ceil	(double)->(double)
(	O
expect	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
)	O
,	O
dnleft	double
=	O
colsum	*(double)
[	O
0	int
]	O
-	O
upleft	double
;	O
upleft	double
<=	O
rowsum	*(double)
[	O
0	int
]	O
&&	O
upleft	double
<=	O
colsum	*(double)
[	O
0	int
]	O
;	O
upleft	double
+=	O
1.0	int
,	O
dnleft	double
-=	O
1.0	int
)	O
{	O
othprob	double
=	O
dap_bincoeff	(double,double)->(double)
(	O
rowsum	*(double)
[	O
0	int
]	O
,	O
upleft	double
)	O
*	O
dap_bincoeff	(double,double)->(double)
(	O
rowsum	*(double)
[	O
1	int
]	O
,	O
dnleft	double
)	O
;	O
if	O
(	O
othprob	double
<=	O
oneprob	double
)	O
prob	double
+=	O
othprob	double
;	O
}	O
if	O
(	O
tab	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
==	O
expect	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
)	O
prob	double
=	O
1.0	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"                     2-tailed  %g\n"	*(char)
,	O
prob	double
/	O
denom	double
)	O
;	O
}	O
}	O
else	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(freq2) Fisher's exact test computed for 2 x 2 tables only.\n"	*(char)
,	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
statv	*(int)
[	O
FREQORD	int
]	O
)	O
{	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
=	O
0.0	int
;	O
d	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
=	O
0.0	int
;	O
for	O
(	O
rr	int
=	O
0	int
;	O
rr	int
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
rr	int
++	O
)	O
for	O
(	O
cc	int
=	O
0	int
;	O
cc	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
cc	int
++	O
)	O
{	O
if	O
(	O
(	O
rr	int
<	O
r	double
&&	O
cc	int
<	O
c	int
)	O
||	O
(	O
rr	int
>	O
r	double
&&	O
cc	int
>	O
c	int
)	O
)	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
+=	O
tab	*(*(double))
[	O
rr	int
]	O
[	O
cc	int
]	O
;	O
else	O
if	O
(	O
(	O
rr	int
<	O
r	double
&&	O
cc	int
>	O
c	int
)	O
||	O
(	O
rr	int
>	O
r	double
&&	O
cc	int
<	O
c	int
)	O
)	O
d	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
+=	O
tab	*(*(double))
[	O
rr	int
]	O
[	O
cc	int
]	O
;	O
}	O
}	O
for	O
(	O
r	double
=	O
0	int
,	O
p	double
=	O
0.0	int
,	O
q	double
=	O
0.0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
p	double
+=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
*	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
;	O
q	double
+=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
*	O
d	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Statistic          Value   ASE\n"	*(char)
)	O
;	O
for	O
(	O
r	double
=	O
0	int
,	O
var	double
=	O
0.0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp1	double
=	O
q	double
*	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
-	O
p	double
*	O
d	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
;	O
var	double
+=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp1	double
*	O
tmp1	double
;	O
}	O
tmp2	double
=	O
p	double
+	O
q	double
;	O
tmp2	double
*=	O
tmp2	double
;	O
tmp2	double
*=	O
tmp2	double
;	O
var	double
*=	O
16.0	int
/	O
tmp2	double
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Gamma             %6.3f  %5.3f\n"	*(char)
,	O
(	O
p	double
-	O
q	double
)	O
/	O
(	O
p	double
+	O
q	double
)	O
,	O
sqrt	(double)->(double)
(	O
var	double
)	O
)	O
;	O
for	O
(	O
r	double
=	O
0	int
,	O
tmp1	double
=	O
sum	*(double)
*	O
sum	*(double)
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
tmp1	double
-=	O
rowsum	*(double)
[	O
r	double
]	O
*	O
rowsum	*(double)
[	O
r	double
]	O
;	O
for	O
(	O
c	int
=	O
0	int
,	O
tmp2	double
=	O
sum	*(double)
*	O
sum	*(double)
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
tmp2	double
-=	O
colsum	*(double)
[	O
c	int
]	O
*	O
colsum	*(double)
[	O
c	int
]	O
;	O
w	int
=	O
sqrt	(double)->(double)
(	O
tmp1	double
*	O
tmp2	double
)	O
;	O
t	double
=	O
(	O
p	double
-	O
q	double
)	O
/	O
w	int
;	O
for	O
(	O
r	double
=	O
0	int
,	O
var	double
=	O
0.0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp3	double
=	O
2.0	int
*	O
w	int
*	O
(	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
-	O
d	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
)	O
+	O
t	double
*	O
(	O
rowsum	*(double)
[	O
r	double
]	O
*	O
tmp2	double
+	O
colsum	*(double)
[	O
c	int
]	O
*	O
tmp1	double
)	O
;	O
var	double
+=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp3	double
*	O
tmp3	double
;	O
}	O
tmp4	double
=	O
tmp1	double
+	O
tmp2	double
;	O
var	double
=	O
(	O
var	double
-	O
sum	*(double)
*	O
sum	*(double)
*	O
sum	*(double)
*	O
t	double
*	O
t	double
*	O
tmp4	double
*	O
tmp4	double
)	O
/	O
(	O
w	int
*	O
w	int
*	O
w	int
*	O
w	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Kendall's Tau-b   %6.3f  %5.3f\n"	*(char)
,	O
t	double
,	O
sqrt	(double)->(double)
(	O
var	double
)	O
)	O
;	O
for	O
(	O
r	double
=	O
0	int
,	O
var	double
=	O
0.0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp3	double
=	O
tmp1	double
*	O
(	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
-	O
d	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
)	O
-	O
(	O
p	double
-	O
q	double
)	O
*	O
(	O
sum	*(double)
-	O
rowsum	*(double)
[	O
r	double
]	O
)	O
;	O
var	double
+=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp3	double
*	O
tmp3	double
;	O
}	O
var	double
*=	O
4.0	int
/	O
(	O
tmp1	double
*	O
tmp1	double
*	O
tmp1	double
*	O
tmp1	double
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Somers' D C|R     %6.3f  %5.3f\n"	*(char)
,	O
(	O
p	double
-	O
q	double
)	O
/	O
tmp1	double
,	O
sqrt	(double)->(double)
(	O
var	double
)	O
)	O
;	O
for	O
(	O
r	double
=	O
0	int
,	O
var	double
=	O
0.0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp3	double
=	O
tmp2	double
*	O
(	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
-	O
d	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
)	O
-	O
(	O
p	double
-	O
q	double
)	O
*	O
(	O
sum	*(double)
-	O
colsum	*(double)
[	O
c	int
]	O
)	O
;	O
var	double
+=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp3	double
*	O
tmp3	double
;	O
}	O
var	double
*=	O
4.0	int
/	O
(	O
tmp2	double
*	O
tmp2	double
*	O
tmp2	double
*	O
tmp2	double
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Somers' D R|C     %6.3f  %5.3f\n"	*(char)
,	O
(	O
p	double
-	O
q	double
)	O
/	O
tmp2	double
,	O
sqrt	(double)->(double)
(	O
var	double
)	O
)	O
;	O
}	O
if	O
(	O
statv	*(int)
[	O
FREQPAIR	int
]	O
)	O
{	O
if	O
(	O
nlevels	*(int)
[	O
0	int
]	O
!=	O
nlevels	*(int)
[	O
1	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(freq2) PAIR requires square table, table is %d x %d.\n"	*(char)
,	O
nlevels	*(int)
[	O
0	int
]	O
,	O
nlevels	*(int)
[	O
1	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
r	double
=	O
0	int
,	O
p	double
=	O
0.0	int
,	O
q	double
=	O
0.0	int
,	O
tmp1	double
=	O
0.0	int
,	O
tmp2	double
=	O
0.0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
{	O
p	double
+=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
r	double
]	O
;	O
q	double
+=	O
expect	*(*(double))
[	O
r	double
]	O
[	O
r	double
]	O
;	O
tmp1	double
+=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
r	double
]	O
*	O
(	O
rowsum	*(double)
[	O
r	double
]	O
+	O
colsum	*(double)
[	O
r	double
]	O
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp3	double
=	O
(	O
rowsum	*(double)
[	O
c	int
]	O
+	O
colsum	*(double)
[	O
r	double
]	O
)	O
;	O
tmp2	double
+=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp3	double
*	O
tmp3	double
;	O
}	O
}	O
p	double
/=	O
sum	*(double)
;	O
q	double
/=	O
sum	*(double)
;	O
tmp1	double
/=	O
sum	*(double)
*	O
sum	*(double)
;	O
tmp2	double
/=	O
sum	*(double)
*	O
sum	*(double)
*	O
sum	*(double)
;	O
tmp3	double
=	O
1.0	int
-	O
p	double
;	O
tmp4	double
=	O
1.0	int
-	O
q	double
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Statistic          Value   ASE\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Kappa             %6.3f  %5.3f\n"	*(char)
,	O
(	O
p	double
-	O
q	double
)	O
/	O
tmp4	double
,	O
sqrt	(double)->(double)
(	O
(	O
p	double
*	O
tmp3	double
/	O
(	O
tmp4	double
*	O
tmp4	double
)	O
+	O
2.0	int
*	O
tmp3	double
*	O
(	O
2.0	int
*	O
p	double
*	O
q	double
-	O
tmp1	double
)	O
/	O
(	O
tmp4	double
*	O
tmp4	double
*	O
tmp4	double
)	O
+	O
tmp3	double
*	O
tmp3	double
*	O
(	O
tmp2	double
-	O
4.0	int
*	O
q	double
*	O
q	double
)	O
/	O
(	O
tmp4	double
*	O
tmp4	double
*	O
tmp4	double
*	O
tmp4	double
)	O
)	O
/	O
sum	*(double)
)	O
)	O
;	O
}	O
if	O
(	O
statv	*(int)
[	O
FREQNOM	int
]	O
)	O
{	O
for	O
(	O
hx	double
=	O
0.0	int
,	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
hx	double
-=	O
rowsum	*(double)
[	O
r	double
]	O
*	O
log	(double)->(double)
(	O
rowsum	*(double)
[	O
r	double
]	O
/	O
sum	*(double)
)	O
;	O
hx	double
/=	O
sum	*(double)
;	O
for	O
(	O
hy	double
=	O
0.0	int
,	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
hy	double
-=	O
colsum	*(double)
[	O
c	int
]	O
*	O
log	(double)->(double)
(	O
colsum	*(double)
[	O
c	int
]	O
/	O
sum	*(double)
)	O
;	O
hy	double
/=	O
sum	*(double)
;	O
for	O
(	O
hxy	double
=	O
0.0	int
,	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
hxy	double
-=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
*	O
log	(double)->(double)
(	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
/	O
sum	*(double)
)	O
;	O
hxy	double
/=	O
sum	*(double)
;	O
uv	double
=	O
hx	double
+	O
hy	double
-	O
hxy	double
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Statistic              Value   ASE\n"	*(char)
)	O
;	O
for	O
(	O
var	double
=	O
0.0	int
,	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp1	double
=	O
hy	double
*	O
log	(double)->(double)
(	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
/	O
rowsum	*(double)
[	O
r	double
]	O
)	O
+	O
(	O
hx	double
-	O
hxy	double
)	O
*	O
log	(double)->(double)
(	O
colsum	*(double)
[	O
c	int
]	O
/	O
sum	*(double)
)	O
;	O
var	double
+=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp1	double
*	O
tmp1	double
;	O
}	O
var	double
=	O
sqrt	(double)->(double)
(	O
var	double
)	O
/	O
(	O
sum	*(double)
*	O
hy	double
*	O
hy	double
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Uncertainty C|R       %6.3f  %5.3f\n"	*(char)
,	O
uv	double
/	O
hy	double
,	O
var	double
)	O
;	O
for	O
(	O
var	double
=	O
0.0	int
,	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp1	double
=	O
hx	double
*	O
log	(double)->(double)
(	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
/	O
colsum	*(double)
[	O
c	int
]	O
)	O
+	O
(	O
hy	double
-	O
hxy	double
)	O
*	O
log	(double)->(double)
(	O
rowsum	*(double)
[	O
r	double
]	O
/	O
sum	*(double)
)	O
;	O
var	double
+=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp1	double
*	O
tmp1	double
;	O
}	O
var	double
=	O
sqrt	(double)->(double)
(	O
var	double
)	O
/	O
(	O
sum	*(double)
*	O
hx	double
*	O
hx	double
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Uncertainty R|C       %6.3f  %5.3f\n"	*(char)
,	O
uv	double
/	O
hx	double
,	O
var	double
)	O
;	O
for	O
(	O
var	double
=	O
0.0	int
,	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	*(int)
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	*(int)
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp1	double
=	O
hxy	double
*	O
log	(double)->(double)
(	O
rowsum	*(double)
[	O
r	double
]	O
*	O
colsum	*(double)
[	O
c	int
]	O
/	O
(	O
sum	*(double)
*	O
sum	*(double)
)	O
)	O
-	O
(	O
hx	double
+	O
hy	double
)	O
*	O
log	(double)->(double)
(	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
/	O
sum	*(double)
)	O
;	O
var	double
+=	O
tab	*(*(double))
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp1	double
*	O
tmp1	double
;	O
}	O
tmp2	double
=	O
hx	double
+	O
hy	double
;	O
var	double
=	O
2.0	int
*	O
sqrt	(double)->(double)
(	O
var	double
)	O
/	O
(	O
sum	*(double)
*	O
tmp2	double
*	O
tmp2	double
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Uncertainty Symmetric %6.3f  %5.3f\n"	*(char)
,	O
2.0	int
*	O
uv	double
/	O
(	O
hx	double
+	O
hy	double
)	O
,	O
var	double
)	O
;	O
}	O
dap_swap	()->(void)
(	O
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
expmem	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
expect	*(*(double))
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
rowsum	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
colsum	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
amem	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
a	double
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
dmem	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
d	*(*(double))
,	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
freqparse	(*(char),*(int),*(int))->(int)
(	O
char	O
*	O
varlist	array(char)
,	O
int	O
*	O
varv	array(int)
,	O
int	O
*	O
wt	*(int)
)	O
{	O
int	O
nvars	int
;	O
int	O
m	int
;	O
int	O
i	int
;	O
char	O
*	O
mname	*(char)
;	O
int	O
wtvar	*(int)
;	O
wt	*(int)
[	O
0	int
]	O
=	O
-	O
1	int
;	O
if	O
(	O
!	O
varlist	array(char)
)	O
return	O
0	int
;	O
mname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_namelen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
varlist	array(char)
[	O
m	int
]	O
==	O
' '	O
;	O
m	int
++	O
)	O
;	O
for	O
(	O
nvars	int
=	O
0	int
,	O
wtvar	*(int)
=	O
0	int
;	O
varlist	array(char)
[	O
m	int
]	O
;	O
)	O
{	O
if	O
(	O
varlist	array(char)
[	O
m	int
]	O
==	O
'*'	O
)	O
{	O
if	O
(	O
wtvar	*(int)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(freqparse) Only one weight variable allowed: %s\n"	*(char)
,	O
varlist	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
wtvar	*(int)
=	O
1	int
;	O
for	O
(	O
m	int
++	O
;	O
varlist	array(char)
[	O
m	int
]	O
==	O
' '	O
;	O
m	int
++	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
varlist	array(char)
[	O
m	int
+	O
i	int
]	O
&&	O
varlist	array(char)
[	O
m	int
+	O
i	int
]	O
!=	O
' '	O
&&	O
varlist	array(char)
[	O
m	int
+	O
i	int
]	O
!=	O
'*'	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
mname	*(char)
[	O
i	int
]	O
=	O
varlist	array(char)
[	O
m	int
+	O
i	int
]	O
;	O
else	O
{	O
mname	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_list) Variable name too long: %s\n"	*(char)
,	O
mname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
mname	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
wtvar	*(int)
)	O
{	O
if	O
(	O
(	O
wt	*(int)
[	O
0	int
]	O
=	O
dap_varnum	(array(char))->(int)
(	O
mname	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_list) Weight variable unknown: %s\n"	*(char)
,	O
mname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
varv	array(int)
[	O
nvars	int
++	O
]	O
=	O
dap_varnum	(array(char))->(int)
(	O
mname	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_list) Variable unknown: %s\n"	*(char)
,	O
mname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
m	int
+=	O
i	int
;	O
while	O
(	O
varlist	array(char)
[	O
m	int
]	O
==	O
' '	O
)	O
m	int
++	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
mname	*(char)
,	O
""	*(char)
)	O
;	O
return	O
nvars	int
;	O
}	O
static	O
void	O
cmh1	(*(*(double)),*(double),*(double))->(void)
(	O
double	O
*	O
*	O
tab	*(*(double))
,	O
double	O
*	O
cmh	*(double)
,	O
double	O
*	O
cmhvar	*(double)
)	O
{	O
double	O
rowsum	*(double)
[	O
2	int
]	O
;	O
double	O
colsum	*(double)
[	O
2	int
]	O
;	O
double	O
tabsum	double
;	O
rowsum	*(double)
[	O
0	int
]	O
=	O
tab	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
+	O
tab	*(*(double))
[	O
0	int
]	O
[	O
1	int
]	O
;	O
rowsum	*(double)
[	O
1	int
]	O
=	O
tab	*(*(double))
[	O
1	int
]	O
[	O
0	int
]	O
+	O
tab	*(*(double))
[	O
1	int
]	O
[	O
1	int
]	O
;	O
colsum	*(double)
[	O
0	int
]	O
=	O
tab	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
+	O
tab	*(*(double))
[	O
1	int
]	O
[	O
0	int
]	O
;	O
colsum	*(double)
[	O
1	int
]	O
=	O
tab	*(*(double))
[	O
0	int
]	O
[	O
1	int
]	O
+	O
tab	*(*(double))
[	O
1	int
]	O
[	O
1	int
]	O
;	O
tabsum	double
=	O
rowsum	*(double)
[	O
0	int
]	O
+	O
rowsum	*(double)
[	O
1	int
]	O
;	O
*	O
cmh	*(double)
+=	O
tab	*(*(double))
[	O
0	int
]	O
[	O
0	int
]	O
-	O
rowsum	*(double)
[	O
0	int
]	O
*	O
colsum	*(double)
[	O
0	int
]	O
/	O
tabsum	double
;	O
*	O
cmhvar	*(double)
+=	O
rowsum	*(double)
[	O
0	int
]	O
*	O
rowsum	*(double)
[	O
1	int
]	O
*	O
colsum	*(double)
[	O
0	int
]	O
*	O
colsum	*(double)
[	O
1	int
]	O
/	O
(	O
tabsum	double
*	O
tabsum	double
*	O
(	O
tabsum	double
-	O
1.0	int
)	O
)	O
;	O
}	O
static	O
void	O
printcmh	(double,double,*(int),int,*(int),int)->(void)
(	O
double	O
cmh	*(double)
,	O
double	O
cmhvar	*(double)
,	O
int	O
*	O
varv	array(int)
,	O
int	O
nvar	int
,	O
int	O
*	O
markv	array(int)
,	O
int	O
nmark	int
)	O
{	O
int	O
v	int
;	O
dap_swap	()->(void)
(	O
)	O
;	O
dap_head	(array(int),int)->(void)
(	O
markv	array(int)
,	O
nmark	int
)	O
;	O
cmh	*(double)
=	O
fabs	(double)->(double)
(	O
cmh	*(double)
)	O
-	O
0.5	int
;	O
cmh	*(double)
*=	O
cmh	*(double)
/	O
cmhvar	*(double)
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Cochran-Mantel-Haenszel test for %s x %s, stratified by"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
1	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
2	int
]	O
]	O
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
-	O
2	int
;	O
v	int
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %s"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"M0-squared = %g, Prob[M-squared > M0-squared] = %g\n"	*(char)
,	O
cmh	*(double)
,	O
rint	(double)->(double)
(	O
10000.0	int
*	O
probchisq	(double,int)->(double)
(	O
cmh	*(double)
,	O
1	int
)	O
)	O
/	O
10000.0	int
)	O
;	O
dap_swap	()->(void)
(	O
)	O
;	O
}	O
void	O
freq	(*(char),*(char),*(char),*(char))->(void)
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
varlist	array(char)
,	O
char	O
*	O
stats	array(int)
,	O
char	O
*	O
marks	array(char)
)	O
{	O
char	O
*	O
outname	*(char)
;	O
int	O
statv	*(int)
[	O
NFREQSTAT	int
]	O
;	O
int	O
typen	int
;	O
int	O
celln	int
;	O
int	O
*	O
markv	array(int)
;	O
int	O
nmark	int
;	O
int	O
*	O
varv	array(int)
;	O
int	O
nvar	int
;	O
int	O
v	int
;	O
int	O
wt	*(int)
;	O
char	O
*	O
outlist	*(char)
;	O
double	O
count	double
;	O
double	O
sumcount	double
;	O
double	O
*	O
tabmem	*(double)
;	O
double	O
*	O
*	O
tab	*(*(double))
;	O
char	O
*	O
levmem	*(char)
;	O
char	O
*	O
*	O
level	double
[	O
2	int
]	O
;	O
int	O
nlevels	*(int)
[	O
2	int
]	O
;	O
int	O
l1	int
,	O
l2	int
;	O
double	O
cmh	*(double)
,	O
cmhvar	*(double)
;	O
int	O
more	int
,	O
moremore	int
;	O
int	O
(	O
*	O
strc	*(()->(int))
)	O
(	O
)	O
;	O
strc	*(()->(int))
=	O
&	O
strcmp	(*(char),*(char))->(int)
;	O
if	O
(	O
!	O
fname	array(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(freq) No dataset name given.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
outname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
+	O
5	int
,	O
""	*(char)
)	O
;	O
dap_suffix	(array(char),array(char),array(char))->(void)
(	O
outname	*(char)
,	O
fname	array(char)
,	O
".frq"	*(char)
)	O
;	O
outlist	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_listlen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
markv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
varv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
tabmem	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxlev	int
*	O
dap_maxlev	int
,	O
""	*(char)
)	O
;	O
tab	*(*(double))
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
dap_maxlev	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
l1	int
=	O
0	int
;	O
l1	int
<	O
dap_maxlev	int
;	O
l1	int
++	O
)	O
tab	*(*(double))
[	O
l1	int
]	O
=	O
tabmem	*(double)
+	O
l1	int
*	O
dap_maxlev	int
;	O
levmem	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
2	int
*	O
dap_maxlev	int
*	O
(	O
dap_strlen	int
+	O
1	int
)	O
,	O
""	*(char)
)	O
;	O
level	double
[	O
0	int
]	O
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxlev	int
,	O
""	*(char)
)	O
;	O
level	double
[	O
1	int
]	O
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxlev	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
l1	int
=	O
0	int
;	O
l1	int
<	O
dap_maxlev	int
;	O
l1	int
++	O
)	O
{	O
level	double
[	O
0	int
]	O
[	O
l1	int
]	O
=	O
levmem	*(char)
+	O
l1	int
*	O
(	O
dap_strlen	int
+	O
1	int
)	O
;	O
level	double
[	O
1	int
]	O
[	O
l1	int
]	O
=	O
level	double
[	O
0	int
]	O
[	O
l1	int
]	O
+	O
dap_maxlev	int
*	O
(	O
dap_strlen	int
+	O
1	int
)	O
;	O
}	O
statparse	(*(char),*(int))->(void)
(	O
stats	array(int)
,	O
statv	*(int)
)	O
;	O
inset	(array(char))->(void)
(	O
fname	array(char)
)	O
;	O
if	O
(	O
(	O
typen	int
=	O
dap_varnum	(array(char))->(int)
(	O
"_type_"	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(freq) Missing _type_ variable.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
nmark	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
marks	array(char)
,	O
markv	array(int)
,	O
dap_maxvar	int
)	O
;	O
nvar	int
=	O
freqparse	(*(char),*(int),*(int))->(int)
(	O
varlist	array(char)
,	O
varv	array(int)
,	O
&	O
wt	*(int)
)	O
;	O
if	O
(	O
statv	*(int)
[	O
FREQCMH	int
]	O
&&	O
nvar	int
<	O
3	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(freq) Cochran-Mantel-Haenszel test performed only for tables with dimension >= 3.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
celln	int
=	O
dap_vd	(array(char),int)->(int)
(	O
"_cell_ -1"	*(char)
,	O
0	int
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
v	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
else	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
" "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
}	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
" _cell_ "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
marks	array(char)
)	O
;	O
outset	(array(char),array(char))->(void)
(	O
outname	*(char)
,	O
outlist	*(char)
)	O
;	O
nlevels	*(int)
[	O
0	int
]	O
=	O
0	int
;	O
nlevels	*(int)
[	O
1	int
]	O
=	O
0	int
;	O
for	O
(	O
l1	int
=	O
0	int
;	O
l1	int
<	O
dap_maxlev	int
;	O
l1	int
++	O
)	O
for	O
(	O
l2	int
=	O
0	int
;	O
l2	int
<	O
dap_maxlev	int
;	O
l2	int
++	O
)	O
tab	*(*(double))
[	O
l1	int
]	O
[	O
l2	int
]	O
=	O
0.0	int
;	O
for	O
(	O
dap_mark	()->(void)
(	O
)	O
,	O
sumcount	double
=	O
0.0	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
)	O
{	O
more	int
=	O
step	()->(int)
(	O
)	O
;	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
markv	array(int)
,	O
nmark	int
)	O
)	O
{	O
dap_rewind	()->(void)
(	O
)	O
;	O
if	O
(	O
nvar	int
==	O
2	int
)	O
{	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
level	double
[	O
0	int
]	O
[	O
0	int
]	O
,	O
nlevels	*(int)
[	O
0	int
]	O
,	O
dap_strlen	int
+	O
1	int
,	O
strc	*(()->(int))
)	O
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
level	double
[	O
1	int
]	O
[	O
0	int
]	O
,	O
nlevels	*(int)
[	O
1	int
]	O
,	O
dap_strlen	int
+	O
1	int
,	O
strc	*(()->(int))
)	O
;	O
}	O
for	O
(	O
count	double
=	O
0.0	int
,	O
cmh	*(double)
=	O
0.0	int
,	O
cmhvar	*(double)
=	O
0.0	int
,	O
moremore	int
=	O
1	int
;	O
moremore	int
;	O
)	O
{	O
dap_mark	()->(void)
(	O
)	O
;	O
moremore	int
=	O
(	O
step	()->(int)
(	O
)	O
&&	O
!	O
dap_newpart	(array(int),int)->(int)
(	O
markv	array(int)
,	O
nmark	int
)	O
)	O
;	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
varv	array(int)
,	O
nvar	int
)	O
||	O
dap_newpart	(array(int),int)->(int)
(	O
markv	array(int)
,	O
nmark	int
)	O
)	O
{	O
freq1	(*(int),int,double,double,*(int),int,int)->(void)
(	O
varv	array(int)
,	O
nvar	int
,	O
count	double
,	O
sumcount	double
,	O
statv	*(int)
,	O
typen	int
,	O
celln	int
)	O
;	O
if	O
(	O
nvar	int
==	O
2	int
)	O
tabentry	(*(int),*(*(double)),array(*(*(char))),array(int),double)->(void)
(	O
varv	array(int)
,	O
tab	*(*(double))
,	O
level	double
,	O
nlevels	*(int)
,	O
count	double
)	O
;	O
else	O
if	O
(	O
statv	*(int)
[	O
FREQCMH	int
]	O
)	O
{	O
tabentry	(*(int),*(*(double)),array(*(*(char))),array(int),double)->(void)
(	O
varv	array(int)
+	O
nvar	int
-	O
2	int
,	O
tab	*(*(double))
,	O
level	double
,	O
nlevels	*(int)
,	O
count	double
)	O
;	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
varv	array(int)
,	O
nvar	int
-	O
2	int
)	O
)	O
cmh1	(*(*(double)),*(double),*(double))->(void)
(	O
tab	*(*(double))
,	O
&	O
cmh	*(double)
,	O
&	O
cmhvar	*(double)
)	O
;	O
}	O
count	double
=	O
0.0	int
;	O
}	O
if	O
(	O
wt	*(int)
>=	O
0	int
)	O
count	double
+=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
wt	*(int)
]	O
;	O
else	O
count	double
+=	O
1.0	int
;	O
}	O
if	O
(	O
nvar	int
==	O
2	int
)	O
freq2	(*(*(double)),array(*(*(char))),array(int),*(int),*(int),int,*(int),int,int)->(void)
(	O
tab	*(*(double))
,	O
level	double
,	O
nlevels	*(int)
,	O
statv	*(int)
,	O
markv	array(int)
,	O
nmark	int
,	O
varv	array(int)
,	O
typen	int
,	O
celln	int
)	O
;	O
else	O
if	O
(	O
statv	*(int)
[	O
FREQCMH	int
]	O
)	O
printcmh	(double,double,*(int),int,*(int),int)->(void)
(	O
cmh	*(double)
,	O
cmhvar	*(double)
,	O
varv	array(int)
,	O
nvar	int
,	O
markv	array(int)
,	O
nmark	int
)	O
;	O
for	O
(	O
l1	int
=	O
0	int
;	O
l1	int
<	O
dap_maxlev	int
;	O
l1	int
++	O
)	O
for	O
(	O
l2	int
=	O
0	int
;	O
l2	int
<	O
dap_maxlev	int
;	O
l2	int
++	O
)	O
tab	*(*(double))
[	O
l1	int
]	O
[	O
l2	int
]	O
=	O
0.0	int
;	O
sumcount	double
=	O
0.0	int
;	O
nlevels	*(int)
[	O
0	int
]	O
=	O
0	int
;	O
nlevels	*(int)
[	O
1	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
nvar	int
==	O
2	int
)	O
{	O
findlev	(int,*(*(char)),*(int))->(int)
(	O
varv	array(int)
[	O
0	int
]	O
,	O
level	double
[	O
0	int
]	O
,	O
nlevels	*(int)
)	O
;	O
findlev	(int,*(*(char)),*(int))->(int)
(	O
varv	array(int)
[	O
1	int
]	O
,	O
level	double
[	O
1	int
]	O
,	O
nlevels	*(int)
+	O
1	int
)	O
;	O
}	O
if	O
(	O
wt	*(int)
>=	O
0	int
)	O
sumcount	double
+=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
wt	*(int)
]	O
;	O
else	O
sumcount	double
+=	O
1.0	int
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
outname	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
outlist	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
markv	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
varv	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
tabmem	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
tab	*(*(double))
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
levmem	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
level	double
[	O
0	int
]	O
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
level	double
[	O
1	int
]	O
,	O
""	*(char)
)	O
;	O
}	O
static	O
void	O
trim1	(*(double),int,*(*(double)),int,*(double),*(double))->(void)
(	O
double	O
*	O
vpct	*(double)
,	O
int	O
nvar	int
,	O
double	O
*	O
*	O
val	*(*(*(double)))
,	O
int	O
nobs	int
,	O
double	O
*	O
vmin	*(double)
,	O
double	O
*	O
vmax	*(double)
)	O
{	O
int	O
v	int
;	O
int	O
trimcnt	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
trimcnt	int
=	O
(	O
int	O
)	O
rint	(double)->(double)
(	O
vpct	*(double)
[	O
v	int
]	O
/	O
100.0	int
*	O
(	O
(	O
double	O
)	O
nobs	int
)	O
)	O
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
(	O
void	O
*	O
)	O
val	*(*(*(double)))
[	O
v	int
]	O
,	O
(	O
size_t	long
)	O
nobs	int
,	O
(	O
size_t	long
)	O
sizeof	O
(	O
double	O
)	O
,	O
cmp	*(()->(int))
)	O
;	O
vmin	*(double)
[	O
v	int
]	O
=	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
trimcnt	int
]	O
;	O
vmax	*(double)
[	O
v	int
]	O
=	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
nobs	int
-	O
trimcnt	int
-	O
1	int
]	O
;	O
}	O
}	O
static	O
int	O
trimparse	(*(char),*(int),*(double))->(int)
(	O
char	O
*	O
trimspec	*(char)
,	O
int	O
*	O
varv	array(int)
,	O
double	O
*	O
vpct	*(double)
)	O
{	O
int	O
n	int
;	O
int	O
i	int
;	O
char	O
*	O
varname	*(char)
;	O
int	O
v	int
;	O
double	O
div	(int,int)->(struct(int,int))
;	O
int	O
digits	int
;	O
int	O
nvar	int
;	O
if	O
(	O
!	O
trimspec	*(char)
)	O
return	O
0	int
;	O
varname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_namelen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
trimspec	*(char)
[	O
n	int
]	O
==	O
' '	O
;	O
n	int
++	O
)	O
;	O
for	O
(	O
nvar	int
=	O
0	int
;	O
trimspec	*(char)
[	O
n	int
]	O
;	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
trimspec	*(char)
[	O
n	int
+	O
i	int
]	O
&&	O
trimspec	*(char)
[	O
n	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
varname	*(char)
[	O
i	int
]	O
=	O
trimspec	*(char)
[	O
n	int
+	O
i	int
]	O
;	O
else	O
{	O
varname	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(trimparse) trim variable name too long: %s\n"	*(char)
,	O
varname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
varname	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
n	int
+=	O
i	int
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	(array(char))->(int)
(	O
varname	*(char)
)	O
)	O
>=	O
0	int
)	O
{	O
varv	array(int)
[	O
nvar	int
]	O
=	O
v	int
;	O
while	O
(	O
trimspec	*(char)
[	O
n	int
]	O
==	O
' '	O
)	O
n	int
++	O
;	O
for	O
(	O
digits	int
=	O
0	int
,	O
div	(int,int)->(struct(int,int))
=	O
0.0	int
;	O
(	O
'0'	O
<=	O
trimspec	*(char)
[	O
n	int
]	O
&&	O
trimspec	*(char)
[	O
n	int
]	O
<=	O
'9'	O
)	O
||	O
trimspec	*(char)
[	O
n	int
]	O
==	O
'.'	O
;	O
n	int
++	O
)	O
{	O
if	O
(	O
trimspec	*(char)
[	O
n	int
]	O
==	O
'.'	O
)	O
{	O
if	O
(	O
div	(int,int)->(struct(int,int))
>=	O
1.0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(trimparse) multiple decimal points in percent for %s\n"	*(char)
,	O
varname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
div	(int,int)->(struct(int,int))
=	O
1.0	int
;	O
}	O
else	O
{	O
digits	int
=	O
10	int
*	O
digits	int
+	O
trimspec	*(char)
[	O
n	int
]	O
-	O
'0'	O
;	O
if	O
(	O
div	(int,int)->(struct(int,int))
>=	O
1.0	int
)	O
div	(int,int)->(struct(int,int))
*=	O
10.0	int
;	O
}	O
}	O
vpct	*(double)
[	O
nvar	int
]	O
=	O
(	O
double	O
)	O
digits	int
;	O
if	O
(	O
div	(int,int)->(struct(int,int))
>=	O
1.0	int
)	O
vpct	*(double)
[	O
nvar	int
]	O
/=	O
div	(int,int)->(struct(int,int))
;	O
if	O
(	O
vpct	*(double)
[	O
nvar	int
]	O
>	O
0.0	int
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
v	int
]	O
==	O
DBL	O
)	O
nvar	int
++	O
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(trimparse) trim variable not double: %s\n"	*(char)
,	O
varname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(trimparse) no percent for trim variable: %s\n"	*(char)
,	O
varname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(trimparse) unknown trim variable: %s\n"	*(char)
,	O
varname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
while	O
(	O
trimspec	*(char)
[	O
n	int
]	O
==	O
' '	O
)	O
n	int
++	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
varname	*(char)
,	O
""	*(char)
)	O
;	O
return	O
nvar	int
;	O
}	O
void	O
trim	(*(char),*(char),*(char))->(void)
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
trimspec	*(char)
,	O
char	O
*	O
marks	array(char)
)	O
{	O
char	O
*	O
outname	*(char)
;	O
int	O
*	O
markv	array(int)
;	O
int	O
nmark	int
;	O
int	O
*	O
varv	array(int)
;	O
double	O
*	O
vpct	*(double)
;	O
int	O
nvar	int
;	O
double	O
*	O
valmem	*(double)
;	O
double	O
*	O
*	O
val	*(*(*(double)))
;	O
int	O
v	int
;	O
int	O
nobs	int
;	O
double	O
*	O
vmin	*(double)
;	O
double	O
*	O
vmax	*(double)
;	O
int	O
more	int
;	O
if	O
(	O
!	O
fname	array(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(trim) No dataset name given.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
outname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
+	O
5	int
,	O
""	*(char)
)	O
;	O
dap_suffix	(array(char),array(char),array(char))->(void)
(	O
outname	*(char)
,	O
fname	array(char)
,	O
".trm"	*(char)
)	O
;	O
markv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
varv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
vpct	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
vmin	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
vmax	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
inset	(array(char))->(void)
(	O
fname	array(char)
)	O
;	O
nmark	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
marks	array(char)
,	O
markv	array(int)
,	O
dap_maxvar	int
)	O
;	O
nvar	int
=	O
trimparse	(*(char),*(int),*(double))->(int)
(	O
trimspec	*(char)
,	O
varv	array(int)
,	O
vpct	*(double)
)	O
;	O
outset	(array(char),array(char))->(void)
(	O
outname	*(char)
,	O
""	*(char)
)	O
;	O
valmem	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
*	O
dap_maxval	int
,	O
""	*(char)
)	O
;	O
val	*(*(*(double)))
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<=	O
nvar	int
;	O
v	int
++	O
)	O
val	*(*(*(double)))
[	O
v	int
]	O
=	O
valmem	*(double)
+	O
v	int
*	O
dap_maxval	int
;	O
for	O
(	O
dap_mark	()->(void)
(	O
)	O
,	O
nobs	int
=	O
0	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
nobs	int
++	O
)	O
{	O
more	int
=	O
step	()->(int)
(	O
)	O
;	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
markv	array(int)
,	O
nmark	int
)	O
)	O
{	O
trim1	(*(double),int,*(*(double)),int,*(double),*(double))->(void)
(	O
vpct	*(double)
,	O
nvar	int
,	O
val	*(*(*(double)))
,	O
nobs	int
,	O
vmin	*(double)
,	O
vmax	*(double)
)	O
;	O
dap_rewind	()->(void)
(	O
)	O
;	O
while	O
(	O
step	()->(int)
(	O
)	O
&&	O
!	O
dap_newpart	(array(int),int)->(int)
(	O
markv	array(int)
,	O
nmark	int
)	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
<	O
vmin	*(double)
[	O
v	int
]	O
||	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
>	O
vmax	*(double)
[	O
v	int
]	O
)	O
break	O
;	O
}	O
if	O
(	O
v	int
==	O
nvar	int
)	O
output	()->(void)
(	O
)	O
;	O
dap_mark	()->(void)
(	O
)	O
;	O
}	O
nobs	int
=	O
0	int
;	O
}	O
if	O
(	O
nobs	int
<	O
dap_maxval	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
finite	(double)->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
)	O
val	*(*(*(double)))
[	O
v	int
]	O
[	O
nobs	int
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(trim) NaN value %d for %s\n"	*(char)
,	O
nobs	int
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(group) Too many data.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
outname	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
markv	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
varv	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
vpct	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
valmem	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
val	*(*(*(double)))
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
vmin	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
vmax	*(double)
,	O
""	*(char)
)	O
;	O
}	O
