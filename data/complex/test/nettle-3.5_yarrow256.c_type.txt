static	O
void	O
yarrow_gate	(*(struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))))->(void)
(	O
struct	O
yarrow256_ctx	struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))
*	O
ctx	*(void)
)	O
;	O
void	O
yarrow256_init	O
(	O
struct	O
yarrow256_ctx	struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))
*	O
ctx	*(void)
,	O
unsigned	O
n	int
,	O
struct	O
yarrow_source	struct(array(int),enum(int,int))
*	O
s	*(struct(array(int),enum(int,int)))
)	O
{	O
unsigned	O
i	int
;	O
sha256_init	O
(	O
&	O
ctx	*(void)
->	O
pools	array(struct(array(int),long,int,array(char)))
[	O
0	int
]	O
)	O
;	O
sha256_init	O
(	O
&	O
ctx	*(void)
->	O
pools	array(struct(array(int),long,int,array(char)))
[	O
1	int
]	O
)	O
;	O
ctx	*(void)
->	O
seeded	int
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
ctx	*(void)
->	O
counter	array(char)
,	O
0	int
,	O
sizeof	O
(	O
ctx	*(void)
->	O
counter	array(char)
)	O
)	O
;	O
ctx	*(void)
->	O
nsources	int
=	O
n	int
;	O
ctx	*(void)
->	O
sources	*(struct(array(int),enum(int,int)))
=	O
s	*(struct(array(int),enum(int,int)))
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
ctx	*(void)
->	O
sources	*(struct(array(int),enum(int,int)))
[	O
i	int
]	O
.	O
estimate	array(int)
[	O
YARROW_FAST	int
]	O
=	O
0	int
;	O
ctx	*(void)
->	O
sources	*(struct(array(int),enum(int,int)))
[	O
i	int
]	O
.	O
estimate	array(int)
[	O
YARROW_SLOW	int
]	O
=	O
0	int
;	O
ctx	*(void)
->	O
sources	*(struct(array(int),enum(int,int)))
[	O
i	int
]	O
.	O
next	enum(int,int)
=	O
YARROW_FAST	int
;	O
}	O
}	O
void	O
yarrow256_seed	O
(	O
struct	O
yarrow256_ctx	struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))
*	O
ctx	*(void)
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
seed_file	*(char)
)	O
{	O
assert	O
(	O
length	long
>	O
0	int
)	O
;	O
sha256_update	O
(	O
&	O
ctx	*(void)
->	O
pools	array(struct(array(int),long,int,array(char)))
[	O
YARROW_FAST	int
]	O
,	O
length	long
,	O
seed_file	*(char)
)	O
;	O
yarrow256_fast_reseed	O
(	O
ctx	*(void)
)	O
;	O
}	O
static	O
void	O
yarrow_generate_block	(*(struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))),*(char))->(void)
(	O
struct	O
yarrow256_ctx	struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))
*	O
ctx	*(void)
,	O
uint8_t	char
*	O
block	array(char)
)	O
{	O
unsigned	O
i	int
;	O
aes256_encrypt	O
(	O
&	O
ctx	*(void)
->	O
key	*(char)
,	O
sizeof	O
(	O
ctx	*(void)
->	O
counter	array(char)
)	O
,	O
block	array(char)
,	O
ctx	*(void)
->	O
counter	array(char)
)	O
;	O
for	O
(	O
i	int
=	O
sizeof	O
(	O
ctx	*(void)
->	O
counter	array(char)
)	O
;	O
i	int
--	O
;	O
)	O
{	O
if	O
(	O
++	O
ctx	*(void)
->	O
counter	array(char)
[	O
i	int
]	O
)	O
break	O
;	O
}	O
}	O
static	O
void	O
yarrow_iterate	(*(char))->(void)
(	O
uint8_t	char
*	O
digest	*(char)
)	O
{	O
uint8_t	char
v0	array(char)
[	O
SHA256_DIGEST_SIZE	int
]	O
;	O
unsigned	O
i	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
v0	array(char)
,	O
digest	*(char)
,	O
SHA256_DIGEST_SIZE	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
++	O
i	int
<	O
YARROW_RESEED_ITERATIONS	int
;	O
)	O
{	O
uint8_t	char
count	long
[	O
4	int
]	O
;	O
struct	O
sha256_ctx	struct(array(int),long,int,array(char))
hash	struct(array(int),long,int,array(char))
;	O
sha256_init	O
(	O
&	O
hash	struct(array(int),long,int,array(char))
)	O
;	O
WRITE_UINT32	O
(	O
count	long
,	O
i	int
)	O
;	O
sha256_update	O
(	O
&	O
hash	struct(array(int),long,int,array(char))
,	O
SHA256_DIGEST_SIZE	int
,	O
digest	*(char)
)	O
;	O
sha256_update	O
(	O
&	O
hash	struct(array(int),long,int,array(char))
,	O
sizeof	O
(	O
v0	array(char)
)	O
,	O
v0	array(char)
)	O
;	O
sha256_update	O
(	O
&	O
hash	struct(array(int),long,int,array(char))
,	O
sizeof	O
(	O
count	long
)	O
,	O
count	long
)	O
;	O
sha256_digest	O
(	O
&	O
hash	struct(array(int),long,int,array(char))
,	O
SHA256_DIGEST_SIZE	int
,	O
digest	*(char)
)	O
;	O
}	O
}	O
void	O
yarrow256_fast_reseed	O
(	O
struct	O
yarrow256_ctx	struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))
*	O
ctx	*(void)
)	O
{	O
uint8_t	char
digest	*(char)
[	O
SHA256_DIGEST_SIZE	int
]	O
;	O
unsigned	O
i	int
;	O
if	O
(	O
ctx	*(void)
->	O
seeded	int
)	O
{	O
uint8_t	char
blocks	array(char)
[	O
AES_BLOCK_SIZE	int
*	O
2	int
]	O
;	O
yarrow_generate_block	(*(struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))),*(char))->(void)
(	O
ctx	*(void)
,	O
blocks	array(char)
)	O
;	O
yarrow_generate_block	(*(struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))),*(char))->(void)
(	O
ctx	*(void)
,	O
blocks	array(char)
+	O
AES_BLOCK_SIZE	int
)	O
;	O
sha256_update	O
(	O
&	O
ctx	*(void)
->	O
pools	array(struct(array(int),long,int,array(char)))
[	O
YARROW_FAST	int
]	O
,	O
sizeof	O
(	O
blocks	array(char)
)	O
,	O
blocks	array(char)
)	O
;	O
}	O
sha256_digest	O
(	O
&	O
ctx	*(void)
->	O
pools	array(struct(array(int),long,int,array(char)))
[	O
YARROW_FAST	int
]	O
,	O
sizeof	O
(	O
digest	*(char)
)	O
,	O
digest	*(char)
)	O
;	O
yarrow_iterate	(*(char))->(void)
(	O
digest	*(char)
)	O
;	O
aes256_set_encrypt_key	O
(	O
&	O
ctx	*(void)
->	O
key	*(char)
,	O
digest	*(char)
)	O
;	O
ctx	*(void)
->	O
seeded	int
=	O
1	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
ctx	*(void)
->	O
counter	array(char)
,	O
0	int
,	O
sizeof	O
(	O
ctx	*(void)
->	O
counter	array(char)
)	O
)	O
;	O
aes256_encrypt	O
(	O
&	O
ctx	*(void)
->	O
key	*(char)
,	O
sizeof	O
(	O
ctx	*(void)
->	O
counter	array(char)
)	O
,	O
ctx	*(void)
->	O
counter	array(char)
,	O
ctx	*(void)
->	O
counter	array(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ctx	*(void)
->	O
nsources	int
;	O
i	int
++	O
)	O
ctx	*(void)
->	O
sources	*(struct(array(int),enum(int,int)))
[	O
i	int
]	O
.	O
estimate	array(int)
[	O
YARROW_FAST	int
]	O
=	O
0	int
;	O
}	O
void	O
yarrow256_slow_reseed	O
(	O
struct	O
yarrow256_ctx	struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))
*	O
ctx	*(void)
)	O
{	O
uint8_t	char
digest	*(char)
[	O
SHA256_DIGEST_SIZE	int
]	O
;	O
unsigned	O
i	int
;	O
sha256_digest	O
(	O
&	O
ctx	*(void)
->	O
pools	array(struct(array(int),long,int,array(char)))
[	O
YARROW_SLOW	int
]	O
,	O
sizeof	O
(	O
digest	*(char)
)	O
,	O
digest	*(char)
)	O
;	O
sha256_update	O
(	O
&	O
ctx	*(void)
->	O
pools	array(struct(array(int),long,int,array(char)))
[	O
YARROW_FAST	int
]	O
,	O
sizeof	O
(	O
digest	*(char)
)	O
,	O
digest	*(char)
)	O
;	O
yarrow256_fast_reseed	O
(	O
ctx	*(void)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ctx	*(void)
->	O
nsources	int
;	O
i	int
++	O
)	O
ctx	*(void)
->	O
sources	*(struct(array(int),enum(int,int)))
[	O
i	int
]	O
.	O
estimate	array(int)
[	O
YARROW_SLOW	int
]	O
=	O
0	int
;	O
}	O
int	O
yarrow256_update	O
(	O
struct	O
yarrow256_ctx	struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))
*	O
ctx	*(void)
,	O
unsigned	O
source_index	int
,	O
unsigned	O
entropy	int
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
data	*(char)
)	O
{	O
enum	O
yarrow_pool_id	enum(int,int)
current	enum(int,int)
;	O
struct	O
yarrow_source	struct(array(int),enum(int,int))
*	O
source	int
;	O
assert	O
(	O
source_index	int
<	O
ctx	*(void)
->	O
nsources	int
)	O
;	O
if	O
(	O
!	O
length	long
)	O
return	O
0	int
;	O
source	int
=	O
&	O
ctx	*(void)
->	O
sources	*(struct(array(int),enum(int,int)))
[	O
source_index	int
]	O
;	O
if	O
(	O
!	O
ctx	*(void)
->	O
seeded	int
)	O
current	enum(int,int)
=	O
YARROW_SLOW	int
;	O
else	O
{	O
current	enum(int,int)
=	O
source	int
->	O
next	enum(int,int)
;	O
source	int
->	O
next	enum(int,int)
=	O
!	O
source	int
->	O
next	enum(int,int)
;	O
}	O
sha256_update	O
(	O
&	O
ctx	*(void)
->	O
pools	array(struct(array(int),long,int,array(char)))
[	O
current	enum(int,int)
]	O
,	O
length	long
,	O
data	*(char)
)	O
;	O
if	O
(	O
source	int
->	O
estimate	array(int)
[	O
current	enum(int,int)
]	O
<	O
YARROW_MAX_ENTROPY	int
)	O
{	O
if	O
(	O
entropy	int
>	O
YARROW_MAX_ENTROPY	int
)	O
entropy	int
=	O
YARROW_MAX_ENTROPY	int
;	O
if	O
(	O
(	O
length	long
<	O
(	O
YARROW_MAX_ENTROPY	int
/	O
YARROW_MULTIPLIER	int
)	O
)	O
&&	O
(	O
entropy	int
>	O
YARROW_MULTIPLIER	int
*	O
length	long
)	O
)	O
entropy	int
=	O
YARROW_MULTIPLIER	int
*	O
length	long
;	O
entropy	int
+=	O
source	int
->	O
estimate	array(int)
[	O
current	enum(int,int)
]	O
;	O
if	O
(	O
entropy	int
>	O
YARROW_MAX_ENTROPY	int
)	O
entropy	int
=	O
YARROW_MAX_ENTROPY	int
;	O
source	int
->	O
estimate	array(int)
[	O
current	enum(int,int)
]	O
=	O
entropy	int
;	O
}	O
switch	O
(	O
current	enum(int,int)
)	O
{	O
case	O
YARROW_FAST	int
:	O
if	O
(	O
source	int
->	O
estimate	array(int)
[	O
YARROW_FAST	int
]	O
>=	O
YARROW_FAST_THRESHOLD	int
)	O
{	O
yarrow256_fast_reseed	O
(	O
ctx	*(void)
)	O
;	O
return	O
1	int
;	O
}	O
else	O
return	O
0	int
;	O
case	O
YARROW_SLOW	int
:	O
{	O
if	O
(	O
!	O
yarrow256_needed_sources	O
(	O
ctx	*(void)
)	O
)	O
{	O
yarrow256_slow_reseed	O
(	O
ctx	*(void)
)	O
;	O
return	O
1	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
static	O
void	O
yarrow_gate	(*(struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))))->(void)
(	O
struct	O
yarrow256_ctx	struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))
*	O
ctx	*(void)
)	O
{	O
uint8_t	char
key	*(char)
[	O
AES256_KEY_SIZE	int
]	O
;	O
unsigned	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
key	*(char)
)	O
;	O
i	int
+=	O
AES_BLOCK_SIZE	int
)	O
yarrow_generate_block	(*(struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))),*(char))->(void)
(	O
ctx	*(void)
,	O
key	*(char)
+	O
i	int
)	O
;	O
aes256_set_encrypt_key	O
(	O
&	O
ctx	*(void)
->	O
key	*(char)
,	O
key	*(char)
)	O
;	O
}	O
void	O
yarrow256_random	O
(	O
struct	O
yarrow256_ctx	struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))
*	O
ctx	*(void)
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
dst	*(char)
)	O
{	O
assert	O
(	O
ctx	*(void)
->	O
seeded	int
)	O
;	O
while	O
(	O
length	long
>=	O
AES_BLOCK_SIZE	int
)	O
{	O
yarrow_generate_block	(*(struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))),*(char))->(void)
(	O
ctx	*(void)
,	O
dst	*(char)
)	O
;	O
dst	*(char)
+=	O
AES_BLOCK_SIZE	int
;	O
length	long
-=	O
AES_BLOCK_SIZE	int
;	O
}	O
if	O
(	O
length	long
)	O
{	O
uint8_t	char
buffer	array(char)
[	O
AES_BLOCK_SIZE	int
]	O
;	O
assert	O
(	O
length	long
<	O
AES_BLOCK_SIZE	int
)	O
;	O
yarrow_generate_block	(*(struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))),*(char))->(void)
(	O
ctx	*(void)
,	O
buffer	array(char)
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dst	*(char)
,	O
buffer	array(char)
,	O
length	long
)	O
;	O
}	O
yarrow_gate	(*(struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))))->(void)
(	O
ctx	*(void)
)	O
;	O
}	O
int	O
yarrow256_is_seeded	O
(	O
struct	O
yarrow256_ctx	struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))
*	O
ctx	*(void)
)	O
{	O
return	O
ctx	*(void)
->	O
seeded	int
;	O
}	O
unsigned	O
yarrow256_needed_sources	O
(	O
struct	O
yarrow256_ctx	struct(array(struct(array(int),long,int,array(char))),int,struct(array(int)),array(char),int,*(struct(array(int),enum(int,int))))
*	O
ctx	*(void)
)	O
{	O
unsigned	O
k	int
,	O
i	int
;	O
for	O
(	O
i	int
=	O
k	int
=	O
0	int
;	O
i	int
<	O
ctx	*(void)
->	O
nsources	int
;	O
i	int
++	O
)	O
if	O
(	O
ctx	*(void)
->	O
sources	*(struct(array(int),enum(int,int)))
[	O
i	int
]	O
.	O
estimate	array(int)
[	O
YARROW_SLOW	int
]	O
>=	O
YARROW_SLOW_THRESHOLD	int
)	O
k	int
++	O
;	O
return	O
(	O
k	int
<	O
YARROW_SLOW_K	int
)	O
?	O
(	O
YARROW_SLOW_K	int
-	O
k	int
)	O
:	O
0	int
;	O
}	O
