Keymap	*(struct(char,*((int,int)->(int))))
rl_binding_keymap	*(struct(char,*((int,int)->(int))))
;	O
static	O
int	O
_rl_skip_to_delim	(*(char),int,int)->(int)
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
_rl_init_file_error	(*(char))->(void)
(	O
const	O
char	O
*	O
,	O
...	O
)	O
__attribute__	O
(	O
(	O
__format__	O
(	O
printf	(*(char))->(int)
,	O
1	int
,	O
2	int
)	O
)	O
)	O
;	O
static	O
char	O
*	O
_rl_read_file	(*(char),*(long))->(*(char))
PARAMS	O
(	O
(	O
char	O
*	O
,	O
size_t	long
*	O
)	O
)	O
;	O
static	O
int	O
_rl_read_init_file	(*(char),int)->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
glean_key_from_name	(*(char))->(int)
PARAMS	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
find_boolean_var	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
find_string_var	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
_rl_get_string_variable_value	(*(char))->(*(char))
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
substring_member_of_array	(*(char),*(*(char)))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
const	O
*	O
)	O
)	O
;	O
static	O
int	O
currently_reading_init_file	int
;	O
static	O
int	O
_rl_prefer_visible_bell	int
=	O
1	int
;	O
int	O
rl_add_defun	(*(char),*((int,int)->(int)),int)->(int)
(	O
name	*(char)
,	O
function	*((int,int)->(int))
,	O
key	int
)	O
const	O
char	O
*	O
name	*(char)
;	O
rl_command_func_t	(int,int)->(int)
*	O
function	*((int,int)->(int))
;	O
int	O
key	int
;	O
{	O
if	O
(	O
key	int
!=	O
-	O
1	int
)	O
rl_bind_key	(int,*((int,int)->(int)))->(int)
(	O
key	int
,	O
function	*((int,int)->(int))
)	O
;	O
rl_add_funmap_entry	(*(char),*((int,int)->(int)))->(int)
(	O
name	*(char)
,	O
function	*((int,int)->(int))
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_bind_key	(int,*((int,int)->(int)))->(int)
(	O
key	int
,	O
function	*((int,int)->(int))
)	O
int	O
key	int
;	O
rl_command_func_t	(int,int)->(int)
*	O
function	*((int,int)->(int))
;	O
{	O
char	O
keyseq	array(char)
[	O
3	int
]	O
;	O
int	O
l	int
;	O
if	O
(	O
key	int
<	O
0	int
)	O
return	O
(	O
key	int
)	O
;	O
if	O
(	O
META_CHAR	O
(	O
key	int
)	O
&&	O
_rl_convert_meta_chars_to_ascii	int
)	O
{	O
if	O
(	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
[	O
ESC	O
]	O
.	O
type	enum(int,int,int,int)
==	O
ISKMAP	int
)	O
{	O
Keymap	*(struct(char,*((int,int)->(int))))
escmap	*(struct(char,*((int,int)->(int))))
;	O
escmap	*(struct(char,*((int,int)->(int))))
=	O
FUNCTION_TO_KEYMAP	O
(	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
,	O
ESC	O
)	O
;	O
key	int
=	O
UNMETA	O
(	O
key	int
)	O
;	O
escmap	*(struct(char,*((int,int)->(int))))
[	O
key	int
]	O
.	O
type	enum(int,int,int,int)
=	O
ISFUNC	int
;	O
escmap	*(struct(char,*((int,int)->(int))))
[	O
key	int
]	O
.	O
function	*((int,int)->(int))
=	O
function	*((int,int)->(int))
;	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
key	int
)	O
;	O
}	O
if	O
(	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
[	O
key	int
]	O
.	O
type	enum(int,int,int,int)
!=	O
ISKMAP	int
)	O
{	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
[	O
key	int
]	O
.	O
type	enum(int,int,int,int)
=	O
ISFUNC	int
;	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
[	O
key	int
]	O
.	O
function	*((int,int)->(int))
=	O
function	*((int,int)->(int))
;	O
}	O
else	O
{	O
l	int
=	O
0	int
;	O
if	O
(	O
key	int
==	O
'\\'	O
)	O
keyseq	array(char)
[	O
l	int
++	O
]	O
=	O
'\\'	O
;	O
keyseq	array(char)
[	O
l	int
++	O
]	O
=	O
key	int
;	O
keyseq	array(char)
[	O
l	int
]	O
=	O
'\0'	O
;	O
rl_bind_keyseq	(*(char),*((int,int)->(int)))->(int)
(	O
keyseq	array(char)
,	O
function	*((int,int)->(int))
)	O
;	O
}	O
rl_binding_keymap	*(struct(char,*((int,int)->(int))))
=	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_bind_key_in_map	(int,*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
key	int
,	O
function	*((int,int)->(int))
,	O
map	*(struct(char,*((int,int)->(int))))
)	O
int	O
key	int
;	O
rl_command_func_t	(int,int)->(int)
*	O
function	*((int,int)->(int))
;	O
Keymap	*(struct(char,*((int,int)->(int))))
map	*(struct(char,*((int,int)->(int))))
;	O
{	O
int	O
result	int
;	O
Keymap	*(struct(char,*((int,int)->(int))))
oldmap	*(struct(char,*((int,int)->(int))))
;	O
oldmap	*(struct(char,*((int,int)->(int))))
=	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
;	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
=	O
map	*(struct(char,*((int,int)->(int))))
;	O
result	int
=	O
rl_bind_key	(int,*((int,int)->(int)))->(int)
(	O
key	int
,	O
function	*((int,int)->(int))
)	O
;	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
=	O
oldmap	*(struct(char,*((int,int)->(int))))
;	O
return	O
(	O
result	int
)	O
;	O
}	O
int	O
rl_bind_key_if_unbound_in_map	(int,*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
key	int
,	O
default_func	*((int,int)->(int))
,	O
kmap	*(struct(char,*((int,int)->(int))))
)	O
int	O
key	int
;	O
rl_command_func_t	(int,int)->(int)
*	O
default_func	*((int,int)->(int))
;	O
Keymap	*(struct(char,*((int,int)->(int))))
kmap	*(struct(char,*((int,int)->(int))))
;	O
{	O
char	O
keyseq	array(char)
[	O
2	int
]	O
;	O
keyseq	array(char)
[	O
0	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
key	int
;	O
keyseq	array(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
rl_bind_keyseq_if_unbound_in_map	(*(char),*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
keyseq	array(char)
,	O
default_func	*((int,int)->(int))
,	O
kmap	*(struct(char,*((int,int)->(int))))
)	O
)	O
;	O
}	O
int	O
rl_bind_key_if_unbound	(int,*((int,int)->(int)))->(int)
(	O
key	int
,	O
default_func	*((int,int)->(int))
)	O
int	O
key	int
;	O
rl_command_func_t	(int,int)->(int)
*	O
default_func	*((int,int)->(int))
;	O
{	O
char	O
keyseq	array(char)
[	O
2	int
]	O
;	O
keyseq	array(char)
[	O
0	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
key	int
;	O
keyseq	array(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
rl_bind_keyseq_if_unbound_in_map	(*(char),*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
keyseq	array(char)
,	O
default_func	*((int,int)->(int))
,	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
)	O
)	O
;	O
}	O
int	O
rl_unbind_key	(int)->(int)
(	O
key	int
)	O
int	O
key	int
;	O
{	O
return	O
(	O
rl_bind_key	(int,*((int,int)->(int)))->(int)
(	O
key	int
,	O
(	O
rl_command_func_t	(int,int)->(int)
*	O
)	O
NULL	O
)	O
)	O
;	O
}	O
int	O
rl_unbind_key_in_map	(int,*(struct(char,*((int,int)->(int)))))->(int)
(	O
key	int
,	O
map	*(struct(char,*((int,int)->(int))))
)	O
int	O
key	int
;	O
Keymap	*(struct(char,*((int,int)->(int))))
map	*(struct(char,*((int,int)->(int))))
;	O
{	O
return	O
(	O
rl_bind_key_in_map	(int,*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
key	int
,	O
(	O
rl_command_func_t	(int,int)->(int)
*	O
)	O
NULL	O
,	O
map	*(struct(char,*((int,int)->(int))))
)	O
)	O
;	O
}	O
int	O
rl_unbind_function_in_map	(*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
func	*((int,int)->(int))
,	O
map	*(struct(char,*((int,int)->(int))))
)	O
rl_command_func_t	(int,int)->(int)
*	O
func	*((int,int)->(int))
;	O
Keymap	*(struct(char,*((int,int)->(int))))
map	*(struct(char,*((int,int)->(int))))
;	O
{	O
register	O
int	O
i	int
,	O
rval	int
;	O
for	O
(	O
i	int
=	O
rval	int
=	O
0	int
;	O
i	int
<	O
KEYMAP_SIZE	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
map	*(struct(char,*((int,int)->(int))))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
ISFUNC	int
&&	O
map	*(struct(char,*((int,int)->(int))))
[	O
i	int
]	O
.	O
function	*((int,int)->(int))
==	O
func	*((int,int)->(int))
)	O
{	O
map	*(struct(char,*((int,int)->(int))))
[	O
i	int
]	O
.	O
function	*((int,int)->(int))
=	O
(	O
rl_command_func_t	(int,int)->(int)
*	O
)	O
NULL	O
;	O
rval	int
=	O
1	int
;	O
}	O
}	O
return	O
rval	int
;	O
}	O
int	O
rl_unbind_command_in_map	(*(char),*(struct(char,*((int,int)->(int)))))->(int)
(	O
command	*(char)
,	O
map	*(struct(char,*((int,int)->(int))))
)	O
const	O
char	O
*	O
command	*(char)
;	O
Keymap	*(struct(char,*((int,int)->(int))))
map	*(struct(char,*((int,int)->(int))))
;	O
{	O
rl_command_func_t	(int,int)->(int)
*	O
func	*((int,int)->(int))
;	O
func	*((int,int)->(int))
=	O
rl_named_function	(*(char))->(*((int,int)->(int)))
(	O
command	*(char)
)	O
;	O
if	O
(	O
func	*((int,int)->(int))
==	O
0	int
)	O
return	O
0	int
;	O
return	O
(	O
rl_unbind_function_in_map	(*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
func	*((int,int)->(int))
,	O
map	*(struct(char,*((int,int)->(int))))
)	O
)	O
;	O
}	O
int	O
rl_bind_keyseq	(*(char),*((int,int)->(int)))->(int)
(	O
keyseq	array(char)
,	O
function	*((int,int)->(int))
)	O
const	O
char	O
*	O
keyseq	array(char)
;	O
rl_command_func_t	(int,int)->(int)
*	O
function	*((int,int)->(int))
;	O
{	O
return	O
(	O
rl_generic_bind	(int,*(char),*(char),*(struct(char,*((int,int)->(int)))))->(int)
(	O
ISFUNC	int
,	O
keyseq	array(char)
,	O
(	O
char	O
*	O
)	O
function	*((int,int)->(int))
,	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
)	O
)	O
;	O
}	O
int	O
rl_bind_keyseq_in_map	(*(char),*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
keyseq	array(char)
,	O
function	*((int,int)->(int))
,	O
map	*(struct(char,*((int,int)->(int))))
)	O
const	O
char	O
*	O
keyseq	array(char)
;	O
rl_command_func_t	(int,int)->(int)
*	O
function	*((int,int)->(int))
;	O
Keymap	*(struct(char,*((int,int)->(int))))
map	*(struct(char,*((int,int)->(int))))
;	O
{	O
return	O
(	O
rl_generic_bind	(int,*(char),*(char),*(struct(char,*((int,int)->(int)))))->(int)
(	O
ISFUNC	int
,	O
keyseq	array(char)
,	O
(	O
char	O
*	O
)	O
function	*((int,int)->(int))
,	O
map	*(struct(char,*((int,int)->(int))))
)	O
)	O
;	O
}	O
int	O
rl_set_key	(*(char),*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
keyseq	array(char)
,	O
function	*((int,int)->(int))
,	O
map	*(struct(char,*((int,int)->(int))))
)	O
const	O
char	O
*	O
keyseq	array(char)
;	O
rl_command_func_t	(int,int)->(int)
*	O
function	*((int,int)->(int))
;	O
Keymap	*(struct(char,*((int,int)->(int))))
map	*(struct(char,*((int,int)->(int))))
;	O
{	O
return	O
(	O
rl_generic_bind	(int,*(char),*(char),*(struct(char,*((int,int)->(int)))))->(int)
(	O
ISFUNC	int
,	O
keyseq	array(char)
,	O
(	O
char	O
*	O
)	O
function	*((int,int)->(int))
,	O
map	*(struct(char,*((int,int)->(int))))
)	O
)	O
;	O
}	O
int	O
rl_bind_keyseq_if_unbound_in_map	(*(char),*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
keyseq	array(char)
,	O
default_func	*((int,int)->(int))
,	O
kmap	*(struct(char,*((int,int)->(int))))
)	O
const	O
char	O
*	O
keyseq	array(char)
;	O
rl_command_func_t	(int,int)->(int)
*	O
default_func	*((int,int)->(int))
;	O
Keymap	*(struct(char,*((int,int)->(int))))
kmap	*(struct(char,*((int,int)->(int))))
;	O
{	O
rl_command_func_t	(int,int)->(int)
*	O
func	*((int,int)->(int))
;	O
if	O
(	O
keyseq	array(char)
)	O
{	O
func	*((int,int)->(int))
=	O
rl_function_of_keyseq	(*(char),*(struct(char,*((int,int)->(int)))),*(int))->(*((int,int)->(int)))
(	O
keyseq	array(char)
,	O
kmap	*(struct(char,*((int,int)->(int))))
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
!	O
func	*((int,int)->(int))
||	O
func	*((int,int)->(int))
==	O
rl_do_lowercase_version	(int,int)->(int)
||	O
func	*((int,int)->(int))
==	O
rl_vi_movement_mode	(int,int)->(int)
)	O
return	O
(	O
rl_bind_keyseq_in_map	(*(char),*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
keyseq	array(char)
,	O
default_func	*((int,int)->(int))
,	O
kmap	*(struct(char,*((int,int)->(int))))
)	O
)	O
;	O
else	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_bind_keyseq_if_unbound	(*(char),*((int,int)->(int)))->(int)
(	O
keyseq	array(char)
,	O
default_func	*((int,int)->(int))
)	O
const	O
char	O
*	O
keyseq	array(char)
;	O
rl_command_func_t	(int,int)->(int)
*	O
default_func	*((int,int)->(int))
;	O
{	O
return	O
(	O
rl_bind_keyseq_if_unbound_in_map	(*(char),*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
keyseq	array(char)
,	O
default_func	*((int,int)->(int))
,	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
)	O
)	O
;	O
}	O
int	O
rl_macro_bind	(*(char),*(char),*(struct(char,*((int,int)->(int)))))->(int)
(	O
keyseq	array(char)
,	O
macro	*(char)
,	O
map	*(struct(char,*((int,int)->(int))))
)	O
const	O
char	O
*	O
keyseq	array(char)
,	O
*	O
macro	*(char)
;	O
Keymap	*(struct(char,*((int,int)->(int))))
map	*(struct(char,*((int,int)->(int))))
;	O
{	O
char	O
*	O
macro_keys	*(char)
;	O
int	O
macro_keys_len	int
;	O
macro_keys	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
(	O
2	int
*	O
strlen	(*(char))->(long)
(	O
macro	*(char)
)	O
)	O
+	O
1	int
)	O
;	O
if	O
(	O
rl_translate_keyseq	(*(char),*(char),*(int))->(int)
(	O
macro	*(char)
,	O
macro_keys	*(char)
,	O
&	O
macro_keys_len	int
)	O
)	O
{	O
xfree	(*(void))->(void)
(	O
macro_keys	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rl_generic_bind	(int,*(char),*(char),*(struct(char,*((int,int)->(int)))))->(int)
(	O
ISMACR	int
,	O
keyseq	array(char)
,	O
macro_keys	*(char)
,	O
map	*(struct(char,*((int,int)->(int))))
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_generic_bind	(int,*(char),*(char),*(struct(char,*((int,int)->(int)))))->(int)
(	O
type	enum(int,int,int,int)
,	O
keyseq	array(char)
,	O
data	*(void)
,	O
map	*(struct(char,*((int,int)->(int))))
)	O
int	O
type	enum(int,int,int,int)
;	O
const	O
char	O
*	O
keyseq	array(char)
;	O
char	O
*	O
data	*(void)
;	O
Keymap	*(struct(char,*((int,int)->(int))))
map	*(struct(char,*((int,int)->(int))))
;	O
{	O
char	O
*	O
keys	*(char)
;	O
int	O
keys_len	int
;	O
register	O
int	O
i	int
;	O
KEYMAP_ENTRY	struct(char,*((int,int)->(int)))
k	struct(char,*((int,int)->(int)))
;	O
k	struct(char,*((int,int)->(int)))
.	O
function	*((int,int)->(int))
=	O
0	int
;	O
if	O
(	O
keyseq	array(char)
==	O
0	int
||	O
*	O
keyseq	array(char)
==	O
0	int
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
==	O
ISMACR	int
)	O
xfree	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
keys	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
1	int
+	O
(	O
2	int
*	O
strlen	(*(char))->(long)
(	O
keyseq	array(char)
)	O
)	O
)	O
;	O
if	O
(	O
rl_translate_keyseq	(*(char),*(char),*(int))->(int)
(	O
keyseq	array(char)
,	O
keys	*(char)
,	O
&	O
keys_len	int
)	O
)	O
{	O
xfree	(*(void))->(void)
(	O
keys	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
keys_len	int
;	O
i	int
++	O
)	O
{	O
unsigned	O
char	O
uc	char
=	O
keys	*(char)
[	O
i	int
]	O
;	O
int	O
ic	int
;	O
ic	int
=	O
uc	char
;	O
if	O
(	O
ic	int
<	O
0	int
||	O
ic	int
>=	O
KEYMAP_SIZE	int
)	O
{	O
xfree	(*(void))->(void)
(	O
keys	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
META_CHAR	O
(	O
ic	int
)	O
&&	O
_rl_convert_meta_chars_to_ascii	int
)	O
{	O
ic	int
=	O
UNMETA	O
(	O
ic	int
)	O
;	O
if	O
(	O
map	*(struct(char,*((int,int)->(int))))
[	O
ESC	O
]	O
.	O
type	enum(int,int,int,int)
==	O
ISKMAP	int
)	O
map	*(struct(char,*((int,int)->(int))))
=	O
FUNCTION_TO_KEYMAP	O
(	O
map	*(struct(char,*((int,int)->(int))))
,	O
ESC	O
)	O
;	O
}	O
if	O
(	O
(	O
i	int
+	O
1	int
)	O
<	O
keys_len	int
)	O
{	O
if	O
(	O
map	*(struct(char,*((int,int)->(int))))
[	O
ic	int
]	O
.	O
type	enum(int,int,int,int)
!=	O
ISKMAP	int
)	O
{	O
k	struct(char,*((int,int)->(int)))
=	O
map	*(struct(char,*((int,int)->(int))))
[	O
ic	int
]	O
;	O
map	*(struct(char,*((int,int)->(int))))
[	O
ic	int
]	O
.	O
type	enum(int,int,int,int)
=	O
ISKMAP	int
;	O
map	*(struct(char,*((int,int)->(int))))
[	O
ic	int
]	O
.	O
function	*((int,int)->(int))
=	O
KEYMAP_TO_FUNCTION	O
(	O
rl_make_bare_keymap	()->(*(struct(char,*((int,int)->(int)))))
(	O
)	O
)	O
;	O
}	O
map	*(struct(char,*((int,int)->(int))))
=	O
FUNCTION_TO_KEYMAP	O
(	O
map	*(struct(char,*((int,int)->(int))))
,	O
ic	int
)	O
;	O
if	O
(	O
k	struct(char,*((int,int)->(int)))
.	O
function	*((int,int)->(int))
&&	O
(	O
(	O
k	struct(char,*((int,int)->(int)))
.	O
type	enum(int,int,int,int)
==	O
ISFUNC	int
&&	O
k	struct(char,*((int,int)->(int)))
.	O
function	*((int,int)->(int))
!=	O
rl_do_lowercase_version	(int,int)->(int)
)	O
||	O
k	struct(char,*((int,int)->(int)))
.	O
type	enum(int,int,int,int)
==	O
ISMACR	int
)	O
)	O
{	O
map	*(struct(char,*((int,int)->(int))))
[	O
ANYOTHERKEY	O
]	O
=	O
k	struct(char,*((int,int)->(int)))
;	O
k	struct(char,*((int,int)->(int)))
.	O
function	*((int,int)->(int))
=	O
0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
map	*(struct(char,*((int,int)->(int))))
[	O
ic	int
]	O
.	O
type	enum(int,int,int,int)
==	O
ISMACR	int
)	O
xfree	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
map	*(struct(char,*((int,int)->(int))))
[	O
ic	int
]	O
.	O
function	*((int,int)->(int))
)	O
;	O
else	O
if	O
(	O
map	*(struct(char,*((int,int)->(int))))
[	O
ic	int
]	O
.	O
type	enum(int,int,int,int)
==	O
ISKMAP	int
)	O
{	O
map	*(struct(char,*((int,int)->(int))))
=	O
FUNCTION_TO_KEYMAP	O
(	O
map	*(struct(char,*((int,int)->(int))))
,	O
ic	int
)	O
;	O
ic	int
=	O
ANYOTHERKEY	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
ISFUNC	int
&&	O
data	*(void)
==	O
0	int
)	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
_rl_null_function	(int,int)->(int)
;	O
}	O
map	*(struct(char,*((int,int)->(int))))
[	O
ic	int
]	O
.	O
function	*((int,int)->(int))
=	O
KEYMAP_TO_FUNCTION	O
(	O
data	*(void)
)	O
;	O
map	*(struct(char,*((int,int)->(int))))
[	O
ic	int
]	O
.	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
}	O
rl_binding_keymap	*(struct(char,*((int,int)->(int))))
=	O
map	*(struct(char,*((int,int)->(int))))
;	O
}	O
xfree	(*(void))->(void)
(	O
keys	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_translate_keyseq	(*(char),*(char),*(int))->(int)
(	O
seq	*(char)
,	O
array	*(char)
,	O
len	*(int)
)	O
const	O
char	O
*	O
seq	*(char)
;	O
char	O
*	O
array	*(char)
;	O
int	O
*	O
len	*(int)
;	O
{	O
register	O
int	O
i	int
,	O
c	int
,	O
l	int
,	O
temp	int
;	O
for	O
(	O
i	int
=	O
l	int
=	O
0	int
;	O
c	int
=	O
seq	*(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
c	int
=	O
seq	*(char)
[	O
++	O
i	int
]	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
c	int
==	O
'C'	O
||	O
c	int
==	O
'M'	O
)	O
&&	O
seq	*(char)
[	O
i	int
+	O
1	int
]	O
==	O
'-'	O
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
&	O
seq	*(char)
[	O
i	int
]	O
,	O
"C-\\M-"	*(char)
,	O
5	int
)	O
==	O
0	int
)	O
{	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
ESC	O
;	O
i	int
+=	O
5	int
;	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
CTRL	O
(	O
_rl_to_upper	(int)->(int)
(	O
seq	*(char)
[	O
i	int
]	O
)	O
)	O
;	O
if	O
(	O
seq	*(char)
[	O
i	int
]	O
==	O
'\0'	O
)	O
i	int
--	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'M'	O
)	O
{	O
i	int
++	O
;	O
if	O
(	O
_rl_convert_meta_chars_to_ascii	int
&&	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
[	O
ESC	O
]	O
.	O
type	enum(int,int,int,int)
==	O
ISKMAP	int
)	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
ESC	O
;	O
else	O
if	O
(	O
seq	*(char)
[	O
i	int
+	O
1	int
]	O
==	O
'\\'	O
&&	O
seq	*(char)
[	O
i	int
+	O
2	int
]	O
==	O
'C'	O
&&	O
seq	*(char)
[	O
i	int
+	O
3	int
]	O
==	O
'-'	O
)	O
{	O
i	int
+=	O
4	int
;	O
temp	int
=	O
(	O
seq	*(char)
[	O
i	int
]	O
==	O
'?'	O
)	O
?	O
RUBOUT	int
:	O
CTRL	O
(	O
_rl_to_upper	(int)->(int)
(	O
seq	*(char)
[	O
i	int
]	O
)	O
)	O
;	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
META	O
(	O
temp	int
)	O
;	O
}	O
else	O
{	O
i	int
++	O
;	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
META	O
(	O
seq	*(char)
[	O
i	int
]	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
c	int
==	O
'C'	O
)	O
{	O
i	int
+=	O
2	int
;	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
(	O
seq	*(char)
[	O
i	int
]	O
==	O
'?'	O
)	O
?	O
RUBOUT	int
:	O
CTRL	O
(	O
_rl_to_upper	(int)->(int)
(	O
seq	*(char)
[	O
i	int
]	O
)	O
)	O
;	O
}	O
continue	O
;	O
}	O
switch	O
(	O
c	int
)	O
{	O
case	O
'a'	O
:	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
'\007'	O
;	O
break	O
;	O
case	O
'b'	O
:	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
'\b'	O
;	O
break	O
;	O
case	O
'd'	O
:	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
RUBOUT	int
;	O
break	O
;	O
case	O
'e'	O
:	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
ESC	O
;	O
break	O
;	O
case	O
'f'	O
:	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
'\f'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
NEWLINE	char
;	O
break	O
;	O
case	O
'r'	O
:	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
RETURN	O
;	O
break	O
;	O
case	O
't'	O
:	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
TAB	char
;	O
break	O
;	O
case	O
'v'	O
:	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
0x0B	int
;	O
break	O
;	O
case	O
'\\'	O
:	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
'\\'	O
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
i	int
++	O
;	O
for	O
(	O
temp	int
=	O
2	int
,	O
c	int
-=	O
'0'	O
;	O
ISOCTAL	O
(	O
(	O
unsigned	O
char	O
)	O
seq	*(char)
[	O
i	int
]	O
)	O
&&	O
temp	int
--	O
;	O
i	int
++	O
)	O
c	int
=	O
(	O
c	int
*	O
8	int
)	O
+	O
OCTVALUE	O
(	O
seq	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
--	O
;	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
c	int
&	O
largest_char	int
;	O
break	O
;	O
case	O
'x'	O
:	O
i	int
++	O
;	O
for	O
(	O
temp	int
=	O
2	int
,	O
c	int
=	O
0	int
;	O
ISXDIGIT	O
(	O
(	O
unsigned	O
char	O
)	O
seq	*(char)
[	O
i	int
]	O
)	O
&&	O
temp	int
--	O
;	O
i	int
++	O
)	O
c	int
=	O
(	O
c	int
*	O
16	int
)	O
+	O
HEXVALUE	O
(	O
seq	*(char)
[	O
i	int
]	O
)	O
;	O
if	O
(	O
temp	int
==	O
2	int
)	O
c	int
=	O
'x'	O
;	O
i	int
--	O
;	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
c	int
&	O
largest_char	int
;	O
break	O
;	O
default	O
:	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
c	int
;	O
break	O
;	O
}	O
continue	O
;	O
}	O
array	*(char)
[	O
l	int
++	O
]	O
=	O
c	int
;	O
}	O
*	O
len	*(int)
=	O
l	int
;	O
array	*(char)
[	O
l	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
_rl_isescape	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\007'	O
:	O
case	O
'\b'	O
:	O
case	O
'\f'	O
:	O
case	O
'\n'	O
:	O
case	O
'\r'	O
:	O
case	O
TAB	char
:	O
case	O
0x0b	int
:	O
return	O
(	O
1	int
)	O
;	O
default	O
:	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
int	O
_rl_escchar	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\007'	O
:	O
return	O
(	O
'a'	O
)	O
;	O
case	O
'\b'	O
:	O
return	O
(	O
'b'	O
)	O
;	O
case	O
'\f'	O
:	O
return	O
(	O
'f'	O
)	O
;	O
case	O
'\n'	O
:	O
return	O
(	O
'n'	O
)	O
;	O
case	O
'\r'	O
:	O
return	O
(	O
'r'	O
)	O
;	O
case	O
TAB	char
:	O
return	O
(	O
't'	O
)	O
;	O
case	O
0x0b	int
:	O
return	O
(	O
'v'	O
)	O
;	O
default	O
:	O
return	O
(	O
c	int
)	O
;	O
}	O
}	O
char	O
*	O
rl_untranslate_keyseq	(int)->(*(char))
(	O
seq	*(char)
)	O
int	O
seq	*(char)
;	O
{	O
static	O
char	O
kseq	*(char)
[	O
16	int
]	O
;	O
int	O
i	int
,	O
c	int
;	O
i	int
=	O
0	int
;	O
c	int
=	O
seq	*(char)
;	O
if	O
(	O
META_CHAR	O
(	O
c	int
)	O
)	O
{	O
kseq	*(char)
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
kseq	*(char)
[	O
i	int
++	O
]	O
=	O
'M'	O
;	O
kseq	*(char)
[	O
i	int
++	O
]	O
=	O
'-'	O
;	O
c	int
=	O
UNMETA	O
(	O
c	int
)	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
ESC	O
)	O
{	O
kseq	*(char)
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
c	int
=	O
'e'	O
;	O
}	O
else	O
if	O
(	O
CTRL_CHAR	O
(	O
c	int
)	O
)	O
{	O
kseq	*(char)
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
kseq	*(char)
[	O
i	int
++	O
]	O
=	O
'C'	O
;	O
kseq	*(char)
[	O
i	int
++	O
]	O
=	O
'-'	O
;	O
c	int
=	O
_rl_to_lower	(int)->(int)
(	O
UNCTRL	O
(	O
c	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
RUBOUT	int
)	O
{	O
kseq	*(char)
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
kseq	*(char)
[	O
i	int
++	O
]	O
=	O
'C'	O
;	O
kseq	*(char)
[	O
i	int
++	O
]	O
=	O
'-'	O
;	O
c	int
=	O
'?'	O
;	O
}	O
if	O
(	O
c	int
==	O
ESC	O
)	O
{	O
kseq	*(char)
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
c	int
=	O
'e'	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\\'	O
||	O
c	int
==	O
'"'	O
)	O
{	O
kseq	*(char)
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
}	O
kseq	*(char)
[	O
i	int
++	O
]	O
=	O
(	O
unsigned	O
char	O
)	O
c	int
;	O
kseq	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
return	O
kseq	*(char)
;	O
}	O
char	O
*	O
_rl_untranslate_macro_value	(*(char),int)->(*(char))
(	O
seq	*(char)
,	O
use_escapes	int
)	O
char	O
*	O
seq	*(char)
;	O
int	O
use_escapes	int
;	O
{	O
char	O
*	O
ret	*(char)
,	O
*	O
r	*(char)
,	O
*	O
s	*(char)
;	O
int	O
c	int
;	O
r	*(char)
=	O
ret	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
7	int
*	O
strlen	(*(char))->(long)
(	O
seq	*(char)
)	O
+	O
1	int
)	O
;	O
for	O
(	O
s	*(char)
=	O
seq	*(char)
;	O
*	O
s	*(char)
;	O
s	*(char)
++	O
)	O
{	O
c	int
=	O
*	O
s	*(char)
;	O
if	O
(	O
META_CHAR	O
(	O
c	int
)	O
)	O
{	O
*	O
r	*(char)
++	O
=	O
'\\'	O
;	O
*	O
r	*(char)
++	O
=	O
'M'	O
;	O
*	O
r	*(char)
++	O
=	O
'-'	O
;	O
c	int
=	O
UNMETA	O
(	O
c	int
)	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
ESC	O
)	O
{	O
*	O
r	*(char)
++	O
=	O
'\\'	O
;	O
c	int
=	O
'e'	O
;	O
}	O
else	O
if	O
(	O
CTRL_CHAR	O
(	O
c	int
)	O
)	O
{	O
*	O
r	*(char)
++	O
=	O
'\\'	O
;	O
if	O
(	O
use_escapes	int
&&	O
_rl_isescape	(int)->(int)
(	O
c	int
)	O
)	O
c	int
=	O
_rl_escchar	(int)->(int)
(	O
c	int
)	O
;	O
else	O
{	O
*	O
r	*(char)
++	O
=	O
'C'	O
;	O
*	O
r	*(char)
++	O
=	O
'-'	O
;	O
c	int
=	O
_rl_to_lower	(int)->(int)
(	O
UNCTRL	O
(	O
c	int
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
c	int
==	O
RUBOUT	int
)	O
{	O
*	O
r	*(char)
++	O
=	O
'\\'	O
;	O
*	O
r	*(char)
++	O
=	O
'C'	O
;	O
*	O
r	*(char)
++	O
=	O
'-'	O
;	O
c	int
=	O
'?'	O
;	O
}	O
if	O
(	O
c	int
==	O
ESC	O
)	O
{	O
*	O
r	*(char)
++	O
=	O
'\\'	O
;	O
c	int
=	O
'e'	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\\'	O
||	O
c	int
==	O
'"'	O
)	O
*	O
r	*(char)
++	O
=	O
'\\'	O
;	O
*	O
r	*(char)
++	O
=	O
(	O
unsigned	O
char	O
)	O
c	int
;	O
}	O
*	O
r	*(char)
=	O
'\0'	O
;	O
return	O
ret	*(char)
;	O
}	O
rl_command_func_t	(int,int)->(int)
*	O
rl_named_function	(*(char))->(*((int,int)->(int)))
(	O
string	*(char)
)	O
const	O
char	O
*	O
string	*(char)
;	O
{	O
register	O
int	O
i	int
;	O
rl_initialize_funmap	()->(void)
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
funmap	*(*(struct(*(char),*((int,int)->(int)))))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
_rl_stricmp	O
(	O
funmap	*(*(struct(*(char),*((int,int)->(int)))))
[	O
i	int
]	O
->	O
name	*(char)
,	O
string	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
funmap	*(*(struct(*(char),*((int,int)->(int)))))
[	O
i	int
]	O
->	O
function	*((int,int)->(int))
)	O
;	O
return	O
(	O
(	O
rl_command_func_t	(int,int)->(int)
*	O
)	O
NULL	O
)	O
;	O
}	O
rl_command_func_t	(int,int)->(int)
*	O
rl_function_of_keyseq	(*(char),*(struct(char,*((int,int)->(int)))),*(int))->(*((int,int)->(int)))
(	O
keyseq	array(char)
,	O
map	*(struct(char,*((int,int)->(int))))
,	O
type	enum(int,int,int,int)
)	O
const	O
char	O
*	O
keyseq	array(char)
;	O
Keymap	*(struct(char,*((int,int)->(int))))
map	*(struct(char,*((int,int)->(int))))
;	O
int	O
*	O
type	enum(int,int,int,int)
;	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
map	*(struct(char,*((int,int)->(int))))
==	O
0	int
)	O
map	*(struct(char,*((int,int)->(int))))
=	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
;	O
for	O
(	O
i	int
=	O
0	int
;	O
keyseq	array(char)
&&	O
keyseq	array(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
unsigned	O
char	O
ic	int
=	O
keyseq	array(char)
[	O
i	int
]	O
;	O
if	O
(	O
META_CHAR	O
(	O
ic	int
)	O
&&	O
_rl_convert_meta_chars_to_ascii	int
)	O
{	O
if	O
(	O
map	*(struct(char,*((int,int)->(int))))
[	O
ESC	O
]	O
.	O
type	enum(int,int,int,int)
==	O
ISKMAP	int
)	O
{	O
map	*(struct(char,*((int,int)->(int))))
=	O
FUNCTION_TO_KEYMAP	O
(	O
map	*(struct(char,*((int,int)->(int))))
,	O
ESC	O
)	O
;	O
ic	int
=	O
UNMETA	O
(	O
ic	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
type	enum(int,int,int,int)
)	O
*	O
type	enum(int,int,int,int)
=	O
map	*(struct(char,*((int,int)->(int))))
[	O
ESC	O
]	O
.	O
type	enum(int,int,int,int)
;	O
return	O
(	O
map	*(struct(char,*((int,int)->(int))))
[	O
ESC	O
]	O
.	O
function	*((int,int)->(int))
)	O
;	O
}	O
}	O
if	O
(	O
map	*(struct(char,*((int,int)->(int))))
[	O
ic	int
]	O
.	O
type	enum(int,int,int,int)
==	O
ISKMAP	int
)	O
{	O
if	O
(	O
keyseq	array(char)
[	O
i	int
+	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
)	O
*	O
type	enum(int,int,int,int)
=	O
ISKMAP	int
;	O
return	O
(	O
map	*(struct(char,*((int,int)->(int))))
[	O
ic	int
]	O
.	O
function	*((int,int)->(int))
)	O
;	O
}	O
else	O
map	*(struct(char,*((int,int)->(int))))
=	O
FUNCTION_TO_KEYMAP	O
(	O
map	*(struct(char,*((int,int)->(int))))
,	O
ic	int
)	O
;	O
}	O
else	O
if	O
(	O
map	*(struct(char,*((int,int)->(int))))
[	O
ic	int
]	O
.	O
type	enum(int,int,int,int)
!=	O
ISKMAP	int
&&	O
keyseq	array(char)
[	O
i	int
+	O
1	int
]	O
)	O
return	O
(	O
(	O
rl_command_func_t	(int,int)->(int)
*	O
)	O
NULL	O
)	O
;	O
else	O
{	O
if	O
(	O
type	enum(int,int,int,int)
)	O
*	O
type	enum(int,int,int,int)
=	O
map	*(struct(char,*((int,int)->(int))))
[	O
ic	int
]	O
.	O
type	enum(int,int,int,int)
;	O
return	O
(	O
map	*(struct(char,*((int,int)->(int))))
[	O
ic	int
]	O
.	O
function	*((int,int)->(int))
)	O
;	O
}	O
}	O
return	O
(	O
(	O
rl_command_func_t	(int,int)->(int)
*	O
)	O
NULL	O
)	O
;	O
}	O
static	O
char	O
*	O
last_readline_init_file	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
const	O
char	O
*	O
current_readline_init_file	*(char)
;	O
static	O
int	O
current_readline_init_include_level	int
;	O
static	O
int	O
current_readline_init_lineno	int
;	O
static	O
char	O
*	O
_rl_read_file	(*(char),*(long))->(*(char))
(	O
filename	*(char)
,	O
sizep	*(long)
)	O
char	O
*	O
filename	*(char)
;	O
size_t	long
*	O
sizep	*(long)
;	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
size_t	long
file_size	long
;	O
char	O
*	O
buffer	*(char)
;	O
int	O
i	int
,	O
file	int
;	O
if	O
(	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
filename	*(char)
,	O
&	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
||	O
(	O
file	int
=	O
open	(*(char),int)->(int)
(	O
filename	*(char)
,	O
O_RDONLY	int
,	O
0666	int
)	O
)	O
<	O
0	int
)	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
file_size	long
=	O
(	O
size_t	long
)	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
;	O
if	O
(	O
file_size	long
!=	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
||	O
file_size	long
+	O
1	int
<	O
file_size	long
)	O
{	O
if	O
(	O
file	int
>=	O
0	int
)	O
close	*((*(void))->(int))
(	O
file	int
)	O
;	O
errno	O
=	O
EFBIG	int
;	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
buffer	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
file_size	long
+	O
1	int
)	O
;	O
i	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
file	int
,	O
buffer	*(char)
,	O
file_size	long
)	O
;	O
close	*((*(void))->(int))
(	O
file	int
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
xfree	(*(void))->(void)
(	O
buffer	*(char)
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
buffer	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
sizep	*(long)
)	O
*	O
sizep	*(long)
=	O
i	int
;	O
return	O
(	O
buffer	*(char)
)	O
;	O
}	O
int	O
rl_re_read_init_file	(int,int)->(int)
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
int	O
r	*(char)
;	O
r	*(char)
=	O
rl_read_init_file	(*(char))->(int)
(	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
rl_set_keymap_from_edit_mode	()->(void)
(	O
)	O
;	O
return	O
r	*(char)
;	O
}	O
int	O
rl_read_init_file	(*(char))->(int)
(	O
filename	*(char)
)	O
const	O
char	O
*	O
filename	*(char)
;	O
{	O
if	O
(	O
filename	*(char)
==	O
0	int
)	O
filename	*(char)
=	O
last_readline_init_file	*(char)
;	O
if	O
(	O
filename	*(char)
==	O
0	int
)	O
filename	*(char)
=	O
sh_get_env_value	(*(char))->(*(char))
(	O
"INPUTRC"	*(char)
)	O
;	O
if	O
(	O
filename	*(char)
==	O
0	int
||	O
*	O
filename	*(char)
==	O
0	int
)	O
{	O
filename	*(char)
=	O
DEFAULT_INPUTRC	*(char)
;	O
if	O
(	O
_rl_read_init_file	(*(char),int)->(int)
(	O
filename	*(char)
,	O
0	int
)	O
==	O
0	int
)	O
return	O
0	int
;	O
filename	*(char)
=	O
SYS_INPUTRC	*(char)
;	O
}	O
return	O
(	O
_rl_read_init_file	(*(char),int)->(int)
(	O
filename	*(char)
,	O
0	int
)	O
)	O
;	O
}	O
static	O
int	O
_rl_read_init_file	(*(char),int)->(int)
(	O
filename	*(char)
,	O
include_level	int
)	O
const	O
char	O
*	O
filename	*(char)
;	O
int	O
include_level	int
;	O
{	O
register	O
int	O
i	int
;	O
char	O
*	O
buffer	*(char)
,	O
*	O
openname	*(char)
,	O
*	O
line	*(char)
,	O
*	O
end	int
;	O
size_t	long
file_size	long
;	O
current_readline_init_file	*(char)
=	O
filename	*(char)
;	O
current_readline_init_include_level	int
=	O
include_level	int
;	O
openname	*(char)
=	O
tilde_expand	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
buffer	*(char)
=	O
_rl_read_file	(*(char),*(long))->(*(char))
(	O
openname	*(char)
,	O
&	O
file_size	long
)	O
;	O
xfree	(*(void))->(void)
(	O
openname	*(char)
)	O
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
if	O
(	O
buffer	*(char)
==	O
0	int
)	O
return	O
(	O
errno	O
)	O
;	O
if	O
(	O
include_level	int
==	O
0	int
&&	O
filename	*(char)
!=	O
last_readline_init_file	*(char)
)	O
{	O
FREE	O
(	O
last_readline_init_file	*(char)
)	O
;	O
last_readline_init_file	*(char)
=	O
savestring	O
(	O
filename	*(char)
)	O
;	O
}	O
currently_reading_init_file	int
=	O
1	int
;	O
current_readline_init_lineno	int
=	O
1	int
;	O
line	*(char)
=	O
buffer	*(char)
;	O
end	int
=	O
buffer	*(char)
+	O
file_size	long
;	O
while	O
(	O
line	*(char)
<	O
end	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
line	*(char)
+	O
i	int
!=	O
end	int
&&	O
line	*(char)
[	O
i	int
]	O
!=	O
'\n'	O
;	O
i	int
++	O
)	O
;	O
line	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
*	O
line	*(char)
&&	O
whitespace	O
(	O
*	O
line	*(char)
)	O
)	O
{	O
line	*(char)
++	O
;	O
i	int
--	O
;	O
}	O
if	O
(	O
*	O
line	*(char)
&&	O
*	O
line	*(char)
!=	O
'#'	O
)	O
rl_parse_and_bind	(*(char))->(int)
(	O
line	*(char)
)	O
;	O
line	*(char)
+=	O
i	int
+	O
1	int
;	O
current_readline_init_lineno	int
++	O
;	O
}	O
xfree	(*(void))->(void)
(	O
buffer	*(char)
)	O
;	O
currently_reading_init_file	int
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
_rl_init_file_error	(*(char))->(void)
(	O
const	O
char	O
*	O
format	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
format	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"readline: "	*(char)
)	O
;	O
if	O
(	O
currently_reading_init_file	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: line %d: "	*(char)
,	O
current_readline_init_file	*(char)
,	O
current_readline_init_lineno	int
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
format	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
typedef	O
int	O
_rl_parser_func_t	(*(char))->(int)
PARAMS	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
const	O
char	O
*	O
const	O
_rl_possible_control_prefixes	array(*(char))
[	O
]	O
=	O
{	O
"Control-"	*(char)
,	O
"C-"	*(char)
,	O
"CTRL-"	*(char)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
}	O
;	O
const	O
char	O
*	O
const	O
_rl_possible_meta_prefixes	array(*(char))
[	O
]	O
=	O
{	O
"Meta"	*(char)
,	O
"M-"	*(char)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
}	O
;	O
const	O
char	O
*	O
rl_readline_name	*(char)
=	O
"other"	*(char)
;	O
static	O
unsigned	O
char	O
*	O
if_stack	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
NULL	O
;	O
static	O
int	O
if_stack_depth	int
;	O
static	O
int	O
if_stack_size	int
;	O
static	O
int	O
parser_if	(*(char))->(int)
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
char	O
*	O
args	array(struct(int,int,*(void),*(void)))
;	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
if_stack_depth	int
+	O
1	int
>=	O
if_stack_size	int
)	O
{	O
if	O
(	O
!	O
if_stack	*(char)
)	O
if_stack	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
if_stack_size	int
=	O
20	int
)	O
;	O
else	O
if_stack	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
if_stack	*(char)
,	O
if_stack_size	int
+=	O
20	int
)	O
;	O
}	O
if_stack	*(char)
[	O
if_stack_depth	int
++	O
]	O
=	O
_rl_parsing_conditionalized_out	char
;	O
if	O
(	O
_rl_parsing_conditionalized_out	char
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
args	array(struct(int,int,*(void),*(void)))
[	O
i	int
]	O
&&	O
!	O
whitespace	O
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
i	int
]	O
)	O
args	array(struct(int,int,*(void),*(void)))
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
rl_terminal_name	*(char)
&&	O
_rl_strnicmp	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
"term="	*(char)
,	O
5	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
tem	*(char)
,	O
*	O
tname	*(char)
;	O
tname	*(char)
=	O
savestring	O
(	O
rl_terminal_name	*(char)
)	O
;	O
tem	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
tname	*(char)
,	O
'-'	O
)	O
;	O
if	O
(	O
tem	*(char)
)	O
*	O
tem	*(char)
=	O
'\0'	O
;	O
_rl_parsing_conditionalized_out	char
=	O
_rl_stricmp	O
(	O
args	array(struct(int,int,*(void),*(void)))
+	O
5	int
,	O
tname	*(char)
)	O
&&	O
_rl_stricmp	O
(	O
args	array(struct(int,int,*(void),*(void)))
+	O
5	int
,	O
rl_terminal_name	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
tname	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
_rl_strnicmp	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
"mode="	*(char)
,	O
5	int
)	O
==	O
0	int
)	O
{	O
int	O
mode	int
;	O
if	O
(	O
_rl_stricmp	O
(	O
args	array(struct(int,int,*(void),*(void)))
+	O
5	int
,	O
"emacs"	*(char)
)	O
==	O
0	int
)	O
mode	int
=	O
emacs_mode	int
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
args	array(struct(int,int,*(void),*(void)))
+	O
5	int
,	O
"vi"	*(char)
)	O
==	O
0	int
)	O
mode	int
=	O
vi_mode	int
;	O
else	O
mode	int
=	O
no_mode	O
;	O
_rl_parsing_conditionalized_out	char
=	O
mode	int
!=	O
rl_editing_mode	int
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
rl_readline_name	*(char)
)	O
==	O
0	int
)	O
_rl_parsing_conditionalized_out	char
=	O
0	int
;	O
else	O
_rl_parsing_conditionalized_out	char
=	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parser_else	(*(char))->(int)
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
char	O
*	O
args	array(struct(int,int,*(void),*(void)))
;	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
if_stack_depth	int
==	O
0	int
)	O
{	O
_rl_init_file_error	(*(char))->(void)
(	O
"$else found without matching $if"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
if_stack_depth	int
;	O
i	int
++	O
)	O
if	O
(	O
if_stack	*(char)
[	O
i	int
]	O
==	O
1	int
)	O
return	O
0	int
;	O
_rl_parsing_conditionalized_out	char
=	O
!	O
_rl_parsing_conditionalized_out	char
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parser_endif	(*(char))->(int)
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
char	O
*	O
args	array(struct(int,int,*(void),*(void)))
;	O
{	O
if	O
(	O
if_stack_depth	int
)	O
_rl_parsing_conditionalized_out	char
=	O
if_stack	*(char)
[	O
--	O
if_stack_depth	int
]	O
;	O
else	O
_rl_init_file_error	(*(char))->(void)
(	O
"$endif without matching $if"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parser_include	(*(char))->(int)
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
char	O
*	O
args	array(struct(int,int,*(void),*(void)))
;	O
{	O
const	O
char	O
*	O
old_init_file	*(char)
;	O
char	O
*	O
e	*(char)
;	O
int	O
old_line_number	int
,	O
old_include_level	int
,	O
r	*(char)
;	O
if	O
(	O
_rl_parsing_conditionalized_out	char
)	O
return	O
(	O
0	int
)	O
;	O
old_init_file	*(char)
=	O
current_readline_init_file	*(char)
;	O
old_line_number	int
=	O
current_readline_init_lineno	int
;	O
old_include_level	int
=	O
current_readline_init_include_level	int
;	O
e	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
'\n'	O
)	O
;	O
if	O
(	O
e	*(char)
)	O
*	O
e	*(char)
=	O
'\0'	O
;	O
r	*(char)
=	O
_rl_read_init_file	(*(char),int)->(int)
(	O
(	O
const	O
char	O
*	O
)	O
args	array(struct(int,int,*(void),*(void)))
,	O
old_include_level	int
+	O
1	int
)	O
;	O
current_readline_init_file	*(char)
=	O
old_init_file	*(char)
;	O
current_readline_init_lineno	int
=	O
old_line_number	int
;	O
current_readline_init_include_level	int
=	O
old_include_level	int
;	O
return	O
r	*(char)
;	O
}	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
const	O
name	*(char)
;	O
_rl_parser_func_t	(*(char))->(int)
*	O
function	*((int,int)->(int))
;	O
}	O
parser_directives	array(struct(*(char),*((*(char))->(int))))
[	O
]	O
=	O
{	O
{	O
"if"	*(char)
,	O
parser_if	(*(char))->(int)
}	O
,	O
{	O
"endif"	*(char)
,	O
parser_endif	(*(char))->(int)
}	O
,	O
{	O
"else"	*(char)
,	O
parser_else	(*(char))->(int)
}	O
,	O
{	O
"include"	*(char)
,	O
parser_include	(*(char))->(int)
}	O
,	O
{	O
(	O
char	O
*	O
)	O
0x0	int
,	O
(	O
_rl_parser_func_t	(*(char))->(int)
*	O
)	O
0x0	int
}	O
}	O
;	O
static	O
int	O
handle_parser_directive	(*(char))->(int)
(	O
statement	*(char)
)	O
char	O
*	O
statement	*(char)
;	O
{	O
register	O
int	O
i	int
;	O
char	O
*	O
directive	*(char)
,	O
*	O
args	array(struct(int,int,*(void),*(void)))
;	O
for	O
(	O
i	int
=	O
0	int
;	O
whitespace	O
(	O
statement	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
directive	*(char)
=	O
&	O
statement	*(char)
[	O
i	int
]	O
;	O
for	O
(	O
;	O
statement	*(char)
[	O
i	int
]	O
&&	O
!	O
whitespace	O
(	O
statement	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
statement	*(char)
[	O
i	int
]	O
)	O
statement	*(char)
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
for	O
(	O
;	O
statement	*(char)
[	O
i	int
]	O
&&	O
whitespace	O
(	O
statement	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
args	array(struct(int,int,*(void),*(void)))
=	O
&	O
statement	*(char)
[	O
i	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
parser_directives	array(struct(*(char),*((*(char))->(int))))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
if	O
(	O
_rl_stricmp	O
(	O
directive	*(char)
,	O
parser_directives	array(struct(*(char),*((*(char))->(int))))
[	O
i	int
]	O
.	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
(	O
*	O
parser_directives	array(struct(*(char),*((*(char))->(int))))
[	O
i	int
]	O
.	O
function	*((int,int)->(int))
)	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
_rl_init_file_error	(*(char))->(void)
(	O
"%s: unknown parser directive"	*(char)
,	O
directive	*(char)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
static	O
int	O
_rl_skip_to_delim	(*(char),int,int)->(int)
(	O
string	*(char)
,	O
start	int
,	O
delim	int
)	O
char	O
*	O
string	*(char)
;	O
int	O
start	int
,	O
delim	int
;	O
{	O
int	O
i	int
,	O
c	int
,	O
passc	int
;	O
for	O
(	O
i	int
=	O
start	int
,	O
passc	int
=	O
0	int
;	O
c	int
=	O
string	*(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
passc	int
)	O
{	O
passc	int
=	O
0	int
;	O
if	O
(	O
c	int
==	O
0	int
)	O
break	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
passc	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
==	O
delim	int
)	O
break	O
;	O
}	O
return	O
i	int
;	O
}	O
int	O
rl_parse_and_bind	(*(char))->(int)
(	O
string	*(char)
)	O
char	O
*	O
string	*(char)
;	O
{	O
char	O
*	O
funname	*(char)
,	O
*	O
kname	*(char)
;	O
register	O
int	O
c	int
,	O
i	int
;	O
int	O
key	int
,	O
equivalency	int
,	O
foundmod	int
,	O
foundsep	int
;	O
while	O
(	O
string	*(char)
&&	O
whitespace	O
(	O
*	O
string	*(char)
)	O
)	O
string	*(char)
++	O
;	O
if	O
(	O
string	*(char)
==	O
0	int
||	O
*	O
string	*(char)
==	O
0	int
||	O
*	O
string	*(char)
==	O
'#'	O
)	O
return	O
0	int
;	O
if	O
(	O
*	O
string	*(char)
==	O
'$'	O
)	O
{	O
handle_parser_directive	(*(char))->(int)
(	O
&	O
string	*(char)
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
_rl_parsing_conditionalized_out	char
)	O
return	O
0	int
;	O
i	int
=	O
0	int
;	O
if	O
(	O
*	O
string	*(char)
==	O
'"'	O
)	O
{	O
i	int
=	O
_rl_skip_to_delim	(*(char),int,int)->(int)
(	O
string	*(char)
,	O
1	int
,	O
'"'	O
)	O
;	O
if	O
(	O
string	*(char)
[	O
i	int
]	O
==	O
'\0'	O
)	O
{	O
_rl_init_file_error	(*(char))->(void)
(	O
"%s: no closing `\"' in key binding"	*(char)
,	O
string	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
else	O
i	int
++	O
;	O
}	O
for	O
(	O
;	O
(	O
c	int
=	O
string	*(char)
[	O
i	int
]	O
)	O
&&	O
c	int
!=	O
':'	O
&&	O
c	int
!=	O
' '	O
&&	O
c	int
!=	O
'\t'	O
;	O
i	int
++	O
)	O
;	O
equivalency	int
=	O
(	O
c	int
==	O
':'	O
&&	O
string	*(char)
[	O
i	int
+	O
1	int
]	O
==	O
'='	O
)	O
;	O
foundsep	int
=	O
c	int
!=	O
0	int
;	O
if	O
(	O
string	*(char)
[	O
i	int
]	O
)	O
string	*(char)
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
equivalency	int
)	O
string	*(char)
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
_rl_stricmp	O
(	O
string	*(char)
,	O
"set"	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
var	*(char)
,	O
*	O
value	*(char)
,	O
*	O
e	*(char)
;	O
int	O
s	*(char)
;	O
var	*(char)
=	O
string	*(char)
+	O
i	int
;	O
while	O
(	O
*	O
var	*(char)
&&	O
whitespace	O
(	O
*	O
var	*(char)
)	O
)	O
var	*(char)
++	O
;	O
value	*(char)
=	O
var	*(char)
;	O
while	O
(	O
*	O
value	*(char)
&&	O
whitespace	O
(	O
*	O
value	*(char)
)	O
==	O
0	int
)	O
value	*(char)
++	O
;	O
if	O
(	O
*	O
value	*(char)
)	O
*	O
value	*(char)
++	O
=	O
'\0'	O
;	O
while	O
(	O
*	O
value	*(char)
&&	O
whitespace	O
(	O
*	O
value	*(char)
)	O
)	O
value	*(char)
++	O
;	O
if	O
(	O
find_boolean_var	(*(char))->(int)
(	O
var	*(char)
)	O
>=	O
0	int
)	O
{	O
remove_trailing	O
:	O
e	*(char)
=	O
value	*(char)
+	O
strlen	(*(char))->(long)
(	O
value	*(char)
)	O
-	O
1	int
;	O
while	O
(	O
e	*(char)
>=	O
value	*(char)
&&	O
whitespace	O
(	O
*	O
e	*(char)
)	O
)	O
e	*(char)
--	O
;	O
e	*(char)
++	O
;	O
if	O
(	O
*	O
e	*(char)
&&	O
e	*(char)
>=	O
value	*(char)
)	O
*	O
e	*(char)
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
(	O
i	int
=	O
find_string_var	(*(char))->(int)
(	O
var	*(char)
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
*	O
value	*(char)
==	O
'"'	O
)	O
{	O
i	int
=	O
_rl_skip_to_delim	(*(char),int,int)->(int)
(	O
value	*(char)
,	O
1	int
,	O
*	O
value	*(char)
)	O
;	O
value	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
value	*(char)
++	O
;	O
}	O
else	O
goto	O
remove_trailing	O
;	O
}	O
rl_variable_bind	(*(char),*(char))->(int)
(	O
var	*(char)
,	O
value	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
;	O
string	*(char)
[	O
i	int
]	O
&&	O
whitespace	O
(	O
string	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
funname	*(char)
=	O
&	O
string	*(char)
[	O
i	int
]	O
;	O
if	O
(	O
*	O
funname	*(char)
==	O
'\''	O
||	O
*	O
funname	*(char)
==	O
'"'	O
)	O
{	O
i	int
=	O
_rl_skip_to_delim	(*(char),int,int)->(int)
(	O
string	*(char)
,	O
i	int
+	O
1	int
,	O
*	O
funname	*(char)
)	O
;	O
if	O
(	O
string	*(char)
[	O
i	int
]	O
)	O
i	int
++	O
;	O
}	O
for	O
(	O
;	O
string	*(char)
[	O
i	int
]	O
&&	O
whitespace	O
(	O
string	*(char)
[	O
i	int
]	O
)	O
==	O
0	int
;	O
i	int
++	O
)	O
;	O
string	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
equivalency	int
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
foundsep	int
==	O
0	int
)	O
{	O
_rl_init_file_error	(*(char))->(void)
(	O
"%s: no key sequence terminator"	*(char)
,	O
string	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
*	O
string	*(char)
==	O
'"'	O
)	O
{	O
char	O
*	O
seq	*(char)
;	O
register	O
int	O
j	int
,	O
k	struct(char,*((int,int)->(int)))
,	O
passc	int
;	O
seq	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
1	int
+	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
)	O
;	O
for	O
(	O
j	int
=	O
1	int
,	O
k	struct(char,*((int,int)->(int)))
=	O
passc	int
=	O
0	int
;	O
string	*(char)
[	O
j	int
]	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
passc	int
||	O
(	O
string	*(char)
[	O
j	int
]	O
==	O
'\\'	O
)	O
)	O
{	O
seq	*(char)
[	O
k	struct(char,*((int,int)->(int)))
++	O
]	O
=	O
string	*(char)
[	O
j	int
]	O
;	O
passc	int
=	O
!	O
passc	int
;	O
continue	O
;	O
}	O
if	O
(	O
string	*(char)
[	O
j	int
]	O
==	O
'"'	O
)	O
break	O
;	O
seq	*(char)
[	O
k	struct(char,*((int,int)->(int)))
++	O
]	O
=	O
string	*(char)
[	O
j	int
]	O
;	O
}	O
seq	*(char)
[	O
k	struct(char,*((int,int)->(int)))
]	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
funname	*(char)
==	O
'\''	O
||	O
*	O
funname	*(char)
==	O
'"'	O
)	O
{	O
j	int
=	O
strlen	(*(char))->(long)
(	O
funname	*(char)
)	O
;	O
if	O
(	O
j	int
&&	O
funname	*(char)
[	O
j	int
-	O
1	int
]	O
==	O
*	O
funname	*(char)
)	O
funname	*(char)
[	O
j	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
rl_macro_bind	(*(char),*(char),*(struct(char,*((int,int)->(int)))))->(int)
(	O
seq	*(char)
,	O
&	O
funname	*(char)
[	O
1	int
]	O
,	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
)	O
;	O
}	O
else	O
rl_bind_keyseq	(*(char),*((int,int)->(int)))->(int)
(	O
seq	*(char)
,	O
rl_named_function	(*(char))->(*((int,int)->(int)))
(	O
funname	*(char)
)	O
)	O
;	O
xfree	(*(void))->(void)
(	O
seq	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
kname	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
string	*(char)
,	O
'-'	O
)	O
;	O
if	O
(	O
kname	*(char)
==	O
0	int
)	O
kname	*(char)
=	O
string	*(char)
;	O
else	O
kname	*(char)
++	O
;	O
key	int
=	O
glean_key_from_name	(*(char))->(int)
(	O
kname	*(char)
)	O
;	O
foundmod	int
=	O
0	int
;	O
if	O
(	O
substring_member_of_array	(*(char),*(*(char)))->(int)
(	O
string	*(char)
,	O
_rl_possible_control_prefixes	array(*(char))
)	O
)	O
{	O
key	int
=	O
CTRL	O
(	O
_rl_to_upper	(int)->(int)
(	O
key	int
)	O
)	O
;	O
foundmod	int
=	O
1	int
;	O
}	O
if	O
(	O
substring_member_of_array	(*(char),*(*(char)))->(int)
(	O
string	*(char)
,	O
_rl_possible_meta_prefixes	array(*(char))
)	O
)	O
{	O
key	int
=	O
META	O
(	O
key	int
)	O
;	O
foundmod	int
=	O
1	int
;	O
}	O
if	O
(	O
foundmod	int
==	O
0	int
&&	O
kname	*(char)
!=	O
string	*(char)
)	O
{	O
_rl_init_file_error	(*(char))->(void)
(	O
"%s: unknown key modifier"	*(char)
,	O
string	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
*	O
funname	*(char)
==	O
'\''	O
||	O
*	O
funname	*(char)
==	O
'"'	O
)	O
{	O
char	O
useq	array(char)
[	O
2	int
]	O
;	O
int	O
fl	int
=	O
strlen	(*(char))->(long)
(	O
funname	*(char)
)	O
;	O
useq	array(char)
[	O
0	int
]	O
=	O
key	int
;	O
useq	array(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
fl	int
&&	O
funname	*(char)
[	O
fl	int
-	O
1	int
]	O
==	O
*	O
funname	*(char)
)	O
funname	*(char)
[	O
fl	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
rl_macro_bind	(*(char),*(char),*(struct(char,*((int,int)->(int)))))->(int)
(	O
useq	array(char)
,	O
&	O
funname	*(char)
[	O
1	int
]	O
,	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
)	O
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
funname	*(char)
,	O
"prefix-meta"	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
seq	*(char)
[	O
2	int
]	O
;	O
seq	*(char)
[	O
0	int
]	O
=	O
key	int
;	O
seq	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
rl_generic_bind	(int,*(char),*(char),*(struct(char,*((int,int)->(int)))))->(int)
(	O
ISKMAP	int
,	O
seq	*(char)
,	O
(	O
char	O
*	O
)	O
emacs_meta_keymap	array(struct(char,*((int,int)->(int))))
,	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
)	O
;	O
}	O
else	O
rl_bind_key	(int,*((int,int)->(int)))->(int)
(	O
key	int
,	O
rl_named_function	(*(char))->(*((int,int)->(int)))
(	O
funname	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
const	O
name	*(char)
;	O
int	O
*	O
value	*(char)
;	O
int	O
flags	int
;	O
}	O
boolean_varlist	array(struct(*(char),*(int),int))
[	O
]	O
=	O
{	O
{	O
"bind-tty-special-chars"	*(char)
,	O
&	O
_rl_bind_stty_chars	int
,	O
0	int
}	O
,	O
{	O
"blink-matching-paren"	*(char)
,	O
&	O
rl_blink_matching_paren	int
,	O
V_SPECIAL	int
}	O
,	O
{	O
"byte-oriented"	*(char)
,	O
&	O
rl_byte_oriented	int
,	O
0	int
}	O
,	O
{	O
"colored-completion-prefix"	*(char)
,	O
&	O
_rl_colored_completion_prefix	int
,	O
0	int
}	O
,	O
{	O
"colored-stats"	*(char)
,	O
&	O
_rl_colored_stats	int
,	O
0	int
}	O
,	O
{	O
"completion-ignore-case"	*(char)
,	O
&	O
_rl_completion_case_fold	int
,	O
0	int
}	O
,	O
{	O
"completion-map-case"	*(char)
,	O
&	O
_rl_completion_case_map	int
,	O
0	int
}	O
,	O
{	O
"convert-meta"	*(char)
,	O
&	O
_rl_convert_meta_chars_to_ascii	int
,	O
0	int
}	O
,	O
{	O
"disable-completion"	*(char)
,	O
&	O
rl_inhibit_completion	int
,	O
0	int
}	O
,	O
{	O
"echo-control-characters"	*(char)
,	O
&	O
_rl_echo_control_chars	int
,	O
0	int
}	O
,	O
{	O
"enable-bracketed-paste"	*(char)
,	O
&	O
_rl_enable_bracketed_paste	int
,	O
0	int
}	O
,	O
{	O
"enable-keypad"	*(char)
,	O
&	O
_rl_enable_keypad	int
,	O
0	int
}	O
,	O
{	O
"enable-meta-key"	*(char)
,	O
&	O
_rl_enable_meta	int
,	O
0	int
}	O
,	O
{	O
"expand-tilde"	*(char)
,	O
&	O
rl_complete_with_tilde_expansion	int
,	O
0	int
}	O
,	O
{	O
"history-preserve-point"	*(char)
,	O
&	O
_rl_history_preserve_point	int
,	O
0	int
}	O
,	O
{	O
"horizontal-scroll-mode"	*(char)
,	O
&	O
_rl_horizontal_scroll_mode	int
,	O
0	int
}	O
,	O
{	O
"input-meta"	*(char)
,	O
&	O
_rl_meta_flag	int
,	O
0	int
}	O
,	O
{	O
"mark-directories"	*(char)
,	O
&	O
_rl_complete_mark_directories	int
,	O
0	int
}	O
,	O
{	O
"mark-modified-lines"	*(char)
,	O
&	O
_rl_mark_modified_lines	int
,	O
0	int
}	O
,	O
{	O
"mark-symlinked-directories"	*(char)
,	O
&	O
_rl_complete_mark_symlink_dirs	int
,	O
0	int
}	O
,	O
{	O
"match-hidden-files"	*(char)
,	O
&	O
_rl_match_hidden_files	int
,	O
0	int
}	O
,	O
{	O
"menu-complete-display-prefix"	*(char)
,	O
&	O
_rl_menu_complete_prefix_first	int
,	O
0	int
}	O
,	O
{	O
"meta-flag"	*(char)
,	O
&	O
_rl_meta_flag	int
,	O
0	int
}	O
,	O
{	O
"output-meta"	*(char)
,	O
&	O
_rl_output_meta_chars	int
,	O
0	int
}	O
,	O
{	O
"page-completions"	*(char)
,	O
&	O
_rl_page_completions	int
,	O
0	int
}	O
,	O
{	O
"prefer-visible-bell"	*(char)
,	O
&	O
_rl_prefer_visible_bell	int
,	O
V_SPECIAL	int
}	O
,	O
{	O
"print-completions-horizontally"	*(char)
,	O
&	O
_rl_print_completions_horizontally	int
,	O
0	int
}	O
,	O
{	O
"revert-all-at-newline"	*(char)
,	O
&	O
_rl_revert_all_at_newline	int
,	O
0	int
}	O
,	O
{	O
"show-all-if-ambiguous"	*(char)
,	O
&	O
_rl_complete_show_all	int
,	O
0	int
}	O
,	O
{	O
"show-all-if-unmodified"	*(char)
,	O
&	O
_rl_complete_show_unmodified	int
,	O
0	int
}	O
,	O
{	O
"show-mode-in-prompt"	*(char)
,	O
&	O
_rl_show_mode_in_prompt	int
,	O
0	int
}	O
,	O
{	O
"skip-completed-text"	*(char)
,	O
&	O
_rl_skip_completed_text	int
,	O
0	int
}	O
,	O
{	O
"visible-stats"	*(char)
,	O
&	O
rl_visible_stats	int
,	O
0	int
}	O
,	O
{	O
(	O
char	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
int	O
find_boolean_var	(*(char))->(int)
(	O
name	*(char)
)	O
const	O
char	O
*	O
name	*(char)
;	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
boolean_varlist	array(struct(*(char),*(int),int))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
boolean_varlist	array(struct(*(char),*(int),int))
[	O
i	int
]	O
.	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
i	int
;	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
hack_special_boolean_var	(int)->(void)
(	O
i	int
)	O
int	O
i	int
;	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
name	*(char)
=	O
boolean_varlist	array(struct(*(char),*(int),int))
[	O
i	int
]	O
.	O
name	*(char)
;	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"blink-matching-paren"	*(char)
)	O
==	O
0	int
)	O
_rl_enable_paren_matching	(int)->(void)
(	O
rl_blink_matching_paren	int
)	O
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"prefer-visible-bell"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
_rl_prefer_visible_bell	int
)	O
_rl_bell_preference	int
=	O
VISIBLE_BELL	int
;	O
else	O
_rl_bell_preference	int
=	O
AUDIBLE_BELL	int
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"show-mode-in-prompt"	*(char)
)	O
==	O
0	int
)	O
_rl_reset_prompt	()->(void)
(	O
)	O
;	O
}	O
typedef	O
int	O
_rl_sv_func_t	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_bell_style	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_combegin	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_dispprefix	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_compquery	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_compwidth	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_editmode	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_emacs_modestr	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_histsize	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_isrchterm	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_keymap	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_seqtimeout	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_viins_modestr	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_vicmd_modestr	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
const	O
name	*(char)
;	O
int	O
flags	int
;	O
_rl_sv_func_t	(*(char))->(int)
*	O
set_func	*((*(char))->(int))
;	O
}	O
string_varlist	array(struct(*(char),int,*((*(char))->(int))))
[	O
]	O
=	O
{	O
{	O
"bell-style"	*(char)
,	O
V_STRING	int
,	O
sv_bell_style	(*(char))->(int)
}	O
,	O
{	O
"comment-begin"	*(char)
,	O
V_STRING	int
,	O
sv_combegin	(*(char))->(int)
}	O
,	O
{	O
"completion-display-width"	*(char)
,	O
V_INT	int
,	O
sv_compwidth	(*(char))->(int)
}	O
,	O
{	O
"completion-prefix-display-length"	*(char)
,	O
V_INT	int
,	O
sv_dispprefix	(*(char))->(int)
}	O
,	O
{	O
"completion-query-items"	*(char)
,	O
V_INT	int
,	O
sv_compquery	(*(char))->(int)
}	O
,	O
{	O
"editing-mode"	*(char)
,	O
V_STRING	int
,	O
sv_editmode	(*(char))->(int)
}	O
,	O
{	O
"emacs-mode-string"	*(char)
,	O
V_STRING	int
,	O
sv_emacs_modestr	(*(char))->(int)
}	O
,	O
{	O
"history-size"	*(char)
,	O
V_INT	int
,	O
sv_histsize	(*(char))->(int)
}	O
,	O
{	O
"isearch-terminators"	*(char)
,	O
V_STRING	int
,	O
sv_isrchterm	(*(char))->(int)
}	O
,	O
{	O
"keymap"	*(char)
,	O
V_STRING	int
,	O
sv_keymap	(*(char))->(int)
}	O
,	O
{	O
"keyseq-timeout"	*(char)
,	O
V_INT	int
,	O
sv_seqtimeout	(*(char))->(int)
}	O
,	O
{	O
"vi-cmd-mode-string"	*(char)
,	O
V_STRING	int
,	O
sv_vicmd_modestr	(*(char))->(int)
}	O
,	O
{	O
"vi-ins-mode-string"	*(char)
,	O
V_STRING	int
,	O
sv_viins_modestr	(*(char))->(int)
}	O
,	O
{	O
(	O
char	O
*	O
)	O
NULL	O
,	O
0	int
,	O
(	O
_rl_sv_func_t	(*(char))->(int)
*	O
)	O
0	int
}	O
}	O
;	O
static	O
int	O
find_string_var	(*(char))->(int)
(	O
name	*(char)
)	O
const	O
char	O
*	O
name	*(char)
;	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
string_varlist	array(struct(*(char),int,*((*(char))->(int))))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
string_varlist	array(struct(*(char),int,*((*(char))->(int))))
[	O
i	int
]	O
.	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
i	int
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
bool_to_int	(*(char))->(int)
(	O
value	*(char)
)	O
const	O
char	O
*	O
value	*(char)
;	O
{	O
return	O
(	O
value	*(char)
==	O
0	int
||	O
*	O
value	*(char)
==	O
'\0'	O
||	O
(	O
_rl_stricmp	O
(	O
value	*(char)
,	O
"on"	*(char)
)	O
==	O
0	int
)	O
||	O
(	O
value	*(char)
[	O
0	int
]	O
==	O
'1'	O
&&	O
value	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
)	O
;	O
}	O
char	O
*	O
rl_variable_value	(*(char))->(*(char))
(	O
name	*(char)
)	O
const	O
char	O
*	O
name	*(char)
;	O
{	O
register	O
int	O
i	int
;	O
i	int
=	O
find_boolean_var	(*(char))->(int)
(	O
name	*(char)
)	O
;	O
if	O
(	O
i	int
>=	O
0	int
)	O
return	O
(	O
*	O
boolean_varlist	array(struct(*(char),*(int),int))
[	O
i	int
]	O
.	O
value	*(char)
?	O
"on"	*(char)
:	O
"off"	*(char)
)	O
;	O
i	int
=	O
find_string_var	(*(char))->(int)
(	O
name	*(char)
)	O
;	O
if	O
(	O
i	int
>=	O
0	int
)	O
return	O
(	O
_rl_get_string_variable_value	(*(char))->(*(char))
(	O
string_varlist	array(struct(*(char),int,*((*(char))->(int))))
[	O
i	int
]	O
.	O
name	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_variable_bind	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
value	*(char)
)	O
const	O
char	O
*	O
name	*(char)
,	O
*	O
value	*(char)
;	O
{	O
register	O
int	O
i	int
;	O
int	O
v	int
;	O
i	int
=	O
find_boolean_var	(*(char))->(int)
(	O
name	*(char)
)	O
;	O
if	O
(	O
i	int
>=	O
0	int
)	O
{	O
*	O
boolean_varlist	array(struct(*(char),*(int),int))
[	O
i	int
]	O
.	O
value	*(char)
=	O
bool_to_int	(*(char))->(int)
(	O
value	*(char)
)	O
;	O
if	O
(	O
boolean_varlist	array(struct(*(char),*(int),int))
[	O
i	int
]	O
.	O
flags	int
&	O
V_SPECIAL	int
)	O
hack_special_boolean_var	(int)->(void)
(	O
i	int
)	O
;	O
return	O
0	int
;	O
}	O
i	int
=	O
find_string_var	(*(char))->(int)
(	O
name	*(char)
)	O
;	O
if	O
(	O
i	int
<	O
0	int
||	O
string_varlist	array(struct(*(char),int,*((*(char))->(int))))
[	O
i	int
]	O
.	O
set_func	*((*(char))->(int))
==	O
0	int
)	O
{	O
if	O
(	O
i	int
<	O
0	int
)	O
_rl_init_file_error	(*(char))->(void)
(	O
"%s: unknown variable name"	*(char)
,	O
name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
v	int
=	O
(	O
*	O
string_varlist	array(struct(*(char),int,*((*(char))->(int))))
[	O
i	int
]	O
.	O
set_func	*((*(char))->(int))
)	O
(	O
value	*(char)
)	O
;	O
return	O
v	int
;	O
}	O
static	O
int	O
sv_editmode	(*(char))->(int)
(	O
value	*(char)
)	O
const	O
char	O
*	O
value	*(char)
;	O
{	O
if	O
(	O
_rl_strnicmp	O
(	O
value	*(char)
,	O
"vi"	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
{	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
=	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
;	O
rl_editing_mode	int
=	O
vi_mode	int
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
_rl_strnicmp	O
(	O
value	*(char)
,	O
"emacs"	*(char)
,	O
5	int
)	O
==	O
0	int
)	O
{	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
=	O
emacs_standard_keymap	array(struct(char,*((int,int)->(int))))
;	O
rl_editing_mode	int
=	O
emacs_mode	int
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
sv_combegin	(*(char))->(int)
(	O
value	*(char)
)	O
const	O
char	O
*	O
value	*(char)
;	O
{	O
if	O
(	O
value	*(char)
&&	O
*	O
value	*(char)
)	O
{	O
FREE	O
(	O
_rl_comment_begin	*(char)
)	O
;	O
_rl_comment_begin	*(char)
=	O
savestring	O
(	O
value	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
sv_dispprefix	(*(char))->(int)
(	O
value	*(char)
)	O
const	O
char	O
*	O
value	*(char)
;	O
{	O
int	O
nval	int
=	O
0	int
;	O
if	O
(	O
value	*(char)
&&	O
*	O
value	*(char)
)	O
{	O
nval	int
=	O
atoi	(*(char))->(int)
(	O
value	*(char)
)	O
;	O
if	O
(	O
nval	int
<	O
0	int
)	O
nval	int
=	O
0	int
;	O
}	O
_rl_completion_prefix_display_length	int
=	O
nval	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sv_compquery	(*(char))->(int)
(	O
value	*(char)
)	O
const	O
char	O
*	O
value	*(char)
;	O
{	O
int	O
nval	int
=	O
100	int
;	O
if	O
(	O
value	*(char)
&&	O
*	O
value	*(char)
)	O
{	O
nval	int
=	O
atoi	(*(char))->(int)
(	O
value	*(char)
)	O
;	O
if	O
(	O
nval	int
<	O
0	int
)	O
nval	int
=	O
0	int
;	O
}	O
rl_completion_query_items	int
=	O
nval	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sv_compwidth	(*(char))->(int)
(	O
value	*(char)
)	O
const	O
char	O
*	O
value	*(char)
;	O
{	O
int	O
nval	int
=	O
-	O
1	int
;	O
if	O
(	O
value	*(char)
&&	O
*	O
value	*(char)
)	O
nval	int
=	O
atoi	(*(char))->(int)
(	O
value	*(char)
)	O
;	O
_rl_completion_columns	int
=	O
nval	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sv_histsize	(*(char))->(int)
(	O
value	*(char)
)	O
const	O
char	O
*	O
value	*(char)
;	O
{	O
int	O
nval	int
;	O
nval	int
=	O
500	int
;	O
if	O
(	O
value	*(char)
&&	O
*	O
value	*(char)
)	O
{	O
nval	int
=	O
atoi	(*(char))->(int)
(	O
value	*(char)
)	O
;	O
if	O
(	O
nval	int
<	O
0	int
)	O
{	O
unstifle_history	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
stifle_history	(int)->(void)
(	O
nval	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sv_keymap	(*(char))->(int)
(	O
value	*(char)
)	O
const	O
char	O
*	O
value	*(char)
;	O
{	O
Keymap	*(struct(char,*((int,int)->(int))))
kmap	*(struct(char,*((int,int)->(int))))
;	O
kmap	*(struct(char,*((int,int)->(int))))
=	O
rl_get_keymap_by_name	(*(char))->(*(struct(char,*((int,int)->(int)))))
(	O
value	*(char)
)	O
;	O
if	O
(	O
kmap	*(struct(char,*((int,int)->(int))))
)	O
{	O
rl_set_keymap	(*(struct(char,*((int,int)->(int)))))->(void)
(	O
kmap	*(struct(char,*((int,int)->(int))))
)	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
sv_seqtimeout	(*(char))->(int)
(	O
value	*(char)
)	O
const	O
char	O
*	O
value	*(char)
;	O
{	O
int	O
nval	int
;	O
nval	int
=	O
0	int
;	O
if	O
(	O
value	*(char)
&&	O
*	O
value	*(char)
)	O
{	O
nval	int
=	O
atoi	(*(char))->(int)
(	O
value	*(char)
)	O
;	O
if	O
(	O
nval	int
<	O
0	int
)	O
nval	int
=	O
0	int
;	O
}	O
_rl_keyseq_timeout	int
=	O
nval	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sv_bell_style	(*(char))->(int)
(	O
value	*(char)
)	O
const	O
char	O
*	O
value	*(char)
;	O
{	O
if	O
(	O
value	*(char)
==	O
0	int
||	O
*	O
value	*(char)
==	O
'\0'	O
)	O
_rl_bell_preference	int
=	O
AUDIBLE_BELL	int
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
value	*(char)
,	O
"none"	*(char)
)	O
==	O
0	int
||	O
_rl_stricmp	O
(	O
value	*(char)
,	O
"off"	*(char)
)	O
==	O
0	int
)	O
_rl_bell_preference	int
=	O
NO_BELL	int
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
value	*(char)
,	O
"audible"	*(char)
)	O
==	O
0	int
||	O
_rl_stricmp	O
(	O
value	*(char)
,	O
"on"	*(char)
)	O
==	O
0	int
)	O
_rl_bell_preference	int
=	O
AUDIBLE_BELL	int
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
value	*(char)
,	O
"visible"	*(char)
)	O
==	O
0	int
)	O
_rl_bell_preference	int
=	O
VISIBLE_BELL	int
;	O
else	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sv_isrchterm	(*(char))->(int)
(	O
value	*(char)
)	O
const	O
char	O
*	O
value	*(char)
;	O
{	O
int	O
beg	int
,	O
end	int
,	O
delim	int
;	O
char	O
*	O
v	int
;	O
if	O
(	O
value	*(char)
==	O
0	int
)	O
return	O
1	int
;	O
v	int
=	O
savestring	O
(	O
value	*(char)
)	O
;	O
FREE	O
(	O
_rl_isearch_terminators	*(char)
)	O
;	O
if	O
(	O
v	int
[	O
0	int
]	O
==	O
'"'	O
||	O
v	int
[	O
0	int
]	O
==	O
'\''	O
)	O
{	O
delim	int
=	O
v	int
[	O
0	int
]	O
;	O
for	O
(	O
beg	int
=	O
end	int
=	O
1	int
;	O
v	int
[	O
end	int
]	O
&&	O
v	int
[	O
end	int
]	O
!=	O
delim	int
;	O
end	int
++	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
beg	int
=	O
end	int
=	O
0	int
;	O
v	int
[	O
end	int
]	O
&&	O
whitespace	O
(	O
v	int
[	O
end	int
]	O
)	O
==	O
0	int
;	O
end	int
++	O
)	O
;	O
}	O
v	int
[	O
end	int
]	O
=	O
'\0'	O
;	O
_rl_isearch_terminators	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
2	int
*	O
strlen	(*(char))->(long)
(	O
v	int
)	O
+	O
1	int
)	O
;	O
rl_translate_keyseq	(*(char),*(char),*(int))->(int)
(	O
v	int
+	O
beg	int
,	O
_rl_isearch_terminators	*(char)
,	O
&	O
end	int
)	O
;	O
_rl_isearch_terminators	*(char)
[	O
end	int
]	O
=	O
'\0'	O
;	O
xfree	(*(void))->(void)
(	O
v	int
)	O
;	O
return	O
0	int
;	O
}	O
extern	O
char	O
*	O
_rl_emacs_mode_str	*(char)
;	O
static	O
int	O
sv_emacs_modestr	(*(char))->(int)
(	O
value	*(char)
)	O
const	O
char	O
*	O
value	*(char)
;	O
{	O
if	O
(	O
value	*(char)
&&	O
*	O
value	*(char)
)	O
{	O
FREE	O
(	O
_rl_emacs_mode_str	*(char)
)	O
;	O
_rl_emacs_mode_str	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
2	int
*	O
strlen	(*(char))->(long)
(	O
value	*(char)
)	O
+	O
1	int
)	O
;	O
rl_translate_keyseq	(*(char),*(char),*(int))->(int)
(	O
value	*(char)
,	O
_rl_emacs_mode_str	*(char)
,	O
&	O
_rl_emacs_modestr_len	int
)	O
;	O
_rl_emacs_mode_str	*(char)
[	O
_rl_emacs_modestr_len	int
]	O
=	O
'\0'	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
value	*(char)
)	O
{	O
FREE	O
(	O
_rl_emacs_mode_str	*(char)
)	O
;	O
_rl_emacs_mode_str	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
1	int
)	O
;	O
_rl_emacs_mode_str	*(char)
[	O
_rl_emacs_modestr_len	int
=	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
value	*(char)
==	O
0	int
)	O
{	O
FREE	O
(	O
_rl_emacs_mode_str	*(char)
)	O
;	O
_rl_emacs_mode_str	*(char)
=	O
0	int
;	O
_rl_emacs_modestr_len	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
sv_viins_modestr	(*(char))->(int)
(	O
value	*(char)
)	O
const	O
char	O
*	O
value	*(char)
;	O
{	O
if	O
(	O
value	*(char)
&&	O
*	O
value	*(char)
)	O
{	O
FREE	O
(	O
_rl_vi_ins_mode_str	*(char)
)	O
;	O
_rl_vi_ins_mode_str	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
2	int
*	O
strlen	(*(char))->(long)
(	O
value	*(char)
)	O
+	O
1	int
)	O
;	O
rl_translate_keyseq	(*(char),*(char),*(int))->(int)
(	O
value	*(char)
,	O
_rl_vi_ins_mode_str	*(char)
,	O
&	O
_rl_vi_ins_modestr_len	int
)	O
;	O
_rl_vi_ins_mode_str	*(char)
[	O
_rl_vi_ins_modestr_len	int
]	O
=	O
'\0'	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
value	*(char)
)	O
{	O
FREE	O
(	O
_rl_vi_ins_mode_str	*(char)
)	O
;	O
_rl_vi_ins_mode_str	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
1	int
)	O
;	O
_rl_vi_ins_mode_str	*(char)
[	O
_rl_vi_ins_modestr_len	int
=	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
value	*(char)
==	O
0	int
)	O
{	O
FREE	O
(	O
_rl_vi_ins_mode_str	*(char)
)	O
;	O
_rl_vi_ins_mode_str	*(char)
=	O
0	int
;	O
_rl_vi_ins_modestr_len	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
sv_vicmd_modestr	(*(char))->(int)
(	O
value	*(char)
)	O
const	O
char	O
*	O
value	*(char)
;	O
{	O
if	O
(	O
value	*(char)
&&	O
*	O
value	*(char)
)	O
{	O
FREE	O
(	O
_rl_vi_cmd_mode_str	*(char)
)	O
;	O
_rl_vi_cmd_mode_str	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
2	int
*	O
strlen	(*(char))->(long)
(	O
value	*(char)
)	O
+	O
1	int
)	O
;	O
rl_translate_keyseq	(*(char),*(char),*(int))->(int)
(	O
value	*(char)
,	O
_rl_vi_cmd_mode_str	*(char)
,	O
&	O
_rl_vi_cmd_modestr_len	int
)	O
;	O
_rl_vi_cmd_mode_str	*(char)
[	O
_rl_vi_cmd_modestr_len	int
]	O
=	O
'\0'	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
value	*(char)
)	O
{	O
FREE	O
(	O
_rl_vi_cmd_mode_str	*(char)
)	O
;	O
_rl_vi_cmd_mode_str	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
1	int
)	O
;	O
_rl_vi_cmd_mode_str	*(char)
[	O
_rl_vi_cmd_modestr_len	int
=	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
value	*(char)
==	O
0	int
)	O
{	O
FREE	O
(	O
_rl_vi_cmd_mode_str	*(char)
)	O
;	O
_rl_vi_cmd_mode_str	*(char)
=	O
0	int
;	O
_rl_vi_cmd_modestr_len	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
typedef	O
struct	O
{	O
const	O
char	O
*	O
const	O
name	*(char)
;	O
int	O
value	*(char)
;	O
}	O
assoc_list	struct(*(char),int)
;	O
static	O
const	O
assoc_list	struct(*(char),int)
name_key_alist	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"DEL"	*(char)
,	O
0x7f	int
}	O
,	O
{	O
"ESC"	*(char)
,	O
'\033'	O
}	O
,	O
{	O
"Escape"	*(char)
,	O
'\033'	O
}	O
,	O
{	O
"LFD"	*(char)
,	O
'\n'	O
}	O
,	O
{	O
"Newline"	*(char)
,	O
'\n'	O
}	O
,	O
{	O
"RET"	*(char)
,	O
'\r'	O
}	O
,	O
{	O
"Return"	*(char)
,	O
'\r'	O
}	O
,	O
{	O
"Rubout"	*(char)
,	O
0x7f	int
}	O
,	O
{	O
"SPC"	*(char)
,	O
' '	O
}	O
,	O
{	O
"Space"	*(char)
,	O
' '	O
}	O
,	O
{	O
"Tab"	*(char)
,	O
0x09	int
}	O
,	O
{	O
(	O
char	O
*	O
)	O
0x0	int
,	O
0	int
}	O
}	O
;	O
static	O
int	O
glean_key_from_name	(*(char))->(int)
(	O
name	*(char)
)	O
char	O
*	O
name	*(char)
;	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
name_key_alist	array(struct(*(char),int))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
name_key_alist	array(struct(*(char),int))
[	O
i	int
]	O
.	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
name_key_alist	array(struct(*(char),int))
[	O
i	int
]	O
.	O
value	*(char)
)	O
;	O
return	O
(	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
name	*(char)
)	O
;	O
}	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
const	O
name	*(char)
;	O
Keymap	*(struct(char,*((int,int)->(int))))
map	*(struct(char,*((int,int)->(int))))
;	O
}	O
keymap_names	array(struct(*(char),*(struct(char,*((int,int)->(int))))))
[	O
]	O
=	O
{	O
{	O
"emacs"	*(char)
,	O
emacs_standard_keymap	array(struct(char,*((int,int)->(int))))
}	O
,	O
{	O
"emacs-standard"	*(char)
,	O
emacs_standard_keymap	array(struct(char,*((int,int)->(int))))
}	O
,	O
{	O
"emacs-meta"	*(char)
,	O
emacs_meta_keymap	array(struct(char,*((int,int)->(int))))
}	O
,	O
{	O
"emacs-ctlx"	*(char)
,	O
emacs_ctlx_keymap	array(struct(char,*((int,int)->(int))))
}	O
,	O
{	O
"vi"	*(char)
,	O
vi_movement_keymap	array(struct(char,*((int,int)->(int))))
}	O
,	O
{	O
"vi-move"	*(char)
,	O
vi_movement_keymap	array(struct(char,*((int,int)->(int))))
}	O
,	O
{	O
"vi-command"	*(char)
,	O
vi_movement_keymap	array(struct(char,*((int,int)->(int))))
}	O
,	O
{	O
"vi-insert"	*(char)
,	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
}	O
,	O
{	O
(	O
char	O
*	O
)	O
0x0	int
,	O
(	O
Keymap	*(struct(char,*((int,int)->(int))))
)	O
0x0	int
}	O
}	O
;	O
Keymap	*(struct(char,*((int,int)->(int))))
rl_get_keymap_by_name	(*(char))->(*(struct(char,*((int,int)->(int)))))
(	O
name	*(char)
)	O
const	O
char	O
*	O
name	*(char)
;	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
keymap_names	array(struct(*(char),*(struct(char,*((int,int)->(int))))))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
keymap_names	array(struct(*(char),*(struct(char,*((int,int)->(int))))))
[	O
i	int
]	O
.	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
keymap_names	array(struct(*(char),*(struct(char,*((int,int)->(int))))))
[	O
i	int
]	O
.	O
map	*(struct(char,*((int,int)->(int))))
)	O
;	O
return	O
(	O
(	O
Keymap	*(struct(char,*((int,int)->(int))))
)	O
NULL	O
)	O
;	O
}	O
char	O
*	O
rl_get_keymap_name	(*(struct(char,*((int,int)->(int)))))->(*(char))
(	O
map	*(struct(char,*((int,int)->(int))))
)	O
Keymap	*(struct(char,*((int,int)->(int))))
map	*(struct(char,*((int,int)->(int))))
;	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
keymap_names	array(struct(*(char),*(struct(char,*((int,int)->(int))))))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
if	O
(	O
map	*(struct(char,*((int,int)->(int))))
==	O
keymap_names	array(struct(*(char),*(struct(char,*((int,int)->(int))))))
[	O
i	int
]	O
.	O
map	*(struct(char,*((int,int)->(int))))
)	O
return	O
(	O
(	O
char	O
*	O
)	O
keymap_names	array(struct(*(char),*(struct(char,*((int,int)->(int))))))
[	O
i	int
]	O
.	O
name	*(char)
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
void	O
rl_set_keymap	(*(struct(char,*((int,int)->(int)))))->(void)
(	O
map	*(struct(char,*((int,int)->(int))))
)	O
Keymap	*(struct(char,*((int,int)->(int))))
map	*(struct(char,*((int,int)->(int))))
;	O
{	O
if	O
(	O
map	*(struct(char,*((int,int)->(int))))
)	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
=	O
map	*(struct(char,*((int,int)->(int))))
;	O
}	O
Keymap	*(struct(char,*((int,int)->(int))))
rl_get_keymap	()->(*(struct(char,*((int,int)->(int)))))
(	O
)	O
{	O
return	O
(	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
)	O
;	O
}	O
void	O
rl_set_keymap_from_edit_mode	()->(void)
(	O
)	O
{	O
if	O
(	O
rl_editing_mode	int
==	O
emacs_mode	int
)	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
=	O
emacs_standard_keymap	array(struct(char,*((int,int)->(int))))
;	O
else	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
)	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
=	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
;	O
}	O
char	O
*	O
rl_get_keymap_name_from_edit_mode	()->(*(char))
(	O
)	O
{	O
if	O
(	O
rl_editing_mode	int
==	O
emacs_mode	int
)	O
return	O
"emacs"	*(char)
;	O
else	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
)	O
return	O
"vi"	*(char)
;	O
else	O
return	O
"none"	*(char)
;	O
}	O
void	O
rl_list_funmap_names	()->(void)
(	O
)	O
{	O
register	O
int	O
i	int
;	O
const	O
char	O
*	O
*	O
funmap_names	*(*(char))
;	O
funmap_names	*(*(char))
=	O
rl_funmap_names	()->(*(*(char)))
(	O
)	O
;	O
if	O
(	O
!	O
funmap_names	*(*(char))
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
funmap_names	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
funmap_names	*(*(char))
[	O
i	int
]	O
)	O
;	O
xfree	(*(void))->(void)
(	O
funmap_names	*(*(char))
)	O
;	O
}	O
static	O
char	O
*	O
_rl_get_keyname	(int)->(*(char))
(	O
key	int
)	O
int	O
key	int
;	O
{	O
char	O
*	O
keyname	*(char)
;	O
int	O
i	int
,	O
c	int
;	O
keyname	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
8	int
)	O
;	O
c	int
=	O
key	int
;	O
if	O
(	O
c	int
==	O
ESC	O
)	O
{	O
keyname	*(char)
[	O
0	int
]	O
=	O
'\\'	O
;	O
keyname	*(char)
[	O
1	int
]	O
=	O
'e'	O
;	O
keyname	*(char)
[	O
2	int
]	O
=	O
'\0'	O
;	O
return	O
keyname	*(char)
;	O
}	O
if	O
(	O
key	int
==	O
RUBOUT	int
)	O
{	O
keyname	*(char)
[	O
0	int
]	O
=	O
'\\'	O
;	O
keyname	*(char)
[	O
1	int
]	O
=	O
'C'	O
;	O
keyname	*(char)
[	O
2	int
]	O
=	O
'-'	O
;	O
keyname	*(char)
[	O
3	int
]	O
=	O
'?'	O
;	O
keyname	*(char)
[	O
4	int
]	O
=	O
'\0'	O
;	O
return	O
keyname	*(char)
;	O
}	O
i	int
=	O
0	int
;	O
if	O
(	O
CTRL_CHAR	O
(	O
c	int
)	O
)	O
{	O
keyname	*(char)
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
keyname	*(char)
[	O
i	int
++	O
]	O
=	O
'C'	O
;	O
keyname	*(char)
[	O
i	int
++	O
]	O
=	O
'-'	O
;	O
c	int
=	O
_rl_to_lower	(int)->(int)
(	O
UNCTRL	O
(	O
c	int
)	O
)	O
;	O
}	O
if	O
(	O
c	int
>=	O
128	int
&&	O
c	int
<=	O
159	int
)	O
{	O
keyname	*(char)
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
keyname	*(char)
[	O
i	int
++	O
]	O
=	O
'2'	O
;	O
c	int
-=	O
128	int
;	O
keyname	*(char)
[	O
i	int
++	O
]	O
=	O
(	O
c	int
/	O
8	int
)	O
+	O
'0'	O
;	O
c	int
=	O
(	O
c	int
%	O
8	int
)	O
+	O
'0'	O
;	O
}	O
if	O
(	O
c	int
==	O
'\\'	O
||	O
c	int
==	O
'"'	O
)	O
keyname	*(char)
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
keyname	*(char)
[	O
i	int
++	O
]	O
=	O
(	O
char	O
)	O
c	int
;	O
keyname	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
return	O
keyname	*(char)
;	O
}	O
char	O
*	O
*	O
rl_invoking_keyseqs_in_map	(*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(*(*(char)))
(	O
function	*((int,int)->(int))
,	O
map	*(struct(char,*((int,int)->(int))))
)	O
rl_command_func_t	(int,int)->(int)
*	O
function	*((int,int)->(int))
;	O
Keymap	*(struct(char,*((int,int)->(int))))
map	*(struct(char,*((int,int)->(int))))
;	O
{	O
register	O
int	O
key	int
;	O
char	O
*	O
*	O
result	int
;	O
int	O
result_index	int
,	O
result_size	int
;	O
result	int
=	O
(	O
char	O
*	O
*	O
)	O
NULL	O
;	O
result_index	int
=	O
result_size	int
=	O
0	int
;	O
for	O
(	O
key	int
=	O
0	int
;	O
key	int
<	O
KEYMAP_SIZE	int
;	O
key	int
++	O
)	O
{	O
switch	O
(	O
map	*(struct(char,*((int,int)->(int))))
[	O
key	int
]	O
.	O
type	enum(int,int,int,int)
)	O
{	O
case	O
ISMACR	int
:	O
case	O
ISFUNC	int
:	O
if	O
(	O
map	*(struct(char,*((int,int)->(int))))
[	O
key	int
]	O
.	O
function	*((int,int)->(int))
==	O
function	*((int,int)->(int))
)	O
{	O
char	O
*	O
keyname	*(char)
;	O
keyname	*(char)
=	O
_rl_get_keyname	(int)->(*(char))
(	O
key	int
)	O
;	O
if	O
(	O
result_index	int
+	O
2	int
>	O
result_size	int
)	O
{	O
result_size	int
+=	O
10	int
;	O
result	int
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
result	int
,	O
result_size	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
}	O
result	int
[	O
result_index	int
++	O
]	O
=	O
keyname	*(char)
;	O
result	int
[	O
result_index	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
break	O
;	O
case	O
ISKMAP	int
:	O
{	O
char	O
*	O
*	O
seqs	*(*(char))
;	O
register	O
int	O
i	int
;	O
if	O
(	O
map	*(struct(char,*((int,int)->(int))))
[	O
key	int
]	O
.	O
function	*((int,int)->(int))
)	O
seqs	*(*(char))
=	O
rl_invoking_keyseqs_in_map	(*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(*(*(char)))
(	O
function	*((int,int)->(int))
,	O
FUNCTION_TO_KEYMAP	O
(	O
map	*(struct(char,*((int,int)->(int))))
,	O
key	int
)	O
)	O
;	O
else	O
break	O
;	O
if	O
(	O
seqs	*(*(char))
==	O
0	int
)	O
break	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
seqs	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
char	O
*	O
keyname	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
6	int
+	O
strlen	(*(char))->(long)
(	O
seqs	*(*(char))
[	O
i	int
]	O
)	O
)	O
;	O
if	O
(	O
key	int
==	O
ESC	O
)	O
{	O
if	O
(	O
_rl_convert_meta_chars_to_ascii	int
&&	O
map	*(struct(char,*((int,int)->(int))))
[	O
ESC	O
]	O
.	O
type	enum(int,int,int,int)
==	O
ISKMAP	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
keyname	*(char)
,	O
"\\M-"	*(char)
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
keyname	*(char)
,	O
"\\e"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
CTRL_CHAR	O
(	O
key	int
)	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
keyname	*(char)
,	O
"\\C-%c"	*(char)
,	O
_rl_to_lower	(int)->(int)
(	O
UNCTRL	O
(	O
key	int
)	O
)	O
)	O
;	O
else	O
if	O
(	O
key	int
==	O
RUBOUT	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
keyname	*(char)
,	O
"\\C-?"	*(char)
)	O
;	O
else	O
if	O
(	O
key	int
==	O
'\\'	O
||	O
key	int
==	O
'"'	O
)	O
{	O
keyname	*(char)
[	O
0	int
]	O
=	O
'\\'	O
;	O
keyname	*(char)
[	O
1	int
]	O
=	O
(	O
char	O
)	O
key	int
;	O
keyname	*(char)
[	O
2	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
keyname	*(char)
[	O
0	int
]	O
=	O
(	O
char	O
)	O
key	int
;	O
keyname	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
keyname	*(char)
,	O
seqs	*(*(char))
[	O
i	int
]	O
)	O
;	O
xfree	(*(void))->(void)
(	O
seqs	*(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
result_index	int
+	O
2	int
>	O
result_size	int
)	O
{	O
result_size	int
+=	O
10	int
;	O
result	int
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
result	int
,	O
result_size	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
}	O
result	int
[	O
result_index	int
++	O
]	O
=	O
keyname	*(char)
;	O
result	int
[	O
result_index	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
xfree	(*(void))->(void)
(	O
seqs	*(*(char))
)	O
;	O
}	O
break	O
;	O
}	O
}	O
return	O
(	O
result	int
)	O
;	O
}	O
char	O
*	O
*	O
rl_invoking_keyseqs	(*((int,int)->(int)))->(*(*(char)))
(	O
function	*((int,int)->(int))
)	O
rl_command_func_t	(int,int)->(int)
*	O
function	*((int,int)->(int))
;	O
{	O
return	O
(	O
rl_invoking_keyseqs_in_map	(*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(*(*(char)))
(	O
function	*((int,int)->(int))
,	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
)	O
)	O
;	O
}	O
void	O
rl_function_dumper	(int)->(void)
(	O
print_readably	int
)	O
int	O
print_readably	int
;	O
{	O
register	O
int	O
i	int
;	O
const	O
char	O
*	O
*	O
names	*(*(char))
;	O
const	O
char	O
*	O
name	*(char)
;	O
names	*(*(char))
=	O
rl_funmap_names	()->(*(*(char)))
(	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
name	*(char)
=	O
names	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
rl_command_func_t	(int,int)->(int)
*	O
function	*((int,int)->(int))
;	O
char	O
*	O
*	O
invokers	*(*(char))
;	O
function	*((int,int)->(int))
=	O
rl_named_function	(*(char))->(*((int,int)->(int)))
(	O
name	*(char)
)	O
;	O
invokers	*(*(char))
=	O
rl_invoking_keyseqs_in_map	(*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(*(*(char)))
(	O
function	*((int,int)->(int))
,	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
)	O
;	O
if	O
(	O
print_readably	int
)	O
{	O
if	O
(	O
!	O
invokers	*(*(char))
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"# %s (not bound)\n"	*(char)
,	O
name	*(char)
)	O
;	O
else	O
{	O
register	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
invokers	*(*(char))
[	O
j	int
]	O
;	O
j	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\"%s\": %s\n"	*(char)
,	O
invokers	*(*(char))
[	O
j	int
]	O
,	O
name	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
invokers	*(*(char))
[	O
j	int
]	O
)	O
;	O
}	O
xfree	(*(void))->(void)
(	O
invokers	*(*(char))
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
invokers	*(*(char))
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s is not bound to any keys\n"	*(char)
,	O
name	*(char)
)	O
;	O
else	O
{	O
register	O
int	O
j	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s can be found on "	*(char)
,	O
name	*(char)
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
invokers	*(*(char))
[	O
j	int
]	O
&&	O
j	int
<	O
5	int
;	O
j	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\"%s\"%s"	*(char)
,	O
invokers	*(*(char))
[	O
j	int
]	O
,	O
invokers	*(*(char))
[	O
j	int
+	O
1	int
]	O
?	O
", "	*(char)
:	O
".\n"	*(char)
)	O
;	O
}	O
if	O
(	O
j	int
==	O
5	int
&&	O
invokers	*(*(char))
[	O
j	int
]	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"...\n"	*(char)
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
invokers	*(*(char))
[	O
j	int
]	O
;	O
j	int
++	O
)	O
xfree	(*(void))->(void)
(	O
invokers	*(*(char))
[	O
j	int
]	O
)	O
;	O
xfree	(*(void))->(void)
(	O
invokers	*(*(char))
)	O
;	O
}	O
}	O
}	O
xfree	(*(void))->(void)
(	O
names	*(*(char))
)	O
;	O
}	O
int	O
rl_dump_functions	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_dispatching	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\r\n"	*(char)
)	O
;	O
rl_function_dumper	(int)->(void)
(	O
rl_explicit_arg	int
)	O
;	O
rl_on_new_line	()->(int)
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
_rl_macro_dumper_internal	(int,*(struct(char,*((int,int)->(int)))),*(char))->(void)
(	O
print_readably	int
,	O
map	*(struct(char,*((int,int)->(int))))
,	O
prefix	*(char)
)	O
int	O
print_readably	int
;	O
Keymap	*(struct(char,*((int,int)->(int))))
map	*(struct(char,*((int,int)->(int))))
;	O
char	O
*	O
prefix	*(char)
;	O
{	O
register	O
int	O
key	int
;	O
char	O
*	O
keyname	*(char)
,	O
*	O
out	*(char)
;	O
int	O
prefix_len	int
;	O
for	O
(	O
key	int
=	O
0	int
;	O
key	int
<	O
KEYMAP_SIZE	int
;	O
key	int
++	O
)	O
{	O
switch	O
(	O
map	*(struct(char,*((int,int)->(int))))
[	O
key	int
]	O
.	O
type	enum(int,int,int,int)
)	O
{	O
case	O
ISMACR	int
:	O
keyname	*(char)
=	O
_rl_get_keyname	(int)->(*(char))
(	O
key	int
)	O
;	O
out	*(char)
=	O
_rl_untranslate_macro_value	(*(char),int)->(*(char))
(	O
(	O
char	O
*	O
)	O
map	*(struct(char,*((int,int)->(int))))
[	O
key	int
]	O
.	O
function	*((int,int)->(int))
,	O
0	int
)	O
;	O
if	O
(	O
print_readably	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\"%s%s\": \"%s\"\n"	*(char)
,	O
prefix	*(char)
?	O
prefix	*(char)
:	O
""	*(char)
,	O
keyname	*(char)
,	O
out	*(char)
?	O
out	*(char)
:	O
""	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s%s outputs %s\n"	*(char)
,	O
prefix	*(char)
?	O
prefix	*(char)
:	O
""	*(char)
,	O
keyname	*(char)
,	O
out	*(char)
?	O
out	*(char)
:	O
""	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
keyname	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
out	*(char)
)	O
;	O
break	O
;	O
case	O
ISFUNC	int
:	O
break	O
;	O
case	O
ISKMAP	int
:	O
prefix_len	int
=	O
prefix	*(char)
?	O
strlen	(*(char))->(long)
(	O
prefix	*(char)
)	O
:	O
0	int
;	O
if	O
(	O
key	int
==	O
ESC	O
)	O
{	O
keyname	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
3	int
+	O
prefix_len	int
)	O
;	O
if	O
(	O
prefix	*(char)
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
keyname	*(char)
,	O
prefix	*(char)
)	O
;	O
keyname	*(char)
[	O
prefix_len	int
]	O
=	O
'\\'	O
;	O
keyname	*(char)
[	O
prefix_len	int
+	O
1	int
]	O
=	O
'e'	O
;	O
keyname	*(char)
[	O
prefix_len	int
+	O
2	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
keyname	*(char)
=	O
_rl_get_keyname	(int)->(*(char))
(	O
key	int
)	O
;	O
if	O
(	O
prefix	*(char)
)	O
{	O
out	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
keyname	*(char)
)	O
+	O
prefix_len	int
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
out	*(char)
,	O
prefix	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
out	*(char)
+	O
prefix_len	int
,	O
keyname	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
keyname	*(char)
)	O
;	O
keyname	*(char)
=	O
out	*(char)
;	O
}	O
}	O
_rl_macro_dumper_internal	(int,*(struct(char,*((int,int)->(int)))),*(char))->(void)
(	O
print_readably	int
,	O
FUNCTION_TO_KEYMAP	O
(	O
map	*(struct(char,*((int,int)->(int))))
,	O
key	int
)	O
,	O
keyname	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
keyname	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
}	O
void	O
rl_macro_dumper	(int)->(void)
(	O
print_readably	int
)	O
int	O
print_readably	int
;	O
{	O
_rl_macro_dumper_internal	(int,*(struct(char,*((int,int)->(int)))),*(char))->(void)
(	O
print_readably	int
,	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
int	O
rl_dump_macros	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_dispatching	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\r\n"	*(char)
)	O
;	O
rl_macro_dumper	(int)->(void)
(	O
rl_explicit_arg	int
)	O
;	O
rl_on_new_line	()->(int)
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
char	O
*	O
_rl_get_string_variable_value	(*(char))->(*(char))
(	O
name	*(char)
)	O
const	O
char	O
*	O
name	*(char)
;	O
{	O
static	O
char	O
numbuf	array(char)
[	O
32	int
]	O
;	O
char	O
*	O
ret	*(char)
;	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"bell-style"	*(char)
)	O
==	O
0	int
)	O
{	O
switch	O
(	O
_rl_bell_preference	int
)	O
{	O
case	O
NO_BELL	int
:	O
return	O
"none"	*(char)
;	O
case	O
VISIBLE_BELL	int
:	O
return	O
"visible"	*(char)
;	O
case	O
AUDIBLE_BELL	int
:	O
default	O
:	O
return	O
"audible"	*(char)
;	O
}	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"comment-begin"	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
_rl_comment_begin	*(char)
?	O
_rl_comment_begin	*(char)
:	O
RL_COMMENT_BEGIN_DEFAULT	*(char)
)	O
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"completion-display-width"	*(char)
)	O
==	O
0	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
numbuf	array(char)
,	O
"%d"	*(char)
,	O
_rl_completion_columns	int
)	O
;	O
return	O
(	O
numbuf	array(char)
)	O
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"completion-prefix-display-length"	*(char)
)	O
==	O
0	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
numbuf	array(char)
,	O
"%d"	*(char)
,	O
_rl_completion_prefix_display_length	int
)	O
;	O
return	O
(	O
numbuf	array(char)
)	O
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"completion-query-items"	*(char)
)	O
==	O
0	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
numbuf	array(char)
,	O
"%d"	*(char)
,	O
rl_completion_query_items	int
)	O
;	O
return	O
(	O
numbuf	array(char)
)	O
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"editing-mode"	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
rl_get_keymap_name_from_edit_mode	()->(*(char))
(	O
)	O
)	O
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"history-size"	*(char)
)	O
==	O
0	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
numbuf	array(char)
,	O
"%d"	*(char)
,	O
history_is_stifled	()->(int)
(	O
)	O
?	O
history_max_entries	int
:	O
0	int
)	O
;	O
return	O
(	O
numbuf	array(char)
)	O
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"isearch-terminators"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
_rl_isearch_terminators	*(char)
==	O
0	int
)	O
return	O
0	int
;	O
ret	*(char)
=	O
_rl_untranslate_macro_value	(*(char),int)->(*(char))
(	O
_rl_isearch_terminators	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
ret	*(char)
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
numbuf	array(char)
,	O
ret	*(char)
,	O
sizeof	O
(	O
numbuf	array(char)
)	O
-	O
1	int
)	O
;	O
xfree	(*(void))->(void)
(	O
ret	*(char)
)	O
;	O
numbuf	array(char)
[	O
sizeof	O
(	O
numbuf	array(char)
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
numbuf	array(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
numbuf	array(char)
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"keymap"	*(char)
)	O
==	O
0	int
)	O
{	O
ret	*(char)
=	O
rl_get_keymap_name	(*(struct(char,*((int,int)->(int)))))->(*(char))
(	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
)	O
;	O
if	O
(	O
ret	*(char)
==	O
0	int
)	O
ret	*(char)
=	O
rl_get_keymap_name_from_edit_mode	()->(*(char))
(	O
)	O
;	O
return	O
(	O
ret	*(char)
?	O
ret	*(char)
:	O
"none"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"keyseq-timeout"	*(char)
)	O
==	O
0	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
numbuf	array(char)
,	O
"%d"	*(char)
,	O
_rl_keyseq_timeout	int
)	O
;	O
return	O
(	O
numbuf	array(char)
)	O
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"emacs-mode-string"	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
_rl_emacs_mode_str	*(char)
?	O
_rl_emacs_mode_str	*(char)
:	O
RL_EMACS_MODESTR_DEFAULT	*(char)
)	O
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"vi-cmd-mode-string"	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
_rl_vi_cmd_mode_str	*(char)
?	O
_rl_vi_cmd_mode_str	*(char)
:	O
RL_VI_CMD_MODESTR_DEFAULT	*(char)
)	O
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	*(char)
,	O
"vi-ins-mode-string"	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
_rl_vi_ins_mode_str	*(char)
?	O
_rl_vi_ins_mode_str	*(char)
:	O
RL_VI_INS_MODESTR_DEFAULT	*(char)
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
rl_variable_dumper	(int)->(void)
(	O
print_readably	int
)	O
int	O
print_readably	int
;	O
{	O
int	O
i	int
;	O
char	O
*	O
v	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
boolean_varlist	array(struct(*(char),*(int),int))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
{	O
if	O
(	O
print_readably	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"set %s %s\n"	*(char)
,	O
boolean_varlist	array(struct(*(char),*(int),int))
[	O
i	int
]	O
.	O
name	*(char)
,	O
*	O
boolean_varlist	array(struct(*(char),*(int),int))
[	O
i	int
]	O
.	O
value	*(char)
?	O
"on"	*(char)
:	O
"off"	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s is set to `%s'\n"	*(char)
,	O
boolean_varlist	array(struct(*(char),*(int),int))
[	O
i	int
]	O
.	O
name	*(char)
,	O
*	O
boolean_varlist	array(struct(*(char),*(int),int))
[	O
i	int
]	O
.	O
value	*(char)
?	O
"on"	*(char)
:	O
"off"	*(char)
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
string_varlist	array(struct(*(char),int,*((*(char))->(int))))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
{	O
v	int
=	O
_rl_get_string_variable_value	(*(char))->(*(char))
(	O
string_varlist	array(struct(*(char),int,*((*(char))->(int))))
[	O
i	int
]	O
.	O
name	*(char)
)	O
;	O
if	O
(	O
v	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
print_readably	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"set %s %s\n"	*(char)
,	O
string_varlist	array(struct(*(char),int,*((*(char))->(int))))
[	O
i	int
]	O
.	O
name	*(char)
,	O
v	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s is set to `%s'\n"	*(char)
,	O
string_varlist	array(struct(*(char),int,*((*(char))->(int))))
[	O
i	int
]	O
.	O
name	*(char)
,	O
v	int
)	O
;	O
}	O
}	O
int	O
rl_dump_variables	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_dispatching	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\r\n"	*(char)
)	O
;	O
rl_variable_dumper	(int)->(void)
(	O
rl_explicit_arg	int
)	O
;	O
rl_on_new_line	()->(int)
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
substring_member_of_array	(*(char),*(*(char)))->(int)
(	O
string	*(char)
,	O
array	*(char)
)	O
const	O
char	O
*	O
string	*(char)
;	O
const	O
char	O
*	O
const	O
*	O
array	*(char)
;	O
{	O
while	O
(	O
*	O
array	*(char)
)	O
{	O
if	O
(	O
_rl_strindex	(*(char),*(char))->(*(char))
(	O
string	*(char)
,	O
*	O
array	*(char)
)	O
)	O
return	O
(	O
1	int
)	O
;	O
array	*(char)
++	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
