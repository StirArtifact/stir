unsigned	O
int	O
num_files	int
;	O
static	O
unsigned	O
int	O
gen	int
;	O
struct	O
node	*(struct)
*	O
all_nodes	*(struct)
;	O
static	O
size_t	long
all_nodes_nr_items	long
;	O
pthread_rwlock_t	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
all_nodes_lock	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
=	O
PTHREAD_RWLOCK_INITIALIZER	O
;	O
error_t	(*(int))->(int)
diskfs_alloc_node	(*(struct),int,*(*(struct)))->(int)
(	O
struct	O
node	*(struct)
*	O
dp	*(struct)
,	O
mode_t	int
mode	int
,	O
struct	O
node	*(struct)
*	O
*	O
npp	*(*(struct))
)	O
{	O
struct	O
disknode	struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long),*(struct),*(*(struct)))
*	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
;	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
=	O
calloc	O
(	O
1	int
,	O
sizeof	O
*	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
)	O
;	O
if	O
(	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
==	O
0	int
)	O
return	O
ENOSPC	O
;	O
if	O
(	O
round_page	()->(int)
(	O
get_used	()->(long)
(	O
)	O
+	O
sizeof	O
*	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
)	O
/	O
vm_page_size	O
>	O
tmpfs_page_limit	long
)	O
{	O
pthread_rwlock_unlock	()->(int)
(	O
&	O
all_nodes_lock	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
;	O
free	()->(int)
(	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
)	O
;	O
return	O
ENOSPC	O
;	O
}	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
gen	int
=	O
gen	int
++	O
;	O
__atomic_add_fetch	O
(	O
&	O
num_files	int
,	O
1	int
,	O
__ATOMIC_RELAXED	int
)	O
;	O
adjust_used	(long)->(void)
(	O
sizeof	O
*	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
)	O
;	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
type	int
=	O
IFTODT	()->(int)
(	O
mode	int
&	O
S_IFMT	O
)	O
;	O
return	O
diskfs_cached_lookup	()->(int)
(	O
(	O
ino_t	long
)	O
(	O
uintptr_t	O
)	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
,	O
npp	*(*(struct))
)	O
;	O
}	O
void	O
diskfs_free_node	(*(struct),int)->(void)
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
,	O
mode_t	int
mode	int
)	O
{	O
switch	O
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
type	int
)	O
{	O
case	O
DT_REG	O
:	O
if	O
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
memobj	int
!=	O
MACH_PORT_NULL	O
)	O
{	O
vm_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
memref	int
,	O
4096	int
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
memobj	int
)	O
;	O
}	O
break	O
;	O
case	O
DT_DIR	O
:	O
assert	()->(int)
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
dir	struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long)))
.	O
entries	*(struct)
==	O
0	int
)	O
;	O
break	O
;	O
case	O
DT_LNK	O
:	O
free	()->(int)
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
lnk	*(char)
)	O
;	O
break	O
;	O
}	O
pthread_rwlock_wrlock	()->(int)
(	O
&	O
all_nodes_lock	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
;	O
*	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hprevp	*(*(struct))
=	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hnext	*(struct)
;	O
if	O
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hnext	*(struct)
!=	O
0	int
)	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hnext	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hprevp	*(*(struct))
=	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hprevp	*(*(struct))
;	O
all_nodes_nr_items	long
-=	O
1	int
;	O
pthread_rwlock_unlock	()->(int)
(	O
&	O
all_nodes_lock	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
;	O
free	()->(int)
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
)	O
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
=	O
0	int
;	O
__atomic_sub_fetch	O
(	O
&	O
num_files	int
,	O
1	int
,	O
__ATOMIC_RELAXED	int
)	O
;	O
adjust_used	(long)->(void)
(	O
-	O
sizeof	O
*	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
)	O
;	O
}	O
void	O
diskfs_node_norefs	(*(struct))->(void)
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
)	O
{	O
if	O
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
!=	O
0	int
)	O
{	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
size	long
=	O
np	*(struct)
->	O
dn_stat	O
.	O
st_size	O
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
mode	int
=	O
np	*(struct)
->	O
dn_stat	O
.	O
st_mode	O
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
nlink	long
=	O
np	*(struct)
->	O
dn_stat	O
.	O
st_nlink	O
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
uid	int
=	O
np	*(struct)
->	O
dn_stat	O
.	O
st_uid	O
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
author	int
=	O
np	*(struct)
->	O
dn_stat	O
.	O
st_author	O
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
gid	int
=	O
np	*(struct)
->	O
dn_stat	O
.	O
st_gid	O
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
atime	struct(long,long)
=	O
np	*(struct)
->	O
dn_stat	O
.	O
st_atim	O
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
mtime	struct(long,long)
=	O
np	*(struct)
->	O
dn_stat	O
.	O
st_mtim	O
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
ctime	struct(long,long)
=	O
np	*(struct)
->	O
dn_stat	O
.	O
st_ctim	O
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
flags	int
=	O
np	*(struct)
->	O
dn_stat	O
.	O
st_flags	O
;	O
switch	O
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
type	int
)	O
{	O
case	O
DT_REG	O
:	O
assert	()->(int)
(	O
np	*(struct)
->	O
allocsize	O
%	O
vm_page_size	O
==	O
0	int
)	O
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
allocpages	int
=	O
np	*(struct)
->	O
allocsize	O
/	O
vm_page_size	O
;	O
break	O
;	O
case	O
DT_CHR	O
:	O
case	O
DT_BLK	O
:	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
chr	long
=	O
np	*(struct)
->	O
dn_stat	O
.	O
st_rdev	O
;	O
break	O
;	O
}	O
}	O
free	()->(int)
(	O
np	*(struct)
)	O
;	O
}	O
static	O
void	O
recompute_blocks	(*(struct))->(void)
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
)	O
{	O
struct	O
disknode	struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long),*(struct),*(*(struct)))
*	O
const	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
=	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
;	O
struct	O
stat	O
*	O
const	O
st	*(struct)
=	O
&	O
np	*(struct)
->	O
dn_stat	O
;	O
st	*(struct)
->	O
st_blocks	O
=	O
sizeof	O
*	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
+	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
translen	long
;	O
switch	O
(	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
type	int
)	O
{	O
case	O
DT_REG	O
:	O
np	*(struct)
->	O
allocsize	O
=	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
allocpages	int
*	O
vm_page_size	O
;	O
st	*(struct)
->	O
st_blocks	O
+=	O
np	*(struct)
->	O
allocsize	O
;	O
break	O
;	O
case	O
DT_LNK	O
:	O
st	*(struct)
->	O
st_blocks	O
+=	O
st	*(struct)
->	O
st_size	O
+	O
1	int
;	O
break	O
;	O
case	O
DT_CHR	O
:	O
case	O
DT_BLK	O
:	O
st	*(struct)
->	O
st_rdev	O
=	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
chr	long
;	O
break	O
;	O
case	O
DT_DIR	O
:	O
st	*(struct)
->	O
st_blocks	O
+=	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
size	long
;	O
break	O
;	O
}	O
st	*(struct)
->	O
st_blocks	O
=	O
(	O
st	*(struct)
->	O
st_blocks	O
+	O
511	int
)	O
/	O
512	int
;	O
}	O
error_t	(*(int))->(int)
diskfs_cached_lookup	()->(int)
(	O
ino_t	long
inum	long
,	O
struct	O
node	*(struct)
*	O
*	O
npp	*(*(struct))
)	O
{	O
struct	O
disknode	struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long),*(struct),*(*(struct)))
*	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
=	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	O
)	O
inum	long
;	O
struct	O
node	*(struct)
*	O
np	*(struct)
;	O
assert	()->(int)
(	O
npp	*(*(struct))
)	O
;	O
pthread_rwlock_rdlock	()->(int)
(	O
&	O
all_nodes_lock	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
;	O
if	O
(	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hprevp	*(*(struct))
!=	O
0	int
)	O
goto	O
gotit	O
;	O
else	O
{	O
struct	O
stat	O
*	O
st	*(struct)
;	O
pthread_rwlock_unlock	()->(int)
(	O
&	O
all_nodes_lock	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
;	O
np	*(struct)
=	O
diskfs_make_node	()->(int)
(	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
)	O
;	O
np	*(struct)
->	O
cache_id	O
=	O
(	O
ino_t	long
)	O
(	O
uintptr_t	O
)	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
;	O
pthread_rwlock_wrlock	()->(int)
(	O
&	O
all_nodes_lock	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
;	O
if	O
(	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hprevp	*(*(struct))
!=	O
NULL	O
)	O
{	O
diskfs_nrele	()->(int)
(	O
np	*(struct)
)	O
;	O
goto	O
gotit	O
;	O
}	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hnext	*(struct)
=	O
all_nodes	*(struct)
;	O
if	O
(	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hnext	*(struct)
)	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hnext	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hprevp	*(*(struct))
=	O
&	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hnext	*(struct)
;	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hprevp	*(*(struct))
=	O
&	O
all_nodes	*(struct)
;	O
all_nodes	*(struct)
=	O
np	*(struct)
;	O
all_nodes_nr_items	long
+=	O
1	int
;	O
diskfs_nref_light	()->(int)
(	O
np	*(struct)
)	O
;	O
pthread_rwlock_unlock	()->(int)
(	O
&	O
all_nodes_lock	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
;	O
st	*(struct)
=	O
&	O
np	*(struct)
->	O
dn_stat	O
;	O
memset	O
(	O
st	*(struct)
,	O
0	int
,	O
sizeof	O
*	O
st	*(struct)
)	O
;	O
st	*(struct)
->	O
st_fstype	O
=	O
FSTYPE_MEMFS	O
;	O
st	*(struct)
->	O
st_fsid	O
=	O
getpid	()->(int)
(	O
)	O
;	O
st	*(struct)
->	O
st_blksize	O
=	O
vm_page_size	O
;	O
st	*(struct)
->	O
st_ino	O
=	O
(	O
ino_t	long
)	O
(	O
uintptr_t	O
)	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
;	O
st	*(struct)
->	O
st_gen	O
=	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
gen	int
;	O
st	*(struct)
->	O
st_size	O
=	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
size	long
;	O
st	*(struct)
->	O
st_mode	O
=	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
mode	int
;	O
st	*(struct)
->	O
st_nlink	O
=	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
nlink	long
;	O
st	*(struct)
->	O
st_uid	O
=	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
uid	int
;	O
st	*(struct)
->	O
st_author	O
=	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
author	int
;	O
st	*(struct)
->	O
st_gid	O
=	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
gid	int
;	O
st	*(struct)
->	O
st_atim	O
=	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
atime	struct(long,long)
;	O
st	*(struct)
->	O
st_mtim	O
=	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
mtime	struct(long,long)
;	O
st	*(struct)
->	O
st_ctim	O
=	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
ctime	struct(long,long)
;	O
st	*(struct)
->	O
st_flags	O
=	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
flags	int
;	O
st	*(struct)
->	O
st_rdev	O
=	O
0	int
;	O
np	*(struct)
->	O
allocsize	O
=	O
0	int
;	O
recompute_blocks	(*(struct))->(void)
(	O
np	*(struct)
)	O
;	O
}	O
pthread_mutex_lock	()->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
*	O
npp	*(*(struct))
=	O
np	*(struct)
;	O
return	O
0	int
;	O
gotit	O
:	O
np	*(struct)
=	O
*	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hprevp	*(*(struct))
;	O
assert	()->(int)
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
==	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
)	O
;	O
assert	()->(int)
(	O
*	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hprevp	*(*(struct))
==	O
np	*(struct)
)	O
;	O
diskfs_nref	()->(int)
(	O
np	*(struct)
)	O
;	O
pthread_rwlock_unlock	()->(int)
(	O
&	O
all_nodes_lock	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
*	O
npp	*(*(struct))
=	O
np	*(struct)
;	O
return	O
0	int
;	O
}	O
error_t	(*(int))->(int)
diskfs_node_iterate	((*(int))->(int))->(int)
(	O
error_t	(*(int))->(int)
(	O
*	O
fun	*(int)
)	O
(	O
struct	O
node	*(struct)
*	O
)	O
)	O
{	O
error_t	(*(int))->(int)
err	O
=	O
0	int
;	O
size_t	long
num_nodes	long
;	O
struct	O
node	*(struct)
*	O
node	*(struct)
,	O
*	O
*	O
node_list	*(*(struct))
,	O
*	O
*	O
p	*(*(struct))
;	O
pthread_rwlock_rdlock	()->(int)
(	O
&	O
all_nodes_lock	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
;	O
num_nodes	long
=	O
all_nodes_nr_items	long
;	O
p	*(*(struct))
=	O
node_list	*(*(struct))
=	O
alloca	O
(	O
num_nodes	long
*	O
sizeof	O
(	O
struct	O
node	*(struct)
*	O
)	O
)	O
;	O
for	O
(	O
node	*(struct)
=	O
all_nodes	*(struct)
;	O
node	*(struct)
!=	O
0	int
;	O
node	*(struct)
=	O
node	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hnext	*(struct)
)	O
{	O
*	O
p	*(*(struct))
++	O
=	O
node	*(struct)
;	O
refcounts_ref	()->(int)
(	O
&	O
node	*(struct)
->	O
refcounts	O
,	O
NULL	O
)	O
;	O
}	O
pthread_rwlock_unlock	()->(int)
(	O
&	O
all_nodes_lock	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
;	O
p	*(*(struct))
=	O
node_list	*(*(struct))
;	O
while	O
(	O
num_nodes	long
--	O
>	O
0	int
)	O
{	O
node	*(struct)
=	O
*	O
p	*(*(struct))
++	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
pthread_mutex_lock	()->(int)
(	O
&	O
node	*(struct)
->	O
lock	O
)	O
;	O
err	O
=	O
(	O
*	O
fun	*(int)
)	O
(	O
node	*(struct)
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
node	*(struct)
->	O
lock	O
)	O
;	O
}	O
diskfs_nrele	()->(int)
(	O
node	*(struct)
)	O
;	O
}	O
return	O
err	O
;	O
}	O
void	O
diskfs_try_dropping_softrefs	(*(struct))->(void)
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
)	O
{	O
pthread_rwlock_wrlock	()->(int)
(	O
&	O
all_nodes_lock	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
;	O
if	O
(	O
np	*(struct)
->	O
cache_id	O
!=	O
0	int
)	O
{	O
struct	O
references	O
result	struct
;	O
refcounts_references	()->(int)
(	O
&	O
np	*(struct)
->	O
refcounts	O
,	O
&	O
result	struct
)	O
;	O
if	O
(	O
result	struct
.	O
hard	O
>	O
0	int
)	O
{	O
pthread_rwlock_unlock	()->(int)
(	O
&	O
all_nodes_lock	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
;	O
return	O
;	O
}	O
np	*(struct)
->	O
cache_id	O
=	O
0	int
;	O
diskfs_nrele_light	()->(int)
(	O
np	*(struct)
)	O
;	O
}	O
pthread_rwlock_unlock	()->(int)
(	O
&	O
all_nodes_lock	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
;	O
}	O
void	O
diskfs_lost_hardrefs	(*(struct))->(void)
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
)	O
{	O
}	O
void	O
diskfs_new_hardrefs	(*(struct))->(void)
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
)	O
{	O
}	O
error_t	(*(int))->(int)
diskfs_get_translator	(*(struct),*(*(char)),*(int))->(int)
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
,	O
char	O
*	O
*	O
namep	*(*(char))
,	O
u_int	int
*	O
namelen	int
)	O
{	O
*	O
namelen	int
=	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
translen	long
;	O
if	O
(	O
*	O
namelen	int
==	O
0	int
)	O
return	O
0	int
;	O
*	O
namep	*(*(char))
=	O
malloc	O
(	O
*	O
namelen	int
)	O
;	O
if	O
(	O
*	O
namep	*(*(char))
==	O
0	int
)	O
return	O
ENOMEM	O
;	O
memcpy	O
(	O
*	O
namep	*(*(char))
,	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
trans	*(char)
,	O
*	O
namelen	int
)	O
;	O
return	O
0	int
;	O
}	O
error_t	(*(int))->(int)
diskfs_set_translator	(*(struct),*(char),int,*(struct))->(int)
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
,	O
const	O
char	O
*	O
name	array(char)
,	O
u_int	int
namelen	int
,	O
struct	O
protid	O
*	O
cred	*(struct)
)	O
{	O
char	O
*	O
new	*(char)
;	O
if	O
(	O
namelen	int
==	O
0	int
)	O
{	O
free	()->(int)
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
trans	*(char)
)	O
;	O
new	*(char)
=	O
0	int
;	O
np	*(struct)
->	O
dn_stat	O
.	O
st_mode	O
&=	O
~	O
S_IPTRANS	O
;	O
}	O
else	O
{	O
new	*(char)
=	O
realloc	O
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
trans	*(char)
,	O
namelen	int
)	O
;	O
if	O
(	O
new	*(char)
==	O
0	int
)	O
return	O
ENOSPC	O
;	O
memcpy	O
(	O
new	*(char)
,	O
name	array(char)
,	O
namelen	int
)	O
;	O
np	*(struct)
->	O
dn_stat	O
.	O
st_mode	O
|=	O
S_IPTRANS	O
;	O
}	O
adjust_used	(long)->(void)
(	O
namelen	int
-	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
translen	long
)	O
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
trans	*(char)
=	O
new	*(char)
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
translen	long
=	O
namelen	int
;	O
recompute_blocks	(*(struct))->(void)
(	O
np	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	(*(int))->(int)
create_symlink_hook	(*(struct),*(char))->(int)
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
,	O
const	O
char	O
*	O
target	*(char)
)	O
{	O
assert	()->(int)
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
lnk	*(char)
==	O
0	int
)	O
;	O
np	*(struct)
->	O
dn_stat	O
.	O
st_size	O
=	O
strlen	O
(	O
target	*(char)
)	O
;	O
if	O
(	O
np	*(struct)
->	O
dn_stat	O
.	O
st_size	O
>	O
0	int
)	O
{	O
const	O
size_t	long
size	long
=	O
np	*(struct)
->	O
dn_stat	O
.	O
st_size	O
+	O
1	int
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
lnk	*(char)
=	O
malloc	O
(	O
size	long
)	O
;	O
if	O
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
lnk	*(char)
==	O
0	int
)	O
return	O
ENOSPC	O
;	O
memcpy	O
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
lnk	*(char)
,	O
target	*(char)
,	O
size	long
)	O
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
type	int
=	O
DT_LNK	O
;	O
adjust_used	(long)->(void)
(	O
size	long
)	O
;	O
recompute_blocks	(*(struct))->(void)
(	O
np	*(struct)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
error_t	(*(int))->(int)
(	O
*	O
diskfs_create_symlink_hook	*(int)
)	O
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
,	O
const	O
char	O
*	O
target	*(char)
)	O
=	O
create_symlink_hook	(*(struct),*(char))->(int)
;	O
static	O
error_t	(*(int))->(int)
read_symlink_hook	(*(struct),*(char))->(int)
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
,	O
char	O
*	O
target	*(char)
)	O
{	O
memcpy	O
(	O
target	*(char)
,	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
lnk	*(char)
,	O
np	*(struct)
->	O
dn_stat	O
.	O
st_size	O
+	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
error_t	(*(int))->(int)
(	O
*	O
diskfs_read_symlink_hook	*(int)
)	O
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
,	O
char	O
*	O
target	*(char)
)	O
=	O
read_symlink_hook	(*(struct),*(char))->(int)
;	O
void	O
diskfs_write_disknode	(*(struct),int)->(void)
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
,	O
int	O
wait	int
)	O
{	O
}	O
void	O
diskfs_file_update	(*(struct),int)->(void)
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
,	O
int	O
wait	int
)	O
{	O
diskfs_node_update	()->(int)
(	O
np	*(struct)
,	O
wait	int
)	O
;	O
}	O
error_t	(*(int))->(int)
diskfs_node_reload	(*(struct))->(int)
(	O
struct	O
node	*(struct)
*	O
node	*(struct)
)	O
{	O
return	O
0	int
;	O
}	O
error_t	(*(int))->(int)
diskfs_truncate	(*(struct),long)->(int)
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
,	O
off_t	long
size	long
)	O
{	O
if	O
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
type	int
==	O
DT_LNK	O
)	O
{	O
free	()->(int)
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
lnk	*(char)
)	O
;	O
adjust_used	(long)->(void)
(	O
size	long
-	O
np	*(struct)
->	O
dn_stat	O
.	O
st_size	O
)	O
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
lnk	*(char)
=	O
0	int
;	O
np	*(struct)
->	O
dn_stat	O
.	O
st_size	O
=	O
size	long
;	O
return	O
0	int
;	O
}	O
if	O
(	O
np	*(struct)
->	O
allocsize	O
<=	O
size	long
)	O
return	O
0	int
;	O
assert	()->(int)
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
type	int
==	O
DT_REG	O
)	O
;	O
if	O
(	O
default_pager	int
==	O
MACH_PORT_NULL	O
)	O
return	O
EIO	O
;	O
np	*(struct)
->	O
dn_stat	O
.	O
st_size	O
=	O
size	long
;	O
off_t	long
set_size	long
=	O
size	long
;	O
size	long
=	O
round_page	()->(int)
(	O
size	long
)	O
;	O
if	O
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
memobj	int
!=	O
MACH_PORT_NULL	O
)	O
{	O
error_t	(*(int))->(int)
err	O
=	O
default_pager_object_set_size	O
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
memobj	int
,	O
set_size	long
)	O
;	O
if	O
(	O
err	O
==	O
MIG_BAD_ID	O
)	O
return	O
0	int
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
}	O
adjust_used	(long)->(void)
(	O
size	long
-	O
np	*(struct)
->	O
allocsize	O
)	O
;	O
np	*(struct)
->	O
dn_stat	O
.	O
st_blocks	O
+=	O
(	O
size	long
-	O
np	*(struct)
->	O
allocsize	O
)	O
/	O
512	int
;	O
np	*(struct)
->	O
allocsize	O
=	O
size	long
;	O
return	O
0	int
;	O
}	O
error_t	(*(int))->(int)
diskfs_grow	(*(struct),long,*(struct))->(int)
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
,	O
off_t	long
size	long
,	O
struct	O
protid	O
*	O
cred	*(struct)
)	O
{	O
assert	()->(int)
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
type	int
==	O
DT_REG	O
)	O
;	O
if	O
(	O
np	*(struct)
->	O
allocsize	O
>=	O
size	long
)	O
return	O
0	int
;	O
off_t	long
set_size	long
=	O
size	long
;	O
size	long
=	O
round_page	()->(int)
(	O
size	long
)	O
;	O
if	O
(	O
round_page	()->(int)
(	O
get_used	()->(long)
(	O
)	O
+	O
size	long
-	O
np	*(struct)
->	O
allocsize	O
)	O
/	O
vm_page_size	O
>	O
tmpfs_page_limit	long
)	O
return	O
ENOSPC	O
;	O
if	O
(	O
default_pager	int
==	O
MACH_PORT_NULL	O
)	O
return	O
EIO	O
;	O
if	O
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
memobj	int
!=	O
MACH_PORT_NULL	O
)	O
{	O
error_t	(*(int))->(int)
err	O
=	O
default_pager_object_set_size	O
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
memobj	int
,	O
set_size	long
)	O
;	O
if	O
(	O
err	O
==	O
MIG_BAD_ID	O
)	O
err	O
=	O
0	int
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
}	O
adjust_used	(long)->(void)
(	O
size	long
-	O
np	*(struct)
->	O
allocsize	O
)	O
;	O
np	*(struct)
->	O
dn_stat	O
.	O
st_blocks	O
+=	O
(	O
size	long
-	O
np	*(struct)
->	O
allocsize	O
)	O
/	O
512	int
;	O
np	*(struct)
->	O
allocsize	O
=	O
size	long
;	O
return	O
0	int
;	O
}	O
mach_port_t	O
diskfs_get_filemap	(*(struct),int)->(int)
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
,	O
vm_prot_t	O
prot	int
)	O
{	O
error_t	(*(int))->(int)
err	O
;	O
if	O
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
type	int
!=	O
DT_REG	O
)	O
{	O
errno	O
=	O
EOPNOTSUPP	O
;	O
return	O
MACH_PORT_NULL	O
;	O
}	O
if	O
(	O
default_pager	int
==	O
MACH_PORT_NULL	O
)	O
{	O
errno	O
=	O
EIO	O
;	O
return	O
MACH_PORT_NULL	O
;	O
}	O
if	O
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
memobj	int
==	O
MACH_PORT_NULL	O
)	O
{	O
error_t	(*(int))->(int)
err	O
=	O
default_pager_object_create	O
(	O
default_pager	int
,	O
&	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
memobj	int
,	O
np	*(struct)
->	O
allocsize	O
)	O
;	O
if	O
(	O
err	O
)	O
{	O
errno	O
=	O
err	O
;	O
return	O
MACH_PORT_NULL	O
;	O
}	O
assert	()->(int)
(	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
memobj	int
!=	O
MACH_PORT_NULL	O
)	O
;	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
memref	int
=	O
0	int
;	O
vm_map	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
&	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
memref	int
,	O
4096	int
,	O
0	int
,	O
1	int
,	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
memobj	int
,	O
0	int
,	O
0	int
,	O
VM_PROT_NONE	O
,	O
VM_PROT_NONE	O
,	O
VM_INHERIT_NONE	O
)	O
;	O
assert_perror	()->(int)
(	O
err	O
)	O
;	O
}	O
err	O
=	O
mach_port_mod_refs	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
memobj	int
,	O
MACH_PORT_RIGHT_SEND	O
,	O
+	O
1	int
)	O
;	O
assert_perror	()->(int)
(	O
err	O
)	O
;	O
return	O
np	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
reg	struct(int,int,int)
.	O
memobj	int
;	O
}	O
struct	O
pager	O
*	O
diskfs_get_filemap_pager_struct	(*(struct))->(*(struct))
(	O
struct	O
node	*(struct)
*	O
np	*(struct)
)	O
{	O
return	O
0	int
;	O
}	O
int	O
diskfs_pager_users	()->(int)
(	O
)	O
{	O
return	O
0	int
;	O
}	O
void	O
diskfs_shutdown_pager	()->(void)
(	O
)	O
{	O
}	O
vm_prot_t	O
diskfs_max_user_pager_prot	()->(int)
(	O
)	O
{	O
return	O
VM_PROT_READ	O
;	O
}	O
error_t	(*(int))->(int)
diskfs_S_file_get_storage_info	(*(struct),*(*(int)),*(int),*(int),*(*(int)),*(int),*(*(long)),*(int),*(*(char)),*(int))->(int)
(	O
struct	O
protid	O
*	O
cred	*(struct)
,	O
mach_port_t	O
*	O
*	O
ports	*(*(int))
,	O
mach_msg_type_name_t	O
*	O
ports_type	*(int)
,	O
mach_msg_type_number_t	O
*	O
num_ports	*(int)
,	O
int	O
*	O
*	O
ints	*(*(int))
,	O
mach_msg_type_number_t	O
*	O
num_ints	*(int)
,	O
off_t	long
*	O
*	O
offsets	*(*(long))
,	O
mach_msg_type_number_t	O
*	O
num_offsets	*(int)
,	O
char	O
*	O
*	O
data	*(*(char))
,	O
mach_msg_type_number_t	O
*	O
data_len	*(int)
)	O
{	O
mach_port_t	O
memobj	int
=	O
diskfs_get_filemap	(*(struct),int)->(int)
(	O
cred	*(struct)
->	O
po	O
->	O
np	*(struct)
,	O
VM_PROT_ALL	O
)	O
;	O
if	O
(	O
memobj	int
==	O
MACH_PORT_NULL	O
)	O
return	O
errno	O
;	O
assert	()->(int)
(	O
*	O
num_ports	*(int)
>=	O
1	int
)	O
;	O
*	O
num_ports	*(int)
=	O
1	int
;	O
*	O
ports_type	*(int)
=	O
MACH_MSG_TYPE_MOVE_SEND	O
;	O
(	O
*	O
ports	*(*(int))
)	O
[	O
0	int
]	O
=	O
(	O
cred	*(struct)
->	O
po	O
->	O
openstat	O
&	O
O_RDWR	O
)	O
==	O
O_RDWR	O
?	O
memobj	int
:	O
MACH_PORT_NULL	O
;	O
assert	()->(int)
(	O
*	O
num_offsets	*(int)
>=	O
2	int
)	O
;	O
*	O
num_offsets	*(int)
=	O
2	int
;	O
(	O
*	O
offsets	*(*(long))
)	O
[	O
0	int
]	O
=	O
0	int
;	O
(	O
*	O
offsets	*(*(long))
)	O
[	O
1	int
]	O
=	O
cred	*(struct)
->	O
po	O
->	O
np	*(struct)
->	O
dn_stat	O
.	O
st_size	O
;	O
assert	()->(int)
(	O
*	O
num_ints	*(int)
>=	O
6	int
)	O
;	O
*	O
num_ints	*(int)
=	O
6	int
;	O
(	O
*	O
ints	*(*(int))
)	O
[	O
0	int
]	O
=	O
STORAGE_MEMORY	O
;	O
(	O
*	O
ints	*(*(int))
)	O
[	O
1	int
]	O
=	O
(	O
cred	*(struct)
->	O
po	O
->	O
openstat	O
&	O
O_WRITE	O
)	O
?	O
0	int
:	O
STORE_READONLY	O
;	O
(	O
*	O
ints	*(*(int))
)	O
[	O
2	int
]	O
=	O
1	int
;	O
(	O
*	O
ints	*(*(int))
)	O
[	O
3	int
]	O
=	O
1	int
;	O
(	O
*	O
ints	*(*(int))
)	O
[	O
4	int
]	O
=	O
0	int
;	O
(	O
*	O
ints	*(*(int))
)	O
[	O
5	int
]	O
=	O
0	int
;	O
*	O
data_len	*(int)
=	O
0	int
;	O
return	O
0	int
;	O
}	O
