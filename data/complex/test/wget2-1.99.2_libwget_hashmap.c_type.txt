typedef	O
struct	O
_entry_st	struct(*(void),*(void),*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int)),int)
_entry_t	struct
;	O
struct	O
_entry_st	struct(*(void),*(void),*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int)),int)
{	O
void	O
*	O
key	int
,	O
*	O
value	*(void)
;	O
_entry_t	struct
*	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
;	O
unsigned	O
int	O
hash	*((*(void))->(int))
;	O
}	O
;	O
struct	O
wget_hashmap_st	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((*(void))->(void)),*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int))),int,int,int,float,float)
{	O
wget_hashmap_hash_fn	(*(void))->(int)
*	O
hash	*((*(void))->(int))
;	O
wget_hashmap_compare_fn	(*(void),*(void))->(int)
*	O
cmp	*((*(void),*(void))->(int))
;	O
wget_hashmap_key_destructor	(*(void))->(void)
*	O
key_destructor	*((*(void))->(void))
;	O
wget_hashmap_value_destructor	(*(void))->(void)
*	O
value_destructor	*((*(void))->(void))
;	O
_entry_t	struct
*	O
*	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
;	O
int	O
max	int
,	O
cur	int
,	O
threshold	int
;	O
float	O
resize_factor	float
,	O
load_factor	float
;	O
}	O
;	O
struct	O
wget_hashmap_iterator_st	struct(*(struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((*(void))->(void)),*(*(struct(*`,*`,*`,int))),int,int,int,float,float)),*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int)),int)
{	O
struct	O
wget_hashmap_st	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((*(void))->(void)),*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int))),int,int,int,float,float)
*	O
h	*(struct)
;	O
_entry_t	struct
*	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
;	O
int	O
pos	int
;	O
}	O
;	O
wget_hashmap_iterator	struct
*	O
wget_hashmap_iterator_alloc	(*(struct))->(*(struct))
(	O
wget_hashmap	struct
*	O
h	*(struct)
)	O
{	O
struct	O
wget_hashmap_iterator_st	struct(*(struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((*(void))->(void)),*(*(struct(*`,*`,*`,int))),int,int,int,float,float)),*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int)),int)
*	O
iter	*(*(struct))
=	O
wget_calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
struct	O
wget_hashmap_iterator_st	struct(*(struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((*(void))->(void)),*(*(struct(*`,*`,*`,int))),int,int,int,float,float)),*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int)),int)
)	O
)	O
;	O
if	O
(	O
iter	*(*(struct))
)	O
iter	*(*(struct))
->	O
h	*(struct)
=	O
h	*(struct)
;	O
return	O
(	O
wget_hashmap_iterator	struct
*	O
)	O
iter	*(*(struct))
;	O
}	O
void	O
wget_hashmap_iterator_free	(*(*(struct)))->(void)
(	O
wget_hashmap_iterator	struct
*	O
*	O
iter	*(*(struct))
)	O
{	O
if	O
(	O
iter	*(*(struct))
)	O
xfree	O
(	O
*	O
iter	*(*(struct))
)	O
;	O
}	O
void	O
*	O
wget_hashmap_iterator_next	(*(struct),*(*(void)))->(*(void))
(	O
wget_hashmap_iterator	struct
*	O
iter	*(*(struct))
,	O
void	O
*	O
*	O
value	*(void)
)	O
{	O
struct	O
wget_hashmap_iterator_st	struct(*(struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((*(void))->(void)),*(*(struct(*`,*`,*`,int))),int,int,int,float,float)),*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int)),int)
*	O
_iter	*(struct(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*`),int,int,int,float,float)),*(struct(*(void),*(void),*(struct`),int)),int))
=	O
(	O
struct	O
wget_hashmap_iterator_st	struct(*(struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((*(void))->(void)),*(*(struct(*`,*`,*`,int))),int,int,int,float,float)),*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int)),int)
*	O
)	O
iter	*(*(struct))
;	O
struct	O
wget_hashmap_st	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((*(void))->(void)),*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int))),int,int,int,float,float)
*	O
h	*(struct)
=	O
_iter	*(struct(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*`),int,int,int,float,float)),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
h	*(struct)
;	O
if	O
(	O
_iter	*(struct(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*`),int,int,int,float,float)),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
)	O
{	O
if	O
(	O
(	O
_iter	*(struct(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*`),int,int,int,float,float)),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
_iter	*(struct(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*`),int,int,int,float,float)),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
)	O
)	O
{	O
found	O
:	O
if	O
(	O
value	*(void)
)	O
*	O
value	*(void)
=	O
_iter	*(struct(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*`),int,int,int,float,float)),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
;	O
return	O
_iter	*(struct(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*`),int,int,int,float,float)),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
;	O
}	O
_iter	*(struct(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*`),int,int,int,float,float)),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
pos	int
++	O
;	O
}	O
if	O
(	O
!	O
_iter	*(struct(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*`),int,int,int,float,float)),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
)	O
{	O
for	O
(	O
;	O
_iter	*(struct(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*`),int,int,int,float,float)),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
pos	int
<	O
h	*(struct)
->	O
max	int
;	O
_iter	*(struct(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*`),int,int,int,float,float)),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
pos	int
++	O
)	O
{	O
if	O
(	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
[	O
_iter	*(struct(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*`),int,int,int,float,float)),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
pos	int
]	O
)	O
{	O
_iter	*(struct(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*`),int,int,int,float,float)),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
[	O
_iter	*(struct(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*`),int,int,int,float,float)),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
pos	int
]	O
;	O
goto	O
found	O
;	O
}	O
}	O
}	O
return	O
NULL	O
;	O
}	O
wget_hashmap	struct
*	O
wget_hashmap_create	(int,*((*(void))->(int)),*((*(void),*(void))->(int)))->(*(struct))
(	O
int	O
max	int
,	O
wget_hashmap_hash_fn	(*(void))->(int)
*	O
hash	*((*(void))->(int))
,	O
wget_hashmap_compare_fn	(*(void),*(void))->(int)
*	O
cmp	*((*(void),*(void))->(int))
)	O
{	O
wget_hashmap	struct
*	O
h	*(struct)
=	O
wget_malloc	(long)->(*(void))
(	O
sizeof	O
(	O
wget_hashmap	struct
)	O
)	O
;	O
if	O
(	O
!	O
h	*(struct)
)	O
return	O
NULL	O
;	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
wget_calloc	(long,long)->(*(void))
(	O
max	int
,	O
sizeof	O
(	O
_entry_t	struct
*	O
)	O
)	O
;	O
if	O
(	O
!	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
)	O
{	O
xfree	O
(	O
h	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
h	*(struct)
->	O
max	int
=	O
max	int
;	O
h	*(struct)
->	O
cur	int
=	O
0	int
;	O
h	*(struct)
->	O
resize_factor	float
=	O
2	int
;	O
h	*(struct)
->	O
hash	*((*(void))->(int))
=	O
hash	*((*(void))->(int))
;	O
h	*(struct)
->	O
cmp	*((*(void),*(void))->(int))
=	O
cmp	*((*(void),*(void))->(int))
;	O
h	*(struct)
->	O
key_destructor	*((*(void))->(void))
=	O
free	(*(void))->(void)
;	O
h	*(struct)
->	O
value_destructor	*((*(void))->(void))
=	O
free	(*(void))->(void)
;	O
h	*(struct)
->	O
load_factor	float
=	O
0.75	int
;	O
h	*(struct)
->	O
threshold	int
=	O
(	O
int	O
)	O
(	O
max	int
*	O
h	*(struct)
->	O
load_factor	float
)	O
;	O
return	O
h	*(struct)
;	O
}	O
WGET_GCC_NONNULL_ALL	O
static	O
_entry_t	struct
*	O
hashmap_find_entry	(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*(struct`)),int,int,int,float,float)),*(char),int)->(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
(	O
const	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
const	O
char	O
*	O
key	int
,	O
unsigned	O
int	O
hash	*((*(void))->(int))
)	O
{	O
for	O
(	O
_entry_t	struct
*	O
e	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
=	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
[	O
hash	*((*(void))->(int))
%	O
h	*(struct)
->	O
max	int
]	O
;	O
e	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
;	O
e	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
=	O
e	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
)	O
{	O
if	O
(	O
hash	*((*(void))->(int))
==	O
e	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
hash	*((*(void))->(int))
&&	O
(	O
key	int
==	O
e	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
key	int
||	O
!	O
h	*(struct)
->	O
cmp	*((*(void),*(void))->(int))
(	O
key	int
,	O
e	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
key	int
)	O
)	O
)	O
{	O
return	O
e	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
WGET_GCC_NONNULL_ALL	O
static	O
void	O
hashmap_rehash	(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*(struct`)),int,int,int,float,float)),*(*(struct(*(void),*(void),*(struct`),int))),int,int)->(void)
(	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
_entry_t	struct
*	O
*	O
new_entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
,	O
int	O
newmax	int
,	O
int	O
recalc_hash	int
)	O
{	O
_entry_t	struct
*	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
,	O
*	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
;	O
int	O
cur	int
=	O
h	*(struct)
->	O
cur	int
;	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
h	*(struct)
->	O
max	int
&&	O
cur	int
;	O
it	int
++	O
)	O
{	O
for	O
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
[	O
it	int
]	O
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
)	O
{	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
=	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
;	O
if	O
(	O
recalc_hash	int
)	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
hash	*((*(void))->(int))
=	O
h	*(struct)
->	O
hash	*((*(void))->(int))
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
)	O
;	O
int	O
pos	int
=	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
hash	*((*(void))->(int))
%	O
newmax	int
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
=	O
new_entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
[	O
pos	int
]	O
;	O
new_entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
[	O
pos	int
]	O
=	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
;	O
cur	int
--	O
;	O
}	O
}	O
xfree	O
(	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
)	O
;	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
new_entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
;	O
h	*(struct)
->	O
max	int
=	O
newmax	int
;	O
h	*(struct)
->	O
threshold	int
=	O
(	O
int	O
)	O
(	O
newmax	int
*	O
h	*(struct)
->	O
load_factor	float
)	O
;	O
}	O
WGET_GCC_NONNULL	O
(	O
(	O
1	int
,	O
3	int
)	O
)	O
static	O
int	O
hashmap_new_entry	(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*(struct`)),int,int,int,float,float)),int,*(char),*(char))->(int)
(	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
unsigned	O
int	O
hash	*((*(void))->(int))
,	O
const	O
char	O
*	O
key	int
,	O
const	O
char	O
*	O
value	*(void)
)	O
{	O
_entry_t	struct
*	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
;	O
if	O
(	O
!	O
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
wget_malloc	(long)->(*(void))
(	O
sizeof	O
(	O
_entry_t	struct
)	O
)	O
)	O
)	O
return	O
WGET_E_MEMORY	int
;	O
int	O
pos	int
=	O
hash	*((*(void))->(int))
%	O
h	*(struct)
->	O
max	int
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
=	O
(	O
void	O
*	O
)	O
key	int
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
=	O
(	O
void	O
*	O
)	O
value	*(void)
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
hash	*((*(void))->(int))
=	O
hash	*((*(void))->(int))
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
=	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
[	O
pos	int
]	O
;	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
[	O
pos	int
]	O
=	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
;	O
if	O
(	O
++	O
h	*(struct)
->	O
cur	int
>=	O
h	*(struct)
->	O
threshold	int
)	O
{	O
int	O
newsize	int
=	O
(	O
int	O
)	O
(	O
h	*(struct)
->	O
max	int
*	O
h	*(struct)
->	O
resize_factor	float
)	O
;	O
if	O
(	O
newsize	int
>	O
0	int
)	O
{	O
_entry_t	struct
*	O
*	O
new_entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
;	O
if	O
(	O
!	O
(	O
new_entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
wget_calloc	(long,long)->(*(void))
(	O
newsize	int
,	O
sizeof	O
(	O
_entry_t	struct
*	O
)	O
)	O
)	O
)	O
{	O
h	*(struct)
->	O
cur	int
--	O
;	O
xfree	O
(	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
[	O
pos	int
]	O
)	O
;	O
return	O
WGET_E_MEMORY	int
;	O
}	O
hashmap_rehash	(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*(struct`)),int,int,int,float,float)),*(*(struct(*(void),*(void),*(struct`),int))),int,int)->(void)
(	O
h	*(struct)
,	O
new_entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
,	O
newsize	int
,	O
0	int
)	O
;	O
}	O
}	O
return	O
WGET_E_SUCCESS	int
;	O
}	O
int	O
wget_hashmap_put	(*(struct),*(void),*(void))->(int)
(	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
const	O
void	O
*	O
key	int
,	O
const	O
void	O
*	O
value	*(void)
)	O
{	O
if	O
(	O
h	*(struct)
&&	O
key	int
)	O
{	O
_entry_t	struct
*	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
;	O
unsigned	O
int	O
hash	*((*(void))->(int))
=	O
h	*(struct)
->	O
hash	*((*(void))->(int))
(	O
key	int
)	O
;	O
int	O
rc	int
;	O
if	O
(	O
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
hashmap_find_entry	(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*(struct`)),int,int,int,float,float)),*(char),int)->(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
(	O
h	*(struct)
,	O
key	int
,	O
hash	*((*(void))->(int))
)	O
)	O
)	O
{	O
if	O
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
!=	O
key	int
&&	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
!=	O
value	*(void)
)	O
{	O
if	O
(	O
h	*(struct)
->	O
key_destructor	*((*(void))->(void))
)	O
h	*(struct)
->	O
key_destructor	*((*(void))->(void))
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
)	O
;	O
if	O
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
==	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
)	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
=	O
NULL	O
;	O
}	O
if	O
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
!=	O
value	*(void)
&&	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
!=	O
key	int
)	O
{	O
if	O
(	O
h	*(struct)
->	O
value_destructor	*((*(void))->(void))
)	O
h	*(struct)
->	O
value_destructor	*((*(void))->(void))
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
)	O
;	O
}	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
=	O
(	O
void	O
*	O
)	O
key	int
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
=	O
(	O
void	O
*	O
)	O
value	*(void)
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
hashmap_new_entry	(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*(struct`)),int,int,int,float,float)),int,*(char),*(char))->(int)
(	O
h	*(struct)
,	O
hash	*((*(void))->(int))
,	O
key	int
,	O
value	*(void)
)	O
)	O
<	O
0	int
)	O
return	O
rc	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
wget_hashmap_contains	(*(struct),*(void))->(int)
(	O
const	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
const	O
void	O
*	O
key	int
)	O
{	O
return	O
wget_hashmap_get	(*(struct),*(void),*(*(void)))->(int)
(	O
h	*(struct)
,	O
key	int
,	O
NULL	O
)	O
;	O
}	O
int	O
wget_hashmap_get	(*(struct),*(void),*(*(void)))->(int)
(	O
const	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
const	O
void	O
*	O
key	int
,	O
void	O
*	O
*	O
value	*(void)
)	O
{	O
if	O
(	O
h	*(struct)
&&	O
key	int
)	O
{	O
_entry_t	struct
*	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
;	O
if	O
(	O
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
hashmap_find_entry	(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*(struct`)),int,int,int,float,float)),*(char),int)->(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
(	O
h	*(struct)
,	O
key	int
,	O
h	*(struct)
->	O
hash	*((*(void))->(int))
(	O
key	int
)	O
)	O
)	O
)	O
{	O
if	O
(	O
value	*(void)
)	O
*	O
value	*(void)
=	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
WGET_GCC_NONNULL_ALL	O
static	O
int	O
hashmap_remove_entry	(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*(struct`)),int,int,int,float,float)),*(char),int)->(int)
(	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
const	O
char	O
*	O
key	int
,	O
int	O
free_kv	int
)	O
{	O
_entry_t	struct
*	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
,	O
*	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
,	O
*	O
prev	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
=	O
NULL	O
;	O
unsigned	O
int	O
hash	*((*(void))->(int))
=	O
h	*(struct)
->	O
hash	*((*(void))->(int))
(	O
key	int
)	O
;	O
int	O
pos	int
=	O
hash	*((*(void))->(int))
%	O
h	*(struct)
->	O
max	int
;	O
for	O
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
[	O
pos	int
]	O
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
;	O
prev	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
=	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
,	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
)	O
{	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
=	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
;	O
if	O
(	O
hash	*((*(void))->(int))
==	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
hash	*((*(void))->(int))
&&	O
(	O
key	int
==	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
||	O
!	O
h	*(struct)
->	O
cmp	*((*(void),*(void))->(int))
(	O
key	int
,	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
)	O
)	O
)	O
{	O
if	O
(	O
prev	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
)	O
prev	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
->	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
=	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
;	O
else	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
[	O
pos	int
]	O
=	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
;	O
if	O
(	O
free_kv	int
)	O
{	O
if	O
(	O
h	*(struct)
->	O
key_destructor	*((*(void))->(void))
)	O
h	*(struct)
->	O
key_destructor	*((*(void))->(void))
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
)	O
;	O
if	O
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
!=	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
)	O
{	O
if	O
(	O
h	*(struct)
->	O
value_destructor	*((*(void))->(void))
)	O
h	*(struct)
->	O
value_destructor	*((*(void))->(void))
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
)	O
;	O
}	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
=	O
NULL	O
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
=	O
NULL	O
;	O
}	O
xfree	O
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
)	O
;	O
h	*(struct)
->	O
cur	int
--	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
wget_hashmap_remove	(*(struct),*(void))->(int)
(	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
const	O
void	O
*	O
key	int
)	O
{	O
if	O
(	O
h	*(struct)
&&	O
key	int
)	O
return	O
hashmap_remove_entry	(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*(struct`)),int,int,int,float,float)),*(char),int)->(int)
(	O
h	*(struct)
,	O
key	int
,	O
1	int
)	O
;	O
else	O
return	O
0	int
;	O
}	O
int	O
wget_hashmap_remove_nofree	(*(struct),*(void))->(int)
(	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
const	O
void	O
*	O
key	int
)	O
{	O
if	O
(	O
h	*(struct)
&&	O
key	int
)	O
return	O
hashmap_remove_entry	(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*(struct`)),int,int,int,float,float)),*(char),int)->(int)
(	O
h	*(struct)
,	O
key	int
,	O
0	int
)	O
;	O
else	O
return	O
0	int
;	O
}	O
void	O
wget_hashmap_free	(*(*(struct)))->(void)
(	O
wget_hashmap	struct
*	O
*	O
h	*(struct)
)	O
{	O
if	O
(	O
h	*(struct)
&&	O
*	O
h	*(struct)
)	O
{	O
wget_hashmap_clear	(*(struct))->(void)
(	O
*	O
h	*(struct)
)	O
;	O
xfree	O
(	O
(	O
*	O
h	*(struct)
)	O
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
)	O
;	O
xfree	O
(	O
*	O
h	*(struct)
)	O
;	O
}	O
}	O
void	O
wget_hashmap_clear	(*(struct))->(void)
(	O
wget_hashmap	struct
*	O
h	*(struct)
)	O
{	O
if	O
(	O
h	*(struct)
)	O
{	O
_entry_t	struct
*	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
,	O
*	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
;	O
int	O
it	int
,	O
cur	int
=	O
h	*(struct)
->	O
cur	int
;	O
for	O
(	O
it	int
=	O
0	int
;	O
it	int
<	O
h	*(struct)
->	O
max	int
&&	O
cur	int
;	O
it	int
++	O
)	O
{	O
for	O
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
[	O
it	int
]	O
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
)	O
{	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
=	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
;	O
if	O
(	O
h	*(struct)
->	O
key_destructor	*((*(void))->(void))
)	O
h	*(struct)
->	O
key_destructor	*((*(void))->(void))
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
)	O
;	O
if	O
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
!=	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
&&	O
h	*(struct)
->	O
value_destructor	*((*(void))->(void))
)	O
h	*(struct)
->	O
value_destructor	*((*(void))->(void))
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
)	O
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
=	O
NULL	O
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
=	O
NULL	O
;	O
xfree	O
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
)	O
;	O
cur	int
--	O
;	O
}	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
[	O
it	int
]	O
=	O
NULL	O
;	O
}	O
h	*(struct)
->	O
cur	int
=	O
0	int
;	O
}	O
}	O
int	O
wget_hashmap_size	(*(struct))->(int)
(	O
const	O
wget_hashmap	struct
*	O
h	*(struct)
)	O
{	O
return	O
h	*(struct)
?	O
h	*(struct)
->	O
cur	int
:	O
0	int
;	O
}	O
int	O
wget_hashmap_browse	(*(struct),*((*(void),*(void),*(void))->(int)),*(void))->(int)
(	O
const	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
wget_hashmap_browse_fn	(*(void),*(void),*(void))->(int)
*	O
browse	*((*(void),*(void))->(int))
,	O
void	O
*	O
ctx	*(void)
)	O
{	O
if	O
(	O
h	*(struct)
&&	O
browse	*((*(void),*(void))->(int))
)	O
{	O
_entry_t	struct
*	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
;	O
int	O
it	int
,	O
ret	int
,	O
cur	int
=	O
h	*(struct)
->	O
cur	int
;	O
for	O
(	O
it	int
=	O
0	int
;	O
it	int
<	O
h	*(struct)
->	O
max	int
&&	O
cur	int
;	O
it	int
++	O
)	O
{	O
for	O
(	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
h	*(struct)
->	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
[	O
it	int
]	O
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
;	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
next	*(struct(*(void),*(void),*(struct(*(void),*(void),*(struct`),int)),int))
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
browse	*((*(void),*(void))->(int))
(	O
ctx	*(void)
,	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
key	int
,	O
entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
->	O
value	*(void)
)	O
)	O
!=	O
0	int
)	O
return	O
ret	int
;	O
cur	int
--	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
void	O
wget_hashmap_setcmpfunc	(*(struct),*((*(void),*(void))->(int)))->(void)
(	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
wget_hashmap_compare_fn	(*(void),*(void))->(int)
*	O
cmp	*((*(void),*(void))->(int))
)	O
{	O
if	O
(	O
h	*(struct)
)	O
h	*(struct)
->	O
cmp	*((*(void),*(void))->(int))
=	O
cmp	*((*(void),*(void))->(int))
;	O
}	O
int	O
wget_hashmap_sethashfunc	(*(struct),*((*(void))->(int)))->(int)
(	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
wget_hashmap_hash_fn	(*(void))->(int)
*	O
hash	*((*(void))->(int))
)	O
{	O
if	O
(	O
!	O
h	*(struct)
)	O
return	O
WGET_E_INVALID	int
;	O
if	O
(	O
!	O
h	*(struct)
->	O
cur	int
)	O
return	O
WGET_E_SUCCESS	int
;	O
_entry_t	struct
*	O
*	O
new_entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
=	O
wget_calloc	(long,long)->(*(void))
(	O
h	*(struct)
->	O
max	int
,	O
sizeof	O
(	O
_entry_t	struct
*	O
)	O
)	O
;	O
if	O
(	O
!	O
new_entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
)	O
return	O
WGET_E_MEMORY	int
;	O
h	*(struct)
->	O
hash	*((*(void))->(int))
=	O
hash	*((*(void))->(int))
;	O
hashmap_rehash	(*(struct(*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*((*`)->(void)),*(*(struct`)),int,int,int,float,float)),*(*(struct(*(void),*(void),*(struct`),int))),int,int)->(void)
(	O
h	*(struct)
,	O
new_entry	*(*(struct(*(void),*(void),*(struct(*`,*`,*`,int)),int)))
,	O
h	*(struct)
->	O
max	int
,	O
1	int
)	O
;	O
return	O
WGET_E_SUCCESS	int
;	O
}	O
void	O
wget_hashmap_set_key_destructor	(*(struct),*((*(void))->(void)))->(void)
(	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
wget_hashmap_key_destructor	(*(void))->(void)
*	O
destructor	*((*(void))->(void))
)	O
{	O
if	O
(	O
h	*(struct)
)	O
h	*(struct)
->	O
key_destructor	*((*(void))->(void))
=	O
destructor	*((*(void))->(void))
;	O
}	O
void	O
wget_hashmap_set_value_destructor	(*(struct),*((*(void))->(void)))->(void)
(	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
wget_hashmap_value_destructor	(*(void))->(void)
*	O
destructor	*((*(void))->(void))
)	O
{	O
if	O
(	O
h	*(struct)
)	O
h	*(struct)
->	O
value_destructor	*((*(void))->(void))
=	O
destructor	*((*(void))->(void))
;	O
}	O
void	O
wget_hashmap_set_load_factor	(*(struct),float)->(void)
(	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
float	O
factor	float
)	O
{	O
if	O
(	O
h	*(struct)
)	O
{	O
h	*(struct)
->	O
load_factor	float
=	O
factor	float
;	O
h	*(struct)
->	O
threshold	int
=	O
(	O
int	O
)	O
(	O
h	*(struct)
->	O
max	int
*	O
h	*(struct)
->	O
load_factor	float
)	O
;	O
}	O
}	O
void	O
wget_hashmap_set_resize_factor	(*(struct),float)->(void)
(	O
wget_hashmap	struct
*	O
h	*(struct)
,	O
float	O
factor	float
)	O
{	O
if	O
(	O
h	*(struct)
)	O
h	*(struct)
->	O
resize_factor	float
=	O
factor	float
;	O
}	O
