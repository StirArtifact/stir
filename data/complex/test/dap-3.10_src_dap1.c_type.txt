extern	O
char	O
*	O
dap_dapname	*(char)
;	O
extern	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
2	int
]	O
;	O
extern	O
DFILE	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))
*	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
2	int
]	O
;	O
extern	O
dataobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
]	O
;	O
extern	O
dataobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
]	O
;	O
extern	O
int	O
dap_ono	int
;	O
extern	O
FILE	struct
*	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
extern	O
FILE	struct
*	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
extern	O
FILE	struct
*	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
extern	O
char	O
*	O
dap_title	*(char)
;	O
extern	O
int	O
dap_maxlines	int
;	O
static	O
int	O
*	O
startmem	*(int)
;	O
static	O
int	O
*	O
start	array(*(int))
[	O
2	int
]	O
;	O
static	O
void	O
sortparse	(array(char),int)->(void)
(	O
char	O
line	array(char)
[	O
]	O
,	O
int	O
which	int
)	O
{	O
int	O
v	int
;	O
int	O
l	int
;	O
int	O
newfield	int
;	O
for	O
(	O
v	int
=	O
0	int
,	O
l	int
=	O
0	int
,	O
newfield	int
=	O
1	int
;	O
line	array(char)
[	O
l	int
]	O
&&	O
line	array(char)
[	O
l	int
]	O
!=	O
'\n'	O
;	O
l	int
++	O
)	O
{	O
if	O
(	O
newfield	int
)	O
start	array(*(int))
[	O
which	int
]	O
[	O
v	int
++	O
]	O
=	O
l	int
;	O
newfield	int
=	O
(	O
line	array(char)
[	O
l	int
]	O
==	O
SETDELIM	char
)	O
;	O
}	O
}	O
static	O
char	O
*	O
mod	*(char)
;	O
static	O
int	O
nmods	int
;	O
static	O
int	O
*	O
varv	array(int)
;	O
static	O
int	O
nvar	int
;	O
static	O
int	O
fieldcmp	(array(char),array(char))->(int)
(	O
char	O
f1	array(char)
[	O
]	O
,	O
char	O
f2	double
[	O
]	O
)	O
{	O
int	O
f	*(()->(double))
;	O
for	O
(	O
f	*(()->(double))
=	O
0	int
;	O
f1	array(char)
[	O
f	*(()->(double))
]	O
&&	O
f1	array(char)
[	O
f	*(()->(double))
]	O
!=	O
SETDELIM	char
&&	O
f1	array(char)
[	O
f	*(()->(double))
]	O
!=	O
'\n'	O
&&	O
f1	array(char)
[	O
f	*(()->(double))
]	O
==	O
f2	double
[	O
f	*(()->(double))
]	O
;	O
f	*(()->(double))
++	O
)	O
;	O
if	O
(	O
f1	array(char)
[	O
f	*(()->(double))
]	O
==	O
f2	double
[	O
f	*(()->(double))
]	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
f1	array(char)
[	O
f	*(()->(double))
]	O
||	O
f1	array(char)
[	O
f	*(()->(double))
]	O
==	O
SETDELIM	char
||	O
f1	array(char)
[	O
f	*(()->(double))
]	O
==	O
'\n'	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
f2	double
[	O
f	*(()->(double))
]	O
||	O
f2	double
[	O
f	*(()->(double))
]	O
==	O
SETDELIM	char
||	O
f2	double
[	O
f	*(()->(double))
]	O
==	O
'\n'	O
)	O
return	O
1	int
;	O
return	O
f1	array(char)
[	O
f	*(()->(double))
]	O
-	O
f2	double
[	O
f	*(()->(double))
]	O
;	O
}	O
static	O
int	O
sortcmp	(*(*(char)),*(*(char)))->(int)
(	O
char	O
*	O
*	O
e0	*(*(char))
,	O
char	O
*	O
*	O
e1	*(*(char))
)	O
{	O
int	O
v	int
;	O
int	O
cmp	int
;	O
cmp	int
=	O
0	int
;	O
sortparse	(array(char),int)->(void)
(	O
*	O
e0	*(*(char))
,	O
0	int
)	O
;	O
sortparse	(array(char),int)->(void)
(	O
*	O
e1	*(*(char))
,	O
1	int
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
cmp	int
=	O
fieldcmp	(array(char),array(char))->(int)
(	O
*	O
e0	*(*(char))
+	O
start	array(*(int))
[	O
0	int
]	O
[	O
varv	array(int)
[	O
v	int
]	O
]	O
,	O
*	O
e1	*(*(char))
+	O
start	array(*(int))
[	O
1	int
]	O
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
if	O
(	O
cmp	int
)	O
break	O
;	O
}	O
if	O
(	O
nmods	int
&&	O
mod	*(char)
[	O
v	int
]	O
==	O
'd'	O
)	O
cmp	int
=	O
-	O
cmp	int
;	O
return	O
cmp	int
;	O
}	O
static	O
int	O
linediff	(array(char),array(char))->(int)
(	O
char	O
l1	array(char)
[	O
]	O
,	O
char	O
l2	array(char)
[	O
]	O
)	O
{	O
int	O
l	int
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l1	array(char)
[	O
l	int
]	O
&&	O
l1	array(char)
[	O
l	int
]	O
!=	O
'\n'	O
&&	O
l1	array(char)
[	O
l	int
]	O
==	O
l2	array(char)
[	O
l	int
]	O
;	O
l	int
++	O
)	O
;	O
return	O
l1	array(char)
[	O
l	int
]	O
!=	O
l2	array(char)
[	O
l	int
]	O
;	O
}	O
static	O
void	O
dsort	(*(char),*(char),array(int),int,int,*(char),int)->(void)
(	O
char	O
*	O
origset	*(char)
,	O
char	O
*	O
sortset	*(char)
,	O
int	O
sortvar	array(int)
[	O
]	O
,	O
int	O
nfields	int
,	O
int	O
unique	int
,	O
char	O
*	O
mod	*(char)
,	O
int	O
nmods	int
)	O
;	O
void	O
sort	(array(char),array(char),array(char))->(void)
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
varlist	array(char)
,	O
char	O
*	O
modifiers	array(char)
)	O
{	O
static	O
int	O
sortinit	int
=	O
0	int
;	O
int	O
unique	int
;	O
int	O
lastun	int
;	O
int	O
l	int
;	O
int	O
i	int
;	O
int	O
v	int
;	O
int	O
vn	int
;	O
char	O
*	O
dsrt0	*(char)
;	O
char	O
*	O
dsrt	*(char)
;	O
char	O
*	O
dfile	*(char)
;	O
static	O
char	O
*	O
*	O
line	array(char)
;	O
int	O
newline	int
;	O
int	O
nlines	int
;	O
char	O
*	O
c	int
;	O
int	O
flen	int
;	O
int	O
(	O
*	O
scmp	*(()->(int))
)	O
(	O
)	O
;	O
if	O
(	O
!	O
sortinit	int
)	O
{	O
sortinit	int
=	O
1	int
;	O
line	array(char)
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxlines	int
,	O
""	*(char)
)	O
;	O
startmem	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
2	int
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
start	array(*(int))
[	O
0	int
]	O
=	O
startmem	*(int)
;	O
start	array(*(int))
[	O
1	int
]	O
=	O
startmem	*(int)
+	O
dap_maxvar	int
;	O
mod	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
varv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
fname	array(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s:sort: no dataset name given\n"	*(char)
,	O
dap_dapname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
scmp	*(()->(int))
=	O
&	O
sortcmp	(*(*(char)),*(*(char)))->(int)
;	O
unique	int
=	O
0	int
;	O
if	O
(	O
modifiers	array(char)
)	O
{	O
for	O
(	O
l	int
=	O
0	int
;	O
modifiers	array(char)
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
for	O
(	O
nmods	int
=	O
0	int
,	O
unique	int
=	O
0	int
;	O
modifiers	array(char)
[	O
l	int
]	O
;	O
)	O
{	O
if	O
(	O
modifiers	array(char)
[	O
l	int
]	O
==	O
'u'	O
)	O
{	O
unique	int
=	O
1	int
;	O
l	int
++	O
;	O
}	O
else	O
if	O
(	O
modifiers	array(char)
[	O
l	int
]	O
==	O
'i'	O
||	O
modifiers	array(char)
[	O
l	int
]	O
==	O
'd'	O
)	O
{	O
while	O
(	O
modifiers	array(char)
[	O
l	int
]	O
==	O
'i'	O
||	O
modifiers	array(char)
[	O
l	int
]	O
==	O
'd'	O
)	O
mod	*(char)
[	O
nmods	int
++	O
]	O
=	O
modifiers	array(char)
[	O
l	int
++	O
]	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(sort) Bad modifier(s): %s\n"	*(char)
,	O
modifiers	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
while	O
(	O
modifiers	array(char)
[	O
l	int
]	O
==	O
' '	O
)	O
l	int
++	O
;	O
}	O
}	O
else	O
nmods	int
=	O
0	int
;	O
dsrt0	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
+	O
5	int
,	O
""	*(char)
)	O
;	O
dap_suffix	(array(char),array(char),array(char))->(void)
(	O
dsrt0	*(char)
,	O
fname	array(char)
,	O
".srt"	*(char)
)	O
;	O
inset	(array(char))->(void)
(	O
fname	array(char)
)	O
;	O
outset	(array(char),array(char))->(void)
(	O
dsrt0	*(char)
,	O
""	*(char)
)	O
;	O
nvar	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
varlist	array(char)
,	O
varv	array(int)
,	O
dap_maxvar	int
)	O
;	O
if	O
(	O
nmods	int
&&	O
(	O
nvar	int
!=	O
nmods	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(sort) Number of modifiers %d does not equal number of sort variables %d.\n"	*(char)
,	O
nmods	int
,	O
nvar	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
fname	array(char)
[	O
0	int
]	O
==	O
'<'	O
)	O
{	O
for	O
(	O
nlines	int
=	O
0	int
,	O
i	int
=	O
dap_ftell	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(long)
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
)	O
,	O
newline	int
=	O
1	int
;	O
i	int
<	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_end	*(char)
-	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_str	*(char)
;	O
i	int
++	O
)	O
{	O
if	O
(	O
newline	int
)	O
{	O
if	O
(	O
nlines	int
<	O
dap_maxlines	int
)	O
line	array(char)
[	O
nlines	int
++	O
]	O
=	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_str	*(char)
+	O
i	int
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(sort) Too many lines in ramfile %s\n"	*(char)
,	O
fname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
newline	int
=	O
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_str	*(char)
[	O
i	int
]	O
==	O
'\n'	O
)	O
;	O
}	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
line	array(char)
,	O
nlines	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
scmp	*(()->(int))
)	O
;	O
for	O
(	O
l	int
=	O
0	int
,	O
lastun	int
=	O
-	O
1	int
;	O
l	int
<	O
nlines	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
!	O
unique	int
||	O
lastun	int
<	O
0	int
||	O
linediff	(array(char),array(char))->(int)
(	O
line	array(char)
[	O
lastun	int
]	O
,	O
line	array(char)
[	O
l	int
]	O
)	O
)	O
{	O
for	O
(	O
c	int
=	O
line	array(char)
[	O
l	int
]	O
;	O
c	int
<	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_end	*(char)
&&	O
*	O
c	int
!=	O
'\n'	O
;	O
c	int
++	O
)	O
dap_putc	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
*	O
c	int
,	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
)	O
;	O
dap_putc	(int,*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(*`,*`,*`)))))->(void)
(	O
'\n'	O
,	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
)	O
;	O
lastun	int
=	O
l	int
;	O
}	O
else	O
{	O
for	O
(	O
c	int
=	O
line	array(char)
[	O
l	int
]	O
;	O
c	int
<	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_end	*(char)
&&	O
*	O
c	int
!=	O
'\n'	O
;	O
c	int
++	O
)	O
;	O
}	O
}	O
flen	int
=	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_end	*(char)
-	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_str	*(char)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_str	*(char)
,	O
dap_out	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_str	*(char)
,	O
flen	int
)	O
;	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_end	*(char)
=	O
dap_in	array(*(struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(char),*(char),*(char))))))
[	O
0	int
]	O
->	O
dfile_ram	*(struct(*(char),*(char),*(char)))
->	O
rfile_str	*(char)
+	O
flen	int
;	O
}	O
else	O
{	O
inset	(array(char))->(void)
(	O
NULL	O
)	O
;	O
dfile	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
dap_setdir	*(char)
)	O
+	O
2	int
,	O
""	*(char)
)	O
;	O
dap_name	(array(char),array(char))->(void)
(	O
dfile	*(char)
,	O
fname	array(char)
)	O
;	O
dsrt	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
dsrt0	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
dap_setdir	*(char)
)	O
+	O
2	int
,	O
""	*(char)
)	O
;	O
dap_name	(array(char),array(char))->(void)
(	O
dsrt	*(char)
,	O
dsrt0	*(char)
)	O
;	O
dsort	(*(char),*(char),array(int),int,int,*(char),int)->(void)
(	O
dfile	*(char)
,	O
dsrt	*(char)
,	O
varv	array(int)
,	O
nvar	int
,	O
unique	int
,	O
mod	*(char)
,	O
nmods	int
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
dsrt	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
dfile	*(char)
,	O
""	*(char)
)	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
dsrt0	*(char)
,	O
""	*(char)
)	O
;	O
}	O
static	O
void	O
printhead	(*(*(char)),int,*(char),*(int),int)->(void)
(	O
char	O
*	O
*	O
formstr	*(*(char))
,	O
int	O
space	int
,	O
char	O
*	O
fname	array(char)
,	O
int	O
*	O
varv	array(int)
,	O
int	O
nvar	int
)	O
{	O
int	O
v	int
;	O
int	O
d	int
;	O
char	O
*	O
ttext	*(char)
;	O
int	O
wastitle	int
;	O
ttext	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
+	O
11	int
,	O
""	*(char)
)	O
;	O
if	O
(	O
dap_title	*(char)
)	O
wastitle	int
=	O
1	int
;	O
else	O
{	O
wastitle	int
=	O
0	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
ttext	*(char)
,	O
"Printing: "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
ttext	*(char)
,	O
fname	array(char)
)	O
;	O
title	(*(char))->(void)
(	O
ttext	*(char)
)	O
;	O
}	O
dap_head	(array(int),int)->(void)
(	O
(	O
int	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
space	int
==	O
' '	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  Obs "	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
space	int
!=	O
' '	O
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
,	O
"_type_"	*(char)
)	O
)	O
continue	O
;	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
<=	O
0	int
)	O
{	O
if	O
(	O
space	int
==	O
' '	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%12s"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
}	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
formstr	*(*(char))
[	O
v	int
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
if	O
(	O
v	int
<	O
nvar	int
-	O
1	int
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
space	int
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
space	int
==	O
' '	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"----- "	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
for	O
(	O
d	int
=	O
0	int
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
[	O
d	int
]	O
;	O
d	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'-'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
<=	O
0	int
)	O
{	O
while	O
(	O
d	int
<	O
12	int
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'-'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
d	int
++	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
d	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'-'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
d	int
++	O
;	O
}	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
!	O
wastitle	int
)	O
title	(*(char))->(void)
(	O
NULL	O
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
ttext	*(char)
,	O
""	*(char)
)	O
;	O
}	O
void	O
print	(array(char),*(char))->(void)
(	O
char	O
fname	array(char)
[	O
]	O
,	O
char	O
*	O
varlist	array(char)
)	O
{	O
char	O
*	O
varlist1	*(char)
;	O
int	O
space	int
;	O
int	O
*	O
varv	array(int)
;	O
int	O
nvar	int
;	O
int	O
typen	int
;	O
char	O
*	O
formmem	*(char)
;	O
char	O
*	O
*	O
formstr	*(*(char))
;	O
int	O
v	int
;	O
int	O
lenstr	int
;	O
int	O
obn	int
;	O
varv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
inset	(array(char))->(void)
(	O
fname	array(char)
)	O
;	O
space	int
=	O
' '	O
;	O
if	O
(	O
varlist	array(char)
&&	O
varlist	array(char)
[	O
0	int
]	O
)	O
{	O
varlist1	*(char)
=	O
(	O
char	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
varlist	array(char)
)	O
+	O
1	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
varlist	array(char)
[	O
v	int
]	O
;	O
v	int
++	O
)	O
{	O
if	O
(	O
varlist	array(char)
[	O
v	int
]	O
==	O
'\t'	O
||	O
varlist	array(char)
[	O
v	int
]	O
==	O
','	O
)	O
{	O
varlist1	*(char)
[	O
v	int
]	O
=	O
' '	O
;	O
if	O
(	O
space	int
==	O
' '	O
)	O
space	int
=	O
varlist	array(char)
[	O
v	int
]	O
;	O
else	O
if	O
(	O
space	int
!=	O
varlist	array(char)
[	O
v	int
]	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(print) variable list contains more than one type of separator\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
varlist1	*(char)
[	O
v	int
]	O
=	O
varlist	array(char)
[	O
v	int
]	O
;	O
}	O
varlist1	*(char)
[	O
v	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
varv	array(int)
[	O
0	int
]	O
=	O
dap_varnum	(array(char))->(int)
(	O
"_type_"	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(print) Missing _type_ variable.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
typen	int
=	O
varv	array(int)
[	O
0	int
]	O
;	O
nvar	int
=	O
1	int
+	O
dap_list	(array(char),array(int),int)->(int)
(	O
varlist1	*(char)
,	O
varv	array(int)
+	O
1	int
,	O
dap_maxvar	int
-	O
1	int
)	O
;	O
if	O
(	O
nvar	int
==	O
1	int
)	O
{	O
nvar	int
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nvar	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
varv	array(int)
[	O
v	int
]	O
=	O
v	int
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
varlist1	*(char)
,	O
""	*(char)
)	O
;	O
}	O
else	O
{	O
nvar	int
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nvar	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
varv	array(int)
[	O
v	int
]	O
=	O
v	int
;	O
}	O
formmem	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
nvar	int
*	O
10	int
,	O
""	*(char)
)	O
;	O
formstr	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
formstr	*(*(char))
[	O
v	int
]	O
=	O
formmem	*(char)
+	O
10	int
*	O
v	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
{	O
lenstr	int
=	O
strlen	(*(char))->(long)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
if	O
(	O
lenstr	int
<	O
12	int
)	O
lenstr	int
=	O
12	int
;	O
if	O
(	O
space	int
!=	O
' '	O
)	O
lenstr	int
=	O
0	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
formstr	*(*(char))
[	O
v	int
]	O
,	O
"%%%dd"	*(char)
,	O
lenstr	int
)	O
;	O
}	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
{	O
lenstr	int
=	O
strlen	(*(char))->(long)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
if	O
(	O
lenstr	int
<	O
12	int
)	O
lenstr	int
=	O
12	int
;	O
if	O
(	O
space	int
!=	O
' '	O
)	O
lenstr	int
=	O
0	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
formstr	*(*(char))
[	O
v	int
]	O
,	O
"%%%dg"	*(char)
,	O
lenstr	int
)	O
;	O
}	O
else	O
{	O
lenstr	int
=	O
strlen	(*(char))->(long)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
if	O
(	O
lenstr	int
<	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
lenstr	int
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
;	O
if	O
(	O
space	int
!=	O
' '	O
)	O
lenstr	int
=	O
0	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
formstr	*(*(char))
[	O
v	int
]	O
,	O
"%%-%ds"	*(char)
,	O
lenstr	int
)	O
;	O
}	O
}	O
printhead	(*(*(char)),int,*(char),*(int),int)->(void)
(	O
formstr	*(*(char))
,	O
space	int
,	O
fname	array(char)
,	O
varv	array(int)
,	O
nvar	int
)	O
;	O
for	O
(	O
obn	int
=	O
1	int
;	O
step	()->(int)
(	O
)	O
;	O
)	O
{	O
if	O
(	O
space	int
==	O
' '	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%5d "	*(char)
,	O
obn	int
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
space	int
!=	O
' '	O
&&	O
varv	array(int)
[	O
v	int
]	O
==	O
typen	int
)	O
continue	O
;	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
formstr	*(*(char))
[	O
v	int
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_int	*(int)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
formstr	*(*(char))
[	O
v	int
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
formstr	*(*(char))
[	O
v	int
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
if	O
(	O
v	int
<	O
nvar	int
-	O
1	int
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
space	int
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
obn	int
++	O
;	O
}	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
varv	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
formmem	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
formstr	*(*(char))
,	O
""	*(char)
)	O
;	O
}	O
int	O
dap_mnsparse	(*(char),*(char),*(int),*(int),array(int))->(int)
(	O
char	O
*	O
varlist	array(char)
,	O
char	O
*	O
outlist	*(char)
,	O
int	O
*	O
varv	array(int)
,	O
int	O
*	O
wtvar	*(int)
,	O
int	O
stats	array(int)
[	O
]	O
)	O
{	O
int	O
v	int
;	O
int	O
i	int
;	O
int	O
j	int
;	O
int	O
k	int
;	O
char	O
*	O
vname	array(char)
;	O
char	O
*	O
tmplist	*(char)
;	O
int	O
vn	int
;	O
int	O
wn	int
;	O
int	O
nvar	int
;	O
int	O
s	int
;	O
int	O
nonly	int
;	O
if	O
(	O
!	O
varlist	array(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(meansparse) Missing variable list.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
vname	array(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_namelen	int
+	O
6	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
varlist	array(char)
[	O
v	int
]	O
;	O
v	int
++	O
)	O
;	O
for	O
(	O
--	O
v	int
;	O
v	int
>=	O
0	int
&&	O
varlist	array(char)
[	O
v	int
]	O
==	O
' '	O
;	O
--	O
v	int
)	O
;	O
nvar	int
=	O
0	int
;	O
tmplist	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_listlen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
tmplist	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
wn	int
=	O
-	O
1	int
;	O
for	O
(	O
nonly	int
=	O
0	int
;	O
v	int
>=	O
0	int
;	O
)	O
{	O
for	O
(	O
i	int
=	O
v	int
;	O
i	int
>=	O
0	int
&&	O
varlist	array(char)
[	O
i	int
]	O
!=	O
' '	O
&&	O
varlist	array(char)
[	O
i	int
]	O
!=	O
'*'	O
;	O
--	O
i	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
v	int
-	O
i	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
<	O
dap_namelen	int
)	O
vname	array(char)
[	O
j	int
]	O
=	O
varlist	array(char)
[	O
i	int
+	O
j	int
+	O
1	int
]	O
;	O
else	O
{	O
vname	array(char)
[	O
j	int
]	O
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(meansparse) Variable name too long: %s\n"	*(char)
,	O
vname	array(char)
)	O
;	O
}	O
}	O
vname	array(char)
[	O
j	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
i	int
>=	O
0	int
&&	O
varlist	array(char)
[	O
i	int
]	O
==	O
' '	O
)	O
--	O
i	int
;	O
if	O
(	O
(	O
vn	int
=	O
dap_varnum	(array(char))->(int)
(	O
vname	array(char)
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
vn	int
]	O
==	O
DBL	O
)	O
{	O
if	O
(	O
tmplist	*(char)
[	O
0	int
]	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
tmplist	*(char)
,	O
" "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
tmplist	*(char)
,	O
vname	array(char)
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(meansparse) Variable must be double: %s\n"	*(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
NSTATS	O
;	O
s	int
++	O
)	O
{	O
if	O
(	O
s	int
!=	O
N	int
&&	O
stats	array(int)
[	O
s	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(meansparse) Statistics other than N requested for unknown variable %s\n"	*(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
tmplist	*(char)
,	O
vname	array(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
vname	array(char)
,	O
" -1"	*(char)
)	O
;	O
vn	int
=	O
dap_vd	(array(char),int)->(int)
(	O
vname	array(char)
,	O
0	int
)	O
;	O
nonly	int
=	O
1	int
;	O
}	O
v	int
=	O
i	int
;	O
if	O
(	O
v	int
>=	O
0	int
&&	O
varlist	array(char)
[	O
v	int
]	O
==	O
'*'	O
)	O
{	O
wn	int
=	O
vn	int
;	O
for	O
(	O
--	O
v	int
;	O
v	int
>=	O
0	int
&&	O
varlist	array(char)
[	O
v	int
]	O
==	O
' '	O
;	O
--	O
v	int
)	O
;	O
}	O
else	O
{	O
wtvar	*(int)
[	O
nvar	int
]	O
=	O
wn	int
;	O
varv	array(int)
[	O
nvar	int
++	O
]	O
=	O
vn	int
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
tmplist	*(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
for	O
(	O
--	O
i	int
;	O
i	int
>=	O
0	int
&&	O
tmplist	*(char)
[	O
i	int
]	O
==	O
' '	O
;	O
--	O
i	int
)	O
;	O
for	O
(	O
outlist	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
i	int
>=	O
0	int
;	O
)	O
{	O
for	O
(	O
j	int
=	O
i	int
;	O
j	int
>	O
0	int
&&	O
tmplist	*(char)
[	O
j	int
-	O
1	int
]	O
!=	O
' '	O
;	O
--	O
j	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
i	int
-	O
j	int
;	O
k	int
++	O
)	O
vname	array(char)
[	O
k	int
]	O
=	O
tmplist	*(char)
[	O
j	int
+	O
k	int
]	O
;	O
vname	array(char)
[	O
k	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
outlist	*(char)
[	O
0	int
]	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
" "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
vname	array(char)
)	O
;	O
for	O
(	O
i	int
=	O
j	int
-	O
1	int
;	O
i	int
>=	O
0	int
&&	O
tmplist	*(char)
[	O
i	int
]	O
==	O
' '	O
;	O
--	O
i	int
)	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
vname	array(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
tmplist	*(char)
,	O
""	*(char)
)	O
;	O
if	O
(	O
nonly	int
)	O
return	O
-	O
nvar	int
;	O
return	O
nvar	int
;	O
}	O
char	O
dap_sttnm	array(array(char))
[	O
NSTATS	O
]	O
[	O
STATLEN	int
+	O
1	int
]	O
=	O
{	O
"N"	*(char)
,	O
"SUM"	*(char)
,	O
"SUMWT"	*(char)
,	O
"MEAN"	*(char)
,	O
"MIN"	*(char)
,	O
"MAX"	*(char)
,	O
"RANGE"	*(char)
,	O
"STEPXXXX"	*(char)
,	O
"VAR"	*(char)
,	O
"VARM"	*(char)
,	O
"SD"	*(char)
,	O
"SEM"	*(char)
,	O
"VARFREQ"	*(char)
,	O
"VARMFREQ"	*(char)
,	O
"SDFREQ"	*(char)
,	O
"SEMFREQ"	*(char)
,	O
"T"	*(char)
,	O
"TPROB"	*(char)
,	O
"QRANGE"	*(char)
,	O
"SIGN"	*(char)
,	O
"SPROB"	*(char)
,	O
"SRANK"	*(char)
,	O
"SRPROB"	*(char)
,	O
"NORMAL"	*(char)
,	O
"NPROB"	*(char)
,	O
"P1"	*(char)
,	O
"P5"	*(char)
,	O
"P10"	*(char)
,	O
"Q1"	*(char)
,	O
"MED"	*(char)
,	O
"Q3"	*(char)
,	O
"P90"	*(char)
,	O
"P95"	*(char)
,	O
"P99"	*(char)
,	O
"PXXXXX"	*(char)
,	O
"PXXXXX"	*(char)
,	O
"PXXXXX"	*(char)
}	O
;	O
void	O
dap_stats	(array(char),array(int))->(void)
(	O
char	O
*	O
statlist	array(char)
,	O
int	O
*	O
stats	array(int)
)	O
{	O
int	O
s	int
;	O
int	O
i	int
;	O
char	O
*	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
sn	int
;	O
double	O
pctpt	double
;	O
int	O
pctptn	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
NSTATS	O
;	O
s	int
++	O
)	O
stats	array(int)
[	O
s	int
]	O
=	O
0	int
;	O
if	O
(	O
!	O
statlist	array(char)
)	O
return	O
;	O
if	O
(	O
!	O
stats	array(int)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(dap_stats) Missing statistics index list.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
s	int
=	O
0	int
;	O
statlist	array(char)
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_namelen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
pctptn	int
=	O
0	int
;	O
statlist	array(char)
[	O
s	int
]	O
;	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
statlist	array(char)
[	O
s	int
+	O
i	int
]	O
&&	O
statlist	array(char)
[	O
s	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
[	O
i	int
]	O
=	O
statlist	array(char)
[	O
s	int
+	O
i	int
]	O
;	O
else	O
{	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_stats) Statistic name too long: %s\n"	*(char)
,	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
"STD"	*(char)
)	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
"SD"	*(char)
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
"STDERR"	*(char)
)	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
"SEM"	*(char)
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
"PRT"	*(char)
)	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
"TPROB"	*(char)
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
"MEDIAN"	*(char)
)	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
"MED"	*(char)
)	O
;	O
for	O
(	O
sn	int
=	O
0	int
;	O
sn	int
<	O
NSTATS	O
-	O
MAXPCTPT	int
+	O
pctptn	int
;	O
sn	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
dap_sttnm	array(array(char))
[	O
sn	int
]	O
)	O
)	O
{	O
stats	array(int)
[	O
sn	int
]	O
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
sn	int
==	O
NSTATS	O
-	O
MAXPCTPT	int
+	O
pctptn	int
)	O
{	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
"STEP"	*(char)
,	O
4	int
)	O
)	O
{	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
[	O
8	int
]	O
=	O
'\0'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_sttnm	array(array(char))
[	O
STEP	O
]	O
,	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
stats	array(int)
[	O
STEP	O
]	O
=	O
1	int
;	O
}	O
else	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
[	O
0	int
]	O
==	O
'P'	O
&&	O
sscanf	(*(char),*(char))->(int)
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
+	O
1	int
,	O
"%lf"	*(char)
,	O
&	O
pctpt	double
)	O
==	O
1	int
)	O
{	O
if	O
(	O
pctptn	int
++	O
<	O
MAXPCTPT	int
)	O
{	O
stats	array(int)
[	O
sn	int
]	O
=	O
1	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_sttnm	array(array(char))
[	O
sn	int
++	O
]	O
,	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_stats) Too many user-defined statistics: %s\n"	*(char)
,	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_stats) Invalid statistic name: %s\n"	*(char)
,	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
s	int
+=	O
i	int
;	O
while	O
(	O
statlist	array(char)
[	O
s	int
]	O
==	O
' '	O
)	O
s	int
++	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
""	*(char)
)	O
;	O
}	O
static	O
void	O
meansout	(array(int),int,array(int),array(double),array(double),array(double),array(double),array(double),array(int))->(void)
(	O
int	O
varv	array(int)
[	O
]	O
,	O
int	O
nvar	int
,	O
int	O
nobs	array(int)
[	O
]	O
,	O
double	O
sum	array(double)
[	O
]	O
,	O
double	O
sumwt	array(double)
[	O
]	O
,	O
double	O
min	array(double)
[	O
]	O
,	O
double	O
max	array(double)
[	O
]	O
,	O
double	O
ss	array(double)
[	O
]	O
,	O
int	O
stats	array(int)
[	O
]	O
)	O
{	O
double	O
*	O
dn	*(double)
;	O
int	O
typevar	int
;	O
int	O
v	int
;	O
int	O
nsteps	int
;	O
int	O
step	()->(int)
;	O
double	O
*	O
range	*(double)
;	O
double	O
fract	double
;	O
dap_swap	()->(void)
(	O
)	O
;	O
dn	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dn	*(double)
[	O
v	int
]	O
=	O
(	O
double	O
)	O
nobs	array(int)
[	O
v	int
]	O
;	O
if	O
(	O
(	O
typevar	int
=	O
dap_varnum	(array(char))->(int)
(	O
"_type_"	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(meansout) Missing _type_ variable\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
N	int
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"N"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array(int)
[	O
v	int
]	O
>=	O
1	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
dn	*(double)
[	O
v	int
]	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
SUM	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"SUM"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array(int)
[	O
v	int
]	O
>=	O
1	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
sum	array(double)
[	O
v	int
]	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
SUMWT	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"SUMWT"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array(int)
[	O
v	int
]	O
>=	O
1	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
sumwt	array(double)
[	O
v	int
]	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
MEAN	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"MEAN"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array(int)
[	O
v	int
]	O
>=	O
1	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
sum	array(double)
[	O
v	int
]	O
/	O
sumwt	array(double)
[	O
v	int
]	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
MIN	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"MIN"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array(int)
[	O
v	int
]	O
>=	O
1	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
min	array(double)
[	O
v	int
]	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
MAX	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"MAX"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array(int)
[	O
v	int
]	O
>=	O
1	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
max	array(double)
[	O
v	int
]	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
RANGE	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"RANGE"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array(int)
[	O
v	int
]	O
>=	O
1	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
max	array(double)
[	O
v	int
]	O
-	O
min	array(double)
[	O
v	int
]	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
VAR	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"VAR"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dn	*(double)
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
ss	array(double)
[	O
v	int
]	O
/	O
(	O
dn	*(double)
[	O
v	int
]	O
-	O
1.0	int
)	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
SD	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"SD"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dn	*(double)
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
sqrt	(double)->(double)
(	O
ss	array(double)
[	O
v	int
]	O
/	O
(	O
dn	*(double)
[	O
v	int
]	O
-	O
1.0	int
)	O
)	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
SEM	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"SEM"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dn	*(double)
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
sqrt	(double)->(double)
(	O
ss	array(double)
[	O
v	int
]	O
/	O
(	O
dn	*(double)
[	O
v	int
]	O
*	O
(	O
dn	*(double)
[	O
v	int
]	O
-	O
1.0	int
)	O
)	O
)	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
VARM	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"VARM"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dn	*(double)
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
ss	array(double)
[	O
v	int
]	O
/	O
(	O
dn	*(double)
[	O
v	int
]	O
*	O
(	O
dn	*(double)
[	O
v	int
]	O
-	O
1.0	int
)	O
)	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
VARFREQ	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"VARFREQ"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
sumwt	array(double)
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
ss	array(double)
[	O
v	int
]	O
/	O
(	O
sumwt	array(double)
[	O
v	int
]	O
-	O
1.0	int
)	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
SDFREQ	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"SDFREQ"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
sumwt	array(double)
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
sqrt	(double)->(double)
(	O
ss	array(double)
[	O
v	int
]	O
/	O
(	O
sumwt	array(double)
[	O
v	int
]	O
-	O
1.0	int
)	O
)	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
SEMFREQ	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"SEMFREQ"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
sumwt	array(double)
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
sqrt	(double)->(double)
(	O
ss	array(double)
[	O
v	int
]	O
/	O
(	O
sumwt	array(double)
[	O
v	int
]	O
*	O
(	O
sumwt	array(double)
[	O
v	int
]	O
-	O
1.0	int
)	O
)	O
)	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
VARMFREQ	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"SEMFREQ"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
sumwt	array(double)
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
ss	array(double)
[	O
v	int
]	O
/	O
(	O
sumwt	array(double)
[	O
v	int
]	O
*	O
(	O
sumwt	array(double)
[	O
v	int
]	O
-	O
1.0	int
)	O
)	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
STEP	O
]	O
)	O
{	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
dap_sttnm	array(array(char))
[	O
STEP	O
]	O
+	O
4	int
,	O
"%d"	*(char)
,	O
&	O
nsteps	int
)	O
==	O
1	int
)	O
{	O
range	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"STEP"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array(int)
[	O
v	int
]	O
>=	O
1	int
)	O
range	*(double)
[	O
v	int
]	O
=	O
max	array(double)
[	O
v	int
]	O
-	O
min	array(double)
[	O
v	int
]	O
;	O
else	O
range	*(double)
[	O
v	int
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
for	O
(	O
step	()->(int)
=	O
0	int
;	O
step	()->(int)
<=	O
nsteps	int
;	O
step	()->(int)
++	O
)	O
{	O
fract	double
=	O
(	O
(	O
double	O
)	O
step	()->(int)
)	O
/	O
(	O
(	O
double	O
)	O
nsteps	int
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
min	array(double)
[	O
v	int
]	O
+	O
range	*(double)
[	O
v	int
]	O
*	O
fract	double
;	O
output	()->(void)
(	O
)	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
range	*(double)
,	O
""	*(char)
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(meansout) Bad number of steps: %s\n"	*(char)
,	O
dap_sttnm	array(array(char))
[	O
STEP	O
]	O
+	O
4	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
stats	array(int)
[	O
T	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"T"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
sumwt	array(double)
[	O
v	int
]	O
>	O
0.0	int
&&	O
ss	array(double)
[	O
v	int
]	O
>	O
0.0	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
(	O
sum	array(double)
[	O
v	int
]	O
/	O
sumwt	array(double)
[	O
v	int
]	O
)	O
*	O
sqrt	(double)->(double)
(	O
sumwt	array(double)
[	O
v	int
]	O
*	O
(	O
dn	*(double)
[	O
v	int
]	O
-	O
1.0	int
)	O
/	O
ss	array(double)
[	O
v	int
]	O
)	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stats	array(int)
[	O
TPROB	O
]	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typevar	int
]	O
,	O
"TPROB"	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
sumwt	array(double)
[	O
v	int
]	O
>	O
0.0	int
&&	O
ss	array(double)
[	O
v	int
]	O
>	O
0.0	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
2.0	int
*	O
probt	(double,int)->(double)
(	O
fabs	(double)->(double)
(	O
(	O
sum	array(double)
[	O
v	int
]	O
/	O
sumwt	array(double)
[	O
v	int
]	O
)	O
*	O
sqrt	(double)->(double)
(	O
sumwt	array(double)
[	O
v	int
]	O
*	O
(	O
dn	*(double)
[	O
v	int
]	O
-	O
1.0	int
)	O
/	O
ss	array(double)
[	O
v	int
]	O
)	O
)	O
,	O
nobs	array(int)
[	O
v	int
]	O
-	O
1	int
)	O
;	O
else	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
dap_swap	()->(void)
(	O
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
dn	*(double)
,	O
""	*(char)
)	O
;	O
}	O
int	O
dap_list	(array(char),array(int),int)->(int)
(	O
char	O
*	O
varlist	array(char)
,	O
int	O
*	O
varv	array(int)
,	O
int	O
maxvars	int
)	O
{	O
int	O
nvars	int
;	O
int	O
m	int
;	O
int	O
i	int
;	O
char	O
*	O
mname	*(char)
;	O
if	O
(	O
!	O
varlist	array(char)
)	O
return	O
0	int
;	O
if	O
(	O
!	O
varv	array(int)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(dap_list) Missing variable index list.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
m	int
=	O
0	int
;	O
varlist	array(char)
[	O
m	int
]	O
==	O
' '	O
;	O
m	int
++	O
)	O
;	O
mname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_namelen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
nvars	int
=	O
0	int
;	O
varlist	array(char)
[	O
m	int
]	O
;	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
varlist	array(char)
[	O
m	int
+	O
i	int
]	O
&&	O
varlist	array(char)
[	O
m	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
mname	*(char)
[	O
i	int
]	O
=	O
varlist	array(char)
[	O
m	int
+	O
i	int
]	O
;	O
else	O
{	O
mname	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_list) variable name too long: %s\n"	*(char)
,	O
mname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
mname	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
nvars	int
>=	O
maxvars	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_list) More than %d variables: %s\n"	*(char)
,	O
maxvars	int
,	O
varlist	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
varv	array(int)
[	O
nvars	int
++	O
]	O
=	O
dap_varnum	(array(char))->(int)
(	O
mname	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dap_list) variable unknown: %s\n"	*(char)
,	O
mname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
m	int
+=	O
i	int
;	O
while	O
(	O
varlist	array(char)
[	O
m	int
]	O
==	O
' '	O
)	O
m	int
++	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
mname	*(char)
,	O
""	*(char)
)	O
;	O
return	O
nvars	int
;	O
}	O
int	O
dap_newpart	(array(int),int)->(int)
(	O
int	O
markv	array(int)
[	O
]	O
,	O
int	O
nmark	int
)	O
{	O
int	O
marked	int
;	O
int	O
m	int
;	O
marked	int
=	O
0	int
;	O
if	O
(	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_valid	int
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_valid	int
)	O
{	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
nmark	int
;	O
m	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
markv	array(int)
[	O
m	int
]	O
]	O
>	O
0	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
markv	array(int)
[	O
m	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
markv	array(int)
[	O
m	int
]	O
]	O
)	O
)	O
marked	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
markv	array(int)
[	O
m	int
]	O
]	O
==	O
INT	int
)	O
{	O
if	O
(	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_int	*(int)
[	O
markv	array(int)
[	O
m	int
]	O
]	O
!=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_int	*(int)
[	O
markv	array(int)
[	O
m	int
]	O
]	O
)	O
marked	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
dap_prev	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
markv	array(int)
[	O
m	int
]	O
]	O
!=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
markv	array(int)
[	O
m	int
]	O
]	O
)	O
marked	int
=	O
1	int
;	O
}	O
}	O
}	O
else	O
marked	int
=	O
1	int
;	O
}	O
return	O
marked	int
;	O
}	O
void	O
means	(array(char),array(char),array(char),array(char))->(void)
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
varlist	array(char)
,	O
char	O
*	O
statlist	array(char)
,	O
char	O
*	O
marks	array(char)
)	O
{	O
char	O
*	O
outname	*(char)
;	O
int	O
stats	array(int)
[	O
NSTATS	O
]	O
;	O
int	O
nonly	int
;	O
int	O
*	O
varv	array(int)
;	O
int	O
*	O
markv	array(int)
;	O
int	O
nvar	int
;	O
int	O
nmark	int
;	O
int	O
*	O
nobs	array(int)
;	O
char	O
*	O
outlist	*(char)
;	O
int	O
*	O
wtvar	*(int)
;	O
double	O
*	O
sum	array(double)
;	O
double	O
*	O
sumwt	array(double)
;	O
double	O
*	O
ss	array(double)
;	O
double	O
*	O
min	array(double)
;	O
double	O
*	O
max	array(double)
;	O
int	O
v	int
;	O
double	O
wt	double
;	O
double	O
vtmp	double
;	O
double	O
tmp	double
;	O
int	O
*	O
nnan	*(int)
;	O
int	O
more	int
;	O
if	O
(	O
!	O
fname	array(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(means) Missing input dataset name.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
outname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
+	O
5	int
,	O
""	*(char)
)	O
;	O
dap_suffix	(array(char),array(char),array(char))->(void)
(	O
outname	*(char)
,	O
fname	array(char)
,	O
".mns"	*(char)
)	O
;	O
varv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
markv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
wtvar	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
outlist	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_listlen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
inset	(array(char))->(void)
(	O
fname	array(char)
)	O
;	O
dap_stats	(array(char),array(int))->(void)
(	O
statlist	array(char)
,	O
stats	array(int)
)	O
;	O
nvar	int
=	O
dap_mnsparse	(*(char),*(char),*(int),*(int),array(int))->(int)
(	O
varlist	array(char)
,	O
outlist	*(char)
,	O
varv	array(int)
,	O
wtvar	*(int)
,	O
stats	array(int)
)	O
;	O
if	O
(	O
(	O
nonly	int
=	O
(	O
nvar	int
<	O
0	int
)	O
)	O
)	O
nvar	int
=	O
-	O
nvar	int
;	O
nobs	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
nnan	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
if	O
(	O
marks	array(char)
&&	O
marks	array(char)
[	O
0	int
]	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
" "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
marks	array(char)
)	O
;	O
}	O
outset	(array(char),array(char))->(void)
(	O
outname	*(char)
,	O
outlist	*(char)
)	O
;	O
nmark	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
marks	array(char)
,	O
markv	array(int)
,	O
dap_maxvar	int
)	O
;	O
sum	array(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
sumwt	array(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
ss	array(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
min	array(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
max	array(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
sum	array(double)
[	O
v	int
]	O
=	O
0.0	int
;	O
sumwt	array(double)
[	O
v	int
]	O
=	O
0.0	int
;	O
ss	array(double)
[	O
v	int
]	O
=	O
0.0	int
;	O
nobs	array(int)
[	O
v	int
]	O
=	O
0	int
;	O
nnan	*(int)
[	O
v	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
more	int
=	O
1	int
;	O
more	int
;	O
)	O
{	O
more	int
=	O
step	()->(int)
(	O
)	O
;	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
markv	array(int)
,	O
nmark	int
)	O
)	O
{	O
meansout	(array(int),int,array(int),array(double),array(double),array(double),array(double),array(double),array(int))->(void)
(	O
varv	array(int)
,	O
nvar	int
,	O
nobs	array(int)
,	O
sum	array(double)
,	O
sumwt	array(double)
,	O
min	array(double)
,	O
max	array(double)
,	O
ss	array(double)
,	O
stats	array(int)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nnan	*(int)
[	O
v	int
]	O
)	O
{	O
dap_swap	()->(void)
(	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(means) %d NaNs for %s\n"	*(char)
,	O
nnan	*(int)
[	O
v	int
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
dap_swap	()->(void)
(	O
)	O
;	O
}	O
sum	array(double)
[	O
v	int
]	O
=	O
0.0	int
;	O
sumwt	array(double)
[	O
v	int
]	O
=	O
0.0	int
;	O
ss	array(double)
[	O
v	int
]	O
=	O
0.0	int
;	O
nobs	array(int)
[	O
v	int
]	O
=	O
0	int
;	O
nnan	*(int)
[	O
v	int
]	O
=	O
0	int
;	O
}	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
vtmp	double
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
;	O
if	O
(	O
wtvar	*(int)
[	O
v	int
]	O
>=	O
0	int
)	O
wt	double
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
wtvar	*(int)
[	O
v	int
]	O
]	O
;	O
else	O
wt	double
=	O
1.0	int
;	O
if	O
(	O
finite	(double)->(int)
(	O
vtmp	double
)	O
&&	O
finite	(double)->(int)
(	O
wt	double
)	O
)	O
{	O
if	O
(	O
!	O
nobs	array(int)
[	O
v	int
]	O
)	O
{	O
min	array(double)
[	O
v	int
]	O
=	O
vtmp	double
;	O
max	array(double)
[	O
v	int
]	O
=	O
vtmp	double
;	O
}	O
else	O
{	O
if	O
(	O
vtmp	double
<	O
min	array(double)
[	O
v	int
]	O
)	O
min	array(double)
[	O
v	int
]	O
=	O
vtmp	double
;	O
if	O
(	O
vtmp	double
>	O
max	array(double)
[	O
v	int
]	O
)	O
max	array(double)
[	O
v	int
]	O
=	O
vtmp	double
;	O
tmp	double
=	O
sum	array(double)
[	O
v	int
]	O
-	O
sumwt	array(double)
[	O
v	int
]	O
*	O
vtmp	double
;	O
ss	array(double)
[	O
v	int
]	O
+=	O
tmp	double
*	O
tmp	double
*	O
wt	double
/	O
(	O
sumwt	array(double)
[	O
v	int
]	O
*	O
(	O
sumwt	array(double)
[	O
v	int
]	O
+	O
wt	double
)	O
)	O
;	O
}	O
sumwt	array(double)
[	O
v	int
]	O
+=	O
wt	double
;	O
sum	array(double)
[	O
v	int
]	O
+=	O
vtmp	double
*	O
wt	double
;	O
nobs	array(int)
[	O
v	int
]	O
++	O
;	O
}	O
else	O
if	O
(	O
nonly	int
)	O
nobs	array(int)
[	O
v	int
]	O
++	O
;	O
else	O
nnan	*(int)
[	O
v	int
]	O
++	O
;	O
}	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
outname	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
varv	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
markv	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
nobs	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
outlist	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
wtvar	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
sum	array(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
sumwt	array(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
ss	array(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
min	array(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
max	array(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
nnan	*(int)
,	O
""	*(char)
)	O
;	O
}	O
typedef	O
struct	O
{	O
char	O
*	O
lab	*(char)
;	O
int	O
labd	int
;	O
int	O
laba	int
;	O
int	O
labc	int
;	O
}	O
labnode	struct(*(char),int,int,int)
;	O
static	O
char	O
tabform	array(char)
[	O
7	int
]	O
;	O
static	O
char	O
emptyform	array(char)
[	O
5	int
]	O
;	O
static	O
int	O
cellwidth	int
;	O
static	O
double	O
*	O
tabvalmem	*(double)
;	O
static	O
double	O
*	O
*	O
tableval	*(*(double))
;	O
static	O
int	O
*	O
valsetmem	*(int)
;	O
static	O
int	O
*	O
*	O
valset	*(*(int))
;	O
static	O
int	O
nrows	int
,	O
ncols	int
;	O
static	O
labnode	struct(*(char),int,int,int)
*	O
collabel	*(struct(*(char),int,int,int))
;	O
static	O
int	O
labroot	int
;	O
static	O
int	O
nextclab	int
;	O
static	O
char	O
*	O
rlabmem	*(char)
;	O
static	O
char	O
*	O
*	O
rlptrmem	*(*(char))
;	O
static	O
char	O
*	O
*	O
*	O
rowlabel	*(*(*(char)))
;	O
static	O
int	O
rtitlesp	int
;	O
static	O
int	O
*	O
rowvar	*(int)
;	O
static	O
int	O
nrowvar	int
;	O
static	O
int	O
*	O
colvar	*(int)
;	O
static	O
int	O
ncolvar	int
;	O
static	O
int	O
colsort	int
;	O
static	O
int	O
newlab	(array(char))->(int)
(	O
char	O
lname	array(char)
[	O
]	O
)	O
{	O
if	O
(	O
nextclab	int
==	O
dap_maxclab	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(newlab) too many column labels: %s\n"	*(char)
,	O
lname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
collabel	*(struct(*(char),int,int,int))
[	O
nextclab	int
]	O
.	O
lab	*(char)
,	O
lname	array(char)
)	O
;	O
collabel	*(struct(*(char),int,int,int))
[	O
nextclab	int
]	O
.	O
labd	int
=	O
-	O
1	int
;	O
collabel	*(struct(*(char),int,int,int))
[	O
nextclab	int
]	O
.	O
laba	int
=	O
-	O
1	int
;	O
collabel	*(struct(*(char),int,int,int))
[	O
nextclab	int
]	O
.	O
labc	int
=	O
-	O
1	int
;	O
return	O
nextclab	int
++	O
;	O
}	O
static	O
int	O
nodecnt	(int)->(int)
(	O
int	O
clab	int
)	O
{	O
int	O
across	int
;	O
int	O
totalcnt	int
;	O
if	O
(	O
collabel	*(struct(*(char),int,int,int))
[	O
clab	int
]	O
.	O
labd	int
<	O
0	int
)	O
return	O
1	int
;	O
for	O
(	O
across	int
=	O
collabel	*(struct(*(char),int,int,int))
[	O
clab	int
]	O
.	O
labd	int
,	O
totalcnt	int
=	O
0	int
;	O
across	int
>=	O
0	int
;	O
across	int
=	O
collabel	*(struct(*(char),int,int,int))
[	O
across	int
]	O
.	O
laba	int
)	O
totalcnt	int
+=	O
nodecnt	(int)->(int)
(	O
across	int
)	O
;	O
return	O
totalcnt	int
;	O
}	O
static	O
void	O
labelprint	(array(char),int)->(void)
(	O
char	O
name	array(char)
[	O
]	O
,	O
int	O
width	int
)	O
{	O
static	O
char	O
*	O
label	*(char)
=	O
NULL	O
;	O
int	O
c	int
;	O
if	O
(	O
!	O
label	*(char)
)	O
label	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_strlen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
label	*(char)
,	O
name	array(char)
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
label	*(char)
[	O
c	int
]	O
&&	O
c	int
<	O
width	int
;	O
c	int
++	O
)	O
;	O
while	O
(	O
c	int
<	O
width	int
)	O
label	*(char)
[	O
c	int
++	O
]	O
=	O
' '	O
;	O
label	*(char)
[	O
c	int
]	O
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
label	*(char)
)	O
;	O
}	O
static	O
void	O
divider	(int,int,int,int,int)->(void)
(	O
int	O
left	int
,	O
int	O
conn	int
,	O
int	O
sep	int
,	O
int	O
right	int
,	O
int	O
nblank	int
)	O
{	O
int	O
col	int
;	O
int	O
c	int
;	O
int	O
connect	int
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
left	int
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
col	int
=	O
0	int
;	O
col	int
<	O
nrowvar	int
;	O
col	int
++	O
)	O
{	O
if	O
(	O
col	int
<	O
nblank	int
)	O
connect	int
=	O
' '	O
;	O
else	O
connect	int
=	O
conn	int
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
rtitlesp	int
;	O
c	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
connect	int
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
col	int
<	O
nrowvar	int
-	O
1	int
)	O
{	O
if	O
(	O
col	int
<	O
nblank	int
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
left	int
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
sep	int
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
right	int
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
for	O
(	O
col	int
=	O
0	int
;	O
col	int
<	O
ncols	int
;	O
col	int
++	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
cellwidth	int
;	O
c	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
conn	int
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
col	int
<	O
ncols	int
-	O
1	int
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
sep	int
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
right	int
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
tableline	(int,int)->(void)
(	O
int	O
start	array(*(int))
,	O
int	O
depth	int
)	O
{	O
int	O
across	int
;	O
int	O
cnt	int
;	O
int	O
c	int
;	O
for	O
(	O
across	int
=	O
start	array(*(int))
;	O
across	int
>=	O
0	int
;	O
across	int
=	O
collabel	*(struct(*(char),int,int,int))
[	O
across	int
]	O
.	O
laba	int
)	O
{	O
if	O
(	O
!	O
depth	int
)	O
{	O
labelprint	(array(char),int)->(void)
(	O
collabel	*(struct(*(char),int,int,int))
[	O
across	int
]	O
.	O
lab	*(char)
,	O
cellwidth	int
)	O
;	O
cnt	int
=	O
nodecnt	(int)->(int)
(	O
across	int
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
(	O
cnt	int
-	O
1	int
)	O
*	O
(	O
cellwidth	int
+	O
1	int
)	O
;	O
c	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'|'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
tableline	(int,int)->(void)
(	O
collabel	*(struct(*(char),int,int,int))
[	O
across	int
]	O
.	O
labd	int
,	O
depth	int
-	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
tablehead	()->(void)
(	O
)	O
{	O
int	O
row	int
,	O
col	int
;	O
int	O
c	int
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
col	int
=	O
0	int
;	O
col	int
<	O
nrowvar	int
;	O
col	int
++	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
rtitlesp	int
+	O
1	int
;	O
c	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
colvar	*(int)
[	O
ncolvar	int
-	O
1	int
]	O
]	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
colvar	*(int)
[	O
0	int
]	O
>=	O
0	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" for "	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
col	int
=	O
0	int
;	O
col	int
<	O
ncolvar	int
-	O
1	int
;	O
col	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
colvar	*(int)
[	O
col	int
]	O
]	O
)	O
;	O
if	O
(	O
col	int
<	O
ncolvar	int
-	O
2	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" / "	*(char)
)	O
;	O
}	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
divider	(int,int,int,int,int)->(void)
(	O
'='	O
,	O
'='	O
,	O
'='	O
,	O
'='	O
,	O
0	int
)	O
;	O
for	O
(	O
row	int
=	O
0	int
;	O
row	int
<	O
ncolvar	int
-	O
1	int
;	O
row	int
++	O
)	O
{	O
if	O
(	O
row	int
<	O
ncolvar	int
-	O
2	int
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'|'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
col	int
=	O
0	int
;	O
col	int
<	O
nrowvar	int
;	O
col	int
++	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
rtitlesp	int
;	O
c	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
col	int
<	O
nrowvar	int
-	O
1	int
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'|'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
else	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'|'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
col	int
=	O
0	int
;	O
col	int
<	O
nrowvar	int
;	O
col	int
++	O
)	O
{	O
labelprint	(array(char),int)->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
rowvar	*(int)
[	O
col	int
]	O
]	O
,	O
rtitlesp	int
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'|'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
tableline	(int,int)->(void)
(	O
labroot	int
,	O
row	int
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
row	int
<	O
ncolvar	int
-	O
2	int
)	O
divider	(int,int,int,int,int)->(void)
(	O
'|'	O
,	O
'-'	O
,	O
'+'	O
,	O
'|'	O
,	O
0	int
)	O
;	O
}	O
divider	(int,int,int,int,int)->(void)
(	O
'|'	O
,	O
'='	O
,	O
'|'	O
,	O
'|'	O
,	O
0	int
)	O
;	O
}	O
static	O
void	O
valprint	(int,int)->(void)
(	O
int	O
row	int
,	O
int	O
node	int
)	O
{	O
while	O
(	O
node	int
>=	O
0	int
)	O
{	O
if	O
(	O
collabel	*(struct(*(char),int,int,int))
[	O
node	int
]	O
.	O
labd	int
>=	O
0	int
)	O
valprint	(int,int)->(void)
(	O
row	int
,	O
collabel	*(struct(*(char),int,int,int))
[	O
node	int
]	O
.	O
labd	int
)	O
;	O
else	O
{	O
if	O
(	O
valset	*(*(int))
[	O
row	int
]	O
[	O
collabel	*(struct(*(char),int,int,int))
[	O
node	int
]	O
.	O
labc	int
]	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
tabform	array(char)
,	O
tableval	*(*(double))
[	O
row	int
]	O
[	O
collabel	*(struct(*(char),int,int,int))
[	O
node	int
]	O
.	O
labc	int
]	O
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
emptyform	array(char)
,	O
""	*(char)
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'|'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
node	int
=	O
collabel	*(struct(*(char),int,int,int))
[	O
node	int
]	O
.	O
laba	int
;	O
}	O
}	O
static	O
void	O
tableprint	()->(void)
(	O
)	O
{	O
int	O
row	int
,	O
col	int
;	O
int	O
isblank	int
;	O
int	O
nextblank	int
;	O
int	O
nblank	int
;	O
int	O
nextnblank	int
;	O
for	O
(	O
row	int
=	O
0	int
;	O
row	int
<=	O
nrows	int
;	O
row	int
++	O
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'|'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
nblank	int
=	O
0	int
;	O
nextnblank	int
=	O
0	int
;	O
for	O
(	O
col	int
=	O
0	int
,	O
isblank	int
=	O
1	int
,	O
nextblank	int
=	O
1	int
;	O
col	int
<	O
nrowvar	int
;	O
col	int
++	O
)	O
{	O
if	O
(	O
isblank	int
&&	O
rowlabel	*(*(*(char)))
[	O
row	int
]	O
[	O
col	int
]	O
[	O
0	int
]	O
)	O
{	O
nblank	int
=	O
col	int
;	O
isblank	int
=	O
0	int
;	O
}	O
if	O
(	O
nextblank	int
&&	O
row	int
<=	O
nrows	int
-	O
1	int
&&	O
rowlabel	*(*(*(char)))
[	O
row	int
+	O
1	int
]	O
[	O
col	int
]	O
[	O
0	int
]	O
)	O
{	O
nextnblank	int
=	O
col	int
;	O
nextblank	int
=	O
0	int
;	O
}	O
labelprint	(array(char),int)->(void)
(	O
rowlabel	*(*(*(char)))
[	O
row	int
]	O
[	O
col	int
]	O
,	O
rtitlesp	int
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'|'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
valprint	(int,int)->(void)
(	O
row	int
,	O
labroot	int
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
nextnblank	int
!=	O
nblank	int
)	O
nblank	int
=	O
nextnblank	int
;	O
if	O
(	O
row	int
<=	O
nrows	int
-	O
1	int
)	O
divider	(int,int,int,int,int)->(void)
(	O
'|'	O
,	O
'-'	O
,	O
'+'	O
,	O
'|'	O
,	O
nblank	int
)	O
;	O
else	O
divider	(int,int,int,int,int)->(void)
(	O
'-'	O
,	O
'-'	O
,	O
'-'	O
,	O
'-'	O
,	O
0	int
)	O
;	O
}	O
}	O
static	O
int	O
findcol	()->(int)
(	O
)	O
{	O
int	O
varn	int
;	O
int	O
node	int
,	O
prevnode	int
,	O
nextnode	int
;	O
int	O
upnode	int
;	O
int	O
cmp	int
;	O
char	O
*	O
label	*(char)
;	O
nextnode	int
=	O
-	O
1	int
;	O
if	O
(	O
colsort	int
&&	O
colvar	*(int)
[	O
0	int
]	O
>=	O
0	int
)	O
{	O
for	O
(	O
node	int
=	O
labroot	int
,	O
varn	int
=	O
0	int
,	O
upnode	int
=	O
-	O
1	int
;	O
varn	int
<	O
ncolvar	int
-	O
1	int
;	O
varn	int
++	O
)	O
{	O
if	O
(	O
node	int
>=	O
0	int
)	O
{	O
for	O
(	O
nextnode	int
=	O
collabel	*(struct(*(char),int,int,int))
[	O
node	int
]	O
.	O
laba	int
;	O
nextnode	int
>=	O
0	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
colvar	*(int)
[	O
varn	int
]	O
]	O
,	O
collabel	*(struct(*(char),int,int,int))
[	O
nextnode	int
]	O
.	O
lab	*(char)
)	O
>=	O
0	int
;	O
)	O
{	O
node	int
=	O
nextnode	int
;	O
nextnode	int
=	O
collabel	*(struct(*(char),int,int,int))
[	O
nextnode	int
]	O
.	O
laba	int
;	O
}	O
cmp	int
=	O
strcmp	(*(char),*(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
colvar	*(int)
[	O
varn	int
]	O
]	O
,	O
collabel	*(struct(*(char),int,int,int))
[	O
node	int
]	O
.	O
lab	*(char)
)	O
;	O
}	O
else	O
cmp	int
=	O
-	O
1	int
;	O
if	O
(	O
cmp	int
<	O
0	int
)	O
{	O
if	O
(	O
upnode	int
>=	O
0	int
)	O
{	O
nextnode	int
=	O
node	int
;	O
node	int
=	O
newlab	(array(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
colvar	*(int)
[	O
varn	int
]	O
]	O
)	O
;	O
collabel	*(struct(*(char),int,int,int))
[	O
upnode	int
]	O
.	O
labd	int
=	O
node	int
;	O
collabel	*(struct(*(char),int,int,int))
[	O
node	int
]	O
.	O
laba	int
=	O
nextnode	int
;	O
}	O
else	O
{	O
labroot	int
=	O
newlab	(array(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
colvar	*(int)
[	O
varn	int
]	O
]	O
)	O
;	O
collabel	*(struct(*(char),int,int,int))
[	O
labroot	int
]	O
.	O
laba	int
=	O
node	int
;	O
node	int
=	O
labroot	int
;	O
}	O
}	O
else	O
if	O
(	O
cmp	int
>	O
0	int
)	O
{	O
collabel	*(struct(*(char),int,int,int))
[	O
node	int
]	O
.	O
laba	int
=	O
newlab	(array(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
colvar	*(int)
[	O
varn	int
]	O
]	O
)	O
;	O
node	int
=	O
collabel	*(struct(*(char),int,int,int))
[	O
node	int
]	O
.	O
laba	int
;	O
collabel	*(struct(*(char),int,int,int))
[	O
node	int
]	O
.	O
laba	int
=	O
nextnode	int
;	O
}	O
upnode	int
=	O
node	int
;	O
node	int
=	O
collabel	*(struct(*(char),int,int,int))
[	O
node	int
]	O
.	O
labd	int
;	O
}	O
}	O
else	O
{	O
for	O
(	O
node	int
=	O
labroot	int
,	O
varn	int
=	O
0	int
,	O
upnode	int
=	O
-	O
1	int
;	O
varn	int
<	O
ncolvar	int
-	O
1	int
;	O
varn	int
++	O
)	O
{	O
if	O
(	O
colvar	*(int)
[	O
0	int
]	O
>=	O
0	int
)	O
label	*(char)
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
colvar	*(int)
[	O
varn	int
]	O
]	O
;	O
else	O
label	*(char)
=	O
""	*(char)
;	O
for	O
(	O
prevnode	int
=	O
-	O
1	int
;	O
node	int
>=	O
0	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
label	*(char)
,	O
collabel	*(struct(*(char),int,int,int))
[	O
node	int
]	O
.	O
lab	*(char)
)	O
;	O
)	O
{	O
prevnode	int
=	O
node	int
;	O
node	int
=	O
collabel	*(struct(*(char),int,int,int))
[	O
node	int
]	O
.	O
laba	int
;	O
}	O
if	O
(	O
node	int
<	O
0	int
)	O
{	O
node	int
=	O
newlab	(array(char))->(int)
(	O
label	*(char)
)	O
;	O
if	O
(	O
prevnode	int
>=	O
0	int
)	O
collabel	*(struct(*(char),int,int,int))
[	O
prevnode	int
]	O
.	O
laba	int
=	O
node	int
;	O
else	O
if	O
(	O
upnode	int
>=	O
0	int
)	O
collabel	*(struct(*(char),int,int,int))
[	O
upnode	int
]	O
.	O
labd	int
=	O
node	int
;	O
else	O
labroot	int
=	O
node	int
;	O
}	O
upnode	int
=	O
node	int
;	O
node	int
=	O
collabel	*(struct(*(char),int,int,int))
[	O
node	int
]	O
.	O
labd	int
;	O
}	O
}	O
if	O
(	O
collabel	*(struct(*(char),int,int,int))
[	O
upnode	int
]	O
.	O
labc	int
<	O
0	int
)	O
{	O
if	O
(	O
ncols	int
>=	O
dap_maxcols	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(findcol) too many columns in table\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
collabel	*(struct(*(char),int,int,int))
[	O
upnode	int
]	O
.	O
labc	int
=	O
ncols	int
++	O
;	O
}	O
return	O
collabel	*(struct(*(char),int,int,int))
[	O
upnode	int
]	O
.	O
labc	int
;	O
}	O
static	O
void	O
tableform	(array(char))->(void)
(	O
char	O
tform	array(char)
[	O
]	O
)	O
{	O
char	O
width	int
[	O
7	int
]	O
;	O
int	O
w	int
;	O
int	O
forg	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
width	int
,	O
tform	array(char)
)	O
;	O
for	O
(	O
w	int
=	O
0	int
;	O
width	int
[	O
w	int
]	O
&&	O
width	int
[	O
w	int
]	O
!=	O
'.'	O
;	O
w	int
++	O
)	O
;	O
if	O
(	O
width	int
[	O
w	int
]	O
==	O
'.'	O
)	O
forg	int
=	O
'f'	O
;	O
else	O
forg	int
=	O
'g'	O
;	O
width	int
[	O
w	int
]	O
=	O
'\0'	O
;	O
cellwidth	int
=	O
atoi	(*(char))->(int)
(	O
width	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
tabform	array(char)
,	O
"%"	*(char)
)	O
;	O
if	O
(	O
forg	int
==	O
'f'	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
tabform	array(char)
,	O
tform	array(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
tabform	array(char)
,	O
"f"	*(char)
)	O
;	O
}	O
else	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
tabform	array(char)
,	O
width	int
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
tabform	array(char)
,	O
"g"	*(char)
)	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
emptyform	array(char)
,	O
"%%%ds"	*(char)
,	O
cellwidth	int
)	O
;	O
}	O
static	O
void	O
specparse	(array(char),array(char),array(char))->(void)
(	O
char	O
rowvars	array(char)
[	O
]	O
,	O
char	O
colvars	array(char)
[	O
]	O
,	O
char	O
format	array(char)
[	O
]	O
)	O
{	O
int	O
t	int
;	O
int	O
i	int
;	O
int	O
sp	int
;	O
char	O
*	O
vname	array(char)
;	O
int	O
v	int
;	O
vname	array(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_namelen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
nrowvar	int
=	O
0	int
;	O
ncolvar	int
=	O
0	int
;	O
for	O
(	O
t	int
=	O
0	int
;	O
rowvars	array(char)
[	O
t	int
]	O
==	O
' '	O
;	O
t	int
++	O
)	O
;	O
while	O
(	O
rowvars	array(char)
[	O
t	int
]	O
)	O
{	O
while	O
(	O
rowvars	array(char)
[	O
t	int
]	O
==	O
' '	O
)	O
t	int
++	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
rowvars	array(char)
[	O
t	int
+	O
i	int
]	O
&&	O
rowvars	array(char)
[	O
t	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
vname	array(char)
[	O
i	int
]	O
=	O
rowvars	array(char)
[	O
t	int
+	O
i	int
]	O
;	O
else	O
{	O
vname	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(specparse) Row variable name too long: %s\n"	*(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
vname	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	(array(char))->(int)
(	O
vname	array(char)
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
nrowvar	int
<	O
dap_maxrowv	int
)	O
rowvar	*(int)
[	O
nrowvar	int
++	O
]	O
=	O
v	int
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(specparse) Too many row variables: %s\n"	*(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(specparse) Unknown row variable: %s\n"	*(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
t	int
+=	O
i	int
;	O
while	O
(	O
rowvars	array(char)
[	O
t	int
]	O
==	O
' '	O
)	O
t	int
++	O
;	O
}	O
for	O
(	O
t	int
=	O
0	int
;	O
colvars	array(char)
[	O
t	int
]	O
==	O
' '	O
;	O
t	int
++	O
)	O
;	O
while	O
(	O
colvars	array(char)
[	O
t	int
]	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
colvars	array(char)
[	O
t	int
+	O
i	int
]	O
&&	O
colvars	array(char)
[	O
t	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
vname	array(char)
[	O
i	int
]	O
=	O
colvars	array(char)
[	O
t	int
+	O
i	int
]	O
;	O
else	O
{	O
vname	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(specparse) Column variable name too long: %s\n"	*(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
vname	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	(array(char))->(int)
(	O
vname	array(char)
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
ncolvar	int
<	O
dap_maxcolv	int
)	O
colvar	*(int)
[	O
ncolvar	int
++	O
]	O
=	O
v	int
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(specparse) Too many column variables: %s\n"	*(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(specparse) Unknown column variable: %s\n"	*(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
t	int
+=	O
i	int
;	O
while	O
(	O
colvars	array(char)
[	O
t	int
]	O
==	O
' '	O
)	O
t	int
++	O
;	O
}	O
for	O
(	O
t	int
=	O
0	int
;	O
format	array(char)
[	O
t	int
]	O
==	O
' '	O
;	O
t	int
++	O
)	O
;	O
if	O
(	O
format	array(char)
[	O
t	int
]	O
==	O
's'	O
)	O
{	O
colsort	int
=	O
1	int
;	O
for	O
(	O
t	int
++	O
;	O
format	array(char)
[	O
t	int
]	O
==	O
' '	O
;	O
t	int
++	O
)	O
;	O
}	O
else	O
colsort	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
format	array(char)
[	O
t	int
+	O
i	int
]	O
&&	O
format	array(char)
[	O
t	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
vname	array(char)
[	O
i	int
]	O
=	O
format	array(char)
[	O
t	int
+	O
i	int
]	O
;	O
else	O
{	O
vname	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(specparse) Format too long %s\n"	*(char)
,	O
vname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
vname	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
tableform	(array(char))->(void)
(	O
vname	array(char)
)	O
;	O
for	O
(	O
t	int
+=	O
i	int
;	O
format	array(char)
[	O
t	int
]	O
==	O
' '	O
;	O
t	int
++	O
)	O
;	O
if	O
(	O
format	array(char)
[	O
t	int
]	O
)	O
{	O
for	O
(	O
sp	int
=	O
0	int
;	O
'0'	O
<=	O
format	array(char)
[	O
t	int
]	O
&&	O
format	array(char)
[	O
t	int
]	O
<=	O
'9'	O
;	O
t	int
++	O
)	O
sp	int
=	O
10	int
*	O
sp	int
+	O
format	array(char)
[	O
t	int
]	O
-	O
'0'	O
;	O
if	O
(	O
format	array(char)
[	O
t	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(specparse) Extra character(s) at end of format: %s\n"	*(char)
,	O
format	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
rtitlesp	int
=	O
(	O
sp	int
-	O
1	int
)	O
/	O
nrowvar	int
;	O
}	O
if	O
(	O
!	O
tabform	array(char)
[	O
0	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(specparse) No format\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
ncolvar	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(specparse) No column or analysis variable(s) specified.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
ncolvar	int
<	O
2	int
)	O
{	O
colvar	*(int)
[	O
1	int
]	O
=	O
colvar	*(int)
[	O
0	int
]	O
;	O
colvar	*(int)
[	O
0	int
]	O
=	O
-	O
1	int
;	O
ncolvar	int
=	O
2	int
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
vname	array(char)
,	O
""	*(char)
)	O
;	O
}	O
void	O
table	(array(char),array(char),array(char),array(char),array(char))->(void)
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
rowvars	array(char)
,	O
char	O
*	O
colvars	array(char)
,	O
char	O
*	O
format	array(char)
,	O
char	O
*	O
marks	array(char)
)	O
{	O
static	O
int	O
tabinit	int
=	O
0	int
;	O
static	O
char	O
*	O
prevmem	*(char)
;	O
static	O
char	O
*	O
*	O
prev	*(*(char))
;	O
int	O
r	double
;	O
int	O
s	int
;	O
int	O
c	int
;	O
int	O
v	int
;	O
static	O
int	O
*	O
markv	array(int)
;	O
int	O
nmark	int
;	O
int	O
more	int
;	O
static	O
char	O
*	O
nstring	*(char)
;	O
if	O
(	O
!	O
tabinit	int
)	O
{	O
tabinit	int
=	O
1	int
;	O
valsetmem	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxrows	int
*	O
dap_maxcols	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
""	*(char)
)	O
;	O
valset	*(*(int))
=	O
(	O
int	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxrows	int
*	O
sizeof	O
(	O
int	O
*	O
)	O
,	O
""	*(char)
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
dap_maxrows	int
;	O
r	double
++	O
)	O
valset	*(*(int))
[	O
r	double
]	O
=	O
valsetmem	*(int)
+	O
dap_maxcols	int
*	O
r	double
;	O
tabvalmem	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxrows	int
*	O
dap_maxcols	int
*	O
sizeof	O
(	O
double	O
)	O
,	O
""	*(char)
)	O
;	O
tableval	*(*(double))
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxrows	int
*	O
sizeof	O
(	O
double	O
*	O
)	O
,	O
""	*(char)
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
dap_maxrows	int
;	O
r	double
++	O
)	O
tableval	*(*(double))
[	O
r	double
]	O
=	O
tabvalmem	*(double)
+	O
dap_maxcols	int
*	O
r	double
;	O
collabel	*(struct(*(char),int,int,int))
=	O
(	O
labnode	struct(*(char),int,int,int)
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxclab	int
*	O
sizeof	O
(	O
labnode	struct(*(char),int,int,int)
)	O
,	O
""	*(char)
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
dap_maxclab	int
;	O
c	int
++	O
)	O
collabel	*(struct(*(char),int,int,int))
[	O
c	int
]	O
.	O
lab	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_lablen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
rowvar	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
colvar	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
rlabmem	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxrows	int
*	O
dap_maxrowv	int
*	O
(	O
dap_lablen	int
+	O
1	int
)	O
,	O
""	*(char)
)	O
;	O
rlptrmem	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxrows	int
*	O
dap_maxrowv	int
,	O
""	*(char)
)	O
;	O
rowlabel	*(*(*(char)))
=	O
(	O
char	O
*	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
char	O
*	O
*	O
)	O
*	O
dap_maxrows	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
dap_maxrows	int
;	O
r	double
++	O
)	O
{	O
rowlabel	*(*(*(char)))
[	O
r	double
]	O
=	O
rlptrmem	*(*(char))
+	O
r	double
*	O
dap_maxrowv	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_maxrowv	int
;	O
v	int
++	O
)	O
rowlabel	*(*(*(char)))
[	O
r	double
]	O
[	O
v	int
]	O
=	O
rlabmem	*(char)
+	O
r	double
*	O
(	O
dap_maxrowv	int
*	O
(	O
dap_lablen	int
+	O
1	int
)	O
)	O
+	O
v	int
*	O
(	O
dap_lablen	int
+	O
1	int
)	O
;	O
}	O
prevmem	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxrowv	int
*	O
(	O
dap_lablen	int
+	O
1	int
)	O
,	O
""	*(char)
)	O
;	O
prev	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxrowv	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_maxrowv	int
;	O
v	int
++	O
)	O
prev	*(*(char))
[	O
v	int
]	O
=	O
prevmem	*(char)
+	O
v	int
*	O
(	O
dap_lablen	int
+	O
1	int
)	O
;	O
markv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
nstring	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_strlen	int
+	O
1	int
,	O
"dap_strlen"	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
fname	array(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(table) no dataset name given\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
inset	(array(char))->(void)
(	O
fname	array(char)
)	O
;	O
tabform	array(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
rtitlesp	int
=	O
8	int
;	O
if	O
(	O
!	O
rowvars	array(char)
||	O
!	O
colvars	array(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(table) no row and/or column variables specified\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
format	array(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(table) no format given\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
specparse	(array(char),array(char),array(char))->(void)
(	O
rowvars	array(char)
,	O
colvars	array(char)
,	O
format	array(char)
)	O
;	O
nmark	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
marks	array(char)
,	O
markv	array(int)
,	O
dap_maxvar	int
)	O
;	O
nextclab	int
=	O
0	int
;	O
labroot	int
=	O
-	O
1	int
;	O
ncols	int
=	O
0	int
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nrowvar	int
;	O
r	double
++	O
)	O
{	O
prev	*(*(char))
[	O
r	double
]	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
rowvar	*(int)
[	O
r	double
]	O
]	O
<=	O
0	int
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
rowvar	*(int)
[	O
r	double
]	O
]	O
)	O
dap_free	(*(void),*(char))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
rowvar	*(int)
[	O
r	double
]	O
]	O
,	O
""	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
rowvar	*(int)
[	O
r	double
]	O
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
rtitlesp	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
}	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
ncolvar	int
-	O
1	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
colvar	*(int)
[	O
c	int
]	O
]	O
<=	O
0	int
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
colvar	*(int)
[	O
c	int
]	O
]	O
)	O
dap_free	(*(void),*(char))->(void)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
colvar	*(int)
[	O
c	int
]	O
]	O
,	O
""	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
colvar	*(int)
[	O
c	int
]	O
]	O
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
rtitlesp	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
}	O
}	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
dap_maxrows	int
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
dap_maxcols	int
;	O
c	int
++	O
)	O
valset	*(*(int))
[	O
r	double
]	O
[	O
c	int
]	O
=	O
0	int
;	O
for	O
(	O
nrows	int
=	O
-	O
1	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
)	O
{	O
more	int
=	O
step	()->(int)
(	O
)	O
;	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
markv	array(int)
,	O
nmark	int
)	O
)	O
{	O
dap_swap	()->(void)
(	O
)	O
;	O
dap_head	(array(int),int)->(void)
(	O
markv	array(int)
,	O
nmark	int
)	O
;	O
tablehead	()->(void)
(	O
)	O
;	O
tableprint	()->(void)
(	O
)	O
;	O
dap_swap	()->(void)
(	O
)	O
;	O
nextclab	int
=	O
0	int
;	O
labroot	int
=	O
-	O
1	int
;	O
ncols	int
=	O
0	int
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nrowvar	int
;	O
r	double
++	O
)	O
prev	*(*(char))
[	O
r	double
]	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
dap_maxrows	int
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
dap_maxcols	int
;	O
c	int
++	O
)	O
valset	*(*(int))
[	O
r	double
]	O
[	O
c	int
]	O
=	O
0	int
;	O
nrows	int
=	O
-	O
1	int
;	O
}	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nrowvar	int
;	O
r	double
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
rowvar	*(int)
[	O
r	double
]	O
]	O
==	O
INT	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
nstring	*(char)
,	O
"%d"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_int	*(int)
[	O
rowvar	*(int)
[	O
r	double
]	O
]	O
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
rowvar	*(int)
[	O
r	double
]	O
]	O
,	O
nstring	*(char)
,	O
rtitlesp	int
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
rowvar	*(int)
[	O
r	double
]	O
]	O
[	O
rtitlesp	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
rowvar	*(int)
[	O
r	double
]	O
]	O
==	O
DBL	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
nstring	*(char)
,	O
"%g"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
rowvar	*(int)
[	O
r	double
]	O
]	O
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
rowvar	*(int)
[	O
r	double
]	O
]	O
,	O
nstring	*(char)
,	O
rtitlesp	int
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
rowvar	*(int)
[	O
r	double
]	O
]	O
[	O
rtitlesp	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nrowvar	int
;	O
r	double
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
rowvar	*(int)
[	O
r	double
]	O
]	O
,	O
prev	*(*(char))
[	O
r	double
]	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
r	double
<	O
nrowvar	int
)	O
{	O
nrows	int
++	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
r	double
;	O
s	int
++	O
)	O
rowlabel	*(*(*(char)))
[	O
nrows	int
]	O
[	O
s	int
]	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
;	O
r	double
<	O
nrowvar	int
;	O
r	double
++	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
prev	*(*(char))
[	O
r	double
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
rowvar	*(int)
[	O
r	double
]	O
]	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rowlabel	*(*(*(char)))
[	O
nrows	int
]	O
[	O
r	double
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
rowvar	*(int)
[	O
r	double
]	O
]	O
)	O
;	O
}	O
}	O
if	O
(	O
nrows	int
<	O
0	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(table) No rows.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
ncolvar	int
-	O
1	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
colvar	*(int)
[	O
c	int
]	O
]	O
==	O
INT	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
nstring	*(char)
,	O
"%d"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_int	*(int)
[	O
colvar	*(int)
[	O
c	int
]	O
]	O
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
colvar	*(int)
[	O
c	int
]	O
]	O
,	O
nstring	*(char)
,	O
rtitlesp	int
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
colvar	*(int)
[	O
c	int
]	O
]	O
[	O
rtitlesp	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
colvar	*(int)
[	O
c	int
]	O
]	O
==	O
DBL	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
nstring	*(char)
,	O
"%g"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
colvar	*(int)
[	O
c	int
]	O
]	O
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
colvar	*(int)
[	O
c	int
]	O
]	O
,	O
nstring	*(char)
,	O
rtitlesp	int
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
colvar	*(int)
[	O
c	int
]	O
]	O
[	O
rtitlesp	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
c	int
=	O
findcol	()->(int)
(	O
)	O
;	O
tableval	*(*(double))
[	O
nrows	int
]	O
[	O
c	int
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
colvar	*(int)
[	O
ncolvar	int
-	O
1	int
]	O
]	O
;	O
valset	*(*(int))
[	O
nrows	int
]	O
[	O
c	int
]	O
=	O
1	int
;	O
}	O
}	O
void	O
split	(*(char),*(char),*(char))->(void)
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
varlist	array(char)
,	O
char	O
*	O
classvalvars	*(char)
)	O
{	O
char	O
*	O
skiplist	*(char)
;	O
char	O
*	O
outname	*(char)
;	O
char	O
*	O
classvar	*(char)
;	O
char	O
*	O
valuevar	*(char)
;	O
int	O
s	int
,	O
t	int
;	O
char	O
*	O
varname	*(char)
;	O
int	O
maxname	int
;	O
int	O
*	O
var	*(int)
;	O
int	O
nv	int
;	O
int	O
vv	int
;	O
int	O
vlen	int
;	O
int	O
prevlen	int
;	O
int	O
classv	int
,	O
valuev	int
;	O
classvar	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
varlist	array(char)
)	O
+	O
6	int
,	O
""	*(char)
)	O
;	O
valuevar	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
varlist	array(char)
)	O
+	O
6	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
classvalvars	*(char)
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
classvalvars	*(char)
[	O
s	int
]	O
&&	O
classvalvars	*(char)
[	O
s	int
]	O
!=	O
' '	O
;	O
)	O
classvar	*(char)
[	O
t	int
++	O
]	O
=	O
classvalvars	*(char)
[	O
s	int
++	O
]	O
;	O
classvar	*(char)
[	O
t	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
t	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(split) No classification variable specified.\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
while	O
(	O
classvalvars	*(char)
[	O
s	int
]	O
==	O
' '	O
)	O
s	int
++	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
classvalvars	*(char)
[	O
s	int
]	O
&&	O
classvalvars	*(char)
[	O
s	int
]	O
!=	O
' '	O
;	O
)	O
valuevar	*(char)
[	O
t	int
++	O
]	O
=	O
classvalvars	*(char)
[	O
s	int
++	O
]	O
;	O
valuevar	*(char)
[	O
t	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
t	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(split) No value variable specified: %s\n"	*(char)
,	O
classvalvars	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
var	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
(	O
(	O
strlen	(*(char))->(long)
(	O
varlist	array(char)
)	O
+	O
1	int
)	O
/	O
2	int
)	O
,	O
""	*(char)
)	O
;	O
varname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
varlist	array(char)
)	O
+	O
1	int
,	O
""	*(char)
)	O
;	O
skiplist	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
varlist	array(char)
)	O
+	O
2	int
,	O
""	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
skiplist	*(char)
,	O
"!"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
skiplist	*(char)
,	O
varlist	array(char)
)	O
;	O
outname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
+	O
5	int
,	O
""	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
outname	*(char)
,	O
fname	array(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
outname	*(char)
,	O
".spl"	*(char)
)	O
;	O
inset	(array(char))->(void)
(	O
fname	array(char)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
varlist	array(char)
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
for	O
(	O
nv	int
=	O
0	int
,	O
prevlen	int
=	O
DBL	O
-	O
1	int
,	O
maxname	int
=	O
0	int
;	O
varlist	array(char)
[	O
s	int
]	O
;	O
nv	int
++	O
)	O
{	O
for	O
(	O
t	int
=	O
0	int
;	O
varlist	array(char)
[	O
s	int
]	O
&&	O
varlist	array(char)
[	O
s	int
]	O
!=	O
' '	O
;	O
)	O
varname	*(char)
[	O
t	int
++	O
]	O
=	O
varlist	array(char)
[	O
s	int
++	O
]	O
;	O
varname	*(char)
[	O
t	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
t	int
>	O
maxname	int
)	O
maxname	int
=	O
t	int
;	O
if	O
(	O
(	O
var	*(int)
[	O
nv	int
]	O
=	O
dap_varnum	(array(char))->(int)
(	O
varname	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(split) Unknown variable: %s\n"	*(char)
,	O
varname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
vlen	int
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
var	*(int)
[	O
nv	int
]	O
]	O
;	O
if	O
(	O
prevlen	int
<	O
DBL	O
)	O
prevlen	int
=	O
vlen	int
;	O
else	O
if	O
(	O
prevlen	int
!=	O
vlen	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(split) Length of %s (%d) differs from that of previous variables (%d)\n"	*(char)
,	O
varname	*(char)
,	O
vlen	int
,	O
prevlen	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
while	O
(	O
varlist	array(char)
[	O
s	int
]	O
==	O
' '	O
)	O
s	int
++	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
classvar	*(char)
+	O
strlen	(*(char))->(long)
(	O
classvar	*(char)
)	O
,	O
" %d"	*(char)
,	O
maxname	int
)	O
;	O
classv	int
=	O
dap_vd	(array(char),int)->(int)
(	O
classvar	*(char)
,	O
0	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
valuevar	*(char)
+	O
strlen	(*(char))->(long)
(	O
valuevar	*(char)
)	O
,	O
" %d"	*(char)
,	O
vlen	int
)	O
;	O
valuev	int
=	O
dap_vd	(array(char),int)->(int)
(	O
valuevar	*(char)
,	O
0	int
)	O
;	O
outset	(array(char),array(char))->(void)
(	O
outname	*(char)
,	O
skiplist	*(char)
)	O
;	O
while	O
(	O
step	()->(int)
(	O
)	O
)	O
{	O
for	O
(	O
vv	int
=	O
0	int
;	O
vv	int
<	O
nv	int
;	O
vv	int
++	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
classv	int
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
var	*(int)
[	O
vv	int
]	O
]	O
)	O
;	O
if	O
(	O
vlen	int
==	O
DBL	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
valuev	int
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
var	*(int)
[	O
vv	int
]	O
]	O
;	O
else	O
if	O
(	O
vlen	int
==	O
INT	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
valuev	int
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
var	*(int)
[	O
vv	int
]	O
]	O
;	O
else	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
valuev	int
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
var	*(int)
[	O
vv	int
]	O
]	O
)	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
classvar	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
valuevar	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
var	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
skiplist	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
outname	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
varname	*(char)
,	O
""	*(char)
)	O
;	O
}	O
void	O
join	(*(char),*(char),*(char))->(void)
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
partvars	*(char)
,	O
char	O
*	O
valuevar	*(char)
)	O
{	O
char	O
*	O
partvars1	*(char)
;	O
int	O
npart	int
;	O
char	O
*	O
classvar	*(char)
;	O
int	O
s	int
,	O
t	int
;	O
char	O
*	O
outname	*(char)
;	O
char	O
*	O
skiplist	*(char)
;	O
int	O
cv	int
;	O
int	O
vv	int
;	O
int	O
nnew	int
;	O
int	O
nv	int
;	O
int	O
vlen	int
;	O
int	O
*	O
partv	array(int)
;	O
int	O
*	O
newv	*(int)
;	O
int	O
valv	int
;	O
int	O
vallen	int
;	O
char	O
*	O
varspec	array(char)
;	O
int	O
more	int
;	O
int	O
np	int
;	O
outname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
+	O
5	int
,	O
""	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
outname	*(char)
,	O
fname	array(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
outname	*(char)
,	O
".joi"	*(char)
)	O
;	O
newv	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
*	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	*(char)
)	O
;	O
partvars1	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
partvars	*(char)
)	O
+	O
1	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
partvars	*(char)
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
for	O
(	O
npart	int
=	O
0	int
;	O
partvars	*(char)
[	O
s	int
]	O
;	O
)	O
{	O
for	O
(	O
t	int
=	O
s	int
;	O
partvars	*(char)
[	O
t	int
]	O
&&	O
partvars	*(char)
[	O
t	int
]	O
!=	O
' '	O
;	O
t	int
++	O
)	O
;	O
while	O
(	O
partvars	*(char)
[	O
t	int
]	O
==	O
' '	O
)	O
t	int
++	O
;	O
if	O
(	O
partvars	*(char)
[	O
t	int
]	O
)	O
{	O
s	int
=	O
t	int
;	O
npart	int
++	O
;	O
}	O
else	O
break	O
;	O
}	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
partvars1	*(char)
,	O
partvars	*(char)
,	O
s	int
)	O
;	O
partvars1	*(char)
[	O
s	int
]	O
=	O
'\0'	O
;	O
classvar	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
partvars	*(char)
)	O
-	O
s	int
+	O
2	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
partvars	*(char)
[	O
s	int
]	O
&&	O
partvars	*(char)
[	O
s	int
]	O
!=	O
' '	O
;	O
)	O
classvar	*(char)
[	O
t	int
++	O
]	O
=	O
partvars	*(char)
[	O
s	int
++	O
]	O
;	O
classvar	*(char)
[	O
t	int
]	O
=	O
'\0'	O
;	O
skiplist	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
classvar	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
valuevar	*(char)
)	O
+	O
3	int
,	O
""	*(char)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
classvar	*(char)
,	O
"_type_"	*(char)
)	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
skiplist	*(char)
,	O
"!%s %s"	*(char)
,	O
classvar	*(char)
,	O
valuevar	*(char)
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
skiplist	*(char)
,	O
"!%s"	*(char)
,	O
valuevar	*(char)
)	O
;	O
inset	(array(char))->(void)
(	O
fname	array(char)
)	O
;	O
if	O
(	O
(	O
cv	int
=	O
dap_varnum	(array(char))->(int)
(	O
classvar	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(join) Unknown variable: %s\n"	*(char)
,	O
classvar	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
valv	int
=	O
dap_varnum	(array(char))->(int)
(	O
valuevar	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(join) Unknown variable: %s\n"	*(char)
,	O
valuevar	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
vallen	int
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
valv	int
]	O
;	O
vlen	int
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_len	*(int)
[	O
cv	int
]	O
;	O
varspec	array(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
vlen	int
+	O
5	int
,	O
""	*(char)
)	O
;	O
if	O
(	O
vlen	int
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(join) Variable %s not string variable (%d)\n"	*(char)
,	O
classvar	*(char)
,	O
vlen	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
dap_mark	()->(void)
(	O
)	O
;	O
partv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
*	O
)	O
*	O
npart	int
,	O
""	*(char)
)	O
;	O
dap_list	(array(char),array(int),int)->(int)
(	O
partvars1	*(char)
,	O
partv	array(int)
,	O
npart	int
)	O
;	O
for	O
(	O
nnew	int
=	O
0	int
;	O
step	()->(int)
(	O
)	O
;	O
nnew	int
++	O
)	O
{	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
partv	array(int)
,	O
npart	int
)	O
)	O
break	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
varspec	array(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
cv	int
]	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
varspec	array(char)
+	O
strlen	(*(char))->(long)
(	O
varspec	array(char)
)	O
,	O
" %d"	*(char)
,	O
vallen	int
)	O
;	O
newv	*(int)
[	O
nnew	int
]	O
=	O
dap_vd	(array(char),int)->(int)
(	O
varspec	array(char)
,	O
0	int
)	O
;	O
}	O
dap_rewind	()->(void)
(	O
)	O
;	O
outset	(array(char),array(char))->(void)
(	O
outname	*(char)
,	O
skiplist	*(char)
)	O
;	O
for	O
(	O
more	int
=	O
1	int
,	O
nv	int
=	O
0	int
;	O
more	int
;	O
nv	int
++	O
)	O
{	O
more	int
=	O
step	()->(int)
(	O
)	O
;	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
partv	array(int)
,	O
npart	int
)	O
)	O
{	O
if	O
(	O
nv	int
<	O
nnew	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(join) Too few lines in part:"	*(char)
)	O
;	O
for	O
(	O
np	int
=	O
0	int
;	O
np	int
<	O
npart	int
;	O
np	int
++	O
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
partv	array(int)
[	O
np	int
]	O
]	O
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
dap_swap	()->(void)
(	O
)	O
;	O
output	()->(void)
(	O
)	O
;	O
dap_swap	()->(void)
(	O
)	O
;	O
nv	int
=	O
0	int
;	O
}	O
if	O
(	O
more	int
)	O
{	O
if	O
(	O
nv	int
>=	O
nnew	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(join) Too many lines at %s\n"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
cv	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_nam	*(*(char))
[	O
newv	*(int)
[	O
nv	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
cv	int
]	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(join) Missing or extra lines at %s\n"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
cv	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
vallen	int
==	O
DBL	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
newv	*(int)
[	O
nv	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
valv	int
]	O
;	O
else	O
if	O
(	O
vallen	int
==	O
INT	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
newv	*(int)
[	O
nv	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
valv	int
]	O
;	O
else	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
newv	*(int)
[	O
nv	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
valv	int
]	O
)	O
;	O
}	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
outname	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
newv	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
partvars1	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
classvar	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
skiplist	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
varspec	array(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
partv	array(int)
,	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
*	O
fieldstart	*(int)
;	O
static	O
int	O
*	O
fieldlen	*(int)
;	O
static	O
int	O
*	O
unfield	*(int)
;	O
static	O
int	O
linelen	int
;	O
static	O
int	O
keylen	int
;	O
static	O
int	O
*	O
keyend	*(int)
;	O
static	O
int	O
*	O
sortord	*(int)
;	O
static	O
int	O
*	O
keymap	*(int)
;	O
static	O
int	O
nvars	int
;	O
static	O
char	O
*	O
mem1	*(char)
;	O
static	O
char	O
*	O
mem2	*(char)
;	O
static	O
int	O
maxlines	int
;	O
static	O
char	O
*	O
*	O
line	array(char)
;	O
static	O
int	O
*	O
field	*(int)
;	O
static	O
int	O
nfields	int
;	O
static	O
int	O
unique	int
;	O
static	O
char	O
tmplate	array(char)
[	O
]	O
=	O
TMPLATE	*(char)
;	O
static	O
unsigned	O
long	O
int	O
fpos	long
;	O
static	O
int	O
strtoi	(*(char),*(int),*(int))->(int)
(	O
char	O
*	O
s	int
,	O
int	O
*	O
pi	*(int)
,	O
int	O
*	O
ps	*(int)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
'0'	O
<=	O
*	O
s	int
&&	O
*	O
s	int
<=	O
'9'	O
;	O
s	int
++	O
)	O
i	int
=	O
10	int
*	O
i	int
+	O
*	O
s	int
-	O
'0'	O
;	O
*	O
pi	*(int)
=	O
i	int
;	O
if	O
(	O
*	O
s	int
==	O
'd'	O
)	O
{	O
*	O
ps	*(int)
=	O
0	int
;	O
s	int
++	O
;	O
}	O
else	O
*	O
ps	*(int)
=	O
1	int
;	O
return	O
!	O
*	O
s	int
;	O
}	O
static	O
void	O
cleanup	(int)->(void)
(	O
int	O
nseg	int
)	O
{	O
int	O
s	int
;	O
char	O
segname	array(char)
[	O
]	O
=	O
TMPLATE	*(char)
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
nseg	int
;	O
s	int
++	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
segname	array(char)
,	O
tmplate	array(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
segname	array(char)
+	O
18	int
,	O
"%06d"	*(char)
,	O
s	int
)	O
;	O
unlink	(*(char))->(int)
(	O
segname	array(char)
)	O
;	O
}	O
}	O
static	O
int	O
linecmp	(*(*(char)),*(*(char)))->(int)
(	O
char	O
*	O
*	O
s1	*(*(char))
,	O
char	O
*	O
*	O
s2	*(*(char))
)	O
{	O
char	O
*	O
t1	double
,	O
*	O
t2	*(char)
;	O
char	O
*	O
e1	*(*(char))
;	O
for	O
(	O
e1	*(*(char))
=	O
*	O
s1	*(*(char))
+	O
keylen	int
-	O
1	int
,	O
t1	double
=	O
*	O
s1	*(*(char))
,	O
t2	*(char)
=	O
*	O
s2	*(*(char))
;	O
t1	double
<	O
e1	*(*(char))
&&	O
*	O
t1	double
==	O
*	O
t2	*(char)
;	O
t1	double
++	O
,	O
t2	*(char)
++	O
)	O
;	O
return	O
(	O
keymap	*(int)
[	O
t1	double
-	O
*	O
s1	*(*(char))
]	O
?	O
*	O
t1	double
-	O
*	O
t2	*(char)
:	O
*	O
t2	*(char)
-	O
*	O
t1	double
)	O
;	O
}	O
static	O
int	O
sortseg	(int,int)->(int)
(	O
int	O
orig	int
,	O
int	O
s	int
)	O
{	O
char	O
segname	array(char)
[	O
]	O
=	O
TMPLATE	*(char)
;	O
ssize_t	long
nread	long
;	O
int	O
seg	int
;	O
char	O
*	O
m1	*(char)
,	O
*	O
m2	*(char)
;	O
int	O
nlines	int
;	O
char	O
*	O
lstart1	*(char)
,	O
*	O
lstart2	*(char)
;	O
int	O
f	*(()->(double))
;	O
int	O
last	int
;	O
int	O
l	int
;	O
char	O
*	O
lp	*(char)
;	O
char	O
*	O
mp	*(char)
;	O
int	O
newfield	int
;	O
int	O
(	O
*	O
cmp	int
)	O
(	O
)	O
;	O
cmp	int
=	O
&	O
linecmp	(*(*(char)),*(*(char)))->(int)
;	O
nread	long
=	O
read	(int,*(void),long)->(long)
(	O
orig	int
,	O
mem1	*(char)
,	O
dap_maxmem	int
)	O
;	O
if	O
(	O
!	O
nread	long
)	O
return	O
0	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
segname	array(char)
,	O
tmplate	array(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
segname	array(char)
+	O
18	int
,	O
"%06d"	*(char)
,	O
s	int
)	O
;	O
if	O
(	O
(	O
seg	int
=	O
open	(*(char),int)->(int)
(	O
segname	array(char)
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dsort) can't write %s\n"	*(char)
,	O
segname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
lstart1	*(char)
=	O
mem1	*(char)
,	O
lstart2	*(char)
=	O
mem2	*(char)
,	O
nlines	int
=	O
0	int
;	O
lstart1	*(char)
<	O
mem1	*(char)
+	O
nread	long
&&	O
lstart2	*(char)
+	O
linelen	int
<	O
mem2	*(char)
+	O
dap_maxmem	int
;	O
lstart1	*(char)
=	O
m1	*(char)
,	O
lstart2	*(char)
+=	O
linelen	int
)	O
{	O
if	O
(	O
nlines	int
<	O
maxlines	int
)	O
line	array(char)
[	O
nlines	int
++	O
]	O
=	O
lstart2	*(char)
;	O
else	O
break	O
;	O
for	O
(	O
f	*(()->(double))
=	O
0	int
,	O
m1	*(char)
=	O
lstart1	*(char)
,	O
last	int
=	O
'\0'	O
;	O
f	*(()->(double))
<	O
nvars	int
;	O
f	*(()->(double))
++	O
)	O
{	O
for	O
(	O
m2	*(char)
=	O
lstart2	*(char)
+	O
fieldstart	*(int)
[	O
unfield	*(int)
[	O
f	*(()->(double))
]	O
]	O
;	O
m1	*(char)
<	O
mem1	*(char)
+	O
nread	long
&&	O
*	O
m1	*(char)
!=	O
'|'	O
&&	O
*	O
m1	*(char)
!=	O
'\n'	O
;	O
)	O
*	O
m2	*(char)
++	O
=	O
*	O
m1	*(char)
++	O
;	O
last	int
=	O
*	O
m1	*(char)
++	O
;	O
while	O
(	O
m2	*(char)
<	O
lstart2	*(char)
+	O
fieldstart	*(int)
[	O
unfield	*(int)
[	O
f	*(()->(double))
]	O
+	O
1	int
]	O
)	O
*	O
m2	*(char)
++	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
last	int
!=	O
'\n'	O
)	O
break	O
;	O
}	O
if	O
(	O
last	int
!=	O
'\n'	O
)	O
--	O
nlines	int
;	O
nread	long
=	O
lstart1	*(char)
-	O
mem1	*(char)
;	O
if	O
(	O
!	O
nread	long
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(dsort) line longer than buffer\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
fpos	long
+=	O
nread	long
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
line	array(char)
,	O
nlines	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
cmp	int
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
nlines	int
;	O
l	int
++	O
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
mem1	*(char)
+	O
l	int
*	O
linelen	int
,	O
line	array(char)
[	O
l	int
]	O
,	O
linelen	int
)	O
;	O
write	(int,*(void),long)->(long)
(	O
seg	int
,	O
mem1	*(char)
,	O
nlines	int
*	O
linelen	int
)	O
;	O
close	(int)->(int)
(	O
seg	int
)	O
;	O
return	O
nread	long
;	O
}	O
static	O
char	O
*	O
*	O
nextline	*(*(char))
;	O
static	O
int	O
nextlinecmp	(*(int),*(int))->(int)
(	O
int	O
*	O
s1	*(*(char))
,	O
int	O
*	O
s2	*(*(char))
)	O
{	O
return	O
linecmp	(*(*(char)),*(*(char)))->(int)
(	O
nextline	*(*(char))
+	O
*	O
s1	*(*(char))
,	O
nextline	*(*(char))
+	O
*	O
s2	*(*(char))
)	O
;	O
}	O
static	O
void	O
merge	(int,int)->(void)
(	O
int	O
nseg	int
,	O
int	O
out	int
)	O
{	O
int	O
s	int
,	O
s1	*(*(char))
,	O
s2	*(*(char))
;	O
int	O
c	int
;	O
int	O
l	int
;	O
int	O
f	*(()->(double))
;	O
char	O
*	O
segnamemem	*(char)
;	O
char	O
*	O
*	O
segname	array(char)
;	O
int	O
segfile	int
;	O
int	O
chunksize	int
;	O
int	O
*	O
chunkread	*(int)
;	O
char	O
*	O
prevline	*(char)
;	O
unsigned	O
long	O
int	O
*	O
spos	*(long)
;	O
int	O
nmore	int
;	O
unsigned	O
int	O
outpos	int
;	O
int	O
*	O
segord	*(int)
;	O
int	O
(	O
*	O
scmp	*(()->(int))
)	O
(	O
)	O
;	O
scmp	*(()->(int))
=	O
&	O
nextlinecmp	(*(int),*(int))->(int)
;	O
nextline	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
nseg	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
"nextline"	*(char)
)	O
;	O
prevline	*(char)
=	O
NULL	O
;	O
segnamemem	*(char)
=	O
(	O
char	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
nseg	int
*	O
(	O
strlen	(*(char))->(long)
(	O
TMPLATE	*(char)
)	O
+	O
1	int
)	O
,	O
"segnamemem"	*(char)
)	O
;	O
segname	array(char)
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
nseg	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
"segname"	*(char)
)	O
;	O
spos	*(long)
=	O
(	O
unsigned	O
long	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
nseg	int
*	O
sizeof	O
(	O
unsigned	O
long	O
int	O
)	O
,	O
"spos"	*(char)
)	O
;	O
segord	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
nseg	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"segord"	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
chunksize	int
=	O
dap_maxmem	int
/	O
(	O
nseg	int
*	O
linelen	int
)	O
*	O
linelen	int
)	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(dsort) insufficient memory\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
chunkread	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
nseg	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"chunkread"	*(char)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
nseg	int
;	O
s	int
++	O
)	O
{	O
segname	array(char)
[	O
s	int
]	O
=	O
segnamemem	*(char)
+	O
s	int
*	O
(	O
strlen	(*(char))->(long)
(	O
TMPLATE	*(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
segname	array(char)
[	O
s	int
]	O
,	O
tmplate	array(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
segname	array(char)
[	O
s	int
]	O
+	O
18	int
,	O
"%06d"	*(char)
,	O
s	int
)	O
;	O
nextline	*(*(char))
[	O
s	int
]	O
=	O
mem1	*(char)
+	O
s	int
*	O
chunksize	int
;	O
spos	*(long)
[	O
s	int
]	O
=	O
0	int
;	O
chunkread	*(int)
[	O
s	int
]	O
=	O
0	int
;	O
segord	*(int)
[	O
s	int
]	O
=	O
s	int
;	O
}	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
nseg	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
(	O
segfile	int
=	O
open	(*(char),int)->(int)
(	O
segname	array(char)
[	O
s	int
]	O
,	O
O_RDONLY	int
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dsort) can't read %s\n"	*(char)
,	O
segname	array(char)
[	O
s	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
chunkread	*(int)
[	O
s	int
]	O
=	O
read	(int,*(void),long)->(long)
(	O
segfile	int
,	O
mem1	*(char)
+	O
s	int
*	O
chunksize	int
,	O
chunksize	int
)	O
)	O
>	O
0	int
)	O
spos	*(long)
[	O
s	int
]	O
+=	O
chunkread	*(int)
[	O
s	int
]	O
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dsort) bad initial read of %s\n"	*(char)
,	O
segname	array(char)
[	O
s	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
close	(int)->(int)
(	O
segfile	int
)	O
;	O
}	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
segord	*(int)
,	O
nseg	int
,	O
sizeof	O
(	O
int	O
)	O
,	O
scmp	*(()->(int))
)	O
;	O
for	O
(	O
nmore	int
=	O
nseg	int
,	O
outpos	int
=	O
0	int
;	O
nmore	int
;	O
)	O
{	O
if	O
(	O
unique	int
)	O
{	O
if	O
(	O
!	O
prevline	*(char)
)	O
prevline	*(char)
=	O
(	O
char	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
linelen	int
,	O
"prevline"	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
unique	int
||	O
(	O
prevline	*(char)
&&	O
linecmp	(*(*(char)),*(*(char)))->(int)
(	O
nextline	*(*(char))
+	O
segord	*(int)
[	O
0	int
]	O
,	O
&	O
prevline	*(char)
)	O
)	O
)	O
{	O
for	O
(	O
f	*(()->(double))
=	O
0	int
;	O
f	*(()->(double))
<	O
nvars	int
;	O
f	*(()->(double))
++	O
)	O
{	O
for	O
(	O
l	int
=	O
fieldstart	*(int)
[	O
unfield	*(int)
[	O
f	*(()->(double))
]	O
]	O
;	O
l	int
<	O
fieldstart	*(int)
[	O
unfield	*(int)
[	O
f	*(()->(double))
]	O
+	O
1	int
]	O
;	O
l	int
++	O
)	O
{	O
if	O
(	O
outpos	int
==	O
dap_maxmem	int
)	O
{	O
write	(int,*(void),long)->(long)
(	O
out	int
,	O
mem2	*(char)
,	O
outpos	int
)	O
;	O
outpos	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
(	O
mem2	*(char)
[	O
outpos	int
]	O
=	O
nextline	*(*(char))
[	O
segord	*(int)
[	O
0	int
]	O
]	O
[	O
l	int
]	O
)	O
)	O
break	O
;	O
outpos	int
++	O
;	O
}	O
if	O
(	O
outpos	int
==	O
dap_maxmem	int
)	O
{	O
write	(int,*(void),long)->(long)
(	O
out	int
,	O
mem2	*(char)
,	O
outpos	int
)	O
;	O
outpos	int
=	O
0	int
;	O
}	O
if	O
(	O
f	*(()->(double))
<	O
nvars	int
-	O
1	int
)	O
mem2	*(char)
[	O
outpos	int
++	O
]	O
=	O
'|'	O
;	O
else	O
mem2	*(char)
[	O
outpos	int
++	O
]	O
=	O
'\n'	O
;	O
}	O
}	O
if	O
(	O
unique	int
)	O
{	O
if	O
(	O
!	O
prevline	*(char)
)	O
prevline	*(char)
=	O
(	O
char	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
linelen	int
,	O
"prevline"	*(char)
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
prevline	*(char)
,	O
nextline	*(*(char))
[	O
segord	*(int)
[	O
0	int
]	O
]	O
,	O
linelen	int
)	O
;	O
}	O
if	O
(	O
(	O
nextline	*(*(char))
[	O
segord	*(int)
[	O
0	int
]	O
]	O
+=	O
linelen	int
)	O
>=	O
mem1	*(char)
+	O
segord	*(int)
[	O
0	int
]	O
*	O
chunksize	int
+	O
chunkread	*(int)
[	O
segord	*(int)
[	O
0	int
]	O
]	O
)	O
{	O
if	O
(	O
(	O
segfile	int
=	O
open	(*(char),int)->(int)
(	O
segname	array(char)
[	O
segord	*(int)
[	O
0	int
]	O
]	O
,	O
O_RDONLY	int
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dsort) can't read %s\n"	*(char)
,	O
segname	array(char)
[	O
segord	*(int)
[	O
0	int
]	O
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
lseek	(int,long,int)->(long)
(	O
segfile	int
,	O
spos	*(long)
[	O
segord	*(int)
[	O
0	int
]	O
]	O
,	O
SEEK_CUR	int
)	O
>	O
0	int
)	O
{	O
if	O
(	O
(	O
chunkread	*(int)
[	O
segord	*(int)
[	O
0	int
]	O
]	O
=	O
read	(int,*(void),long)->(long)
(	O
segfile	int
,	O
mem1	*(char)
+	O
segord	*(int)
[	O
0	int
]	O
*	O
chunksize	int
,	O
chunksize	int
)	O
)	O
>	O
0	int
)	O
{	O
spos	*(long)
[	O
segord	*(int)
[	O
0	int
]	O
]	O
+=	O
chunkread	*(int)
[	O
segord	*(int)
[	O
0	int
]	O
]	O
;	O
nextline	*(*(char))
[	O
segord	*(int)
[	O
0	int
]	O
]	O
=	O
mem1	*(char)
+	O
segord	*(int)
[	O
0	int
]	O
*	O
chunksize	int
;	O
}	O
else	O
--	O
nmore	int
;	O
}	O
else	O
{	O
chunkread	*(int)
[	O
segord	*(int)
[	O
0	int
]	O
]	O
=	O
0	int
;	O
--	O
nmore	int
;	O
}	O
close	(int)->(int)
(	O
segfile	int
)	O
;	O
}	O
if	O
(	O
chunkread	*(int)
[	O
segord	*(int)
[	O
0	int
]	O
]	O
<=	O
0	int
)	O
{	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
nmore	int
;	O
s	int
++	O
)	O
segord	*(int)
[	O
s	int
]	O
=	O
segord	*(int)
[	O
s	int
+	O
1	int
]	O
;	O
}	O
else	O
{	O
for	O
(	O
s1	*(*(char))
=	O
1	int
;	O
s1	*(*(char))
<	O
nmore	int
;	O
s1	*(*(char))
++	O
)	O
{	O
if	O
(	O
linecmp	(*(*(char)),*(*(char)))->(int)
(	O
nextline	*(*(char))
+	O
segord	*(int)
[	O
0	int
]	O
,	O
nextline	*(*(char))
+	O
segord	*(int)
[	O
s1	*(*(char))
]	O
)	O
<=	O
0	int
)	O
break	O
;	O
}	O
s2	*(*(char))
=	O
segord	*(int)
[	O
0	int
]	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
s1	*(*(char))
-	O
1	int
;	O
s	int
++	O
)	O
segord	*(int)
[	O
s	int
]	O
=	O
segord	*(int)
[	O
s	int
+	O
1	int
]	O
;	O
segord	*(int)
[	O
s	int
]	O
=	O
s2	*(*(char))
;	O
}	O
}	O
if	O
(	O
outpos	int
)	O
write	(int,*(void),long)->(long)
(	O
out	int
,	O
mem2	*(char)
,	O
outpos	int
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
nextline	*(*(char))
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
prevline	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
segnamemem	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
segname	array(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
spos	*(long)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
chunkread	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
segord	*(int)
,	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
fieldfix	(int)->(int)
(	O
int	O
code	array(char)
)	O
{	O
switch	O
(	O
code	array(char)
)	O
{	O
case	O
DBL	O
:	O
return	O
12	int
;	O
case	O
INT	int
:	O
return	O
6	int
;	O
default	O
:	O
return	O
code	array(char)
;	O
}	O
}	O
static	O
int	O
fixheader	(*(char),int)->(int)
(	O
char	O
*	O
header	*(char)
,	O
int	O
srt	int
)	O
{	O
int	O
headerlen	int
;	O
int	O
nspaces	int
;	O
int	O
v	int
;	O
int	O
gotsign	int
;	O
int	O
sign	int
;	O
int	O
h	int
;	O
char	O
*	O
h1	*(char)
;	O
int	O
newfield	int
;	O
int	O
fieldlen1	int
;	O
int	O
f	*(()->(double))
,	O
f1	array(char)
,	O
f2	double
;	O
int	O
k	int
,	O
k1	int
;	O
char	O
*	O
*	O
headerfield	*(*(char))
;	O
headerfield	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxvar	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
"headerfield"	*(char)
)	O
;	O
fieldstart	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
(	O
dap_maxvar	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
int	O
)	O
,	O
"fieldstart"	*(char)
)	O
;	O
fieldstart	*(int)
[	O
0	int
]	O
=	O
0	int
;	O
fieldlen	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
(	O
dap_maxvar	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
int	O
)	O
,	O
"fieldlen"	*(char)
)	O
;	O
for	O
(	O
headerlen	int
=	O
0	int
,	O
nspaces	int
=	O
0	int
,	O
nvars	int
=	O
0	int
,	O
newfield	int
=	O
1	int
,	O
linelen	int
=	O
0	int
;	O
headerlen	int
<	O
dap_linelen	int
&&	O
header	*(char)
[	O
headerlen	int
]	O
!=	O
'\n'	O
;	O
headerlen	int
++	O
)	O
{	O
if	O
(	O
newfield	int
)	O
{	O
if	O
(	O
nvars	int
)	O
linelen	int
+=	O
(	O
fieldlen	*(int)
[	O
nvars	int
-	O
1	int
]	O
=	O
fieldfix	(int)->(int)
(	O
sign	int
*	O
fieldlen1	int
)	O
)	O
;	O
headerfield	*(*(char))
[	O
nvars	int
++	O
]	O
=	O
header	*(char)
+	O
headerlen	int
;	O
newfield	int
=	O
0	int
;	O
}	O
if	O
(	O
header	*(char)
[	O
headerlen	int
]	O
==	O
' '	O
)	O
{	O
if	O
(	O
++	O
nspaces	int
==	O
1	int
)	O
{	O
fieldlen1	int
=	O
0	int
;	O
gotsign	int
=	O
0	int
;	O
}	O
else	O
{	O
nspaces	int
=	O
0	int
;	O
newfield	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
nspaces	int
==	O
1	int
&&	O
header	*(char)
[	O
headerlen	int
]	O
!=	O
' '	O
)	O
{	O
if	O
(	O
!	O
gotsign	int
)	O
{	O
if	O
(	O
header	*(char)
[	O
headerlen	int
]	O
==	O
'-'	O
)	O
sign	int
=	O
-	O
1	int
;	O
else	O
{	O
sign	int
=	O
1	int
;	O
gotsign	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
gotsign	int
)	O
fieldlen1	int
=	O
10	int
*	O
fieldlen1	int
+	O
header	*(char)
[	O
headerlen	int
]	O
-	O
'0'	O
;	O
gotsign	int
=	O
1	int
;	O
}	O
}	O
linelen	int
+=	O
(	O
fieldlen	*(int)
[	O
nvars	int
-	O
1	int
]	O
=	O
fieldfix	(int)->(int)
(	O
sign	int
*	O
fieldlen1	int
)	O
)	O
;	O
maxlines	int
=	O
dap_maxmem	int
/	O
linelen	int
;	O
line	array(char)
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
maxlines	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
"line"	*(char)
)	O
;	O
if	O
(	O
headerlen	int
==	O
dap_linelen	int
)	O
{	O
header	*(char)
[	O
dap_linelen	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dsort) header line too long %s\n"	*(char)
,	O
header	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
f	*(()->(double))
=	O
0	int
,	O
f2	double
=	O
nfields	int
;	O
f	*(()->(double))
<	O
nvars	int
;	O
f	*(()->(double))
++	O
)	O
{	O
for	O
(	O
f1	array(char)
=	O
0	int
;	O
f1	array(char)
<	O
nfields	int
;	O
f1	array(char)
++	O
)	O
{	O
if	O
(	O
field	*(int)
[	O
f1	array(char)
]	O
==	O
f	*(()->(double))
)	O
break	O
;	O
}	O
if	O
(	O
f1	array(char)
==	O
nfields	int
)	O
field	*(int)
[	O
f2	double
++	O
]	O
=	O
f	*(()->(double))
;	O
}	O
for	O
(	O
f	*(()->(double))
=	O
0	int
;	O
f	*(()->(double))
<	O
nvars	int
;	O
f	*(()->(double))
++	O
)	O
unfield	*(int)
[	O
field	*(int)
[	O
f	*(()->(double))
]	O
]	O
=	O
f	*(()->(double))
;	O
for	O
(	O
fieldstart	*(int)
[	O
0	int
]	O
=	O
0	int
,	O
f	*(()->(double))
=	O
1	int
;	O
f	*(()->(double))
<=	O
nvars	int
;	O
f	*(()->(double))
++	O
)	O
fieldstart	*(int)
[	O
f	*(()->(double))
]	O
=	O
fieldstart	*(int)
[	O
f	*(()->(double))
-	O
1	int
]	O
+	O
fieldlen	*(int)
[	O
field	*(int)
[	O
f	*(()->(double))
-	O
1	int
]	O
]	O
;	O
keyend	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
nfields	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"keyend"	*(char)
)	O
;	O
for	O
(	O
f	*(()->(double))
=	O
0	int
,	O
keylen	int
=	O
0	int
;	O
f	*(()->(double))
<	O
nfields	int
;	O
f	*(()->(double))
++	O
)	O
{	O
keylen	int
+=	O
fieldlen	*(int)
[	O
field	*(int)
[	O
f	*(()->(double))
]	O
]	O
;	O
keyend	*(int)
[	O
f	*(()->(double))
]	O
=	O
keylen	int
;	O
}	O
keymap	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
keylen	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"keymap"	*(char)
)	O
;	O
for	O
(	O
f	*(()->(double))
=	O
0	int
,	O
k	int
=	O
0	int
;	O
f	*(()->(double))
<	O
nfields	int
;	O
f	*(()->(double))
++	O
)	O
{	O
for	O
(	O
k1	int
=	O
0	int
;	O
k1	int
<	O
fieldlen	*(int)
[	O
field	*(int)
[	O
f	*(()->(double))
]	O
]	O
;	O
k1	int
++	O
)	O
keymap	*(int)
[	O
k	int
++	O
]	O
=	O
sortord	*(int)
[	O
f	*(()->(double))
]	O
;	O
}	O
write	(int,*(void),long)->(long)
(	O
srt	int
,	O
header	*(char)
,	O
headerlen	int
+	O
1	int
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
headerfield	*(*(char))
,	O
""	*(char)
)	O
;	O
return	O
headerlen	int
+	O
1	int
;	O
}	O
static	O
void	O
dsort	(*(char),*(char),array(int),int,int,*(char),int)->(void)
(	O
char	O
*	O
origset	*(char)
,	O
char	O
*	O
sortset	*(char)
,	O
int	O
sortvar	array(int)
[	O
]	O
,	O
int	O
nsort	int
,	O
int	O
uniq	int
,	O
char	O
*	O
mod	*(char)
,	O
int	O
nmods	int
)	O
{	O
int	O
f	*(()->(double))
;	O
int	O
orig	int
;	O
int	O
nseg	int
;	O
int	O
srt	int
;	O
char	O
*	O
header	*(char)
;	O
int	O
c	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
header	*(char)
=	O
(	O
char	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_linelen	int
,	O
"header"	*(char)
)	O
;	O
field	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxvar	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"field"	*(char)
)	O
;	O
unfield	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxvar	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"unfield"	*(char)
)	O
;	O
sortord	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
dap_maxvar	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"dsortord"	*(char)
)	O
;	O
nfields	int
=	O
nsort	int
;	O
if	O
(	O
!	O
nmods	int
)	O
{	O
for	O
(	O
f	*(()->(double))
=	O
0	int
;	O
f	*(()->(double))
<	O
nfields	int
;	O
f	*(()->(double))
++	O
)	O
mod	*(char)
[	O
f	*(()->(double))
]	O
=	O
'i'	O
;	O
}	O
else	O
if	O
(	O
nmods	int
!=	O
nfields	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dsort) nmods (%d) != nfields (%d)\n"	*(char)
,	O
nmods	int
,	O
nfields	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
unique	int
=	O
uniq	int
;	O
for	O
(	O
f	*(()->(double))
=	O
0	int
;	O
f	*(()->(double))
<	O
nfields	int
;	O
f	*(()->(double))
++	O
)	O
{	O
sortord	*(int)
[	O
f	*(()->(double))
]	O
=	O
(	O
mod	*(char)
[	O
f	*(()->(double))
]	O
==	O
'i'	O
?	O
1	int
:	O
0	int
)	O
;	O
field	*(int)
[	O
f	*(()->(double))
]	O
=	O
sortvar	array(int)
[	O
f	*(()->(double))
]	O
;	O
}	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
dap_tmpdir	*(char)
,	O
&	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
{	O
if	O
(	O
mkdir	(*(char),int)->(int)
(	O
dap_tmpdir	*(char)
,	O
(	O
mode_t	int
)	O
0700	int
)	O
<	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
dap_dapname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
(	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
S_IFDIR	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: non-directory file exists: %s\n"	*(char)
,	O
dap_dapname	*(char)
,	O
dap_tmpdir	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
mem1	*(char)
=	O
(	O
char	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
2	int
*	O
dap_maxmem	int
,	O
"mem1"	*(char)
)	O
;	O
mem2	*(char)
=	O
mem1	*(char)
+	O
dap_maxmem	int
;	O
if	O
(	O
!	O
nfields	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(dsort) no fields specified for sorting\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
orig	int
=	O
open	(*(char),int)->(int)
(	O
origset	*(char)
,	O
O_RDONLY	int
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dsort) can't read %s\n"	*(char)
,	O
origset	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
srt	int
=	O
open	(*(char),int)->(int)
(	O
sortset	*(char)
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(dsort) can't write %s\n"	*(char)
,	O
sortset	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
read	(int,*(void),long)->(long)
(	O
orig	int
,	O
header	*(char)
,	O
dap_linelen	int
)	O
<	O
0	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(dsort) can't read header\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
fpos	long
=	O
fixheader	(*(char),int)->(int)
(	O
header	*(char)
,	O
srt	int
)	O
;	O
lseek	(int,long,int)->(long)
(	O
orig	int
,	O
fpos	long
,	O
SEEK_SET	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
tmplate	array(char)
+	O
12	int
,	O
"%06d"	*(char)
,	O
getpid	()->(int)
(	O
)	O
%	O
1000000	int
)	O
;	O
for	O
(	O
nseg	int
=	O
0	int
;	O
sortseg	(int,int)->(int)
(	O
orig	int
,	O
nseg	int
)	O
;	O
nseg	int
++	O
)	O
lseek	(int,long,int)->(long)
(	O
orig	int
,	O
fpos	long
,	O
SEEK_SET	int
)	O
;	O
merge	(int,int)->(void)
(	O
nseg	int
,	O
srt	int
)	O
;	O
cleanup	(int)->(void)
(	O
nseg	int
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
header	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
mem1	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
fieldstart	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
line	array(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
field	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
unfield	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
fieldlen	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
sortord	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
keyend	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
keymap	*(int)
,	O
""	*(char)
)	O
;	O
}	O
int	O
*	O
bubblesort	(*(int),int,int)->(*(int))
(	O
int	O
*	O
list	*(int)
,	O
int	O
n	int
,	O
int	O
order	int
)	O
{	O
int	O
*	O
returndata	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
n	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"return"	*(char)
)	O
;	O
int	O
i	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
returndata	*(int)
[	O
i	int
]	O
=	O
list	*(int)
[	O
i	int
]	O
;	O
}	O
int	O
swappedcount	int
=	O
0	int
;	O
int	O
swapped	int
=	O
0	int
;	O
do	O
{	O
swapped	int
=	O
0	int
;	O
i	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
order	int
>	O
0	int
)	O
{	O
if	O
(	O
returndata	*(int)
[	O
i	int
-	O
1	int
]	O
>	O
returndata	*(int)
[	O
i	int
]	O
)	O
{	O
int	O
act	int
=	O
returndata	*(int)
[	O
i	int
]	O
;	O
returndata	*(int)
[	O
i	int
]	O
=	O
returndata	*(int)
[	O
i	int
-	O
1	int
]	O
;	O
returndata	*(int)
[	O
i	int
-	O
1	int
]	O
=	O
act	int
;	O
swapped	int
=	O
1	int
;	O
swappedcount	int
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
returndata	*(int)
[	O
i	int
-	O
1	int
]	O
<	O
returndata	*(int)
[	O
i	int
]	O
)	O
{	O
int	O
act	int
=	O
returndata	*(int)
[	O
i	int
]	O
;	O
returndata	*(int)
[	O
i	int
]	O
=	O
returndata	*(int)
[	O
i	int
-	O
1	int
]	O
;	O
returndata	*(int)
[	O
i	int
-	O
1	int
]	O
=	O
act	int
;	O
swapped	int
=	O
1	int
;	O
swappedcount	int
++	O
;	O
}	O
}	O
}	O
}	O
while	O
(	O
swapped	int
)	O
;	O
printf	(*(char))->(int)
(	O
"nb swapped =%d\n"	*(char)
,	O
swappedcount	int
)	O
;	O
return	O
returndata	*(int)
;	O
}	O
void	O
surveyselect	(*(char),*(char),*(char),int)->(void)
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
outname	*(char)
,	O
char	O
*	O
method	*(char)
,	O
int	O
tirage	int
)	O
{	O
inset	(array(char))->(void)
(	O
fname	array(char)
)	O
;	O
int	O
nbLines	int
=	O
0	int
;	O
while	O
(	O
step	()->(int)
(	O
)	O
)	O
{	O
nbLines	int
++	O
;	O
}	O
printf	(*(char))->(int)
(	O
"nblines to read = %d, nb selected = %d\n"	*(char)
,	O
nbLines	int
,	O
tirage	int
)	O
;	O
int	O
*	O
list	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
tirage	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"list"	*(char)
)	O
;	O
int	O
i	int
=	O
0	int
;	O
int	O
sysrand	int
=	O
rand	()->(int)
(	O
)	O
%	O
(	O
nbLines	int
/	O
tirage	int
)	O
;	O
printf	(*(char))->(int)
(	O
"reload data\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"create index list based on method\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
tirage	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
method	*(char)
,	O
"SRS"	*(char)
)	O
==	O
0	int
)	O
{	O
int	O
notalone	int
=	O
0	int
;	O
int	O
choice	int
=	O
0	int
;	O
do	O
{	O
choice	int
=	O
rand	()->(int)
(	O
)	O
%	O
nbLines	int
;	O
int	O
j	int
=	O
0	int
;	O
notalone	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
i	int
;	O
j	int
++	O
)	O
if	O
(	O
list	*(int)
[	O
j	int
]	O
==	O
choice	int
)	O
notalone	int
=	O
1	int
;	O
}	O
while	O
(	O
notalone	int
==	O
1	int
)	O
;	O
list	*(int)
[	O
i	int
]	O
=	O
choice	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
method	*(char)
,	O
"SYS"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
i	int
==	O
0	int
)	O
{	O
list	*(int)
[	O
i	int
]	O
=	O
sysrand	int
;	O
}	O
else	O
{	O
list	*(int)
[	O
i	int
]	O
=	O
list	*(int)
[	O
i	int
-	O
1	int
]	O
+	O
nbLines	int
/	O
tirage	int
;	O
}	O
}	O
}	O
printf	(*(char))->(int)
(	O
"sort values\n"	*(char)
)	O
;	O
int	O
*	O
listsorted	*(int)
=	O
bubblesort	(*(int),int,int)->(*(int))
(	O
list	*(int)
,	O
tirage	int
,	O
1	int
)	O
;	O
int	O
counter	int
=	O
0	int
;	O
int	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
printf	(*(char))->(int)
(	O
"set output\n"	*(char)
)	O
;	O
inset	(array(char))->(void)
(	O
fname	array(char)
)	O
;	O
outset	(array(char),array(char))->(void)
(	O
outname	*(char)
,	O
""	*(char)
)	O
;	O
while	O
(	O
step	()->(int)
(	O
)	O
)	O
{	O
int	O
founded	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
tirage	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
listsorted	*(int)
[	O
i	int
]	O
==	O
counter	int
)	O
founded	int
=	O
1	int
;	O
}	O
if	O
(	O
founded	int
)	O
{	O
output	()->(void)
(	O
)	O
;	O
index	(*(char),int)->(*(char))
++	O
;	O
}	O
counter	int
++	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
list	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
listsorted	*(int)
,	O
""	*(char)
)	O
;	O
}	O
