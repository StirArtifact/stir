struct	O
entry	struct(*(char),long,bool,long)
{	O
char	O
*	O
string	*(char)
;	O
size_t	long
length	*(long)
;	O
bool	bool
hashcode_cached	bool
;	O
size_t	long
hashcode	long
;	O
}	O
;	O
static	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
entry_create	(*(char),long)->(*(struct(*(char),long,bool,long)))
(	O
char	O
*	O
string	*(char)
,	O
size_t	long
length	*(long)
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
result	*(struct)
=	O
XMALLOC	O
(	O
struct	O
entry	struct(*(char),long,bool,long)
)	O
;	O
result	*(struct)
->	O
string	*(char)
=	O
string	*(char)
;	O
result	*(struct)
->	O
length	*(long)
=	O
length	*(long)
;	O
result	*(struct)
->	O
hashcode_cached	bool
=	O
false	int
;	O
return	O
result	*(struct)
;	O
}	O
static	O
bool	bool
entry_equals	(*(void),*(void))->(bool)
(	O
const	O
void	O
*	O
elt1	*(void)
,	O
const	O
void	O
*	O
elt2	*(void)
)	O
{	O
const	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
entry1	*(struct(*(char),long,bool,long))
=	O
(	O
const	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
elt1	*(void)
;	O
const	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
entry2	*(struct(*(char),long,bool,long))
=	O
(	O
const	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
elt2	*(void)
;	O
return	O
entry1	*(struct(*(char),long,bool,long))
->	O
length	*(long)
==	O
entry2	*(struct(*(char),long,bool,long))
->	O
length	*(long)
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
entry1	*(struct(*(char),long,bool,long))
->	O
string	*(char)
,	O
entry2	*(struct(*(char),long,bool,long))
->	O
string	*(char)
,	O
entry1	*(struct(*(char),long,bool,long))
->	O
length	*(long)
)	O
==	O
0	int
;	O
}	O
static	O
size_t	long
entry_hashcode	(*(void))->(long)
(	O
const	O
void	O
*	O
elt	*(void)
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
entry	struct(*(char),long,bool,long)
=	O
(	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
elt	*(void)
;	O
if	O
(	O
!	O
entry	struct(*(char),long,bool,long)
->	O
hashcode_cached	bool
)	O
{	O
const	O
char	O
*	O
s	long
;	O
size_t	long
n	long
;	O
size_t	long
h	long
=	O
0	int
;	O
for	O
(	O
s	long
=	O
entry	struct(*(char),long,bool,long)
->	O
string	*(char)
,	O
n	long
=	O
entry	struct(*(char),long,bool,long)
->	O
length	*(long)
;	O
n	long
>	O
0	int
;	O
s	long
++	O
,	O
n	long
--	O
)	O
h	long
=	O
(	O
unsigned	O
char	O
)	O
*	O
s	long
+	O
(	O
(	O
h	long
<<	O
9	int
)	O
|	O
(	O
h	long
>>	O
(	O
sizeof	O
(	O
size_t	long
)	O
*	O
CHAR_BIT	O
-	O
9	int
)	O
)	O
)	O
;	O
entry	struct(*(char),long,bool,long)
->	O
hashcode	long
=	O
h	long
;	O
entry	struct(*(char),long,bool,long)
->	O
hashcode_cached	bool
=	O
true	int
;	O
}	O
return	O
entry	struct(*(char),long,bool,long)
->	O
hashcode	long
;	O
}	O
static	O
double	O
entry_fstrcmp	(*(struct(*(char),long,bool,long)),*(struct(*(char),long,bool,long)),double)->(double)
(	O
const	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
entry1	*(struct(*(char),long,bool,long))
,	O
const	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
entry2	*(struct(*(char),long,bool,long))
,	O
double	O
lower_bound	double
)	O
{	O
char	O
*	O
memory	*(char)
;	O
double	O
similarity	double
;	O
if	O
(	O
memchr	(*(void),int,long)->(*(void))
(	O
entry1	*(struct(*(char),long,bool,long))
->	O
string	*(char)
,	O
'\0'	O
,	O
entry1	*(struct(*(char),long,bool,long))
->	O
length	*(long)
)	O
!=	O
NULL	O
)	O
return	O
0.0	int
;	O
if	O
(	O
memchr	(*(void),int,long)->(*(void))
(	O
entry2	*(struct(*(char),long,bool,long))
->	O
string	*(char)
,	O
'\0'	O
,	O
entry2	*(struct(*(char),long,bool,long))
->	O
length	*(long)
)	O
!=	O
NULL	O
)	O
return	O
0.0	int
;	O
memory	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloca	O
(	O
entry1	*(struct(*(char),long,bool,long))
->	O
length	*(long)
+	O
1	int
+	O
entry2	*(struct(*(char),long,bool,long))
->	O
length	*(long)
+	O
1	int
)	O
;	O
{	O
char	O
*	O
p	*(void)
=	O
memory	*(char)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
,	O
entry1	*(struct(*(char),long,bool,long))
->	O
string	*(char)
,	O
entry1	*(struct(*(char),long,bool,long))
->	O
length	*(long)
)	O
;	O
p	*(void)
+=	O
entry1	*(struct(*(char),long,bool,long))
->	O
length	*(long)
;	O
*	O
p	*(void)
++	O
=	O
'\0'	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
,	O
entry2	*(struct(*(char),long,bool,long))
->	O
string	*(char)
,	O
entry2	*(struct(*(char),long,bool,long))
->	O
length	*(long)
)	O
;	O
p	*(void)
+=	O
entry2	*(struct(*(char),long,bool,long))
->	O
length	*(long)
;	O
*	O
p	*(void)
++	O
=	O
'\0'	O
;	O
}	O
similarity	double
=	O
fstrcmp_bounded	(*(char),*(char),double)->(double)
(	O
memory	*(char)
,	O
memory	*(char)
+	O
entry1	*(struct(*(char),long,bool,long))
->	O
length	*(long)
+	O
1	int
,	O
lower_bound	double
)	O
;	O
freea	(*(void))->(void)
(	O
memory	*(char)
)	O
;	O
return	O
similarity	double
;	O
}	O
struct	O
changelog_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
{	O
gl_list_t	*(struct)
entries_list	*(struct)
;	O
gl_list_t	*(struct)
entries_reversed	*(struct)
;	O
size_t	long
num_entries	long
;	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
*	O
entries	*(*(struct(*(char),long,bool,long)))
;	O
}	O
;	O
static	O
void	O
read_changelog_file	(*(char),*(struct(*(struct),*(struct),long,*(*(struct`)))))->(void)
(	O
const	O
char	O
*	O
filename	*(char)
,	O
struct	O
changelog_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
*	O
result	*(struct)
)	O
{	O
size_t	long
length	*(long)
;	O
char	O
*	O
contents	*(*(void))
=	O
read_file	(*(char),*(long))->(*(char))
(	O
filename	*(char)
,	O
&	O
length	*(long)
)	O
;	O
if	O
(	O
contents	*(*(void))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"could not read file '%s'\n"	*(char)
,	O
filename	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
result	*(struct)
->	O
entries_list	*(struct)
=	O
gl_list_create_empty	(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*((*(void),*(void))->(bool)),*((*(void))->(long)),*((*(void))->(void)),bool)->(*(struct))
(	O
GL_LINKEDHASH_LIST	O
,	O
entry_equals	(*(void),*(void))->(bool)
,	O
entry_hashcode	(*(void))->(long)
,	O
NULL	O
,	O
true	int
)	O
;	O
result	*(struct)
->	O
entries_reversed	*(struct)
=	O
gl_list_create_empty	(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*((*(void),*(void))->(bool)),*((*(void))->(long)),*((*(void))->(void)),bool)->(*(struct))
(	O
GL_RBTREEHASH_LIST	O
,	O
entry_equals	(*(void),*(void))->(bool)
,	O
entry_hashcode	(*(void))->(long)
,	O
NULL	O
,	O
true	int
)	O
;	O
{	O
char	O
*	O
contents_end	*(char)
=	O
contents	*(*(void))
+	O
length	*(long)
;	O
char	O
*	O
start	*(char)
=	O
contents	*(*(void))
;	O
while	O
(	O
start	*(char)
<	O
contents_end	*(char)
)	O
{	O
char	O
*	O
ptr	*(char)
=	O
start	*(char)
;	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
curr	*(struct(*(char),long,bool,long))
;	O
while	O
(	O
ptr	*(char)
<	O
contents_end	*(char)
)	O
{	O
ptr	*(char)
=	O
memchr	(*(void),int,long)->(*(void))
(	O
ptr	*(char)
,	O
'\n'	O
,	O
contents_end	*(char)
-	O
ptr	*(char)
)	O
;	O
if	O
(	O
ptr	*(char)
==	O
NULL	O
)	O
{	O
ptr	*(char)
=	O
contents_end	*(char)
;	O
break	O
;	O
}	O
ptr	*(char)
++	O
;	O
if	O
(	O
contents_end	*(char)
-	O
ptr	*(char)
>=	O
2	int
&&	O
ptr	*(char)
[	O
0	int
]	O
==	O
'\n'	O
&&	O
!	O
(	O
ptr	*(char)
[	O
1	int
]	O
==	O
'\n'	O
||	O
ptr	*(char)
[	O
1	int
]	O
==	O
'\t'	O
||	O
ptr	*(char)
[	O
1	int
]	O
==	O
' '	O
)	O
)	O
{	O
ptr	*(char)
++	O
;	O
break	O
;	O
}	O
}	O
curr	*(struct(*(char),long,bool,long))
=	O
entry_create	(*(char),long)->(*(struct(*(char),long,bool,long)))
(	O
start	*(char)
,	O
ptr	*(char)
-	O
start	*(char)
)	O
;	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
result	*(struct)
->	O
entries_list	*(struct)
,	O
curr	*(struct(*(char),long,bool,long))
)	O
;	O
gl_list_add_first	(*(struct),*(void))->(*(struct))
(	O
result	*(struct)
->	O
entries_reversed	*(struct)
,	O
curr	*(struct(*(char),long,bool,long))
)	O
;	O
start	*(char)
=	O
ptr	*(char)
;	O
}	O
}	O
result	*(struct)
->	O
num_entries	long
=	O
gl_list_size	(*(struct))->(long)
(	O
result	*(struct)
->	O
entries_list	*(struct)
)	O
;	O
result	*(struct)
->	O
entries	*(*(struct(*(char),long,bool,long)))
=	O
XNMALLOC	O
(	O
result	*(struct)
->	O
num_entries	long
,	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
;	O
{	O
size_t	long
index	(*(char),int)->(*(char))
=	O
0	int
;	O
gl_list_iterator_t	struct(*(struct),*(struct),long,*(void),*(void),long,long)
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
=	O
gl_list_iterator	(*(struct))->(struct(*(struct),*(struct),long,*(void),*(void),long,long))
(	O
result	*(struct)
->	O
entries_list	*(struct)
)	O
;	O
const	O
void	O
*	O
elt	*(void)
;	O
gl_list_node_t	*(struct)
node	*(struct)
;	O
while	O
(	O
gl_list_iterator_next	(*(struct(*(struct),*(struct),long,*(void),*(void),long,long)),*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
,	O
&	O
elt	*(void)
,	O
&	O
node	*(struct)
)	O
)	O
result	*(struct)
->	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
index	(*(char),int)->(*(char))
++	O
]	O
=	O
(	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
elt	*(void)
;	O
gl_list_iterator_free	(*(struct(*(struct),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
ASSERT	O
(	O
index	(*(char),int)->(*(char))
==	O
result	*(struct)
->	O
num_entries	long
)	O
;	O
}	O
}	O
struct	O
entries_mapping	struct(*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long))))),*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long))))),*(long),*(long))
{	O
struct	O
changelog_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
*	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
;	O
struct	O
changelog_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
*	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
;	O
ssize_t	long
*	O
index_mapping	*(long)
;	O
ssize_t	long
*	O
index_mapping_reverse	*(long)
;	O
}	O
;	O
static	O
ssize_t	long
entries_mapping_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
(	O
struct	O
entries_mapping	struct(*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long))))),*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long))))),*(long),*(long))
*	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
,	O
ssize_t	long
i	long
)	O
{	O
if	O
(	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping	*(long)
[	O
i	long
]	O
<	O
-	O
1	int
)	O
{	O
struct	O
changelog_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
*	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
=	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
;	O
struct	O
changelog_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
*	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
=	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
;	O
size_t	long
n1	long
=	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
num_entries	long
;	O
size_t	long
n2	long
=	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
num_entries	long
;	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
entry_i	*(struct(*(char),long,bool,long))
=	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
;	O
ssize_t	long
j	long
;	O
ssize_t	long
best_j	long
=	O
-	O
1	int
;	O
double	O
best_j_similarity	double
=	O
0.0	int
;	O
for	O
(	O
j	long
=	O
n2	long
-	O
1	int
;	O
j	long
>=	O
0	int
;	O
j	long
--	O
)	O
if	O
(	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
<	O
0	int
)	O
{	O
double	O
similarity	double
=	O
entry_fstrcmp	(*(struct(*(char),long,bool,long)),*(struct(*(char),long,bool,long)),double)->(double)
(	O
entry_i	*(struct(*(char),long,bool,long))
,	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
]	O
,	O
best_j_similarity	double
)	O
;	O
if	O
(	O
similarity	double
>	O
best_j_similarity	double
)	O
{	O
best_j	long
=	O
j	long
;	O
best_j_similarity	double
=	O
similarity	double
;	O
}	O
}	O
if	O
(	O
best_j_similarity	double
>=	O
FSTRCMP_THRESHOLD	int
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
entry_j	*(struct(*(char),long,bool,long))
=	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
best_j	long
]	O
;	O
ssize_t	long
best_i	long
=	O
-	O
1	int
;	O
double	O
best_i_similarity	double
=	O
0.0	int
;	O
ssize_t	long
ii	long
;	O
for	O
(	O
ii	long
=	O
n1	long
-	O
1	int
;	O
ii	long
>=	O
0	int
;	O
ii	long
--	O
)	O
if	O
(	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping	*(long)
[	O
ii	long
]	O
<	O
0	int
)	O
{	O
double	O
similarity	double
=	O
entry_fstrcmp	(*(struct(*(char),long,bool,long)),*(struct(*(char),long,bool,long)),double)->(double)
(	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
ii	long
]	O
,	O
entry_j	*(struct(*(char),long,bool,long))
,	O
best_i_similarity	double
)	O
;	O
if	O
(	O
similarity	double
>	O
best_i_similarity	double
)	O
{	O
best_i	long
=	O
ii	long
;	O
best_i_similarity	double
=	O
similarity	double
;	O
}	O
}	O
if	O
(	O
best_i_similarity	double
>=	O
FSTRCMP_THRESHOLD	int
&&	O
best_i	long
==	O
i	long
)	O
{	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping	*(long)
[	O
i	long
]	O
=	O
best_j	long
;	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping_reverse	*(long)
[	O
best_j	long
]	O
=	O
i	long
;	O
}	O
}	O
if	O
(	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping	*(long)
[	O
i	long
]	O
<	O
-	O
1	int
)	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping	*(long)
[	O
i	long
]	O
=	O
-	O
1	int
;	O
}	O
return	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping	*(long)
[	O
i	long
]	O
;	O
}	O
static	O
ssize_t	long
entries_mapping_reverse_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
(	O
struct	O
entries_mapping	struct(*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long))))),*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long))))),*(long),*(long))
*	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
,	O
ssize_t	long
j	long
)	O
{	O
if	O
(	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
<	O
-	O
1	int
)	O
{	O
struct	O
changelog_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
*	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
=	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
;	O
struct	O
changelog_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
*	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
=	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
;	O
size_t	long
n1	long
=	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
num_entries	long
;	O
size_t	long
n2	long
=	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
num_entries	long
;	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
entry_j	*(struct(*(char),long,bool,long))
=	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
]	O
;	O
ssize_t	long
i	long
;	O
ssize_t	long
best_i	long
=	O
-	O
1	int
;	O
double	O
best_i_similarity	double
=	O
0.0	int
;	O
for	O
(	O
i	long
=	O
n1	long
-	O
1	int
;	O
i	long
>=	O
0	int
;	O
i	long
--	O
)	O
if	O
(	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping	*(long)
[	O
i	long
]	O
<	O
0	int
)	O
{	O
double	O
similarity	double
=	O
entry_fstrcmp	(*(struct(*(char),long,bool,long)),*(struct(*(char),long,bool,long)),double)->(double)
(	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
,	O
entry_j	*(struct(*(char),long,bool,long))
,	O
best_i_similarity	double
)	O
;	O
if	O
(	O
similarity	double
>	O
best_i_similarity	double
)	O
{	O
best_i	long
=	O
i	long
;	O
best_i_similarity	double
=	O
similarity	double
;	O
}	O
}	O
if	O
(	O
best_i_similarity	double
>=	O
FSTRCMP_THRESHOLD	int
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
entry_i	*(struct(*(char),long,bool,long))
=	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
best_i	long
]	O
;	O
ssize_t	long
best_j	long
=	O
-	O
1	int
;	O
double	O
best_j_similarity	double
=	O
0.0	int
;	O
ssize_t	long
jj	long
;	O
for	O
(	O
jj	long
=	O
n2	long
-	O
1	int
;	O
jj	long
>=	O
0	int
;	O
jj	long
--	O
)	O
if	O
(	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping_reverse	*(long)
[	O
jj	long
]	O
<	O
0	int
)	O
{	O
double	O
similarity	double
=	O
entry_fstrcmp	(*(struct(*(char),long,bool,long)),*(struct(*(char),long,bool,long)),double)->(double)
(	O
entry_i	*(struct(*(char),long,bool,long))
,	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
jj	long
]	O
,	O
best_j_similarity	double
)	O
;	O
if	O
(	O
similarity	double
>	O
best_j_similarity	double
)	O
{	O
best_j	long
=	O
jj	long
;	O
best_j_similarity	double
=	O
similarity	double
;	O
}	O
}	O
if	O
(	O
best_j_similarity	double
>=	O
FSTRCMP_THRESHOLD	int
&&	O
best_j	long
==	O
j	long
)	O
{	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
=	O
best_i	long
;	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping	*(long)
[	O
best_i	long
]	O
=	O
j	long
;	O
}	O
}	O
if	O
(	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
<	O
-	O
1	int
)	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
=	O
-	O
1	int
;	O
}	O
return	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
->	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
;	O
}	O
static	O
void	O
compute_mapping	(*(struct(*(struct),*(struct),long,*(*(struct`)))),*(struct(*(struct),*(struct),long,*(*(struct`)))),bool,*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))))->(void)
(	O
struct	O
changelog_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
*	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
,	O
struct	O
changelog_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
*	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
,	O
bool	bool
full	bool
,	O
struct	O
entries_mapping	struct(*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long))))),*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long))))),*(long),*(long))
*	O
result	*(struct)
)	O
{	O
ssize_t	long
*	O
index_mapping	*(long)
;	O
ssize_t	long
*	O
index_mapping_reverse	*(long)
;	O
size_t	long
n1	long
=	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
num_entries	long
;	O
size_t	long
n2	long
=	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
num_entries	long
;	O
ssize_t	long
i	long
,	O
j	long
;	O
index_mapping	*(long)
=	O
XNMALLOC	O
(	O
n1	long
,	O
ssize_t	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n1	long
;	O
i	long
++	O
)	O
index_mapping	*(long)
[	O
i	long
]	O
=	O
-	O
2	int
;	O
index_mapping_reverse	*(long)
=	O
XNMALLOC	O
(	O
n2	long
,	O
ssize_t	long
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n2	long
;	O
j	long
++	O
)	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
=	O
-	O
2	int
;	O
for	O
(	O
i	long
=	O
n1	long
-	O
1	int
;	O
i	long
>=	O
0	int
;	O
i	long
--	O
)	O
if	O
(	O
index_mapping	*(long)
[	O
i	long
]	O
<	O
-	O
1	int
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
entry	struct(*(char),long,bool,long)
=	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
;	O
j	long
=	O
gl_list_indexof	(*(struct),*(void))->(long)
(	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
entries_reversed	*(struct)
,	O
entry	struct(*(char),long,bool,long)
)	O
;	O
if	O
(	O
j	long
>=	O
0	int
)	O
{	O
j	long
=	O
n2	long
-	O
1	int
-	O
j	long
;	O
if	O
(	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
<	O
0	int
)	O
{	O
index_mapping	*(long)
[	O
i	long
]	O
=	O
j	long
;	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
=	O
i	long
;	O
{	O
ssize_t	long
curr_i	long
=	O
i	long
;	O
ssize_t	long
curr_j	long
=	O
j	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
ssize_t	long
next_i	long
;	O
ssize_t	long
next_j	long
;	O
next_i	long
=	O
gl_list_indexof_from	(*(struct),long,*(void))->(long)
(	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
entries_reversed	*(struct)
,	O
n1	long
-	O
curr_i	long
,	O
entry	struct(*(char),long,bool,long)
)	O
;	O
if	O
(	O
next_i	long
<	O
0	int
)	O
break	O
;	O
next_j	long
=	O
gl_list_indexof_from	(*(struct),long,*(void))->(long)
(	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
entries_reversed	*(struct)
,	O
n2	long
-	O
curr_j	long
,	O
entry	struct(*(char),long,bool,long)
)	O
;	O
if	O
(	O
next_j	long
<	O
0	int
)	O
break	O
;	O
curr_i	long
=	O
n1	long
-	O
1	int
-	O
next_i	long
;	O
curr_j	long
=	O
n2	long
-	O
1	int
-	O
next_j	long
;	O
ASSERT	O
(	O
index_mapping	*(long)
[	O
curr_i	long
]	O
<	O
0	int
)	O
;	O
ASSERT	O
(	O
index_mapping_reverse	*(long)
[	O
curr_j	long
]	O
<	O
0	int
)	O
;	O
index_mapping	*(long)
[	O
curr_i	long
]	O
=	O
curr_j	long
;	O
index_mapping_reverse	*(long)
[	O
curr_j	long
]	O
=	O
curr_i	long
;	O
}	O
}	O
}	O
}	O
}	O
result	*(struct)
->	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
=	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
;	O
result	*(struct)
->	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
=	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
;	O
result	*(struct)
->	O
index_mapping	*(long)
=	O
index_mapping	*(long)
;	O
result	*(struct)
->	O
index_mapping_reverse	*(long)
=	O
index_mapping_reverse	*(long)
;	O
if	O
(	O
full	bool
)	O
for	O
(	O
i	long
=	O
n1	long
-	O
1	int
;	O
i	long
>=	O
0	int
;	O
i	long
--	O
)	O
entries_mapping_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
(	O
result	*(struct)
,	O
i	long
)	O
;	O
}	O
enum	O
edit_type	enum(int,int,int)
{	O
ADDITION	int
,	O
CHANGE	int
,	O
REMOVAL	int
}	O
;	O
struct	O
edit	struct(enum(int,int,int),long,long,long,long)
{	O
enum	O
edit_type	enum(int,int,int)
type	enum(int,int,int)
;	O
ssize_t	long
i1	long
,	O
i2	long
;	O
ssize_t	long
j1	long
,	O
j2	long
;	O
}	O
;	O
struct	O
differences	struct(*(long),*(long),long,*(*(struct(enum(int,int,int),long,long,long,long))))
{	O
ssize_t	long
*	O
index_mapping	*(long)
;	O
ssize_t	long
*	O
index_mapping_reverse	*(long)
;	O
size_t	long
num_edits	long
;	O
struct	O
edit	struct(enum(int,int,int),long,long,long,long)
*	O
*	O
edits	*(*(struct(enum(int,int,int),long,long,long,long)))
;	O
}	O
;	O
static	O
void	O
compute_differences	(*(struct(*(struct),*(struct),long,*(*(struct`)))),*(struct(*(struct),*(struct),long,*(*(struct`)))),*(struct(*(long),*(long),long,*(*(struct`)))))->(void)
(	O
struct	O
changelog_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
*	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
,	O
struct	O
changelog_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
*	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
,	O
struct	O
differences	struct(*(long),*(long),long,*(*(struct(enum(int,int,int),long,long,long,long))))
*	O
result	*(struct)
)	O
{	O
struct	O
context	struct(*(*(struct(*(char),long,bool,long))),*(*(struct(*(char),long,bool,long))),*(long),*(long),*(long),*(long),long)
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
;	O
size_t	long
n1	long
=	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
num_entries	long
;	O
size_t	long
n2	long
=	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
num_entries	long
;	O
ssize_t	long
i	long
;	O
ssize_t	long
j	long
;	O
gl_list_t	*(struct)
edits	*(*(struct(enum(int,int,int),long,long,long,long)))
;	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
xvec	*(*(struct(*(char),long,bool,long)))
=	O
file1	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
entries	*(*(struct(*(char),long,bool,long)))
;	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
yvec	*(*(struct(*(char),long,bool,long)))
=	O
file2	*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long)))))
->	O
entries	*(*(struct(*(char),long,bool,long)))
;	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping	*(long)
=	O
XNMALLOC	O
(	O
n1	long
,	O
ssize_t	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n1	long
;	O
i	long
++	O
)	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping	*(long)
[	O
i	long
]	O
=	O
0	int
;	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping_reverse	*(long)
=	O
XNMALLOC	O
(	O
n2	long
,	O
ssize_t	long
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n2	long
;	O
j	long
++	O
)	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
=	O
0	int
;	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
fdiag	*(long)
=	O
XNMALLOC	O
(	O
2	int
*	O
(	O
n1	long
+	O
n2	long
+	O
3	int
)	O
,	O
ssize_t	long
)	O
+	O
n2	long
+	O
1	int
;	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
bdiag	*(long)
=	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
fdiag	*(long)
+	O
n1	long
+	O
n2	long
+	O
3	int
;	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
too_expensive	long
=	O
n1	long
+	O
n2	long
;	O
compareseq	(long,long,long,long,bool,*(struct(*(*(struct`)),*(*(struct`)),*(long),*(long),*(long),*(long),long)))->(bool)
(	O
0	int
,	O
n1	long
,	O
0	int
,	O
n2	long
,	O
0	int
,	O
&	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
)	O
;	O
i	long
=	O
0	int
;	O
j	long
=	O
0	int
;	O
while	O
(	O
i	long
<	O
n1	long
||	O
j	long
<	O
n2	long
)	O
{	O
while	O
(	O
i	long
<	O
n1	long
&&	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping	*(long)
[	O
i	long
]	O
<	O
0	int
)	O
i	long
++	O
;	O
while	O
(	O
j	long
<	O
n2	long
&&	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
<	O
0	int
)	O
j	long
++	O
;	O
ASSERT	O
(	O
(	O
i	long
<	O
n1	long
)	O
==	O
(	O
j	long
<	O
n2	long
)	O
)	O
;	O
if	O
(	O
i	long
==	O
n1	long
&&	O
j	long
==	O
n2	long
)	O
break	O
;	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping	*(long)
[	O
i	long
]	O
=	O
j	long
;	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
=	O
i	long
;	O
i	long
++	O
;	O
j	long
++	O
;	O
}	O
edits	*(*(struct(enum(int,int,int),long,long,long,long)))
=	O
gl_list_create_empty	(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*((*(void),*(void))->(bool)),*((*(void))->(long)),*((*(void))->(void)),bool)->(*(struct))
(	O
GL_ARRAY_LIST	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
true	int
)	O
;	O
i	long
=	O
0	int
;	O
j	long
=	O
0	int
;	O
while	O
(	O
i	long
<	O
n1	long
||	O
j	long
<	O
n2	long
)	O
{	O
if	O
(	O
i	long
==	O
n1	long
)	O
{	O
struct	O
edit	struct(enum(int,int,int),long,long,long,long)
*	O
e	*(struct(enum(int,int,int),long,long,long,long))
;	O
ASSERT	O
(	O
j	long
<	O
n2	long
)	O
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
=	O
XMALLOC	O
(	O
struct	O
edit	struct(enum(int,int,int),long,long,long,long)
)	O
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
type	enum(int,int,int)
=	O
ADDITION	int
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
j1	long
=	O
j	long
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
j2	long
=	O
n2	long
-	O
1	int
;	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
edits	*(*(struct(enum(int,int,int),long,long,long,long)))
,	O
e	*(struct(enum(int,int,int),long,long,long,long))
)	O
;	O
break	O
;	O
}	O
if	O
(	O
j	long
==	O
n2	long
)	O
{	O
struct	O
edit	struct(enum(int,int,int),long,long,long,long)
*	O
e	*(struct(enum(int,int,int),long,long,long,long))
;	O
ASSERT	O
(	O
i	long
<	O
n1	long
)	O
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
=	O
XMALLOC	O
(	O
struct	O
edit	struct(enum(int,int,int),long,long,long,long)
)	O
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
type	enum(int,int,int)
=	O
REMOVAL	int
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
i1	long
=	O
i	long
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
i2	long
=	O
n1	long
-	O
1	int
;	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
edits	*(*(struct(enum(int,int,int),long,long,long,long)))
,	O
e	*(struct(enum(int,int,int),long,long,long,long))
)	O
;	O
break	O
;	O
}	O
if	O
(	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping	*(long)
[	O
i	long
]	O
>=	O
0	int
)	O
{	O
if	O
(	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
>=	O
0	int
)	O
{	O
ASSERT	O
(	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping	*(long)
[	O
i	long
]	O
==	O
j	long
)	O
;	O
ASSERT	O
(	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
==	O
i	long
)	O
;	O
i	long
++	O
;	O
j	long
++	O
;	O
}	O
else	O
{	O
struct	O
edit	struct(enum(int,int,int),long,long,long,long)
*	O
e	*(struct(enum(int,int,int),long,long,long,long))
;	O
ASSERT	O
(	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
<	O
0	int
)	O
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
=	O
XMALLOC	O
(	O
struct	O
edit	struct(enum(int,int,int),long,long,long,long)
)	O
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
type	enum(int,int,int)
=	O
ADDITION	int
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
j1	long
=	O
j	long
;	O
do	O
j	long
++	O
;	O
while	O
(	O
j	long
<	O
n2	long
&&	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
<	O
0	int
)	O
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
j2	long
=	O
j	long
-	O
1	int
;	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
edits	*(*(struct(enum(int,int,int),long,long,long,long)))
,	O
e	*(struct(enum(int,int,int),long,long,long,long))
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
>=	O
0	int
)	O
{	O
struct	O
edit	struct(enum(int,int,int),long,long,long,long)
*	O
e	*(struct(enum(int,int,int),long,long,long,long))
;	O
ASSERT	O
(	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping	*(long)
[	O
i	long
]	O
<	O
0	int
)	O
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
=	O
XMALLOC	O
(	O
struct	O
edit	struct(enum(int,int,int),long,long,long,long)
)	O
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
type	enum(int,int,int)
=	O
REMOVAL	int
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
i1	long
=	O
i	long
;	O
do	O
i	long
++	O
;	O
while	O
(	O
i	long
<	O
n1	long
&&	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping	*(long)
[	O
i	long
]	O
<	O
0	int
)	O
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
i2	long
=	O
i	long
-	O
1	int
;	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
edits	*(*(struct(enum(int,int,int),long,long,long,long)))
,	O
e	*(struct(enum(int,int,int),long,long,long,long))
)	O
;	O
}	O
else	O
{	O
struct	O
edit	struct(enum(int,int,int),long,long,long,long)
*	O
e	*(struct(enum(int,int,int),long,long,long,long))
;	O
ASSERT	O
(	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping	*(long)
[	O
i	long
]	O
<	O
0	int
)	O
;	O
ASSERT	O
(	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
<	O
0	int
)	O
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
=	O
XMALLOC	O
(	O
struct	O
edit	struct(enum(int,int,int),long,long,long,long)
)	O
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
type	enum(int,int,int)
=	O
CHANGE	int
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
i1	long
=	O
i	long
;	O
do	O
i	long
++	O
;	O
while	O
(	O
i	long
<	O
n1	long
&&	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping	*(long)
[	O
i	long
]	O
<	O
0	int
)	O
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
i2	long
=	O
i	long
-	O
1	int
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
j1	long
=	O
j	long
;	O
do	O
j	long
++	O
;	O
while	O
(	O
j	long
<	O
n2	long
&&	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping_reverse	*(long)
[	O
j	long
]	O
<	O
0	int
)	O
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
->	O
j2	long
=	O
j	long
-	O
1	int
;	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
edits	*(*(struct(enum(int,int,int),long,long,long,long)))
,	O
e	*(struct(enum(int,int,int),long,long,long,long))
)	O
;	O
}	O
}	O
}	O
result	*(struct)
->	O
index_mapping	*(long)
=	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping	*(long)
;	O
result	*(struct)
->	O
index_mapping_reverse	*(long)
=	O
ctxt	*(struct(*(*(struct(*`,long,bool,long))),*(*(struct(*`,long,bool,long))),*(long),*(long),*(long),*(long),long))
.	O
index_mapping_reverse	*(long)
;	O
result	*(struct)
->	O
num_edits	long
=	O
gl_list_size	(*(struct))->(long)
(	O
edits	*(*(struct(enum(int,int,int),long,long,long,long)))
)	O
;	O
result	*(struct)
->	O
edits	*(*(struct(enum(int,int,int),long,long,long,long)))
=	O
XNMALLOC	O
(	O
result	*(struct)
->	O
num_edits	long
,	O
struct	O
edit	struct(enum(int,int,int),long,long,long,long)
*	O
)	O
;	O
{	O
size_t	long
index	(*(char),int)->(*(char))
=	O
0	int
;	O
gl_list_iterator_t	struct(*(struct),*(struct),long,*(void),*(void),long,long)
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
=	O
gl_list_iterator	(*(struct))->(struct(*(struct),*(struct),long,*(void),*(void),long,long))
(	O
edits	*(*(struct(enum(int,int,int),long,long,long,long)))
)	O
;	O
const	O
void	O
*	O
elt	*(void)
;	O
gl_list_node_t	*(struct)
node	*(struct)
;	O
while	O
(	O
gl_list_iterator_next	(*(struct(*(struct),*(struct),long,*(void),*(void),long,long)),*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
,	O
&	O
elt	*(void)
,	O
&	O
node	*(struct)
)	O
)	O
result	*(struct)
->	O
edits	*(*(struct(enum(int,int,int),long,long,long,long)))
[	O
index	(*(char),int)->(*(char))
++	O
]	O
=	O
(	O
struct	O
edit	struct(enum(int,int,int),long,long,long,long)
*	O
)	O
elt	*(void)
;	O
gl_list_iterator_free	(*(struct(*(struct),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
ASSERT	O
(	O
index	(*(char),int)->(*(char))
==	O
result	*(struct)
->	O
num_edits	long
)	O
;	O
}	O
}	O
static	O
struct	O
entry	struct(*(char),long,bool,long)
empty_entry	struct(*(char),long,bool,long)
=	O
{	O
NULL	O
,	O
0	int
}	O
;	O
static	O
size_t	long
find_paragraph_end	(*(struct(*(char),long,bool,long)),long)->(long)
(	O
const	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
entry	struct(*(char),long,bool,long)
,	O
size_t	long
offset	long
)	O
{	O
const	O
char	O
*	O
string	*(char)
=	O
entry	struct(*(char),long,bool,long)
->	O
string	*(char)
;	O
size_t	long
length	*(long)
=	O
entry	struct(*(char),long,bool,long)
->	O
length	*(long)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
const	O
char	O
*	O
nl	*(char)
=	O
memchr	(*(void),int,long)->(*(void))
(	O
string	*(char)
+	O
offset	long
,	O
'\n'	O
,	O
length	*(long)
-	O
offset	long
)	O
;	O
if	O
(	O
nl	*(char)
==	O
NULL	O
)	O
return	O
length	*(long)
;	O
offset	long
=	O
(	O
nl	*(char)
-	O
string	*(char)
)	O
+	O
1	int
;	O
if	O
(	O
offset	long
<	O
length	*(long)
&&	O
string	*(char)
[	O
offset	long
]	O
==	O
'\n'	O
)	O
return	O
offset	long
;	O
}	O
}	O
static	O
bool	bool
try_split_merged_entry	(*(struct(*(char),long,bool,long)),*(struct(*(char),long,bool,long)),array(*(struct(*(char),long,bool,long))))->(bool)
(	O
const	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
old_entry	*(struct(*(char),long,bool,long))
,	O
const	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
new_entry	*(struct(*(char),long,bool,long))
,	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
new_split	array(*(struct(*(char),long,bool,long)))
[	O
2	int
]	O
)	O
{	O
size_t	long
old_title_len	long
=	O
find_paragraph_end	(*(struct(*(char),long,bool,long)),long)->(long)
(	O
old_entry	*(struct(*(char),long,bool,long))
,	O
0	int
)	O
;	O
size_t	long
new_title_len	long
=	O
find_paragraph_end	(*(struct(*(char),long,bool,long)),long)->(long)
(	O
new_entry	*(struct(*(char),long,bool,long))
,	O
0	int
)	O
;	O
struct	O
entry	struct(*(char),long,bool,long)
old_body	struct(*(char),long,bool,long)
;	O
struct	O
entry	struct(*(char),long,bool,long)
new_body	struct(*(char),long,bool,long)
;	O
size_t	long
best_split_offset	long
;	O
double	O
best_similarity	double
;	O
size_t	long
split_offset	long
;	O
if	O
(	O
!	O
(	O
old_title_len	long
==	O
new_title_len	long
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
old_entry	*(struct(*(char),long,bool,long))
->	O
string	*(char)
,	O
new_entry	*(struct(*(char),long,bool,long))
->	O
string	*(char)
,	O
old_title_len	long
)	O
==	O
0	int
)	O
)	O
return	O
false	int
;	O
old_body	struct(*(char),long,bool,long)
.	O
string	*(char)
=	O
old_entry	*(struct(*(char),long,bool,long))
->	O
string	*(char)
+	O
old_title_len	long
;	O
old_body	struct(*(char),long,bool,long)
.	O
length	*(long)
=	O
old_entry	*(struct(*(char),long,bool,long))
->	O
length	*(long)
-	O
old_title_len	long
;	O
best_split_offset	long
=	O
split_offset	long
=	O
new_title_len	long
;	O
best_similarity	double
=	O
0.0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
double	O
similarity	double
;	O
new_body	struct(*(char),long,bool,long)
.	O
string	*(char)
=	O
new_entry	*(struct(*(char),long,bool,long))
->	O
string	*(char)
+	O
split_offset	long
;	O
new_body	struct(*(char),long,bool,long)
.	O
length	*(long)
=	O
new_entry	*(struct(*(char),long,bool,long))
->	O
length	*(long)
-	O
split_offset	long
;	O
similarity	double
=	O
entry_fstrcmp	(*(struct(*(char),long,bool,long)),*(struct(*(char),long,bool,long)),double)->(double)
(	O
&	O
old_body	struct(*(char),long,bool,long)
,	O
&	O
new_body	struct(*(char),long,bool,long)
,	O
best_similarity	double
)	O
;	O
if	O
(	O
similarity	double
>	O
best_similarity	double
)	O
{	O
best_split_offset	long
=	O
split_offset	long
;	O
best_similarity	double
=	O
similarity	double
;	O
}	O
if	O
(	O
best_similarity	double
==	O
1.0	int
)	O
break	O
;	O
if	O
(	O
split_offset	long
<	O
new_entry	*(struct(*(char),long,bool,long))
->	O
length	*(long)
)	O
split_offset	long
=	O
find_paragraph_end	(*(struct(*(char),long,bool,long)),long)->(long)
(	O
new_entry	*(struct(*(char),long,bool,long))
,	O
split_offset	long
+	O
1	int
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
best_split_offset	long
==	O
new_entry	*(struct(*(char),long,bool,long))
->	O
length	*(long)
)	O
return	O
false	int
;	O
ASSERT	O
(	O
new_entry	*(struct(*(char),long,bool,long))
->	O
string	*(char)
[	O
best_split_offset	long
]	O
==	O
'\n'	O
)	O
;	O
if	O
(	O
best_similarity	double
<	O
FSTRCMP_STRICTER_THRESHOLD	int
)	O
return	O
false	int
;	O
new_split	array(*(struct(*(char),long,bool,long)))
[	O
0	int
]	O
=	O
entry_create	(*(char),long)->(*(struct(*(char),long,bool,long)))
(	O
new_entry	*(struct(*(char),long,bool,long))
->	O
string	*(char)
,	O
best_split_offset	long
+	O
1	int
)	O
;	O
{	O
size_t	long
len1	long
=	O
new_title_len	long
;	O
size_t	long
len2	long
=	O
new_entry	*(struct(*(char),long,bool,long))
->	O
length	*(long)
-	O
best_split_offset	long
;	O
char	O
*	O
combined	*(char)
=	O
XNMALLOC	O
(	O
len1	long
+	O
len2	long
,	O
char	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
combined	*(char)
,	O
new_entry	*(struct(*(char),long,bool,long))
->	O
string	*(char)
,	O
len1	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
combined	*(char)
+	O
len1	long
,	O
new_entry	*(struct(*(char),long,bool,long))
->	O
string	*(char)
+	O
best_split_offset	long
,	O
len2	long
)	O
;	O
new_split	array(*(struct(*(char),long,bool,long)))
[	O
1	int
]	O
=	O
entry_create	(*(char),long)->(*(struct(*(char),long,bool,long)))
(	O
combined	*(char)
,	O
len1	long
+	O
len2	long
)	O
;	O
}	O
return	O
true	int
;	O
}	O
static	O
void	O
entry_write	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),long,bool,long)))->(void)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
entry	struct(*(char),long,bool,long)
)	O
{	O
if	O
(	O
entry	struct(*(char),long,bool,long)
->	O
length	*(long)
>	O
0	int
)	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
entry	struct(*(char),long,bool,long)
->	O
string	*(char)
,	O
1	int
,	O
entry	struct(*(char),long,bool,long)
->	O
length	*(long)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
struct	O
conflict	struct(long,*(*(struct(*(char),long,bool,long))),long,*(*(struct(*(char),long,bool,long))))
{	O
size_t	long
num_old_entries	long
;	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
*	O
old_entries	*(*(struct(*(char),long,bool,long)))
;	O
size_t	long
num_modified_entries	long
;	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
*	O
modified_entries	*(*(struct(*(char),long,bool,long)))
;	O
}	O
;	O
static	O
void	O
conflict_write	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(long,*(*(struct`)),long,*(*(struct`)))))->(void)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
struct	O
conflict	struct(long,*(*(struct(*(char),long,bool,long))),long,*(*(struct(*(char),long,bool,long))))
*	O
c	long
)	O
{	O
size_t	long
i	long
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"<<<<<<<\n"	*(char)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
c	long
->	O
num_old_entries	long
;	O
i	long
++	O
)	O
entry_write	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),long,bool,long)))->(void)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
c	long
->	O
old_entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"=======\n"	*(char)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
c	long
->	O
num_modified_entries	long
;	O
i	long
++	O
)	O
entry_write	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),long,bool,long)))->(void)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
c	long
->	O
modified_entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
">>>>>>>\n"	*(char)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
const	O
struct	O
option	struct(*(char),int,*(int),int)
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"split-merged-entry"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
1	int
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Try `%s --help' for more information.\n"	*(char)
,	O
program_name	*(char)
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Usage: %s [OPTION] O-FILE-NAME A-FILE-NAME B-FILE-NAME\n"	*(char)
,	O
program_name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Merges independent modifications of a ChangeLog style file.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"O-FILE-NAME names the original file, the ancestor of the two others.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"A-FILE-NAME names the publicly modified file.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"B-FILE-NAME names the user-modified file.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Writes the merged file into A-FILE-NAME.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Informative output:\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"  -h, --help                  display this help and exit\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"  -V, --version               output version information and exit\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Report bugs to <bug-gnu-gettext@gnu.org>.\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array(*(char))
[	O
]	O
)	O
{	O
int	O
optchar	int
;	O
bool	bool
do_help	bool
;	O
bool	bool
do_version	bool
;	O
bool	bool
split_merged_entry	bool
;	O
set_program_name	(*(char))->(void)
(	O
argv	array(*(char))
[	O
0	int
]	O
)	O
;	O
do_help	bool
=	O
false	int
;	O
do_version	bool
=	O
false	int
;	O
split_merged_entry	bool
=	O
true	int
;	O
while	O
(	O
(	O
optchar	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	array(*(char))
,	O
"hV"	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
switch	O
(	O
optchar	int
)	O
{	O
case	O
'\0'	O
:	O
break	O
;	O
case	O
'h'	O
:	O
do_help	bool
=	O
true	int
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
1	int
:	O
break	O
;	O
default	O
:	O
usage	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
do_version	bool
)	O
{	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
program_name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv2+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	*(char)
,	O
"2008"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Written by %s.\n"	*(char)
,	O
"Bruno Haible"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
do_help	bool
)	O
{	O
usage	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
optind	int
+	O
3	int
!=	O
argc	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"expected three arguments"	*(char)
)	O
;	O
{	O
const	O
char	O
*	O
ancestor_file_name	*(char)
;	O
const	O
char	O
*	O
destination_file_name	*(char)
;	O
bool	bool
downstream	bool
;	O
const	O
char	O
*	O
other_file_name	*(char)
;	O
const	O
char	O
*	O
mainstream_file_name	*(char)
;	O
const	O
char	O
*	O
modified_file_name	*(char)
;	O
struct	O
changelog_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
;	O
struct	O
changelog_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
mainstream_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
;	O
struct	O
changelog_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
;	O
struct	O
entries_mapping	struct(*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long))))),*(struct(*(struct),*(struct),long,*(*(struct(*`,long,bool,long))))),*(long),*(long))
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
;	O
struct	O
differences	struct(*(long),*(long),long,*(*(struct(enum(int,int,int),long,long,long,long))))
diffs	struct(*(long),*(long),long,*(*(struct(enum(int,int,int),long,long,long,long))))
;	O
gl_list_node_t	*(struct)
*	O
result_entries_pointers	*(*(struct))
;	O
gl_list_t	*(struct)
result_entries	*(struct)
;	O
gl_list_t	*(struct)
result_conflicts	*(struct)
;	O
ancestor_file_name	*(char)
=	O
argv	array(*(char))
[	O
optind	int
]	O
;	O
destination_file_name	*(char)
=	O
argv	array(*(char))
[	O
optind	int
+	O
1	int
]	O
;	O
other_file_name	*(char)
=	O
argv	array(*(char))
[	O
optind	int
+	O
2	int
]	O
;	O
{	O
const	O
char	O
*	O
var	*(char)
;	O
var	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"GIT_DOWNSTREAM"	*(char)
)	O
;	O
if	O
(	O
var	*(char)
!=	O
NULL	O
&&	O
var	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
downstream	bool
=	O
true	int
;	O
else	O
{	O
var	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"GIT_UPSTREAM"	*(char)
)	O
;	O
if	O
(	O
var	*(char)
!=	O
NULL	O
&&	O
var	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
downstream	bool
=	O
false	int
;	O
else	O
{	O
var	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"GIT_REFLOG_ACTION"	*(char)
)	O
;	O
if	O
(	O
var	*(char)
!=	O
NULL	O
&&	O
(	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
var	*(char)
,	O
"pull"	*(char)
,	O
4	int
)	O
==	O
0	int
&&	O
c_strstr	(*(char),*(char))->(*(char))
(	O
var	*(char)
,	O
" --rebase"	*(char)
)	O
==	O
NULL	O
)	O
||	O
strncmp	(*(char),*(char),long)->(int)
(	O
var	*(char)
,	O
"merge origin"	*(char)
,	O
12	int
)	O
==	O
0	int
)	O
)	O
downstream	bool
=	O
true	int
;	O
else	O
{	O
downstream	bool
=	O
false	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
downstream	bool
)	O
{	O
mainstream_file_name	*(char)
=	O
other_file_name	*(char)
;	O
modified_file_name	*(char)
=	O
destination_file_name	*(char)
;	O
}	O
else	O
{	O
mainstream_file_name	*(char)
=	O
destination_file_name	*(char)
;	O
modified_file_name	*(char)
=	O
other_file_name	*(char)
;	O
}	O
read_changelog_file	(*(char),*(struct(*(struct),*(struct),long,*(*(struct`)))))->(void)
(	O
ancestor_file_name	*(char)
,	O
&	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
)	O
;	O
read_changelog_file	(*(char),*(struct(*(struct),*(struct),long,*(*(struct`)))))->(void)
(	O
mainstream_file_name	*(char)
,	O
&	O
mainstream_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
)	O
;	O
read_changelog_file	(*(char),*(struct(*(struct),*(struct),long,*(*(struct`)))))->(void)
(	O
modified_file_name	*(char)
,	O
&	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
)	O
;	O
compute_mapping	(*(struct(*(struct),*(struct),long,*(*(struct`)))),*(struct(*(struct),*(struct),long,*(*(struct`)))),bool,*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))))->(void)
(	O
&	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
,	O
&	O
mainstream_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
,	O
false	int
,	O
&	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
)	O
;	O
(	O
void	O
)	O
entries_mapping_reverse_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
;	O
compute_differences	(*(struct(*(struct),*(struct),long,*(*(struct`)))),*(struct(*(struct),*(struct),long,*(*(struct`)))),*(struct(*(long),*(long),long,*(*(struct`)))))->(void)
(	O
&	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
,	O
&	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
,	O
&	O
diffs	struct(*(long),*(long),long,*(*(struct(enum(int,int,int),long,long,long,long))))
)	O
;	O
result_entries_pointers	*(*(struct))
=	O
XNMALLOC	O
(	O
mainstream_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
num_entries	long
,	O
gl_list_node_t	*(struct)
)	O
;	O
result_entries	*(struct)
=	O
gl_list_create_empty	(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*((*(void),*(void))->(bool)),*((*(void))->(long)),*((*(void))->(void)),bool)->(*(struct))
(	O
GL_LINKED_LIST	O
,	O
entry_equals	(*(void),*(void))->(bool)
,	O
entry_hashcode	(*(void))->(long)
,	O
NULL	O
,	O
true	int
)	O
;	O
{	O
size_t	long
k	long
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
mainstream_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
num_entries	long
;	O
k	long
++	O
)	O
result_entries_pointers	*(*(struct))
[	O
k	long
]	O
=	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
result_entries	*(struct)
,	O
mainstream_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
k	long
]	O
)	O
;	O
}	O
result_conflicts	*(struct)
=	O
gl_list_create_empty	(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*((*(void),*(void))->(bool)),*((*(void))->(long)),*((*(void))->(void)),bool)->(*(struct))
(	O
GL_ARRAY_LIST	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
true	int
)	O
;	O
{	O
size_t	long
e	*(struct(enum(int,int,int),long,long,long,long))
;	O
for	O
(	O
e	*(struct(enum(int,int,int),long,long,long,long))
=	O
0	int
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
<	O
diffs	struct(*(long),*(long),long,*(*(struct(enum(int,int,int),long,long,long,long))))
.	O
num_edits	long
;	O
e	*(struct(enum(int,int,int),long,long,long,long))
++	O
)	O
{	O
struct	O
edit	struct(enum(int,int,int),long,long,long,long)
*	O
edit	struct(enum(int,int,int),long,long,long,long)
=	O
diffs	struct(*(long),*(long),long,*(*(struct(enum(int,int,int),long,long,long,long))))
.	O
edits	*(*(struct(enum(int,int,int),long,long,long,long)))
[	O
e	*(struct(enum(int,int,int),long,long,long,long))
]	O
;	O
switch	O
(	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
type	enum(int,int,int)
)	O
{	O
case	O
ADDITION	int
:	O
if	O
(	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
==	O
0	int
)	O
{	O
ssize_t	long
j	long
;	O
for	O
(	O
j	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
;	O
j	long
>=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
;	O
j	long
--	O
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
added_entry	*(struct(*(char),long,bool,long))
=	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
]	O
;	O
gl_list_add_first	(*(struct),*(void))->(*(struct))
(	O
result_entries	*(struct)
,	O
added_entry	*(struct(*(char),long,bool,long))
)	O
;	O
}	O
}	O
else	O
{	O
ssize_t	long
i_before	long
;	O
ssize_t	long
i_after	long
;	O
ssize_t	long
k_before	long
;	O
ssize_t	long
k_after	long
;	O
i_before	long
=	O
diffs	struct(*(long),*(long),long,*(*(struct(enum(int,int,int),long,long,long,long))))
.	O
index_mapping_reverse	*(long)
[	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
-	O
1	int
]	O
;	O
ASSERT	O
(	O
i_before	long
>=	O
0	int
)	O
;	O
i_after	long
=	O
(	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
+	O
1	int
==	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
num_entries	long
?	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
num_entries	long
:	O
diffs	struct(*(long),*(long),long,*(*(struct(enum(int,int,int),long,long,long,long))))
.	O
index_mapping_reverse	*(long)
[	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
+	O
1	int
]	O
)	O
;	O
ASSERT	O
(	O
i_after	long
>=	O
0	int
)	O
;	O
ASSERT	O
(	O
i_after	long
==	O
i_before	long
+	O
1	int
)	O
;	O
k_before	long
=	O
entries_mapping_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
(	O
&	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
,	O
i_before	long
)	O
;	O
k_after	long
=	O
(	O
i_after	long
==	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
num_entries	long
?	O
mainstream_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
num_entries	long
:	O
entries_mapping_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
(	O
&	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
,	O
i_after	long
)	O
)	O
;	O
if	O
(	O
k_before	long
>=	O
0	int
&&	O
k_after	long
>=	O
0	int
&&	O
k_after	long
==	O
k_before	long
+	O
1	int
)	O
{	O
if	O
(	O
k_after	long
==	O
mainstream_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
num_entries	long
)	O
{	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
;	O
j	long
<=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
;	O
j	long
++	O
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
added_entry	*(struct(*(char),long,bool,long))
=	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
]	O
;	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
result_entries	*(struct)
,	O
added_entry	*(struct(*(char),long,bool,long))
)	O
;	O
}	O
}	O
else	O
{	O
gl_list_node_t	*(struct)
node_k_after	*(struct)
=	O
result_entries_pointers	*(*(struct))
[	O
k_after	long
]	O
;	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
;	O
j	long
<=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
;	O
j	long
++	O
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
added_entry	*(struct(*(char),long,bool,long))
=	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
]	O
;	O
gl_list_add_before	(*(struct),*(struct),*(void))->(*(struct))
(	O
result_entries	*(struct)
,	O
node_k_after	*(struct)
,	O
added_entry	*(struct(*(char),long,bool,long))
)	O
;	O
}	O
}	O
}	O
else	O
{	O
struct	O
conflict	struct(long,*(*(struct(*(char),long,bool,long))),long,*(*(struct(*(char),long,bool,long))))
*	O
c	long
=	O
XMALLOC	O
(	O
struct	O
conflict	struct(long,*(*(struct(*(char),long,bool,long))),long,*(*(struct(*(char),long,bool,long))))
)	O
;	O
size_t	long
j	long
;	O
c	long
->	O
num_old_entries	long
=	O
0	int
;	O
c	long
->	O
old_entries	*(*(struct(*(char),long,bool,long)))
=	O
NULL	O
;	O
c	long
->	O
num_modified_entries	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
+	O
1	int
;	O
c	long
->	O
modified_entries	*(*(struct(*(char),long,bool,long)))
=	O
XNMALLOC	O
(	O
c	long
->	O
num_modified_entries	long
,	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
;	O
for	O
(	O
j	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
;	O
j	long
<=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
;	O
j	long
++	O
)	O
c	long
->	O
modified_entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
]	O
=	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
]	O
;	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
result_conflicts	*(struct)
,	O
c	long
)	O
;	O
}	O
}	O
break	O
;	O
case	O
REMOVAL	int
:	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i1	long
;	O
i	long
<=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
;	O
i	long
++	O
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
removed_entry	*(struct(*(char),long,bool,long))
=	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
;	O
ssize_t	long
k	long
=	O
entries_mapping_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
(	O
&	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
,	O
i	long
)	O
;	O
if	O
(	O
k	long
>=	O
0	int
&&	O
entry_equals	(*(void),*(void))->(bool)
(	O
removed_entry	*(struct(*(char),long,bool,long))
,	O
mainstream_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
k	long
]	O
)	O
)	O
{	O
gl_list_node_set_value	(*(struct),*(struct),*(void))->(void)
(	O
result_entries	*(struct)
,	O
result_entries_pointers	*(*(struct))
[	O
k	long
]	O
,	O
&	O
empty_entry	struct(*(char),long,bool,long)
)	O
;	O
}	O
else	O
{	O
struct	O
conflict	struct(long,*(*(struct(*(char),long,bool,long))),long,*(*(struct(*(char),long,bool,long))))
*	O
c	long
=	O
XMALLOC	O
(	O
struct	O
conflict	struct(long,*(*(struct(*(char),long,bool,long))),long,*(*(struct(*(char),long,bool,long))))
)	O
;	O
c	long
->	O
num_old_entries	long
=	O
1	int
;	O
c	long
->	O
old_entries	*(*(struct(*(char),long,bool,long)))
=	O
XNMALLOC	O
(	O
c	long
->	O
num_old_entries	long
,	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
;	O
c	long
->	O
old_entries	*(*(struct(*(char),long,bool,long)))
[	O
0	int
]	O
=	O
removed_entry	*(struct(*(char),long,bool,long))
;	O
c	long
->	O
num_modified_entries	long
=	O
0	int
;	O
c	long
->	O
modified_entries	*(*(struct(*(char),long,bool,long)))
=	O
NULL	O
;	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
result_conflicts	*(struct)
,	O
c	long
)	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
CHANGE	int
:	O
{	O
bool	bool
done	bool
=	O
false	int
;	O
if	O
(	O
split_merged_entry	bool
&&	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
==	O
0	int
)	O
{	O
if	O
(	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i1	long
<=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
split	array(*(struct(*(char),long,bool,long)))
[	O
2	int
]	O
;	O
bool	bool
simple_merged	bool
=	O
try_split_merged_entry	(*(struct(*(char),long,bool,long)),*(struct(*(char),long,bool,long)),array(*(struct(*(char),long,bool,long))))->(bool)
(	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i1	long
]	O
,	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i1	long
+	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
]	O
,	O
split	array(*(struct(*(char),long,bool,long)))
)	O
;	O
if	O
(	O
simple_merged	bool
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i1	long
+	O
1	int
;	O
i	long
<=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
;	O
i	long
++	O
)	O
if	O
(	O
entry_fstrcmp	(*(struct(*(char),long,bool,long)),*(struct(*(char),long,bool,long)),double)->(double)
(	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
,	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
+	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
]	O
,	O
FSTRCMP_THRESHOLD	int
)	O
<	O
FSTRCMP_THRESHOLD	int
)	O
{	O
simple_merged	bool
=	O
false	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
simple_merged	bool
)	O
{	O
size_t	long
num_changed	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i1	long
+	O
1	int
;	O
size_t	long
num_added	long
=	O
(	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
+	O
1	int
)	O
-	O
num_changed	long
;	O
ssize_t	long
j	long
;	O
gl_list_add_first	(*(struct),*(void))->(*(struct))
(	O
result_entries	*(struct)
,	O
split	array(*(struct(*(char),long,bool,long)))
[	O
0	int
]	O
)	O
;	O
for	O
(	O
j	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
+	O
num_added	long
-	O
1	int
;	O
j	long
>=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
;	O
j	long
--	O
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
added_entry	*(struct(*(char),long,bool,long))
=	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
]	O
;	O
gl_list_add_first	(*(struct),*(void))->(*(struct))
(	O
result_entries	*(struct)
,	O
added_entry	*(struct(*(char),long,bool,long))
)	O
;	O
}	O
for	O
(	O
j	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
+	O
num_added	long
;	O
j	long
<=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
;	O
j	long
++	O
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
changed_entry	*(struct(*(char),long,bool,long))
=	O
(	O
j	long
==	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
+	O
num_added	long
?	O
split	array(*(struct(*(char),long,bool,long)))
[	O
1	int
]	O
:	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
]	O
)	O
;	O
size_t	long
i	long
=	O
j	long
+	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
;	O
ssize_t	long
k	long
=	O
entries_mapping_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
(	O
&	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
,	O
i	long
)	O
;	O
if	O
(	O
k	long
>=	O
0	int
&&	O
entry_equals	(*(void),*(void))->(bool)
(	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
,	O
mainstream_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
k	long
]	O
)	O
)	O
{	O
gl_list_node_set_value	(*(struct),*(struct),*(void))->(void)
(	O
result_entries	*(struct)
,	O
result_entries_pointers	*(*(struct))
[	O
k	long
]	O
,	O
changed_entry	*(struct(*(char),long,bool,long))
)	O
;	O
}	O
else	O
if	O
(	O
!	O
entry_equals	(*(void),*(void))->(bool)
(	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
,	O
changed_entry	*(struct(*(char),long,bool,long))
)	O
)	O
{	O
struct	O
conflict	struct(long,*(*(struct(*(char),long,bool,long))),long,*(*(struct(*(char),long,bool,long))))
*	O
c	long
=	O
XMALLOC	O
(	O
struct	O
conflict	struct(long,*(*(struct(*(char),long,bool,long))),long,*(*(struct(*(char),long,bool,long))))
)	O
;	O
c	long
->	O
num_old_entries	long
=	O
1	int
;	O
c	long
->	O
old_entries	*(*(struct(*(char),long,bool,long)))
=	O
XNMALLOC	O
(	O
c	long
->	O
num_old_entries	long
,	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
;	O
c	long
->	O
old_entries	*(*(struct(*(char),long,bool,long)))
[	O
0	int
]	O
=	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
;	O
c	long
->	O
num_modified_entries	long
=	O
1	int
;	O
c	long
->	O
modified_entries	*(*(struct(*(char),long,bool,long)))
=	O
XNMALLOC	O
(	O
c	long
->	O
num_modified_entries	long
,	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
;	O
c	long
->	O
modified_entries	*(*(struct(*(char),long,bool,long)))
[	O
0	int
]	O
=	O
changed_entry	*(struct(*(char),long,bool,long))
;	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
result_conflicts	*(struct)
,	O
c	long
)	O
;	O
}	O
}	O
done	bool
=	O
true	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
done	bool
)	O
{	O
bool	bool
simple	bool
;	O
if	O
(	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i1	long
<=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
)	O
{	O
size_t	long
i	long
;	O
simple	bool
=	O
true	int
;	O
for	O
(	O
i	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i1	long
;	O
i	long
<=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
;	O
i	long
++	O
)	O
if	O
(	O
entry_fstrcmp	(*(struct(*(char),long,bool,long)),*(struct(*(char),long,bool,long)),double)->(double)
(	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
,	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
+	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
]	O
,	O
FSTRCMP_THRESHOLD	int
)	O
<	O
FSTRCMP_THRESHOLD	int
)	O
{	O
simple	bool
=	O
false	int
;	O
break	O
;	O
}	O
}	O
else	O
simple	bool
=	O
false	int
;	O
if	O
(	O
simple	bool
)	O
{	O
size_t	long
num_changed	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i1	long
+	O
1	int
;	O
size_t	long
num_added	long
=	O
(	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
+	O
1	int
)	O
-	O
num_changed	long
;	O
if	O
(	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
==	O
0	int
)	O
{	O
ssize_t	long
j	long
;	O
for	O
(	O
j	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
+	O
num_added	long
-	O
1	int
;	O
j	long
>=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
;	O
j	long
--	O
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
added_entry	*(struct(*(char),long,bool,long))
=	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
]	O
;	O
gl_list_add_first	(*(struct),*(void))->(*(struct))
(	O
result_entries	*(struct)
,	O
added_entry	*(struct(*(char),long,bool,long))
)	O
;	O
}	O
for	O
(	O
j	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
+	O
num_added	long
;	O
j	long
<=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
;	O
j	long
++	O
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
changed_entry	*(struct(*(char),long,bool,long))
=	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
]	O
;	O
size_t	long
i	long
=	O
j	long
+	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
;	O
ssize_t	long
k	long
=	O
entries_mapping_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
(	O
&	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
,	O
i	long
)	O
;	O
if	O
(	O
k	long
>=	O
0	int
&&	O
entry_equals	(*(void),*(void))->(bool)
(	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
,	O
mainstream_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
k	long
]	O
)	O
)	O
{	O
gl_list_node_set_value	(*(struct),*(struct),*(void))->(void)
(	O
result_entries	*(struct)
,	O
result_entries_pointers	*(*(struct))
[	O
k	long
]	O
,	O
changed_entry	*(struct(*(char),long,bool,long))
)	O
;	O
}	O
else	O
{	O
struct	O
conflict	struct(long,*(*(struct(*(char),long,bool,long))),long,*(*(struct(*(char),long,bool,long))))
*	O
c	long
;	O
ASSERT	O
(	O
!	O
entry_equals	(*(void),*(void))->(bool)
(	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
,	O
changed_entry	*(struct(*(char),long,bool,long))
)	O
)	O
;	O
c	long
=	O
XMALLOC	O
(	O
struct	O
conflict	struct(long,*(*(struct(*(char),long,bool,long))),long,*(*(struct(*(char),long,bool,long))))
)	O
;	O
c	long
->	O
num_old_entries	long
=	O
1	int
;	O
c	long
->	O
old_entries	*(*(struct(*(char),long,bool,long)))
=	O
XNMALLOC	O
(	O
c	long
->	O
num_old_entries	long
,	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
;	O
c	long
->	O
old_entries	*(*(struct(*(char),long,bool,long)))
[	O
0	int
]	O
=	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
;	O
c	long
->	O
num_modified_entries	long
=	O
1	int
;	O
c	long
->	O
modified_entries	*(*(struct(*(char),long,bool,long)))
=	O
XNMALLOC	O
(	O
c	long
->	O
num_modified_entries	long
,	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
;	O
c	long
->	O
modified_entries	*(*(struct(*(char),long,bool,long)))
[	O
0	int
]	O
=	O
changed_entry	*(struct(*(char),long,bool,long))
;	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
result_conflicts	*(struct)
,	O
c	long
)	O
;	O
}	O
}	O
done	bool
=	O
true	int
;	O
}	O
else	O
{	O
ssize_t	long
i_before	long
;	O
ssize_t	long
k_before	long
;	O
bool	bool
linear	bool
;	O
i_before	long
=	O
diffs	struct(*(long),*(long),long,*(*(struct(enum(int,int,int),long,long,long,long))))
.	O
index_mapping_reverse	*(long)
[	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
-	O
1	int
]	O
;	O
ASSERT	O
(	O
i_before	long
>=	O
0	int
)	O
;	O
k_before	long
=	O
entries_mapping_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
(	O
&	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
,	O
i_before	long
)	O
;	O
linear	bool
=	O
(	O
k_before	long
>=	O
0	int
)	O
;	O
if	O
(	O
linear	bool
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
i_before	long
+	O
1	int
;	O
i	long
<=	O
i_before	long
+	O
num_changed	long
;	O
i	long
++	O
)	O
if	O
(	O
entries_mapping_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
(	O
&	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
,	O
i	long
)	O
!=	O
k_before	long
+	O
(	O
i	long
-	O
i_before	long
)	O
)	O
{	O
linear	bool
=	O
false	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
linear	bool
)	O
{	O
gl_list_node_t	*(struct)
node_for_insert	*(struct)
=	O
result_entries_pointers	*(*(struct))
[	O
k_before	long
+	O
1	int
]	O
;	O
ssize_t	long
j	long
;	O
for	O
(	O
j	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
+	O
num_added	long
-	O
1	int
;	O
j	long
>=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
;	O
j	long
--	O
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
added_entry	*(struct(*(char),long,bool,long))
=	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
]	O
;	O
gl_list_add_before	(*(struct),*(struct),*(void))->(*(struct))
(	O
result_entries	*(struct)
,	O
node_for_insert	*(struct)
,	O
added_entry	*(struct(*(char),long,bool,long))
)	O
;	O
}	O
for	O
(	O
j	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
+	O
num_added	long
;	O
j	long
<=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
;	O
j	long
++	O
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
changed_entry	*(struct(*(char),long,bool,long))
=	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
]	O
;	O
size_t	long
i	long
=	O
j	long
+	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
;	O
ssize_t	long
k	long
=	O
entries_mapping_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
(	O
&	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
,	O
i	long
)	O
;	O
ASSERT	O
(	O
k	long
>=	O
0	int
)	O
;	O
if	O
(	O
entry_equals	(*(void),*(void))->(bool)
(	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
,	O
mainstream_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
k	long
]	O
)	O
)	O
{	O
gl_list_node_set_value	(*(struct),*(struct),*(void))->(void)
(	O
result_entries	*(struct)
,	O
result_entries_pointers	*(*(struct))
[	O
k	long
]	O
,	O
changed_entry	*(struct(*(char),long,bool,long))
)	O
;	O
}	O
else	O
{	O
struct	O
conflict	struct(long,*(*(struct(*(char),long,bool,long))),long,*(*(struct(*(char),long,bool,long))))
*	O
c	long
;	O
ASSERT	O
(	O
!	O
entry_equals	(*(void),*(void))->(bool)
(	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
,	O
changed_entry	*(struct(*(char),long,bool,long))
)	O
)	O
;	O
c	long
=	O
XMALLOC	O
(	O
struct	O
conflict	struct(long,*(*(struct(*(char),long,bool,long))),long,*(*(struct(*(char),long,bool,long))))
)	O
;	O
c	long
->	O
num_old_entries	long
=	O
1	int
;	O
c	long
->	O
old_entries	*(*(struct(*(char),long,bool,long)))
=	O
XNMALLOC	O
(	O
c	long
->	O
num_old_entries	long
,	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
;	O
c	long
->	O
old_entries	*(*(struct(*(char),long,bool,long)))
[	O
0	int
]	O
=	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
;	O
c	long
->	O
num_modified_entries	long
=	O
1	int
;	O
c	long
->	O
modified_entries	*(*(struct(*(char),long,bool,long)))
=	O
XNMALLOC	O
(	O
c	long
->	O
num_modified_entries	long
,	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
;	O
c	long
->	O
modified_entries	*(*(struct(*(char),long,bool,long)))
[	O
0	int
]	O
=	O
changed_entry	*(struct(*(char),long,bool,long))
;	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
result_conflicts	*(struct)
,	O
c	long
)	O
;	O
}	O
}	O
done	bool
=	O
true	int
;	O
}	O
}	O
}	O
else	O
{	O
ssize_t	long
i_first	long
;	O
ssize_t	long
k_first	long
;	O
bool	bool
linear_unchanged	bool
;	O
i_first	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i1	long
;	O
k_first	long
=	O
entries_mapping_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
(	O
&	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
,	O
i_first	long
)	O
;	O
linear_unchanged	bool
=	O
(	O
k_first	long
>=	O
0	int
&&	O
entry_equals	(*(void),*(void))->(bool)
(	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i_first	long
]	O
,	O
mainstream_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
k_first	long
]	O
)	O
)	O
;	O
if	O
(	O
linear_unchanged	bool
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
i_first	long
+	O
1	int
;	O
i	long
<=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
;	O
i	long
++	O
)	O
if	O
(	O
!	O
(	O
entries_mapping_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
(	O
&	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
,	O
i	long
)	O
==	O
k_first	long
+	O
(	O
i	long
-	O
i_first	long
)	O
&&	O
entry_equals	(*(void),*(void))->(bool)
(	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
,	O
mainstream_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
entries_mapping_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
(	O
&	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
,	O
i	long
)	O
]	O
)	O
)	O
)	O
{	O
linear_unchanged	bool
=	O
false	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
linear_unchanged	bool
)	O
{	O
gl_list_node_t	*(struct)
node_for_insert	*(struct)
=	O
result_entries_pointers	*(*(struct))
[	O
k_first	long
]	O
;	O
ssize_t	long
j	long
;	O
size_t	long
i	long
;	O
for	O
(	O
j	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
;	O
j	long
>=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
;	O
j	long
--	O
)	O
{	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
new_entry	*(struct(*(char),long,bool,long))
=	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
]	O
;	O
gl_list_add_before	(*(struct),*(struct),*(void))->(*(struct))
(	O
result_entries	*(struct)
,	O
node_for_insert	*(struct)
,	O
new_entry	*(struct(*(char),long,bool,long))
)	O
;	O
}	O
for	O
(	O
i	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i1	long
;	O
i	long
<=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
;	O
i	long
++	O
)	O
{	O
ssize_t	long
k	long
=	O
entries_mapping_get	(*(struct(*(struct(*`,*`,long,*`)),*(struct(*`,*`,long,*`)),*(long),*(long))),long)->(long)
(	O
&	O
mapping	*(struct(*(struct(*(struct`),*(struct`),long,*(*`))),*(struct(*(struct`),*(struct`),long,*(*`))),*(long),*(long)))
,	O
i	long
)	O
;	O
ASSERT	O
(	O
k	long
>=	O
0	int
)	O
;	O
ASSERT	O
(	O
entry_equals	(*(void),*(void))->(bool)
(	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
,	O
mainstream_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
k	long
]	O
)	O
)	O
;	O
gl_list_node_set_value	(*(struct),*(struct),*(void))->(void)
(	O
result_entries	*(struct)
,	O
result_entries_pointers	*(*(struct))
[	O
k	long
]	O
,	O
&	O
empty_entry	struct(*(char),long,bool,long)
)	O
;	O
}	O
done	bool
=	O
true	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
done	bool
)	O
{	O
struct	O
conflict	struct(long,*(*(struct(*(char),long,bool,long))),long,*(*(struct(*(char),long,bool,long))))
*	O
c	long
=	O
XMALLOC	O
(	O
struct	O
conflict	struct(long,*(*(struct(*(char),long,bool,long))),long,*(*(struct(*(char),long,bool,long))))
)	O
;	O
size_t	long
i	long
,	O
j	long
;	O
c	long
->	O
num_old_entries	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i1	long
+	O
1	int
;	O
c	long
->	O
old_entries	*(*(struct(*(char),long,bool,long)))
=	O
XNMALLOC	O
(	O
c	long
->	O
num_old_entries	long
,	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
;	O
for	O
(	O
i	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i1	long
;	O
i	long
<=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i2	long
;	O
i	long
++	O
)	O
c	long
->	O
old_entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
i1	long
]	O
=	O
ancestor_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
i	long
]	O
;	O
c	long
->	O
num_modified_entries	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
+	O
1	int
;	O
c	long
->	O
modified_entries	*(*(struct(*(char),long,bool,long)))
=	O
XNMALLOC	O
(	O
c	long
->	O
num_modified_entries	long
,	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
;	O
for	O
(	O
j	long
=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
;	O
j	long
<=	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j2	long
;	O
j	long
++	O
)	O
c	long
->	O
modified_entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
-	O
edit	struct(enum(int,int,int),long,long,long,long)
->	O
j1	long
]	O
=	O
modified_file	struct(*(struct),*(struct),long,*(*(struct(*(char),long,bool,long))))
.	O
entries	*(*(struct(*(char),long,bool,long)))
[	O
j	long
]	O
;	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
result_conflicts	*(struct)
,	O
c	long
)	O
;	O
}	O
}	O
break	O
;	O
}	O
}	O
}	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
destination_file_name	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"could not write file '%s'\n"	*(char)
,	O
destination_file_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
{	O
size_t	long
n	long
=	O
gl_list_size	(*(struct))->(long)
(	O
result_conflicts	*(struct)
)	O
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
conflict_write	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(long,*(*(struct`)),long,*(*(struct`)))))->(void)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
struct	O
conflict	struct(long,*(*(struct(*(char),long,bool,long))),long,*(*(struct(*(char),long,bool,long))))
*	O
)	O
gl_list_get_at	(*(struct),long)->(*(void))
(	O
result_conflicts	*(struct)
,	O
i	long
)	O
)	O
;	O
}	O
{	O
gl_list_iterator_t	struct(*(struct),*(struct),long,*(void),*(void),long,long)
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
=	O
gl_list_iterator	(*(struct))->(struct(*(struct),*(struct),long,*(void),*(void),long,long))
(	O
result_entries	*(struct)
)	O
;	O
const	O
void	O
*	O
elt	*(void)
;	O
gl_list_node_t	*(struct)
node	*(struct)
;	O
while	O
(	O
gl_list_iterator_next	(*(struct(*(struct),*(struct),long,*(void),*(void),long,long)),*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
,	O
&	O
elt	*(void)
,	O
&	O
node	*(struct)
)	O
)	O
entry_write	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),long,bool,long)))->(void)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
struct	O
entry	struct(*(char),long,bool,long)
*	O
)	O
elt	*(void)
)	O
;	O
gl_list_iterator_free	(*(struct(*(struct),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
}	O
if	O
(	O
fwriteerror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"error writing to file '%s'\n"	*(char)
,	O
destination_file_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
exit	(int)->(void)
(	O
gl_list_size	(*(struct))->(long)
(	O
result_conflicts	*(struct)
)	O
>	O
0	int
?	O
EXIT_FAILURE	int
:	O
EXIT_SUCCESS	int
)	O
;	O
}	O
}	O
