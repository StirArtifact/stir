typedef	O
unsigned	O
char	O
Request	char
;	O
typedef	O
unsigned	O
short	O
Length	short
;	O
enum	O
tunnel_request	enum(int,int,int,int,int,int,int,int)
{	O
TUNNEL_SIMPLE	int
=	O
0x40	int
,	O
TUNNEL_OPEN	int
=	O
0x01	int
,	O
TUNNEL_DATA	int
=	O
0x02	int
,	O
TUNNEL_PADDING	int
=	O
0x03	int
,	O
TUNNEL_ERROR	int
=	O
0x04	int
,	O
TUNNEL_PAD1	int
=	O
TUNNEL_SIMPLE	int
|	O
0x05	int
,	O
TUNNEL_CLOSE	int
=	O
TUNNEL_SIMPLE	int
|	O
0x06	int
,	O
TUNNEL_DISCONNECT	int
=	O
TUNNEL_SIMPLE	int
|	O
0x07	int
}	O
;	O
static	O
inline	O
const	O
char	O
*	O
REQ_TO_STRING	(char)->(*(char))
(	O
Request	char
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
{	O
switch	O
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
{	O
case	O
TUNNEL_OPEN	int
:	O
return	O
"TUNNEL_OPEN"	*(char)
;	O
case	O
TUNNEL_DATA	int
:	O
return	O
"TUNNEL_DATA"	*(char)
;	O
case	O
TUNNEL_PADDING	int
:	O
return	O
"TUNNEL_PADDING"	*(char)
;	O
case	O
TUNNEL_ERROR	int
:	O
return	O
"TUNNEL_ERROR"	*(char)
;	O
case	O
TUNNEL_PAD1	int
:	O
return	O
"TUNNEL_PAD1"	*(char)
;	O
case	O
TUNNEL_CLOSE	int
:	O
return	O
"TUNNEL_CLOSE"	*(char)
;	O
case	O
TUNNEL_DISCONNECT	int
:	O
return	O
"TUNNEL_DISCONNECT"	*(char)
;	O
default	O
:	O
return	O
"(unknown)"	*(char)
;	O
}	O
}	O
struct	O
tunnel	*(struct)
{	O
int	O
in_fd	int
,	O
out_fd	int
;	O
int	O
server_socket	(struct(int),int,int)->(int)
;	O
Http_destination	struct(*(char),int,*(char),int,*(char),*(char))
dest	short
;	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
address	long
;	O
size_t	long
bytes	long
;	O
size_t	long
content_length	long
;	O
char	O
buf	*(char)
[	O
65536	int
]	O
;	O
char	O
*	O
buf_ptr	*(char)
;	O
size_t	long
buf_len	long
;	O
int	O
padding_only	int
;	O
size_t	long
in_total_raw	long
;	O
size_t	long
in_total_data	long
;	O
size_t	long
out_total_raw	long
;	O
size_t	long
out_total_data	long
;	O
time_t	long
out_connect_time	long
;	O
int	O
strict_content_length	int
;	O
int	O
keep_alive	int
;	O
int	O
max_connection_age	int
;	O
}	O
;	O
static	O
const	O
size_t	long
sizeof_header	long
=	O
sizeof	O
(	O
Request	char
)	O
+	O
sizeof	O
(	O
Length	short
)	O
;	O
static	O
inline	O
int	O
tunnel_is_disconnected	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
)	O
{	O
return	O
tunnel	*(struct)
->	O
out_fd	int
==	O
-	O
1	int
;	O
}	O
static	O
inline	O
int	O
tunnel_is_connected	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
)	O
{	O
return	O
!	O
tunnel_is_disconnected	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
;	O
}	O
static	O
inline	O
int	O
tunnel_is_server	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
)	O
{	O
return	O
tunnel	*(struct)
->	O
server_socket	(struct(int),int,int)->(int)
!=	O
-	O
1	int
;	O
}	O
static	O
inline	O
int	O
tunnel_is_client	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
)	O
{	O
return	O
!	O
tunnel_is_server	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
;	O
}	O
static	O
int	O
get_proto_number	(*(char))->(int)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
protoent	struct(*(char),*(*(char)),int)
*	O
p	*(struct(*(char),*(*(char)),int))
;	O
int	O
number	int
;	O
p	*(struct(*(char),*(*(char)),int))
=	O
getprotobyname	(*(char))->(*(struct(*(char),*(*(char)),int)))
(	O
name	*(char)
)	O
;	O
if	O
(	O
p	*(struct(*(char),*(*(char)),int))
==	O
NULL	O
)	O
number	int
=	O
-	O
1	int
;	O
else	O
number	int
=	O
p	*(struct(*(char),*(*(char)),int))
->	O
p_proto	int
;	O
endprotoent	()->(void)
(	O
)	O
;	O
return	O
number	int
;	O
}	O
static	O
int	O
tunnel_in_setsockopts	(int)->(int)
(	O
int	O
fd	int
)	O
{	O
int	O
tcp	int
=	O
get_proto_number	(*(char))->(int)
(	O
"tcp"	*(char)
)	O
;	O
if	O
(	O
tcp	int
!=	O
-	O
1	int
)	O
{	O
int	O
i	int
,	O
n	long
;	O
i	int
=	O
1	int
;	O
if	O
(	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
fd	int
,	O
tcp	int
,	O
SO_RCVLOWAT	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
sizeof	O
i	int
)	O
==	O
-	O
1	int
)	O
{	O
log_debug	()->(void)
(	O
"tunnel_in_setsockopts: non-fatal SO_RCVLOWAT error: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
n	long
=	O
sizeof	O
i	int
;	O
getsockopt	(int,int,int,*(void),*(int))->(int)
(	O
fd	int
,	O
tcp	int
,	O
SO_RCVLOWAT	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
&	O
n	long
)	O
;	O
log_debug	()->(void)
(	O
"tunnel_out_setsockopts: SO_RCVLOWAT: %d"	*(char)
,	O
i	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
tunnel_out_setsockopts	(int)->(int)
(	O
int	O
fd	int
)	O
{	O
{	O
int	O
tcp	int
=	O
get_proto_number	(*(char))->(int)
(	O
"tcp"	*(char)
)	O
;	O
int	O
i	int
,	O
n	long
;	O
if	O
(	O
tcp	int
!=	O
-	O
1	int
)	O
{	O
i	int
=	O
1	int
;	O
if	O
(	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
fd	int
,	O
tcp	int
,	O
SO_SNDLOWAT	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
sizeof	O
i	int
)	O
==	O
-	O
1	int
)	O
{	O
log_debug	()->(void)
(	O
"tunnel_out_setsockopts: "	*(char)
"non-fatal SO_SNDLOWAT error: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
n	long
=	O
sizeof	O
i	int
;	O
getsockopt	(int,int,int,*(void),*(int))->(int)
(	O
fd	int
,	O
tcp	int
,	O
SO_SNDLOWAT	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
&	O
n	long
)	O
;	O
log_debug	()->(void)
(	O
"tunnel_out_setsockopts: non-fatal SO_SNDLOWAT: %d"	*(char)
,	O
i	int
)	O
;	O
}	O
}	O
{	O
struct	O
linger	struct(int,int)
l	struct(int,int)
;	O
int	O
n	long
;	O
l	struct(int,int)
.	O
l_onoff	int
=	O
1	int
;	O
l	struct(int,int)
.	O
l_linger	int
=	O
20	int
*	O
100	int
;	O
if	O
(	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
fd	int
,	O
SOL_SOCKET	int
,	O
SO_LINGER	int
,	O
(	O
void	O
*	O
)	O
&	O
l	struct(int,int)
,	O
sizeof	O
l	struct(int,int)
)	O
==	O
-	O
1	int
)	O
{	O
log_debug	()->(void)
(	O
"tunnel_out_setsockopts: non-fatal SO_LINGER error: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
n	long
=	O
sizeof	O
l	struct(int,int)
;	O
getsockopt	(int,int,int,*(void),*(int))->(int)
(	O
fd	int
,	O
SOL_SOCKET	int
,	O
SO_LINGER	int
,	O
(	O
void	O
*	O
)	O
&	O
l	struct(int,int)
,	O
&	O
n	long
)	O
;	O
log_debug	()->(void)
(	O
"tunnel_out_setsockopts: SO_LINGER: onoff=%d linger=%d"	*(char)
,	O
l	struct(int,int)
.	O
l_onoff	int
,	O
l	struct(int,int)
.	O
l_linger	int
)	O
;	O
}	O
{	O
int	O
tcp	int
=	O
get_proto_number	(*(char))->(int)
(	O
"tcp"	*(char)
)	O
;	O
int	O
i	int
,	O
n	long
;	O
if	O
(	O
tcp	int
!=	O
-	O
1	int
)	O
{	O
i	int
=	O
1	int
;	O
if	O
(	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
fd	int
,	O
tcp	int
,	O
TCP_NODELAY	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
sizeof	O
i	int
)	O
==	O
-	O
1	int
)	O
{	O
log_debug	()->(void)
(	O
"tunnel_out_setsockopts: "	*(char)
"non-fatal TCP_NODELAY error: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
n	long
=	O
sizeof	O
i	int
;	O
getsockopt	(int,int,int,*(void),*(int))->(int)
(	O
fd	int
,	O
tcp	int
,	O
TCP_NODELAY	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
&	O
n	long
)	O
;	O
log_debug	()->(void)
(	O
"tunnel_out_setsockopts: non-fatal TCP_NODELAY: %d"	*(char)
,	O
i	int
)	O
;	O
}	O
}	O
{	O
int	O
i	int
,	O
n	long
;	O
i	int
=	O
1	int
;	O
if	O
(	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
fd	int
,	O
SOL_SOCKET	int
,	O
SO_KEEPALIVE	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
sizeof	O
i	int
)	O
==	O
-	O
1	int
)	O
{	O
log_debug	()->(void)
(	O
"tunnel_out_setsockopts: non-fatal SO_KEEPALIVE error: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
n	long
=	O
sizeof	O
i	int
;	O
getsockopt	(int,int,int,*(void),*(int))->(int)
(	O
fd	int
,	O
SOL_SOCKET	int
,	O
SO_KEEPALIVE	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
&	O
n	long
)	O
;	O
log_debug	()->(void)
(	O
"tunnel_out_setsockopts: SO_KEEPALIVE: %d"	*(char)
,	O
i	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
tunnel_out_disconnect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(void)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
)	O
{	O
if	O
(	O
tunnel_is_disconnected	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
)	O
return	O
;	O
close	(int)->(int)
(	O
tunnel	*(struct)
->	O
out_fd	int
)	O
;	O
tunnel	*(struct)
->	O
out_fd	int
=	O
-	O
1	int
;	O
tunnel	*(struct)
->	O
bytes	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
buf_ptr	*(char)
=	O
tunnel	*(struct)
->	O
buf	*(char)
;	O
tunnel	*(struct)
->	O
buf_len	long
=	O
0	int
;	O
log_debug	()->(void)
(	O
"tunnel_out_disconnect: output disconnected"	*(char)
)	O
;	O
}	O
static	O
void	O
tunnel_in_disconnect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(void)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
)	O
{	O
if	O
(	O
tunnel	*(struct)
->	O
in_fd	int
==	O
-	O
1	int
)	O
return	O
;	O
close	(int)->(int)
(	O
tunnel	*(struct)
->	O
in_fd	int
)	O
;	O
tunnel	*(struct)
->	O
in_fd	int
=	O
-	O
1	int
;	O
log_debug	()->(void)
(	O
"tunnel_in_disconnect: input disconnected"	*(char)
)	O
;	O
}	O
static	O
int	O
tunnel_out_connect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
)	O
{	O
ssize_t	long
n	long
;	O
if	O
(	O
tunnel_is_connected	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
)	O
{	O
log_debug	()->(void)
(	O
"tunnel_out_connect: already connected"	*(char)
)	O
;	O
tunnel_out_disconnect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(void)
(	O
tunnel	*(struct)
)	O
;	O
}	O
tunnel	*(struct)
->	O
out_fd	int
=	O
do_connect	(*(struct(short,short,struct(int),array(char))))->(int)
(	O
&	O
tunnel	*(struct)
->	O
address	long
)	O
;	O
if	O
(	O
tunnel	*(struct)
->	O
out_fd	int
==	O
-	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_out_connect: do_connect (%d.%d.%d.%d:%u) error: %s"	*(char)
,	O
ntohl	(int)->(int)
(	O
tunnel	*(struct)
->	O
address	long
.	O
sin_addr	struct(int)
.	O
s_addr	int
)	O
>>	O
24	int
,	O
(	O
ntohl	(int)->(int)
(	O
tunnel	*(struct)
->	O
address	long
.	O
sin_addr	struct(int)
.	O
s_addr	int
)	O
>>	O
16	int
)	O
&	O
0xff	int
,	O
(	O
ntohl	(int)->(int)
(	O
tunnel	*(struct)
->	O
address	long
.	O
sin_addr	struct(int)
.	O
s_addr	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
,	O
ntohl	(int)->(int)
(	O
tunnel	*(struct)
->	O
address	long
.	O
sin_addr	struct(int)
.	O
s_addr	int
)	O
&	O
0xff	int
,	O
ntohs	(short)->(short)
(	O
tunnel	*(struct)
->	O
address	long
.	O
sin_port	short
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
tunnel_out_setsockopts	(int)->(int)
(	O
tunnel	*(struct)
->	O
out_fd	int
)	O
;	O
n	long
=	O
http_post	(int,*(struct(*(char),int,*(char),int,*(char),*(char))),long)->(long)
(	O
tunnel	*(struct)
->	O
out_fd	int
,	O
&	O
tunnel	*(struct)
->	O
dest	short
,	O
tunnel	*(struct)
->	O
content_length	long
+	O
1	int
)	O
;	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
tunnel	*(struct)
->	O
bytes	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
buf_ptr	*(char)
=	O
tunnel	*(struct)
->	O
buf	*(char)
;	O
tunnel	*(struct)
->	O
buf_len	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
padding_only	int
=	O
TRUE	int
;	O
time	(*(long))->(long)
(	O
&	O
tunnel	*(struct)
->	O
out_connect_time	long
)	O
;	O
log_debug	()->(void)
(	O
"tunnel_out_connect: output connected"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
tunnel_in_connect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
)	O
{	O
Http_response	struct(int,int,int,*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
;	O
ssize_t	long
n	long
;	O
log_verbose	()->(void)
(	O
"tunnel_in_connect()"	*(char)
)	O
;	O
if	O
(	O
tunnel	*(struct)
->	O
in_fd	int
!=	O
-	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_in_connect: already connected"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
tunnel	*(struct)
->	O
in_fd	int
=	O
do_connect	(*(struct(short,short,struct(int),array(char))))->(int)
(	O
&	O
tunnel	*(struct)
->	O
address	long
)	O
;	O
if	O
(	O
tunnel	*(struct)
->	O
in_fd	int
==	O
-	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_in_connect: do_connect() error: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
tunnel_in_setsockopts	(int)->(int)
(	O
tunnel	*(struct)
->	O
in_fd	int
)	O
;	O
if	O
(	O
http_get	(int,*(struct(*(char),int,*(char),int,*(char),*(char))))->(long)
(	O
tunnel	*(struct)
->	O
in_fd	int
,	O
&	O
tunnel	*(struct)
->	O
dest	short
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
n	long
=	O
http_parse_response	(int,*(*(struct(int,int,int,*(char),*(struct`)))))->(long)
(	O
tunnel	*(struct)
->	O
in_fd	int
,	O
&	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
if	O
(	O
n	long
==	O
0	int
)	O
log_error	(*(char))->(void)
(	O
"tunnel_in_connect: no response; peer "	*(char)
"closed connection"	*(char)
)	O
;	O
else	O
log_error	(*(char))->(void)
(	O
"tunnel_in_connect: no response; error: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
major_version	int
!=	O
1	int
||	O
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
minor_version	int
!=	O
1	int
&&	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
minor_version	int
!=	O
0	int
)	O
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_in_connect: unknown HTTP version: %d.%d"	*(char)
,	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
major_version	int
,	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
minor_version	int
)	O
;	O
n	long
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
status_code	int
!=	O
200	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_in_connect: HTTP error %d"	*(char)
,	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
status_code	int
)	O
;	O
errno	O
=	O
http_error_to_errno	(int)->(int)
(	O
-	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
status_code	int
)	O
;	O
n	long
=	O
-	O
1	int
;	O
}	O
if	O
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
http_destroy_response	(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))->(void)
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
;	O
if	O
(	O
n	long
>	O
0	int
)	O
{	O
}	O
else	O
{	O
return	O
n	long
;	O
}	O
log_debug	()->(void)
(	O
"tunnel_in_connect: input connected"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
static	O
inline	O
ssize_t	long
tunnel_write_data	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(void),long)->(long)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
,	O
void	O
*	O
data	*(void)
,	O
size_t	long
length	int
)	O
{	O
if	O
(	O
write_all	(int,*(void),long)->(long)
(	O
tunnel	*(struct)
->	O
out_fd	int
,	O
data	*(void)
,	O
length	int
)	O
==	O
-	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_write_data: write error: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
tunnel	*(struct)
->	O
bytes	long
+=	O
length	int
;	O
return	O
length	int
;	O
}	O
static	O
int	O
tunnel_write_request	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),char,*(void),short)->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
,	O
Request	char
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
,	O
void	O
*	O
data	*(void)
,	O
Length	short
length	int
)	O
{	O
if	O
(	O
tunnel	*(struct)
->	O
bytes	long
+	O
sizeof	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
+	O
(	O
data	*(void)
?	O
sizeof	O
length	int
+	O
length	int
:	O
0	int
)	O
>	O
tunnel	*(struct)
->	O
content_length	long
)	O
tunnel_padding	(*(struct),long)->(long)
(	O
tunnel	*(struct)
,	O
tunnel	*(struct)
->	O
content_length	long
-	O
tunnel	*(struct)
->	O
bytes	long
)	O
;	O
{	O
time_t	long
t	long
;	O
time	(*(long))->(long)
(	O
&	O
t	long
)	O
;	O
if	O
(	O
tunnel_is_client	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
&&	O
tunnel_is_connected	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
&&	O
t	long
-	O
tunnel	*(struct)
->	O
out_connect_time	long
>	O
tunnel	*(struct)
->	O
max_connection_age	int
)	O
{	O
char	O
c	char
=	O
TUNNEL_DISCONNECT	int
;	O
log_debug	()->(void)
(	O
"tunnel_write_request: connection > %d seconds old"	*(char)
,	O
tunnel	*(struct)
->	O
max_connection_age	int
)	O
;	O
if	O
(	O
tunnel	*(struct)
->	O
strict_content_length	int
)	O
{	O
int	O
l	struct(int,int)
=	O
tunnel	*(struct)
->	O
content_length	long
-	O
tunnel	*(struct)
->	O
bytes	long
-	O
1	int
;	O
log_debug	()->(void)
(	O
"tunnel_write_request: write padding (%d bytes)"	*(char)
,	O
tunnel	*(struct)
->	O
content_length	long
-	O
tunnel	*(struct)
->	O
bytes	long
-	O
1	int
)	O
;	O
if	O
(	O
l	struct(int,int)
>	O
3	int
)	O
{	O
char	O
c	char
;	O
short	O
s	short
;	O
int	O
i	int
;	O
c	char
=	O
TUNNEL_PADDING	int
;	O
tunnel_write_data	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(void),long)->(long)
(	O
tunnel	*(struct)
,	O
&	O
c	char
,	O
sizeof	O
c	char
)	O
;	O
s	short
=	O
htons	(short)->(short)
(	O
l	struct(int,int)
-	O
2	int
)	O
;	O
tunnel_write_data	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(void),long)->(long)
(	O
tunnel	*(struct)
,	O
&	O
s	short
,	O
sizeof	O
s	short
)	O
;	O
l	struct(int,int)
-=	O
2	int
;	O
c	char
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
l	struct(int,int)
;	O
i	int
++	O
)	O
tunnel_write_data	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(void),long)->(long)
(	O
tunnel	*(struct)
,	O
&	O
c	char
,	O
sizeof	O
c	char
)	O
;	O
}	O
else	O
{	O
char	O
c	char
=	O
TUNNEL_PAD1	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
l	struct(int,int)
;	O
i	int
++	O
)	O
tunnel_write_data	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(void),long)->(long)
(	O
tunnel	*(struct)
,	O
&	O
c	char
,	O
sizeof	O
c	char
)	O
;	O
}	O
}	O
log_debug	()->(void)
(	O
"tunnel_write_request: closing old connection"	*(char)
)	O
;	O
if	O
(	O
tunnel_write_data	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(void),long)->(long)
(	O
tunnel	*(struct)
,	O
&	O
c	char
,	O
sizeof	O
c	char
)	O
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
tunnel_out_disconnect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(void)
(	O
tunnel	*(struct)
)	O
;	O
}	O
}	O
if	O
(	O
tunnel_is_disconnected	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
)	O
{	O
if	O
(	O
tunnel_is_client	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
)	O
{	O
if	O
(	O
tunnel_out_connect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
tunnel_accept	(*(struct))->(int)
(	O
tunnel	*(struct)
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
!=	O
TUNNEL_PADDING	int
&&	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
!=	O
TUNNEL_PAD1	int
)	O
tunnel	*(struct)
->	O
padding_only	int
=	O
FALSE	int
;	O
if	O
(	O
tunnel_write_data	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(void),long)->(long)
(	O
tunnel	*(struct)
,	O
&	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
,	O
sizeof	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EPIPE	int
)	O
return	O
-	O
1	int
;	O
tunnel_out_disconnect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(void)
(	O
tunnel	*(struct)
)	O
;	O
if	O
(	O
tunnel_is_client	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
)	O
tunnel_out_connect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
;	O
else	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_write_request: couldn't write request: "	*(char)
"output is disconnected"	*(char)
)	O
;	O
errno	O
=	O
EIO	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
tunnel_write_data	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(void),long)->(long)
(	O
tunnel	*(struct)
,	O
&	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
,	O
sizeof	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
data	*(void)
)	O
{	O
Length	short
network_length	short
=	O
htons	(short)->(short)
(	O
(	O
short	O
)	O
length	int
)	O
;	O
if	O
(	O
tunnel_write_data	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(void),long)->(long)
(	O
tunnel	*(struct)
,	O
&	O
network_length	short
,	O
sizeof	O
network_length	short
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
tunnel_write_data	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(void),long)->(long)
(	O
tunnel	*(struct)
,	O
data	*(void)
,	O
(	O
size_t	long
)	O
length	int
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
data	*(void)
)	O
{	O
tunnel	*(struct)
->	O
out_total_raw	long
+=	O
3	int
+	O
length	int
;	O
if	O
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
==	O
TUNNEL_DATA	int
)	O
log_verbose	()->(void)
(	O
"tunnel_write_request: %s (%d)"	*(char)
,	O
REQ_TO_STRING	(char)->(*(char))
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
,	O
length	int
)	O
;	O
else	O
log_debug	()->(void)
(	O
"tunnel_write_request: %s (%d)"	*(char)
,	O
REQ_TO_STRING	(char)->(*(char))
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
,	O
length	int
)	O
;	O
}	O
else	O
{	O
tunnel	*(struct)
->	O
out_total_raw	long
+=	O
1	int
;	O
log_debug	()->(void)
(	O
"tunnel_write_request: %s"	*(char)
,	O
REQ_TO_STRING	(char)->(*(char))
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
)	O
;	O
}	O
log_annoying	()->(void)
(	O
"tunnel_write_data: out_total_raw = %u"	*(char)
,	O
tunnel	*(struct)
->	O
out_total_raw	long
)	O
;	O
if	O
(	O
tunnel	*(struct)
->	O
bytes	long
>=	O
tunnel	*(struct)
->	O
content_length	long
)	O
{	O
char	O
c	char
=	O
TUNNEL_DISCONNECT	int
;	O
tunnel_write_data	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(void),long)->(long)
(	O
tunnel	*(struct)
,	O
&	O
c	char
,	O
sizeof	O
c	char
)	O
;	O
tunnel_out_disconnect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(void)
(	O
tunnel	*(struct)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
tunnel_connect	(*(struct))->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
)	O
{	O
char	O
auth_data	array(char)
[	O
1	int
]	O
=	O
{	O
42	int
}	O
;	O
log_verbose	()->(void)
(	O
"tunnel_connect()"	*(char)
)	O
;	O
if	O
(	O
tunnel_is_connected	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_connect: already connected"	*(char)
)	O
;	O
errno	O
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
tunnel_write_request	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),char,*(void),short)->(int)
(	O
tunnel	*(struct)
,	O
TUNNEL_OPEN	int
,	O
auth_data	array(char)
,	O
sizeof	O
auth_data	array(char)
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
tunnel_in_connect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
inline	O
int	O
tunnel_write_or_padding	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),char,*(void),long)->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
,	O
Request	char
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
,	O
void	O
*	O
data	*(void)
,	O
size_t	long
length	int
)	O
{	O
static	O
char	O
padding	array(char)
[	O
65536	int
]	O
;	O
size_t	long
n	long
,	O
remaining	long
;	O
char	O
*	O
wdata	*(char)
=	O
data	*(void)
;	O
for	O
(	O
remaining	long
=	O
length	int
;	O
remaining	long
>	O
0	int
;	O
remaining	long
-=	O
n	long
,	O
wdata	*(char)
+=	O
n	long
)	O
{	O
if	O
(	O
tunnel	*(struct)
->	O
bytes	long
+	O
remaining	long
>	O
tunnel	*(struct)
->	O
content_length	long
-	O
sizeof_header	long
&&	O
tunnel	*(struct)
->	O
content_length	long
-	O
tunnel	*(struct)
->	O
bytes	long
>	O
sizeof_header	long
)	O
n	long
=	O
tunnel	*(struct)
->	O
content_length	long
-	O
sizeof_header	long
-	O
tunnel	*(struct)
->	O
bytes	long
;	O
else	O
if	O
(	O
remaining	long
>	O
tunnel	*(struct)
->	O
content_length	long
-	O
sizeof_header	long
)	O
n	long
=	O
tunnel	*(struct)
->	O
content_length	long
-	O
sizeof_header	long
;	O
else	O
n	long
=	O
remaining	long
;	O
if	O
(	O
n	long
>	O
65535	int
)	O
n	long
=	O
65535	int
;	O
if	O
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
==	O
TUNNEL_PADDING	int
)	O
{	O
if	O
(	O
n	long
+	O
sizeof_header	long
>	O
remaining	long
)	O
n	long
=	O
remaining	long
-	O
sizeof_header	long
;	O
if	O
(	O
tunnel_write_request	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),char,*(void),short)->(int)
(	O
tunnel	*(struct)
,	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
,	O
padding	array(char)
,	O
n	long
)	O
==	O
-	O
1	int
)	O
break	O
;	O
n	long
+=	O
sizeof_header	long
;	O
}	O
else	O
{	O
if	O
(	O
tunnel_write_request	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),char,*(void),short)->(int)
(	O
tunnel	*(struct)
,	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
,	O
wdata	*(char)
,	O
n	long
)	O
==	O
-	O
1	int
)	O
break	O
;	O
}	O
}	O
return	O
length	int
-	O
remaining	long
;	O
}	O
ssize_t	long
tunnel_write	(*(struct),*(void),long)->(long)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
,	O
void	O
*	O
data	*(void)
,	O
size_t	long
length	int
)	O
{	O
ssize_t	long
n	long
;	O
n	long
=	O
tunnel_write_or_padding	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),char,*(void),long)->(int)
(	O
tunnel	*(struct)
,	O
TUNNEL_DATA	int
,	O
data	*(void)
,	O
length	int
)	O
;	O
tunnel	*(struct)
->	O
out_total_data	long
+=	O
length	int
;	O
log_verbose	()->(void)
(	O
"tunnel_write: out_total_data = %u"	*(char)
,	O
tunnel	*(struct)
->	O
out_total_data	long
)	O
;	O
return	O
n	long
;	O
}	O
ssize_t	long
tunnel_padding	(*(struct),long)->(long)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
,	O
size_t	long
length	int
)	O
{	O
if	O
(	O
length	int
<	O
sizeof_header	long
+	O
1	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
tunnel_write_request	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),char,*(void),short)->(int)
(	O
tunnel	*(struct)
,	O
TUNNEL_PAD1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
return	O
length	int
;	O
}	O
return	O
tunnel_write_or_padding	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),char,*(void),long)->(int)
(	O
tunnel	*(struct)
,	O
TUNNEL_PADDING	int
,	O
NULL	O
,	O
length	int
)	O
;	O
}	O
int	O
tunnel_close	(*(struct))->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
)	O
{	O
struct	O
pollfd	struct(int,short,short)
p	*(struct(*(char),*(*(char)),int))
;	O
char	O
buf	*(char)
[	O
10240	int
]	O
;	O
ssize_t	long
n	long
;	O
if	O
(	O
tunnel	*(struct)
->	O
strict_content_length	int
)	O
{	O
log_debug	()->(void)
(	O
"tunnel_close: write padding (%d bytes)"	*(char)
,	O
tunnel	*(struct)
->	O
content_length	long
-	O
tunnel	*(struct)
->	O
bytes	long
-	O
1	int
)	O
;	O
tunnel_padding	(*(struct),long)->(long)
(	O
tunnel	*(struct)
,	O
tunnel	*(struct)
->	O
content_length	long
-	O
tunnel	*(struct)
->	O
bytes	long
-	O
1	int
)	O
;	O
}	O
log_debug	()->(void)
(	O
"tunnel_close: write TUNNEL_CLOSE request"	*(char)
)	O
;	O
tunnel_write_request	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),char,*(void),short)->(int)
(	O
tunnel	*(struct)
,	O
TUNNEL_CLOSE	int
,	O
NULL	O
,	O
0	int
)	O
;	O
tunnel_out_disconnect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(void)
(	O
tunnel	*(struct)
)	O
;	O
log_debug	()->(void)
(	O
"tunnel_close: reading trailing data from input ..."	*(char)
)	O
;	O
p	*(struct(*(char),*(*(char)),int))
.	O
fd	int
=	O
tunnel	*(struct)
->	O
in_fd	int
;	O
p	*(struct(*(char),*(*(char)),int))
.	O
events	short
=	O
POLLIN	int
;	O
while	O
(	O
poll	(*(struct(int,short,short)),long,int)->(int)
(	O
&	O
p	*(struct(*(char),*(*(char)),int))
,	O
1	int
,	O
READ_TRAIL_TIMEOUT	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
p	*(struct(*(char),*(*(char)),int))
.	O
revents	short
&	O
POLLIN	int
)	O
{	O
n	long
=	O
read	(int,*(void),long)->(long)
(	O
tunnel	*(struct)
->	O
in_fd	int
,	O
buf	*(char)
,	O
sizeof	O
buf	*(char)
)	O
;	O
if	O
(	O
n	long
>	O
0	int
)	O
{	O
log_annoying	()->(void)
(	O
"read (%d, %p, %d) = %d"	*(char)
,	O
tunnel	*(struct)
->	O
in_fd	int
,	O
buf	*(char)
,	O
sizeof	O
buf	*(char)
,	O
n	long
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
n	long
==	O
-	O
1	int
&&	O
errno	O
==	O
EAGAIN	int
)	O
continue	O
;	O
else	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
log_debug	()->(void)
(	O
"tunnel_close: ... error: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
else	O
log_debug	()->(void)
(	O
"tunnel_close: ... done (tunnel closed)"	*(char)
)	O
;	O
}	O
if	O
(	O
p	*(struct(*(char),*(*(char)),int))
.	O
revents	short
&	O
POLLHUP	int
)	O
log_debug	()->(void)
(	O
"POLLHUP"	*(char)
)	O
;	O
if	O
(	O
p	*(struct(*(char),*(*(char)),int))
.	O
revents	short
&	O
POLLERR	int
)	O
log_debug	()->(void)
(	O
"POLLERR"	*(char)
)	O
;	O
if	O
(	O
p	*(struct(*(char),*(*(char)),int))
.	O
revents	short
&	O
POLLNVAL	int
)	O
log_debug	()->(void)
(	O
"POLLNVAL"	*(char)
)	O
;	O
break	O
;	O
}	O
tunnel_in_disconnect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(void)
(	O
tunnel	*(struct)
)	O
;	O
tunnel	*(struct)
->	O
buf_len	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
in_total_raw	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
in_total_data	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
out_total_raw	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
out_total_data	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
tunnel_read_request	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(enum(int,int,int,int,int,int,int,int)),*(char),*(long))->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
,	O
enum	O
tunnel_request	enum(int,int,int,int,int,int,int,int)
*	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
,	O
unsigned	O
char	O
*	O
buf	*(char)
,	O
size_t	long
*	O
length	int
)	O
{	O
Request	char
req	char
;	O
Length	short
len	long
;	O
ssize_t	long
n	long
;	O
log_annoying	()->(void)
(	O
"read (%d, %p, %d) ..."	*(char)
,	O
tunnel	*(struct)
->	O
in_fd	int
,	O
&	O
req	char
,	O
1	int
)	O
;	O
n	long
=	O
read	(int,*(void),long)->(long)
(	O
tunnel	*(struct)
->	O
in_fd	int
,	O
&	O
req	char
,	O
1	int
)	O
;	O
log_annoying	()->(void)
(	O
"... = %d"	*(char)
,	O
n	long
)	O
;	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EAGAIN	int
)	O
log_error	(*(char))->(void)
(	O
"tunnel_read_request: error reading request: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
n	long
;	O
}	O
else	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
log_debug	()->(void)
(	O
"tunnel_read_request: connection closed by peer"	*(char)
)	O
;	O
tunnel_in_disconnect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(void)
(	O
tunnel	*(struct)
)	O
;	O
if	O
(	O
tunnel_is_client	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
&&	O
tunnel_in_connect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
errno	O
=	O
EAGAIN	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
=	O
req	char
;	O
tunnel	*(struct)
->	O
in_total_raw	long
+=	O
n	long
;	O
log_annoying	()->(void)
(	O
"request = 0x%x (%s)"	*(char)
,	O
req	char
,	O
REQ_TO_STRING	(char)->(*(char))
(	O
req	char
)	O
)	O
;	O
if	O
(	O
req	char
&	O
TUNNEL_SIMPLE	int
)	O
{	O
log_annoying	()->(void)
(	O
"tunnel_read_request: in_total_raw = %u"	*(char)
,	O
tunnel	*(struct)
->	O
in_total_raw	long
)	O
;	O
log_debug	()->(void)
(	O
"tunnel_read_request:  %s"	*(char)
,	O
REQ_TO_STRING	(char)->(*(char))
(	O
req	char
)	O
)	O
;	O
*	O
length	int
=	O
0	int
;	O
return	O
1	int
;	O
}	O
n	long
=	O
read_all	(int,*(void),long)->(long)
(	O
tunnel	*(struct)
->	O
in_fd	int
,	O
&	O
len	long
,	O
2	int
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_read_request: error reading request length: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
n	long
==	O
0	int
)	O
errno	O
=	O
EIO	int
;	O
return	O
-	O
1	int
;	O
}	O
len	long
=	O
ntohs	(short)->(short)
(	O
len	long
)	O
;	O
*	O
length	int
=	O
len	long
;	O
tunnel	*(struct)
->	O
in_total_raw	long
+=	O
n	long
;	O
log_annoying	()->(void)
(	O
"length = %d"	*(char)
,	O
len	long
)	O
;	O
if	O
(	O
len	long
>	O
0	int
)	O
{	O
n	long
=	O
read_all	(int,*(void),long)->(long)
(	O
tunnel	*(struct)
->	O
in_fd	int
,	O
buf	*(char)
,	O
(	O
size_t	long
)	O
len	long
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_read_request: error reading request data: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
n	long
==	O
0	int
)	O
errno	O
=	O
EIO	int
;	O
return	O
-	O
1	int
;	O
}	O
tunnel	*(struct)
->	O
in_total_raw	long
+=	O
n	long
;	O
log_annoying	()->(void)
(	O
"tunnel_read_request: in_total_raw = %u"	*(char)
,	O
tunnel	*(struct)
->	O
in_total_raw	long
)	O
;	O
}	O
if	O
(	O
req	char
==	O
TUNNEL_DATA	int
)	O
log_verbose	()->(void)
(	O
"tunnel_read_request:  %s (%d)"	*(char)
,	O
REQ_TO_STRING	(char)->(*(char))
(	O
req	char
)	O
,	O
len	long
)	O
;	O
else	O
log_debug	()->(void)
(	O
"tunnel_read_request:  %s (%d)"	*(char)
,	O
REQ_TO_STRING	(char)->(*(char))
(	O
req	char
)	O
,	O
len	long
)	O
;	O
return	O
1	int
;	O
}	O
ssize_t	long
tunnel_read	(*(struct),*(void),long)->(long)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
,	O
void	O
*	O
data	*(void)
,	O
size_t	long
length	int
)	O
{	O
enum	O
tunnel_request	enum(int,int,int,int,int,int,int,int)
req	char
;	O
size_t	long
len	long
;	O
ssize_t	long
n	long
;	O
if	O
(	O
tunnel	*(struct)
->	O
buf_len	long
>	O
0	int
)	O
{	O
n	long
=	O
min	O
(	O
tunnel	*(struct)
->	O
buf_len	long
,	O
length	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
data	*(void)
,	O
tunnel	*(struct)
->	O
buf_ptr	*(char)
,	O
n	long
)	O
;	O
tunnel	*(struct)
->	O
buf_ptr	*(char)
+=	O
n	long
;	O
tunnel	*(struct)
->	O
buf_len	long
-=	O
n	long
;	O
return	O
n	long
;	O
}	O
if	O
(	O
tunnel	*(struct)
->	O
in_fd	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
tunnel_is_client	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
)	O
{	O
if	O
(	O
tunnel_in_connect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
tunnel_accept	(*(struct))->(int)
(	O
tunnel	*(struct)
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
errno	O
=	O
EAGAIN	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
tunnel	*(struct)
->	O
out_fd	int
==	O
-	O
1	int
&&	O
tunnel_is_server	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
)	O
{	O
tunnel_accept	(*(struct))->(int)
(	O
tunnel	*(struct)
)	O
;	O
errno	O
=	O
EAGAIN	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
tunnel_read_request	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(enum(int,int,int,int,int,int,int,int)),*(char),*(long))->(int)
(	O
tunnel	*(struct)
,	O
&	O
req	char
,	O
tunnel	*(struct)
->	O
buf	*(char)
,	O
&	O
len	long
)	O
<=	O
0	int
)	O
{	O
log_annoying	()->(void)
(	O
"tunnel_read_request returned <= 0, returning -1"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
req	char
)	O
{	O
case	O
TUNNEL_OPEN	int
:	O
break	O
;	O
case	O
TUNNEL_DATA	int
:	O
tunnel	*(struct)
->	O
buf_ptr	*(char)
=	O
tunnel	*(struct)
->	O
buf	*(char)
;	O
tunnel	*(struct)
->	O
buf_len	long
=	O
len	long
;	O
tunnel	*(struct)
->	O
in_total_data	long
+=	O
len	long
;	O
log_verbose	()->(void)
(	O
"tunnel_read: in_total_data = %u"	*(char)
,	O
tunnel	*(struct)
->	O
in_total_data	long
)	O
;	O
return	O
tunnel_read	(*(struct),*(void),long)->(long)
(	O
tunnel	*(struct)
,	O
data	*(void)
,	O
length	int
)	O
;	O
case	O
TUNNEL_PADDING	int
:	O
break	O
;	O
case	O
TUNNEL_PAD1	int
:	O
break	O
;	O
case	O
TUNNEL_ERROR	int
:	O
tunnel	*(struct)
->	O
buf	*(char)
[	O
len	long
]	O
=	O
0	int
;	O
log_error	(*(char))->(void)
(	O
"tunnel_read: received error: %s"	*(char)
,	O
tunnel	*(struct)
->	O
buf	*(char)
)	O
;	O
errno	O
=	O
EIO	int
;	O
return	O
-	O
1	int
;	O
case	O
TUNNEL_CLOSE	int
:	O
return	O
0	int
;	O
case	O
TUNNEL_DISCONNECT	int
:	O
tunnel_in_disconnect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(void)
(	O
tunnel	*(struct)
)	O
;	O
if	O
(	O
tunnel_is_client	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
&&	O
tunnel_in_connect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
errno	O
=	O
EAGAIN	int
;	O
return	O
-	O
1	int
;	O
default	O
:	O
log_error	(*(char))->(void)
(	O
"tunnel_read: protocol error: unknown request 0x%02x"	*(char)
,	O
req	char
)	O
;	O
errno	O
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
errno	O
=	O
EAGAIN	int
;	O
return	O
-	O
1	int
;	O
}	O
int	O
tunnel_pollin_fd	(*(struct))->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
)	O
{	O
if	O
(	O
tunnel_is_server	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
&&	O
(	O
tunnel	*(struct)
->	O
in_fd	int
==	O
-	O
1	int
||	O
tunnel	*(struct)
->	O
out_fd	int
==	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
tunnel	*(struct)
->	O
in_fd	int
==	O
-	O
1	int
)	O
log_verbose	()->(void)
(	O
"tunnel_pollin_fd: in_fd = -1; returning server_socket = %d"	*(char)
,	O
tunnel	*(struct)
->	O
server_socket	(struct(int),int,int)->(int)
)	O
;	O
else	O
log_verbose	()->(void)
(	O
"tunnel_pollin_fd: out_fd = -1; returning server_socket = %d"	*(char)
,	O
tunnel	*(struct)
->	O
server_socket	(struct(int),int,int)->(int)
)	O
;	O
return	O
tunnel	*(struct)
->	O
server_socket	(struct(int),int,int)->(int)
;	O
}	O
else	O
if	O
(	O
tunnel	*(struct)
->	O
in_fd	int
!=	O
-	O
1	int
)	O
return	O
tunnel	*(struct)
->	O
in_fd	int
;	O
else	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_pollin_fd: returning -1"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
int	O
tunnel_maybe_pad	(*(struct),long)->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
,	O
size_t	long
length	int
)	O
{	O
size_t	long
padding	array(char)
;	O
if	O
(	O
tunnel_is_disconnected	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
||	O
tunnel	*(struct)
->	O
bytes	long
%	O
length	int
==	O
0	int
||	O
tunnel	*(struct)
->	O
padding_only	int
)	O
return	O
0	int
;	O
padding	array(char)
=	O
length	int
-	O
tunnel	*(struct)
->	O
bytes	long
%	O
length	int
;	O
if	O
(	O
padding	array(char)
>	O
tunnel	*(struct)
->	O
content_length	long
-	O
tunnel	*(struct)
->	O
bytes	long
)	O
padding	array(char)
=	O
tunnel	*(struct)
->	O
content_length	long
-	O
tunnel	*(struct)
->	O
bytes	long
;	O
return	O
tunnel_padding	(*(struct),long)->(long)
(	O
tunnel	*(struct)
,	O
padding	array(char)
)	O
;	O
}	O
int	O
tunnel_accept	(*(struct))->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
)	O
{	O
if	O
(	O
tunnel	*(struct)
->	O
in_fd	int
!=	O
-	O
1	int
&&	O
tunnel	*(struct)
->	O
out_fd	int
!=	O
-	O
1	int
)	O
{	O
log_debug	()->(void)
(	O
"tunnel_accept: tunnel already established"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
while	O
(	O
tunnel	*(struct)
->	O
in_fd	int
==	O
-	O
1	int
||	O
tunnel	*(struct)
->	O
out_fd	int
==	O
-	O
1	int
)	O
{	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
addr	struct(int)
;	O
Http_request	struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
;	O
struct	O
pollfd	struct(int,short,short)
p	*(struct(*(char),*(*(char)),int))
;	O
ssize_t	long
m	long
;	O
int	O
len	long
;	O
int	O
n	long
;	O
int	O
s	short
;	O
p	*(struct(*(char),*(*(char)),int))
.	O
fd	int
=	O
tunnel	*(struct)
->	O
server_socket	(struct(int),int,int)->(int)
;	O
p	*(struct(*(char),*(*(char)),int))
.	O
events	short
=	O
POLLIN	int
;	O
n	long
=	O
poll	(*(struct(int,short,short)),long,int)->(int)
(	O
&	O
p	*(struct(*(char),*(*(char)),int))
,	O
1	int
,	O
(	O
tunnel	*(struct)
->	O
in_fd	int
!=	O
-	O
1	int
||	O
tunnel	*(struct)
->	O
out_fd	int
!=	O
-	O
1	int
?	O
ACCEPT_TIMEOUT	int
*	O
1000	int
:	O
-	O
1	int
)	O
)	O
;	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_accept: poll error: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_accept: poll timed out"	*(char)
)	O
;	O
break	O
;	O
}	O
len	long
=	O
sizeof	O
addr	struct(int)
;	O
s	short
=	O
accept	(int,*(struct(short,array(char))),*(int))->(int)
(	O
tunnel	*(struct)
->	O
server_socket	(struct(int),int,int)->(int)
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
addr	struct(int)
,	O
&	O
len	long
)	O
;	O
if	O
(	O
s	short
==	O
-	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_accept: accept error: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
log_notice	(*(char))->(void)
(	O
"connection from %d.%d.%d.%d:%u"	*(char)
,	O
ntohl	(int)->(int)
(	O
addr	struct(int)
.	O
sin_addr	struct(int)
.	O
s_addr	int
)	O
>>	O
24	int
,	O
(	O
ntohl	(int)->(int)
(	O
addr	struct(int)
.	O
sin_addr	struct(int)
.	O
s_addr	int
)	O
>>	O
16	int
)	O
&	O
0xff	int
,	O
(	O
ntohl	(int)->(int)
(	O
addr	struct(int)
.	O
sin_addr	struct(int)
.	O
s_addr	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
,	O
ntohl	(int)->(int)
(	O
addr	struct(int)
.	O
sin_addr	struct(int)
.	O
s_addr	int
)	O
&	O
0xff	int
,	O
ntohs	(short)->(short)
(	O
addr	struct(int)
.	O
sin_port	short
)	O
)	O
;	O
m	long
=	O
http_parse_request	(int,*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct`)))))->(long)
(	O
s	short
,	O
&	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
if	O
(	O
m	long
<=	O
0	int
)	O
return	O
m	long
;	O
if	O
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
method	enum(int,int,int,int,int,int,int)
==	O
-	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_accept: error parsing header: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
close	(int)->(int)
(	O
s	short
)	O
;	O
}	O
else	O
if	O
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
method	enum(int,int,int,int,int,int,int)
==	O
HTTP_POST	int
||	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
method	enum(int,int,int,int,int,int,int)
==	O
HTTP_PUT	int
)	O
{	O
if	O
(	O
tunnel	*(struct)
->	O
in_fd	int
==	O
-	O
1	int
)	O
{	O
tunnel	*(struct)
->	O
in_fd	int
=	O
s	short
;	O
fcntl	(int,int)->(int)
(	O
tunnel	*(struct)
->	O
in_fd	int
,	O
F_SETFL	int
,	O
fcntl	(int,int)->(int)
(	O
tunnel	*(struct)
->	O
in_fd	int
,	O
F_GETFL	int
)	O
|	O
O_NONBLOCK	int
)	O
;	O
tunnel_in_setsockopts	(int)->(int)
(	O
tunnel	*(struct)
->	O
in_fd	int
)	O
;	O
log_debug	()->(void)
(	O
"tunnel_accept: input connected"	*(char)
)	O
;	O
}	O
else	O
{	O
log_error	(*(char))->(void)
(	O
"rejected tunnel_in: already got a connection"	*(char)
)	O
;	O
close	(int)->(int)
(	O
s	short
)	O
;	O
}	O
}	O
else	O
if	O
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
method	enum(int,int,int,int,int,int,int)
==	O
HTTP_GET	int
)	O
{	O
if	O
(	O
tunnel	*(struct)
->	O
out_fd	int
==	O
-	O
1	int
)	O
{	O
char	O
str	*(*(char))
[	O
1024	int
]	O
;	O
tunnel	*(struct)
->	O
out_fd	int
=	O
s	short
;	O
tunnel_out_setsockopts	(int)->(int)
(	O
tunnel	*(struct)
->	O
out_fd	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
str	*(*(char))
,	O
"HTTP/1.1 200 OK\r\n"	*(char)
"Content-Length: %d\r\n"	*(char)
"Connection: close\r\n"	*(char)
"Pragma: no-cache\r\n"	*(char)
"Cache-Control: no-cache, no-store, must-revalidate\r\n"	*(char)
"Expires: 0\r\n"	*(char)
"Content-Type: text/html\r\n"	*(char)
"\r\n"	*(char)
,	O
tunnel	*(struct)
->	O
content_length	long
+	O
1	int
)	O
;	O
if	O
(	O
write_all	(int,*(void),long)->(long)
(	O
tunnel	*(struct)
->	O
out_fd	int
,	O
str	*(*(char))
,	O
strlen	(*(char))->(long)
(	O
str	*(*(char))
)	O
)	O
<=	O
0	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_accept: couldn't write GET header: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
close	(int)->(int)
(	O
tunnel	*(struct)
->	O
out_fd	int
)	O
;	O
tunnel	*(struct)
->	O
out_fd	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
tunnel	*(struct)
->	O
bytes	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
buf_len	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
buf_ptr	*(char)
=	O
tunnel	*(struct)
->	O
buf	*(char)
;	O
log_debug	()->(void)
(	O
"tunnel_accept: output connected"	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_accept: rejected tunnel_out: "	*(char)
"already got a connection"	*(char)
)	O
;	O
close	(int)->(int)
(	O
s	short
)	O
;	O
}	O
}	O
else	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_accept: unknown header type"	*(char)
)	O
;	O
log_debug	()->(void)
(	O
"tunnel_accept: closing connection"	*(char)
)	O
;	O
close	(int)->(int)
(	O
s	short
)	O
;	O
}	O
http_destroy_request	(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))->(void)
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
}	O
if	O
(	O
tunnel	*(struct)
->	O
in_fd	int
==	O
-	O
1	int
||	O
tunnel	*(struct)
->	O
out_fd	int
==	O
-	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_accept: in_fd = %d, out_fd = %d"	*(char)
,	O
tunnel	*(struct)
->	O
in_fd	int
,	O
tunnel	*(struct)
->	O
out_fd	int
)	O
;	O
if	O
(	O
tunnel	*(struct)
->	O
in_fd	int
!=	O
-	O
1	int
)	O
close	(int)->(int)
(	O
tunnel	*(struct)
->	O
in_fd	int
)	O
;	O
tunnel	*(struct)
->	O
in_fd	int
=	O
-	O
1	int
;	O
log_debug	()->(void)
(	O
"tunnel_accept: input disconnected"	*(char)
)	O
;	O
tunnel_out_disconnect	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(void)
(	O
tunnel	*(struct)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
Tunnel	struct
*	O
tunnel_new_server	(*(char),int,long)->(*(struct))
(	O
const	O
char	O
*	O
host	*(char)
,	O
int	O
port	int
,	O
size_t	long
content_length	long
)	O
{	O
Tunnel	struct
*	O
tunnel	*(struct)
;	O
struct	O
in_addr	struct(int)
addr	struct(int)
;	O
struct	O
hostent	struct(*(char),*(*(char)),int,int,*(*(char)))
*	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
;	O
if	O
(	O
host	*(char)
==	O
NULL	O
)	O
addr	struct(int)
.	O
s_addr	int
=	O
INADDR_ANY	O
;	O
else	O
if	O
(	O
(	O
addr	struct(int)
.	O
s_addr	int
=	O
inet_addr	(*(char))->(int)
(	O
host	*(char)
)	O
)	O
==	O
INADDR_NONE	O
)	O
{	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
=	O
gethostbyname	(*(char))->(*(struct(*(char),*(*(char)),int,int,*(*(char)))))
(	O
host	*(char)
)	O
;	O
if	O
(	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
==	O
NULL	O
||	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_addrtype	int
!=	O
AF_INET	O
)	O
return	O
NULL	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
addr	struct(int)
,	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_addr	O
,	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_length	int
)	O
;	O
}	O
tunnel	*(struct)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
Tunnel	struct
)	O
)	O
;	O
if	O
(	O
tunnel	*(struct)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
content_length	long
==	O
0	int
)	O
content_length	long
=	O
DEFAULT_CONTENT_LENGTH	O
;	O
tunnel	*(struct)
->	O
in_fd	int
=	O
-	O
1	int
;	O
tunnel	*(struct)
->	O
out_fd	int
=	O
-	O
1	int
;	O
tunnel	*(struct)
->	O
server_socket	(struct(int),int,int)->(int)
=	O
-	O
1	int
;	O
tunnel	*(struct)
->	O
dest	short
.	O
host_name	*(char)
=	O
host	*(char)
;	O
tunnel	*(struct)
->	O
dest	short
.	O
host_port	int
=	O
port	int
;	O
tunnel	*(struct)
->	O
buf_ptr	*(char)
=	O
tunnel	*(struct)
->	O
buf	*(char)
;	O
tunnel	*(struct)
->	O
buf_len	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
content_length	long
=	O
content_length	long
-	O
1	int
;	O
tunnel	*(struct)
->	O
in_total_raw	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
in_total_data	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
out_total_raw	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
out_total_data	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
strict_content_length	int
=	O
FALSE	int
;	O
tunnel	*(struct)
->	O
bytes	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
server_socket	(struct(int),int,int)->(int)
=	O
server_socket	(struct(int),int,int)->(int)
(	O
addr	struct(int)
,	O
tunnel	*(struct)
->	O
dest	short
.	O
host_port	int
,	O
1	int
)	O
;	O
if	O
(	O
tunnel	*(struct)
->	O
server_socket	(struct(int),int,int)->(int)
==	O
-	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_new_server: server_socket (%d) = -1"	*(char)
,	O
tunnel	*(struct)
->	O
dest	short
.	O
host_port	int
)	O
;	O
tunnel_destroy	(*(struct))->(void)
(	O
tunnel	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
tunnel	*(struct)
;	O
}	O
Tunnel	struct
*	O
tunnel_new_client	(*(char),int,*(char),int,long)->(*(struct))
(	O
const	O
char	O
*	O
host	*(char)
,	O
int	O
host_port	int
,	O
const	O
char	O
*	O
proxy	*(char)
,	O
int	O
proxy_port	int
,	O
size_t	long
content_length	long
)	O
{	O
const	O
char	O
*	O
remote	*(char)
;	O
int	O
remote_port	int
;	O
Tunnel	struct
*	O
tunnel	*(struct)
;	O
log_verbose	()->(void)
(	O
"tunnel_new_client (\"%s\", %d, \"%s\", %d, %d)"	*(char)
,	O
host	*(char)
,	O
host_port	int
,	O
proxy	*(char)
?	O
proxy	*(char)
:	O
"(null)"	*(char)
,	O
proxy_port	int
,	O
content_length	long
)	O
;	O
tunnel	*(struct)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
Tunnel	struct
)	O
)	O
;	O
if	O
(	O
tunnel	*(struct)
==	O
NULL	O
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_new_client: out of memory"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
tunnel	*(struct)
->	O
in_fd	int
=	O
-	O
1	int
;	O
tunnel	*(struct)
->	O
out_fd	int
=	O
-	O
1	int
;	O
tunnel	*(struct)
->	O
server_socket	(struct(int),int,int)->(int)
=	O
-	O
1	int
;	O
tunnel	*(struct)
->	O
dest	short
.	O
host_name	*(char)
=	O
host	*(char)
;	O
tunnel	*(struct)
->	O
dest	short
.	O
host_port	int
=	O
host_port	int
;	O
tunnel	*(struct)
->	O
dest	short
.	O
proxy_name	*(char)
=	O
proxy	*(char)
;	O
tunnel	*(struct)
->	O
dest	short
.	O
proxy_port	int
=	O
proxy_port	int
;	O
tunnel	*(struct)
->	O
dest	short
.	O
proxy_authorization	*(char)
=	O
NULL	O
;	O
tunnel	*(struct)
->	O
dest	short
.	O
user_agent	*(char)
=	O
NULL	O
;	O
tunnel	*(struct)
->	O
content_length	long
=	O
content_length	long
-	O
1	int
;	O
tunnel	*(struct)
->	O
buf_ptr	*(char)
=	O
tunnel	*(struct)
->	O
buf	*(char)
;	O
tunnel	*(struct)
->	O
buf_len	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
in_total_raw	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
in_total_data	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
out_total_raw	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
out_total_data	long
=	O
0	int
;	O
tunnel	*(struct)
->	O
strict_content_length	int
=	O
FALSE	int
;	O
tunnel	*(struct)
->	O
bytes	long
=	O
0	int
;	O
if	O
(	O
tunnel	*(struct)
->	O
dest	short
.	O
proxy_name	*(char)
==	O
NULL	O
)	O
{	O
remote	*(char)
=	O
tunnel	*(struct)
->	O
dest	short
.	O
host_name	*(char)
;	O
remote_port	int
=	O
tunnel	*(struct)
->	O
dest	short
.	O
host_port	int
;	O
}	O
else	O
{	O
remote	*(char)
=	O
tunnel	*(struct)
->	O
dest	short
.	O
proxy_name	*(char)
;	O
remote_port	int
=	O
tunnel	*(struct)
->	O
dest	short
.	O
proxy_port	int
;	O
}	O
if	O
(	O
set_address	(*(struct(short,short,struct(int),array(char))),*(char),int)->(int)
(	O
&	O
tunnel	*(struct)
->	O
address	long
,	O
remote	*(char)
,	O
remote_port	int
)	O
==	O
-	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"tunnel_new_client: set_address: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
tunnel	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
tunnel	*(struct)
;	O
}	O
void	O
tunnel_destroy	(*(struct))->(void)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
)	O
{	O
if	O
(	O
tunnel_is_connected	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)))->(int)
(	O
tunnel	*(struct)
)	O
||	O
tunnel	*(struct)
->	O
in_fd	int
!=	O
-	O
1	int
)	O
tunnel_close	(*(struct))->(int)
(	O
tunnel	*(struct)
)	O
;	O
if	O
(	O
tunnel	*(struct)
->	O
server_socket	(struct(int),int,int)->(int)
!=	O
-	O
1	int
)	O
close	(int)->(int)
(	O
tunnel	*(struct)
->	O
server_socket	(struct(int),int,int)->(int)
)	O
;	O
free	(*(void))->(void)
(	O
tunnel	*(struct)
)	O
;	O
}	O
static	O
int	O
tunnel_opt	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(char),*(void),int)->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
,	O
const	O
char	O
*	O
opt	*(char)
,	O
void	O
*	O
data	*(void)
,	O
int	O
get_flag	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
opt	*(char)
,	O
"strict_content_length"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
get_flag	int
)	O
*	O
(	O
int	O
*	O
)	O
data	*(void)
=	O
tunnel	*(struct)
->	O
strict_content_length	int
;	O
else	O
tunnel	*(struct)
->	O
strict_content_length	int
=	O
*	O
(	O
int	O
*	O
)	O
data	*(void)
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
opt	*(char)
,	O
"keep_alive"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
get_flag	int
)	O
*	O
(	O
int	O
*	O
)	O
data	*(void)
=	O
tunnel	*(struct)
->	O
keep_alive	int
;	O
else	O
tunnel	*(struct)
->	O
keep_alive	int
=	O
*	O
(	O
int	O
*	O
)	O
data	*(void)
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
opt	*(char)
,	O
"max_connection_age"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
get_flag	int
)	O
*	O
(	O
int	O
*	O
)	O
data	*(void)
=	O
tunnel	*(struct)
->	O
max_connection_age	int
;	O
else	O
tunnel	*(struct)
->	O
max_connection_age	int
=	O
*	O
(	O
int	O
*	O
)	O
data	*(void)
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
opt	*(char)
,	O
"proxy_authorization"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
get_flag	int
)	O
{	O
if	O
(	O
tunnel	*(struct)
->	O
dest	short
.	O
proxy_authorization	*(char)
==	O
NULL	O
)	O
*	O
(	O
char	O
*	O
*	O
)	O
data	*(void)
=	O
NULL	O
;	O
else	O
*	O
(	O
char	O
*	O
*	O
)	O
data	*(void)
=	O
strdup	(*(char))->(*(char))
(	O
tunnel	*(struct)
->	O
dest	short
.	O
proxy_authorization	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
tunnel	*(struct)
->	O
dest	short
.	O
proxy_authorization	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
tunnel	*(struct)
->	O
dest	short
.	O
proxy_authorization	*(char)
)	O
;	O
tunnel	*(struct)
->	O
dest	short
.	O
proxy_authorization	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
data	*(void)
)	O
;	O
if	O
(	O
tunnel	*(struct)
->	O
dest	short
.	O
proxy_authorization	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
opt	*(char)
,	O
"user_agent"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
get_flag	int
)	O
{	O
if	O
(	O
tunnel	*(struct)
->	O
dest	short
.	O
user_agent	*(char)
==	O
NULL	O
)	O
*	O
(	O
char	O
*	O
*	O
)	O
data	*(void)
=	O
NULL	O
;	O
else	O
*	O
(	O
char	O
*	O
*	O
)	O
data	*(void)
=	O
strdup	(*(char))->(*(char))
(	O
tunnel	*(struct)
->	O
dest	short
.	O
user_agent	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
tunnel	*(struct)
->	O
dest	short
.	O
user_agent	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
tunnel	*(struct)
->	O
dest	short
.	O
user_agent	*(char)
)	O
;	O
tunnel	*(struct)
->	O
dest	short
.	O
user_agent	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
data	*(void)
)	O
;	O
if	O
(	O
tunnel	*(struct)
->	O
dest	short
.	O
user_agent	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
errno	O
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
tunnel_setopt	(*(struct),*(char),*(void))->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
,	O
const	O
char	O
*	O
opt	*(char)
,	O
void	O
*	O
data	*(void)
)	O
{	O
return	O
tunnel_opt	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(char),*(void),int)->(int)
(	O
tunnel	*(struct)
,	O
opt	*(char)
,	O
data	*(void)
,	O
FALSE	int
)	O
;	O
}	O
int	O
tunnel_getopt	(*(struct),*(char),*(void))->(int)
(	O
Tunnel	struct
*	O
tunnel	*(struct)
,	O
const	O
char	O
*	O
opt	*(char)
,	O
void	O
*	O
data	*(void)
)	O
{	O
return	O
tunnel_opt	(*(struct(int,int,int,struct(*(char),int,*(char),int,*(char),*(char)),struct(short,short,struct(int),array(char)),long,long,array(char),*(char),long,int,long,long,long,long,long,int,int,int)),*(char),*(void),int)->(int)
(	O
tunnel	*(struct)
,	O
opt	*(char)
,	O
data	*(void)
,	O
TRUE	int
)	O
;	O
}	O
