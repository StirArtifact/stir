const	O
char	O
*	O
argp_program_version	*(char)
=	O
STANDARD_HURD_VERSION	()->(int)
(	O
proc	O
)	O
;	O
int	O
message_demuxer	(*(int),*(int))->(int)
(	O
mach_msg_header_t	O
*	O
inp	*(int)
,	O
mach_msg_header_t	O
*	O
outp	*(int)
)	O
{	O
mig_routine_t	O
routine	O
;	O
if	O
(	O
(	O
routine	O
=	O
process_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
notify_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
ports_interrupt_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
proc_exc_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
task_notify_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
)	O
{	O
pthread_mutex_lock	()->(int)
(	O
&	O
global_lock	int
)	O
;	O
(	O
*	O
routine	O
)	O
(	O
inp	*(int)
,	O
outp	*(int)
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	int
)	O
;	O
return	O
TRUE	O
;	O
}	O
else	O
return	O
FALSE	O
;	O
}	O
pthread_mutex_t	O
global_lock	int
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
int	O
startup_fallback	int
;	O
error_t	O
increase_priority	()->(int)
(	O
void	O
)	O
{	O
mach_port_t	O
pset	O
=	O
MACH_PORT_NULL	O
,	O
psetcntl	O
=	O
MACH_PORT_NULL	O
;	O
error_t	O
err	O
;	O
err	O
=	O
thread_get_assignment	()->(int)
(	O
mach_thread_self	()->(int)
(	O
)	O
,	O
&	O
pset	O
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
out	O
;	O
err	O
=	O
host_processor_set_priv	()->(int)
(	O
_hurd_host_priv	O
,	O
pset	O
,	O
&	O
psetcntl	O
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
out	O
;	O
err	O
=	O
thread_max_priority	()->(int)
(	O
mach_thread_self	()->(int)
(	O
)	O
,	O
psetcntl	O
,	O
0	int
)	O
;	O
if	O
(	O
err	O
==	O
KERN_INVALID_ARGUMENT	O
)	O
err	O
=	O
EPERM	O
;	O
if	O
(	O
err	O
)	O
goto	O
out	O
;	O
err	O
=	O
task_priority	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
2	int
,	O
1	int
)	O
;	O
out	O
:	O
if	O
(	O
MACH_PORT_VALID	()->(int)
(	O
pset	O
)	O
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
pset	O
)	O
;	O
if	O
(	O
MACH_PORT_VALID	()->(int)
(	O
psetcntl	O
)	O
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
psetcntl	O
)	O
;	O
return	O
err	O
;	O
}	O
int	O
main	(int,*(*(char)),*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
*	O
envp	*(*(char))
)	O
{	O
mach_port_t	O
boot	O
;	O
error_t	O
err	O
;	O
void	O
*	O
genport	*(void)
;	O
process_t	int
startup_port	int
;	O
mach_port_t	O
startup	O
;	O
struct	O
argp	struct
argp	struct
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
"Hurd process server"	*(char)
}	O
;	O
argp_parse	()->(int)
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
initialize_version_info	()->(int)
(	O
)	O
;	O
err	O
=	O
task_get_bootstrap_port	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
&	O
boot	O
)	O
;	O
assert_perror	()->(int)
(	O
err	O
)	O
;	O
if	O
(	O
boot	O
==	O
MACH_PORT_NULL	O
)	O
error	()->(int)
(	O
2	int
,	O
0	int
,	O
"proc server can only be run by startup during boot"	*(char)
)	O
;	O
proc_bucket	O
=	O
ports_create_bucket	()->(int)
(	O
)	O
;	O
proc_class	O
=	O
ports_create_class	()->(int)
(	O
0	int
,	O
0	int
)	O
;	O
generic_port_class	O
=	O
ports_create_class	()->(int)
(	O
0	int
,	O
0	int
)	O
;	O
exc_class	O
=	O
ports_create_class	()->(int)
(	O
exc_clean	O
,	O
0	int
)	O
;	O
ports_create_port	()->(int)
(	O
generic_port_class	O
,	O
proc_bucket	O
,	O
sizeof	O
(	O
struct	O
port_info	O
)	O
,	O
&	O
genport	*(void)
)	O
;	O
generic_port	O
=	O
ports_get_right	()->(int)
(	O
genport	*(void)
)	O
;	O
init_proc	O
=	O
create_init_proc	()->(int)
(	O
)	O
;	O
startup_proc	O
=	O
allocate_proc	()->(int)
(	O
MACH_PORT_NULL	O
)	O
;	O
startup_proc	O
->	O
p_deadmsg	O
=	O
1	int
;	O
complete_proc	()->(int)
(	O
startup_proc	O
,	O
HURD_PID_STARTUP	O
)	O
;	O
self_proc	O
=	O
allocate_proc	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
)	O
;	O
assert	()->(int)
(	O
self_proc	O
)	O
;	O
complete_proc	()->(int)
(	O
self_proc	O
,	O
HURD_PID_PROC	O
)	O
;	O
startup_port	int
=	O
ports_get_send_right	()->(int)
(	O
startup_proc	O
)	O
;	O
err	O
=	O
startup_procinit	()->(int)
(	O
boot	O
,	O
startup_port	int
,	O
&	O
startup_proc	O
->	O
p_task	O
,	O
&	O
authserver	O
,	O
&	O
_hurd_host_priv	O
,	O
&	O
_hurd_device_master	O
)	O
;	O
assert_perror	()->(int)
(	O
err	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
startup_port	int
)	O
;	O
mach_port_mod_refs	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
authserver	O
,	O
MACH_PORT_RIGHT_SEND	O
,	O
1	int
)	O
;	O
_hurd_port_set	()->(int)
(	O
&	O
_hurd_ports	O
[	O
INIT_PORT_AUTH	int
]	O
,	O
authserver	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
boot	O
)	O
;	O
proc_death_notify	()->(int)
(	O
startup_proc	O
)	O
;	O
add_proc_to_hash	()->(int)
(	O
startup_proc	O
)	O
;	O
self_proc	O
->	O
p_argv	O
=	O
(	O
vm_address_t	O
)	O
argv	*(*(char))
;	O
self_proc	O
->	O
p_envp	O
=	O
(	O
vm_address_t	O
)	O
envp	*(*(char))
;	O
err	O
=	O
increase_priority	()->(int)
(	O
)	O
;	O
if	O
(	O
err	O
&&	O
err	O
!=	O
EPERM	O
)	O
error	()->(int)
(	O
0	int
,	O
err	O
,	O
"Increasing priority failed"	*(char)
)	O
;	O
err	O
=	O
register_new_task_notification	()->(int)
(	O
_hurd_host_priv	O
,	O
generic_port	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
if	O
(	O
err	O
)	O
error	()->(int)
(	O
0	int
,	O
err	O
,	O
"Registering task notifications failed"	*(char)
)	O
;	O
{	O
mach_port_t	O
cons	O
;	O
err	O
=	O
device_open	()->(int)
(	O
_hurd_device_master	O
,	O
D_READ	O
|	O
D_WRITE	O
,	O
"console"	*(char)
,	O
&	O
cons	O
)	O
;	O
assert_perror	()->(int)
(	O
err	O
)	O
;	O
stdin	O
=	O
mach_open_devstream	()->(int)
(	O
cons	O
,	O
"r"	*(char)
)	O
;	O
stdout	O
=	O
stderr	O
=	O
mach_open_devstream	()->(int)
(	O
cons	O
,	O
"w"	*(char)
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
cons	O
)	O
;	O
}	O
startup	O
=	O
file_name_lookup	()->(int)
(	O
_SERVERS_STARTUP	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
MACH_PORT_VALID	()->(int)
(	O
startup	O
)	O
)	O
{	O
err	O
=	O
startup_essential_task	()->(int)
(	O
startup	O
,	O
mach_task_self	()->(int)
(	O
)	O
,	O
MACH_PORT_NULL	O
,	O
"proc"	*(char)
,	O
_hurd_host_priv	O
)	O
;	O
if	O
(	O
err	O
)	O
startup_fallback	int
=	O
1	int
;	O
err	O
=	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
startup	O
)	O
;	O
assert_perror	()->(int)
(	O
err	O
)	O
;	O
}	O
else	O
startup_fallback	int
=	O
1	int
;	O
while	O
(	O
1	int
)	O
ports_manage_port_operations_multithread	()->(int)
(	O
proc_bucket	O
,	O
message_demuxer	(*(int),*(int))->(int)
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
