void	O
VQuaternionToMatrix	(*(struct(double,struct(double,double,double))),*(struct(array(array(double)))))->(void)
(	O
VQuaternion	struct(double,struct(double,double,double))
*	O
q	*(struct(double,struct(double,double,double)))
,	O
VMatrix	struct(array(array(double)))
*	O
m	array(array(double))
)	O
{	O
double	O
s	double
,	O
xs	double
,	O
ys	double
,	O
zs	double
,	O
wx	double
,	O
wy	double
,	O
wz	double
,	O
xx	double
,	O
xy	double
,	O
xz	double
,	O
yy	double
,	O
yz	double
,	O
zz	double
;	O
s	double
=	O
2.0	int
/	O
(	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
x	double
*	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
x	double
+	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
y	double
*	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
y	double
+	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
z	double
*	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
z	double
+	O
q	*(struct(double,struct(double,double,double)))
->	O
s	double
*	O
q	*(struct(double,struct(double,double,double)))
->	O
s	double
)	O
;	O
xs	double
=	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
x	double
*	O
s	double
;	O
ys	double
=	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
y	double
*	O
s	double
;	O
zs	double
=	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
z	double
*	O
s	double
;	O
wx	double
=	O
q	*(struct(double,struct(double,double,double)))
->	O
s	double
*	O
xs	double
;	O
wy	double
=	O
q	*(struct(double,struct(double,double,double)))
->	O
s	double
*	O
ys	double
;	O
wz	double
=	O
q	*(struct(double,struct(double,double,double)))
->	O
s	double
*	O
zs	double
;	O
xx	double
=	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
x	double
*	O
xs	double
;	O
xy	double
=	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
x	double
*	O
ys	double
;	O
xz	double
=	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
x	double
*	O
zs	double
;	O
yy	double
=	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
y	double
*	O
ys	double
;	O
yz	double
=	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
y	double
*	O
zs	double
;	O
zz	double
=	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
z	double
*	O
zs	double
;	O
VIdentMatrix	(*(struct(array(array(double)))))->(void)
(	O
m	array(array(double))
)	O
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
0	int
]	O
[	O
0	int
]	O
=	O
1.0	int
-	O
(	O
yy	double
+	O
zz	double
)	O
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
0	int
]	O
[	O
1	int
]	O
=	O
xy	double
+	O
wz	double
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
0	int
]	O
[	O
2	int
]	O
=	O
xz	double
-	O
wy	double
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
1	int
]	O
[	O
0	int
]	O
=	O
xy	double
-	O
wz	double
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
1	int
]	O
[	O
1	int
]	O
=	O
1.0	int
-	O
(	O
xx	double
+	O
zz	double
)	O
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
1	int
]	O
[	O
2	int
]	O
=	O
yz	double
+	O
wx	double
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
2	int
]	O
[	O
0	int
]	O
=	O
xz	double
+	O
wy	double
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
2	int
]	O
[	O
1	int
]	O
=	O
yz	double
-	O
wx	double
;	O
m	array(array(double))
->	O
m	array(array(double))
[	O
2	int
]	O
[	O
2	int
]	O
=	O
1.0	int
-	O
(	O
xx	double
+	O
yy	double
)	O
;	O
}	O
void	O
VMatrixToQuaternion	(*(struct(array(array(double)))),*(struct(double,struct(double,double,double))))->(void)
(	O
VMatrix	struct(array(array(double)))
*	O
m	array(array(double))
,	O
VQuaternion	struct(double,struct(double,double,double))
*	O
q	*(struct(double,struct(double,double,double)))
)	O
{	O
double	O
tr	double
,	O
s	double
,	O
*	O
q1	*(double)
=	O
(	O
double	O
*	O
)	O
&	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
;	O
int	O
i	int
,	O
j	int
,	O
k	int
;	O
tr	double
=	O
m	array(array(double))
->	O
m	array(array(double))
[	O
0	int
]	O
[	O
0	int
]	O
+	O
m	array(array(double))
->	O
m	array(array(double))
[	O
1	int
]	O
[	O
1	int
]	O
+	O
m	array(array(double))
->	O
m	array(array(double))
[	O
2	int
]	O
[	O
2	int
]	O
;	O
if	O
(	O
tr	double
>	O
0.0	int
)	O
{	O
s	double
=	O
sqrt	(double)->(double)
(	O
tr	double
+	O
1.0	int
)	O
;	O
q	*(struct(double,struct(double,double,double)))
->	O
s	double
=	O
s	double
*	O
0.5	int
;	O
s	double
=	O
0.5	int
/	O
s	double
;	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
x	double
=	O
(	O
m	array(array(double))
->	O
m	array(array(double))
[	O
1	int
]	O
[	O
2	int
]	O
-	O
m	array(array(double))
->	O
m	array(array(double))
[	O
2	int
]	O
[	O
1	int
]	O
)	O
*	O
s	double
;	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
y	double
=	O
(	O
m	array(array(double))
->	O
m	array(array(double))
[	O
2	int
]	O
[	O
0	int
]	O
-	O
m	array(array(double))
->	O
m	array(array(double))
[	O
0	int
]	O
[	O
2	int
]	O
)	O
*	O
s	double
;	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
z	double
=	O
(	O
m	array(array(double))
->	O
m	array(array(double))
[	O
0	int
]	O
[	O
1	int
]	O
-	O
m	array(array(double))
->	O
m	array(array(double))
[	O
1	int
]	O
[	O
0	int
]	O
)	O
*	O
s	double
;	O
}	O
else	O
{	O
i	int
=	O
0	int
;	O
if	O
(	O
m	array(array(double))
->	O
m	array(array(double))
[	O
1	int
]	O
[	O
1	int
]	O
>	O
m	array(array(double))
->	O
m	array(array(double))
[	O
0	int
]	O
[	O
0	int
]	O
)	O
{	O
i	int
=	O
1	int
;	O
}	O
if	O
(	O
m	array(array(double))
->	O
m	array(array(double))
[	O
2	int
]	O
[	O
2	int
]	O
>	O
m	array(array(double))
->	O
m	array(array(double))
[	O
i	int
]	O
[	O
i	int
]	O
)	O
{	O
i	int
=	O
2	int
;	O
}	O
j	int
=	O
(	O
i	int
+	O
1	int
)	O
%	O
3	int
;	O
k	int
=	O
(	O
j	int
+	O
1	int
)	O
%	O
3	int
;	O
s	double
=	O
sqrt	(double)->(double)
(	O
(	O
m	array(array(double))
->	O
m	array(array(double))
[	O
i	int
]	O
[	O
i	int
]	O
-	O
(	O
m	array(array(double))
->	O
m	array(array(double))
[	O
j	int
]	O
[	O
j	int
]	O
+	O
m	array(array(double))
->	O
m	array(array(double))
[	O
k	int
]	O
[	O
k	int
]	O
)	O
)	O
+	O
1.0	int
)	O
;	O
q1	*(double)
[	O
i	int
]	O
=	O
s	double
*	O
0.5	int
;	O
s	double
=	O
0.5	int
/	O
s	double
;	O
q	*(struct(double,struct(double,double,double)))
->	O
s	double
=	O
(	O
m	array(array(double))
->	O
m	array(array(double))
[	O
j	int
]	O
[	O
k	int
]	O
+	O
m	array(array(double))
->	O
m	array(array(double))
[	O
k	int
]	O
[	O
j	int
]	O
)	O
*	O
s	double
;	O
q1	*(double)
[	O
j	int
]	O
=	O
(	O
m	array(array(double))
->	O
m	array(array(double))
[	O
i	int
]	O
[	O
j	int
]	O
+	O
m	array(array(double))
->	O
m	array(array(double))
[	O
j	int
]	O
[	O
i	int
]	O
)	O
*	O
s	double
;	O
q1	*(double)
[	O
k	int
]	O
=	O
(	O
m	array(array(double))
->	O
m	array(array(double))
[	O
i	int
]	O
[	O
k	int
]	O
+	O
m	array(array(double))
->	O
m	array(array(double))
[	O
k	int
]	O
[	O
i	int
]	O
)	O
*	O
s	double
;	O
}	O
}	O
void	O
VInterpolateQuaternion	(*(struct(double,struct(double,double,double))),*(struct(double,struct(double,double,double))),double,*(struct(double,struct(double,double,double))))->(void)
(	O
VQuaternion	struct(double,struct(double,double,double))
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
,	O
VQuaternion	struct(double,struct(double,double,double))
*	O
q	*(struct(double,struct(double,double,double)))
,	O
double	O
t	double
,	O
VQuaternion	struct(double,struct(double,double,double))
*	O
qt	*(struct(double,struct(double,double,double)))
)	O
{	O
double	O
omega	double
,	O
cosom	double
,	O
sinom	double
,	O
sclp	double
,	O
sclq	double
;	O
cosom	double
=	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
v	struct(double,double,double)
.	O
x	double
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
v	struct(double,double,double)
.	O
x	double
+	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
v	struct(double,double,double)
.	O
y	double
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
v	struct(double,double,double)
.	O
y	double
+	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
v	struct(double,double,double)
.	O
z	double
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
v	struct(double,double,double)
.	O
z	double
+	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
s	double
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
s	double
;	O
if	O
(	O
(	O
1.0	int
+	O
cosom	double
)	O
>	O
EPSILON	int
)	O
{	O
if	O
(	O
(	O
1.0	int
-	O
cosom	double
)	O
>	O
EPSILON	int
)	O
{	O
omega	double
=	O
acos	(double)->(double)
(	O
cosom	double
)	O
;	O
sinom	double
=	O
sin	(double)->(double)
(	O
omega	double
)	O
;	O
sclp	double
=	O
sin	(double)->(double)
(	O
(	O
1.0	int
-	O
t	double
)	O
*	O
omega	double
)	O
/	O
sinom	double
;	O
sclq	double
=	O
sin	(double)->(double)
(	O
t	double
*	O
omega	double
)	O
/	O
sinom	double
;	O
}	O
else	O
{	O
sclp	double
=	O
1.0	int
-	O
t	double
;	O
sclq	double
=	O
t	double
;	O
}	O
qt	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
x	double
=	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
v	struct(double,double,double)
.	O
x	double
*	O
sclp	double
+	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
x	double
*	O
sclq	double
;	O
qt	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
y	double
=	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
v	struct(double,double,double)
.	O
y	double
*	O
sclp	double
+	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
y	double
*	O
sclq	double
;	O
qt	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
z	double
=	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
v	struct(double,double,double)
.	O
z	double
*	O
sclp	double
+	O
q	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
z	double
*	O
sclq	double
;	O
qt	*(struct(double,struct(double,double,double)))
->	O
s	double
=	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
s	double
*	O
sclp	double
+	O
q	*(struct(double,struct(double,double,double)))
->	O
s	double
*	O
sclq	double
;	O
}	O
else	O
{	O
qt	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
x	double
=	O
-	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
v	struct(double,double,double)
.	O
y	double
;	O
qt	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
y	double
=	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
v	struct(double,double,double)
.	O
x	double
;	O
qt	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
z	double
=	O
-	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
s	double
;	O
qt	*(struct(double,struct(double,double,double)))
->	O
s	double
=	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
v	struct(double,double,double)
.	O
z	double
;	O
sclp	double
=	O
sin	(double)->(double)
(	O
(	O
1.0	int
-	O
t	double
)	O
*	O
M_PI_2	int
)	O
;	O
sclq	double
=	O
sin	(double)->(double)
(	O
t	double
*	O
M_PI_2	int
)	O
;	O
qt	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
x	double
=	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
v	struct(double,double,double)
.	O
x	double
*	O
sclp	double
+	O
qt	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
x	double
*	O
sclq	double
;	O
qt	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
y	double
=	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
v	struct(double,double,double)
.	O
y	double
*	O
sclp	double
+	O
qt	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
y	double
*	O
sclq	double
;	O
qt	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
z	double
=	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
v	struct(double,double,double)
.	O
z	double
*	O
sclp	double
+	O
qt	*(struct(double,struct(double,double,double)))
->	O
v	struct(double,double,double)
.	O
z	double
*	O
sclq	double
;	O
}	O
}	O
VQuaternion	struct(double,struct(double,double,double))
*	O
VQuaternionMult	(*(struct(double,struct(double,double,double))),*(struct(double,struct(double,double,double))),*(struct(double,struct(double,double,double))))->(*(struct(double,struct(double,double,double))))
(	O
VQuaternion	struct(double,struct(double,double,double))
*	O
a	*(struct(double,double,double))
,	O
VQuaternion	struct(double,struct(double,double,double))
*	O
b	*(struct(double,double,double))
,	O
VQuaternion	struct(double,struct(double,double,double))
*	O
r	*(struct(double,double,double))
)	O
{	O
VPoint	struct(double,double,double)
aa	struct(double,double,double)
,	O
bb	struct(double,double,double)
,	O
c	*(struct(long,short,short,short,char,char))
;	O
r	*(struct(double,double,double))
->	O
s	double
=	O
a	*(struct(double,double,double))
->	O
s	double
*	O
b	*(struct(double,double,double))
->	O
s	double
-	O
VDotProd	(*(struct(double,double,double)),*(struct(double,double,double)))->(double)
(	O
&	O
a	*(struct(double,double,double))
->	O
v	struct(double,double,double)
,	O
&	O
b	*(struct(double,double,double))
->	O
v	struct(double,double,double)
)	O
;	O
VCrossProd	(*(struct(double,double,double)),*(struct(double,double,double)),*(struct(double,double,double)))->(void)
(	O
&	O
a	*(struct(double,double,double))
->	O
v	struct(double,double,double)
,	O
&	O
b	*(struct(double,double,double))
->	O
v	struct(double,double,double)
,	O
&	O
c	*(struct(long,short,short,short,char,char))
)	O
;	O
c	*(struct(long,short,short,short,char,char))
.	O
x	double
+=	O
a	*(struct(double,double,double))
->	O
s	double
*	O
b	*(struct(double,double,double))
->	O
v	struct(double,double,double)
.	O
x	double
+	O
b	*(struct(double,double,double))
->	O
s	double
*	O
a	*(struct(double,double,double))
->	O
v	struct(double,double,double)
.	O
x	double
;	O
c	*(struct(long,short,short,short,char,char))
.	O
y	double
+=	O
a	*(struct(double,double,double))
->	O
s	double
*	O
b	*(struct(double,double,double))
->	O
v	struct(double,double,double)
.	O
y	double
+	O
b	*(struct(double,double,double))
->	O
s	double
*	O
a	*(struct(double,double,double))
->	O
v	struct(double,double,double)
.	O
y	double
;	O
c	*(struct(long,short,short,short,char,char))
.	O
z	double
+=	O
a	*(struct(double,double,double))
->	O
s	double
*	O
b	*(struct(double,double,double))
->	O
v	struct(double,double,double)
.	O
z	double
+	O
b	*(struct(double,double,double))
->	O
s	double
*	O
a	*(struct(double,double,double))
->	O
v	struct(double,double,double)
.	O
z	double
;	O
r	*(struct(double,double,double))
->	O
v	struct(double,double,double)
=	O
c	*(struct(long,short,short,short,char,char))
;	O
return	O
r	*(struct(double,double,double))
;	O
}	O
VQuaternion	struct(double,struct(double,double,double))
*	O
VQuaternionComplement	(*(struct(double,struct(double,double,double))),*(struct(double,struct(double,double,double))))->(*(struct(double,struct(double,double,double))))
(	O
VQuaternion	struct(double,struct(double,double,double))
*	O
a	*(struct(double,double,double))
,	O
VQuaternion	struct(double,struct(double,double,double))
*	O
r	*(struct(double,double,double))
)	O
{	O
r	*(struct(double,double,double))
->	O
s	double
=	O
a	*(struct(double,double,double))
->	O
s	double
;	O
r	*(struct(double,double,double))
->	O
v	struct(double,double,double)
.	O
x	double
=	O
-	O
a	*(struct(double,double,double))
->	O
v	struct(double,double,double)
.	O
x	double
;	O
r	*(struct(double,double,double))
->	O
v	struct(double,double,double)
.	O
y	double
=	O
-	O
a	*(struct(double,double,double))
->	O
v	struct(double,double,double)
.	O
y	double
;	O
r	*(struct(double,double,double))
->	O
v	struct(double,double,double)
.	O
z	double
=	O
-	O
a	*(struct(double,double,double))
->	O
v	struct(double,double,double)
.	O
z	double
;	O
return	O
r	*(struct(double,double,double))
;	O
}	O
