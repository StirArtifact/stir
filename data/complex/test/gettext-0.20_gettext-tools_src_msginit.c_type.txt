extern	O
const	O
char	O
*	O
_nl_expand_alias	(*(char))->(*(char))
(	O
const	O
char	O
*	O
name	*(char)
)	O
;	O
static	O
const	O
char	O
*	O
locale	*(char)
;	O
static	O
const	O
char	O
*	O
catalogname	*(char)
;	O
static	O
const	O
char	O
*	O
language	*(char)
;	O
static	O
bool	bool
no_translator	bool
;	O
static	O
const	O
struct	O
option	struct(*(char),int,*(int),int)
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"color"	*(char)
,	O
optional_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
5	int
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"input"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"locale"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"no-translator"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
1	int
}	O
,	O
{	O
"no-wrap"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
2	int
}	O
,	O
{	O
"output-file"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'o'	O
}	O
,	O
{	O
"properties-input"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'P'	O
}	O
,	O
{	O
"properties-output"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'p'	O
}	O
,	O
{	O
"stringtable-input"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
3	int
}	O
,	O
{	O
"stringtable-output"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
4	int
}	O
,	O
{	O
"style"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
6	int
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
"width"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'w'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
status	int
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
const	O
char	O
*	O
find_pot	()->(*(char))
(	O
void	O
)	O
;	O
static	O
const	O
char	O
*	O
catalogname_for_locale	(*(char))->(*(char))
(	O
const	O
char	O
*	O
locale	*(char)
)	O
;	O
static	O
const	O
char	O
*	O
language_of_locale	(*(char))->(*(char))
(	O
const	O
char	O
*	O
locale	*(char)
)	O
;	O
static	O
char	O
*	O
get_field	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
header	*(char)
,	O
const	O
char	O
*	O
field	*(char)
)	O
;	O
static	O
msgdomain_list_ty	struct
*	O
fill_header	(*(struct(*(*(struct`)),long,long,bool,*(char))))->(*(struct(*(*(struct`)),long,long,bool,*(char))))
(	O
msgdomain_list_ty	struct
*	O
mdlp	*(struct(*(*(struct(*`,*`))),long,long,bool,*(char)))
)	O
;	O
static	O
msgdomain_list_ty	struct
*	O
update_msgstr_plurals	(*(struct(*(*(struct`)),long,long,bool,*(char))))->(*(struct(*(*(struct`)),long,long,bool,*(char))))
(	O
msgdomain_list_ty	struct
*	O
mdlp	*(struct(*(*(struct(*`,*`))),long,long,bool,*(char)))
)	O
;	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
opt	int
;	O
bool	bool
do_help	bool
;	O
bool	bool
do_version	bool
;	O
char	O
*	O
output_file	*(char)
;	O
const	O
char	O
*	O
input_file	*(char)
;	O
msgdomain_list_ty	struct
*	O
result	*(*(void))
;	O
catalog_input_format_ty	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
input_syntax	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
=	O
&	O
input_format_po	struct(*((*(struct(*`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char))->(void)),bool)
;	O
catalog_output_format_ty	*(struct(*((*(struct`),*(struct`),long,bool)->(void)),bool,bool,bool,bool,bool,bool,bool,bool))
output_syntax	*(struct(*((*(struct`),*(struct`),long,bool)->(void)),bool,bool,bool,bool,bool,bool,bool,bool))
=	O
&	O
output_format_po	struct(*((*(struct(*`,long,long,bool,*`)),*(struct),long,bool)->(void)),bool,bool,bool,bool,bool,bool,bool,bool)
;	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
error_print_progname	*(()->(void))
=	O
maybe_print_progname	()->(void)
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
relocate	O
(	O
LOCALEDIR	*(char)
)	O
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
"bison-runtime"	*(char)
,	O
relocate	O
(	O
BISON_LOCALEDIR	O
)	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
atexit	(*(()->(void)))->(int)
(	O
close_stdout	()->(void)
)	O
;	O
do_help	bool
=	O
false	int
;	O
do_version	bool
=	O
false	int
;	O
output_file	*(char)
=	O
NULL	O
;	O
input_file	*(char)
=	O
NULL	O
;	O
locale	*(char)
=	O
NULL	O
;	O
while	O
(	O
(	O
opt	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"hi:l:o:pPVw:"	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
switch	O
(	O
opt	int
)	O
{	O
case	O
'\0'	O
:	O
break	O
;	O
case	O
'h'	O
:	O
do_help	bool
=	O
true	int
;	O
break	O
;	O
case	O
'i'	O
:	O
if	O
(	O
input_file	*(char)
!=	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"at most one input file allowed"	*(char)
)	O
)	O
;	O
usage	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
input_file	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'l'	O
:	O
locale	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'o'	O
:	O
output_file	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'p'	O
:	O
output_syntax	*(struct(*((*(struct`),*(struct`),long,bool)->(void)),bool,bool,bool,bool,bool,bool,bool,bool))
=	O
&	O
output_format_properties	struct(*((*(struct(*`,long,long,bool,*`)),*(struct),long,bool)->(void)),bool,bool,bool,bool,bool,bool,bool,bool)
;	O
break	O
;	O
case	O
'P'	O
:	O
input_syntax	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
=	O
&	O
input_format_properties	struct(*((*(struct(*`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char))->(void)),bool)
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	bool
=	O
true	int
;	O
break	O
;	O
case	O
'w'	O
:	O
{	O
int	O
value	*(char)
;	O
char	O
*	O
endp	*(char)
;	O
value	*(char)
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
&	O
endp	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
endp	*(char)
!=	O
optarg	*(char)
)	O
message_page_width_set	(long)->(void)
(	O
value	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
1	int
:	O
no_translator	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
2	int
:	O
message_page_width_ignore	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
3	int
:	O
input_syntax	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
=	O
&	O
input_format_stringtable	struct(*((*(struct(*`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char))->(void)),bool)
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
4	int
:	O
output_syntax	*(struct(*((*(struct`),*(struct`),long,bool)->(void)),bool,bool,bool,bool,bool,bool,bool,bool))
=	O
&	O
output_format_stringtable	struct(*((*(struct(*`,long,long,bool,*`)),*(struct),long,bool)->(void)),bool,bool,bool,bool,bool,bool,bool,bool)
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
5	int
:	O
if	O
(	O
handle_color_option	(*(char))->(bool)
(	O
optarg	*(char)
)	O
||	O
color_test_mode	bool
)	O
usage	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
6	int
:	O
handle_style_option	(*(char))->(void)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
usage	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
do_version	bool
)	O
{	O
printf	(*(char))->(int)
(	O
"%s (GNU %s) %s\n"	*(char)
,	O
basename	(*(char))->(*(char))
(	O
program_name	*(char)
)	O
,	O
PACKAGE	*(char)
,	O
VERSION	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	*(char)
)	O
,	O
"2001-2019"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Written by %s.\n"	*(char)
)	O
,	O
proper_name	(*(char))->(*(char))
(	O
"Bruno Haible"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
do_help	bool
)	O
usage	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
if	O
(	O
optind	int
!=	O
argc	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"too many arguments"	*(char)
)	O
)	O
;	O
if	O
(	O
input_file	*(char)
==	O
NULL	O
)	O
input_file	*(char)
=	O
find_pot	()->(*(char))
(	O
)	O
;	O
if	O
(	O
locale	*(char)
==	O
NULL	O
)	O
{	O
locale	*(char)
=	O
gl_locale_name	(int,*(char))->(*(char))
(	O
LC_MESSAGES	O
,	O
"LC_MESSAGES"	*(char)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
locale	*(char)
,	O
"C"	*(char)
)	O
==	O
0	int
)	O
{	O
const	O
char	O
*	O
doc_url	*(char)
=	O
"https://www.gnu.org/software/gettext/manual/html_node/Setting-the-POSIX-Locale.html"	*(char)
;	O
multiline_error	(*(char),*(char))->(void)
(	O
xstrdup	(*(char))->(*(char))
(	O
""	*(char)
)	O
,	O
xasprintf	(*(char))->(*(char))
(	O
_	O
(	O
"You are in a language indifferent environment.  Please set\nyour LANG environment variable, as described in\n<%s>.\nThis is necessary so you can test your translations.\n"	*(char)
)	O
,	O
doc_url	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
{	O
const	O
char	O
*	O
alias	*(char)
=	O
_nl_expand_alias	(*(char))->(*(char))
(	O
locale	*(char)
)	O
;	O
if	O
(	O
alias	*(char)
!=	O
NULL	O
)	O
locale	*(char)
=	O
alias	*(char)
;	O
}	O
catalogname	*(char)
=	O
catalogname_for_locale	(*(char))->(*(char))
(	O
locale	*(char)
)	O
;	O
language	*(char)
=	O
language_of_locale	(*(char))->(*(char))
(	O
locale	*(char)
)	O
;	O
if	O
(	O
output_file	*(char)
==	O
NULL	O
)	O
{	O
output_file	*(char)
=	O
xasprintf	(*(char))->(*(char))
(	O
"%s.po"	*(char)
,	O
catalogname	*(char)
)	O
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
output_file	*(char)
,	O
F_OK	int
)	O
==	O
0	int
)	O
{	O
multiline_error	(*(char),*(char))->(void)
(	O
xstrdup	(*(char))->(*(char))
(	O
""	*(char)
)	O
,	O
xasprintf	(*(char))->(*(char))
(	O
_	O
(	O
"Output file %s already exists.\nPlease specify the locale through the --locale option or\nthe output .po file through the --output-file option.\n"	*(char)
)	O
,	O
output_file	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
result	*(*(void))
=	O
read_catalog_file	(*(char),*(struct(*((*`,*`,*`,*`)->(void)),bool)))->(*(struct(*(*(struct`)),long,long,bool,*(char))))
(	O
input_file	*(char)
,	O
input_syntax	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
)	O
;	O
result	*(*(void))
=	O
fill_header	(*(struct(*(*(struct`)),long,long,bool,*(char))))->(*(struct(*(*(struct`)),long,long,bool,*(char))))
(	O
result	*(*(void))
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
language	*(char)
,	O
"en"	*(char)
)	O
==	O
0	int
)	O
result	*(*(void))
=	O
msgdomain_list_english	(*(struct(*(*(struct`)),long,long,bool,*(char))))->(*(struct(*(*(struct`)),long,long,bool,*(char))))
(	O
result	*(*(void))
)	O
;	O
else	O
result	*(*(void))
=	O
update_msgstr_plurals	(*(struct(*(*(struct`)),long,long,bool,*(char))))->(*(struct(*(*(struct`)),long,long,bool,*(char))))
(	O
result	*(*(void))
)	O
;	O
msgdomain_list_print	(*(struct(*(*(struct`)),long,long,bool,*(char))),*(char),*(struct(*((*`,*`,long,bool)->(void)),bool,bool,bool,bool,bool,bool,bool,bool)),bool,bool)->(void)
(	O
result	*(*(void))
,	O
output_file	*(char)
,	O
output_syntax	*(struct(*((*(struct`),*(struct`),long,bool)->(void)),bool,bool,bool,bool,bool,bool,bool,bool))
,	O
true	int
,	O
false	int
)	O
;	O
if	O
(	O
!	O
no_translator	bool
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Created %s.\n"	*(char)
)	O
,	O
output_file	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Try '%s --help' for more information.\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Usage: %s [OPTION]\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Creates a new PO file, initializing the meta information with values from the\nuser's environment.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Mandatory arguments to long options are mandatory for short options too.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Input file location:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -i, --input=INPUTFILE       input POT file\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"If no input file is given, the current directory is searched for the POT file.\nIf it is -, standard input is read.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Output file location:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -o, --output-file=FILE      write output to specified PO file\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"If no output file is given, it depends on the --locale option or the user's\nlocale setting.  If it is -, the results are written to standard output.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Input file syntax:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -P, --properties-input      input file is in Java .properties syntax\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --stringtable-input     input file is in NeXTstep/GNUstep .strings syntax\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Output details:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -l, --locale=LL_CC[.ENCODING]  set target locale\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --no-translator         assume the PO file is automatically generated\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --color                 use colors and other text attributes always\n      --color=WHEN            use colors and other text attributes if WHEN.\n                              WHEN may be 'always', 'never', 'auto', or 'html'.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --style=STYLEFILE       specify CSS style rule file for --color\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -p, --properties-output     write out a Java .properties file\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --stringtable-output    write out a NeXTstep/GNUstep .strings file\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -w, --width=NUMBER          set output page width\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --no-wrap               do not break long message lines, longer than\n                              the output page width, into several lines\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Informative output:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -h, --help                  display this help and exit\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -V, --version               output version information and exit\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"Report bugs to <bug-gnu-gettext@gnu.org>.\n"	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
find_pot	()->(*(char))
(	O
)	O
{	O
DIR	struct
*	O
dirp	*(struct)
;	O
char	O
*	O
found	*(char)
=	O
NULL	O
;	O
dirp	*(struct)
=	O
opendir	(*(char))->(*(struct))
(	O
"."	*(char)
)	O
;	O
if	O
(	O
dirp	*(struct)
!=	O
NULL	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dp	*(struct(long,long,short,char,array(char)))
;	O
errno	O
=	O
0	int
;	O
dp	*(struct(long,long,short,char,array(char)))
=	O
readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
dirp	*(struct)
)	O
;	O
if	O
(	O
dp	*(struct(long,long,short,char,array(char)))
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
=	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
;	O
size_t	long
namlen	long
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
if	O
(	O
namlen	long
>	O
4	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
name	*(char)
+	O
namlen	long
-	O
4	int
,	O
".pot"	*(char)
,	O
4	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
found	*(char)
==	O
NULL	O
)	O
found	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
else	O
{	O
multiline_error	(*(char),*(char))->(void)
(	O
xstrdup	(*(char))->(*(char))
(	O
""	*(char)
)	O
,	O
xstrdup	(*(char))->(*(char))
(	O
_	O
(	O
"Found more than one .pot file.\nPlease specify the input .pot file through the --input option.\n"	*(char)
)	O
)	O
)	O
;	O
usage	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
errno	O
!=	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"error reading current directory"	*(char)
)	O
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
closedir	(*(struct))->(int)
(	O
dirp	*(struct)
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"error reading current directory"	*(char)
)	O
)	O
;	O
if	O
(	O
found	*(char)
!=	O
NULL	O
)	O
return	O
found	*(char)
;	O
}	O
multiline_error	(*(char),*(char))->(void)
(	O
xstrdup	(*(char))->(*(char))
(	O
""	*(char)
)	O
,	O
xstrdup	(*(char))->(*(char))
(	O
_	O
(	O
"Found no .pot file in the current directory.\nPlease specify the input .pot file through the --input option.\n"	*(char)
)	O
)	O
)	O
;	O
usage	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
catalogname_for_locale	(*(char))->(*(char))
(	O
const	O
char	O
*	O
locale	*(char)
)	O
{	O
static	O
const	O
char	O
*	O
locales_with_principal_territory	array(*(char))
[	O
]	O
=	O
{	O
"ace_ID"	*(char)
,	O
"af_ZA"	*(char)
,	O
"ak_GH"	*(char)
,	O
"am_ET"	*(char)
,	O
"an_ES"	*(char)
,	O
"ang_GB"	*(char)
,	O
"arn_CL"	*(char)
,	O
"as_IN"	*(char)
,	O
"ast_ES"	*(char)
,	O
"av_RU"	*(char)
,	O
"awa_IN"	*(char)
,	O
"az_AZ"	*(char)
,	O
"ban_ID"	*(char)
,	O
"be_BY"	*(char)
,	O
"bej_SD"	*(char)
,	O
"bem_ZM"	*(char)
,	O
"bg_BG"	*(char)
,	O
"bho_IN"	*(char)
,	O
"bik_PH"	*(char)
,	O
"bin_NG"	*(char)
,	O
"bm_ML"	*(char)
,	O
"bn_IN"	*(char)
,	O
"bo_CN"	*(char)
,	O
"br_FR"	*(char)
,	O
"bs_BA"	*(char)
,	O
"bug_ID"	*(char)
,	O
"ca_ES"	*(char)
,	O
"ce_RU"	*(char)
,	O
"ceb_PH"	*(char)
,	O
"co_FR"	*(char)
,	O
"cr_CA"	*(char)
,	O
"cs_CZ"	*(char)
,	O
"csb_PL"	*(char)
,	O
"cy_GB"	*(char)
,	O
"da_DK"	*(char)
,	O
"de_DE"	*(char)
,	O
"din_SD"	*(char)
,	O
"doi_IN"	*(char)
,	O
"dsb_DE"	*(char)
,	O
"dv_MV"	*(char)
,	O
"dz_BT"	*(char)
,	O
"ee_GH"	*(char)
,	O
"el_GR"	*(char)
,	O
"es_ES"	*(char)
,	O
"et_EE"	*(char)
,	O
"fa_IR"	*(char)
,	O
"fi_FI"	*(char)
,	O
"fil_PH"	*(char)
,	O
"fj_FJ"	*(char)
,	O
"fo_FO"	*(char)
,	O
"fon_BJ"	*(char)
,	O
"fr_FR"	*(char)
,	O
"fur_IT"	*(char)
,	O
"fy_NL"	*(char)
,	O
"ga_IE"	*(char)
,	O
"gd_GB"	*(char)
,	O
"gon_IN"	*(char)
,	O
"gsw_CH"	*(char)
,	O
"gu_IN"	*(char)
,	O
"he_IL"	*(char)
,	O
"hi_IN"	*(char)
,	O
"hil_PH"	*(char)
,	O
"hr_HR"	*(char)
,	O
"hsb_DE"	*(char)
,	O
"ht_HT"	*(char)
,	O
"hu_HU"	*(char)
,	O
"hy_AM"	*(char)
,	O
"id_ID"	*(char)
,	O
"ig_NG"	*(char)
,	O
"ii_CN"	*(char)
,	O
"ilo_PH"	*(char)
,	O
"is_IS"	*(char)
,	O
"it_IT"	*(char)
,	O
"ja_JP"	*(char)
,	O
"jab_NG"	*(char)
,	O
"jv_ID"	*(char)
,	O
"ka_GE"	*(char)
,	O
"kab_DZ"	*(char)
,	O
"kaj_NG"	*(char)
,	O
"kam_KE"	*(char)
,	O
"kmb_AO"	*(char)
,	O
"kcg_NG"	*(char)
,	O
"kdm_NG"	*(char)
,	O
"kg_CD"	*(char)
,	O
"kk_KZ"	*(char)
,	O
"kl_GL"	*(char)
,	O
"km_KH"	*(char)
,	O
"kn_IN"	*(char)
,	O
"ko_KR"	*(char)
,	O
"kok_IN"	*(char)
,	O
"kr_NG"	*(char)
,	O
"kru_IN"	*(char)
,	O
"lg_UG"	*(char)
,	O
"li_BE"	*(char)
,	O
"lo_LA"	*(char)
,	O
"lt_LT"	*(char)
,	O
"lu_CD"	*(char)
,	O
"lua_CD"	*(char)
,	O
"luo_KE"	*(char)
,	O
"lv_LV"	*(char)
,	O
"mad_ID"	*(char)
,	O
"mag_IN"	*(char)
,	O
"mai_IN"	*(char)
,	O
"mak_ID"	*(char)
,	O
"man_ML"	*(char)
,	O
"men_SL"	*(char)
,	O
"mg_MG"	*(char)
,	O
"mi_NZ"	*(char)
,	O
"min_ID"	*(char)
,	O
"mk_MK"	*(char)
,	O
"ml_IN"	*(char)
,	O
"mn_MN"	*(char)
,	O
"mni_IN"	*(char)
,	O
"mos_BF"	*(char)
,	O
"mr_IN"	*(char)
,	O
"ms_MY"	*(char)
,	O
"mt_MT"	*(char)
,	O
"mwr_IN"	*(char)
,	O
"my_MM"	*(char)
,	O
"na_NR"	*(char)
,	O
"nah_MX"	*(char)
,	O
"nap_IT"	*(char)
,	O
"nb_NO"	*(char)
,	O
"nds_DE"	*(char)
,	O
"ne_NP"	*(char)
,	O
"nl_NL"	*(char)
,	O
"nn_NO"	*(char)
,	O
"no_NO"	*(char)
,	O
"nr_ZA"	*(char)
,	O
"nso_ZA"	*(char)
,	O
"nym_TZ"	*(char)
,	O
"nyn_UG"	*(char)
,	O
"oc_FR"	*(char)
,	O
"oj_CA"	*(char)
,	O
"or_IN"	*(char)
,	O
"pa_IN"	*(char)
,	O
"pag_PH"	*(char)
,	O
"pam_PH"	*(char)
,	O
"pap_AN"	*(char)
,	O
"pbb_CO"	*(char)
,	O
"pl_PL"	*(char)
,	O
"ps_AF"	*(char)
,	O
"pt_PT"	*(char)
,	O
"raj_IN"	*(char)
,	O
"rm_CH"	*(char)
,	O
"rn_BI"	*(char)
,	O
"ro_RO"	*(char)
,	O
"ru_RU"	*(char)
,	O
"sa_IN"	*(char)
,	O
"sah_RU"	*(char)
,	O
"sas_ID"	*(char)
,	O
"sat_IN"	*(char)
,	O
"sc_IT"	*(char)
,	O
"scn_IT"	*(char)
,	O
"sg_CF"	*(char)
,	O
"shn_MM"	*(char)
,	O
"si_LK"	*(char)
,	O
"sid_ET"	*(char)
,	O
"sk_SK"	*(char)
,	O
"sl_SI"	*(char)
,	O
"smn_FI"	*(char)
,	O
"sms_FI"	*(char)
,	O
"so_SO"	*(char)
,	O
"sq_AL"	*(char)
,	O
"sr_RS"	*(char)
,	O
"srr_SN"	*(char)
,	O
"suk_TZ"	*(char)
,	O
"sus_GN"	*(char)
,	O
"sv_SE"	*(char)
,	O
"te_IN"	*(char)
,	O
"tem_SL"	*(char)
,	O
"tet_ID"	*(char)
,	O
"tg_TJ"	*(char)
,	O
"th_TH"	*(char)
,	O
"tiv_NG"	*(char)
,	O
"tk_TM"	*(char)
,	O
"tl_PH"	*(char)
,	O
"to_TO"	*(char)
,	O
"tr_TR"	*(char)
,	O
"tum_MW"	*(char)
,	O
"ug_CN"	*(char)
,	O
"uk_UA"	*(char)
,	O
"umb_AO"	*(char)
,	O
"ur_PK"	*(char)
,	O
"uz_UZ"	*(char)
,	O
"ve_ZA"	*(char)
,	O
"vi_VN"	*(char)
,	O
"wa_BE"	*(char)
,	O
"wal_ET"	*(char)
,	O
"war_PH"	*(char)
,	O
"wen_DE"	*(char)
,	O
"yao_MW"	*(char)
,	O
"zap_MX"	*(char)
}	O
;	O
const	O
char	O
*	O
dot	*(char)
;	O
size_t	long
i	long
;	O
dot	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
locale	*(char)
,	O
'.'	O
)	O
;	O
if	O
(	O
dot	*(char)
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
codeset_end	*(char)
;	O
char	O
*	O
shorter_locale	*(char)
;	O
codeset_end	*(char)
=	O
strpbrk	(*(char),*(char))->(*(char))
(	O
dot	*(char)
+	O
1	int
,	O
"_@"	*(char)
)	O
;	O
if	O
(	O
codeset_end	*(char)
==	O
NULL	O
)	O
codeset_end	*(char)
=	O
dot	*(char)
+	O
strlen	(*(char))->(long)
(	O
dot	*(char)
)	O
;	O
shorter_locale	*(char)
=	O
XNMALLOC	O
(	O
strlen	(*(char))->(long)
(	O
locale	*(char)
)	O
,	O
char	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
shorter_locale	*(char)
,	O
locale	*(char)
,	O
dot	*(char)
-	O
locale	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
shorter_locale	*(char)
+	O
(	O
dot	*(char)
-	O
locale	*(char)
)	O
,	O
codeset_end	*(char)
)	O
;	O
locale	*(char)
=	O
shorter_locale	*(char)
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
SIZEOF	O
(	O
locales_with_principal_territory	array(*(char))
)	O
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
locale	*(char)
,	O
locales_with_principal_territory	array(*(char))
[	O
i	long
]	O
)	O
==	O
0	int
)	O
{	O
const	O
char	O
*	O
language_end	*(char)
;	O
size_t	long
len	long
;	O
char	O
*	O
shorter_locale	*(char)
;	O
language_end	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
locale	*(char)
,	O
'_'	O
)	O
;	O
if	O
(	O
language_end	*(char)
==	O
NULL	O
)	O
abort	()->(void)
(	O
)	O
;	O
len	long
=	O
language_end	*(char)
-	O
locale	*(char)
;	O
shorter_locale	*(char)
=	O
XNMALLOC	O
(	O
len	long
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
shorter_locale	*(char)
,	O
locale	*(char)
,	O
len	long
)	O
;	O
shorter_locale	*(char)
[	O
len	long
]	O
=	O
'\0'	O
;	O
locale	*(char)
=	O
shorter_locale	*(char)
;	O
break	O
;	O
}	O
return	O
locale	*(char)
;	O
}	O
static	O
const	O
char	O
*	O
language_of_locale	(*(char))->(*(char))
(	O
const	O
char	O
*	O
locale	*(char)
)	O
{	O
const	O
char	O
*	O
language_end	*(char)
;	O
language_end	*(char)
=	O
strpbrk	(*(char),*(char))->(*(char))
(	O
locale	*(char)
,	O
"_.@"	*(char)
)	O
;	O
if	O
(	O
language_end	*(char)
!=	O
NULL	O
)	O
{	O
size_t	long
len	long
;	O
char	O
*	O
result	*(*(void))
;	O
len	long
=	O
language_end	*(char)
-	O
locale	*(char)
;	O
result	*(*(void))
=	O
XNMALLOC	O
(	O
len	long
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
result	*(*(void))
,	O
locale	*(char)
,	O
len	long
)	O
;	O
result	*(*(void))
[	O
len	long
]	O
=	O
'\0'	O
;	O
return	O
result	*(*(void))
;	O
}	O
else	O
return	O
locale	*(char)
;	O
}	O
static	O
const	O
char	O
*	O
canonical_locale_charset	()->(*(char))
(	O
)	O
{	O
const	O
char	O
*	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
;	O
char	O
*	O
old_LC_ALL	*(char)
;	O
const	O
char	O
*	O
charset	*(char)
;	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
=	O
getenv	(*(char))->(*(char))
(	O
"LC_ALL"	*(char)
)	O
;	O
old_LC_ALL	*(char)
=	O
(	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
!=	O
NULL	O
?	O
xstrdup	(*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
)	O
:	O
NULL	O
)	O
;	O
xsetenv	(*(char),*(char),int)->(void)
(	O
"LC_ALL"	*(char)
,	O
locale	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
==	O
NULL	O
)	O
charset	*(char)
=	O
""	*(char)
;	O
else	O
charset	*(char)
=	O
locale_charset	()->(*(char))
(	O
)	O
;	O
if	O
(	O
old_LC_ALL	*(char)
!=	O
NULL	O
)	O
xsetenv	(*(char),*(char),int)->(void)
(	O
"LC_ALL"	*(char)
,	O
old_LC_ALL	*(char)
,	O
1	int
)	O
,	O
free	(*(void))->(void)
(	O
old_LC_ALL	*(char)
)	O
;	O
else	O
unsetenv	(*(char))->(int)
(	O
"LC_ALL"	*(char)
)	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
charset	*(char)
=	O
po_charset_canonicalize	(*(char))->(*(char))
(	O
charset	*(char)
)	O
;	O
if	O
(	O
charset	*(char)
==	O
NULL	O
)	O
charset	*(char)
=	O
po_charset_ascii	*(char)
;	O
return	O
charset	*(char)
;	O
}	O
static	O
const	O
char	O
*	O
englishname_of_language	()->(*(char))
(	O
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
language_table_size	long
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
language_table	array(struct(*(char),*(char)))
[	O
i	long
]	O
.	O
code	*(char)
,	O
language	*(char)
)	O
==	O
0	int
)	O
return	O
language_table	array(struct(*(char),*(char)))
[	O
i	long
]	O
.	O
english	*(char)
;	O
return	O
xasprintf	(*(char))->(*(char))
(	O
"Language %s"	*(char)
,	O
language	*(char)
)	O
;	O
}	O
static	O
const	O
char	O
*	O
project_id	(*(char))->(*(char))
(	O
const	O
char	O
*	O
header	*(char)
)	O
{	O
const	O
char	O
*	O
old_field	*(char)
;	O
old_field	*(char)
=	O
get_field	(*(char),*(char))->(*(char))
(	O
header	*(char)
,	O
"Project-Id-Version"	*(char)
)	O
;	O
if	O
(	O
old_field	*(char)
!=	O
NULL	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
old_field	*(char)
,	O
"PACKAGE VERSION"	*(char)
)	O
!=	O
0	int
)	O
{	O
const	O
char	O
*	O
last_space	*(char)
;	O
last_space	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
old_field	*(char)
,	O
' '	O
)	O
;	O
if	O
(	O
last_space	*(char)
!=	O
NULL	O
)	O
{	O
while	O
(	O
last_space	*(char)
>	O
old_field	*(char)
&&	O
last_space	*(char)
[	O
-	O
1	int
]	O
==	O
' '	O
)	O
last_space	*(char)
--	O
;	O
if	O
(	O
last_space	*(char)
>	O
old_field	*(char)
)	O
{	O
size_t	long
package_len	long
=	O
last_space	*(char)
-	O
old_field	*(char)
;	O
char	O
*	O
package	*(char)
=	O
XNMALLOC	O
(	O
package_len	long
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
package	*(char)
,	O
old_field	*(char)
,	O
package_len	long
)	O
;	O
package	*(char)
[	O
package_len	long
]	O
=	O
'\0'	O
;	O
return	O
package	*(char)
;	O
}	O
}	O
return	O
old_field	*(char)
;	O
}	O
{	O
const	O
char	O
*	O
gettextlibdir	*(char)
;	O
char	O
*	O
prog	*(char)
;	O
char	O
*	O
argv	*(*(char))
[	O
3	int
]	O
;	O
pid_t	int
child	int
;	O
int	O
fd	int
[	O
1	int
]	O
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
line	long
;	O
size_t	long
linesize	long
;	O
size_t	long
linelen	long
;	O
int	O
exitstatus	int
;	O
gettextlibdir	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"GETTEXTLIBDIR_SRCDIR"	*(char)
)	O
;	O
if	O
(	O
gettextlibdir	*(char)
==	O
NULL	O
||	O
gettextlibdir	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
gettextlibdir	*(char)
=	O
relocate	O
(	O
LIBDIR	*(char)
"/gettext"	*(char)
)	O
;	O
prog	*(char)
=	O
xconcatenated_filename	(*(char),*(char),*(char))->(*(char))
(	O
gettextlibdir	*(char)
,	O
"project-id"	*(char)
,	O
NULL	O
)	O
;	O
argv	*(*(char))
[	O
0	int
]	O
=	O
BOURNE_SHELL	*(char)
;	O
argv	*(*(char))
[	O
1	int
]	O
=	O
prog	*(char)
;	O
argv	*(*(char))
[	O
2	int
]	O
=	O
NULL	O
;	O
child	int
=	O
create_pipe_in	(*(char),*(char),*(*(char)),*(char),bool,bool,bool,array(int))->(int)
(	O
prog	*(char)
,	O
BOURNE_SHELL	*(char)
,	O
argv	*(*(char))
,	O
DEV_NULL	*(char)
,	O
false	int
,	O
true	int
,	O
false	int
,	O
fd	int
)	O
;	O
if	O
(	O
child	int
==	O
-	O
1	int
)	O
goto	O
failed	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fd	int
[	O
0	int
]	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"fdopen() failed"	*(char)
)	O
)	O
;	O
goto	O
failed	O
;	O
}	O
line	long
=	O
NULL	O
;	O
linesize	long
=	O
0	int
;	O
linelen	long
=	O
getline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
line	long
,	O
&	O
linesize	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
linelen	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess I/O error"	*(char)
)	O
,	O
prog	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
goto	O
failed	O
;	O
}	O
if	O
(	O
linelen	long
>	O
0	int
&&	O
line	long
[	O
linelen	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
line	long
[	O
linelen	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exitstatus	int
=	O
wait_subprocess	(int,*(char),bool,bool,bool,bool,*(int))->(int)
(	O
child	int
,	O
prog	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
false	int
,	O
NULL	O
)	O
;	O
if	O
(	O
exitstatus	int
!=	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed with exit code %d"	*(char)
)	O
,	O
prog	*(char)
,	O
exitstatus	int
)	O
;	O
goto	O
failed	O
;	O
}	O
return	O
line	long
;	O
}	O
failed	O
:	O
return	O
"PACKAGE"	*(char)
;	O
}	O
static	O
const	O
char	O
*	O
project_id_version	(*(char))->(*(char))
(	O
const	O
char	O
*	O
header	*(char)
)	O
{	O
const	O
char	O
*	O
old_field	*(char)
;	O
old_field	*(char)
=	O
get_field	(*(char),*(char))->(*(char))
(	O
header	*(char)
,	O
"Project-Id-Version"	*(char)
)	O
;	O
if	O
(	O
old_field	*(char)
!=	O
NULL	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
old_field	*(char)
,	O
"PACKAGE VERSION"	*(char)
)	O
!=	O
0	int
)	O
return	O
old_field	*(char)
;	O
{	O
const	O
char	O
*	O
gettextlibdir	*(char)
;	O
char	O
*	O
prog	*(char)
;	O
char	O
*	O
argv	*(*(char))
[	O
4	int
]	O
;	O
pid_t	int
child	int
;	O
int	O
fd	int
[	O
1	int
]	O
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
line	long
;	O
size_t	long
linesize	long
;	O
size_t	long
linelen	long
;	O
int	O
exitstatus	int
;	O
gettextlibdir	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"GETTEXTLIBDIR_SRCDIR"	*(char)
)	O
;	O
if	O
(	O
gettextlibdir	*(char)
==	O
NULL	O
||	O
gettextlibdir	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
gettextlibdir	*(char)
=	O
relocate	O
(	O
LIBDIR	*(char)
"/gettext"	*(char)
)	O
;	O
prog	*(char)
=	O
xconcatenated_filename	(*(char),*(char),*(char))->(*(char))
(	O
gettextlibdir	*(char)
,	O
"project-id"	*(char)
,	O
NULL	O
)	O
;	O
argv	*(*(char))
[	O
0	int
]	O
=	O
BOURNE_SHELL	*(char)
;	O
argv	*(*(char))
[	O
1	int
]	O
=	O
prog	*(char)
;	O
argv	*(*(char))
[	O
2	int
]	O
=	O
"yes"	*(char)
;	O
argv	*(*(char))
[	O
3	int
]	O
=	O
NULL	O
;	O
child	int
=	O
create_pipe_in	(*(char),*(char),*(*(char)),*(char),bool,bool,bool,array(int))->(int)
(	O
prog	*(char)
,	O
BOURNE_SHELL	*(char)
,	O
argv	*(*(char))
,	O
DEV_NULL	*(char)
,	O
false	int
,	O
true	int
,	O
false	int
,	O
fd	int
)	O
;	O
if	O
(	O
child	int
==	O
-	O
1	int
)	O
goto	O
failed	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fd	int
[	O
0	int
]	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"fdopen() failed"	*(char)
)	O
)	O
;	O
goto	O
failed	O
;	O
}	O
line	long
=	O
NULL	O
;	O
linesize	long
=	O
0	int
;	O
linelen	long
=	O
getline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
line	long
,	O
&	O
linesize	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
linelen	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess I/O error"	*(char)
)	O
,	O
prog	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
goto	O
failed	O
;	O
}	O
if	O
(	O
linelen	long
>	O
0	int
&&	O
line	long
[	O
linelen	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
line	long
[	O
linelen	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exitstatus	int
=	O
wait_subprocess	(int,*(char),bool,bool,bool,bool,*(int))->(int)
(	O
child	int
,	O
prog	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
false	int
,	O
NULL	O
)	O
;	O
if	O
(	O
exitstatus	int
!=	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed with exit code %d"	*(char)
)	O
,	O
prog	*(char)
,	O
exitstatus	int
)	O
;	O
goto	O
failed	O
;	O
}	O
return	O
line	long
;	O
}	O
failed	O
:	O
return	O
"PACKAGE VERSION"	*(char)
;	O
}	O
static	O
const	O
char	O
*	O
po_revision_date	(*(char))->(*(char))
(	O
const	O
char	O
*	O
header	*(char)
)	O
{	O
if	O
(	O
no_translator	bool
)	O
return	O
get_field	(*(char),*(char))->(*(char))
(	O
header	*(char)
,	O
"POT-Creation-Date"	*(char)
)	O
;	O
else	O
{	O
time_t	long
now	long
;	O
time	struct(long,long)
(	O
&	O
now	long
)	O
;	O
return	O
po_strftime	(*(long))->(*(char))
(	O
&	O
now	long
)	O
;	O
}	O
}	O
static	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
get_user_pwd	()->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
)	O
{	O
const	O
char	O
*	O
username	*(char)
;	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
userpasswd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
username	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"USER"	*(char)
)	O
;	O
if	O
(	O
username	*(char)
!=	O
NULL	O
)	O
{	O
errno	O
=	O
0	int
;	O
userpasswd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
username	*(char)
)	O
;	O
if	O
(	O
userpasswd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
!=	O
NULL	O
)	O
return	O
userpasswd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
if	O
(	O
errno	O
!=	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"getpwnam(\"%s\")"	*(char)
,	O
username	*(char)
)	O
;	O
}	O
username	*(char)
=	O
getlogin	()->(*(char))
(	O
)	O
;	O
if	O
(	O
username	*(char)
!=	O
NULL	O
)	O
{	O
errno	O
=	O
0	int
;	O
userpasswd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
username	*(char)
)	O
;	O
if	O
(	O
userpasswd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
!=	O
NULL	O
)	O
return	O
userpasswd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
if	O
(	O
errno	O
!=	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"getpwnam(\"%s\")"	*(char)
,	O
username	*(char)
)	O
;	O
}	O
errno	O
=	O
0	int
;	O
userpasswd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwuid	(int)->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
getuid	()->(int)
(	O
)	O
)	O
;	O
if	O
(	O
userpasswd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
!=	O
NULL	O
)	O
return	O
userpasswd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
if	O
(	O
errno	O
!=	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"getpwuid(%ju)"	*(char)
,	O
(	O
uintmax_t	long
)	O
getuid	()->(int)
(	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_user_fullname	()->(*(char))
(	O
)	O
{	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pwd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
pwd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
get_user_pwd	()->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
)	O
;	O
if	O
(	O
pwd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
fullname	*(char)
;	O
const	O
char	O
*	O
fullname_end	*(char)
;	O
char	O
*	O
result	*(*(void))
;	O
fullname	*(char)
=	O
pwd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_gecos	*(char)
;	O
fullname_end	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
fullname	*(char)
,	O
','	O
)	O
;	O
if	O
(	O
fullname_end	*(char)
==	O
NULL	O
)	O
fullname_end	*(char)
=	O
fullname	*(char)
+	O
strlen	(*(char))->(long)
(	O
fullname	*(char)
)	O
;	O
result	*(*(void))
=	O
XNMALLOC	O
(	O
fullname_end	*(char)
-	O
fullname	*(char)
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
result	*(*(void))
,	O
fullname	*(char)
,	O
fullname_end	*(char)
-	O
fullname	*(char)
)	O
;	O
result	*(*(void))
[	O
fullname_end	*(char)
-	O
fullname	*(char)
]	O
=	O
'\0'	O
;	O
return	O
result	*(*(void))
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_user_email	()->(*(char))
(	O
)	O
{	O
{	O
const	O
char	O
*	O
prog	*(char)
=	O
relocate	O
(	O
LIBDIR	*(char)
"/gettext/user-email"	*(char)
)	O
;	O
char	O
*	O
argv	*(*(char))
[	O
4	int
]	O
;	O
pid_t	int
child	int
;	O
int	O
fd	int
[	O
1	int
]	O
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
line	long
;	O
size_t	long
linesize	long
;	O
size_t	long
linelen	long
;	O
int	O
exitstatus	int
;	O
argv	*(*(char))
[	O
0	int
]	O
=	O
BOURNE_SHELL	*(char)
;	O
argv	*(*(char))
[	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
prog	*(char)
;	O
argv	*(*(char))
[	O
2	int
]	O
=	O
(	O
char	O
*	O
)	O
_	O
(	O
"The new message catalog should contain your email address, so that users can\ngive you feedback about the translations, and so that maintainers can contact\nyou in case of unexpected technical problems.\n"	*(char)
)	O
;	O
argv	*(*(char))
[	O
3	int
]	O
=	O
NULL	O
;	O
child	int
=	O
create_pipe_in	(*(char),*(char),*(*(char)),*(char),bool,bool,bool,array(int))->(int)
(	O
prog	*(char)
,	O
BOURNE_SHELL	*(char)
,	O
argv	*(*(char))
,	O
DEV_NULL	*(char)
,	O
false	int
,	O
true	int
,	O
false	int
,	O
fd	int
)	O
;	O
if	O
(	O
child	int
==	O
-	O
1	int
)	O
goto	O
failed	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fd	int
[	O
0	int
]	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"fdopen() failed"	*(char)
)	O
)	O
;	O
goto	O
failed	O
;	O
}	O
line	long
=	O
NULL	O
;	O
linesize	long
=	O
0	int
;	O
linelen	long
=	O
getline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
line	long
,	O
&	O
linesize	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
linelen	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess I/O error"	*(char)
)	O
,	O
prog	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
goto	O
failed	O
;	O
}	O
if	O
(	O
linelen	long
>	O
0	int
&&	O
line	long
[	O
linelen	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
line	long
[	O
linelen	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exitstatus	int
=	O
wait_subprocess	(int,*(char),bool,bool,bool,bool,*(int))->(int)
(	O
child	int
,	O
prog	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
false	int
,	O
NULL	O
)	O
;	O
if	O
(	O
exitstatus	int
!=	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed with exit code %d"	*(char)
)	O
,	O
prog	*(char)
,	O
exitstatus	int
)	O
;	O
goto	O
failed	O
;	O
}	O
return	O
line	long
;	O
}	O
failed	O
:	O
return	O
"EMAIL@ADDRESS"	*(char)
;	O
}	O
static	O
const	O
char	O
*	O
last_translator	()->(*(char))
(	O
)	O
{	O
if	O
(	O
no_translator	bool
)	O
return	O
"Automatically generated"	*(char)
;	O
else	O
{	O
const	O
char	O
*	O
fullname	*(char)
=	O
get_user_fullname	()->(*(char))
(	O
)	O
;	O
const	O
char	O
*	O
email	*(char)
=	O
get_user_email	()->(*(char))
(	O
)	O
;	O
if	O
(	O
fullname	*(char)
!=	O
NULL	O
)	O
return	O
xasprintf	(*(char))->(*(char))
(	O
"%s <%s>"	*(char)
,	O
fullname	*(char)
,	O
email	*(char)
)	O
;	O
else	O
return	O
xasprintf	(*(char))->(*(char))
(	O
"<%s>"	*(char)
,	O
email	*(char)
)	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
language_team_englishname	()->(*(char))
(	O
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
language_variant_table_size	long
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
language_variant_table	array(struct(*(char),*(char)))
[	O
i	long
]	O
.	O
code	*(char)
,	O
catalogname	*(char)
)	O
==	O
0	int
)	O
return	O
language_variant_table	array(struct(*(char),*(char)))
[	O
i	long
]	O
.	O
english	*(char)
;	O
return	O
englishname_of_language	()->(*(char))
(	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
language_team_address	()->(*(char))
(	O
)	O
{	O
{	O
const	O
char	O
*	O
prog	*(char)
=	O
relocate	O
(	O
PROJECTSDIR	O
"/team-address"	*(char)
)	O
;	O
char	O
*	O
argv	*(*(char))
[	O
7	int
]	O
;	O
pid_t	int
child	int
;	O
int	O
fd	int
[	O
1	int
]	O
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
line	long
;	O
size_t	long
linesize	long
;	O
size_t	long
linelen	long
;	O
int	O
exitstatus	int
;	O
argv	*(*(char))
[	O
0	int
]	O
=	O
BOURNE_SHELL	*(char)
;	O
argv	*(*(char))
[	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
prog	*(char)
;	O
argv	*(*(char))
[	O
2	int
]	O
=	O
(	O
char	O
*	O
)	O
relocate	O
(	O
PROJECTSDIR	O
)	O
;	O
argv	*(*(char))
[	O
3	int
]	O
=	O
(	O
char	O
*	O
)	O
relocate	O
(	O
LIBDIR	*(char)
"/gettext"	*(char)
)	O
;	O
argv	*(*(char))
[	O
4	int
]	O
=	O
(	O
char	O
*	O
)	O
catalogname	*(char)
;	O
argv	*(*(char))
[	O
5	int
]	O
=	O
(	O
char	O
*	O
)	O
language	*(char)
;	O
argv	*(*(char))
[	O
6	int
]	O
=	O
NULL	O
;	O
child	int
=	O
create_pipe_in	(*(char),*(char),*(*(char)),*(char),bool,bool,bool,array(int))->(int)
(	O
prog	*(char)
,	O
BOURNE_SHELL	*(char)
,	O
argv	*(*(char))
,	O
DEV_NULL	*(char)
,	O
false	int
,	O
true	int
,	O
false	int
,	O
fd	int
)	O
;	O
if	O
(	O
child	int
==	O
-	O
1	int
)	O
goto	O
failed	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fd	int
[	O
0	int
]	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"fdopen() failed"	*(char)
)	O
)	O
;	O
goto	O
failed	O
;	O
}	O
line	long
=	O
NULL	O
;	O
linesize	long
=	O
0	int
;	O
linelen	long
=	O
getline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
line	long
,	O
&	O
linesize	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
linelen	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
line	long
=	O
""	*(char)
;	O
else	O
if	O
(	O
linelen	long
>	O
0	int
&&	O
line	long
[	O
linelen	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
line	long
[	O
linelen	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exitstatus	int
=	O
wait_subprocess	(int,*(char),bool,bool,bool,bool,*(int))->(int)
(	O
child	int
,	O
prog	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
false	int
,	O
NULL	O
)	O
;	O
if	O
(	O
exitstatus	int
!=	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed with exit code %d"	*(char)
)	O
,	O
prog	*(char)
,	O
exitstatus	int
)	O
;	O
goto	O
failed	O
;	O
}	O
return	O
line	long
;	O
}	O
failed	O
:	O
return	O
""	*(char)
;	O
}	O
static	O
const	O
char	O
*	O
language_team	()->(*(char))
(	O
)	O
{	O
if	O
(	O
no_translator	bool
)	O
return	O
"none"	*(char)
;	O
else	O
{	O
const	O
char	O
*	O
englishname	*(char)
=	O
language_team_englishname	()->(*(char))
(	O
)	O
;	O
const	O
char	O
*	O
address	*(char)
=	O
language_team_address	()->(*(char))
(	O
)	O
;	O
if	O
(	O
address	*(char)
!=	O
NULL	O
&&	O
address	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
return	O
xasprintf	(*(char))->(*(char))
(	O
"%s %s"	*(char)
,	O
englishname	*(char)
,	O
address	*(char)
)	O
;	O
else	O
return	O
englishname	*(char)
;	O
}	O
}	O
static	O
const	O
char	O
*	O
language_value	()->(*(char))
(	O
)	O
{	O
return	O
catalogname	*(char)
;	O
}	O
static	O
const	O
char	O
*	O
mime_version	()->(*(char))
(	O
)	O
{	O
return	O
"1.0"	*(char)
;	O
}	O
static	O
const	O
char	O
*	O
content_type	(*(char))->(*(char))
(	O
const	O
char	O
*	O
header	*(char)
)	O
{	O
bool	bool
was_utf8	bool
;	O
const	O
char	O
*	O
old_field	*(char)
;	O
was_utf8	bool
=	O
false	int
;	O
old_field	*(char)
=	O
get_field	(*(char),*(char))->(*(char))
(	O
header	*(char)
,	O
"Content-Type"	*(char)
)	O
;	O
if	O
(	O
old_field	*(char)
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
charsetstr	*(char)
=	O
c_strstr	(*(char),*(char))->(*(char))
(	O
old_field	*(char)
,	O
"charset="	*(char)
)	O
;	O
if	O
(	O
charsetstr	*(char)
!=	O
NULL	O
)	O
{	O
charsetstr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
"charset="	*(char)
)	O
;	O
was_utf8	bool
=	O
(	O
c_strcasecmp	(*(char),*(char))->(int)
(	O
charsetstr	*(char)
,	O
"UTF-8"	*(char)
)	O
==	O
0	int
)	O
;	O
}	O
}	O
return	O
xasprintf	(*(char))->(*(char))
(	O
"text/plain; charset=%s"	*(char)
,	O
was_utf8	bool
?	O
"UTF-8"	*(char)
:	O
canonical_locale_charset	()->(*(char))
(	O
)	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
content_transfer_encoding	()->(*(char))
(	O
)	O
{	O
return	O
"8bit"	*(char)
;	O
}	O
static	O
const	O
char	O
*	O
plural_forms	()->(*(char))
(	O
)	O
{	O
const	O
char	O
*	O
gettextcldrdir	*(char)
;	O
char	O
*	O
prog	*(char)
=	O
NULL	O
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
plural_table_size	long
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
plural_table	array(struct(*(char),*(char),*(char)))
[	O
i	long
]	O
.	O
lang	*(char)
,	O
catalogname	*(char)
)	O
==	O
0	int
)	O
return	O
plural_table	array(struct(*(char),*(char),*(char)))
[	O
i	long
]	O
.	O
value	*(char)
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
plural_table_size	long
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
plural_table	array(struct(*(char),*(char),*(char)))
[	O
i	long
]	O
.	O
lang	*(char)
,	O
language	*(char)
)	O
==	O
0	int
)	O
return	O
plural_table	array(struct(*(char),*(char),*(char)))
[	O
i	long
]	O
.	O
value	*(char)
;	O
gettextcldrdir	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"GETTEXTCLDRDIR"	*(char)
)	O
;	O
if	O
(	O
gettextcldrdir	*(char)
!=	O
NULL	O
&&	O
gettextcldrdir	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
gettextlibdir	*(char)
;	O
char	O
*	O
dirs	array(*(char))
[	O
3	int
]	O
,	O
*	O
last_dir	*(char)
;	O
char	O
*	O
argv	*(*(char))
[	O
4	int
]	O
;	O
pid_t	int
child	int
;	O
int	O
fd	int
[	O
1	int
]	O
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
line	long
;	O
size_t	long
linesize	long
;	O
size_t	long
linelen	long
;	O
int	O
exitstatus	int
;	O
gettextlibdir	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"GETTEXTLIBDIR_BUILDDIR"	*(char)
)	O
;	O
if	O
(	O
gettextlibdir	*(char)
==	O
NULL	O
||	O
gettextlibdir	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
gettextlibdir	*(char)
=	O
relocate	O
(	O
LIBDIR	*(char)
"/gettext"	*(char)
)	O
;	O
prog	*(char)
=	O
xconcatenated_filename	(*(char),*(char),*(char))->(*(char))
(	O
gettextlibdir	*(char)
,	O
"cldr-plurals"	*(char)
,	O
EXEEXT	O
)	O
;	O
last_dir	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
gettextcldrdir	*(char)
)	O
;	O
dirs	array(*(char))
[	O
0	int
]	O
=	O
"common"	*(char)
;	O
dirs	array(*(char))
[	O
1	int
]	O
=	O
"supplemental"	*(char)
;	O
dirs	array(*(char))
[	O
2	int
]	O
=	O
"plurals.xml"	*(char)
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
SIZEOF	O
(	O
dirs	array(*(char))
)	O
;	O
i	long
++	O
)	O
{	O
char	O
*	O
dir	*(char)
=	O
xconcatenated_filename	(*(char),*(char),*(char))->(*(char))
(	O
last_dir	*(char)
,	O
dirs	array(*(char))
[	O
i	long
]	O
,	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
last_dir	*(char)
)	O
;	O
last_dir	*(char)
=	O
dir	*(char)
;	O
}	O
argv	*(*(char))
[	O
0	int
]	O
=	O
prog	*(char)
;	O
argv	*(*(char))
[	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
language	*(char)
;	O
argv	*(*(char))
[	O
2	int
]	O
=	O
last_dir	*(char)
;	O
argv	*(*(char))
[	O
3	int
]	O
=	O
NULL	O
;	O
child	int
=	O
create_pipe_in	(*(char),*(char),*(*(char)),*(char),bool,bool,bool,array(int))->(int)
(	O
prog	*(char)
,	O
prog	*(char)
,	O
argv	*(*(char))
,	O
DEV_NULL	*(char)
,	O
false	int
,	O
true	int
,	O
false	int
,	O
fd	int
)	O
;	O
free	(*(void))->(void)
(	O
last_dir	*(char)
)	O
;	O
if	O
(	O
child	int
==	O
-	O
1	int
)	O
goto	O
failed	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fd	int
[	O
0	int
]	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"fdopen() failed"	*(char)
)	O
)	O
;	O
goto	O
failed	O
;	O
}	O
line	long
=	O
NULL	O
;	O
linesize	long
=	O
0	int
;	O
linelen	long
=	O
getline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
line	long
,	O
&	O
linesize	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
linelen	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess I/O error"	*(char)
)	O
,	O
prog	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
goto	O
failed	O
;	O
}	O
if	O
(	O
linelen	long
>	O
0	int
&&	O
line	long
[	O
linelen	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
line	long
[	O
linelen	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exitstatus	int
=	O
wait_subprocess	(int,*(char),bool,bool,bool,bool,*(int))->(int)
(	O
child	int
,	O
prog	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
false	int
,	O
NULL	O
)	O
;	O
if	O
(	O
exitstatus	int
!=	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed with exit code %d"	*(char)
)	O
,	O
prog	*(char)
,	O
exitstatus	int
)	O
;	O
goto	O
failed	O
;	O
}	O
return	O
line	long
;	O
}	O
failed	O
:	O
free	(*(void))->(void)
(	O
prog	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
struct	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
const	O
char	O
*	O
(	O
*	O
getter0	*(()->(*(char)))
)	O
(	O
void	O
)	O
;	O
const	O
char	O
*	O
(	O
*	O
getter1	*((*(char))->(*(char)))
)	O
(	O
const	O
char	O
*	O
header	*(char)
)	O
;	O
}	O
fields	array(struct(*(char),*(()->(*(char))),*((*(char))->(*(char)))))
[	O
]	O
=	O
{	O
{	O
"Project-Id-Version"	*(char)
,	O
NULL	O
,	O
project_id_version	(*(char))->(*(char))
}	O
,	O
{	O
"PO-Revision-Date"	*(char)
,	O
NULL	O
,	O
po_revision_date	(*(char))->(*(char))
}	O
,	O
{	O
"Last-Translator"	*(char)
,	O
last_translator	()->(*(char))
,	O
NULL	O
}	O
,	O
{	O
"Language-Team"	*(char)
,	O
language_team	()->(*(char))
,	O
NULL	O
}	O
,	O
{	O
"Language"	*(char)
,	O
language_value	()->(*(char))
,	O
NULL	O
}	O
,	O
{	O
"MIME-Version"	*(char)
,	O
mime_version	()->(*(char))
,	O
NULL	O
}	O
,	O
{	O
"Content-Type"	*(char)
,	O
NULL	O
,	O
content_type	(*(char))->(*(char))
}	O
,	O
{	O
"Content-Transfer-Encoding"	*(char)
,	O
content_transfer_encoding	()->(*(char))
,	O
NULL	O
}	O
,	O
{	O
"Plural-Forms"	*(char)
,	O
plural_forms	()->(*(char))
,	O
NULL	O
}	O
}	O
;	O
static	O
char	O
*	O
get_field	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
header	*(char)
,	O
const	O
char	O
*	O
field	*(char)
)	O
{	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
field	*(char)
)	O
;	O
const	O
char	O
*	O
line	long
;	O
for	O
(	O
line	long
=	O
header	*(char)
;	O
;	O
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
line	long
,	O
field	*(char)
,	O
len	long
)	O
==	O
0	int
&&	O
line	long
[	O
len	long
]	O
==	O
':'	O
)	O
{	O
const	O
char	O
*	O
value_start	*(char)
;	O
const	O
char	O
*	O
value_end	*(char)
;	O
char	O
*	O
value	*(char)
;	O
value_start	*(char)
=	O
line	long
+	O
len	long
+	O
1	int
;	O
if	O
(	O
*	O
value_start	*(char)
==	O
' '	O
)	O
value_start	*(char)
++	O
;	O
value_end	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
value_start	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
value_end	*(char)
==	O
NULL	O
)	O
value_end	*(char)
=	O
value_start	*(char)
+	O
strlen	(*(char))->(long)
(	O
value_start	*(char)
)	O
;	O
value	*(char)
=	O
XNMALLOC	O
(	O
value_end	*(char)
-	O
value_start	*(char)
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
value	*(char)
,	O
value_start	*(char)
,	O
value_end	*(char)
-	O
value_start	*(char)
)	O
;	O
value	*(char)
[	O
value_end	*(char)
-	O
value_start	*(char)
]	O
=	O
'\0'	O
;	O
return	O
value	*(char)
;	O
}	O
line	long
=	O
strchr	(*(char),int)->(*(char))
(	O
line	long
,	O
'\n'	O
)	O
;	O
if	O
(	O
line	long
!=	O
NULL	O
)	O
line	long
++	O
;	O
else	O
break	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
put_field	(*(char),*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
old_header	*(char)
,	O
const	O
char	O
*	O
field	*(char)
,	O
const	O
char	O
*	O
value	*(char)
)	O
{	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
field	*(char)
)	O
;	O
const	O
char	O
*	O
line	long
;	O
char	O
*	O
new_header	*(char)
;	O
char	O
*	O
p	*(void)
;	O
for	O
(	O
line	long
=	O
old_header	*(char)
;	O
;	O
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
line	long
,	O
field	*(char)
,	O
len	long
)	O
==	O
0	int
&&	O
line	long
[	O
len	long
]	O
==	O
':'	O
)	O
{	O
const	O
char	O
*	O
value_start	*(char)
;	O
const	O
char	O
*	O
value_end	*(char)
;	O
value_start	*(char)
=	O
line	long
+	O
len	long
+	O
1	int
;	O
if	O
(	O
*	O
value_start	*(char)
==	O
' '	O
)	O
value_start	*(char)
++	O
;	O
value_end	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
value_start	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
value_end	*(char)
==	O
NULL	O
)	O
value_end	*(char)
=	O
value_start	*(char)
+	O
strlen	(*(char))->(long)
(	O
value_start	*(char)
)	O
;	O
new_header	*(char)
=	O
XNMALLOC	O
(	O
strlen	(*(char))->(long)
(	O
old_header	*(char)
)	O
-	O
(	O
value_end	*(char)
-	O
value_start	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
value	*(char)
)	O
+	O
(	O
*	O
value_end	*(char)
!=	O
'\n'	O
?	O
1	int
:	O
0	int
)	O
+	O
1	int
,	O
char	O
)	O
;	O
p	*(void)
=	O
new_header	*(char)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
,	O
old_header	*(char)
,	O
value_start	*(char)
-	O
old_header	*(char)
)	O
;	O
p	*(void)
+=	O
value_start	*(char)
-	O
old_header	*(char)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
,	O
value	*(char)
,	O
strlen	(*(char))->(long)
(	O
value	*(char)
)	O
)	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
value	*(char)
)	O
;	O
if	O
(	O
*	O
value_end	*(char)
!=	O
'\n'	O
)	O
*	O
p	*(void)
++	O
=	O
'\n'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
value_end	*(char)
)	O
;	O
return	O
new_header	*(char)
;	O
}	O
line	long
=	O
strchr	(*(char),int)->(*(char))
(	O
line	long
,	O
'\n'	O
)	O
;	O
if	O
(	O
line	long
!=	O
NULL	O
)	O
line	long
++	O
;	O
else	O
break	O
;	O
}	O
new_header	*(char)
=	O
XNMALLOC	O
(	O
strlen	(*(char))->(long)
(	O
old_header	*(char)
)	O
+	O
1	int
+	O
len	long
+	O
2	int
+	O
strlen	(*(char))->(long)
(	O
value	*(char)
)	O
+	O
1	int
+	O
1	int
,	O
char	O
)	O
;	O
p	*(void)
=	O
new_header	*(char)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
,	O
old_header	*(char)
,	O
strlen	(*(char))->(long)
(	O
old_header	*(char)
)	O
)	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
old_header	*(char)
)	O
;	O
if	O
(	O
p	*(void)
>	O
new_header	*(char)
&&	O
p	*(void)
[	O
-	O
1	int
]	O
!=	O
'\n'	O
)	O
*	O
p	*(void)
++	O
=	O
'\n'	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
,	O
field	*(char)
,	O
len	long
)	O
;	O
p	*(void)
+=	O
len	long
;	O
*	O
p	*(void)
++	O
=	O
':'	O
;	O
*	O
p	*(void)
++	O
=	O
' '	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
,	O
value	*(char)
,	O
strlen	(*(char))->(long)
(	O
value	*(char)
)	O
)	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
value	*(char)
)	O
;	O
*	O
p	*(void)
++	O
=	O
'\n'	O
;	O
*	O
p	*(void)
=	O
'\0'	O
;	O
return	O
new_header	*(char)
;	O
}	O
static	O
const	O
char	O
*	O
get_title	()->(*(char))
(	O
)	O
{	O
const	O
char	O
*	O
encoding	*(char)
;	O
const	O
char	O
*	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
;	O
char	O
*	O
old_LC_ALL	*(char)
;	O
char	O
*	O
old_LANGUAGE	*(char)
;	O
char	O
*	O
old_OUTPUT_CHARSET	*(char)
;	O
const	O
char	O
*	O
msgid	*(char)
;	O
const	O
char	O
*	O
english	*(char)
;	O
const	O
char	O
*	O
result	*(*(void))
;	O
encoding	*(char)
=	O
canonical_locale_charset	()->(*(char))
(	O
)	O
;	O
english	*(char)
=	O
xasprintf	(*(char))->(*(char))
(	O
"%s translations for %%s package"	*(char)
,	O
englishname_of_language	()->(*(char))
(	O
)	O
)	O
;	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
=	O
getenv	(*(char))->(*(char))
(	O
"LC_ALL"	*(char)
)	O
;	O
old_LC_ALL	*(char)
=	O
(	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
!=	O
NULL	O
?	O
xstrdup	(*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
)	O
:	O
NULL	O
)	O
;	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
=	O
getenv	(*(char))->(*(char))
(	O
"LANGUAGE"	*(char)
)	O
;	O
old_LANGUAGE	*(char)
=	O
(	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
!=	O
NULL	O
?	O
xstrdup	(*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
)	O
:	O
NULL	O
)	O
;	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
=	O
getenv	(*(char))->(*(char))
(	O
"OUTPUT_CHARSET"	*(char)
)	O
;	O
old_OUTPUT_CHARSET	*(char)
=	O
(	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
!=	O
NULL	O
?	O
xstrdup	(*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
)	O
:	O
NULL	O
)	O
;	O
xsetenv	(*(char),*(char),int)->(void)
(	O
"LC_ALL"	*(char)
,	O
locale	*(char)
,	O
1	int
)	O
;	O
unsetenv	(*(char))->(int)
(	O
"LANGUAGE"	*(char)
)	O
;	O
xsetenv	(*(char),*(char),int)->(void)
(	O
"OUTPUT_CHARSET"	*(char)
,	O
encoding	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
==	O
NULL	O
)	O
result	*(*(void))
=	O
english	*(char)
;	O
else	O
{	O
msgid	*(char)
=	O
N_	O
(	O
"English translations for %s package"	*(char)
)	O
;	O
result	*(*(void))
=	O
gettext	(*(char))->(*(char))
(	O
msgid	*(char)
)	O
;	O
if	O
(	O
result	*(*(void))
!=	O
msgid	*(char)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
result	*(*(void))
,	O
msgid	*(char)
)	O
!=	O
0	int
)	O
result	*(*(void))
=	O
xasprintf	(*(char))->(*(char))
(	O
"%s\n%s"	*(char)
,	O
english	*(char)
,	O
result	*(*(void))
)	O
;	O
else	O
result	*(*(void))
=	O
english	*(char)
;	O
}	O
if	O
(	O
old_LC_ALL	*(char)
!=	O
NULL	O
)	O
xsetenv	(*(char),*(char),int)->(void)
(	O
"LC_ALL"	*(char)
,	O
old_LC_ALL	*(char)
,	O
1	int
)	O
,	O
free	(*(void))->(void)
(	O
old_LC_ALL	*(char)
)	O
;	O
else	O
unsetenv	(*(char))->(int)
(	O
"LC_ALL"	*(char)
)	O
;	O
if	O
(	O
old_LANGUAGE	*(char)
!=	O
NULL	O
)	O
xsetenv	(*(char),*(char),int)->(void)
(	O
"LANGUAGE"	*(char)
,	O
old_LANGUAGE	*(char)
,	O
1	int
)	O
,	O
free	(*(void))->(void)
(	O
old_LANGUAGE	*(char)
)	O
;	O
else	O
unsetenv	(*(char))->(int)
(	O
"LANGUAGE"	*(char)
)	O
;	O
if	O
(	O
old_OUTPUT_CHARSET	*(char)
!=	O
NULL	O
)	O
xsetenv	(*(char),*(char),int)->(void)
(	O
"OUTPUT_CHARSET"	*(char)
,	O
old_OUTPUT_CHARSET	*(char)
,	O
1	int
)	O
,	O
free	(*(void))->(void)
(	O
old_OUTPUT_CHARSET	*(char)
)	O
;	O
else	O
unsetenv	(*(char))->(int)
(	O
"OUTPUT_CHARSET"	*(char)
)	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
return	O
result	*(*(void))
;	O
}	O
static	O
const	O
char	O
*	O
subst_string	(*(char),int,*(array(*(char))))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
,	O
unsigned	O
int	O
nsubst	int
,	O
const	O
char	O
*	O
(	O
*	O
subst	*(array(*(char)))
)	O
[	O
2	int
]	O
)	O
{	O
if	O
(	O
nsubst	int
>	O
0	int
)	O
{	O
char	O
*	O
malloced	*(char)
=	O
NULL	O
;	O
size_t	long
*	O
substlen	*(long)
;	O
size_t	long
i	long
;	O
unsigned	O
int	O
j	int
;	O
substlen	*(long)
=	O
(	O
size_t	long
*	O
)	O
xmalloca	O
(	O
nsubst	int
*	O
sizeof	O
(	O
size_t	long
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nsubst	int
;	O
j	int
++	O
)	O
{	O
substlen	*(long)
[	O
j	int
]	O
=	O
strlen	(*(char))->(long)
(	O
subst	*(array(*(char)))
[	O
j	int
]	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
substlen	*(long)
[	O
j	int
]	O
==	O
0	int
)	O
abort	()->(void)
(	O
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
;	O
)	O
{	O
if	O
(	O
str	*(char)
[	O
i	long
]	O
==	O
'\0'	O
)	O
break	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nsubst	int
;	O
j	int
++	O
)	O
if	O
(	O
*	O
(	O
str	*(char)
+	O
i	long
)	O
==	O
*	O
subst	*(array(*(char)))
[	O
j	int
]	O
[	O
0	int
]	O
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
str	*(char)
+	O
i	long
,	O
subst	*(array(*(char)))
[	O
j	int
]	O
[	O
0	int
]	O
,	O
substlen	*(long)
[	O
j	int
]	O
)	O
==	O
0	int
)	O
{	O
size_t	long
replacement_len	long
=	O
strlen	(*(char))->(long)
(	O
subst	*(array(*(char)))
[	O
j	int
]	O
[	O
1	int
]	O
)	O
;	O
size_t	long
new_len	long
=	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
-	O
substlen	*(long)
[	O
j	int
]	O
+	O
replacement_len	long
;	O
char	O
*	O
new_str	*(char)
=	O
XNMALLOC	O
(	O
new_len	long
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
new_str	*(char)
,	O
str	*(char)
,	O
i	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
new_str	*(char)
+	O
i	long
,	O
subst	*(array(*(char)))
[	O
j	int
]	O
[	O
1	int
]	O
,	O
replacement_len	long
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
new_str	*(char)
+	O
i	long
+	O
replacement_len	long
,	O
str	*(char)
+	O
i	long
+	O
substlen	*(long)
[	O
j	int
]	O
)	O
;	O
if	O
(	O
malloced	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
malloced	*(char)
)	O
;	O
str	*(char)
=	O
new_str	*(char)
;	O
malloced	*(char)
=	O
new_str	*(char)
;	O
i	long
+=	O
replacement_len	long
;	O
break	O
;	O
}	O
if	O
(	O
j	int
==	O
nsubst	int
)	O
i	long
++	O
;	O
}	O
freea	(*(void))->(void)
(	O
substlen	*(long)
)	O
;	O
}	O
return	O
str	*(char)
;	O
}	O
static	O
void	O
subst_string_list	(*(struct(*(*(char)),long,long)),int,*(array(*(char))))->(void)
(	O
string_list_ty	struct
*	O
slp	*(struct(*(*(char)),long,long))
,	O
unsigned	O
int	O
nsubst	int
,	O
const	O
char	O
*	O
(	O
*	O
subst	*(array(*(char)))
)	O
[	O
2	int
]	O
)	O
{	O
size_t	long
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
slp	*(struct(*(*(char)),long,long))
->	O
nitems	long
;	O
j	int
++	O
)	O
slp	*(struct(*(*(char)),long,long))
->	O
item	*(*(char))
[	O
j	int
]	O
=	O
subst_string	(*(char),int,*(array(*(char))))->(*(char))
(	O
slp	*(struct(*(*(char)),long,long))
->	O
item	*(*(char))
[	O
j	int
]	O
,	O
nsubst	int
,	O
subst	*(array(*(char)))
)	O
;	O
}	O
static	O
msgdomain_list_ty	struct
*	O
fill_header	(*(struct(*(*(struct`)),long,long,bool,*(char))))->(*(struct(*(*(struct`)),long,long,bool,*(char))))
(	O
msgdomain_list_ty	struct
*	O
mdlp	*(struct(*(*(struct(*`,*`))),long,long,bool,*(char)))
)	O
{	O
const	O
char	O
*	O
field_value	array(*(char))
[	O
NFIELDS	O
]	O
;	O
size_t	long
k	long
,	O
j	int
,	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFIELDS	O
;	O
i	long
++	O
)	O
field_value	array(*(char))
[	O
i	long
]	O
=	O
NULL	O
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
mdlp	*(struct(*(*(struct(*`,*`))),long,long,bool,*(char)))
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
=	O
mdlp	*(struct(*(*(struct(*`,*`))),long,long,bool,*(char)))
->	O
item	*(*(char))
[	O
k	long
]	O
->	O
messages	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
;	O
if	O
(	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
nitems	long
>	O
0	int
)	O
{	O
message_ty	struct
*	O
header_mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
=	O
NULL	O
;	O
char	O
*	O
header	*(char)
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
nitems	long
;	O
j	int
++	O
)	O
if	O
(	O
is_header	O
(	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
item	*(*(char))
[	O
j	int
]	O
)	O
&&	O
!	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
item	*(*(char))
[	O
j	int
]	O
->	O
obsolete	bool
)	O
{	O
header_mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
=	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
item	*(*(char))
[	O
j	int
]	O
;	O
break	O
;	O
}	O
if	O
(	O
header_mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
==	O
NULL	O
)	O
{	O
static	O
lex_pos_ty	struct
pos	struct(*(char),long)
=	O
{	O
__FILE__	O
,	O
__LINE__	O
}	O
;	O
header_mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
=	O
message_alloc	(*(char),*(char),*(char),*(char),long,*(struct(*(char),long)))->(*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*`,long,long)),*(struct(*`,long,long)),long,*(struct(*`,long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`)),int,*(struct(*`,long,*`,*`,*`,*`)))))
(	O
NULL	O
,	O
""	*(char)
,	O
NULL	O
,	O
""	*(char)
,	O
1	int
,	O
&	O
pos	struct(*(char),long)
)	O
;	O
message_list_prepend	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*`,long,long)),*(struct(*`,long,long)),long,*(struct(*`,long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`)),int,*(struct(*`,long,*`,*`,*`,*`)))))->(void)
(	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
header_mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
)	O
;	O
}	O
header	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
header_mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFIELDS	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
field_value	array(*(char))
[	O
i	long
]	O
==	O
NULL	O
)	O
field_value	array(*(char))
[	O
i	long
]	O
=	O
(	O
fields	array(struct(*(char),*(()->(*(char))),*((*(char))->(*(char)))))
[	O
i	long
]	O
.	O
getter1	*((*(char))->(*(char)))
!=	O
NULL	O
?	O
fields	array(struct(*(char),*(()->(*(char))),*((*(char))->(*(char)))))
[	O
i	long
]	O
.	O
getter1	*((*(char))->(*(char)))
(	O
header	*(char)
)	O
:	O
fields	array(struct(*(char),*(()->(*(char))),*((*(char))->(*(char)))))
[	O
i	long
]	O
.	O
getter0	*(()->(*(char)))
(	O
)	O
)	O
;	O
if	O
(	O
field_value	array(*(char))
[	O
i	long
]	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
old_header	*(char)
=	O
header	*(char)
;	O
header	*(char)
=	O
put_field	(*(char),*(char),*(char))->(*(char))
(	O
header	*(char)
,	O
fields	array(struct(*(char),*(()->(*(char))),*((*(char))->(*(char)))))
[	O
i	long
]	O
.	O
name	*(char)
,	O
field_value	array(*(char))
[	O
i	long
]	O
)	O
;	O
free	(*(void))->(void)
(	O
old_header	*(char)
)	O
;	O
}	O
}	O
header_mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
=	O
header	*(char)
;	O
header_mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr_len	long
=	O
strlen	(*(char))->(long)
(	O
header	*(char)
)	O
+	O
1	int
;	O
if	O
(	O
header_mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
comment	*(struct(*(*(char)),long,long))
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
subst	*(array(*(char)))
[	O
4	int
]	O
[	O
2	int
]	O
;	O
const	O
char	O
*	O
id	*(char)
;	O
time_t	long
now	long
;	O
id	*(char)
=	O
project_id	(*(char))->(*(char))
(	O
header	*(char)
)	O
;	O
subst	*(array(*(char)))
[	O
0	int
]	O
[	O
0	int
]	O
=	O
"SOME DESCRIPTIVE TITLE"	*(char)
;	O
subst	*(array(*(char)))
[	O
0	int
]	O
[	O
1	int
]	O
=	O
xasprintf	(*(char))->(*(char))
(	O
get_title	()->(*(char))
(	O
)	O
,	O
id	*(char)
,	O
id	*(char)
)	O
;	O
subst	*(array(*(char)))
[	O
1	int
]	O
[	O
0	int
]	O
=	O
"PACKAGE"	*(char)
;	O
subst	*(array(*(char)))
[	O
1	int
]	O
[	O
1	int
]	O
=	O
id	*(char)
;	O
subst	*(array(*(char)))
[	O
2	int
]	O
[	O
0	int
]	O
=	O
"FIRST AUTHOR <EMAIL@ADDRESS>"	*(char)
;	O
subst	*(array(*(char)))
[	O
2	int
]	O
[	O
1	int
]	O
=	O
field_value	array(*(char))
[	O
FIELD_LAST_TRANSLATOR	int
]	O
;	O
subst	*(array(*(char)))
[	O
3	int
]	O
[	O
0	int
]	O
=	O
"YEAR"	*(char)
;	O
subst	*(array(*(char)))
[	O
3	int
]	O
[	O
1	int
]	O
=	O
xasprintf	(*(char))->(*(char))
(	O
"%d"	*(char)
,	O
(	O
time	struct(long,long)
(	O
&	O
now	long
)	O
,	O
(	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
now	long
)	O
)	O
->	O
tm_year	int
+	O
1900	int
)	O
)	O
;	O
subst_string_list	(*(struct(*(*(char)),long,long)),int,*(array(*(char))))->(void)
(	O
header_mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
comment	*(struct(*(*(char)),long,long))
,	O
SIZEOF	O
(	O
subst	*(array(*(char)))
)	O
,	O
subst	*(array(*(char)))
)	O
;	O
}	O
header_mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
is_fuzzy	bool
=	O
false	int
;	O
}	O
}	O
return	O
mdlp	*(struct(*(*(struct(*`,*`))),long,long,bool,*(char)))
;	O
}	O
static	O
msgdomain_list_ty	struct
*	O
update_msgstr_plurals	(*(struct(*(*(struct`)),long,long,bool,*(char))))->(*(struct(*(*(struct`)),long,long,bool,*(char))))
(	O
msgdomain_list_ty	struct
*	O
mdlp	*(struct(*(*(struct(*`,*`))),long,long,bool,*(char)))
)	O
{	O
size_t	long
k	long
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
mdlp	*(struct(*(*(struct(*`,*`))),long,long,bool,*(char)))
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
=	O
mdlp	*(struct(*(*(struct(*`,*`))),long,long,bool,*(char)))
->	O
item	*(*(char))
[	O
k	long
]	O
->	O
messages	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
;	O
message_ty	struct
*	O
header_entry	*(char)
;	O
unsigned	O
long	O
int	O
nplurals	long
;	O
char	O
*	O
untranslated_plural_msgstr	*(char)
;	O
size_t	long
j	int
;	O
header_entry	*(char)
=	O
message_list_search	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),*(char),*(char))->(*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*`,long,long)),*(struct(*`,long,long)),long,*(struct(*`,long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`)),int,*(struct(*`,long,*`,*`,*`,*`)))))
(	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
NULL	O
,	O
""	*(char)
)	O
;	O
nplurals	long
=	O
get_plural_count	(*(char))->(long)
(	O
header_entry	*(char)
?	O
header_entry	*(char)
->	O
msgstr	*(char)
:	O
NULL	O
)	O
;	O
untranslated_plural_msgstr	*(char)
=	O
XNMALLOC	O
(	O
nplurals	long
,	O
char	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
untranslated_plural_msgstr	*(char)
,	O
'\0'	O
,	O
nplurals	long
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
nitems	long
;	O
j	int
++	O
)	O
{	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
=	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
item	*(*(char))
[	O
j	int
]	O
;	O
bool	bool
is_untranslated	bool
;	O
const	O
char	O
*	O
p	*(void)
;	O
const	O
char	O
*	O
pend	*(char)
;	O
if	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid_plural	*(char)
!=	O
NULL	O
)	O
{	O
is_untranslated	bool
=	O
true	int
;	O
for	O
(	O
p	*(void)
=	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
,	O
pend	*(char)
=	O
p	*(void)
+	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr_len	long
;	O
p	*(void)
<	O
pend	*(char)
;	O
p	*(void)
++	O
)	O
if	O
(	O
*	O
p	*(void)
!=	O
'\0'	O
)	O
{	O
is_untranslated	bool
=	O
false	int
;	O
break	O
;	O
}	O
if	O
(	O
is_untranslated	bool
)	O
{	O
if	O
(	O
nplurals	long
>	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr_len	long
)	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
=	O
untranslated_plural_msgstr	*(char)
;	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr_len	long
=	O
nplurals	long
;	O
}	O
}	O
}	O
}	O
return	O
mdlp	*(struct(*(*(struct(*`,*`))),long,long,bool,*(char)))
;	O
}	O
