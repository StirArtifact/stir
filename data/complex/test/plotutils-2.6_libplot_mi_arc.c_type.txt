typedef	O
struct	O
{	O
int	O
lx	int
,	O
rx	double
;	O
int	O
lw	int
,	O
rw	int
;	O
}	O
miArcSpan	struct(int,int,int,int)
;	O
typedef	O
struct	O
{	O
int	O
k	int
;	O
miArcSpan	struct(int,int,int,int)
*	O
spans	*(struct(int,*(struct(int,int)),*(int)))
;	O
bool	enum(int,int)
top	enum(int,int)
;	O
int	O
count1	int
;	O
int	O
count2	int
;	O
bool	enum(int,int)
bot	enum(int,int)
;	O
bool	enum(int,int)
hole	enum(int,int)
;	O
}	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
;	O
typedef	O
struct	O
{	O
unsigned	O
long	O
lrustamp	long
;	O
unsigned	O
int	O
width	array(short)
,	O
height	int
;	O
unsigned	O
int	O
lw	int
;	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
;	O
}	O
cachedEllipse	struct(long,int,int,int,*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
;	O
struct	O
lib_miEllipseCache	struct(*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int))))),int,*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int))))),long)
{	O
cachedEllipse	struct(long,int,int,int,*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
*	O
ellipses	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
int	O
size	double
;	O
cachedEllipse	struct(long,int,int,int,*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
*	O
lastCacheHit	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
unsigned	O
long	O
lrustamp	long
;	O
}	O
;	O
typedef	O
struct	O
{	O
int	O
arcIndex0	int
,	O
arcIndex1	int
;	O
int	O
paintType0	int
,	O
paintType1	int
;	O
int	O
end0	int
,	O
end1	int
;	O
}	O
miArcJoinStruct	struct(int,int,int,int,int,int)
;	O
typedef	O
struct	O
{	O
int	O
arcIndex	int
;	O
int	O
end	int
;	O
}	O
miArcCapStruct	struct(int,int)
;	O
typedef	O
struct	O
{	O
SppPoint	struct(double,double)
clock	()->(long)
;	O
SppPoint	struct(double,double)
center	struct(double,double)
;	O
SppPoint	struct(double,double)
counterClock	struct(double,double)
;	O
}	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
;	O
typedef	O
struct	O
{	O
miArc	struct(int,int,int,int,int,int)
arc	struct(int,int,int,int,int,int)
;	O
bool	enum(int,int)
render	enum(int,int)
;	O
int	O
join	int
;	O
int	O
cap	int
;	O
bool	enum(int,int)
selfJoin	enum(int,int)
;	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
[	O
2	int
]	O
;	O
double	O
x0	double
,	O
y0	(double)->(double)
;	O
double	O
x1	double
,	O
y1	(double)->(double)
;	O
}	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
;	O
typedef	O
struct	O
{	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
*	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
;	O
int	O
narcs	int
;	O
int	O
arcSize	int
;	O
miArcCapStruct	struct(int,int)
*	O
caps	*(struct(int,int))
;	O
int	O
ncaps	int
;	O
int	O
capSize	int
;	O
miArcJoinStruct	struct(int,int,int,int,int,int)
*	O
joins	*(struct(int,int,int,int,int,int))
;	O
int	O
njoins	int
;	O
int	O
joinSize	int
;	O
}	O
miPolyArcs	struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)
;	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
{	O
int	O
min	int
,	O
max	int
;	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
;	O
}	O
;	O
struct	O
finalSpanChunk	struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))))))
{	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
SPAN_CHUNK_SIZE	int
]	O
;	O
struct	O
finalSpanChunk	struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))))))
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
;	O
}	O
;	O
typedef	O
struct	O
{	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
*	O
finalSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
;	O
int	O
finalMiny	int
,	O
finalMaxy	int
;	O
int	O
finalSize	int
;	O
int	O
nspans	int
;	O
struct	O
finalSpanChunk	struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))))))
*	O
chunks	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
;	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
freeFinalSpans	*(struct(int,int,*(struct(int,int,*(struct`)))))
;	O
}	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
;	O
typedef	O
struct	O
{	O
double	O
map	array(double)
[	O
DASH_MAP_SIZE	int
]	O
;	O
}	O
dashMap	struct(array(double))
;	O
static	O
void	O
fillSpans	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	struct(char,union(char,array(char)))
pixel	struct(char,union(char,array(char)))
,	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
)	O
;	O
static	O
void	O
miArcCap	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(struct(double,double),struct(double,double),struct(double,double))),int,int,int,double,double)->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	struct(char,union(char,array(char)))
pixel	struct(char,union(char,array(char)))
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
pFace	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
int	O
end	int
,	O
int	O
xOrg	int
,	O
int	O
yOrg	int
,	O
double	O
xFtrans	double
,	O
double	O
yFtrans	double
)	O
;	O
static	O
void	O
miArcJoin	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))),int,int,double,double,int,int,double,double)->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	struct(char,union(char,array(char)))
pixel	struct(char,union(char,array(char)))
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
pLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
const	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
pRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
int	O
xOrgLeft	int
,	O
int	O
yOrgLeft	int
,	O
double	O
xFtransLeft	double
,	O
double	O
yFtransLeft	double
,	O
int	O
xOrgRight	int
,	O
int	O
yOrgRight	int
,	O
double	O
xFtransRight	double
,	O
double	O
yFtransRight	double
)	O
;	O
static	O
void	O
miFillWideEllipse	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)),*(struct(*(struct(long,int,int,int,*`)),int,*(struct(long,int,int,int,*`)),long)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	struct(char,union(char,array(char)))
pixel	struct(char,union(char,array(char)))
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
parc	*(struct(int,int,int,int,int,int))
,	O
miEllipseCache	struct
*	O
ellipseCache	*(struct)
)	O
;	O
static	O
void	O
miRoundCap	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),struct(double,double),struct(double,double),struct(double,double),struct(double,double),int,int,int,double,double)->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	struct(char,union(char,array(char)))
pixel	struct(char,union(char,array(char)))
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
SppPoint	struct(double,double)
pCenter	struct(double,double)
,	O
SppPoint	struct(double,double)
pEnd	struct(double,double)
,	O
SppPoint	struct(double,double)
pCorner	struct(double,double)
,	O
SppPoint	struct(double,double)
pOtherCorner	struct(double,double)
,	O
int	O
fLineEnd	int
,	O
int	O
xOrg	int
,	O
int	O
yOrg	int
,	O
double	O
xFtrans	double
,	O
double	O
yFtrans	double
)	O
;	O
static	O
double	O
angleBetween	(struct(double,double),struct(double,double),struct(double,double))->(double)
(	O
SppPoint	struct(double,double)
center	struct(double,double)
,	O
SppPoint	struct(double,double)
point1	struct(double,double)
,	O
SppPoint	struct(double,double)
point2	struct(double,double)
)	O
;	O
static	O
double	O
miDasin	(double)->(double)
(	O
double	O
v	*(struct(double,double))
)	O
;	O
static	O
double	O
miDatan2	(double,double)->(double)
(	O
double	O
dy	int
,	O
double	O
dx	int
)	O
;	O
static	O
double	O
miDcos	(double)->(double)
(	O
double	O
a	double
)	O
;	O
static	O
double	O
miDsin	(double)->(double)
(	O
double	O
a	double
)	O
;	O
static	O
int	O
computeAngleFromPath	(int,int,*(struct(array(double))),*(int),enum(int,int))->(int)
(	O
int	O
startAngle	int
,	O
int	O
endAngle	int
,	O
const	O
dashMap	struct(array(double))
*	O
map	array(double)
,	O
int	O
*	O
lenp	*(int)
,	O
bool	enum(int,int)
backwards	enum(int,int)
)	O
;	O
static	O
int	O
miGetArcPts	(*(struct(double,double,double,double,double,double)),int,*(*(struct(double,double))))->(int)
(	O
const	O
SppArc	struct(double,double,double,double,double,double)
*	O
parc	*(struct(int,int,int,int,int,int))
,	O
int	O
cpt	int
,	O
SppPoint	struct(double,double)
*	O
*	O
ppPts	*(*(struct(double,double)))
)	O
;	O
static	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
*	O
addArc	(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)),*(struct(int,int,int,int,int,int)))->(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)))
(	O
miPolyArcs	struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)
*	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
xarc	*(struct(int,int,int,int,int,int))
)	O
;	O
static	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
miComputeWideEllipse	(int,*(struct(int,int,int,int,int,int)),*(enum(int,int)),*(struct(*(struct(long,int,int,int,*`)),int,*(struct(long,int,int,int,*`)),long)))->(*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
(	O
unsigned	O
int	O
lw	int
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
parc	*(struct(int,int,int,int,int,int))
,	O
bool	enum(int,int)
*	O
mustFree	*(enum(int,int))
,	O
miEllipseCache	struct
*	O
ellipseCache	*(struct)
)	O
;	O
static	O
miPolyArcs	struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)
*	O
miComputeArcs	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)),int)->(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)))
(	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
parcs	*(struct(int,int,int,int,int,int))
,	O
int	O
narcs	int
)	O
;	O
static	O
void	O
addCap	(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)),int,int)->(void)
(	O
miPolyArcs	struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)
*	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
,	O
int	O
end	int
,	O
int	O
arcIndex	int
)	O
;	O
static	O
void	O
addJoin	(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)),int,int,int,int,int,int)->(void)
(	O
miPolyArcs	struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)
*	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
,	O
int	O
end0	int
,	O
int	O
index0	int
,	O
int	O
paintType0	int
,	O
int	O
end1	int
,	O
int	O
index1	int
,	O
int	O
paintType1	int
)	O
;	O
static	O
void	O
computeDashMap	(*(struct(int,int,int,int,int,int)),*(struct(array(double))))->(void)
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arcp	*(struct(int,int,int,int,int,int))
,	O
dashMap	struct(array(double))
*	O
map	array(double)
)	O
;	O
static	O
void	O
drawArc	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),*(struct(int,int,int,int,int,int)),int,int,int,*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(*(struct(long,int,int,int,*`)),int,*(struct(long,int,int,int,*`)),long)))->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
tarc	*(struct(int,int,int,int,int,int))
,	O
unsigned	O
int	O
l	int
,	O
int	O
a0	int
,	O
int	O
a1	int
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miEllipseCache	struct
*	O
ellipseCache	*(struct)
)	O
;	O
static	O
void	O
drawZeroArc	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),*(struct(int,int,int,int,int,int)),int,*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))))->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
tarc	*(struct(int,int,int,int,int,int))
,	O
unsigned	O
int	O
lw	int
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
static	O
void	O
initAccumSpans	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))))->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
)	O
;	O
static	O
void	O
miArcSegment	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),struct(int,int,int,int,int,int),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(*(struct(long,int,int,int,*`)),int,*(struct(long,int,int,int,*`)),long)))->(void)
(	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
miArc	struct(int,int,int,int,int,int)
tarc	*(struct(int,int,int,int,int,int))
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miEllipseCache	struct
*	O
ellipseCache	*(struct)
)	O
;	O
static	O
void	O
miComputeCircleSpans	(int,*(struct(int,int,int,int,int,int)),*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))->(void)
(	O
unsigned	O
int	O
lw	int
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
parc	*(struct(int,int,int,int,int,int))
,	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
;	O
static	O
void	O
miComputeEllipseSpans	(int,*(struct(int,int,int,int,int,int)),*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))->(void)
(	O
unsigned	O
int	O
lw	int
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
parc	*(struct(int,int,int,int,int,int))
,	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
;	O
static	O
void	O
miFreeArcs	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)))->(void)
(	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
miPolyArcs	struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)
*	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
)	O
;	O
static	O
void	O
translateBounds	(*(struct(struct(double,double),struct(double,double),struct(double,double))),int,int,double,double)->(void)
(	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
int	O
x	double
,	O
int	O
y	double
,	O
double	O
fx	double
,	O
double	O
fy	double
)	O
;	O
void	O
miPolyArc_r	O
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
int	O
narcs	int
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
parcs	*(struct(int,int,int,int,int,int))
,	O
miEllipseCache	struct
*	O
ellipseCache	*(struct)
)	O
{	O
int	O
i	int
;	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
parc	*(struct(int,int,int,int,int,int))
;	O
int	O
width	array(short)
;	O
miPixel	struct(char,union(char,array(char)))
pixel	struct(char,union(char,array(char)))
;	O
miPolyArcs	struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)
*	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
;	O
int	O
*	O
cap	int
,	O
*	O
join	int
;	O
int	O
paintType	int
;	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
accumSpans_struct	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
;	O
if	O
(	O
narcs	int
<=	O
0	int
)	O
return	O
;	O
initAccumSpans	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))))->(void)
(	O
&	O
accumSpans_struct	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
)	O
;	O
pixel	struct(char,union(char,array(char)))
=	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
[	O
1	int
]	O
;	O
width	array(short)
=	O
pGC	*(struct)
->	O
lineWidth	int
;	O
if	O
(	O
width	array(short)
==	O
0	int
&&	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_SOLID	int
)	O
{	O
for	O
(	O
i	int
=	O
narcs	int
,	O
parc	*(struct(int,int,int,int,int,int))
=	O
parcs	*(struct(int,int,int,int,int,int))
;	O
--	O
i	int
>=	O
0	int
;	O
parc	*(struct(int,int,int,int,int,int))
++	O
)	O
miArcSegment	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),struct(int,int,int,int,int,int),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(*(struct(long,int,int,int,*`)),int,*(struct(long,int,int,int,*`)),long)))->(void)
(	O
pGC	*(struct)
,	O
&	O
accumSpans_struct	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
,	O
*	O
parc	*(struct(int,int,int,int,int,int))
,	O
(	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
NULL	O
,	O
(	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
NULL	O
,	O
ellipseCache	*(struct)
)	O
;	O
fillSpans	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))))->(void)
(	O
paintedSet	*(struct)
,	O
pixel	struct(char,union(char,array(char)))
,	O
&	O
accumSpans_struct	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_SOLID	int
)	O
&&	O
narcs	int
)	O
{	O
while	O
(	O
parcs	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&&	O
parcs	*(struct(int,int,int,int,int,int))
->	O
height	int
&&	O
(	O
parcs	*(struct(int,int,int,int,int,int))
->	O
angle2	int
>=	O
FULLCIRCLE	O
||	O
parcs	*(struct(int,int,int,int,int,int))
->	O
angle2	int
<=	O
-	O
FULLCIRCLE	O
)	O
)	O
{	O
miFillWideEllipse	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)),*(struct(*(struct(long,int,int,int,*`)),int,*(struct(long,int,int,int,*`)),long)))->(void)
(	O
paintedSet	*(struct)
,	O
pixel	struct(char,union(char,array(char)))
,	O
pGC	*(struct)
,	O
parcs	*(struct(int,int,int,int,int,int))
,	O
ellipseCache	*(struct)
)	O
;	O
if	O
(	O
--	O
narcs	int
==	O
0	int
)	O
return	O
;	O
parcs	*(struct(int,int,int,int,int,int))
++	O
;	O
}	O
}	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
=	O
miComputeArcs	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)),int)->(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)))
(	O
pGC	*(struct)
,	O
parcs	*(struct(int,int,int,int,int,int))
,	O
narcs	int
)	O
;	O
cap	int
=	O
(	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
pGC	*(struct)
->	O
numPixels	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
join	int
=	O
(	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
pGC	*(struct)
->	O
numPixels	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pGC	*(struct)
->	O
numPixels	int
;	O
i	int
++	O
)	O
cap	int
[	O
i	int
]	O
=	O
join	int
[	O
i	int
]	O
=	O
0	int
;	O
for	O
(	O
paintType	int
=	O
0	int
;	O
paintType	int
<	O
pGC	*(struct)
->	O
numPixels	int
;	O
paintType	int
++	O
)	O
{	O
pixel	struct(char,union(char,array(char)))
=	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
[	O
paintType	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
[	O
paintType	int
]	O
.	O
narcs	int
;	O
i	int
++	O
)	O
{	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
*	O
arcData	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
;	O
arcData	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
=	O
&	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
[	O
paintType	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
i	int
]	O
;	O
miArcSegment	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),struct(int,int,int,int,int,int),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(*(struct(long,int,int,int,*`)),int,*(struct(long,int,int,int,*`)),long)))->(void)
(	O
pGC	*(struct)
,	O
&	O
accumSpans_struct	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
,	O
arcData	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
arc	struct(int,int,int,int,int,int)
,	O
&	O
arcData	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
[	O
RIGHT_END	int
]	O
,	O
&	O
arcData	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
[	O
LEFT_END	int
]	O
,	O
ellipseCache	*(struct)
)	O
;	O
if	O
(	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
[	O
paintType	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
i	int
]	O
.	O
render	enum(int,int)
)	O
{	O
fillSpans	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))))->(void)
(	O
paintedSet	*(struct)
,	O
pixel	struct(char,union(char,array(char)))
,	O
&	O
accumSpans_struct	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
)	O
;	O
if	O
(	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
[	O
paintType	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
i	int
]	O
.	O
selfJoin	enum(int,int)
&&	O
cap	int
[	O
paintType	int
]	O
<	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
[	O
paintType	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
i	int
]	O
.	O
cap	int
)	O
cap	int
[	O
paintType	int
]	O
++	O
;	O
while	O
(	O
cap	int
[	O
paintType	int
]	O
<	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
[	O
paintType	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
i	int
]	O
.	O
cap	int
)	O
{	O
int	O
arcIndex	int
,	O
end	int
;	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
*	O
arcData0	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
;	O
arcIndex	int
=	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
[	O
paintType	int
]	O
.	O
caps	*(struct(int,int))
[	O
cap	int
[	O
paintType	int
]	O
]	O
.	O
arcIndex	int
;	O
end	int
=	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
[	O
paintType	int
]	O
.	O
caps	*(struct(int,int))
[	O
cap	int
[	O
paintType	int
]	O
]	O
.	O
end	int
;	O
arcData0	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
=	O
&	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
[	O
paintType	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
arcIndex	int
]	O
;	O
miArcCap	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(struct(double,double),struct(double,double),struct(double,double))),int,int,int,double,double)->(void)
(	O
paintedSet	*(struct)
,	O
pixel	struct(char,union(char,array(char)))
,	O
pGC	*(struct)
,	O
&	O
arcData0	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
[	O
end	int
]	O
,	O
end	int
,	O
arcData0	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
arc	struct(int,int,int,int,int,int)
.	O
x	double
,	O
arcData0	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
arc	struct(int,int,int,int,int,int)
.	O
y	double
,	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcData0	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
arc	struct(int,int,int,int,int,int)
.	O
width	array(short)
)	O
,	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcData0	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
arc	struct(int,int,int,int,int,int)
.	O
height	int
)	O
)	O
;	O
++	O
cap	int
[	O
paintType	int
]	O
;	O
}	O
while	O
(	O
join	int
[	O
paintType	int
]	O
<	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
[	O
paintType	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
i	int
]	O
.	O
join	int
)	O
{	O
int	O
arcIndex0	int
,	O
arcIndex1	int
,	O
end0	int
,	O
end1	int
;	O
int	O
paintType0	int
,	O
paintType1	int
;	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
*	O
arcData0	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
,	O
*	O
arcData1	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
;	O
miArcJoinStruct	struct(int,int,int,int,int,int)
*	O
joinp	*(struct(int,int,int,int,int,int))
;	O
joinp	*(struct(int,int,int,int,int,int))
=	O
&	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
[	O
paintType	int
]	O
.	O
joins	*(struct(int,int,int,int,int,int))
[	O
join	int
[	O
paintType	int
]	O
]	O
;	O
arcIndex0	int
=	O
joinp	*(struct(int,int,int,int,int,int))
->	O
arcIndex0	int
;	O
end0	int
=	O
joinp	*(struct(int,int,int,int,int,int))
->	O
end0	int
;	O
arcIndex1	int
=	O
joinp	*(struct(int,int,int,int,int,int))
->	O
arcIndex1	int
;	O
end1	int
=	O
joinp	*(struct(int,int,int,int,int,int))
->	O
end1	int
;	O
paintType0	int
=	O
joinp	*(struct(int,int,int,int,int,int))
->	O
paintType0	int
;	O
paintType1	int
=	O
joinp	*(struct(int,int,int,int,int,int))
->	O
paintType1	int
;	O
arcData0	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
=	O
&	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
[	O
paintType0	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
arcIndex0	int
]	O
;	O
arcData1	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
=	O
&	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
[	O
paintType1	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
arcIndex1	int
]	O
;	O
miArcJoin	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))),int,int,double,double,int,int,double,double)->(void)
(	O
paintedSet	*(struct)
,	O
pixel	struct(char,union(char,array(char)))
,	O
pGC	*(struct)
,	O
&	O
arcData0	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
[	O
end0	int
]	O
,	O
&	O
arcData1	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
[	O
end1	int
]	O
,	O
arcData0	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
arc	struct(int,int,int,int,int,int)
.	O
x	double
,	O
arcData0	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
arc	struct(int,int,int,int,int,int)
.	O
y	double
,	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcData0	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
arc	struct(int,int,int,int,int,int)
.	O
width	array(short)
)	O
,	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcData0	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
arc	struct(int,int,int,int,int,int)
.	O
height	int
)	O
,	O
arcData1	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
arc	struct(int,int,int,int,int,int)
.	O
x	double
,	O
arcData1	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
arc	struct(int,int,int,int,int,int)
.	O
y	double
,	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcData1	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
arc	struct(int,int,int,int,int,int)
.	O
width	array(short)
)	O
,	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcData1	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
->	O
arc	struct(int,int,int,int,int,int)
.	O
height	int
)	O
)	O
;	O
++	O
join	int
[	O
paintType	int
]	O
;	O
}	O
}	O
}	O
}	O
free	(*(void))->(void)
(	O
cap	int
)	O
;	O
free	(*(void))->(void)
(	O
join	int
)	O
;	O
miFreeArcs	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)))->(void)
(	O
pGC	*(struct)
,	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
)	O
;	O
}	O
}	O
miEllipseCache	struct
*	O
miNewEllipseCache	O
(	O
void	O
)	O
{	O
int	O
k	int
;	O
cachedEllipse	struct(long,int,int,int,*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
*	O
chead	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
,	O
*	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
miEllipseCache	struct
*	O
ellipseCache	*(struct)
;	O
ellipseCache	*(struct)
=	O
(	O
miEllipseCache	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miEllipseCache	struct
)	O
)	O
;	O
ellipseCache	*(struct)
->	O
ellipses	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
=	O
(	O
cachedEllipse	struct(long,int,int,int,*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
*	O
)	O
mi_xmalloc	O
(	O
ELLIPSECACHE_SIZE	int
*	O
sizeof	O
(	O
cachedEllipse	struct(long,int,int,int,*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
)	O
)	O
;	O
ellipseCache	*(struct)
->	O
size	double
=	O
ELLIPSECACHE_SIZE	int
;	O
ellipseCache	*(struct)
->	O
lastCacheHit	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
=	O
ellipseCache	*(struct)
->	O
ellipses	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
ellipseCache	*(struct)
->	O
lrustamp	long
=	O
0	int
;	O
chead	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
=	O
ellipseCache	*(struct)
->	O
ellipses	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
for	O
(	O
k	int
=	O
ELLIPSECACHE_SIZE	int
,	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
=	O
chead	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
--	O
k	int
>=	O
0	int
;	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
++	O
)	O
{	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
lrustamp	long
=	O
0	int
;	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
lw	int
=	O
0	int
;	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
width	array(short)
=	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
height	int
=	O
0	int
;	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
=	O
(	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
)	O
NULL	O
;	O
}	O
return	O
ellipseCache	*(struct)
;	O
}	O
void	O
miDeleteEllipseCache	O
(	O
miEllipseCache	struct
*	O
ellipseCache	*(struct)
)	O
{	O
int	O
k	int
,	O
cache_size	int
;	O
cachedEllipse	struct(long,int,int,int,*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
*	O
chead	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
,	O
*	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
chead	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
=	O
ellipseCache	*(struct)
->	O
ellipses	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
cache_size	int
=	O
ellipseCache	*(struct)
->	O
size	double
;	O
for	O
(	O
k	int
=	O
cache_size	int
,	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
=	O
chead	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
--	O
k	int
>=	O
0	int
;	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
++	O
)	O
{	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
=	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
;	O
if	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
{	O
free	(*(void))->(void)
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
spans	*(struct(int,*(struct(int,int)),*(int)))
)	O
;	O
free	(*(void))->(void)
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
chead	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
)	O
;	O
free	(*(void))->(void)
(	O
ellipseCache	*(struct)
)	O
;	O
}	O
static	O
void	O
miArcSegment	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),struct(int,int,int,int,int,int),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(*(struct(long,int,int,int,*`)),int,*(struct(long,int,int,int,*`)),long)))->(void)
(	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
miArc	struct(int,int,int,int,int,int)
tarc	*(struct(int,int,int,int,int,int))
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miEllipseCache	struct
*	O
ellipseCache	*(struct)
)	O
{	O
unsigned	O
int	O
l	int
=	O
pGC	*(struct)
->	O
lineWidth	int
;	O
int	O
a0	int
,	O
a1	int
,	O
startAngle	int
,	O
endAngle	int
;	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
temp	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
if	O
(	O
l	int
==	O
0	int
)	O
l	int
=	O
1	int
;	O
if	O
(	O
tarc	*(struct(int,int,int,int,int,int))
.	O
width	array(short)
==	O
0	int
||	O
tarc	*(struct(int,int,int,int,int,int))
.	O
height	int
==	O
0	int
)	O
{	O
drawZeroArc	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),*(struct(int,int,int,int,int,int)),int,*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))))->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
&	O
tarc	*(struct(int,int,int,int,int,int))
,	O
l	int
,	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
return	O
;	O
}	O
a0	int
=	O
tarc	*(struct(int,int,int,int,int,int))
.	O
angle1	int
;	O
a1	int
=	O
tarc	*(struct(int,int,int,int,int,int))
.	O
angle2	int
;	O
if	O
(	O
a1	int
>	O
FULLCIRCLE	O
)	O
a1	int
=	O
FULLCIRCLE	O
;	O
else	O
if	O
(	O
a1	int
<	O
-	O
FULLCIRCLE	O
)	O
a1	int
=	O
-	O
FULLCIRCLE	O
;	O
if	O
(	O
a1	int
<	O
0	int
)	O
{	O
startAngle	int
=	O
a0	int
+	O
a1	int
;	O
endAngle	int
=	O
a0	int
;	O
temp	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
temp	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
}	O
else	O
{	O
startAngle	int
=	O
a0	int
;	O
endAngle	int
=	O
a0	int
+	O
a1	int
;	O
}	O
if	O
(	O
startAngle	int
<	O
0	int
)	O
startAngle	int
=	O
FULLCIRCLE	O
-	O
(	O
-	O
startAngle	int
)	O
%	O
FULLCIRCLE	O
;	O
if	O
(	O
startAngle	int
>=	O
FULLCIRCLE	O
)	O
startAngle	int
=	O
startAngle	int
%	O
FULLCIRCLE	O
;	O
if	O
(	O
endAngle	int
<	O
0	int
)	O
endAngle	int
=	O
FULLCIRCLE	O
-	O
(	O
-	O
endAngle	int
)	O
%	O
FULLCIRCLE	O
;	O
if	O
(	O
endAngle	int
>	O
FULLCIRCLE	O
)	O
endAngle	int
=	O
(	O
endAngle	int
-	O
1	int
)	O
%	O
FULLCIRCLE	O
+	O
1	int
;	O
if	O
(	O
(	O
startAngle	int
==	O
endAngle	int
)	O
&&	O
a1	int
)	O
{	O
startAngle	int
=	O
0	int
;	O
endAngle	int
=	O
FULLCIRCLE	O
;	O
}	O
drawArc	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),*(struct(int,int,int,int,int,int)),int,int,int,*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(*(struct(long,int,int,int,*`)),int,*(struct(long,int,int,int,*`)),long)))->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
&	O
tarc	*(struct(int,int,int,int,int,int))
,	O
l	int
,	O
startAngle	int
,	O
endAngle	int
,	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
ellipseCache	*(struct)
)	O
;	O
}	O
static	O
void	O
miFillWideEllipse	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)),*(struct(*(struct(long,int,int,int,*`)),int,*(struct(long,int,int,int,*`)),long)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	struct(char,union(char,array(char)))
pixel	struct(char,union(char,array(char)))
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
parc	*(struct(int,int,int,int,int,int))
,	O
miEllipseCache	struct
*	O
ellipseCache	*(struct)
)	O
{	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
;	O
bool	enum(int,int)
mustFree	*(enum(int,int))
;	O
miArcSpan	struct(int,int,int,int)
*	O
arcSpan	*(struct(int,int,int,int))
,	O
*	O
finalArcSpan	*(struct(int,int,int,int))
;	O
int	O
xorg	int
,	O
yorgu	int
,	O
yorgl	int
;	O
int	O
numArcSpans	int
,	O
n	array(double)
;	O
int	O
numSpans_downward	int
,	O
numSpans_upward	int
,	O
numSpans	int
,	O
botSpans	int
;	O
miPoint	struct(int,int)
*	O
pptInit	*(struct(int,int))
,	O
*	O
ppt_downward	*(struct(int,int))
,	O
*	O
ppt_upward	*(struct(int,int))
;	O
unsigned	O
int	O
*	O
pwidthInit	*(int)
,	O
*	O
pwidth_downward	*(int)
,	O
*	O
pwidth_upward	*(int)
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
=	O
miComputeWideEllipse	(int,*(struct(int,int,int,int,int,int)),*(enum(int,int)),*(struct(*(struct(long,int,int,int,*`)),int,*(struct(long,int,int,int,*`)),long)))->(*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
(	O
pGC	*(struct)
->	O
lineWidth	int
,	O
parc	*(struct(int,int,int,int,int,int))
,	O
&	O
mustFree	*(enum(int,int))
,	O
ellipseCache	*(struct)
)	O
;	O
if	O
(	O
!	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
return	O
;	O
arcSpan	*(struct(int,int,int,int))
=	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
spans	*(struct(int,*(struct(int,int)),*(int)))
;	O
xorg	int
=	O
parc	*(struct(int,int,int,int,int,int))
->	O
x	double
+	O
(	O
int	O
)	O
(	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
>>	O
1	int
)	O
;	O
yorgu	int
=	O
parc	*(struct(int,int,int,int,int,int))
->	O
y	double
+	O
(	O
int	O
)	O
(	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
>>	O
1	int
)	O
;	O
yorgl	int
=	O
yorgu	int
+	O
(	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
)	O
;	O
yorgu	int
-=	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
k	int
;	O
yorgl	int
+=	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
k	int
;	O
numArcSpans	int
=	O
(	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
top	enum(int,int)
?	O
1	int
:	O
0	int
)	O
+	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count1	int
+	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count2	int
+	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
bot	enum(int,int)
?	O
1	int
:	O
0	int
)	O
)	O
;	O
finalArcSpan	*(struct(int,int,int,int))
=	O
&	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
spans	*(struct(int,*(struct(int,int)),*(int)))
[	O
numArcSpans	int
-	O
1	int
]	O
)	O
;	O
botSpans	int
=	O
(	O
finalArcSpan	*(struct(int,int,int,int))
->	O
rw	int
<=	O
0	int
?	O
1	int
:	O
2	int
)	O
;	O
numSpans_downward	int
=	O
(	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
top	enum(int,int)
?	O
1	int
:	O
0	int
)	O
+	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count1	int
+	O
2	int
*	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count2	int
+	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
bot	enum(int,int)
?	O
botSpans	int
:	O
0	int
)	O
)	O
;	O
numSpans_upward	int
=	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count1	int
+	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
hole	enum(int,int)
?	O
1	int
:	O
0	int
)	O
+	O
2	int
*	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count2	int
)	O
;	O
numSpans	int
=	O
numSpans_downward	int
+	O
numSpans_upward	int
;	O
pptInit	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
numSpans	int
*	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
)	O
;	O
pwidthInit	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
numSpans	int
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
ppt_downward	*(struct(int,int))
=	O
pptInit	*(struct(int,int))
;	O
pwidth_downward	*(int)
=	O
pwidthInit	*(int)
;	O
ppt_upward	*(struct(int,int))
=	O
pptInit	*(struct(int,int))
+	O
(	O
numSpans	int
-	O
1	int
)	O
;	O
pwidth_upward	*(int)
=	O
pwidthInit	*(int)
+	O
(	O
numSpans	int
-	O
1	int
)	O
;	O
if	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
top	enum(int,int)
)	O
{	O
ppt_downward	*(struct(int,int))
->	O
x	double
=	O
xorg	int
;	O
ppt_downward	*(struct(int,int))
->	O
y	double
=	O
yorgu	int
-	O
1	int
;	O
ppt_downward	*(struct(int,int))
++	O
;	O
*	O
pwidth_downward	*(int)
++	O
=	O
1	int
;	O
arcSpan	*(struct(int,int,int,int))
++	O
;	O
}	O
for	O
(	O
n	array(double)
=	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count1	int
;	O
--	O
n	array(double)
>=	O
0	int
;	O
)	O
{	O
ppt_downward	*(struct(int,int))
->	O
x	double
=	O
xorg	int
+	O
arcSpan	*(struct(int,int,int,int))
->	O
lx	int
;	O
ppt_downward	*(struct(int,int))
->	O
y	double
=	O
yorgu	int
;	O
*	O
pwidth_downward	*(int)
=	O
arcSpan	*(struct(int,int,int,int))
->	O
lw	int
;	O
ppt_downward	*(struct(int,int))
++	O
;	O
pwidth_downward	*(int)
++	O
;	O
ppt_upward	*(struct(int,int))
->	O
x	double
=	O
xorg	int
+	O
arcSpan	*(struct(int,int,int,int))
->	O
lx	int
;	O
ppt_upward	*(struct(int,int))
->	O
y	double
=	O
yorgl	int
;	O
*	O
pwidth_upward	*(int)
=	O
arcSpan	*(struct(int,int,int,int))
->	O
lw	int
;	O
ppt_upward	*(struct(int,int))
--	O
;	O
pwidth_upward	*(int)
--	O
;	O
yorgu	int
++	O
;	O
yorgl	int
--	O
;	O
arcSpan	*(struct(int,int,int,int))
++	O
;	O
}	O
if	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
hole	enum(int,int)
)	O
{	O
ppt_upward	*(struct(int,int))
->	O
x	double
=	O
xorg	int
;	O
ppt_upward	*(struct(int,int))
->	O
y	double
=	O
yorgl	int
;	O
*	O
pwidth_upward	*(int)
=	O
1	int
;	O
ppt_upward	*(struct(int,int))
--	O
;	O
pwidth_upward	*(int)
--	O
;	O
}	O
for	O
(	O
n	array(double)
=	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count2	int
;	O
--	O
n	array(double)
>=	O
0	int
;	O
)	O
{	O
ppt_downward	*(struct(int,int))
->	O
x	double
=	O
xorg	int
+	O
arcSpan	*(struct(int,int,int,int))
->	O
lx	int
;	O
ppt_downward	*(struct(int,int))
->	O
y	double
=	O
yorgu	int
;	O
*	O
pwidth_downward	*(int)
=	O
arcSpan	*(struct(int,int,int,int))
->	O
lw	int
;	O
ppt_downward	*(struct(int,int))
++	O
;	O
pwidth_downward	*(int)
++	O
;	O
ppt_downward	*(struct(int,int))
->	O
x	double
=	O
xorg	int
+	O
arcSpan	*(struct(int,int,int,int))
->	O
rx	double
;	O
ppt_downward	*(struct(int,int))
->	O
y	double
=	O
yorgu	int
;	O
*	O
pwidth_downward	*(int)
=	O
arcSpan	*(struct(int,int,int,int))
->	O
rw	int
;	O
ppt_downward	*(struct(int,int))
++	O
;	O
pwidth_downward	*(int)
++	O
;	O
ppt_upward	*(struct(int,int))
->	O
x	double
=	O
xorg	int
+	O
arcSpan	*(struct(int,int,int,int))
->	O
lx	int
;	O
ppt_upward	*(struct(int,int))
->	O
y	double
=	O
yorgl	int
;	O
*	O
pwidth_upward	*(int)
=	O
arcSpan	*(struct(int,int,int,int))
->	O
lw	int
;	O
ppt_upward	*(struct(int,int))
--	O
;	O
pwidth_upward	*(int)
--	O
;	O
ppt_upward	*(struct(int,int))
->	O
x	double
=	O
xorg	int
+	O
arcSpan	*(struct(int,int,int,int))
->	O
rx	double
;	O
ppt_upward	*(struct(int,int))
->	O
y	double
=	O
yorgl	int
;	O
*	O
pwidth_upward	*(int)
=	O
arcSpan	*(struct(int,int,int,int))
->	O
rw	int
;	O
ppt_upward	*(struct(int,int))
--	O
;	O
pwidth_upward	*(int)
--	O
;	O
yorgu	int
++	O
;	O
yorgl	int
--	O
;	O
arcSpan	*(struct(int,int,int,int))
++	O
;	O
}	O
if	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
bot	enum(int,int)
)	O
{	O
ppt_downward	*(struct(int,int))
->	O
x	double
=	O
xorg	int
+	O
arcSpan	*(struct(int,int,int,int))
->	O
lx	int
;	O
ppt_downward	*(struct(int,int))
->	O
y	double
=	O
yorgu	int
;	O
*	O
pwidth_downward	*(int)
=	O
arcSpan	*(struct(int,int,int,int))
->	O
lw	int
;	O
ppt_downward	*(struct(int,int))
++	O
;	O
pwidth_downward	*(int)
++	O
;	O
if	O
(	O
arcSpan	*(struct(int,int,int,int))
->	O
rw	int
>	O
0	int
)	O
{	O
ppt_downward	*(struct(int,int))
->	O
x	double
=	O
xorg	int
+	O
arcSpan	*(struct(int,int,int,int))
->	O
rx	double
;	O
ppt_downward	*(struct(int,int))
->	O
y	double
=	O
yorgu	int
;	O
*	O
pwidth_downward	*(int)
=	O
arcSpan	*(struct(int,int,int,int))
->	O
rw	int
;	O
ppt_downward	*(struct(int,int))
++	O
;	O
pwidth_downward	*(int)
++	O
;	O
}	O
}	O
if	O
(	O
mustFree	*(enum(int,int))
)	O
{	O
free	(*(void))->(void)
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
spans	*(struct(int,*(struct(int,int)),*(int)))
)	O
;	O
free	(*(void))->(void)
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
;	O
}	O
MI_PAINT_SPANS	O
(	O
paintedSet	*(struct)
,	O
pixel	struct(char,union(char,array(char)))
,	O
numSpans	int
,	O
pptInit	*(struct(int,int))
,	O
pwidthInit	*(int)
)	O
}	O
static	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
miComputeWideEllipse	(int,*(struct(int,int,int,int,int,int)),*(enum(int,int)),*(struct(*(struct(long,int,int,int,*`)),int,*(struct(long,int,int,int,*`)),long)))->(*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
(	O
unsigned	O
int	O
lw	int
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
parc	*(struct(int,int,int,int,int,int))
,	O
bool	enum(int,int)
*	O
mustFree	*(enum(int,int))
,	O
miEllipseCache	struct
*	O
ellipseCache	*(struct)
)	O
{	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
;	O
cachedEllipse	struct(long,int,int,int,*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
*	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
,	O
*	O
lruent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
int	O
k	int
,	O
cache_size	int
;	O
cachedEllipse	struct(long,int,int,int,*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
fakeent	struct(long,int,int,int,*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
;	O
if	O
(	O
lw	int
==	O
0	int
)	O
lw	int
=	O
1	int
;	O
if	O
(	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
<=	O
MAX_CACHEABLE_ELLIPSE_HEIGHT	int
)	O
{	O
*	O
mustFree	*(enum(int,int))
=	O
false	int
;	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
=	O
ellipseCache	*(struct)
->	O
lastCacheHit	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
if	O
(	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
lw	int
==	O
lw	int
&&	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
width	array(short)
==	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&&	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
height	int
==	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
{	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
lrustamp	long
=	O
++	O
(	O
ellipseCache	*(struct)
->	O
lrustamp	long
)	O
;	O
return	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
;	O
}	O
lruent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
=	O
ellipseCache	*(struct)
->	O
ellipses	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
cache_size	int
=	O
ellipseCache	*(struct)
->	O
size	double
;	O
for	O
(	O
k	int
=	O
cache_size	int
,	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
=	O
lruent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
--	O
k	int
>=	O
0	int
;	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
++	O
)	O
{	O
if	O
(	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
lw	int
==	O
lw	int
&&	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
width	array(short)
==	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&&	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
height	int
==	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
{	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
lrustamp	long
=	O
++	O
(	O
ellipseCache	*(struct)
->	O
lrustamp	long
)	O
;	O
ellipseCache	*(struct)
->	O
lastCacheHit	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
=	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
return	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
;	O
}	O
if	O
(	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
lrustamp	long
<	O
lruent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
lrustamp	long
)	O
lruent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
=	O
cent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
}	O
}	O
else	O
{	O
lruent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
=	O
&	O
fakeent	struct(long,int,int,int,*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
;	O
lruent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
=	O
(	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
)	O
NULL	O
;	O
*	O
mustFree	*(enum(int,int))
=	O
true	int
;	O
}	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
=	O
lruent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
;	O
k	int
=	O
(	O
int	O
)	O
(	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
>>	O
1	int
)	O
+	O
(	O
int	O
)	O
(	O
(	O
lw	int
-	O
1	int
)	O
>>	O
1	int
)	O
;	O
if	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
==	O
(	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
)	O
NULL	O
||	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
k	int
!=	O
k	int
)	O
{	O
if	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
{	O
free	(*(void))->(void)
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
spans	*(struct(int,*(struct(int,int)),*(int)))
)	O
;	O
free	(*(void))->(void)
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
;	O
}	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
=	O
(	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
)	O
)	O
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
spans	*(struct(int,*(struct(int,int)),*(int)))
=	O
(	O
miArcSpan	struct(int,int,int,int)
*	O
)	O
mi_xmalloc	O
(	O
(	O
k	int
+	O
2	int
)	O
*	O
sizeof	O
(	O
miArcSpan	struct(int,int,int,int)
)	O
)	O
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
k	int
=	O
k	int
;	O
lruent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
=	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
;	O
}	O
lruent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
lrustamp	long
=	O
++	O
(	O
ellipseCache	*(struct)
->	O
lrustamp	long
)	O
;	O
lruent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
lw	int
=	O
lw	int
;	O
lruent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
width	array(short)
=	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
;	O
lruent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
->	O
height	int
=	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
if	O
(	O
lruent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
!=	O
&	O
fakeent	struct(long,int,int,int,*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
)	O
ellipseCache	*(struct)
->	O
lastCacheHit	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
=	O
lruent	*(struct(long,int,int,int,*(struct(int,*(struct`),enum(int,int),int,int,enum(int,int),enum(int,int)))))
;	O
if	O
(	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
==	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
miComputeCircleSpans	(int,*(struct(int,int,int,int,int,int)),*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))->(void)
(	O
lw	int
,	O
parc	*(struct(int,int,int,int,int,int))
,	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
;	O
else	O
miComputeEllipseSpans	(int,*(struct(int,int,int,int,int,int)),*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))->(void)
(	O
lw	int
,	O
parc	*(struct(int,int,int,int,int,int))
,	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
;	O
return	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
;	O
}	O
static	O
void	O
miComputeCircleSpans	(int,*(struct(int,int,int,int,int,int)),*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))->(void)
(	O
unsigned	O
int	O
lw	int
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
parc	*(struct(int,int,int,int,int,int))
,	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
{	O
miArcSpan	struct(int,int,int,int)
*	O
span	*(struct(int,int,int,int))
;	O
int	O
doinner	int
;	O
int	O
x	double
,	O
y	double
,	O
e	int
;	O
int	O
xk	int
,	O
yk	int
,	O
xm	int
,	O
ym	int
,	O
dx	int
,	O
dy	int
;	O
int	O
slw	int
,	O
inslw	int
;	O
int	O
inx	int
=	O
0	int
,	O
iny	int
,	O
ine	int
=	O
0	int
;	O
int	O
inxk	int
=	O
0	int
,	O
inyk	int
=	O
0	int
,	O
inxm	int
=	O
0	int
,	O
inym	int
=	O
0	int
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
top	enum(int,int)
=	O
!	O
(	O
lw	int
&	O
1	int
)	O
&&	O
!	O
(	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&	O
1	int
)	O
?	O
true	int
:	O
false	int
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
bot	enum(int,int)
=	O
!	O
(	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
)	O
?	O
true	int
:	O
false	int
;	O
doinner	int
=	O
-	O
(	O
int	O
)	O
lw	int
;	O
slw	int
=	O
(	O
int	O
)	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
-	O
doinner	int
;	O
y	double
=	O
(	O
int	O
)	O
(	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
>>	O
1	int
)	O
;	O
dy	int
=	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
;	O
dx	int
=	O
1	int
-	O
dy	int
;	O
MIWIDEARCSETUP	O
(	O
x	double
,	O
y	double
,	O
dy	int
,	O
slw	int
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
)	O
;	O
inslw	int
=	O
(	O
int	O
)	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
+	O
doinner	int
;	O
if	O
(	O
inslw	int
>	O
0	int
)	O
{	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
hole	enum(int,int)
=	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
top	enum(int,int)
;	O
MIWIDEARCSETUP	O
(	O
inx	int
,	O
iny	int
,	O
dy	int
,	O
inslw	int
,	O
ine	int
,	O
inxk	int
,	O
inxm	int
,	O
inyk	int
,	O
inym	int
)	O
;	O
}	O
else	O
{	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
hole	enum(int,int)
=	O
false	int
;	O
doinner	int
=	O
-	O
y	double
;	O
}	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count1	int
=	O
-	O
doinner	int
-	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
top	enum(int,int)
?	O
1	int
:	O
0	int
)	O
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count2	int
=	O
y	double
+	O
doinner	int
;	O
span	*(struct(int,int,int,int))
=	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
spans	*(struct(int,*(struct(int,int)),*(int)))
;	O
while	O
(	O
y	double
)	O
{	O
MIFILLARCSTEP	O
(	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
slw	int
)	O
;	O
span	*(struct(int,int,int,int))
->	O
lx	int
=	O
dy	int
-	O
x	double
;	O
if	O
(	O
++	O
doinner	int
<=	O
0	int
)	O
{	O
span	*(struct(int,int,int,int))
->	O
lw	int
=	O
slw	int
;	O
span	*(struct(int,int,int,int))
->	O
rx	double
=	O
0	int
;	O
span	*(struct(int,int,int,int))
->	O
rw	int
=	O
span	*(struct(int,int,int,int))
->	O
lx	int
+	O
slw	int
;	O
}	O
else	O
{	O
MIFILLINARCSTEP	O
(	O
inx	int
,	O
iny	int
,	O
ine	int
,	O
inxk	int
,	O
inxm	int
,	O
inyk	int
,	O
inym	int
,	O
dx	int
,	O
inslw	int
)	O
;	O
span	*(struct(int,int,int,int))
->	O
lw	int
=	O
x	double
-	O
inx	int
;	O
span	*(struct(int,int,int,int))
->	O
rx	double
=	O
dy	int
-	O
inx	int
+	O
inslw	int
;	O
span	*(struct(int,int,int,int))
->	O
rw	int
=	O
inx	int
-	O
x	double
+	O
slw	int
-	O
inslw	int
;	O
}	O
span	*(struct(int,int,int,int))
++	O
;	O
}	O
if	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
bot	enum(int,int)
)	O
{	O
if	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count2	int
>	O
0	int
)	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count2	int
--	O
;	O
else	O
{	O
if	O
(	O
lw	int
>	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
span	*(struct(int,int,int,int))
[	O
-	O
1	int
]	O
.	O
rx	double
=	O
span	*(struct(int,int,int,int))
[	O
-	O
1	int
]	O
.	O
rw	int
=	O
-	O
(	O
(	O
(	O
int	O
)	O
lw	int
-	O
(	O
int	O
)	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
>>	O
1	int
)	O
;	O
else	O
span	*(struct(int,int,int,int))
[	O
-	O
1	int
]	O
.	O
rw	int
=	O
0	int
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count1	int
--	O
;	O
}	O
}	O
}	O
static	O
void	O
miComputeEllipseSpans	(int,*(struct(int,int,int,int,int,int)),*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))->(void)
(	O
unsigned	O
int	O
lw	int
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
parc	*(struct(int,int,int,int,int,int))
,	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
{	O
miArcSpan	struct(int,int,int,int)
*	O
span	*(struct(int,int,int,int))
;	O
double	O
w	double
,	O
h	double
,	O
r	int
,	O
xorg	int
;	O
double	O
Hs	double
,	O
Hf	double
,	O
WH	double
,	O
K	double
,	O
Vk	double
,	O
Nk	double
,	O
Fk	double
,	O
Vr	double
,	O
N	double
,	O
Nc	double
,	O
Z	double
,	O
rs	double
;	O
double	O
A	double
,	O
T	double
,	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
d	double
,	O
x	double
,	O
y	double
,	O
t	double
,	O
inx	int
,	O
outx	double
=	O
0	int
,	O
hepp	double
,	O
hepm	double
;	O
int	O
flip	int
;	O
bool	enum(int,int)
solution	enum(int,int)
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
top	enum(int,int)
=	O
!	O
(	O
lw	int
&	O
1	int
)	O
&&	O
!	O
(	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&	O
1	int
)	O
?	O
true	int
:	O
false	int
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
bot	enum(int,int)
=	O
!	O
(	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
)	O
?	O
true	int
:	O
false	int
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
hole	enum(int,int)
=	O
(	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
top	enum(int,int)
&&	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
*	O
lw	int
<=	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
*	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&&	O
lw	int
<	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
?	O
true	int
:	O
false	int
)	O
;	O
w	double
=	O
0.5	int
*	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
;	O
h	double
=	O
0.5	int
*	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
r	int
=	O
0.5	int
*	O
lw	int
;	O
rs	double
=	O
r	int
*	O
r	int
;	O
Hs	double
=	O
h	double
*	O
h	double
;	O
WH	double
=	O
w	double
*	O
w	double
-	O
Hs	double
;	O
Nk	double
=	O
w	double
*	O
r	int
;	O
Vk	double
=	O
(	O
Nk	double
*	O
Hs	double
)	O
/	O
(	O
WH	double
+	O
WH	double
)	O
;	O
Hf	double
=	O
Hs	double
*	O
Hs	double
;	O
Nk	double
=	O
(	O
Hf	double
-	O
Nk	double
*	O
Nk	double
)	O
/	O
WH	double
;	O
Fk	double
=	O
Hf	double
/	O
WH	double
;	O
hepp	double
=	O
h	double
+	O
EPSILON	int
;	O
hepm	double
=	O
h	double
-	O
EPSILON	int
;	O
K	double
=	O
h	double
+	O
(	O
(	O
lw	int
-	O
1	int
)	O
>>	O
1	int
)	O
;	O
if	O
(	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&	O
1	int
)	O
xorg	int
=	O
.5	int
;	O
else	O
xorg	int
=	O
0.0	int
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count1	int
=	O
0	int
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count2	int
=	O
0	int
;	O
span	*(struct(int,int,int,int))
=	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
spans	*(struct(int,*(struct(int,int)),*(int)))
;	O
if	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
top	enum(int,int)
)	O
{	O
span	*(struct(int,int,int,int))
->	O
lx	int
=	O
0	int
;	O
span	*(struct(int,int,int,int))
->	O
lw	int
=	O
1	int
;	O
span	*(struct(int,int,int,int))
++	O
;	O
}	O
for	O
(	O
;	O
K	double
>	O
0.0	int
;	O
K	double
-=	O
1.0	int
)	O
{	O
N	double
=	O
(	O
K	double
*	O
K	double
+	O
Nk	double
)	O
/	O
6.0	int
;	O
Nc	double
=	O
N	double
*	O
N	double
*	O
N	double
;	O
Vr	double
=	O
Vk	double
*	O
K	double
;	O
t	double
=	O
Nc	double
+	O
Vr	double
*	O
Vr	double
;	O
d	double
=	O
Nc	double
+	O
t	double
;	O
if	O
(	O
d	double
<	O
0.0	int
)	O
{	O
d	double
=	O
Nc	double
;	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
N	double
;	O
if	O
(	O
(	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
<	O
0.0	int
)	O
==	O
(	O
t	double
<	O
0.0	int
)	O
)	O
{	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
-	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
d	double
=	O
-	O
d	double
;	O
}	O
Z	double
=	O
N	double
-	O
2.0	int
*	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
*	O
cos	(double)->(double)
(	O
acos	(double)->(double)
(	O
-	O
t	double
/	O
d	double
)	O
/	O
3.0	int
)	O
;	O
if	O
(	O
(	O
Z	double
<	O
0.0	int
)	O
==	O
(	O
Vr	double
<	O
0.0	int
)	O
)	O
flip	int
=	O
2	int
;	O
else	O
flip	int
=	O
1	int
;	O
}	O
else	O
{	O
d	double
=	O
Vr	double
*	O
sqrt	(double)->(double)
(	O
d	double
)	O
;	O
Z	double
=	O
N	double
+	O
cbrt	(double)->(double)
(	O
t	double
+	O
d	double
)	O
+	O
cbrt	(double)->(double)
(	O
t	double
-	O
d	double
)	O
;	O
flip	int
=	O
0	int
;	O
}	O
A	double
=	O
sqrt	(double)->(double)
(	O
(	O
Z	double
+	O
Z	double
)	O
-	O
Nk	double
)	O
;	O
T	double
=	O
(	O
Fk	double
-	O
Z	double
)	O
*	O
K	double
/	O
A	double
;	O
inx	int
=	O
0.0	int
;	O
solution	enum(int,int)
=	O
false	int
;	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
-	O
A	double
+	O
K	double
;	O
d	double
=	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
*	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
-	O
4	int
*	O
(	O
Z	double
+	O
T	double
)	O
;	O
if	O
(	O
d	double
>=	O
0	int
)	O
{	O
d	double
=	O
sqrt	(double)->(double)
(	O
d	double
)	O
;	O
y	double
=	O
0.5	int
*	O
(	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
+	O
d	double
)	O
;	O
if	O
(	O
(	O
y	double
>=	O
0.0	int
)	O
&&	O
(	O
y	double
<	O
hepp	double
)	O
)	O
{	O
solution	enum(int,int)
=	O
true	int
;	O
if	O
(	O
y	double
>	O
hepm	double
)	O
y	double
=	O
h	double
;	O
t	double
=	O
y	double
/	O
h	double
;	O
x	double
=	O
w	double
*	O
sqrt	(double)->(double)
(	O
1	int
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
t	double
=	O
K	double
-	O
y	double
;	O
t	double
=	O
sqrt	(double)->(double)
(	O
rs	double
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
if	O
(	O
flip	int
==	O
2	int
)	O
inx	int
=	O
x	double
-	O
t	double
;	O
else	O
outx	double
=	O
x	double
+	O
t	double
;	O
}	O
}	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
A	double
+	O
K	double
;	O
d	double
=	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
*	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
-	O
4	int
*	O
(	O
Z	double
-	O
T	double
)	O
;	O
if	O
(	O
d	double
<	O
0	int
&&	O
!	O
solution	enum(int,int)
)	O
d	double
=	O
0.0	int
;	O
if	O
(	O
d	double
>=	O
0	int
)	O
{	O
d	double
=	O
sqrt	(double)->(double)
(	O
d	double
)	O
;	O
y	double
=	O
0.5	int
*	O
(	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
+	O
d	double
)	O
;	O
if	O
(	O
y	double
<	O
hepp	double
)	O
{	O
if	O
(	O
y	double
>	O
hepm	double
)	O
y	double
=	O
h	double
;	O
t	double
=	O
y	double
/	O
h	double
;	O
x	double
=	O
w	double
*	O
sqrt	(double)->(double)
(	O
1	int
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
t	double
=	O
K	double
-	O
y	double
;	O
inx	int
=	O
x	double
-	O
sqrt	(double)->(double)
(	O
rs	double
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
}	O
y	double
=	O
0.5	int
*	O
(	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
-	O
d	double
)	O
;	O
if	O
(	O
y	double
>=	O
0.0	int
)	O
{	O
if	O
(	O
y	double
>	O
hepm	double
)	O
y	double
=	O
h	double
;	O
t	double
=	O
y	double
/	O
h	double
;	O
x	double
=	O
w	double
*	O
sqrt	(double)->(double)
(	O
1	int
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
t	double
=	O
K	double
-	O
y	double
;	O
t	double
=	O
sqrt	(double)->(double)
(	O
rs	double
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
if	O
(	O
flip	int
==	O
1	int
)	O
inx	int
=	O
x	double
-	O
t	double
;	O
else	O
outx	double
=	O
x	double
+	O
t	double
;	O
}	O
}	O
span	*(struct(int,int,int,int))
->	O
lx	int
=	O
ICEIL	O
(	O
xorg	int
-	O
outx	double
)	O
;	O
if	O
(	O
inx	int
<=	O
0.0	int
)	O
{	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count1	int
++	O
;	O
span	*(struct(int,int,int,int))
->	O
lw	int
=	O
ICEIL	O
(	O
xorg	int
+	O
outx	double
)	O
-	O
span	*(struct(int,int,int,int))
->	O
lx	int
;	O
span	*(struct(int,int,int,int))
->	O
rx	double
=	O
ICEIL	O
(	O
xorg	int
+	O
inx	int
)	O
;	O
span	*(struct(int,int,int,int))
->	O
rw	int
=	O
-	O
ICEIL	O
(	O
xorg	int
-	O
inx	int
)	O
;	O
}	O
else	O
{	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count2	int
++	O
;	O
span	*(struct(int,int,int,int))
->	O
lw	int
=	O
ICEIL	O
(	O
xorg	int
-	O
inx	int
)	O
-	O
span	*(struct(int,int,int,int))
->	O
lx	int
;	O
span	*(struct(int,int,int,int))
->	O
rx	double
=	O
ICEIL	O
(	O
xorg	int
+	O
inx	int
)	O
;	O
span	*(struct(int,int,int,int))
->	O
rw	int
=	O
ICEIL	O
(	O
xorg	int
+	O
outx	double
)	O
-	O
span	*(struct(int,int,int,int))
->	O
rx	double
;	O
}	O
span	*(struct(int,int,int,int))
++	O
;	O
}	O
if	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
bot	enum(int,int)
)	O
{	O
outx	double
=	O
w	double
+	O
r	int
;	O
if	O
(	O
r	int
>=	O
h	double
&&	O
r	int
<=	O
w	double
)	O
inx	int
=	O
0.0	int
;	O
else	O
if	O
(	O
Nk	double
<	O
0.0	int
&&	O
-	O
Nk	double
<	O
Hs	double
)	O
{	O
inx	int
=	O
w	double
*	O
sqrt	(double)->(double)
(	O
1	int
+	O
Nk	double
/	O
Hs	double
)	O
-	O
sqrt	(double)->(double)
(	O
rs	double
+	O
Nk	double
)	O
;	O
if	O
(	O
inx	int
>	O
w	double
-	O
r	int
)	O
inx	int
=	O
w	double
-	O
r	int
;	O
}	O
else	O
inx	int
=	O
w	double
-	O
r	int
;	O
span	*(struct(int,int,int,int))
->	O
lx	int
=	O
ICEIL	O
(	O
xorg	int
-	O
outx	double
)	O
;	O
if	O
(	O
inx	int
<=	O
0.0	int
)	O
{	O
span	*(struct(int,int,int,int))
->	O
lw	int
=	O
ICEIL	O
(	O
xorg	int
+	O
outx	double
)	O
-	O
span	*(struct(int,int,int,int))
->	O
lx	int
;	O
span	*(struct(int,int,int,int))
->	O
rx	double
=	O
ICEIL	O
(	O
xorg	int
+	O
inx	int
)	O
;	O
span	*(struct(int,int,int,int))
->	O
rw	int
=	O
-	O
ICEIL	O
(	O
xorg	int
-	O
inx	int
)	O
;	O
}	O
else	O
{	O
span	*(struct(int,int,int,int))
->	O
lw	int
=	O
ICEIL	O
(	O
xorg	int
-	O
inx	int
)	O
-	O
span	*(struct(int,int,int,int))
->	O
lx	int
;	O
span	*(struct(int,int,int,int))
->	O
rx	double
=	O
ICEIL	O
(	O
xorg	int
+	O
inx	int
)	O
;	O
span	*(struct(int,int,int,int))
->	O
rw	int
=	O
ICEIL	O
(	O
xorg	int
+	O
outx	double
)	O
-	O
span	*(struct(int,int,int,int))
->	O
rx	double
;	O
}	O
}	O
if	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
hole	enum(int,int)
)	O
{	O
span	*(struct(int,int,int,int))
=	O
&	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
spans	*(struct(int,*(struct(int,int)),*(int)))
[	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count1	int
]	O
;	O
span	*(struct(int,int,int,int))
->	O
lw	int
=	O
-	O
span	*(struct(int,int,int,int))
->	O
lx	int
;	O
span	*(struct(int,int,int,int))
->	O
rx	double
=	O
1	int
;	O
span	*(struct(int,int,int,int))
->	O
rw	int
=	O
span	*(struct(int,int,int,int))
->	O
lw	int
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count1	int
--	O
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count2	int
++	O
;	O
}	O
}	O
static	O
miPolyArcs	struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)
*	O
miComputeArcs	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)),int)->(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)))
(	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
parcs	*(struct(int,int,int,int,int,int))
,	O
int	O
narcs	int
)	O
{	O
bool	enum(int,int)
isDashed	enum(int,int)
,	O
isDoubleDash	enum(int,int)
;	O
miPolyArcs	struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)
*	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
;	O
int	O
i	int
,	O
start	int
,	O
k	int
,	O
nextk	int
;	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
*	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
;	O
int	O
numPixels	int
;	O
int	O
paintType	int
,	O
paintTypeStart	int
,	O
prevPaintType	int
;	O
int	O
dashNum	int
,	O
dashIndex	int
,	O
dashRemaining	int
;	O
int	O
dashNumStart	int
,	O
dashIndexStart	int
,	O
dashRemainingStart	int
;	O
isDashed	enum(int,int)
=	O
(	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_SOLID	int
?	O
false	int
:	O
true	int
)	O
;	O
isDoubleDash	enum(int,int)
=	O
(	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
?	O
true	int
:	O
false	int
)	O
;	O
numPixels	int
=	O
pGC	*(struct)
->	O
numPixels	int
;	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
=	O
(	O
miPolyArcs	struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)
*	O
)	O
mi_xmalloc	O
(	O
numPixels	int
*	O
sizeof	O
(	O
miPolyArcs	struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)
)	O
)	O
;	O
for	O
(	O
paintType	int
=	O
0	int
;	O
paintType	int
<	O
numPixels	int
;	O
paintType	int
++	O
)	O
{	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
=	O
(	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
*	O
)	O
NULL	O
;	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
narcs	int
=	O
0	int
;	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
arcSize	int
=	O
0	int
;	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
caps	*(struct(int,int))
=	O
(	O
miArcCapStruct	struct(int,int)
*	O
)	O
NULL	O
;	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
ncaps	int
=	O
0	int
;	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
capSize	int
=	O
0	int
;	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
joins	*(struct(int,int,int,int,int,int))
=	O
(	O
miArcJoinStruct	struct(int,int,int,int,int,int)
*	O
)	O
NULL	O
;	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
njoins	int
=	O
0	int
;	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
joinSize	int
=	O
0	int
;	O
}	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
=	O
(	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
*	O
)	O
mi_xmalloc	O
(	O
narcs	int
*	O
sizeof	O
(	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
narcs	int
;	O
i	int
++	O
)	O
{	O
double	O
a0	int
,	O
a1	int
;	O
int	O
angle2	int
;	O
a0	int
=	O
todeg	O
(	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
.	O
angle1	int
)	O
;	O
angle2	int
=	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
.	O
angle2	int
;	O
if	O
(	O
angle2	int
>	O
FULLCIRCLE	O
)	O
angle2	int
=	O
FULLCIRCLE	O
;	O
else	O
if	O
(	O
angle2	int
<	O
-	O
FULLCIRCLE	O
)	O
angle2	int
=	O
-	O
FULLCIRCLE	O
;	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
i	int
]	O
.	O
selfJoin	enum(int,int)
=	O
(	O
(	O
angle2	int
==	O
FULLCIRCLE	O
)	O
||	O
(	O
angle2	int
==	O
-	O
FULLCIRCLE	O
)	O
?	O
true	int
:	O
false	int
)	O
;	O
a1	int
=	O
todeg	O
(	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
.	O
angle1	int
+	O
angle2	int
)	O
;	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
i	int
]	O
.	O
x0	double
=	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
.	O
x	double
+	O
(	O
double	O
)	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
.	O
width	array(short)
/	O
2	int
*	O
(	O
1	int
+	O
miDcos	(double)->(double)
(	O
a0	int
)	O
)	O
;	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
i	int
]	O
.	O
y0	(double)->(double)
=	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
.	O
y	double
+	O
(	O
double	O
)	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
.	O
height	int
/	O
2	int
*	O
(	O
1	int
-	O
miDsin	(double)->(double)
(	O
a0	int
)	O
)	O
;	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
i	int
]	O
.	O
x1	double
=	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
.	O
x	double
+	O
(	O
double	O
)	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
.	O
width	array(short)
/	O
2	int
*	O
(	O
1	int
+	O
miDcos	(double)->(double)
(	O
a1	int
)	O
)	O
;	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
i	int
]	O
.	O
y1	(double)->(double)
=	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
.	O
y	double
+	O
(	O
double	O
)	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
.	O
height	int
/	O
2	int
*	O
(	O
1	int
-	O
miDsin	(double)->(double)
(	O
a1	int
)	O
)	O
;	O
}	O
paintType	int
=	O
1	int
;	O
dashNum	int
=	O
0	int
;	O
dashIndex	int
=	O
0	int
;	O
dashRemaining	int
=	O
0	int
;	O
if	O
(	O
isDashed	enum(int,int)
)	O
{	O
int	O
dashOffset	int
=	O
0	int
;	O
miStepDash	O
(	O
pGC	*(struct)
->	O
dashOffset	int
,	O
&	O
dashNum	int
,	O
&	O
dashIndex	int
,	O
pGC	*(struct)
->	O
dash	*(int)
,	O
pGC	*(struct)
->	O
numInDashList	int
,	O
&	O
dashOffset	int
)	O
;	O
paintType	int
=	O
(	O
dashNum	int
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
dashNum	int
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
;	O
dashRemaining	int
=	O
(	O
int	O
)	O
(	O
pGC	*(struct)
->	O
dash	*(int)
[	O
dashIndex	int
]	O
)	O
-	O
dashOffset	int
;	O
}	O
paintTypeStart	int
=	O
paintType	int
;	O
dashNumStart	int
=	O
dashNum	int
;	O
dashIndexStart	int
=	O
dashIndex	int
;	O
dashRemainingStart	int
=	O
dashRemaining	int
;	O
for	O
(	O
i	int
=	O
narcs	int
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
{	O
int	O
j	int
;	O
j	int
=	O
i	int
+	O
1	int
;	O
if	O
(	O
j	int
==	O
narcs	int
)	O
j	int
=	O
0	int
;	O
if	O
(	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
i	int
]	O
.	O
selfJoin	enum(int,int)
||	O
i	int
==	O
j	int
||	O
(	O
UNEQUAL	O
(	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
i	int
]	O
.	O
x1	double
,	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
j	int
]	O
.	O
x0	double
)	O
||	O
UNEQUAL	O
(	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
i	int
]	O
.	O
y1	(double)->(double)
,	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
j	int
]	O
.	O
y0	(double)->(double)
)	O
)	O
)	O
{	O
if	O
(	O
paintType	int
!=	O
0	int
||	O
isDoubleDash	enum(int,int)
)	O
addCap	(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)),int,int)->(void)
(	O
&	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
,	O
RIGHT_END	int
,	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
start	int
=	O
i	int
+	O
1	int
;	O
if	O
(	O
start	int
==	O
narcs	int
)	O
start	int
=	O
0	int
;	O
i	int
=	O
start	int
;	O
k	int
=	O
nextk	int
=	O
0	int
;	O
prevPaintType	int
=	O
paintType	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
j	int
,	O
nexti	int
;	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
*	O
arc	struct(int,int,int,int,int,int)
;	O
bool	enum(int,int)
arcsJoin	enum(int,int)
;	O
j	int
=	O
i	int
+	O
1	int
;	O
if	O
(	O
j	int
==	O
narcs	int
)	O
j	int
=	O
0	int
;	O
nexti	int
=	O
i	int
+	O
1	int
;	O
if	O
(	O
nexti	int
==	O
narcs	int
)	O
nexti	int
=	O
0	int
;	O
if	O
(	O
isDashed	enum(int,int)
)	O
{	O
int	O
startAngle	int
,	O
spanAngle	int
,	O
endAngle	int
;	O
int	O
dashAngle	int
,	O
prevDashAngle	int
;	O
bool	enum(int,int)
backwards	enum(int,int)
,	O
selfJoin	enum(int,int)
;	O
dashMap	struct(array(double))
map	array(double)
;	O
miArc	struct(int,int,int,int,int,int)
xarc	*(struct(int,int,int,int,int,int))
;	O
computeDashMap	(*(struct(int,int,int,int,int,int)),*(struct(array(double))))->(void)
(	O
&	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
,	O
&	O
map	array(double)
)	O
;	O
startAngle	int
=	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
.	O
angle1	int
;	O
spanAngle	int
=	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
.	O
angle2	int
;	O
if	O
(	O
spanAngle	int
>	O
FULLCIRCLE	O
)	O
spanAngle	int
=	O
FULLCIRCLE	O
;	O
else	O
if	O
(	O
spanAngle	int
<	O
-	O
FULLCIRCLE	O
)	O
spanAngle	int
=	O
-	O
FULLCIRCLE	O
;	O
if	O
(	O
startAngle	int
<	O
0	int
)	O
startAngle	int
=	O
FULLCIRCLE	O
-	O
(	O
-	O
startAngle	int
)	O
%	O
FULLCIRCLE	O
;	O
if	O
(	O
startAngle	int
>=	O
FULLCIRCLE	O
)	O
startAngle	int
=	O
startAngle	int
%	O
FULLCIRCLE	O
;	O
endAngle	int
=	O
startAngle	int
+	O
spanAngle	int
;	O
backwards	enum(int,int)
=	O
(	O
spanAngle	int
<	O
0	int
?	O
true	int
:	O
false	int
)	O
;	O
dashAngle	int
=	O
startAngle	int
;	O
selfJoin	enum(int,int)
=	O
(	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
i	int
]	O
.	O
selfJoin	enum(int,int)
&&	O
(	O
paintType	int
!=	O
0	int
||	O
isDoubleDash	enum(int,int)
)	O
?	O
true	int
:	O
false	int
)	O
;	O
arc	struct(int,int,int,int,int,int)
=	O
(	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
*	O
)	O
NULL	O
;	O
while	O
(	O
dashAngle	int
!=	O
endAngle	int
)	O
{	O
prevDashAngle	int
=	O
dashAngle	int
;	O
dashAngle	int
=	O
computeAngleFromPath	(int,int,*(struct(array(double))),*(int),enum(int,int))->(int)
(	O
prevDashAngle	int
,	O
endAngle	int
,	O
&	O
map	array(double)
,	O
&	O
dashRemaining	int
,	O
backwards	enum(int,int)
)	O
;	O
if	O
(	O
dashAngle	int
==	O
prevDashAngle	int
)	O
{	O
if	O
(	O
backwards	enum(int,int)
)	O
dashAngle	int
--	O
;	O
else	O
dashAngle	int
++	O
;	O
}	O
if	O
(	O
paintType	int
!=	O
0	int
||	O
isDoubleDash	enum(int,int)
)	O
{	O
xarc	*(struct(int,int,int,int,int,int))
=	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
;	O
spanAngle	int
=	O
prevDashAngle	int
;	O
if	O
(	O
spanAngle	int
<	O
0	int
)	O
spanAngle	int
=	O
FULLCIRCLE	O
-	O
(	O
-	O
spanAngle	int
)	O
%	O
FULLCIRCLE	O
;	O
if	O
(	O
spanAngle	int
>=	O
FULLCIRCLE	O
)	O
spanAngle	int
=	O
spanAngle	int
%	O
FULLCIRCLE	O
;	O
xarc	*(struct(int,int,int,int,int,int))
.	O
angle1	int
=	O
spanAngle	int
;	O
spanAngle	int
=	O
dashAngle	int
-	O
prevDashAngle	int
;	O
if	O
(	O
backwards	enum(int,int)
)	O
{	O
if	O
(	O
dashAngle	int
>	O
prevDashAngle	int
)	O
spanAngle	int
=	O
-	O
FULLCIRCLE	O
+	O
spanAngle	int
;	O
}	O
else	O
{	O
if	O
(	O
dashAngle	int
<	O
prevDashAngle	int
)	O
spanAngle	int
=	O
FULLCIRCLE	O
+	O
spanAngle	int
;	O
}	O
if	O
(	O
spanAngle	int
>	O
FULLCIRCLE	O
)	O
spanAngle	int
=	O
FULLCIRCLE	O
;	O
if	O
(	O
spanAngle	int
<	O
-	O
FULLCIRCLE	O
)	O
spanAngle	int
=	O
-	O
FULLCIRCLE	O
;	O
xarc	*(struct(int,int,int,int,int,int))
.	O
angle2	int
=	O
spanAngle	int
;	O
arc	struct(int,int,int,int,int,int)
=	O
addArc	(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)),*(struct(int,int,int,int,int,int)))->(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)))
(	O
&	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
,	O
&	O
xarc	*(struct(int,int,int,int,int,int))
)	O
;	O
if	O
(	O
!	O
isDoubleDash	enum(int,int)
)	O
{	O
if	O
(	O
prevDashAngle	int
!=	O
startAngle	int
)	O
addCap	(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)),int,int)->(void)
(	O
&	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
,	O
RIGHT_END	int
,	O
arc	struct(int,int,int,int,int,int)
-	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
)	O
;	O
if	O
(	O
dashAngle	int
!=	O
endAngle	int
)	O
addCap	(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)),int,int)->(void)
(	O
&	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
,	O
LEFT_END	int
,	O
arc	struct(int,int,int,int,int,int)
-	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
)	O
;	O
}	O
arc	struct(int,int,int,int,int,int)
->	O
cap	int
=	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
ncaps	int
;	O
arc	struct(int,int,int,int,int,int)
->	O
join	int
=	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
njoins	int
;	O
arc	struct(int,int,int,int,int,int)
->	O
render	enum(int,int)
=	O
false	int
;	O
arc	struct(int,int,int,int,int,int)
->	O
selfJoin	enum(int,int)
=	O
false	int
;	O
if	O
(	O
dashAngle	int
==	O
endAngle	int
)	O
arc	struct(int,int,int,int,int,int)
->	O
selfJoin	enum(int,int)
=	O
selfJoin	enum(int,int)
;	O
}	O
prevPaintType	int
=	O
paintType	int
;	O
if	O
(	O
dashRemaining	int
<=	O
0	int
)	O
{	O
dashNum	int
++	O
;	O
dashIndex	int
++	O
;	O
if	O
(	O
dashIndex	int
==	O
pGC	*(struct)
->	O
numInDashList	int
)	O
dashIndex	int
=	O
0	int
;	O
paintType	int
=	O
(	O
dashNum	int
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
dashNum	int
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
;	O
dashRemaining	int
=	O
(	O
int	O
)	O
(	O
pGC	*(struct)
->	O
dash	*(int)
[	O
dashIndex	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
startAngle	int
==	O
endAngle	int
)	O
{	O
prevPaintType	int
=	O
paintType	int
;	O
if	O
(	O
isDoubleDash	enum(int,int)
==	O
false	int
&&	O
paintType	int
==	O
0	int
)	O
{	O
if	O
(	O
dashNum	int
==	O
0	int
)	O
prevPaintType	int
=	O
numPixels	int
-	O
1	int
;	O
else	O
prevPaintType	int
=	O
(	O
(	O
dashNum	int
-	O
1	int
)	O
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
(	O
dashNum	int
-	O
1	int
)	O
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
;	O
}	O
arc	struct(int,int,int,int,int,int)
=	O
addArc	(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)),*(struct(int,int,int,int,int,int)))->(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)))
(	O
&	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
prevPaintType	int
]	O
,	O
&	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
)	O
;	O
arc	struct(int,int,int,int,int,int)
->	O
join	int
=	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
prevPaintType	int
]	O
.	O
njoins	int
;	O
arc	struct(int,int,int,int,int,int)
->	O
cap	int
=	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
prevPaintType	int
]	O
.	O
ncaps	int
;	O
arc	struct(int,int,int,int,int,int)
->	O
selfJoin	enum(int,int)
=	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
i	int
]	O
.	O
selfJoin	enum(int,int)
;	O
}	O
}	O
else	O
{	O
arc	struct(int,int,int,int,int,int)
=	O
addArc	(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)),*(struct(int,int,int,int,int,int)))->(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)))
(	O
&	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
,	O
&	O
parcs	*(struct(int,int,int,int,int,int))
[	O
i	int
]	O
)	O
;	O
arc	struct(int,int,int,int,int,int)
->	O
join	int
=	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
njoins	int
;	O
arc	struct(int,int,int,int,int,int)
->	O
cap	int
=	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
ncaps	int
;	O
arc	struct(int,int,int,int,int,int)
->	O
selfJoin	enum(int,int)
=	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
i	int
]	O
.	O
selfJoin	enum(int,int)
;	O
prevPaintType	int
=	O
paintType	int
;	O
}	O
if	O
(	O
prevPaintType	int
!=	O
0	int
||	O
isDoubleDash	enum(int,int)
)	O
k	int
=	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
prevPaintType	int
]	O
.	O
narcs	int
-	O
1	int
;	O
if	O
(	O
paintType	int
!=	O
0	int
||	O
isDoubleDash	enum(int,int)
)	O
nextk	int
=	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
narcs	int
;	O
if	O
(	O
nexti	int
==	O
start	int
)	O
{	O
nextk	int
=	O
0	int
;	O
if	O
(	O
isDashed	enum(int,int)
)	O
{	O
paintType	int
=	O
paintTypeStart	int
;	O
dashNum	int
=	O
dashNumStart	int
;	O
dashIndex	int
=	O
dashIndexStart	int
;	O
dashRemaining	int
=	O
dashRemainingStart	int
;	O
}	O
}	O
arcsJoin	enum(int,int)
=	O
(	O
narcs	int
>	O
1	int
&&	O
i	int
!=	O
j	int
&&	O
ISEQUAL	O
(	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
i	int
]	O
.	O
x1	double
,	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
j	int
]	O
.	O
x0	double
)	O
&&	O
ISEQUAL	O
(	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
i	int
]	O
.	O
y1	(double)->(double)
,	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
j	int
]	O
.	O
y0	(double)->(double)
)	O
&&	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
i	int
]	O
.	O
selfJoin	enum(int,int)
==	O
false	int
&&	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
[	O
j	int
]	O
.	O
selfJoin	enum(int,int)
==	O
false	int
)	O
?	O
true	int
:	O
false	int
;	O
if	O
(	O
arc	struct(int,int,int,int,int,int)
!=	O
(	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
arcsJoin	enum(int,int)
)	O
arc	struct(int,int,int,int,int,int)
->	O
render	enum(int,int)
=	O
false	int
;	O
else	O
arc	struct(int,int,int,int,int,int)
->	O
render	enum(int,int)
=	O
true	int
;	O
}	O
if	O
(	O
arcsJoin	enum(int,int)
&&	O
(	O
prevPaintType	int
!=	O
0	int
||	O
isDoubleDash	enum(int,int)
)	O
&&	O
(	O
paintType	int
!=	O
0	int
||	O
isDoubleDash	enum(int,int)
)	O
)	O
{	O
int	O
joinPaintType	int
;	O
joinPaintType	int
=	O
paintType	int
;	O
if	O
(	O
isDoubleDash	enum(int,int)
)	O
{	O
if	O
(	O
nexti	int
==	O
start	int
)	O
joinPaintType	int
=	O
paintTypeStart	int
;	O
if	O
(	O
joinPaintType	int
==	O
0	int
)	O
{	O
if	O
(	O
prevPaintType	int
!=	O
0	int
)	O
joinPaintType	int
=	O
prevPaintType	int
;	O
else	O
joinPaintType	int
=	O
(	O
(	O
dashNum	int
+	O
1	int
)	O
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
(	O
dashNum	int
+	O
1	int
)	O
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
;	O
}	O
}	O
if	O
(	O
joinPaintType	int
!=	O
0	int
||	O
isDoubleDash	enum(int,int)
)	O
{	O
addJoin	(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)),int,int,int,int,int,int)->(void)
(	O
&	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
joinPaintType	int
]	O
,	O
LEFT_END	int
,	O
k	int
,	O
prevPaintType	int
,	O
RIGHT_END	int
,	O
nextk	int
,	O
paintType	int
)	O
;	O
arc	struct(int,int,int,int,int,int)
->	O
join	int
=	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
prevPaintType	int
]	O
.	O
njoins	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
prevPaintType	int
!=	O
0	int
||	O
isDoubleDash	enum(int,int)
)	O
&&	O
arc	struct(int,int,int,int,int,int)
->	O
selfJoin	enum(int,int)
==	O
false	int
)	O
{	O
addCap	(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)),int,int)->(void)
(	O
&	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
prevPaintType	int
]	O
,	O
LEFT_END	int
,	O
k	int
)	O
;	O
arc	struct(int,int,int,int,int,int)
->	O
cap	int
=	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
prevPaintType	int
]	O
.	O
ncaps	int
;	O
}	O
if	O
(	O
isDashed	enum(int,int)
&&	O
arcsJoin	enum(int,int)
==	O
false	int
)	O
{	O
paintType	int
=	O
paintTypeStart	int
;	O
dashNum	int
=	O
dashNumStart	int
;	O
dashIndex	int
=	O
dashIndexStart	int
;	O
dashRemaining	int
=	O
dashRemainingStart	int
;	O
}	O
nextk	int
=	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
narcs	int
;	O
if	O
(	O
nexti	int
==	O
start	int
)	O
{	O
nextk	int
=	O
0	int
;	O
paintType	int
=	O
paintTypeStart	int
;	O
dashNum	int
=	O
dashNumStart	int
;	O
dashIndex	int
=	O
dashIndexStart	int
;	O
dashRemaining	int
=	O
dashRemainingStart	int
;	O
}	O
if	O
(	O
(	O
paintType	int
!=	O
0	int
||	O
isDoubleDash	enum(int,int)
)	O
&&	O
(	O
nexti	int
!=	O
start	int
||	O
(	O
arcsJoin	enum(int,int)
&&	O
isDashed	enum(int,int)
)	O
)	O
)	O
addCap	(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)),int,int)->(void)
(	O
&	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
,	O
RIGHT_END	int
,	O
nextk	int
)	O
;	O
}	O
i	int
=	O
nexti	int
;	O
if	O
(	O
i	int
==	O
start	int
)	O
break	O
;	O
}	O
for	O
(	O
paintType	int
=	O
0	int
;	O
paintType	int
<	O
numPixels	int
;	O
paintType	int
++	O
)	O
if	O
(	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
narcs	int
>	O
0	int
)	O
{	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
narcs	int
-	O
1	int
]	O
.	O
render	enum(int,int)
=	O
true	int
;	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
narcs	int
-	O
1	int
]	O
.	O
join	int
=	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
njoins	int
;	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
narcs	int
-	O
1	int
]	O
.	O
cap	int
=	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
ncaps	int
;	O
}	O
free	(*(void))->(void)
(	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
)	O
;	O
return	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
;	O
}	O
static	O
void	O
miFreeArcs	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)))->(void)
(	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
miPolyArcs	struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)
*	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
)	O
{	O
int	O
paintType	int
;	O
for	O
(	O
paintType	int
=	O
0	int
;	O
paintType	int
<	O
pGC	*(struct)
->	O
numPixels	int
;	O
paintType	int
++	O
)	O
{	O
if	O
(	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
narcs	int
>	O
0	int
)	O
free	(*(void))->(void)
(	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
)	O
;	O
if	O
(	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
njoins	int
>	O
0	int
)	O
free	(*(void))->(void)
(	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
joins	*(struct(int,int,int,int,int,int))
)	O
;	O
if	O
(	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
ncaps	int
>	O
0	int
)	O
free	(*(void))->(void)
(	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
paintType	int
]	O
.	O
caps	*(struct(int,int))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
)	O
;	O
}	O
static	O
void	O
addCap	(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)),int,int)->(void)
(	O
miPolyArcs	struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)
*	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
,	O
int	O
end	int
,	O
int	O
arcIndex	int
)	O
{	O
miArcCapStruct	struct(int,int)
*	O
cap	int
;	O
if	O
(	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
ncaps	int
==	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
capSize	int
)	O
{	O
int	O
newsize	int
=	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
capSize	int
+	O
ADD_REALLOC_STEP	int
;	O
miArcCapStruct	struct(int,int)
*	O
newcaps	*(struct(int,int))
;	O
newcaps	*(struct(int,int))
=	O
(	O
miArcCapStruct	struct(int,int)
*	O
)	O
mi_xrealloc	O
(	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
caps	*(struct(int,int))
,	O
newsize	int
*	O
sizeof	O
(	O
miArcCapStruct	struct(int,int)
)	O
)	O
;	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
caps	*(struct(int,int))
=	O
newcaps	*(struct(int,int))
;	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
capSize	int
=	O
newsize	int
;	O
}	O
cap	int
=	O
&	O
(	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
caps	*(struct(int,int))
[	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
ncaps	int
]	O
)	O
;	O
cap	int
->	O
end	int
=	O
end	int
;	O
cap	int
->	O
arcIndex	int
=	O
arcIndex	int
;	O
++	O
(	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
ncaps	int
)	O
;	O
}	O
static	O
void	O
addJoin	(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)),int,int,int,int,int,int)->(void)
(	O
miPolyArcs	struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)
*	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
,	O
int	O
end0	int
,	O
int	O
index0	int
,	O
int	O
paintType0	int
,	O
int	O
end1	int
,	O
int	O
index1	int
,	O
int	O
paintType1	int
)	O
{	O
miArcJoinStruct	struct(int,int,int,int,int,int)
*	O
join	int
;	O
if	O
(	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
njoins	int
==	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
joinSize	int
)	O
{	O
int	O
newsize	int
=	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
joinSize	int
+	O
ADD_REALLOC_STEP	int
;	O
miArcJoinStruct	struct(int,int,int,int,int,int)
*	O
newjoins	*(struct(int,int,int,int,int,int))
;	O
newjoins	*(struct(int,int,int,int,int,int))
=	O
(	O
miArcJoinStruct	struct(int,int,int,int,int,int)
*	O
)	O
mi_xrealloc	O
(	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
joins	*(struct(int,int,int,int,int,int))
,	O
newsize	int
*	O
sizeof	O
(	O
miArcJoinStruct	struct(int,int,int,int,int,int)
)	O
)	O
;	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
joins	*(struct(int,int,int,int,int,int))
=	O
newjoins	*(struct(int,int,int,int,int,int))
;	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
joinSize	int
=	O
newsize	int
;	O
}	O
join	int
=	O
&	O
(	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
joins	*(struct(int,int,int,int,int,int))
[	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
njoins	int
]	O
)	O
;	O
join	int
->	O
end0	int
=	O
end0	int
;	O
join	int
->	O
arcIndex0	int
=	O
index0	int
;	O
join	int
->	O
paintType0	int
=	O
paintType0	int
;	O
join	int
->	O
end1	int
=	O
end1	int
;	O
join	int
->	O
arcIndex1	int
=	O
index1	int
;	O
join	int
->	O
paintType1	int
=	O
paintType1	int
;	O
++	O
(	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
njoins	int
)	O
;	O
}	O
static	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
*	O
addArc	(*(struct(*(struct(struct`,enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)),*(struct(int,int,int,int,int,int)))->(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)))
(	O
miPolyArcs	struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int)
*	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
xarc	*(struct(int,int,int,int,int,int))
)	O
{	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
*	O
arc	struct(int,int,int,int,int,int)
;	O
if	O
(	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
narcs	int
==	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
arcSize	int
)	O
{	O
int	O
newsize	int
=	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
arcSize	int
+	O
ADD_REALLOC_STEP	int
;	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
*	O
newarcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
;	O
newarcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
=	O
(	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
*	O
)	O
mi_xrealloc	O
(	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
,	O
newsize	int
*	O
sizeof	O
(	O
miArcData	struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)
)	O
)	O
;	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
=	O
newarcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
;	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
arcSize	int
=	O
newsize	int
;	O
}	O
arc	struct(int,int,int,int,int,int)
=	O
&	O
(	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
arcs	*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double))
[	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
narcs	int
]	O
)	O
;	O
arc	struct(int,int,int,int,int,int)
->	O
arc	struct(int,int,int,int,int,int)
=	O
*	O
xarc	*(struct(int,int,int,int,int,int))
;	O
++	O
(	O
polyArcs	*(struct(*(struct(struct(int,int,int,int,int,int),enum(int,int),int,int,enum(int,int),array(struct(struct(double,double),struct(double,double),struct(double,double))),double,double,double,double)),int,int,*(struct(int,int)),int,int,*(struct(int,int,int,int,int,int)),int,int))
->	O
narcs	int
)	O
;	O
return	O
arc	struct(int,int,int,int,int,int)
;	O
}	O
static	O
void	O
miArcJoin	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))),int,int,double,double,int,int,double,double)->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	struct(char,union(char,array(char)))
pixel	struct(char,union(char,array(char)))
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
pLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
const	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
pRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
int	O
xOrgLeft	int
,	O
int	O
yOrgLeft	int
,	O
double	O
xFtransLeft	double
,	O
double	O
yFtransLeft	double
,	O
int	O
xOrgRight	int
,	O
int	O
yOrgRight	int
,	O
double	O
xFtransRight	double
,	O
double	O
yFtransRight	double
)	O
{	O
SppPoint	struct(double,double)
center	struct(double,double)
,	O
corner	struct(double,double)
,	O
otherCorner	struct(double,double)
;	O
SppPoint	struct(double,double)
poly	array(struct(double,double))
[	O
5	int
]	O
;	O
SppPoint	struct(double,double)
*	O
pArcPts	*(struct(double,double))
;	O
int	O
cpt	int
;	O
SppArc	struct(double,double,double,double,double,double)
arc	struct(int,int,int,int,int,int)
;	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
Right	struct(struct(double,double),struct(double,double),struct(double,double))
,	O
Left	struct(struct(double,double),struct(double,double),struct(double,double))
;	O
int	O
polyLen	int
=	O
0	int
;	O
int	O
xOrg	int
,	O
yOrg	int
;	O
double	O
xFtrans	double
,	O
yFtrans	double
;	O
double	O
a	double
;	O
double	O
width	array(short)
;	O
double	O
halftheta	double
;	O
xOrg	int
=	O
(	O
xOrgRight	int
+	O
xOrgLeft	int
)	O
/	O
2	int
;	O
yOrg	int
=	O
(	O
yOrgRight	int
+	O
yOrgLeft	int
)	O
/	O
2	int
;	O
xFtrans	double
=	O
(	O
xFtransLeft	double
+	O
xFtransRight	double
)	O
/	O
2	int
;	O
yFtrans	double
=	O
(	O
yFtransLeft	double
+	O
yFtransRight	double
)	O
/	O
2	int
;	O
Right	struct(struct(double,double),struct(double,double),struct(double,double))
=	O
*	O
pRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
translateBounds	(*(struct(struct(double,double),struct(double,double),struct(double,double))),int,int,double,double)->(void)
(	O
&	O
Right	struct(struct(double,double),struct(double,double),struct(double,double))
,	O
xOrg	int
-	O
xOrgRight	int
,	O
yOrg	int
-	O
yOrgRight	int
,	O
xFtrans	double
-	O
xFtransRight	double
,	O
yFtrans	double
-	O
yFtransRight	double
)	O
;	O
Left	struct(struct(double,double),struct(double,double),struct(double,double))
=	O
*	O
pLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
translateBounds	(*(struct(struct(double,double),struct(double,double),struct(double,double))),int,int,double,double)->(void)
(	O
&	O
Left	struct(struct(double,double),struct(double,double),struct(double,double))
,	O
xOrg	int
-	O
xOrgLeft	int
,	O
yOrg	int
-	O
yOrgLeft	int
,	O
xFtrans	double
-	O
xFtransLeft	double
,	O
yFtrans	double
-	O
yFtransLeft	double
)	O
;	O
pRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
&	O
Right	struct(struct(double,double),struct(double,double),struct(double,double))
;	O
pLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
&	O
Left	struct(struct(double,double),struct(double,double),struct(double,double))
;	O
if	O
(	O
pRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
.	O
x	double
==	O
pLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
.	O
x	double
&&	O
pRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
.	O
y	double
==	O
pLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
.	O
y	double
)	O
return	O
;	O
center	struct(double,double)
=	O
pRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
center	struct(double,double)
;	O
if	O
(	O
0	int
<=	O
(	O
a	double
=	O
angleBetween	(struct(double,double),struct(double,double),struct(double,double))->(double)
(	O
center	struct(double,double)
,	O
pRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
,	O
pLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
)	O
)	O
&&	O
a	double
<=	O
180.0	int
)	O
{	O
corner	struct(double,double)
=	O
pRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
;	O
otherCorner	struct(double,double)
=	O
pLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
;	O
}	O
else	O
{	O
a	double
=	O
angleBetween	(struct(double,double),struct(double,double),struct(double,double))->(double)
(	O
center	struct(double,double)
,	O
pLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
,	O
pRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
)	O
;	O
corner	struct(double,double)
=	O
pLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
;	O
otherCorner	struct(double,double)
=	O
pRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
;	O
}	O
width	array(short)
=	O
(	O
pGC	*(struct)
->	O
lineWidth	int
?	O
pGC	*(struct)
->	O
lineWidth	int
:	O
1	int
)	O
;	O
switch	O
(	O
pGC	*(struct)
->	O
joinStyle	int
)	O
{	O
case	O
MI_JOIN_MITER	int
:	O
default	O
:	O
if	O
(	O
(	O
halftheta	double
=	O
0.5	int
*	O
(	O
180.0	int
-	O
a	double
)	O
)	O
>	O
0.0	int
&&	O
miDsin	(double)->(double)
(	O
halftheta	double
)	O
*	O
pGC	*(struct)
->	O
miterLimit	double
>=	O
1.0	int
)	O
{	O
double	O
ae	double
,	O
ac2	double
,	O
ec2	double
,	O
bc2	double
,	O
de	double
;	O
SppPoint	struct(double,double)
e	int
;	O
poly	array(struct(double,double))
[	O
0	int
]	O
=	O
corner	struct(double,double)
;	O
poly	array(struct(double,double))
[	O
1	int
]	O
=	O
center	struct(double,double)
;	O
poly	array(struct(double,double))
[	O
2	int
]	O
=	O
otherCorner	struct(double,double)
;	O
bc2	double
=	O
(	O
(	O
corner	struct(double,double)
.	O
x	double
-	O
otherCorner	struct(double,double)
.	O
x	double
)	O
*	O
(	O
corner	struct(double,double)
.	O
x	double
-	O
otherCorner	struct(double,double)
.	O
x	double
)	O
+	O
(	O
corner	struct(double,double)
.	O
y	double
-	O
otherCorner	struct(double,double)
.	O
y	double
)	O
*	O
(	O
corner	struct(double,double)
.	O
y	double
-	O
otherCorner	struct(double,double)
.	O
y	double
)	O
)	O
;	O
ec2	double
=	O
0.25	int
*	O
bc2	double
;	O
ac2	double
=	O
(	O
(	O
corner	struct(double,double)
.	O
x	double
-	O
center	struct(double,double)
.	O
x	double
)	O
*	O
(	O
corner	struct(double,double)
.	O
x	double
-	O
center	struct(double,double)
.	O
x	double
)	O
+	O
(	O
corner	struct(double,double)
.	O
y	double
-	O
center	struct(double,double)
.	O
y	double
)	O
*	O
(	O
corner	struct(double,double)
.	O
y	double
-	O
center	struct(double,double)
.	O
y	double
)	O
)	O
;	O
ae	double
=	O
sqrt	(double)->(double)
(	O
ac2	double
-	O
ec2	double
)	O
;	O
de	double
=	O
ec2	double
/	O
ae	double
;	O
e	int
.	O
x	double
=	O
0.5	int
*	O
(	O
corner	struct(double,double)
.	O
x	double
+	O
otherCorner	struct(double,double)
.	O
x	double
)	O
;	O
e	int
.	O
y	double
=	O
0.5	int
*	O
(	O
corner	struct(double,double)
.	O
y	double
+	O
otherCorner	struct(double,double)
.	O
y	double
)	O
;	O
poly	array(struct(double,double))
[	O
3	int
]	O
.	O
x	double
=	O
e	int
.	O
x	double
+	O
de	double
*	O
(	O
e	int
.	O
x	double
-	O
center	struct(double,double)
.	O
x	double
)	O
/	O
ae	double
;	O
poly	array(struct(double,double))
[	O
3	int
]	O
.	O
y	double
=	O
e	int
.	O
y	double
+	O
de	double
*	O
(	O
e	int
.	O
y	double
-	O
center	struct(double,double)
.	O
y	double
)	O
/	O
ae	double
;	O
poly	array(struct(double,double))
[	O
4	int
]	O
=	O
corner	struct(double,double)
;	O
polyLen	int
=	O
5	int
;	O
}	O
else	O
{	O
poly	array(struct(double,double))
[	O
0	int
]	O
=	O
corner	struct(double,double)
;	O
poly	array(struct(double,double))
[	O
1	int
]	O
=	O
center	struct(double,double)
;	O
poly	array(struct(double,double))
[	O
2	int
]	O
=	O
otherCorner	struct(double,double)
;	O
poly	array(struct(double,double))
[	O
3	int
]	O
=	O
corner	struct(double,double)
;	O
polyLen	int
=	O
4	int
;	O
}	O
miFillSppPoly	O
(	O
paintedSet	*(struct)
,	O
pixel	struct(char,union(char,array(char)))
,	O
polyLen	int
,	O
poly	array(struct(double,double))
,	O
xOrg	int
,	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
break	O
;	O
case	O
MI_JOIN_BEVEL	int
:	O
poly	array(struct(double,double))
[	O
0	int
]	O
=	O
corner	struct(double,double)
;	O
poly	array(struct(double,double))
[	O
1	int
]	O
=	O
center	struct(double,double)
;	O
poly	array(struct(double,double))
[	O
2	int
]	O
=	O
otherCorner	struct(double,double)
;	O
poly	array(struct(double,double))
[	O
3	int
]	O
=	O
corner	struct(double,double)
;	O
polyLen	int
=	O
4	int
;	O
miFillSppPoly	O
(	O
paintedSet	*(struct)
,	O
pixel	struct(char,union(char,array(char)))
,	O
polyLen	int
,	O
poly	array(struct(double,double))
,	O
xOrg	int
,	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
break	O
;	O
case	O
MI_JOIN_TRIANGULAR	int
:	O
{	O
double	O
mid2	double
,	O
mid	double
;	O
SppPoint	struct(double,double)
e	int
;	O
e	int
.	O
x	double
=	O
0.5	int
*	O
(	O
corner	struct(double,double)
.	O
x	double
+	O
otherCorner	struct(double,double)
.	O
x	double
)	O
;	O
e	int
.	O
y	double
=	O
0.5	int
*	O
(	O
corner	struct(double,double)
.	O
y	double
+	O
otherCorner	struct(double,double)
.	O
y	double
)	O
;	O
mid2	double
=	O
(	O
(	O
e	int
.	O
x	double
-	O
center	struct(double,double)
.	O
x	double
)	O
*	O
(	O
e	int
.	O
x	double
-	O
center	struct(double,double)
.	O
x	double
)	O
+	O
(	O
e	int
.	O
y	double
-	O
center	struct(double,double)
.	O
y	double
)	O
*	O
(	O
e	int
.	O
y	double
-	O
center	struct(double,double)
.	O
y	double
)	O
)	O
;	O
mid	double
=	O
sqrt	(double)->(double)
(	O
mid2	double
)	O
;	O
poly	array(struct(double,double))
[	O
0	int
]	O
=	O
corner	struct(double,double)
;	O
poly	array(struct(double,double))
[	O
1	int
]	O
=	O
center	struct(double,double)
;	O
poly	array(struct(double,double))
[	O
2	int
]	O
=	O
otherCorner	struct(double,double)
;	O
poly	array(struct(double,double))
[	O
3	int
]	O
.	O
x	double
=	O
e	int
.	O
x	double
+	O
0.5	int
*	O
width	array(short)
*	O
(	O
e	int
.	O
x	double
-	O
center	struct(double,double)
.	O
x	double
)	O
/	O
mid	double
;	O
poly	array(struct(double,double))
[	O
3	int
]	O
.	O
y	double
=	O
e	int
.	O
y	double
+	O
0.5	int
*	O
width	array(short)
*	O
(	O
e	int
.	O
y	double
-	O
center	struct(double,double)
.	O
y	double
)	O
/	O
mid	double
;	O
poly	array(struct(double,double))
[	O
4	int
]	O
=	O
corner	struct(double,double)
;	O
polyLen	int
=	O
5	int
;	O
miFillSppPoly	O
(	O
paintedSet	*(struct)
,	O
pixel	struct(char,union(char,array(char)))
,	O
polyLen	int
,	O
poly	array(struct(double,double))
,	O
xOrg	int
,	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
}	O
break	O
;	O
case	O
MI_JOIN_ROUND	int
:	O
arc	struct(int,int,int,int,int,int)
.	O
x	double
=	O
center	struct(double,double)
.	O
x	double
-	O
width	array(short)
/	O
2	int
;	O
arc	struct(int,int,int,int,int,int)
.	O
y	double
=	O
center	struct(double,double)
.	O
y	double
-	O
width	array(short)
/	O
2	int
;	O
arc	struct(int,int,int,int,int,int)
.	O
width	array(short)
=	O
width	array(short)
;	O
arc	struct(int,int,int,int,int,int)
.	O
height	int
=	O
width	array(short)
;	O
arc	struct(int,int,int,int,int,int)
.	O
angle1	int
=	O
-	O
miDatan2	(double,double)->(double)
(	O
corner	struct(double,double)
.	O
y	double
-	O
center	struct(double,double)
.	O
y	double
,	O
corner	struct(double,double)
.	O
x	double
-	O
center	struct(double,double)
.	O
x	double
)	O
;	O
arc	struct(int,int,int,int,int,int)
.	O
angle2	int
=	O
a	double
;	O
pArcPts	*(struct(double,double))
=	O
(	O
SppPoint	struct(double,double)
*	O
)	O
mi_xmalloc	O
(	O
3	int
*	O
sizeof	O
(	O
SppPoint	struct(double,double)
)	O
)	O
;	O
pArcPts	*(struct(double,double))
[	O
0	int
]	O
=	O
otherCorner	struct(double,double)
;	O
pArcPts	*(struct(double,double))
[	O
1	int
]	O
=	O
center	struct(double,double)
;	O
pArcPts	*(struct(double,double))
[	O
2	int
]	O
=	O
corner	struct(double,double)
;	O
if	O
(	O
(	O
cpt	int
=	O
miGetArcPts	(*(struct(double,double,double,double,double,double)),int,*(*(struct(double,double))))->(int)
(	O
&	O
arc	struct(int,int,int,int,int,int)
,	O
3	int
,	O
&	O
pArcPts	*(struct(double,double))
)	O
)	O
)	O
miFillSppPoly	O
(	O
paintedSet	*(struct)
,	O
pixel	struct(char,union(char,array(char)))
,	O
cpt	int
,	O
pArcPts	*(struct(double,double))
,	O
xOrg	int
,	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
free	(*(void))->(void)
(	O
pArcPts	*(struct(double,double))
)	O
;	O
break	O
;	O
}	O
}	O
static	O
double	O
angleBetween	(struct(double,double),struct(double,double),struct(double,double))->(double)
(	O
SppPoint	struct(double,double)
center	struct(double,double)
,	O
SppPoint	struct(double,double)
point1	struct(double,double)
,	O
SppPoint	struct(double,double)
point2	struct(double,double)
)	O
{	O
double	O
a1	int
,	O
a2	double
,	O
a	double
;	O
a1	int
=	O
miDatan2	(double,double)->(double)
(	O
-	O
(	O
point1	struct(double,double)
.	O
y	double
-	O
center	struct(double,double)
.	O
y	double
)	O
,	O
point1	struct(double,double)
.	O
x	double
-	O
center	struct(double,double)
.	O
x	double
)	O
;	O
a2	double
=	O
miDatan2	(double,double)->(double)
(	O
-	O
(	O
point2	struct(double,double)
.	O
y	double
-	O
center	struct(double,double)
.	O
y	double
)	O
,	O
point2	struct(double,double)
.	O
x	double
-	O
center	struct(double,double)
.	O
x	double
)	O
;	O
a	double
=	O
a2	double
-	O
a1	int
;	O
if	O
(	O
a	double
<=	O
-	O
180.0	int
)	O
a	double
+=	O
360.0	int
;	O
else	O
if	O
(	O
a	double
>	O
180.0	int
)	O
a	double
-=	O
360.0	int
;	O
return	O
a	double
;	O
}	O
static	O
void	O
translateBounds	(*(struct(struct(double,double),struct(double,double),struct(double,double))),int,int,double,double)->(void)
(	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
int	O
x	double
,	O
int	O
y	double
,	O
double	O
fx	double
,	O
double	O
fy	double
)	O
{	O
fx	double
+=	O
x	double
;	O
fy	double
+=	O
y	double
;	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
.	O
x	double
-=	O
fx	double
;	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
.	O
y	double
-=	O
fy	double
;	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
center	struct(double,double)
.	O
x	double
-=	O
fx	double
;	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
center	struct(double,double)
.	O
y	double
-=	O
fy	double
;	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
.	O
x	double
-=	O
fx	double
;	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
.	O
y	double
-=	O
fy	double
;	O
}	O
static	O
void	O
miArcCap	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(struct(double,double),struct(double,double),struct(double,double))),int,int,int,double,double)->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	struct(char,union(char,array(char)))
pixel	struct(char,union(char,array(char)))
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
pFace	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
int	O
end	int
,	O
int	O
xOrg	int
,	O
int	O
yOrg	int
,	O
double	O
xFtrans	double
,	O
double	O
yFtrans	double
)	O
{	O
SppPoint	struct(double,double)
corner	struct(double,double)
,	O
otherCorner	struct(double,double)
,	O
center	struct(double,double)
,	O
endPoint	struct(double,double)
,	O
poly	array(struct(double,double))
[	O
5	int
]	O
;	O
corner	struct(double,double)
=	O
pFace	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
;	O
otherCorner	struct(double,double)
=	O
pFace	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
;	O
center	struct(double,double)
=	O
pFace	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
center	struct(double,double)
;	O
switch	O
(	O
pGC	*(struct)
->	O
capStyle	int
)	O
{	O
case	O
MI_CAP_BUTT	int
:	O
case	O
MI_CAP_NOT_LAST	int
:	O
default	O
:	O
break	O
;	O
case	O
MI_CAP_PROJECTING	int
:	O
poly	array(struct(double,double))
[	O
0	int
]	O
.	O
x	double
=	O
otherCorner	struct(double,double)
.	O
x	double
;	O
poly	array(struct(double,double))
[	O
0	int
]	O
.	O
y	double
=	O
otherCorner	struct(double,double)
.	O
y	double
;	O
poly	array(struct(double,double))
[	O
1	int
]	O
.	O
x	double
=	O
corner	struct(double,double)
.	O
x	double
;	O
poly	array(struct(double,double))
[	O
1	int
]	O
.	O
y	double
=	O
corner	struct(double,double)
.	O
y	double
;	O
poly	array(struct(double,double))
[	O
2	int
]	O
.	O
x	double
=	O
corner	struct(double,double)
.	O
x	double
-	O
(	O
center	struct(double,double)
.	O
y	double
-	O
corner	struct(double,double)
.	O
y	double
)	O
;	O
poly	array(struct(double,double))
[	O
2	int
]	O
.	O
y	double
=	O
corner	struct(double,double)
.	O
y	double
+	O
(	O
center	struct(double,double)
.	O
x	double
-	O
corner	struct(double,double)
.	O
x	double
)	O
;	O
poly	array(struct(double,double))
[	O
3	int
]	O
.	O
x	double
=	O
otherCorner	struct(double,double)
.	O
x	double
-	O
(	O
otherCorner	struct(double,double)
.	O
y	double
-	O
center	struct(double,double)
.	O
y	double
)	O
;	O
poly	array(struct(double,double))
[	O
3	int
]	O
.	O
y	double
=	O
otherCorner	struct(double,double)
.	O
y	double
+	O
(	O
otherCorner	struct(double,double)
.	O
x	double
-	O
center	struct(double,double)
.	O
x	double
)	O
;	O
poly	array(struct(double,double))
[	O
4	int
]	O
.	O
x	double
=	O
otherCorner	struct(double,double)
.	O
x	double
;	O
poly	array(struct(double,double))
[	O
4	int
]	O
.	O
y	double
=	O
otherCorner	struct(double,double)
.	O
y	double
;	O
miFillSppPoly	O
(	O
paintedSet	*(struct)
,	O
pixel	struct(char,union(char,array(char)))
,	O
5	int
,	O
poly	array(struct(double,double))
,	O
xOrg	int
,	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
break	O
;	O
case	O
MI_CAP_TRIANGULAR	int
:	O
poly	array(struct(double,double))
[	O
0	int
]	O
.	O
x	double
=	O
otherCorner	struct(double,double)
.	O
x	double
;	O
poly	array(struct(double,double))
[	O
0	int
]	O
.	O
y	double
=	O
otherCorner	struct(double,double)
.	O
y	double
;	O
poly	array(struct(double,double))
[	O
1	int
]	O
.	O
x	double
=	O
corner	struct(double,double)
.	O
x	double
;	O
poly	array(struct(double,double))
[	O
1	int
]	O
.	O
y	double
=	O
corner	struct(double,double)
.	O
y	double
;	O
poly	array(struct(double,double))
[	O
2	int
]	O
.	O
x	double
=	O
center	struct(double,double)
.	O
x	double
-	O
0.5	int
*	O
(	O
otherCorner	struct(double,double)
.	O
y	double
-	O
corner	struct(double,double)
.	O
y	double
)	O
;	O
poly	array(struct(double,double))
[	O
2	int
]	O
.	O
y	double
=	O
center	struct(double,double)
.	O
y	double
+	O
0.5	int
*	O
(	O
otherCorner	struct(double,double)
.	O
x	double
-	O
corner	struct(double,double)
.	O
x	double
)	O
;	O
poly	array(struct(double,double))
[	O
3	int
]	O
.	O
x	double
=	O
otherCorner	struct(double,double)
.	O
x	double
;	O
poly	array(struct(double,double))
[	O
3	int
]	O
.	O
y	double
=	O
otherCorner	struct(double,double)
.	O
y	double
;	O
miFillSppPoly	O
(	O
paintedSet	*(struct)
,	O
pixel	struct(char,union(char,array(char)))
,	O
4	int
,	O
poly	array(struct(double,double))
,	O
xOrg	int
,	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
break	O
;	O
case	O
MI_CAP_ROUND	int
:	O
endPoint	struct(double,double)
=	O
center	struct(double,double)
;	O
endPoint	struct(double,double)
.	O
x	double
=	O
endPoint	struct(double,double)
.	O
x	double
+	O
100	int
;	O
miRoundCap	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),struct(double,double),struct(double,double),struct(double,double),struct(double,double),int,int,int,double,double)->(void)
(	O
paintedSet	*(struct)
,	O
pixel	struct(char,union(char,array(char)))
,	O
pGC	*(struct)
,	O
center	struct(double,double)
,	O
endPoint	struct(double,double)
,	O
corner	struct(double,double)
,	O
otherCorner	struct(double,double)
,	O
0	int
,	O
-	O
xOrg	int
,	O
-	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
miRoundCap	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),struct(double,double),struct(double,double),struct(double,double),struct(double,double),int,int,int,double,double)->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	struct(char,union(char,array(char)))
pixel	struct(char,union(char,array(char)))
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
SppPoint	struct(double,double)
pCenter	struct(double,double)
,	O
SppPoint	struct(double,double)
pEnd	struct(double,double)
,	O
SppPoint	struct(double,double)
pCorner	struct(double,double)
,	O
SppPoint	struct(double,double)
pOtherCorner	struct(double,double)
,	O
int	O
fLineEnd	int
,	O
int	O
xOrg	int
,	O
int	O
yOrg	int
,	O
double	O
xFtrans	double
,	O
double	O
yFtrans	double
)	O
{	O
int	O
cpt	int
;	O
double	O
width	array(short)
;	O
SppArc	struct(double,double,double,double,double,double)
arc	struct(int,int,int,int,int,int)
;	O
SppPoint	struct(double,double)
*	O
pArcPts	*(struct(double,double))
;	O
width	array(short)
=	O
(	O
pGC	*(struct)
->	O
lineWidth	int
?	O
pGC	*(struct)
->	O
lineWidth	int
:	O
1	int
)	O
;	O
arc	struct(int,int,int,int,int,int)
.	O
x	double
=	O
pCenter	struct(double,double)
.	O
x	double
-	O
width	array(short)
/	O
2	int
;	O
arc	struct(int,int,int,int,int,int)
.	O
y	double
=	O
pCenter	struct(double,double)
.	O
y	double
-	O
width	array(short)
/	O
2	int
;	O
arc	struct(int,int,int,int,int,int)
.	O
width	array(short)
=	O
width	array(short)
;	O
arc	struct(int,int,int,int,int,int)
.	O
height	int
=	O
width	array(short)
;	O
arc	struct(int,int,int,int,int,int)
.	O
angle1	int
=	O
-	O
miDatan2	(double,double)->(double)
(	O
pCorner	struct(double,double)
.	O
y	double
-	O
pCenter	struct(double,double)
.	O
y	double
,	O
pCorner	struct(double,double)
.	O
x	double
-	O
pCenter	struct(double,double)
.	O
x	double
)	O
;	O
if	O
(	O
PTISEQUAL	O
(	O
pCenter	struct(double,double)
,	O
pEnd	struct(double,double)
)	O
)	O
arc	struct(int,int,int,int,int,int)
.	O
angle2	int
=	O
-	O
180.0	int
;	O
else	O
{	O
arc	struct(int,int,int,int,int,int)
.	O
angle2	int
=	O
-	O
miDatan2	(double,double)->(double)
(	O
pOtherCorner	struct(double,double)
.	O
y	double
-	O
pCenter	struct(double,double)
.	O
y	double
,	O
pOtherCorner	struct(double,double)
.	O
x	double
-	O
pCenter	struct(double,double)
.	O
x	double
)	O
-	O
arc	struct(int,int,int,int,int,int)
.	O
angle1	int
;	O
if	O
(	O
arc	struct(int,int,int,int,int,int)
.	O
angle2	int
<	O
0	int
)	O
arc	struct(int,int,int,int,int,int)
.	O
angle2	int
+=	O
360.0	int
;	O
}	O
pArcPts	*(struct(double,double))
=	O
(	O
SppPoint	struct(double,double)
*	O
)	O
NULL	O
;	O
if	O
(	O
(	O
cpt	int
=	O
miGetArcPts	(*(struct(double,double,double,double,double,double)),int,*(*(struct(double,double))))->(int)
(	O
&	O
arc	struct(int,int,int,int,int,int)
,	O
0	int
,	O
&	O
pArcPts	*(struct(double,double))
)	O
)	O
)	O
miFillSppPoly	O
(	O
paintedSet	*(struct)
,	O
pixel	struct(char,union(char,array(char)))
,	O
cpt	int
,	O
pArcPts	*(struct(double,double))
,	O
-	O
xOrg	int
,	O
-	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
free	(*(void))->(void)
(	O
pArcPts	*(struct(double,double))
)	O
;	O
}	O
static	O
int	O
miGetArcPts	(*(struct(double,double,double,double,double,double)),int,*(*(struct(double,double))))->(int)
(	O
const	O
SppArc	struct(double,double,double,double,double,double)
*	O
parc	*(struct(int,int,int,int,int,int))
,	O
int	O
cpt	int
,	O
SppPoint	struct(double,double)
*	O
*	O
ppPts	*(*(struct(double,double)))
)	O
{	O
double	O
st	double
;	O
double	O
et	double
;	O
double	O
dt	double
;	O
double	O
cdt	double
;	O
double	O
x0	double
,	O
y0	(double)->(double)
;	O
double	O
x1	double
,	O
y1	(double)->(double)
;	O
double	O
x2	double
,	O
y2	double
;	O
double	O
xc	int
,	O
yc	int
;	O
int	O
count	int
,	O
i	int
;	O
SppPoint	struct(double,double)
*	O
poly	array(struct(double,double))
;	O
miPoint	struct(int,int)
last	struct(int,int)
;	O
st	double
=	O
-	O
parc	*(struct(int,int,int,int,int,int))
->	O
angle1	int
;	O
et	double
=	O
-	O
parc	*(struct(int,int,int,int,int,int))
->	O
angle2	int
;	O
cdt	double
=	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
;	O
if	O
(	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
>	O
cdt	double
)	O
cdt	double
=	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
cdt	double
*=	O
0.5	int
;	O
if	O
(	O
cdt	double
<=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
cdt	double
<	O
1.0	int
)	O
cdt	double
=	O
1.0	int
;	O
dt	double
=	O
miDasin	(double)->(double)
(	O
1.0	int
/	O
cdt	double
)	O
;	O
count	int
=	O
(	O
int	O
)	O
(	O
et	double
/	O
dt	double
)	O
;	O
count	int
=	O
abs	(int)->(int)
(	O
count	int
)	O
+	O
1	int
;	O
dt	double
=	O
et	double
/	O
count	int
;	O
count	int
++	O
;	O
cdt	double
=	O
2	int
*	O
miDcos	(double)->(double)
(	O
dt	double
)	O
;	O
poly	array(struct(double,double))
=	O
(	O
SppPoint	struct(double,double)
*	O
)	O
mi_xrealloc	O
(	O
*	O
ppPts	*(*(struct(double,double)))
,	O
(	O
cpt	int
+	O
count	int
)	O
*	O
sizeof	O
(	O
SppPoint	struct(double,double)
)	O
)	O
;	O
*	O
ppPts	*(*(struct(double,double)))
=	O
poly	array(struct(double,double))
;	O
xc	int
=	O
0.5	int
*	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
;	O
yc	int
=	O
0.5	int
*	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
x0	double
=	O
xc	int
*	O
miDcos	(double)->(double)
(	O
st	double
)	O
;	O
y0	(double)->(double)
=	O
yc	int
*	O
miDsin	(double)->(double)
(	O
st	double
)	O
;	O
x1	double
=	O
xc	int
*	O
miDcos	(double)->(double)
(	O
st	double
+	O
dt	double
)	O
;	O
y1	(double)->(double)
=	O
yc	int
*	O
miDsin	(double)->(double)
(	O
st	double
+	O
dt	double
)	O
;	O
xc	int
+=	O
parc	*(struct(int,int,int,int,int,int))
->	O
x	double
;	O
yc	int
+=	O
parc	*(struct(int,int,int,int,int,int))
->	O
y	double
;	O
poly	array(struct(double,double))
[	O
cpt	int
]	O
.	O
x	double
=	O
(	O
xc	int
+	O
x0	double
)	O
;	O
poly	array(struct(double,double))
[	O
cpt	int
]	O
.	O
y	double
=	O
(	O
yc	int
+	O
y0	(double)->(double)
)	O
;	O
poly	array(struct(double,double))
[	O
cpt	int
+	O
1	int
]	O
.	O
x	double
=	O
(	O
xc	int
+	O
x1	double
)	O
;	O
poly	array(struct(double,double))
[	O
cpt	int
+	O
1	int
]	O
.	O
y	double
=	O
(	O
yc	int
+	O
y1	(double)->(double)
)	O
;	O
last	struct(int,int)
.	O
x	double
=	O
IROUND	O
(	O
xc	int
+	O
x1	double
)	O
;	O
last	struct(int,int)
.	O
y	double
=	O
IROUND	O
(	O
yc	int
+	O
y1	(double)->(double)
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
{	O
x2	double
=	O
cdt	double
*	O
x1	double
-	O
x0	double
;	O
y2	double
=	O
cdt	double
*	O
y1	(double)->(double)
-	O
y0	(double)->(double)
;	O
poly	array(struct(double,double))
[	O
cpt	int
+	O
i	int
]	O
.	O
x	double
=	O
(	O
xc	int
+	O
x2	double
)	O
;	O
poly	array(struct(double,double))
[	O
cpt	int
+	O
i	int
]	O
.	O
y	double
=	O
(	O
yc	int
+	O
y2	double
)	O
;	O
x0	double
=	O
x1	double
;	O
y0	(double)->(double)
=	O
y1	(double)->(double)
;	O
x1	double
=	O
x2	double
;	O
y1	(double)->(double)
=	O
y2	double
;	O
}	O
if	O
(	O
FABS	O
(	O
parc	*(struct(int,int,int,int,int,int))
->	O
angle2	int
)	O
>=	O
360.0	int
)	O
poly	array(struct(double,double))
[	O
cpt	int
+	O
i	int
-	O
1	int
]	O
=	O
poly	array(struct(double,double))
[	O
0	int
]	O
;	O
else	O
{	O
poly	array(struct(double,double))
[	O
cpt	int
+	O
i	int
-	O
1	int
]	O
.	O
x	double
=	O
(	O
miDcos	(double)->(double)
(	O
st	double
+	O
et	double
)	O
*	O
0.5	int
*	O
parc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
+	O
xc	int
)	O
;	O
poly	array(struct(double,double))
[	O
cpt	int
+	O
i	int
-	O
1	int
]	O
.	O
y	double
=	O
(	O
miDsin	(double)->(double)
(	O
st	double
+	O
et	double
)	O
*	O
0.5	int
*	O
parc	*(struct(int,int,int,int,int,int))
->	O
height	int
+	O
yc	int
)	O
;	O
}	O
return	O
count	int
;	O
}	O
static	O
double	O
miDcos	(double)->(double)
(	O
double	O
a	double
)	O
{	O
int	O
i	int
;	O
if	O
(	O
floor	(double)->(double)
(	O
a	double
/	O
90	int
)	O
==	O
a	double
/	O
90	int
)	O
{	O
i	int
=	O
(	O
int	O
)	O
(	O
a	double
/	O
90.0	int
)	O
;	O
switch	O
(	O
mod	O
(	O
i	int
,	O
4	int
)	O
)	O
{	O
case	O
0	int
:	O
return	O
1	int
;	O
case	O
1	int
:	O
return	O
0	int
;	O
case	O
2	int
:	O
return	O
-	O
1	int
;	O
case	O
3	int
:	O
return	O
0	int
;	O
}	O
}	O
return	O
cos	(double)->(double)
(	O
a	double
*	O
M_PI	int
/	O
180.0	int
)	O
;	O
}	O
static	O
double	O
miDsin	(double)->(double)
(	O
double	O
a	double
)	O
{	O
int	O
i	int
;	O
if	O
(	O
floor	(double)->(double)
(	O
a	double
/	O
90	int
)	O
==	O
a	double
/	O
90	int
)	O
{	O
i	int
=	O
(	O
int	O
)	O
(	O
a	double
/	O
90.0	int
)	O
;	O
switch	O
(	O
mod	O
(	O
i	int
,	O
4	int
)	O
)	O
{	O
case	O
0	int
:	O
return	O
0	int
;	O
case	O
1	int
:	O
return	O
1	int
;	O
case	O
2	int
:	O
return	O
0	int
;	O
case	O
3	int
:	O
return	O
-	O
1	int
;	O
}	O
}	O
return	O
sin	(double)->(double)
(	O
a	double
*	O
M_PI	int
/	O
180.0	int
)	O
;	O
}	O
static	O
double	O
miDasin	(double)->(double)
(	O
double	O
v	*(struct(double,double))
)	O
{	O
if	O
(	O
v	*(struct(double,double))
==	O
0	int
)	O
return	O
0.0	int
;	O
if	O
(	O
v	*(struct(double,double))
==	O
1.0	int
)	O
return	O
90.0	int
;	O
if	O
(	O
v	*(struct(double,double))
==	O
-	O
1.0	int
)	O
return	O
-	O
90.0	int
;	O
return	O
asin	(double)->(double)
(	O
v	*(struct(double,double))
)	O
*	O
(	O
180.0	int
/	O
M_PI	int
)	O
;	O
}	O
static	O
double	O
miDatan2	(double,double)->(double)
(	O
double	O
dy	int
,	O
double	O
dx	int
)	O
{	O
if	O
(	O
dy	int
==	O
0	int
)	O
{	O
if	O
(	O
dx	int
>=	O
0	int
)	O
return	O
0.0	int
;	O
return	O
180.0	int
;	O
}	O
else	O
if	O
(	O
dx	int
==	O
0	int
)	O
{	O
if	O
(	O
dy	int
>	O
0	int
)	O
return	O
90.0	int
;	O
return	O
-	O
90.0	int
;	O
}	O
else	O
if	O
(	O
FABS	O
(	O
dy	int
)	O
==	O
FABS	O
(	O
dx	int
)	O
)	O
{	O
if	O
(	O
dy	int
>	O
0	int
)	O
{	O
if	O
(	O
dx	int
>	O
0	int
)	O
return	O
45.0	int
;	O
return	O
135.0	int
;	O
}	O
else	O
{	O
if	O
(	O
dx	int
>	O
0	int
)	O
return	O
315.0	int
;	O
return	O
225.0	int
;	O
}	O
}	O
else	O
return	O
atan2	(double,double)->(double)
(	O
dy	int
,	O
dx	int
)	O
*	O
(	O
180.0	int
/	O
M_PI	int
)	O
;	O
}	O
static	O
double	O
angleToLength	(int,*(struct(array(double))))->(double)
(	O
int	O
angle	double
,	O
const	O
dashMap	struct(array(double))
*	O
map	array(double)
)	O
;	O
static	O
int	O
lengthToAngle	(double,*(struct(array(double))))->(int)
(	O
double	O
len	long
,	O
const	O
dashMap	struct(array(double))
*	O
map	array(double)
)	O
;	O
static	O
void	O
computeDashMap	(*(struct(int,int,int,int,int,int)),*(struct(array(double))))->(void)
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arcp	*(struct(int,int,int,int,int,int))
,	O
dashMap	struct(array(double))
*	O
map	array(double)
)	O
{	O
int	O
di	int
;	O
double	O
a	double
,	O
x	double
,	O
y	double
,	O
prevx	double
=	O
0.0	int
,	O
prevy	double
=	O
0.0	int
,	O
dist	int
;	O
for	O
(	O
di	int
=	O
0	int
;	O
di	int
<	O
DASH_MAP_SIZE	int
;	O
di	int
++	O
)	O
{	O
a	double
=	O
dashIndexToAngle	O
(	O
di	int
)	O
;	O
x	double
=	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcp	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
)	O
*	O
miDcos	(double)->(double)
(	O
a	double
)	O
;	O
y	double
=	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcp	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
*	O
miDsin	(double)->(double)
(	O
a	double
)	O
;	O
if	O
(	O
di	int
==	O
0	int
)	O
map	array(double)
->	O
map	array(double)
[	O
di	int
]	O
=	O
0.0	int
;	O
else	O
{	O
dist	int
=	O
hypot	(double,double)->(double)
(	O
x	double
-	O
prevx	double
,	O
y	double
-	O
prevy	double
)	O
;	O
map	array(double)
->	O
map	array(double)
[	O
di	int
]	O
=	O
map	array(double)
->	O
map	array(double)
[	O
di	int
-	O
1	int
]	O
+	O
dist	int
;	O
}	O
prevx	double
=	O
x	double
;	O
prevy	double
=	O
y	double
;	O
}	O
}	O
static	O
double	O
angleToLength	(int,*(struct(array(double))))->(double)
(	O
int	O
angle	double
,	O
const	O
dashMap	struct(array(double))
*	O
map	array(double)
)	O
{	O
double	O
len	long
,	O
excesslen	double
,	O
sidelen	double
=	O
map	array(double)
->	O
map	array(double)
[	O
DASH_MAP_SIZE	int
-	O
1	int
]	O
,	O
totallen	double
;	O
int	O
di	int
;	O
int	O
excess	int
;	O
bool	enum(int,int)
oddSide	enum(int,int)
=	O
false	int
;	O
totallen	double
=	O
0	int
;	O
if	O
(	O
angle	double
>=	O
0	int
)	O
{	O
while	O
(	O
angle	double
>=	O
90	int
*	O
64	int
)	O
{	O
angle	double
-=	O
90	int
*	O
64	int
;	O
totallen	double
+=	O
sidelen	double
;	O
oddSide	enum(int,int)
=	O
(	O
oddSide	enum(int,int)
?	O
false	int
:	O
true	int
)	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
angle	double
<	O
0	int
)	O
{	O
angle	double
+=	O
90	int
*	O
64	int
;	O
totallen	double
-=	O
sidelen	double
;	O
oddSide	enum(int,int)
=	O
(	O
oddSide	enum(int,int)
?	O
false	int
:	O
true	int
)	O
;	O
}	O
}	O
if	O
(	O
oddSide	enum(int,int)
)	O
angle	double
=	O
90	int
*	O
64	int
-	O
angle	double
;	O
di	int
=	O
xAngleToDashIndex	O
(	O
angle	double
)	O
;	O
excess	int
=	O
angle	double
-	O
dashIndexToXAngle	O
(	O
di	int
)	O
;	O
len	long
=	O
map	array(double)
->	O
map	array(double)
[	O
di	int
]	O
;	O
if	O
(	O
excess	int
>	O
0	int
)	O
{	O
excesslen	double
=	O
(	O
map	array(double)
->	O
map	array(double)
[	O
di	int
+	O
1	int
]	O
-	O
map	array(double)
->	O
map	array(double)
[	O
di	int
]	O
)	O
*	O
(	O
(	O
double	O
)	O
excess	int
)	O
/	O
dashXAngleStep	O
;	O
len	long
+=	O
excesslen	double
;	O
}	O
if	O
(	O
oddSide	enum(int,int)
)	O
totallen	double
+=	O
(	O
sidelen	double
-	O
len	long
)	O
;	O
else	O
totallen	double
+=	O
len	long
;	O
return	O
totallen	double
;	O
}	O
static	O
int	O
lengthToAngle	(double,*(struct(array(double))))->(int)
(	O
double	O
len	long
,	O
const	O
dashMap	struct(array(double))
*	O
map	array(double)
)	O
{	O
double	O
sidelen	double
=	O
map	array(double)
->	O
map	array(double)
[	O
DASH_MAP_SIZE	int
-	O
1	int
]	O
;	O
int	O
angle	double
,	O
angleexcess	int
;	O
bool	enum(int,int)
oddSide	enum(int,int)
=	O
false	int
;	O
int	O
a0	int
,	O
a1	int
,	O
a	double
;	O
angle	double
=	O
0	int
;	O
if	O
(	O
len	long
>=	O
0	int
)	O
{	O
if	O
(	O
sidelen	double
==	O
0	int
)	O
return	O
2	int
*	O
FULLCIRCLE	O
;	O
while	O
(	O
len	long
>=	O
sidelen	double
)	O
{	O
angle	double
+=	O
90	int
*	O
64	int
;	O
len	long
-=	O
sidelen	double
;	O
oddSide	enum(int,int)
=	O
(	O
oddSide	enum(int,int)
?	O
false	int
:	O
true	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
sidelen	double
==	O
0	int
)	O
return	O
-	O
2	int
*	O
FULLCIRCLE	O
;	O
while	O
(	O
len	long
<	O
0	int
)	O
{	O
angle	double
-=	O
90	int
*	O
64	int
;	O
len	long
+=	O
sidelen	double
;	O
oddSide	enum(int,int)
=	O
(	O
oddSide	enum(int,int)
?	O
false	int
:	O
true	int
)	O
;	O
}	O
}	O
if	O
(	O
oddSide	enum(int,int)
)	O
len	long
=	O
sidelen	double
-	O
len	long
;	O
a0	int
=	O
0	int
;	O
a1	int
=	O
DASH_MAP_SIZE	int
-	O
1	int
;	O
while	O
(	O
a1	int
-	O
a0	int
>	O
1	int
)	O
{	O
a	double
=	O
(	O
a0	int
+	O
a1	int
)	O
/	O
2	int
;	O
if	O
(	O
len	long
>	O
map	array(double)
->	O
map	array(double)
[	O
a	double
]	O
)	O
a0	int
=	O
a	double
;	O
else	O
a1	int
=	O
a	double
;	O
}	O
angleexcess	int
=	O
dashIndexToXAngle	O
(	O
a0	int
)	O
;	O
angleexcess	int
+=	O
(	O
int	O
)	O
(	O
(	O
len	long
-	O
map	array(double)
->	O
map	array(double)
[	O
a0	int
]	O
)	O
/	O
(	O
map	array(double)
->	O
map	array(double)
[	O
a0	int
+	O
1	int
]	O
-	O
map	array(double)
->	O
map	array(double)
[	O
a0	int
]	O
)	O
*	O
dashXAngleStep	O
)	O
;	O
if	O
(	O
oddSide	enum(int,int)
)	O
angle	double
+=	O
(	O
90	int
*	O
64	int
)	O
-	O
angleexcess	int
;	O
else	O
angle	double
+=	O
angleexcess	int
;	O
return	O
angle	double
;	O
}	O
static	O
int	O
computeAngleFromPath	(int,int,*(struct(array(double))),*(int),enum(int,int))->(int)
(	O
int	O
startAngle	int
,	O
int	O
endAngle	int
,	O
const	O
dashMap	struct(array(double))
*	O
map	array(double)
,	O
int	O
*	O
lenp	*(int)
,	O
bool	enum(int,int)
backwards	enum(int,int)
)	O
{	O
int	O
a0	int
,	O
a1	int
,	O
a	double
;	O
double	O
len0	double
;	O
int	O
len	long
;	O
a0	int
=	O
startAngle	int
;	O
a1	int
=	O
endAngle	int
;	O
len	long
=	O
*	O
lenp	*(int)
;	O
if	O
(	O
backwards	enum(int,int)
)	O
{	O
a0	int
=	O
FULLCIRCLE	O
-	O
a0	int
;	O
a1	int
=	O
FULLCIRCLE	O
-	O
a1	int
;	O
}	O
if	O
(	O
a1	int
<	O
a0	int
)	O
a1	int
+=	O
FULLCIRCLE	O
;	O
len0	double
=	O
angleToLength	(int,*(struct(array(double))))->(double)
(	O
a0	int
,	O
map	array(double)
)	O
;	O
a	double
=	O
lengthToAngle	(double,*(struct(array(double))))->(int)
(	O
len0	double
+	O
len	long
,	O
map	array(double)
)	O
;	O
if	O
(	O
a	double
>	O
a1	int
)	O
{	O
a	double
=	O
a1	int
;	O
len	long
=	O
(	O
int	O
)	O
(	O
len	long
-	O
angleToLength	(int,*(struct(array(double))))->(double)
(	O
a1	int
,	O
map	array(double)
)	O
-	O
len0	double
)	O
;	O
}	O
else	O
len	long
=	O
0	int
;	O
if	O
(	O
backwards	enum(int,int)
)	O
a	double
=	O
FULLCIRCLE	O
-	O
a	double
;	O
*	O
lenp	*(int)
=	O
len	long
;	O
return	O
a	double
;	O
}	O
struct	O
arc_def	struct(double,double,double,double,double)
{	O
double	O
w	double
,	O
h	double
;	O
double	O
l	int
;	O
double	O
a0	int
,	O
a1	int
;	O
}	O
;	O
struct	O
bound	struct(double,double)
{	O
double	O
min	int
,	O
max	int
;	O
}	O
;	O
struct	O
ibound	struct(int,int)
{	O
int	O
min	int
,	O
max	int
;	O
}	O
;	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
{	O
struct	O
bound	struct(double,double)
ellipse	struct(double,double)
;	O
struct	O
bound	struct(double,double)
inner	struct(double,double)
,	O
outer	struct(double,double)
;	O
struct	O
bound	struct(double,double)
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
struct	O
ibound	struct(int,int)
inneri	struct(int,int)
,	O
outeri	struct(int,int)
;	O
}	O
;	O
struct	O
line	struct(double,double,enum(int,int))
{	O
double	O
m	array(double)
,	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
bool	enum(int,int)
valid	enum(int,int)
;	O
}	O
;	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
{	O
double	O
tail_y	double
;	O
double	O
h2	double
;	O
double	O
w2	double
;	O
double	O
h4	double
;	O
double	O
w4	double
;	O
double	O
h2mw2	double
;	O
double	O
h2l	double
;	O
double	O
w2l	double
;	O
double	O
fromIntX	double
;	O
double	O
fromIntY	double
;	O
struct	O
line	struct(double,double,enum(int,int))
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
int	O
yorgu	int
;	O
int	O
yorgl	int
;	O
int	O
xorg	int
;	O
}	O
;	O
static	O
double	O
hookEllipseY	(double,*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),enum(int,int))->(double)
(	O
double	O
scan_y	double
,	O
const	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
*	O
bound	struct(double,double)
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
bool	enum(int,int)
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
static	O
double	O
hookX	(double,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),enum(int,int))->(double)
(	O
double	O
scan_y	double
,	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
const	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
*	O
bound	struct(double,double)
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
bool	enum(int,int)
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
static	O
double	O
innerXfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
static	O
double	O
innerYfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
static	O
double	O
innerYfromY	(double,*(struct(double,double,double,double,double)),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
double	O
y	double
,	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
static	O
double	O
outerXfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
static	O
double	O
outerYfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
static	O
double	O
tailX	(double,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
double	O
K	double
,	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
const	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
*	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
static	O
void	O
computeAcc	(*(struct(int,int,int,int,int,int)),int,*(struct(double,double,double,double,double)),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(void)
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
tarc	*(struct(int,int,int,int,int,int))
,	O
unsigned	O
int	O
lw	int
,	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
static	O
void	O
computeBound	(*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))))->(void)
(	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
*	O
bound	struct(double,double)
,	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
static	O
void	O
computeLine	(double,double,double,double,*(struct(double,double,enum(int,int))))->(void)
(	O
double	O
x1	double
,	O
double	O
y1	(double)->(double)
,	O
double	O
x2	double
,	O
double	O
y2	double
,	O
struct	O
line	struct(double,double,enum(int,int))
*	O
line	struct(double,double,enum(int,int))
)	O
;	O
static	O
void	O
tailEllipseY	(*(struct(double,double,double,double,double)),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(void)
(	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
static	O
double	O
tailX	(double,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
double	O
K	double
,	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
const	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
*	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
{	O
double	O
w	double
,	O
h	double
,	O
r	int
;	O
double	O
Hs	double
,	O
Hf	double
,	O
WH	double
,	O
Vk	double
,	O
Nk	double
,	O
Fk	double
,	O
Vr	double
,	O
N	double
,	O
Nc	double
,	O
Z	double
,	O
rs	double
;	O
double	O
A	double
,	O
T	double
,	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
d	double
,	O
x	double
,	O
y	double
,	O
t	double
,	O
hepp	double
,	O
hepm	double
;	O
int	O
flip	int
,	O
solution	enum(int,int)
;	O
double	O
xs	array(double)
[	O
2	int
]	O
;	O
double	O
*	O
xp	*(double)
;	O
w	double
=	O
def	*(struct(double,double,double,double,double))
->	O
w	double
;	O
h	double
=	O
def	*(struct(double,double,double,double,double))
->	O
h	double
;	O
r	int
=	O
def	*(struct(double,double,double,double,double))
->	O
l	int
;	O
rs	double
=	O
r	int
*	O
r	int
;	O
Hs	double
=	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2	double
;	O
WH	double
=	O
-	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2mw2	double
;	O
Nk	double
=	O
def	*(struct(double,double,double,double,double))
->	O
w	double
*	O
r	int
;	O
Vk	double
=	O
(	O
Nk	double
*	O
Hs	double
)	O
/	O
(	O
WH	double
+	O
WH	double
)	O
;	O
Hf	double
=	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h4	double
;	O
Nk	double
=	O
(	O
Hf	double
-	O
Nk	double
*	O
Nk	double
)	O
/	O
WH	double
;	O
if	O
(	O
K	double
==	O
0.0	int
)	O
{	O
if	O
(	O
Nk	double
<	O
0.0	int
&&	O
-	O
Nk	double
<	O
Hs	double
)	O
{	O
xs	array(double)
[	O
0	int
]	O
=	O
w	double
*	O
sqrt	(double)->(double)
(	O
1	int
+	O
Nk	double
/	O
Hs	double
)	O
-	O
sqrt	(double)->(double)
(	O
rs	double
+	O
Nk	double
)	O
;	O
xs	array(double)
[	O
1	int
]	O
=	O
w	double
-	O
r	int
;	O
if	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
valid	enum(int,int)
&&	O
boundedLe	O
(	O
K	double
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
&&	O
!	O
boundedLe	O
(	O
K	double
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
outer	struct(double,double)
)	O
&&	O
xs	array(double)
[	O
0	int
]	O
>=	O
0.0	int
&&	O
xs	array(double)
[	O
1	int
]	O
>=	O
0.0	int
)	O
return	O
xs	array(double)
[	O
1	int
]	O
;	O
if	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
valid	enum(int,int)
&&	O
boundedLe	O
(	O
K	double
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
&&	O
!	O
boundedLe	O
(	O
K	double
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
inner	struct(double,double)
)	O
&&	O
xs	array(double)
[	O
0	int
]	O
<=	O
0.0	int
&&	O
xs	array(double)
[	O
1	int
]	O
<=	O
0.0	int
)	O
return	O
xs	array(double)
[	O
1	int
]	O
;	O
return	O
xs	array(double)
[	O
0	int
]	O
;	O
}	O
return	O
w	double
-	O
r	int
;	O
}	O
Fk	double
=	O
Hf	double
/	O
WH	double
;	O
hepp	double
=	O
h	double
+	O
EPSILON	int
;	O
hepm	double
=	O
h	double
-	O
EPSILON	int
;	O
N	double
=	O
(	O
K	double
*	O
K	double
+	O
Nk	double
)	O
/	O
6.0	int
;	O
Nc	double
=	O
N	double
*	O
N	double
*	O
N	double
;	O
Vr	double
=	O
Vk	double
*	O
K	double
;	O
xp	*(double)
=	O
xs	array(double)
;	O
xs	array(double)
[	O
0	int
]	O
=	O
0.0	int
;	O
t	double
=	O
Nc	double
+	O
Vr	double
*	O
Vr	double
;	O
d	double
=	O
Nc	double
+	O
t	double
;	O
if	O
(	O
d	double
<	O
0.0	int
)	O
{	O
d	double
=	O
Nc	double
;	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
N	double
;	O
if	O
(	O
(	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
<	O
0.0	int
)	O
==	O
(	O
t	double
<	O
0.0	int
)	O
)	O
{	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
-	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
d	double
=	O
-	O
d	double
;	O
}	O
Z	double
=	O
N	double
-	O
2.0	int
*	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
*	O
cos	(double)->(double)
(	O
acos	(double)->(double)
(	O
-	O
t	double
/	O
d	double
)	O
/	O
3.0	int
)	O
;	O
if	O
(	O
(	O
Z	double
<	O
0.0	int
)	O
==	O
(	O
Vr	double
<	O
0.0	int
)	O
)	O
flip	int
=	O
2	int
;	O
else	O
flip	int
=	O
1	int
;	O
}	O
else	O
{	O
d	double
=	O
Vr	double
*	O
sqrt	(double)->(double)
(	O
d	double
)	O
;	O
Z	double
=	O
N	double
+	O
cbrt	(double)->(double)
(	O
t	double
+	O
d	double
)	O
+	O
cbrt	(double)->(double)
(	O
t	double
-	O
d	double
)	O
;	O
flip	int
=	O
0	int
;	O
}	O
A	double
=	O
sqrt	(double)->(double)
(	O
(	O
Z	double
+	O
Z	double
)	O
-	O
Nk	double
)	O
;	O
T	double
=	O
(	O
Fk	double
-	O
Z	double
)	O
*	O
K	double
/	O
A	double
;	O
solution	enum(int,int)
=	O
false	int
;	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
-	O
A	double
+	O
K	double
;	O
d	double
=	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
*	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
-	O
4	int
*	O
(	O
Z	double
+	O
T	double
)	O
;	O
if	O
(	O
d	double
>=	O
0	int
&&	O
flip	int
==	O
2	int
)	O
{	O
d	double
=	O
sqrt	(double)->(double)
(	O
d	double
)	O
;	O
y	double
=	O
0.5	int
*	O
(	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
+	O
d	double
)	O
;	O
if	O
(	O
(	O
y	double
>=	O
0.0	int
)	O
&&	O
(	O
y	double
<	O
hepp	double
)	O
)	O
{	O
solution	enum(int,int)
=	O
true	int
;	O
if	O
(	O
y	double
>	O
hepm	double
)	O
y	double
=	O
h	double
;	O
t	double
=	O
y	double
/	O
h	double
;	O
x	double
=	O
w	double
*	O
sqrt	(double)->(double)
(	O
1	int
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
t	double
=	O
K	double
-	O
y	double
;	O
t	double
=	O
sqrt	(double)->(double)
(	O
rs	double
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
*	O
xp	*(double)
++	O
=	O
x	double
-	O
t	double
;	O
}	O
}	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
A	double
+	O
K	double
;	O
d	double
=	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
*	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
-	O
4	int
*	O
(	O
Z	double
-	O
T	double
)	O
;	O
if	O
(	O
d	double
<	O
0	int
&&	O
!	O
solution	enum(int,int)
)	O
d	double
=	O
0.0	int
;	O
if	O
(	O
d	double
>=	O
0	int
)	O
{	O
d	double
=	O
sqrt	(double)->(double)
(	O
d	double
)	O
;	O
y	double
=	O
0.5	int
*	O
(	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
+	O
d	double
)	O
;	O
if	O
(	O
y	double
<	O
hepp	double
)	O
{	O
if	O
(	O
y	double
>	O
hepm	double
)	O
y	double
=	O
h	double
;	O
t	double
=	O
y	double
/	O
h	double
;	O
x	double
=	O
w	double
*	O
sqrt	(double)->(double)
(	O
1	int
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
t	double
=	O
K	double
-	O
y	double
;	O
*	O
xp	*(double)
++	O
=	O
x	double
-	O
sqrt	(double)->(double)
(	O
rs	double
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
}	O
y	double
=	O
0.5	int
*	O
(	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
-	O
d	double
)	O
;	O
if	O
(	O
y	double
>=	O
0.0	int
&&	O
flip	int
==	O
1	int
)	O
{	O
if	O
(	O
y	double
>	O
hepm	double
)	O
y	double
=	O
h	double
;	O
t	double
=	O
y	double
/	O
h	double
;	O
x	double
=	O
w	double
*	O
sqrt	(double)->(double)
(	O
1	int
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
t	double
=	O
K	double
-	O
y	double
;	O
t	double
=	O
sqrt	(double)->(double)
(	O
rs	double
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
*	O
xp	*(double)
++	O
=	O
x	double
-	O
t	double
;	O
}	O
}	O
if	O
(	O
xp	*(double)
>	O
&	O
xs	array(double)
[	O
1	int
]	O
)	O
{	O
if	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
valid	enum(int,int)
&&	O
boundedLe	O
(	O
K	double
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
&&	O
!	O
boundedLe	O
(	O
K	double
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
outer	struct(double,double)
)	O
&&	O
xs	array(double)
[	O
0	int
]	O
>=	O
0.0	int
&&	O
xs	array(double)
[	O
1	int
]	O
>=	O
0.0	int
)	O
return	O
xs	array(double)
[	O
1	int
]	O
;	O
if	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
valid	enum(int,int)
&&	O
boundedLe	O
(	O
K	double
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
&&	O
!	O
boundedLe	O
(	O
K	double
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
inner	struct(double,double)
)	O
&&	O
xs	array(double)
[	O
0	int
]	O
<=	O
0.0	int
&&	O
xs	array(double)
[	O
1	int
]	O
<=	O
0.0	int
)	O
return	O
xs	array(double)
[	O
1	int
]	O
;	O
}	O
return	O
xs	array(double)
[	O
0	int
]	O
;	O
}	O
static	O
void	O
tailEllipseY	(*(struct(double,double,double,double,double)),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(void)
(	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
{	O
double	O
t	double
;	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
tail_y	double
=	O
0.0	int
;	O
if	O
(	O
def	*(struct(double,double,double,double,double))
->	O
w	double
==	O
def	*(struct(double,double,double,double,double))
->	O
h	double
)	O
return	O
;	O
t	double
=	O
def	*(struct(double,double,double,double,double))
->	O
l	int
*	O
def	*(struct(double,double,double,double,double))
->	O
w	double
;	O
if	O
(	O
def	*(struct(double,double,double,double,double))
->	O
w	double
>	O
def	*(struct(double,double,double,double,double))
->	O
h	double
)	O
{	O
if	O
(	O
t	double
<	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2	double
)	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
t	double
>	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2	double
)	O
return	O
;	O
}	O
t	double
=	O
2.0	int
*	O
def	*(struct(double,double,double,double,double))
->	O
h	double
*	O
t	double
;	O
t	double
=	O
(	O
CUBE_ROOT_4	int
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2	double
-	O
cbrt	(double)->(double)
(	O
t	double
*	O
t	double
)	O
)	O
/	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2mw2	double
;	O
if	O
(	O
t	double
>	O
0.0	int
)	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
tail_y	double
=	O
def	*(struct(double,double,double,double,double))
->	O
h	double
/	O
CUBE_ROOT_2	int
*	O
sqrt	(double)->(double)
(	O
t	double
)	O
;	O
}	O
static	O
double	O
outerXfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
{	O
return	O
x	double
+	O
(	O
x	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2l	double
)	O
/	O
sqrt	(double)->(double)
(	O
x	double
*	O
x	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h4	double
+	O
y	double
*	O
y	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
w4	double
)	O
;	O
}	O
static	O
double	O
outerYfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
{	O
return	O
y	double
+	O
(	O
y	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
w2l	double
)	O
/	O
sqrt	(double)->(double)
(	O
x	double
*	O
x	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h4	double
+	O
y	double
*	O
y	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
w4	double
)	O
;	O
}	O
static	O
double	O
innerXfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
{	O
return	O
x	double
-	O
(	O
x	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2l	double
)	O
/	O
sqrt	(double)->(double)
(	O
x	double
*	O
x	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h4	double
+	O
y	double
*	O
y	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
w4	double
)	O
;	O
}	O
static	O
double	O
innerYfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
{	O
return	O
y	double
-	O
(	O
y	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
w2l	double
)	O
/	O
sqrt	(double)->(double)
(	O
x	double
*	O
x	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h4	double
+	O
y	double
*	O
y	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
w4	double
)	O
;	O
}	O
static	O
double	O
innerYfromY	(double,*(struct(double,double,double,double,double)),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
double	O
y	double
,	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
{	O
double	O
x	double
;	O
x	double
=	O
(	O
def	*(struct(double,double,double,double,double))
->	O
w	double
/	O
def	*(struct(double,double,double,double,double))
->	O
h	double
)	O
*	O
sqrt	(double)->(double)
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2	double
-	O
y	double
*	O
y	double
)	O
;	O
return	O
y	double
-	O
(	O
y	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
w2l	double
)	O
/	O
sqrt	(double)->(double)
(	O
x	double
*	O
x	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h4	double
+	O
y	double
*	O
y	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
w4	double
)	O
;	O
}	O
static	O
void	O
computeLine	(double,double,double,double,*(struct(double,double,enum(int,int))))->(void)
(	O
double	O
x1	double
,	O
double	O
y1	(double)->(double)
,	O
double	O
x2	double
,	O
double	O
y2	double
,	O
struct	O
line	struct(double,double,enum(int,int))
*	O
line	struct(double,double,enum(int,int))
)	O
{	O
if	O
(	O
y1	(double)->(double)
==	O
y2	double
)	O
line	struct(double,double,enum(int,int))
->	O
valid	enum(int,int)
=	O
false	int
;	O
else	O
{	O
line	struct(double,double,enum(int,int))
->	O
m	array(double)
=	O
(	O
x1	double
-	O
x2	double
)	O
/	O
(	O
y1	(double)->(double)
-	O
y2	double
)	O
;	O
line	struct(double,double,enum(int,int))
->	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
x1	double
-	O
y1	(double)->(double)
*	O
line	struct(double,double,enum(int,int))
->	O
m	array(double)
;	O
line	struct(double,double,enum(int,int))
->	O
valid	enum(int,int)
=	O
true	int
;	O
}	O
}	O
static	O
void	O
computeAcc	(*(struct(int,int,int,int,int,int)),int,*(struct(double,double,double,double,double)),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(void)
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
tarc	*(struct(int,int,int,int,int,int))
,	O
unsigned	O
int	O
lw	int
,	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
{	O
def	*(struct(double,double,double,double,double))
->	O
w	double
=	O
0.5	int
*	O
(	O
double	O
)	O
tarc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
;	O
def	*(struct(double,double,double,double,double))
->	O
h	double
=	O
0.5	int
*	O
(	O
double	O
)	O
tarc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
def	*(struct(double,double,double,double,double))
->	O
l	int
=	O
0.5	int
*	O
(	O
double	O
)	O
lw	int
;	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2	double
=	O
def	*(struct(double,double,double,double,double))
->	O
h	double
*	O
def	*(struct(double,double,double,double,double))
->	O
h	double
;	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
w2	double
=	O
def	*(struct(double,double,double,double,double))
->	O
w	double
*	O
def	*(struct(double,double,double,double,double))
->	O
w	double
;	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h4	double
=	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2	double
;	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
w4	double
=	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
w2	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
w2	double
;	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2l	double
=	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2	double
*	O
def	*(struct(double,double,double,double,double))
->	O
l	int
;	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
w2l	double
=	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
w2	double
*	O
def	*(struct(double,double,double,double,double))
->	O
l	int
;	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2mw2	double
=	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2	double
-	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
w2	double
;	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntX	double
=	O
(	O
tarc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&	O
1	int
)	O
?	O
0.5	int
:	O
0.0	int
;	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntY	double
=	O
(	O
tarc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
)	O
?	O
0.5	int
:	O
0.0	int
;	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
=	O
tarc	*(struct(int,int,int,int,int,int))
->	O
x	double
+	O
(	O
int	O
)	O
(	O
tarc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
>>	O
1	int
)	O
;	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
yorgu	int
=	O
tarc	*(struct(int,int,int,int,int,int))
->	O
y	double
+	O
(	O
int	O
)	O
(	O
tarc	*(struct(int,int,int,int,int,int))
->	O
height	int
>>	O
1	int
)	O
;	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
yorgl	int
=	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
yorgu	int
+	O
(	O
tarc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
)	O
;	O
tailEllipseY	(*(struct(double,double,double,double,double)),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(void)
(	O
def	*(struct(double,double,double,double,double))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
}	O
static	O
void	O
computeBound	(*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))))->(void)
(	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
*	O
bound	struct(double,double)
,	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
{	O
double	O
t	double
;	O
double	O
innerTaily	double
;	O
double	O
tail_y	double
;	O
struct	O
bound	struct(double,double)
innerx	struct(double,double)
,	O
outerx	struct(double,double)
;	O
struct	O
bound	struct(double,double)
ellipsex	struct(double,double)
;	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
min	int
=	O
Dsin	O
(	O
def	*(struct(double,double,double,double,double))
->	O
a0	int
)	O
*	O
def	*(struct(double,double,double,double,double))
->	O
h	double
;	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
max	int
=	O
Dsin	O
(	O
def	*(struct(double,double,double,double,double))
->	O
a1	int
)	O
*	O
def	*(struct(double,double,double,double,double))
->	O
h	double
;	O
if	O
(	O
def	*(struct(double,double,double,double,double))
->	O
a0	int
==	O
45	int
&&	O
def	*(struct(double,double,double,double,double))
->	O
w	double
==	O
def	*(struct(double,double,double,double,double))
->	O
h	double
)	O
ellipsex	struct(double,double)
.	O
min	int
=	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
min	int
;	O
else	O
ellipsex	struct(double,double)
.	O
min	int
=	O
Dcos	O
(	O
def	*(struct(double,double,double,double,double))
->	O
a0	int
)	O
*	O
def	*(struct(double,double,double,double,double))
->	O
w	double
;	O
if	O
(	O
def	*(struct(double,double,double,double,double))
->	O
a1	int
==	O
45	int
&&	O
def	*(struct(double,double,double,double,double))
->	O
w	double
==	O
def	*(struct(double,double,double,double,double))
->	O
h	double
)	O
ellipsex	struct(double,double)
.	O
max	int
=	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
max	int
;	O
else	O
ellipsex	struct(double,double)
.	O
max	int
=	O
Dcos	O
(	O
def	*(struct(double,double,double,double,double))
->	O
a1	int
)	O
*	O
def	*(struct(double,double,double,double,double))
->	O
w	double
;	O
bound	struct(double,double)
->	O
outer	struct(double,double)
.	O
min	int
=	O
outerYfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
ellipsex	struct(double,double)
.	O
min	int
,	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
min	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
bound	struct(double,double)
->	O
outer	struct(double,double)
.	O
max	int
=	O
outerYfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
ellipsex	struct(double,double)
.	O
max	int
,	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
max	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
min	int
=	O
innerYfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
ellipsex	struct(double,double)
.	O
min	int
,	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
min	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
max	int
=	O
innerYfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
ellipsex	struct(double,double)
.	O
max	int
,	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
max	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
outerx	struct(double,double)
.	O
min	int
=	O
outerXfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
ellipsex	struct(double,double)
.	O
min	int
,	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
min	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
outerx	struct(double,double)
.	O
max	int
=	O
outerXfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
ellipsex	struct(double,double)
.	O
max	int
,	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
max	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
innerx	struct(double,double)
.	O
min	int
=	O
innerXfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
ellipsex	struct(double,double)
.	O
min	int
,	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
min	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
innerx	struct(double,double)
.	O
max	int
=	O
innerXfromXY	(double,double,*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
ellipsex	struct(double,double)
.	O
max	int
,	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
max	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
if	O
(	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
{	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
.	O
y	double
=	O
bound	struct(double,double)
->	O
outer	struct(double,double)
.	O
min	int
;	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
.	O
x	double
=	O
outerx	struct(double,double)
.	O
min	int
;	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
center	struct(double,double)
.	O
y	double
=	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
min	int
;	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
center	struct(double,double)
.	O
x	double
=	O
ellipsex	struct(double,double)
.	O
min	int
;	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
.	O
y	double
=	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
min	int
;	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
.	O
x	double
=	O
innerx	struct(double,double)
.	O
min	int
;	O
}	O
if	O
(	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
{	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
.	O
y	double
=	O
bound	struct(double,double)
->	O
outer	struct(double,double)
.	O
max	int
;	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
.	O
x	double
=	O
outerx	struct(double,double)
.	O
max	int
;	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
center	struct(double,double)
.	O
y	double
=	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
max	int
;	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
center	struct(double,double)
.	O
x	double
=	O
ellipsex	struct(double,double)
.	O
max	int
;	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
.	O
y	double
=	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
max	int
;	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
.	O
x	double
=	O
innerx	struct(double,double)
.	O
max	int
;	O
}	O
bound	struct(double,double)
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
min	int
=	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
max	int
;	O
bound	struct(double,double)
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
max	int
=	O
bound	struct(double,double)
->	O
outer	struct(double,double)
.	O
max	int
;	O
bound	struct(double,double)
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
min	int
=	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
min	int
;	O
bound	struct(double,double)
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
max	int
=	O
bound	struct(double,double)
->	O
outer	struct(double,double)
.	O
min	int
;	O
computeLine	(double,double,double,double,*(struct(double,double,enum(int,int))))->(void)
(	O
innerx	struct(double,double)
.	O
min	int
,	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
min	int
,	O
outerx	struct(double,double)
.	O
min	int
,	O
bound	struct(double,double)
->	O
outer	struct(double,double)
.	O
min	int
,	O
&	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
computeLine	(double,double,double,double,*(struct(double,double,enum(int,int))))->(void)
(	O
innerx	struct(double,double)
.	O
max	int
,	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
max	int
,	O
outerx	struct(double,double)
.	O
max	int
,	O
bound	struct(double,double)
->	O
outer	struct(double,double)
.	O
max	int
,	O
&	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
if	O
(	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
min	int
>	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
max	int
)	O
{	O
t	double
=	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
min	int
;	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
min	int
=	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
max	int
;	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
max	int
=	O
t	double
;	O
}	O
tail_y	double
=	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
tail_y	double
;	O
if	O
(	O
tail_y	double
>	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
max	int
)	O
tail_y	double
=	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
max	int
;	O
else	O
if	O
(	O
tail_y	double
<	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
min	int
)	O
tail_y	double
=	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
min	int
;	O
innerTaily	double
=	O
innerYfromY	(double,*(struct(double,double,double,double,double)),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
tail_y	double
,	O
def	*(struct(double,double,double,double,double))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
if	O
(	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
min	int
>	O
innerTaily	double
)	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
min	int
=	O
innerTaily	double
;	O
if	O
(	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
max	int
<	O
innerTaily	double
)	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
max	int
=	O
innerTaily	double
;	O
bound	struct(double,double)
->	O
inneri	struct(int,int)
.	O
min	int
=	O
ICEIL	O
(	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
min	int
-	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntY	double
)	O
;	O
bound	struct(double,double)
->	O
inneri	struct(int,int)
.	O
max	int
=	O
IFLOOR	O
(	O
bound	struct(double,double)
->	O
inner	struct(double,double)
.	O
max	int
-	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntY	double
)	O
;	O
bound	struct(double,double)
->	O
outeri	struct(int,int)
.	O
min	int
=	O
ICEIL	O
(	O
bound	struct(double,double)
->	O
outer	struct(double,double)
.	O
min	int
-	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntY	double
)	O
;	O
bound	struct(double,double)
->	O
outeri	struct(int,int)
.	O
max	int
=	O
IFLOOR	O
(	O
bound	struct(double,double)
->	O
outer	struct(double,double)
.	O
max	int
-	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntY	double
)	O
;	O
}	O
static	O
double	O
hookEllipseY	(double,*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),enum(int,int))->(double)
(	O
double	O
scan_y	double
,	O
const	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
*	O
bound	struct(double,double)
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
bool	enum(int,int)
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
{	O
double	O
ret	double
;	O
if	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2mw2	double
==	O
0	int
)	O
{	O
if	O
(	O
(	O
scan_y	double
>	O
0	int
&&	O
(	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
?	O
false	int
:	O
true	int
)	O
)	O
||	O
(	O
scan_y	double
<	O
0	int
&&	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
)	O
return	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
min	int
;	O
return	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
.	O
max	int
;	O
}	O
ret	double
=	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h4	double
*	O
scan_y	double
)	O
/	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2mw2	double
)	O
;	O
if	O
(	O
ret	double
>=	O
0	int
)	O
return	O
cbrt	(double)->(double)
(	O
ret	double
)	O
;	O
else	O
return	O
-	O
cbrt	(double)->(double)
(	O
-	O
ret	double
)	O
;	O
}	O
static	O
double	O
hookX	(double,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),enum(int,int))->(double)
(	O
double	O
scan_y	double
,	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
const	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
*	O
bound	struct(double,double)
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
bool	enum(int,int)
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
{	O
double	O
ellipse_y	double
,	O
x	double
;	O
double	O
maxMin	double
;	O
if	O
(	O
def	*(struct(double,double,double,double,double))
->	O
w	double
!=	O
def	*(struct(double,double,double,double,double))
->	O
h	double
)	O
{	O
ellipse_y	double
=	O
hookEllipseY	(double,*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),enum(int,int))->(double)
(	O
scan_y	double
,	O
bound	struct(double,double)
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
if	O
(	O
boundedLe	O
(	O
ellipse_y	double
,	O
bound	struct(double,double)
->	O
ellipse	struct(double,double)
)	O
)	O
{	O
maxMin	double
=	O
ellipse_y	double
*	O
ellipse_y	double
*	O
ellipse_y	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2mw2	double
-	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2	double
*	O
scan_y	double
*	O
(	O
3	int
*	O
ellipse_y	double
*	O
ellipse_y	double
-	O
2	int
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2	double
)	O
;	O
if	O
(	O
(	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
&&	O
maxMin	double
>	O
0	int
)	O
||	O
(	O
(	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
?	O
false	int
:	O
true	int
)	O
&&	O
maxMin	double
<	O
0	int
)	O
)	O
{	O
if	O
(	O
ellipse_y	double
==	O
0	int
)	O
return	O
def	*(struct(double,double,double,double,double))
->	O
w	double
+	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
?	O
-	O
def	*(struct(double,double,double,double,double))
->	O
l	int
:	O
def	*(struct(double,double,double,double,double))
->	O
l	int
;	O
x	double
=	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2	double
*	O
scan_y	double
-	O
ellipse_y	double
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2mw2	double
)	O
*	O
sqrt	(double)->(double)
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
h2	double
-	O
ellipse_y	double
*	O
ellipse_y	double
)	O
/	O
(	O
def	*(struct(double,double,double,double,double))
->	O
h	double
*	O
def	*(struct(double,double,double,double,double))
->	O
w	double
*	O
ellipse_y	double
)	O
;	O
return	O
x	double
;	O
}	O
}	O
}	O
if	O
(	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
{	O
if	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
valid	enum(int,int)
&&	O
boundedLe	O
(	O
scan_y	double
,	O
bound	struct(double,double)
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
)	O
x	double
=	O
intersectLine	O
(	O
scan_y	double
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
else	O
{	O
if	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
valid	enum(int,int)
)	O
x	double
=	O
intersectLine	O
(	O
scan_y	double
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
else	O
x	double
=	O
def	*(struct(double,double,double,double,double))
->	O
w	double
-	O
def	*(struct(double,double,double,double,double))
->	O
l	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
valid	enum(int,int)
&&	O
boundedLe	O
(	O
scan_y	double
,	O
bound	struct(double,double)
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
)	O
x	double
=	O
intersectLine	O
(	O
scan_y	double
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
else	O
{	O
if	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
valid	enum(int,int)
)	O
x	double
=	O
intersectLine	O
(	O
scan_y	double
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
else	O
x	double
=	O
def	*(struct(double,double,double,double,double))
->	O
w	double
-	O
def	*(struct(double,double,double,double,double))
->	O
l	int
;	O
}	O
}	O
return	O
x	double
;	O
}	O
static	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
realAllocSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))))->(*(struct(int,int,*(struct(int,int,*`)))))
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
)	O
;	O
static	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
*	O
realFindSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int)->(*(*(struct(int,int,*(struct`)))))
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
int	O
y	double
)	O
;	O
static	O
void	O
disposeFinalSpans	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))))->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
)	O
;	O
static	O
void	O
newFinalSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int)->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
int	O
y	double
,	O
int	O
xmin	double
,	O
int	O
xmax	double
)	O
;	O
static	O
void	O
initAccumSpans	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))))->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
)	O
{	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
=	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
*	O
)	O
NULL	O
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
=	O
0	int
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMaxy	int
=	O
-	O
1	int
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSize	int
=	O
0	int
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
nspans	int
=	O
0	int
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
chunks	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
=	O
(	O
struct	O
finalSpanChunk	struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))))))
*	O
)	O
NULL	O
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
freeFinalSpans	*(struct(int,int,*(struct(int,int,*(struct`)))))
=	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
)	O
NULL	O
;	O
}	O
static	O
void	O
newFinalSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int)->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
int	O
y	double
,	O
int	O
xmin	double
,	O
int	O
xmax	double
)	O
{	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
x	double
,	O
*	O
oldx	*(struct(int,int,*(struct(int,int,*(struct`)))))
,	O
*	O
prev	*(struct(int,int,*(struct(int,int,*(struct`)))))
,	O
*	O
*	O
f	*(*(struct(int,int,*(struct(int,int,*`)))))
;	O
if	O
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
<=	O
y	double
&&	O
y	double
<=	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMaxy	int
)	O
f	*(*(struct(int,int,*(struct(int,int,*`)))))
=	O
&	O
(	O
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
)	O
[	O
(	O
y	double
)	O
-	O
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
)	O
]	O
)	O
;	O
else	O
f	*(*(struct(int,int,*(struct(int,int,*`)))))
=	O
realFindSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int)->(*(*(struct(int,int,*(struct`)))))
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
y	double
)	O
;	O
if	O
(	O
f	*(*(struct(int,int,*(struct(int,int,*`)))))
==	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
*	O
)	O
NULL	O
)	O
return	O
;	O
oldx	*(struct(int,int,*(struct(int,int,*(struct`)))))
=	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
)	O
NULL	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
prev	*(struct(int,int,*(struct(int,int,*(struct`)))))
=	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
)	O
NULL	O
;	O
for	O
(	O
x	double
=	O
*	O
f	*(*(struct(int,int,*(struct(int,int,*`)))))
;	O
x	double
;	O
x	double
=	O
x	double
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
)	O
{	O
if	O
(	O
x	double
==	O
oldx	*(struct(int,int,*(struct(int,int,*(struct`)))))
)	O
{	O
prev	*(struct(int,int,*(struct(int,int,*(struct`)))))
=	O
x	double
;	O
continue	O
;	O
}	O
if	O
(	O
x	double
->	O
min	int
<=	O
xmax	double
&&	O
xmin	double
<=	O
x	double
->	O
max	int
)	O
{	O
if	O
(	O
oldx	*(struct(int,int,*(struct(int,int,*(struct`)))))
)	O
{	O
oldx	*(struct(int,int,*(struct(int,int,*(struct`)))))
->	O
min	int
=	O
IMIN	O
(	O
x	double
->	O
min	int
,	O
xmin	double
)	O
;	O
oldx	*(struct(int,int,*(struct(int,int,*(struct`)))))
->	O
max	int
=	O
IMAX	O
(	O
x	double
->	O
max	int
,	O
xmax	double
)	O
;	O
if	O
(	O
prev	*(struct(int,int,*(struct(int,int,*(struct`)))))
)	O
prev	*(struct(int,int,*(struct(int,int,*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
=	O
x	double
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
;	O
else	O
*	O
f	*(*(struct(int,int,*(struct(int,int,*`)))))
=	O
x	double
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
;	O
--	O
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
nspans	int
)	O
;	O
}	O
else	O
{	O
x	double
->	O
min	int
=	O
IMIN	O
(	O
x	double
->	O
min	int
,	O
xmin	double
)	O
;	O
x	double
->	O
max	int
=	O
IMAX	O
(	O
x	double
->	O
max	int
,	O
xmax	double
)	O
;	O
oldx	*(struct(int,int,*(struct(int,int,*(struct`)))))
=	O
x	double
;	O
}	O
xmin	double
=	O
oldx	*(struct(int,int,*(struct(int,int,*(struct`)))))
->	O
min	int
;	O
xmax	double
=	O
oldx	*(struct(int,int,*(struct(int,int,*(struct`)))))
->	O
max	int
;	O
break	O
;	O
}	O
prev	*(struct(int,int,*(struct(int,int,*(struct`)))))
=	O
x	double
;	O
}	O
if	O
(	O
!	O
x	double
)	O
break	O
;	O
}	O
if	O
(	O
!	O
oldx	*(struct(int,int,*(struct(int,int,*(struct`)))))
)	O
{	O
if	O
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
freeFinalSpans	*(struct(int,int,*(struct(int,int,*(struct`)))))
!=	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
)	O
NULL	O
)	O
{	O
x	double
=	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
freeFinalSpans	*(struct(int,int,*(struct(int,int,*(struct`)))))
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
freeFinalSpans	*(struct(int,int,*(struct(int,int,*(struct`)))))
=	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
freeFinalSpans	*(struct(int,int,*(struct(int,int,*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
;	O
x	double
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
=	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
)	O
NULL	O
;	O
}	O
else	O
x	double
=	O
realAllocSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))))->(*(struct(int,int,*(struct(int,int,*`)))))
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
)	O
;	O
if	O
(	O
x	double
)	O
{	O
x	double
->	O
min	int
=	O
xmin	double
;	O
x	double
->	O
max	int
=	O
xmax	double
;	O
x	double
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
=	O
*	O
f	*(*(struct(int,int,*(struct(int,int,*`)))))
;	O
*	O
f	*(*(struct(int,int,*(struct(int,int,*`)))))
=	O
x	double
;	O
++	O
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
nspans	int
)	O
;	O
}	O
}	O
}	O
static	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
*	O
realFindSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int)->(*(*(struct(int,int,*(struct`)))))
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
int	O
y	double
)	O
{	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
*	O
newSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
,	O
*	O
*	O
t	double
;	O
int	O
newSize	int
,	O
newMiny	int
,	O
newMaxy	int
;	O
int	O
change	int
;	O
int	O
i	int
,	O
k	int
;	O
if	O
(	O
y	double
<	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
||	O
y	double
>	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMaxy	int
)	O
{	O
if	O
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSize	int
==	O
0	int
)	O
{	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
=	O
y	double
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMaxy	int
=	O
y	double
-	O
1	int
;	O
}	O
if	O
(	O
y	double
<	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
)	O
change	int
=	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
-	O
y	double
;	O
else	O
change	int
=	O
y	double
-	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMaxy	int
;	O
if	O
(	O
change	int
>=	O
SPAN_REALLOC	int
)	O
change	int
+=	O
SPAN_REALLOC	int
;	O
else	O
change	int
=	O
SPAN_REALLOC	int
;	O
newSize	int
=	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSize	int
+	O
change	int
;	O
newSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
=	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
*	O
)	O
mi_xmalloc	O
(	O
newSize	int
*	O
sizeof	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
)	O
)	O
;	O
newMiny	int
=	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
;	O
newMaxy	int
=	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMaxy	int
;	O
if	O
(	O
y	double
<	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
)	O
newMiny	int
=	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
-	O
change	int
;	O
else	O
newMaxy	int
=	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMaxy	int
+	O
change	int
;	O
if	O
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
(	O
void	O
*	O
)	O
(	O
newSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
+	O
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
-	O
newMiny	int
)	O
)	O
,	O
(	O
void	O
*	O
)	O
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
)	O
,	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSize	int
*	O
sizeof	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
)	O
;	O
}	O
if	O
(	O
(	O
i	int
=	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
-	O
newMiny	int
)	O
>	O
0	int
)	O
for	O
(	O
k	int
=	O
0	int
,	O
t	double
=	O
newSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
;	O
k	int
<	O
i	int
;	O
k	int
++	O
,	O
t	double
++	O
)	O
*	O
t	double
=	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
)	O
NULL	O
;	O
if	O
(	O
(	O
i	int
=	O
newMaxy	int
-	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMaxy	int
)	O
>	O
0	int
)	O
for	O
(	O
k	int
=	O
0	int
,	O
t	double
=	O
newSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
+	O
newSize	int
-	O
i	int
;	O
k	int
<	O
i	int
;	O
k	int
++	O
,	O
t	double
++	O
)	O
*	O
t	double
=	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
)	O
NULL	O
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
=	O
newSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMaxy	int
=	O
newMaxy	int
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
=	O
newMiny	int
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSize	int
=	O
newSize	int
;	O
}	O
return	O
&	O
(	O
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
)	O
[	O
(	O
y	double
)	O
-	O
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
)	O
]	O
)	O
;	O
}	O
static	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
realAllocSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))))->(*(struct(int,int,*(struct(int,int,*`)))))
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
)	O
{	O
struct	O
finalSpanChunk	struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))))))
*	O
newChunk	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
;	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
span	*(struct(int,int,int,int))
;	O
int	O
i	int
;	O
newChunk	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
=	O
(	O
struct	O
finalSpanChunk	struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))))))
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
struct	O
finalSpanChunk	struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))))))
)	O
)	O
;	O
newChunk	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
=	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
chunks	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
chunks	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
=	O
newChunk	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
freeFinalSpans	*(struct(int,int,*(struct(int,int,*(struct`)))))
=	O
newChunk	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
->	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
+	O
1	int
;	O
span	*(struct(int,int,int,int))
=	O
newChunk	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
->	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
+	O
1	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
SPAN_CHUNK_SIZE	int
-	O
1	int
;	O
i	int
++	O
)	O
{	O
span	*(struct(int,int,int,int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
=	O
span	*(struct(int,int,int,int))
+	O
1	int
;	O
span	*(struct(int,int,int,int))
++	O
;	O
}	O
span	*(struct(int,int,int,int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
=	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
)	O
NULL	O
;	O
span	*(struct(int,int,int,int))
=	O
newChunk	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
->	O
data	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(*(void)),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int,int,int),enum(int,int),*(struct(*(struct`))),int,int,enum(int,int),int,int,int,int,double,double,double,double,*(struct(*(char),*(char),*(char),enum(int,int),double,double,double,double,double,double)),double,double,double,double,double,double,array(double),enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),int,enum(int,int),enum(int,int),enum(int,int),enum(int,int),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
;	O
span	*(struct(int,int,int,int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
=	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
)	O
NULL	O
;	O
return	O
span	*(struct(int,int,int,int))
;	O
}	O
static	O
void	O
fillSpans	(*(struct(*(*(struct`)),int,int)),struct(char,union(char,array(char))),*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	struct(char,union(char,array(char)))
pixel	struct(char,union(char,array(char)))
,	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
)	O
{	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
span	*(struct(int,int,int,int))
;	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
*	O
f	*(*(struct(int,int,*(struct(int,int,*`)))))
;	O
int	O
spany	int
;	O
miPoint	struct(int,int)
*	O
ppt	*(struct(int,int))
,	O
*	O
pptInit	*(struct(int,int))
;	O
unsigned	O
int	O
*	O
pwidth	*(int)
,	O
*	O
pwidthInit	*(int)
;	O
if	O
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
nspans	int
==	O
0	int
)	O
return	O
;	O
ppt	*(struct(int,int))
=	O
pptInit	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
nspans	int
*	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
)	O
;	O
pwidth	*(int)
=	O
pwidthInit	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
nspans	int
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
for	O
(	O
spany	int
=	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
,	O
f	*(*(struct(int,int,*(struct(int,int,*`)))))
=	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
;	O
spany	int
<=	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMaxy	int
;	O
spany	int
++	O
,	O
f	*(*(struct(int,int,*(struct(int,int,*`)))))
++	O
)	O
{	O
for	O
(	O
span	*(struct(int,int,int,int))
=	O
*	O
f	*(*(struct(int,int,*(struct(int,int,*`)))))
;	O
span	*(struct(int,int,int,int))
;	O
span	*(struct(int,int,int,int))
=	O
span	*(struct(int,int,int,int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
)	O
{	O
if	O
(	O
span	*(struct(int,int,int,int))
->	O
max	int
<=	O
span	*(struct(int,int,int,int))
->	O
min	int
)	O
continue	O
;	O
ppt	*(struct(int,int))
->	O
x	double
=	O
span	*(struct(int,int,int,int))
->	O
min	int
;	O
ppt	*(struct(int,int))
->	O
y	double
=	O
spany	int
;	O
++	O
ppt	*(struct(int,int))
;	O
*	O
pwidth	*(int)
++	O
=	O
(	O
unsigned	O
int	O
)	O
(	O
span	*(struct(int,int,int,int))
->	O
max	int
-	O
span	*(struct(int,int,int,int))
->	O
min	int
)	O
;	O
}	O
}	O
MI_PAINT_SPANS	O
(	O
paintedSet	*(struct)
,	O
pixel	struct(char,union(char,array(char)))
,	O
ppt	*(struct(int,int))
-	O
pptInit	*(struct(int,int))
,	O
pptInit	*(struct(int,int))
,	O
pwidthInit	*(int)
)	O
disposeFinalSpans	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))))->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
)	O
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMiny	int
=	O
0	int
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalMaxy	int
=	O
-	O
1	int
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSize	int
=	O
0	int
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
nspans	int
=	O
0	int
;	O
}	O
static	O
void	O
disposeFinalSpans	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))))->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
)	O
{	O
struct	O
finalSpanChunk	struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))))))
*	O
chunk	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
,	O
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
;	O
for	O
(	O
chunk	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
=	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
chunks	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
;	O
chunk	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
;	O
chunk	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
=	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
)	O
{	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
=	O
chunk	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`))),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct(*(struct`),*(struct`),*(char),long,*(char),*(char),long,long,double,double,double,double,array(enum(int,int)),array(enum(int,int)),struct(int,int,int),enum(int,int),*(void),*(struct`)))))
;	O
free	(*(void))->(void)
(	O
chunk	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
)	O
;	O
}	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
chunks	*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`)))))
=	O
(	O
struct	O
finalSpanChunk	struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))))))
*	O
)	O
NULL	O
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
freeFinalSpans	*(struct(int,int,*(struct(int,int,*(struct`)))))
=	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
)	O
NULL	O
;	O
free	(*(void))->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
)	O
;	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
->	O
finalSpans	*(*(struct(int,int,*(struct(int,int,*`)))))
=	O
(	O
struct	O
finalSpan	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`))))))
*	O
*	O
)	O
NULL	O
;	O
}	O
static	O
void	O
arcSpan	*(struct(int,int,int,int))
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
int	O
y	double
,	O
int	O
lx	int
,	O
int	O
lw	int
,	O
int	O
rx	double
,	O
int	O
rw	int
,	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
const	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
*	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
unsigned	O
int	O
mask	int
)	O
;	O
static	O
void	O
arcSpan0	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int,int,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),int)->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
int	O
lx	int
,	O
int	O
lw	int
,	O
int	O
rx	double
,	O
int	O
rw	int
,	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
const	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
*	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
unsigned	O
int	O
mask	int
)	O
;	O
static	O
void	O
tailSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),int)->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
int	O
y	double
,	O
int	O
lw	int
,	O
int	O
rw	int
,	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
const	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
*	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
unsigned	O
int	O
mask	int
)	O
;	O
static	O
void	O
arcSpan	*(struct(int,int,int,int))
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
int	O
y	double
,	O
int	O
lx	int
,	O
int	O
lw	int
,	O
int	O
rx	double
,	O
int	O
rw	int
,	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
const	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
*	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
unsigned	O
int	O
mask	int
)	O
{	O
int	O
linx	int
,	O
loutx	int
,	O
rinx	int
,	O
routx	int
;	O
double	O
x	double
,	O
altx	double
;	O
if	O
(	O
boundedLe	O
(	O
y	double
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
inneri	struct(int,int)
)	O
)	O
{	O
linx	int
=	O
-	O
(	O
lx	int
+	O
lw	int
)	O
;	O
rinx	int
=	O
rx	double
;	O
}	O
else	O
{	O
x	double
=	O
hookX	(double,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),enum(int,int))->(double)
(	O
y	double
+	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntY	double
,	O
def	*(struct(double,double,double,double,double))
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
true	int
)	O
;	O
if	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
valid	enum(int,int)
&&	O
boundedLe	O
(	O
y	double
+	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntY	double
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
)	O
{	O
altx	double
=	O
intersectLine	O
(	O
y	double
+	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntY	double
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
if	O
(	O
altx	double
<	O
x	double
)	O
x	double
=	O
altx	double
;	O
}	O
linx	int
=	O
-	O
ICEIL	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntX	double
-	O
x	double
)	O
;	O
rinx	int
=	O
ICEIL	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntX	double
+	O
x	double
)	O
;	O
}	O
if	O
(	O
boundedLe	O
(	O
y	double
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
outeri	struct(int,int)
)	O
)	O
{	O
loutx	int
=	O
-	O
lx	int
;	O
routx	int
=	O
rx	double
+	O
rw	int
;	O
}	O
else	O
{	O
x	double
=	O
hookX	(double,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),enum(int,int))->(double)
(	O
y	double
+	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntY	double
,	O
def	*(struct(double,double,double,double,double))
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
false	int
)	O
;	O
if	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
valid	enum(int,int)
&&	O
boundedLe	O
(	O
y	double
+	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntY	double
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
)	O
{	O
altx	double
=	O
x	double
;	O
x	double
=	O
intersectLine	O
(	O
y	double
+	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntY	double
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
if	O
(	O
x	double
<	O
altx	double
)	O
x	double
=	O
altx	double
;	O
}	O
loutx	int
=	O
-	O
ICEIL	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntX	double
-	O
x	double
)	O
;	O
routx	int
=	O
ICEIL	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntX	double
+	O
x	double
)	O
;	O
}	O
if	O
(	O
routx	int
>	O
rinx	int
)	O
{	O
if	O
(	O
mask	int
&	O
1	int
)	O
newFinalSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int)->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
yorgu	int
-	O
y	double
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
+	O
rinx	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
+	O
routx	int
)	O
;	O
if	O
(	O
mask	int
&	O
8	int
)	O
newFinalSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int)->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
yorgl	int
+	O
y	double
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
+	O
rinx	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
+	O
routx	int
)	O
;	O
}	O
if	O
(	O
loutx	int
>	O
linx	int
)	O
{	O
if	O
(	O
mask	int
&	O
2	int
)	O
newFinalSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int)->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
yorgu	int
-	O
y	double
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
-	O
loutx	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
-	O
linx	int
)	O
;	O
if	O
(	O
mask	int
&	O
4	int
)	O
newFinalSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int)->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
yorgl	int
+	O
y	double
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
-	O
loutx	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
-	O
linx	int
)	O
;	O
}	O
}	O
static	O
void	O
arcSpan0	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int,int,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),int)->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
int	O
lx	int
,	O
int	O
lw	int
,	O
int	O
rx	double
,	O
int	O
rw	int
,	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
const	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
*	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
unsigned	O
int	O
mask	int
)	O
{	O
double	O
x	double
;	O
if	O
(	O
boundedLe	O
(	O
0	int
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
inneri	struct(int,int)
)	O
&&	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
valid	enum(int,int)
&&	O
boundedLe	O
(	O
0	int
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
&&	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
>	O
0	int
)	O
{	O
x	double
=	O
def	*(struct(double,double,double,double,double))
->	O
w	double
-	O
def	*(struct(double,double,double,double,double))
->	O
l	int
;	O
if	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
<	O
x	double
)	O
x	double
=	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
b	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
lw	int
=	O
ICEIL	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntX	double
-	O
x	double
)	O
-	O
lx	int
;	O
rw	int
+=	O
rx	double
;	O
rx	double
=	O
ICEIL	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntX	double
+	O
x	double
)	O
;	O
rw	int
-=	O
rx	double
;	O
}	O
arcSpan	*(struct(int,int,int,int))
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
0	int
,	O
lx	int
,	O
lw	int
,	O
rx	double
,	O
rw	int
,	O
def	*(struct(double,double,double,double,double))
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
mask	int
)	O
;	O
}	O
static	O
void	O
tailSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),int)->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
int	O
y	double
,	O
int	O
lw	int
,	O
int	O
rw	int
,	O
const	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
const	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
*	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
const	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
unsigned	O
int	O
mask	int
)	O
{	O
double	O
yy	int
,	O
xalt	double
,	O
x	double
,	O
lx	int
,	O
rx	double
;	O
int	O
n	array(double)
;	O
if	O
(	O
boundedLe	O
(	O
y	double
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
outeri	struct(int,int)
)	O
)	O
arcSpan	*(struct(int,int,int,int))
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
y	double
,	O
0	int
,	O
lw	int
,	O
-	O
rw	int
,	O
rw	int
,	O
def	*(struct(double,double,double,double,double))
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
mask	int
)	O
;	O
else	O
if	O
(	O
def	*(struct(double,double,double,double,double))
->	O
w	double
!=	O
def	*(struct(double,double,double,double,double))
->	O
h	double
)	O
{	O
yy	int
=	O
y	double
+	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntY	double
;	O
x	double
=	O
tailX	(double,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
yy	int
,	O
def	*(struct(double,double,double,double,double))
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
if	O
(	O
yy	int
==	O
0.0	int
&&	O
x	double
==	O
-	O
rw	int
-	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntX	double
)	O
return	O
;	O
if	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
valid	enum(int,int)
&&	O
boundedLe	O
(	O
yy	int
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
)	O
{	O
rx	double
=	O
x	double
;	O
lx	int
=	O
-	O
x	double
;	O
xalt	double
=	O
intersectLine	O
(	O
yy	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
if	O
(	O
xalt	double
>=	O
-	O
rw	int
-	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntX	double
&&	O
xalt	double
<=	O
rx	double
)	O
rx	double
=	O
xalt	double
;	O
n	array(double)
=	O
ICEIL	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntX	double
+	O
lx	int
)	O
;	O
if	O
(	O
lw	int
>	O
n	array(double)
)	O
{	O
if	O
(	O
mask	int
&	O
2	int
)	O
newFinalSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int)->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
yorgu	int
-	O
y	double
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
+	O
n	array(double)
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
+	O
lw	int
)	O
;	O
if	O
(	O
mask	int
&	O
4	int
)	O
newFinalSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int)->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
yorgl	int
+	O
y	double
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
+	O
n	array(double)
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
+	O
lw	int
)	O
;	O
}	O
n	array(double)
=	O
ICEIL	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntX	double
+	O
rx	double
)	O
;	O
if	O
(	O
n	array(double)
>	O
-	O
rw	int
)	O
{	O
if	O
(	O
mask	int
&	O
1	int
)	O
newFinalSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int)->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
yorgu	int
-	O
y	double
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
-	O
rw	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
+	O
n	array(double)
)	O
;	O
if	O
(	O
mask	int
&	O
8	int
)	O
newFinalSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int)->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
yorgl	int
+	O
y	double
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
-	O
rw	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
+	O
n	array(double)
)	O
;	O
}	O
}	O
arcSpan	*(struct(int,int,int,int))
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
y	double
,	O
ICEIL	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntX	double
-	O
x	double
)	O
,	O
0	int
,	O
ICEIL	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntX	double
+	O
x	double
)	O
,	O
0	int
,	O
def	*(struct(double,double,double,double,double))
,	O
bounds	array(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
mask	int
)	O
;	O
}	O
}	O
static	O
void	O
drawQuadrant	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),*(struct(double,double,double,double,double)),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),int,int,int,*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
int	O
a0	int
,	O
int	O
a1	int
,	O
unsigned	O
int	O
mask	int
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
;	O
static	O
void	O
mirrorSppPoint	(int,*(struct(double,double)))->(void)
(	O
int	O
quadrant	int
,	O
SppPoint	struct(double,double)
*	O
sppPoint	*(struct(double,double))
)	O
;	O
static	O
void	O
drawArc	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),*(struct(int,int,int,int,int,int)),int,int,int,*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(*(struct(long,int,int,int,*`)),int,*(struct(long,int,int,int,*`)),long)))->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
tarc	*(struct(int,int,int,int,int,int))
,	O
unsigned	O
int	O
l	int
,	O
int	O
a0	int
,	O
int	O
a1	int
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miEllipseCache	struct
*	O
ellipseCache	*(struct)
)	O
{	O
struct	O
arc_def	struct(double,double,double,double,double)
def	*(struct(double,double,double,double,double))
;	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
;	O
int	O
startq	int
,	O
endq	int
,	O
curq	int
;	O
int	O
rightq	int
,	O
leftq	int
=	O
0	int
,	O
righta	int
=	O
0	int
,	O
lefta	int
=	O
0	int
;	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
passRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
*	O
passLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
int	O
q0	int
=	O
0	int
,	O
q1	int
=	O
0	int
;	O
unsigned	O
int	O
mask	int
;	O
struct	O
band	struct(int,int,int)
{	O
int	O
a0	int
,	O
a1	int
;	O
unsigned	O
int	O
mask	int
;	O
}	O
band	struct(int,int,int)
[	O
5	int
]	O
,	O
sweep	array(struct(int,int,int))
[	O
20	int
]	O
;	O
int	O
bandno	int
,	O
sweepno	int
;	O
int	O
i	int
,	O
j	int
;	O
bool	enum(int,int)
flipRight	enum(int,int)
=	O
false	int
,	O
flipLeft	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
copyEnd	enum(int,int)
=	O
false	int
;	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
;	O
bool	enum(int,int)
mustFree	*(enum(int,int))
;	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
=	O
miComputeWideEllipse	(int,*(struct(int,int,int,int,int,int)),*(enum(int,int)),*(struct(*(struct(long,int,int,int,*`)),int,*(struct(long,int,int,int,*`)),long)))->(*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))
(	O
l	int
,	O
tarc	*(struct(int,int,int,int,int,int))
,	O
&	O
mustFree	*(enum(int,int))
,	O
ellipseCache	*(struct)
)	O
;	O
if	O
(	O
!	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
return	O
;	O
if	O
(	O
a1	int
<	O
a0	int
)	O
a1	int
+=	O
360	int
*	O
64	int
;	O
startq	int
=	O
a0	int
/	O
(	O
90	int
*	O
64	int
)	O
;	O
if	O
(	O
a0	int
==	O
a1	int
)	O
endq	int
=	O
startq	int
;	O
else	O
endq	int
=	O
(	O
a1	int
-	O
1	int
)	O
/	O
(	O
90	int
*	O
64	int
)	O
;	O
bandno	int
=	O
0	int
;	O
curq	int
=	O
startq	int
;	O
rightq	int
=	O
-	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
switch	O
(	O
curq	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
a0	int
>	O
90	int
*	O
64	int
)	O
q0	int
=	O
0	int
;	O
else	O
q0	int
=	O
a0	int
;	O
if	O
(	O
a1	int
<	O
360	int
*	O
64	int
)	O
q1	int
=	O
IMIN	O
(	O
a1	int
,	O
90	int
*	O
64	int
)	O
;	O
else	O
q1	int
=	O
90	int
*	O
64	int
;	O
if	O
(	O
curq	int
==	O
startq	int
&&	O
a0	int
==	O
q0	int
&&	O
rightq	int
<	O
0	int
)	O
{	O
righta	int
=	O
q0	int
;	O
rightq	int
=	O
curq	int
;	O
}	O
if	O
(	O
curq	int
==	O
endq	int
&&	O
a1	int
==	O
q1	int
)	O
{	O
lefta	int
=	O
q1	int
;	O
leftq	int
=	O
curq	int
;	O
}	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
a1	int
<	O
90	int
*	O
64	int
)	O
q0	int
=	O
0	int
;	O
else	O
q0	int
=	O
180	int
*	O
64	int
-	O
IMIN	O
(	O
a1	int
,	O
180	int
*	O
64	int
)	O
;	O
if	O
(	O
a0	int
>	O
180	int
*	O
64	int
)	O
q1	int
=	O
90	int
*	O
64	int
;	O
else	O
q1	int
=	O
180	int
*	O
64	int
-	O
IMAX	O
(	O
a0	int
,	O
90	int
*	O
64	int
)	O
;	O
if	O
(	O
curq	int
==	O
startq	int
&&	O
180	int
*	O
64	int
-	O
a0	int
==	O
q1	int
)	O
{	O
righta	int
=	O
q1	int
;	O
rightq	int
=	O
curq	int
;	O
}	O
if	O
(	O
curq	int
==	O
endq	int
&&	O
180	int
*	O
64	int
-	O
a1	int
==	O
q0	int
)	O
{	O
lefta	int
=	O
q0	int
;	O
leftq	int
=	O
curq	int
;	O
}	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
a0	int
>	O
270	int
*	O
64	int
)	O
q0	int
=	O
0	int
;	O
else	O
q0	int
=	O
IMAX	O
(	O
a0	int
,	O
180	int
*	O
64	int
)	O
-	O
180	int
*	O
64	int
;	O
if	O
(	O
a1	int
<	O
180	int
*	O
64	int
)	O
q1	int
=	O
90	int
*	O
64	int
;	O
else	O
q1	int
=	O
IMIN	O
(	O
a1	int
,	O
270	int
*	O
64	int
)	O
-	O
180	int
*	O
64	int
;	O
if	O
(	O
curq	int
==	O
startq	int
&&	O
a0	int
-	O
180	int
*	O
64	int
==	O
q0	int
)	O
{	O
righta	int
=	O
q0	int
;	O
rightq	int
=	O
curq	int
;	O
}	O
if	O
(	O
curq	int
==	O
endq	int
&&	O
a1	int
-	O
180	int
*	O
64	int
==	O
q1	int
)	O
{	O
lefta	int
=	O
q1	int
;	O
leftq	int
=	O
curq	int
;	O
}	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
a1	int
<	O
270	int
*	O
64	int
)	O
q0	int
=	O
0	int
;	O
else	O
q0	int
=	O
360	int
*	O
64	int
-	O
IMIN	O
(	O
a1	int
,	O
360	int
*	O
64	int
)	O
;	O
q1	int
=	O
360	int
*	O
64	int
-	O
IMAX	O
(	O
a0	int
,	O
270	int
*	O
64	int
)	O
;	O
if	O
(	O
curq	int
==	O
startq	int
&&	O
360	int
*	O
64	int
-	O
a0	int
==	O
q1	int
)	O
{	O
righta	int
=	O
q1	int
;	O
rightq	int
=	O
curq	int
;	O
}	O
if	O
(	O
curq	int
==	O
endq	int
&&	O
360	int
*	O
64	int
-	O
a1	int
==	O
q0	int
)	O
{	O
lefta	int
=	O
q0	int
;	O
leftq	int
=	O
curq	int
;	O
}	O
break	O
;	O
}	O
band	struct(int,int,int)
[	O
bandno	int
]	O
.	O
a0	int
=	O
q0	int
;	O
band	struct(int,int,int)
[	O
bandno	int
]	O
.	O
a1	int
=	O
q1	int
;	O
band	struct(int,int,int)
[	O
bandno	int
]	O
.	O
mask	int
=	O
1	int
<<	O
curq	int
;	O
bandno	int
++	O
;	O
if	O
(	O
curq	int
==	O
endq	int
)	O
break	O
;	O
curq	int
++	O
;	O
if	O
(	O
curq	int
==	O
4	int
)	O
{	O
a0	int
=	O
0	int
;	O
a1	int
-=	O
360	int
*	O
64	int
;	O
curq	int
=	O
0	int
;	O
endq	int
-=	O
4	int
;	O
}	O
}	O
sweepno	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
q0	int
=	O
90	int
*	O
64	int
;	O
mask	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
bandno	int
;	O
i	int
++	O
)	O
if	O
(	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
a0	int
<=	O
q0	int
)	O
{	O
q0	int
=	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
a0	int
;	O
q1	int
=	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
a1	int
;	O
mask	int
=	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
mask	int
;	O
}	O
if	O
(	O
mask	int
==	O
0	int
)	O
break	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
bandno	int
;	O
i	int
++	O
)	O
if	O
(	O
!	O
(	O
mask	int
&	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
mask	int
)	O
)	O
{	O
if	O
(	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
a0	int
==	O
q0	int
)	O
{	O
if	O
(	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
a1	int
<	O
q1	int
)	O
q1	int
=	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
a1	int
;	O
mask	int
|=	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
mask	int
;	O
}	O
else	O
if	O
(	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
a0	int
<	O
q1	int
)	O
q1	int
=	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
a0	int
;	O
}	O
sweep	array(struct(int,int,int))
[	O
sweepno	int
]	O
.	O
a0	int
=	O
q0	int
;	O
sweep	array(struct(int,int,int))
[	O
sweepno	int
]	O
.	O
a1	int
=	O
q1	int
;	O
sweep	array(struct(int,int,int))
[	O
sweepno	int
]	O
.	O
mask	int
=	O
mask	int
;	O
sweepno	int
++	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
bandno	int
;	O
i	int
++	O
)	O
if	O
(	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
a0	int
==	O
q0	int
)	O
{	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
a0	int
=	O
q1	int
;	O
if	O
(	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
a0	int
==	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
a1	int
)	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
a1	int
=	O
band	struct(int,int,int)
[	O
i	int
]	O
.	O
a0	int
=	O
90	int
*	O
64	int
+	O
1	int
;	O
}	O
}	O
computeAcc	(*(struct(int,int,int,int,int,int)),int,*(struct(double,double,double,double,double)),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(void)
(	O
tarc	*(struct(int,int,int,int,int,int))
,	O
l	int
,	O
&	O
def	*(struct(double,double,double,double,double))
,	O
&	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
sweepno	int
;	O
j	int
++	O
)	O
{	O
mask	int
=	O
sweep	array(struct(int,int,int))
[	O
j	int
]	O
.	O
mask	int
;	O
passRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
passLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
NULL	O
;	O
if	O
(	O
mask	int
&	O
(	O
1	int
<<	O
rightq	int
)	O
)	O
{	O
if	O
(	O
sweep	array(struct(int,int,int))
[	O
j	int
]	O
.	O
a0	int
==	O
righta	int
)	O
passRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
else	O
if	O
(	O
sweep	array(struct(int,int,int))
[	O
j	int
]	O
.	O
a1	int
==	O
righta	int
)	O
{	O
passLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
flipRight	enum(int,int)
=	O
true	int
;	O
}	O
}	O
if	O
(	O
mask	int
&	O
(	O
1	int
<<	O
leftq	int
)	O
)	O
{	O
if	O
(	O
sweep	array(struct(int,int,int))
[	O
j	int
]	O
.	O
a1	int
==	O
lefta	int
)	O
{	O
if	O
(	O
passLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
copyEnd	enum(int,int)
=	O
true	int
;	O
passLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
}	O
else	O
if	O
(	O
sweep	array(struct(int,int,int))
[	O
j	int
]	O
.	O
a0	int
==	O
lefta	int
)	O
{	O
if	O
(	O
passRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
copyEnd	enum(int,int)
=	O
true	int
;	O
passRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
flipLeft	enum(int,int)
=	O
true	int
;	O
}	O
}	O
drawQuadrant	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),*(struct(double,double,double,double,double)),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),int,int,int,*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
&	O
def	*(struct(double,double,double,double,double))
,	O
&	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
sweep	array(struct(int,int,int))
[	O
j	int
]	O
.	O
a0	int
,	O
sweep	array(struct(int,int,int))
[	O
j	int
]	O
.	O
a1	int
,	O
mask	int
,	O
passRight	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
passLeft	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
;	O
}	O
if	O
(	O
copyEnd	enum(int,int)
)	O
*	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
*	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
if	O
(	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
{	O
mirrorSppPoint	(int,*(struct(double,double)))->(void)
(	O
rightq	int
,	O
&	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
)	O
;	O
mirrorSppPoint	(int,*(struct(double,double)))->(void)
(	O
rightq	int
,	O
&	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
center	struct(double,double)
)	O
;	O
mirrorSppPoint	(int,*(struct(double,double)))->(void)
(	O
rightq	int
,	O
&	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
)	O
;	O
if	O
(	O
flipRight	enum(int,int)
)	O
{	O
SppPoint	struct(double,double)
temp	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
temp	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
;	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
=	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
;	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
=	O
temp	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
}	O
}	O
if	O
(	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
{	O
mirrorSppPoint	(int,*(struct(double,double)))->(void)
(	O
leftq	int
,	O
&	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
)	O
;	O
mirrorSppPoint	(int,*(struct(double,double)))->(void)
(	O
leftq	int
,	O
&	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
center	struct(double,double)
)	O
;	O
mirrorSppPoint	(int,*(struct(double,double)))->(void)
(	O
leftq	int
,	O
&	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
)	O
;	O
if	O
(	O
flipLeft	enum(int,int)
)	O
{	O
SppPoint	struct(double,double)
temp	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
temp	*(struct(struct(double,double),struct(double,double),struct(double,double)))
=	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
;	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
=	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
;	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
=	O
temp	*(struct(struct(double,double),struct(double,double),struct(double,double)))
;	O
}	O
}	O
if	O
(	O
mustFree	*(enum(int,int))
)	O
{	O
free	(*(void))->(void)
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
spans	*(struct(int,*(struct(int,int)),*(int)))
)	O
;	O
free	(*(void))->(void)
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
;	O
}	O
}	O
static	O
void	O
drawQuadrant	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),*(struct(double,double,double,double,double)),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),int,int,int,*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))))->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
struct	O
arc_def	struct(double,double,double,double,double)
*	O
def	*(struct(double,double,double,double,double))
,	O
struct	O
accelerators	struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)
*	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
int	O
a0	int
,	O
int	O
a1	int
,	O
unsigned	O
int	O
mask	int
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miArcSpanData	struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int))
*	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
)	O
{	O
struct	O
arc_bound	struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))
bound	struct(double,double)
;	O
double	O
yy	int
,	O
x	double
,	O
xalt	double
;	O
int	O
y	double
,	O
miny	int
,	O
maxy	int
;	O
int	O
n	array(double)
;	O
miArcSpan	struct(int,int,int,int)
*	O
span	*(struct(int,int,int,int))
;	O
def	*(struct(double,double,double,double,double))
->	O
a0	int
=	O
(	O
(	O
double	O
)	O
a0	int
)	O
/	O
64.0	int
;	O
def	*(struct(double,double,double,double,double))
->	O
a1	int
=	O
(	O
(	O
double	O
)	O
a1	int
)	O
/	O
64.0	int
;	O
computeBound	(*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))))->(void)
(	O
def	*(struct(double,double,double,double,double))
,	O
&	O
bound	struct(double,double)
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
yy	int
=	O
bound	struct(double,double)
.	O
inner	struct(double,double)
.	O
min	int
;	O
if	O
(	O
bound	struct(double,double)
.	O
outer	struct(double,double)
.	O
min	int
<	O
yy	int
)	O
yy	int
=	O
bound	struct(double,double)
.	O
outer	struct(double,double)
.	O
min	int
;	O
miny	int
=	O
ICEIL	O
(	O
yy	int
-	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntY	double
)	O
;	O
yy	int
=	O
bound	struct(double,double)
.	O
inner	struct(double,double)
.	O
max	int
;	O
if	O
(	O
bound	struct(double,double)
.	O
outer	struct(double,double)
.	O
max	int
>	O
yy	int
)	O
yy	int
=	O
bound	struct(double,double)
.	O
outer	struct(double,double)
.	O
max	int
;	O
maxy	int
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
yy	int
-	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntY	double
)	O
;	O
y	double
=	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
k	int
;	O
span	*(struct(int,int,int,int))
=	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
spans	*(struct(int,*(struct(int,int)),*(int)))
;	O
if	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
top	enum(int,int)
)	O
{	O
if	O
(	O
a1	int
==	O
90	int
*	O
64	int
&&	O
(	O
mask	int
&	O
1	int
)	O
)	O
newFinalSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int)->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
yorgu	int
-	O
y	double
-	O
1	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
xorg	int
+	O
1	int
)	O
;	O
span	*(struct(int,int,int,int))
++	O
;	O
}	O
for	O
(	O
n	array(double)
=	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count1	int
;	O
--	O
n	array(double)
>=	O
0	int
;	O
)	O
{	O
if	O
(	O
y	double
<	O
miny	int
)	O
return	O
;	O
if	O
(	O
y	double
<=	O
maxy	int
)	O
{	O
arcSpan	*(struct(int,int,int,int))
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
y	double
,	O
span	*(struct(int,int,int,int))
->	O
lx	int
,	O
-	O
span	*(struct(int,int,int,int))
->	O
lx	int
,	O
0	int
,	O
span	*(struct(int,int,int,int))
->	O
lx	int
+	O
span	*(struct(int,int,int,int))
->	O
lw	int
,	O
def	*(struct(double,double,double,double,double))
,	O
&	O
bound	struct(double,double)
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
mask	int
)	O
;	O
if	O
(	O
span	*(struct(int,int,int,int))
->	O
rw	int
+	O
span	*(struct(int,int,int,int))
->	O
rx	double
)	O
tailSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),int)->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
y	double
,	O
-	O
span	*(struct(int,int,int,int))
->	O
rw	int
,	O
-	O
span	*(struct(int,int,int,int))
->	O
rx	double
,	O
def	*(struct(double,double,double,double,double))
,	O
&	O
bound	struct(double,double)
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
mask	int
)	O
;	O
}	O
y	double
--	O
;	O
span	*(struct(int,int,int,int))
++	O
;	O
}	O
if	O
(	O
y	double
<	O
miny	int
)	O
return	O
;	O
if	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
hole	enum(int,int)
)	O
{	O
if	O
(	O
y	double
<=	O
maxy	int
)	O
arcSpan	*(struct(int,int,int,int))
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
y	double
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
def	*(struct(double,double,double,double,double))
,	O
&	O
bound	struct(double,double)
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
mask	int
&	O
0xc	int
)	O
;	O
}	O
for	O
(	O
n	array(double)
=	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
count2	int
;	O
--	O
n	array(double)
>=	O
0	int
;	O
)	O
{	O
if	O
(	O
y	double
<	O
miny	int
)	O
return	O
;	O
if	O
(	O
y	double
<=	O
maxy	int
)	O
arcSpan	*(struct(int,int,int,int))
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
y	double
,	O
span	*(struct(int,int,int,int))
->	O
lx	int
,	O
span	*(struct(int,int,int,int))
->	O
lw	int
,	O
span	*(struct(int,int,int,int))
->	O
rx	double
,	O
span	*(struct(int,int,int,int))
->	O
rw	int
,	O
def	*(struct(double,double,double,double,double))
,	O
&	O
bound	struct(double,double)
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
mask	int
)	O
;	O
y	double
--	O
;	O
span	*(struct(int,int,int,int))
++	O
;	O
}	O
if	O
(	O
spdata	*(struct(int,*(struct(int,int,int,int)),enum(int,int),int,int,enum(int,int),enum(int,int)))
->	O
bot	enum(int,int)
&&	O
miny	int
<=	O
y	double
&&	O
y	double
<=	O
maxy	int
)	O
{	O
unsigned	O
int	O
m	array(double)
=	O
mask	int
;	O
if	O
(	O
y	double
==	O
miny	int
)	O
m	array(double)
&=	O
0xc	int
;	O
if	O
(	O
span	*(struct(int,int,int,int))
->	O
rw	int
<=	O
0	int
)	O
{	O
arcSpan0	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int,int,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),int)->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
span	*(struct(int,int,int,int))
->	O
lx	int
,	O
-	O
span	*(struct(int,int,int,int))
->	O
lx	int
,	O
0	int
,	O
span	*(struct(int,int,int,int))
->	O
lx	int
+	O
span	*(struct(int,int,int,int))
->	O
lw	int
,	O
def	*(struct(double,double,double,double,double))
,	O
&	O
bound	struct(double,double)
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
m	array(double)
)	O
;	O
if	O
(	O
span	*(struct(int,int,int,int))
->	O
rw	int
+	O
span	*(struct(int,int,int,int))
->	O
rx	double
)	O
tailSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),int)->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
y	double
,	O
-	O
span	*(struct(int,int,int,int))
->	O
rw	int
,	O
-	O
span	*(struct(int,int,int,int))
->	O
rx	double
,	O
def	*(struct(double,double,double,double,double))
,	O
&	O
bound	struct(double,double)
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
m	array(double)
)	O
;	O
}	O
else	O
arcSpan0	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int,int,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)),int)->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
span	*(struct(int,int,int,int))
->	O
lx	int
,	O
span	*(struct(int,int,int,int))
->	O
lw	int
,	O
span	*(struct(int,int,int,int))
->	O
rx	double
,	O
span	*(struct(int,int,int,int))
->	O
rw	int
,	O
def	*(struct(double,double,double,double,double))
,	O
&	O
bound	struct(double,double)
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
m	array(double)
)	O
;	O
y	double
--	O
;	O
}	O
while	O
(	O
y	double
>=	O
miny	int
)	O
{	O
yy	int
=	O
y	double
+	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntY	double
;	O
if	O
(	O
def	*(struct(double,double,double,double,double))
->	O
w	double
==	O
def	*(struct(double,double,double,double,double))
->	O
h	double
)	O
{	O
xalt	double
=	O
def	*(struct(double,double,double,double,double))
->	O
w	double
-	O
def	*(struct(double,double,double,double,double))
->	O
l	int
;	O
x	double
=	O
-	O
sqrt	(double)->(double)
(	O
xalt	double
*	O
xalt	double
-	O
yy	int
*	O
yy	int
)	O
;	O
}	O
else	O
{	O
x	double
=	O
tailX	(double,*(struct(double,double,double,double,double)),*(struct(struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(double,double),struct(int,int),struct(int,int))),*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int)))->(double)
(	O
yy	int
,	O
def	*(struct(double,double,double,double,double))
,	O
&	O
bound	struct(double,double)
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
)	O
;	O
if	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
valid	enum(int,int)
&&	O
boundedLe	O
(	O
yy	int
,	O
bound	struct(double,double)
.	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
)	O
{	O
xalt	double
=	O
intersectLine	O
(	O
yy	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
if	O
(	O
xalt	double
<	O
x	double
)	O
x	double
=	O
xalt	double
;	O
}	O
if	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
.	O
valid	enum(int,int)
&&	O
boundedLe	O
(	O
yy	int
,	O
bound	struct(double,double)
.	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
)	O
{	O
xalt	double
=	O
intersectLine	O
(	O
yy	int
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
if	O
(	O
xalt	double
<	O
x	double
)	O
x	double
=	O
xalt	double
;	O
}	O
}	O
arcSpan	*(struct(int,int,int,int))
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
y	double
,	O
ICEIL	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntX	double
-	O
x	double
)	O
,	O
0	int
,	O
ICEIL	O
(	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
->	O
fromIntX	double
+	O
x	double
)	O
,	O
0	int
,	O
def	*(struct(double,double,double,double,double))
,	O
&	O
bound	struct(double,double)
,	O
acc	*(struct(double,double,double,double,double,double,double,double,double,double,struct(double,double,enum(int,int)),struct(double,double,enum(int,int)),int,int,int))
,	O
mask	int
)	O
;	O
y	double
--	O
;	O
}	O
}	O
static	O
void	O
mirrorSppPoint	(int,*(struct(double,double)))->(void)
(	O
int	O
quadrant	int
,	O
SppPoint	struct(double,double)
*	O
sppPoint	*(struct(double,double))
)	O
{	O
switch	O
(	O
quadrant	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
1	int
:	O
sppPoint	*(struct(double,double))
->	O
x	double
=	O
-	O
sppPoint	*(struct(double,double))
->	O
x	double
;	O
break	O
;	O
case	O
2	int
:	O
sppPoint	*(struct(double,double))
->	O
x	double
=	O
-	O
sppPoint	*(struct(double,double))
->	O
x	double
;	O
sppPoint	*(struct(double,double))
->	O
y	double
=	O
-	O
sppPoint	*(struct(double,double))
->	O
y	double
;	O
break	O
;	O
case	O
3	int
:	O
sppPoint	*(struct(double,double))
->	O
y	double
=	O
-	O
sppPoint	*(struct(double,double))
->	O
y	double
;	O
break	O
;	O
}	O
sppPoint	*(struct(double,double))
->	O
y	double
=	O
-	O
sppPoint	*(struct(double,double))
->	O
y	double
;	O
}	O
static	O
void	O
drawZeroArc	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),*(struct(int,int,int,int,int,int)),int,*(struct(struct(double,double),struct(double,double),struct(double,double))),*(struct(struct(double,double),struct(double,double),struct(double,double))))->(void)
(	O
miAccumSpans	struct(*(*(struct(int,int,*(struct`)))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)))),*(struct(int,int,*(struct(int,int,*`)))))
*	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
tarc	*(struct(int,int,int,int,int,int))
,	O
unsigned	O
int	O
lw	int
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
,	O
miArcFace	struct(struct(double,double),struct(double,double),struct(double,double))
*	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
{	O
double	O
x0	double
=	O
0.0	int
,	O
y0	(double)->(double)
=	O
0.0	int
,	O
x1	double
=	O
0.0	int
,	O
y1	(double)->(double)
=	O
0.0	int
;	O
double	O
w	double
,	O
h	double
,	O
x	double
,	O
y	double
;	O
double	O
xmax	double
,	O
ymax	double
,	O
xmin	double
,	O
ymin	double
;	O
int	O
a0	int
,	O
a1	int
;	O
double	O
a	double
,	O
startAngle	int
,	O
endAngle	int
;	O
double	O
l	int
,	O
lx	int
,	O
ly	double
;	O
l	int
=	O
0.5	int
*	O
lw	int
;	O
a0	int
=	O
tarc	*(struct(int,int,int,int,int,int))
->	O
angle1	int
;	O
a1	int
=	O
tarc	*(struct(int,int,int,int,int,int))
->	O
angle2	int
;	O
if	O
(	O
a1	int
>	O
FULLCIRCLE	O
)	O
a1	int
=	O
FULLCIRCLE	O
;	O
else	O
if	O
(	O
a1	int
<	O
-	O
FULLCIRCLE	O
)	O
a1	int
=	O
-	O
FULLCIRCLE	O
;	O
w	double
=	O
0.5	int
*	O
tarc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
;	O
h	double
=	O
0.5	int
*	O
tarc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
startAngle	int
=	O
-	O
(	O
(	O
double	O
)	O
a0	int
/	O
64.0	int
)	O
;	O
endAngle	int
=	O
-	O
(	O
(	O
double	O
)	O
(	O
a0	int
+	O
a1	int
)	O
/	O
64.0	int
)	O
;	O
xmax	double
=	O
-	O
w	double
;	O
xmin	double
=	O
w	double
;	O
ymax	double
=	O
-	O
h	double
;	O
ymin	double
=	O
h	double
;	O
a	double
=	O
startAngle	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
x	double
=	O
w	double
*	O
miDcos	(double)->(double)
(	O
a	double
)	O
;	O
y	double
=	O
h	double
*	O
miDsin	(double)->(double)
(	O
a	double
)	O
;	O
if	O
(	O
a	double
==	O
startAngle	int
)	O
{	O
x0	double
=	O
x	double
;	O
y0	(double)->(double)
=	O
y	double
;	O
}	O
if	O
(	O
a	double
==	O
endAngle	int
)	O
{	O
x1	double
=	O
x	double
;	O
y1	(double)->(double)
=	O
y	double
;	O
}	O
if	O
(	O
x	double
>	O
xmax	double
)	O
xmax	double
=	O
x	double
;	O
if	O
(	O
x	double
<	O
xmin	double
)	O
xmin	double
=	O
x	double
;	O
if	O
(	O
y	double
>	O
ymax	double
)	O
ymax	double
=	O
y	double
;	O
if	O
(	O
y	double
<	O
ymin	double
)	O
ymin	double
=	O
y	double
;	O
if	O
(	O
a	double
==	O
endAngle	int
)	O
break	O
;	O
if	O
(	O
a1	int
<	O
0	int
)	O
{	O
if	O
(	O
floor	(double)->(double)
(	O
a	double
/	O
90.0	int
)	O
==	O
floor	(double)->(double)
(	O
endAngle	int
/	O
90.0	int
)	O
)	O
a	double
=	O
endAngle	int
;	O
else	O
a	double
=	O
90	int
*	O
(	O
floor	(double)->(double)
(	O
a	double
/	O
90.0	int
)	O
+	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ceil	(double)->(double)
(	O
a	double
/	O
90.0	int
)	O
==	O
ceil	(double)->(double)
(	O
endAngle	int
/	O
90.0	int
)	O
)	O
a	double
=	O
endAngle	int
;	O
else	O
a	double
=	O
90	int
*	O
(	O
ceil	(double)->(double)
(	O
a	double
/	O
90.0	int
)	O
-	O
1	int
)	O
;	O
}	O
}	O
lx	int
=	O
ly	double
=	O
l	int
;	O
if	O
(	O
(	O
x1	double
-	O
x0	double
)	O
+	O
(	O
y1	(double)->(double)
-	O
y0	(double)->(double)
)	O
<	O
0	int
)	O
lx	int
=	O
ly	double
=	O
-	O
l	int
;	O
if	O
(	O
h	double
)	O
ly	double
=	O
0.0	int
;	O
else	O
lx	int
=	O
0.0	int
;	O
if	O
(	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
{	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
center	struct(double,double)
.	O
x	double
=	O
x0	double
;	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
center	struct(double,double)
.	O
y	double
=	O
y0	(double)->(double)
;	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
.	O
x	double
=	O
x0	double
-	O
lx	int
;	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
.	O
y	double
=	O
y0	(double)->(double)
-	O
ly	double
;	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
.	O
x	double
=	O
x0	double
+	O
lx	int
;	O
right	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
.	O
y	double
=	O
y0	(double)->(double)
+	O
ly	double
;	O
}	O
if	O
(	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
)	O
{	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
center	struct(double,double)
.	O
x	double
=	O
x1	double
;	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
center	struct(double,double)
.	O
y	double
=	O
y1	(double)->(double)
;	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
.	O
x	double
=	O
x1	double
+	O
lx	int
;	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
clock	()->(long)
.	O
y	double
=	O
y1	(double)->(double)
+	O
ly	double
;	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
.	O
x	double
=	O
x1	double
-	O
lx	int
;	O
left	*(struct(struct(double,double),struct(double,double),struct(double,double)))
->	O
counterClock	struct(double,double)
.	O
y	double
=	O
y1	(double)->(double)
-	O
ly	double
;	O
}	O
x0	double
=	O
xmin	double
;	O
x1	double
=	O
xmax	double
;	O
y0	(double)->(double)
=	O
ymin	double
;	O
y1	(double)->(double)
=	O
ymax	double
;	O
if	O
(	O
ymin	double
!=	O
y1	(double)->(double)
)	O
{	O
xmin	double
=	O
-	O
l	int
;	O
xmax	double
=	O
l	int
;	O
}	O
else	O
{	O
ymin	double
=	O
-	O
l	int
;	O
ymax	double
=	O
l	int
;	O
}	O
if	O
(	O
xmax	double
!=	O
xmin	double
&&	O
ymax	double
!=	O
ymin	double
)	O
{	O
int	O
minx	int
,	O
maxx	int
,	O
miny	int
,	O
maxy	int
;	O
int	O
xorg	int
,	O
yorg	int
,	O
width	array(short)
,	O
height	int
;	O
minx	int
=	O
ICEIL	O
(	O
xmin	double
+	O
w	double
)	O
+	O
tarc	*(struct(int,int,int,int,int,int))
->	O
x	double
;	O
maxx	int
=	O
ICEIL	O
(	O
xmax	double
+	O
w	double
)	O
+	O
tarc	*(struct(int,int,int,int,int,int))
->	O
x	double
;	O
miny	int
=	O
ICEIL	O
(	O
ymin	double
+	O
h	double
)	O
+	O
tarc	*(struct(int,int,int,int,int,int))
->	O
y	double
;	O
maxy	int
=	O
ICEIL	O
(	O
ymax	double
+	O
h	double
)	O
+	O
tarc	*(struct(int,int,int,int,int,int))
->	O
y	double
;	O
xorg	int
=	O
minx	int
;	O
yorg	int
=	O
miny	int
;	O
width	array(short)
=	O
maxx	int
-	O
minx	int
;	O
height	int
=	O
maxy	int
-	O
miny	int
;	O
while	O
(	O
height	int
--	O
)	O
newFinalSpan	(*(struct(*(*(struct`)),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*`)),*(struct(int,int,*`)))),int,int,int)->(void)
(	O
accumSpans	*(struct(*(*(struct(int,int,*`))),int,int,int,int,*(struct(array(struct(int,int,*(struct(int,int,*(struct(int,int,*`)))))),*(struct`))),*(struct(int,int,*(struct`)))))
,	O
yorg	int
,	O
xorg	int
,	O
xorg	int
+	O
width	array(short)
)	O
;	O
}	O
}	O
