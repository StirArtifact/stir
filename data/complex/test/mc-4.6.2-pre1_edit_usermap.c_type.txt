typedef	O
struct	O
NameMap	struct(*(char),int)
{	O
const	O
char	O
*	O
name	*(char)
;	O
int	O
val	array(int)
;	O
}	O
name_map_t	struct(*(char),int)
;	O
typedef	O
struct	O
Config	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
{	O
time_t	long
mtime	long
;	O
GArray	struct
*	O
keymap	*(struct(*(struct(*(struct`),union(*`,*`,int,*`),char,array(char))),union(*(char),*(()->(int)),int,*(struct(*`,*`,char))),char,array(char)))
;	O
GArray	struct
*	O
ext_keymap	*(struct(*(char),int))
;	O
gchar	char
*	O
labels	array(*(char))
[	O
10	int
]	O
;	O
}	O
config_t	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
;	O
typedef	O
struct	O
Command	struct(*(char),*((*(struct(long,*(struct`),*(struct`),array(*(char)))),int,array(*(char)))->(int)))
{	O
const	O
char	O
*	O
name	*(char)
;	O
int	O
(	O
*	O
handler	*((*(struct(long,*(struct`),*(struct`),array(*(char)))),int,array(*(char)))->(int))
)	O
(	O
config_t	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
*	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
,	O
int	O
argc	*(int)
,	O
char	O
*	O
argv	*(*(*(char)))
[	O
]	O
)	O
;	O
}	O
command_t	struct(*(char),*((*(struct(long,*`,*`,array(*(char)))),int,array(*(char)))->(int)))
;	O
static	O
char	O
error_msg	array(char)
[	O
200	int
]	O
=	O
"Nobody see this"	*(char)
;	O
static	O
const	O
name_map_t	struct(*(char),int)
key_names	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"backspace"	*(char)
,	O
KEY_BACKSPACE	int
}	O
,	O
{	O
"end"	*(char)
,	O
KEY_END	int
}	O
,	O
{	O
"up"	*(char)
,	O
KEY_UP	int
}	O
,	O
{	O
"down"	*(char)
,	O
KEY_DOWN	int
}	O
,	O
{	O
"left"	*(char)
,	O
KEY_LEFT	int
}	O
,	O
{	O
"right"	*(char)
,	O
KEY_RIGHT	int
}	O
,	O
{	O
"home"	*(char)
,	O
KEY_HOME	int
}	O
,	O
{	O
"a1"	*(char)
,	O
KEY_A1	int
}	O
,	O
{	O
"c1"	*(char)
,	O
KEY_C1	int
}	O
,	O
{	O
"npage"	*(char)
,	O
KEY_NPAGE	int
}	O
,	O
{	O
"ppage"	*(char)
,	O
KEY_PPAGE	int
}	O
,	O
{	O
"ic"	*(char)
,	O
KEY_IC	int
}	O
,	O
{	O
"enter"	*(char)
,	O
KEY_ENTER	int
}	O
,	O
{	O
"dc"	*(char)
,	O
KEY_DC	int
}	O
,	O
{	O
"scancel"	*(char)
,	O
KEY_SCANCEL	int
}	O
,	O
{	O
"btab"	*(char)
,	O
KEY_BTAB	int
}	O
,	O
{	O
"f11"	*(char)
,	O
KEY_F	O
(	O
11	int
)	O
}	O
,	O
{	O
"f12"	*(char)
,	O
KEY_F	O
(	O
12	int
)	O
}	O
,	O
{	O
"f13"	*(char)
,	O
KEY_F	O
(	O
13	int
)	O
}	O
,	O
{	O
"f14"	*(char)
,	O
KEY_F	O
(	O
14	int
)	O
}	O
,	O
{	O
"f15"	*(char)
,	O
KEY_F	O
(	O
15	int
)	O
}	O
,	O
{	O
"f16"	*(char)
,	O
KEY_F	O
(	O
16	int
)	O
}	O
,	O
{	O
"f17"	*(char)
,	O
KEY_F	O
(	O
17	int
)	O
}	O
,	O
{	O
"f18"	*(char)
,	O
KEY_F	O
(	O
18	int
)	O
}	O
,	O
{	O
"f19"	*(char)
,	O
KEY_F	O
(	O
19	int
)	O
}	O
,	O
{	O
"f20"	*(char)
,	O
KEY_F	O
(	O
20	int
)	O
}	O
,	O
{	O
"tab"	*(char)
,	O
'\t'	O
}	O
,	O
{	O
"return"	*(char)
,	O
'\n'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
const	O
name_map_t	struct(*(char),int)
command_names	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"No-Command"	*(char)
,	O
CK_Ignore_Key	int
}	O
,	O
{	O
"Ignore-Key"	*(char)
,	O
CK_Ignore_Key	int
}	O
,	O
{	O
"BackSpace"	*(char)
,	O
CK_BackSpace	int
}	O
,	O
{	O
"Delete"	*(char)
,	O
CK_Delete	int
}	O
,	O
{	O
"Enter"	*(char)
,	O
CK_Enter	int
}	O
,	O
{	O
"Page-Up"	*(char)
,	O
CK_Page_Up	int
}	O
,	O
{	O
"Page-Down"	*(char)
,	O
CK_Page_Down	int
}	O
,	O
{	O
"Left"	*(char)
,	O
CK_Left	int
}	O
,	O
{	O
"Right"	*(char)
,	O
CK_Right	int
}	O
,	O
{	O
"Word-Left"	*(char)
,	O
CK_Word_Left	int
}	O
,	O
{	O
"Word-Right"	*(char)
,	O
CK_Word_Right	int
}	O
,	O
{	O
"Up"	*(char)
,	O
CK_Up	int
}	O
,	O
{	O
"Down"	*(char)
,	O
CK_Down	int
}	O
,	O
{	O
"Home"	*(char)
,	O
CK_Home	int
}	O
,	O
{	O
"End"	*(char)
,	O
CK_End	int
}	O
,	O
{	O
"Tab"	*(char)
,	O
CK_Tab	int
}	O
,	O
{	O
"Undo"	*(char)
,	O
CK_Undo	int
}	O
,	O
{	O
"Beginning-Of-Text"	*(char)
,	O
CK_Beginning_Of_Text	int
}	O
,	O
{	O
"End-Of-Text"	*(char)
,	O
CK_End_Of_Text	int
}	O
,	O
{	O
"Scroll-Up"	*(char)
,	O
CK_Scroll_Up	int
}	O
,	O
{	O
"Scroll-Down"	*(char)
,	O
CK_Scroll_Down	int
}	O
,	O
{	O
"Return"	*(char)
,	O
CK_Return	int
}	O
,	O
{	O
"Begin-Page"	*(char)
,	O
CK_Begin_Page	int
}	O
,	O
{	O
"End-Page"	*(char)
,	O
CK_End_Page	int
}	O
,	O
{	O
"Delete-Word-Left"	*(char)
,	O
CK_Delete_Word_Left	int
}	O
,	O
{	O
"Delete-Word-Right"	*(char)
,	O
CK_Delete_Word_Right	int
}	O
,	O
{	O
"Paragraph-Up"	*(char)
,	O
CK_Paragraph_Up	int
}	O
,	O
{	O
"Paragraph-Down"	*(char)
,	O
CK_Paragraph_Down	int
}	O
,	O
{	O
"Save"	*(char)
,	O
CK_Save	int
}	O
,	O
{	O
"Load"	*(char)
,	O
CK_Load	int
}	O
,	O
{	O
"New"	*(char)
,	O
CK_New	int
}	O
,	O
{	O
"Save-as"	*(char)
,	O
CK_Save_As	int
}	O
,	O
{	O
"Mark"	*(char)
,	O
CK_Mark	int
}	O
,	O
{	O
"Copy"	*(char)
,	O
CK_Copy	int
}	O
,	O
{	O
"Move"	*(char)
,	O
CK_Move	int
}	O
,	O
{	O
"Remove"	*(char)
,	O
CK_Remove	int
}	O
,	O
{	O
"Unmark"	*(char)
,	O
CK_Unmark	int
}	O
,	O
{	O
"Save-Block"	*(char)
,	O
CK_Save_Block	int
}	O
,	O
{	O
"Column-Mark"	*(char)
,	O
CK_Column_Mark	int
}	O
,	O
{	O
"Find"	*(char)
,	O
CK_Find	int
}	O
,	O
{	O
"Find-Again"	*(char)
,	O
CK_Find_Again	int
}	O
,	O
{	O
"Replace"	*(char)
,	O
CK_Replace	int
}	O
,	O
{	O
"Replace-Again"	*(char)
,	O
CK_Replace_Again	int
}	O
,	O
{	O
"Complete-Word"	*(char)
,	O
CK_Complete_Word	int
}	O
,	O
{	O
"Debug-Start"	*(char)
,	O
CK_Debug_Start	int
}	O
,	O
{	O
"Debug-Stop"	*(char)
,	O
CK_Debug_Stop	int
}	O
,	O
{	O
"Debug-Toggle-Break"	*(char)
,	O
CK_Debug_Toggle_Break	int
}	O
,	O
{	O
"Debug-Clear"	*(char)
,	O
CK_Debug_Clear	int
}	O
,	O
{	O
"Debug-Next"	*(char)
,	O
CK_Debug_Next	int
}	O
,	O
{	O
"Debug-Step"	*(char)
,	O
CK_Debug_Step	int
}	O
,	O
{	O
"Debug-Back-Trace"	*(char)
,	O
CK_Debug_Back_Trace	int
}	O
,	O
{	O
"Debug-Continue"	*(char)
,	O
CK_Debug_Continue	int
}	O
,	O
{	O
"Debug-Enter-Command"	*(char)
,	O
CK_Debug_Enter_Command	int
}	O
,	O
{	O
"Debug-Until-Curser"	*(char)
,	O
CK_Debug_Until_Curser	int
}	O
,	O
{	O
"Insert-File"	*(char)
,	O
CK_Insert_File	int
}	O
,	O
{	O
"Exit"	*(char)
,	O
CK_Exit	int
}	O
,	O
{	O
"Toggle-Insert"	*(char)
,	O
CK_Toggle_Insert	int
}	O
,	O
{	O
"Help"	*(char)
,	O
CK_Help	int
}	O
,	O
{	O
"Date"	*(char)
,	O
CK_Date	int
}	O
,	O
{	O
"Refresh"	*(char)
,	O
CK_Refresh	int
}	O
,	O
{	O
"Goto"	*(char)
,	O
CK_Goto	int
}	O
,	O
{	O
"Delete-Line"	*(char)
,	O
CK_Delete_Line	int
}	O
,	O
{	O
"Delete-To-Line-End"	*(char)
,	O
CK_Delete_To_Line_End	int
}	O
,	O
{	O
"Delete-To-Line-Begin"	*(char)
,	O
CK_Delete_To_Line_Begin	int
}	O
,	O
{	O
"Man-Page"	*(char)
,	O
CK_Man_Page	int
}	O
,	O
{	O
"Sort"	*(char)
,	O
CK_Sort	int
}	O
,	O
{	O
"Mail"	*(char)
,	O
CK_Mail	int
}	O
,	O
{	O
"Cancel"	*(char)
,	O
CK_Cancel	int
}	O
,	O
{	O
"Complete"	*(char)
,	O
CK_Complete	int
}	O
,	O
{	O
"Paragraph-Format"	*(char)
,	O
CK_Paragraph_Format	int
}	O
,	O
{	O
"Util"	*(char)
,	O
CK_Util	int
}	O
,	O
{	O
"Type-Load-Python"	*(char)
,	O
CK_Type_Load_Python	int
}	O
,	O
{	O
"Find-File"	*(char)
,	O
CK_Find_File	int
}	O
,	O
{	O
"Ctags"	*(char)
,	O
CK_Ctags	int
}	O
,	O
{	O
"Match-Bracket"	*(char)
,	O
CK_Match_Bracket	int
}	O
,	O
{	O
"Terminal"	*(char)
,	O
CK_Terminal	int
}	O
,	O
{	O
"Terminal-App"	*(char)
,	O
CK_Terminal_App	int
}	O
,	O
{	O
"ExtCmd"	*(char)
,	O
CK_ExtCmd	int
}	O
,	O
{	O
"User-Menu"	*(char)
,	O
CK_User_Menu	int
}	O
,	O
{	O
"Save-Desktop"	*(char)
,	O
CK_Save_Desktop	int
}	O
,	O
{	O
"New-Window"	*(char)
,	O
CK_New_Window	int
}	O
,	O
{	O
"Cycle"	*(char)
,	O
CK_Cycle	int
}	O
,	O
{	O
"Menu"	*(char)
,	O
CK_Menu	int
}	O
,	O
{	O
"Save-And-Quit"	*(char)
,	O
CK_Save_And_Quit	int
}	O
,	O
{	O
"Run-Another"	*(char)
,	O
CK_Run_Another	int
}	O
,	O
{	O
"Check-Save-And-Quit"	*(char)
,	O
CK_Check_Save_And_Quit	int
}	O
,	O
{	O
"Maximize"	*(char)
,	O
CK_Maximize	int
}	O
,	O
{	O
"Begin-Record-Macro"	*(char)
,	O
CK_Begin_Record_Macro	int
}	O
,	O
{	O
"End-Record-Macro"	*(char)
,	O
CK_End_Record_Macro	int
}	O
,	O
{	O
"Delete-Macro"	*(char)
,	O
CK_Delete_Macro	int
}	O
,	O
{	O
"Toggle-Bookmark"	*(char)
,	O
CK_Toggle_Bookmark	int
}	O
,	O
{	O
"Flush-Bookmarks"	*(char)
,	O
CK_Flush_Bookmarks	int
}	O
,	O
{	O
"Next-Bookmark"	*(char)
,	O
CK_Next_Bookmark	int
}	O
,	O
{	O
"Prev-Bookmark"	*(char)
,	O
CK_Prev_Bookmark	int
}	O
,	O
{	O
"Page-Up-Highlight"	*(char)
,	O
CK_Page_Up_Highlight	int
}	O
,	O
{	O
"Page-Down-Highlight"	*(char)
,	O
CK_Page_Down_Highlight	int
}	O
,	O
{	O
"Left-Highlight"	*(char)
,	O
CK_Left_Highlight	int
}	O
,	O
{	O
"Right-Highlight"	*(char)
,	O
CK_Right_Highlight	int
}	O
,	O
{	O
"Word-Left-Highlight"	*(char)
,	O
CK_Word_Left_Highlight	int
}	O
,	O
{	O
"Word-Right-Highlight"	*(char)
,	O
CK_Word_Right_Highlight	int
}	O
,	O
{	O
"Up-Highlight"	*(char)
,	O
CK_Up_Highlight	int
}	O
,	O
{	O
"Down-Highlight"	*(char)
,	O
CK_Down_Highlight	int
}	O
,	O
{	O
"Home-Highlight"	*(char)
,	O
CK_Home_Highlight	int
}	O
,	O
{	O
"End-Highlight"	*(char)
,	O
CK_End_Highlight	int
}	O
,	O
{	O
"Beginning-Of-Text-Highlight"	*(char)
,	O
CK_Beginning_Of_Text_Highlight	int
}	O
,	O
{	O
"End-Of-Text_Highlight"	*(char)
,	O
CK_End_Of_Text_Highlight	int
}	O
,	O
{	O
"Begin-Page-Highlight"	*(char)
,	O
CK_Begin_Page_Highlight	int
}	O
,	O
{	O
"End-Page-Highlight"	*(char)
,	O
CK_End_Page_Highlight	int
}	O
,	O
{	O
"Scroll-Up-Highlight"	*(char)
,	O
CK_Scroll_Up_Highlight	int
}	O
,	O
{	O
"Scroll-Down-Highlight"	*(char)
,	O
CK_Scroll_Down_Highlight	int
}	O
,	O
{	O
"Paragraph-Up-Highlight"	*(char)
,	O
CK_Paragraph_Up_Highlight	int
}	O
,	O
{	O
"Paragraph-Down-Highlight"	*(char)
,	O
CK_Paragraph_Down_Highlight	int
}	O
,	O
{	O
"XStore"	*(char)
,	O
CK_XStore	int
}	O
,	O
{	O
"XCut"	*(char)
,	O
CK_XCut	int
}	O
,	O
{	O
"XPaste"	*(char)
,	O
CK_XPaste	int
}	O
,	O
{	O
"Selection-History"	*(char)
,	O
CK_Selection_History	int
}	O
,	O
{	O
"Shell"	*(char)
,	O
CK_Shell	int
}	O
,	O
{	O
"Select-Codepage"	*(char)
,	O
CK_Select_Codepage	int
}	O
,	O
{	O
"Insert-Literal"	*(char)
,	O
CK_Insert_Literal	int
}	O
,	O
{	O
"Execute-Macro"	*(char)
,	O
CK_Execute_Macro	int
}	O
,	O
{	O
"Begin-or-End-Macro"	*(char)
,	O
CK_Begin_End_Macro	int
}	O
,	O
{	O
"Ext-mode"	*(char)
,	O
CK_Ext_Mode	int
}	O
,	O
{	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
cfg_free_maps	(*(struct(long,*(struct(*`,int)),*(struct(*`,int)),array(*(char)))))->(void)
(	O
config_t	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
*	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
)	O
{	O
int	O
i	array(int)
;	O
if	O
(	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
->	O
keymap	*(struct(*(struct(*(struct`),union(*`,*`,int,*`),char,array(char))),union(*(char),*(()->(int)),int,*(struct(*`,*`,char))),char,array(char)))
)	O
g_array_free	(*(struct(*(char),int)),int)->(*(char))
(	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
->	O
keymap	*(struct(*(struct(*(struct`),union(*`,*`,int,*`),char,array(char))),union(*(char),*(()->(int)),int,*(struct(*`,*`,char))),char,array(char)))
,	O
TRUE	O
)	O
;	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
->	O
keymap	*(struct(*(struct(*(struct`),union(*`,*`,int,*`),char,array(char))),union(*(char),*(()->(int)),int,*(struct(*`,*`,char))),char,array(char)))
=	O
NULL	O
;	O
if	O
(	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
->	O
ext_keymap	*(struct(*(char),int))
)	O
g_array_free	(*(struct(*(char),int)),int)->(*(char))
(	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
->	O
ext_keymap	*(struct(*(char),int))
,	O
TRUE	O
)	O
;	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
->	O
ext_keymap	*(struct(*(char),int))
=	O
NULL	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
10	int
;	O
i	array(int)
++	O
)	O
g_free	(*(void))->(void)
(	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
->	O
labels	array(*(char))
[	O
i	array(int)
]	O
)	O
;	O
}	O
static	O
GPtrArray	struct
*	O
split_line	(*(char))->(*(struct(*(*(void)),int)))
(	O
char	O
*	O
str	*(char)
)	O
{	O
gboolean	int
inside_quote	int
=	O
FALSE	O
;	O
int	O
move	int
=	O
0	int
;	O
GPtrArray	struct
*	O
args	array(struct(int,int,*(void),*(void)))
;	O
args	array(struct(int,int,*(void),*(void)))
=	O
g_ptr_array_new	()->(*(struct(*(*(void)),int)))
(	O
)	O
;	O
while	O
(	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
str	*(char)
)	O
)	O
str	*(char)
++	O
;	O
g_ptr_array_add	(*(struct(*(*(void)),int)),*(void))->(void)
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
str	*(char)
)	O
;	O
for	O
(	O
;	O
;	O
str	*(char)
++	O
)	O
{	O
switch	O
(	O
*	O
str	*(char)
)	O
{	O
case	O
'#'	O
:	O
if	O
(	O
inside_quote	int
)	O
break	O
;	O
case	O
'\n'	O
:	O
case	O
'\r'	O
:	O
case	O
'\0'	O
:	O
if	O
(	O
str	*(char)
==	O
g_ptr_array_index	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
args	array(struct(int,int,*(void),*(void)))
->	O
len	int
-	O
1	int
)	O
)	O
g_ptr_array_remove_index	(*(struct(*(*(void)),int)),int)->(*(void))
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
args	array(struct(int,int,*(void),*(void)))
->	O
len	int
-	O
1	int
)	O
;	O
else	O
*	O
(	O
str	*(char)
-	O
move	int
)	O
=	O
'\0'	O
;	O
return	O
args	array(struct(int,int,*(void),*(void)))
;	O
case	O
'"'	O
:	O
case	O
'\''	O
:	O
inside_quote	int
=	O
!	O
inside_quote	int
;	O
move	int
++	O
;	O
continue	O
;	O
case	O
' '	O
:	O
case	O
'\t'	O
:	O
if	O
(	O
inside_quote	int
)	O
break	O
;	O
*	O
(	O
str	*(char)
++	O
-	O
move	int
)	O
=	O
'\0'	O
;	O
move	int
=	O
0	int
;	O
while	O
(	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
str	*(char)
)	O
)	O
str	*(char)
++	O
;	O
g_ptr_array_add	(*(struct(*(*(void)),int)),*(void))->(void)
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
str	*(char)
--	O
)	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
switch	O
(	O
*	O
(	O
++	O
str	*(char)
)	O
)	O
{	O
case	O
'n'	O
:	O
*	O
str	*(char)
=	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
str	*(char)
=	O
'\r'	O
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
str	*(char)
=	O
'\t'	O
;	O
break	O
;	O
}	O
move	int
++	O
;	O
break	O
;	O
}	O
if	O
(	O
move	int
!=	O
0	int
)	O
*	O
(	O
str	*(char)
-	O
move	int
)	O
=	O
*	O
str	*(char)
;	O
}	O
}	O
static	O
void	O
keymap_add	(*(struct(*(char),int)),int,int)->(void)
(	O
GArray	struct
*	O
keymap	*(struct(*(struct(*(struct`),union(*`,*`,int,*`),char,array(char))),union(*(char),*(()->(int)),int,*(struct(*`,*`,char))),char,array(char)))
,	O
int	O
key	*(void)
,	O
int	O
cmd	*(int)
)	O
{	O
edit_key_map_type	struct(long,long)
new_one	struct(long,long)
,	O
*	O
map	*(struct)
;	O
guint	int
i	array(int)
;	O
map	*(struct)
=	O
&	O
(	O
g_array_index	O
(	O
keymap	*(struct(*(struct(*(struct`),union(*`,*`,int,*`),char,array(char))),union(*(char),*(()->(int)),int,*(struct(*`,*`,char))),char,array(char)))
,	O
edit_key_map_type	struct(long,long)
,	O
0	int
)	O
)	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
keymap	*(struct(*(struct(*(struct`),union(*`,*`,int,*`),char,array(char))),union(*(char),*(()->(int)),int,*(struct(*`,*`,char))),char,array(char)))
->	O
len	int
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
map	*(struct)
[	O
i	array(int)
]	O
.	O
key	*(void)
==	O
key	*(void)
)	O
{	O
map	*(struct)
[	O
i	array(int)
]	O
.	O
command	*(char)
=	O
cmd	*(int)
;	O
return	O
;	O
}	O
}	O
new_one	struct(long,long)
.	O
key	*(void)
=	O
key	*(void)
;	O
new_one	struct(long,long)
.	O
command	*(char)
=	O
cmd	*(int)
;	O
g_array_append_val	O
(	O
keymap	*(struct(*(struct(*(struct`),union(*`,*`,int,*`),char,array(char))),union(*(char),*(()->(int)),int,*(struct(*`,*`,char))),char,array(char)))
,	O
new_one	struct(long,long)
)	O
;	O
}	O
static	O
gboolean	int
cmd_bind	(*(struct(long,*(struct(*`,int)),*(struct(*`,int)),array(*(char)))),int,array(*(char)))->(int)
(	O
config_t	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
*	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
,	O
int	O
argc	*(int)
,	O
char	O
*	O
argv	*(*(*(char)))
[	O
]	O
)	O
{	O
char	O
*	O
keyname	*(char)
,	O
*	O
command	*(char)
;	O
const	O
name_map_t	struct(*(char),int)
*	O
key	*(void)
=	O
key_names	array(struct(*(char),int))
;	O
const	O
name_map_t	struct(*(char),int)
*	O
cmd	*(int)
=	O
command_names	array(struct(*(char),int))
;	O
int	O
mod	int
=	O
0	int
,	O
k	int
=	O
-	O
1	int
,	O
m	int
=	O
0	int
;	O
if	O
(	O
argc	*(int)
!=	O
3	int
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
error_msg	array(char)
,	O
sizeof	O
(	O
error_msg	array(char)
)	O
,	O
_	O
(	O
"bind: Wrong argument number, bind <key> <command>"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
keyname	*(char)
=	O
argv	*(*(*(char)))
[	O
1	int
]	O
;	O
command	*(char)
=	O
argv	*(*(*(char)))
[	O
2	int
]	O
;	O
while	O
(	O
*	O
keyname	*(char)
)	O
{	O
switch	O
(	O
*	O
keyname	*(char)
++	O
)	O
{	O
case	O
'C'	O
:	O
m	int
=	O
KEY_M_CTRL	int
;	O
continue	O
;	O
case	O
'M'	O
:	O
case	O
'A'	O
:	O
m	int
=	O
KEY_M_ALT	int
;	O
continue	O
;	O
case	O
'S'	O
:	O
m	int
=	O
KEY_M_SHIFT	int
;	O
continue	O
;	O
case	O
'-'	O
:	O
if	O
(	O
!	O
m	int
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
error_msg	array(char)
,	O
sizeof	O
(	O
error_msg	array(char)
)	O
,	O
_	O
(	O
"bind: Bad key value `%s'"	*(char)
)	O
,	O
keyname	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
mod	int
|=	O
m	int
;	O
m	int
=	O
0	int
;	O
continue	O
;	O
}	O
keyname	*(char)
--	O
;	O
break	O
;	O
}	O
if	O
(	O
keyname	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
error_msg	array(char)
,	O
sizeof	O
(	O
error_msg	array(char)
)	O
,	O
_	O
(	O
"bind: Ehh...no key?"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
keyname	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
k	int
=	O
keyname	*(char)
[	O
0	int
]	O
;	O
}	O
else	O
{	O
while	O
(	O
key	*(void)
->	O
name	*(char)
&&	O
strcasecmp	(*(char),*(char))->(int)
(	O
key	*(void)
->	O
name	*(char)
,	O
keyname	*(char)
)	O
!=	O
0	int
)	O
key	*(void)
++	O
;	O
}	O
if	O
(	O
k	int
<	O
0	int
&&	O
!	O
key	*(void)
->	O
name	*(char)
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
error_msg	array(char)
,	O
sizeof	O
(	O
error_msg	array(char)
)	O
,	O
_	O
(	O
"bind: Unknown key: `%s'"	*(char)
)	O
,	O
keyname	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
while	O
(	O
cmd	*(int)
->	O
name	*(char)
&&	O
strcasecmp	(*(char),*(char))->(int)
(	O
cmd	*(int)
->	O
name	*(char)
,	O
command	*(char)
)	O
!=	O
0	int
)	O
cmd	*(int)
++	O
;	O
if	O
(	O
!	O
cmd	*(int)
->	O
name	*(char)
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
error_msg	array(char)
,	O
sizeof	O
(	O
error_msg	array(char)
)	O
,	O
_	O
(	O
"bind: Unknown command: `%s'"	*(char)
)	O
,	O
command	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
mod	int
&	O
KEY_M_CTRL	int
)	O
{	O
if	O
(	O
k	int
<	O
256	int
)	O
k	int
=	O
XCTRL	O
(	O
k	int
)	O
;	O
else	O
k	int
|=	O
KEY_M_CTRL	int
;	O
}	O
if	O
(	O
mod	int
&	O
KEY_M_ALT	int
)	O
k	int
|=	O
KEY_M_ALT	int
;	O
if	O
(	O
mod	int
&	O
KEY_M_SHIFT	int
)	O
k	int
|=	O
KEY_M_SHIFT	int
;	O
if	O
(	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
"bind-ext"	*(char)
,	O
argv	*(*(*(char)))
[	O
0	int
]	O
)	O
)	O
keymap_add	(*(struct(*(char),int)),int,int)->(void)
(	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
->	O
ext_keymap	*(struct(*(char),int))
,	O
k	int
,	O
cmd	*(int)
->	O
val	array(int)
)	O
;	O
else	O
keymap_add	(*(struct(*(char),int)),int,int)->(void)
(	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
->	O
keymap	*(struct(*(struct(*(struct`),union(*`,*`,int,*`),char,array(char))),union(*(char),*(()->(int)),int,*(struct(*`,*`,char))),char,array(char)))
,	O
k	int
,	O
cmd	*(int)
->	O
val	array(int)
)	O
;	O
return	O
TRUE	O
;	O
}	O
static	O
gboolean	int
cmd_label	(*(struct(long,*(struct(*`,int)),*(struct(*`,int)),array(*(char)))),int,array(*(char)))->(int)
(	O
config_t	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
*	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
,	O
int	O
argc	*(int)
,	O
char	O
*	O
argv	*(*(*(char)))
[	O
]	O
)	O
{	O
const	O
name_map_t	struct(*(char),int)
*	O
cmd	*(int)
=	O
command_names	array(struct(*(char),int))
;	O
const	O
char	O
*	O
command	*(char)
,	O
*	O
label	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,*(char),int))
;	O
int	O
fn	int
;	O
if	O
(	O
argc	*(int)
!=	O
4	int
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
error_msg	array(char)
,	O
sizeof	O
(	O
error_msg	array(char)
)	O
,	O
_	O
(	O
"%s: Syntax: %s <n> <command> <label>"	*(char)
)	O
,	O
argv	*(*(*(char)))
[	O
0	int
]	O
,	O
argv	*(*(*(char)))
[	O
0	int
]	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
fn	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
argv	*(*(*(char)))
[	O
1	int
]	O
,	O
NULL	O
,	O
0	int
)	O
;	O
command	*(char)
=	O
argv	*(*(*(char)))
[	O
2	int
]	O
;	O
label	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,*(char),int))
=	O
argv	*(*(*(char)))
[	O
3	int
]	O
;	O
while	O
(	O
cmd	*(int)
->	O
name	*(char)
&&	O
strcasecmp	(*(char),*(char))->(int)
(	O
cmd	*(int)
->	O
name	*(char)
,	O
command	*(char)
)	O
!=	O
0	int
)	O
cmd	*(int)
++	O
;	O
if	O
(	O
!	O
cmd	*(int)
->	O
name	*(char)
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
error_msg	array(char)
,	O
sizeof	O
(	O
error_msg	array(char)
)	O
,	O
_	O
(	O
"%s: Unknown command: `%s'"	*(char)
)	O
,	O
argv	*(*(*(char)))
[	O
0	int
]	O
,	O
command	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
fn	int
<	O
1	int
||	O
fn	int
>	O
10	int
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
error_msg	array(char)
,	O
sizeof	O
(	O
error_msg	array(char)
)	O
,	O
_	O
(	O
"%s: fn should be 1-10"	*(char)
)	O
,	O
argv	*(*(*(char)))
[	O
0	int
]	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
keymap_add	(*(struct(*(char),int)),int,int)->(void)
(	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
->	O
keymap	*(struct(*(struct(*(struct`),union(*`,*`,int,*`),char,array(char))),union(*(char),*(()->(int)),int,*(struct(*`,*`,char))),char,array(char)))
,	O
KEY_F	O
(	O
fn	int
)	O
,	O
cmd	*(int)
->	O
val	array(int)
)	O
;	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
->	O
labels	array(*(char))
[	O
fn	int
-	O
1	int
]	O
=	O
g_strdup	(*(char))->(*(char))
(	O
label	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,*(char),int))
)	O
;	O
return	O
TRUE	O
;	O
}	O
static	O
gboolean	int
parse_file	(*(struct(long,*(struct(*`,int)),*(struct(*`,int)),array(*(char)))),*(char),*(struct(*(char),*((*`,int,array(*(char)))->(int)))))->(int)
(	O
config_t	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
*	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
,	O
const	O
char	O
*	O
file	*(char)
,	O
const	O
command_t	struct(*(char),*((*(struct(long,*`,*`,array(*(char)))),int,array(*(char)))->(int)))
*	O
cmd	*(int)
)	O
{	O
char	O
buf	*(char)
[	O
200	int
]	O
;	O
int	O
line	int
=	O
0	int
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
file	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
error_msg	array(char)
,	O
sizeof	O
(	O
error_msg	array(char)
)	O
,	O
_	O
(	O
"%s: fopen(): %s"	*(char)
)	O
,	O
file	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
const	O
command_t	struct(*(char),*((*(struct(long,*`,*`,array(*(char)))),int,array(*(char)))->(int)))
*	O
c	int
=	O
cmd	*(int)
;	O
GPtrArray	struct
*	O
args	array(struct(int,int,*(void),*(void)))
;	O
char	O
*	O
*	O
argv	*(*(*(char)))
;	O
line	int
++	O
;	O
args	array(struct(int,int,*(void),*(void)))
=	O
split_line	(*(char))->(*(struct(*(*(void)),int)))
(	O
buf	*(char)
)	O
;	O
argv	*(*(*(char)))
=	O
(	O
char	O
*	O
*	O
)	O
args	array(struct(int,int,*(void),*(void)))
->	O
pdata	*(*(void))
;	O
if	O
(	O
args	array(struct(int,int,*(void),*(void)))
->	O
len	int
==	O
0	int
)	O
{	O
g_ptr_array_free	(*(struct(*(*(void)),int)),int)->(*(*(void)))
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
TRUE	O
)	O
;	O
continue	O
;	O
}	O
while	O
(	O
c	int
->	O
name	*(char)
!=	O
NULL	O
&&	O
strcasecmp	(*(char),*(char))->(int)
(	O
c	int
->	O
name	*(char)
,	O
argv	*(*(*(char)))
[	O
0	int
]	O
)	O
!=	O
0	int
)	O
c	int
++	O
;	O
if	O
(	O
c	int
->	O
name	*(char)
==	O
NULL	O
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
error_msg	array(char)
,	O
sizeof	O
(	O
error_msg	array(char)
)	O
,	O
_	O
(	O
"%s:%d: unknown command `%s'"	*(char)
)	O
,	O
file	*(char)
,	O
line	int
,	O
argv	*(*(*(char)))
[	O
0	int
]	O
)	O
;	O
g_ptr_array_free	(*(struct(*(*(void)),int)),int)->(*(*(void)))
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
TRUE	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
(	O
c	int
->	O
handler	*((*(struct(long,*(struct`),*(struct`),array(*(char)))),int,array(*(char)))->(int))
(	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
,	O
args	array(struct(int,int,*(void),*(void)))
->	O
len	int
,	O
argv	*(*(*(char)))
)	O
)	O
)	O
{	O
char	O
*	O
ss	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
error_msg	array(char)
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
error_msg	array(char)
,	O
sizeof	O
(	O
error_msg	array(char)
)	O
,	O
_	O
(	O
"%s:%d: %s"	*(char)
)	O
,	O
file	*(char)
,	O
line	int
,	O
ss	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
ss	*(char)
)	O
;	O
g_ptr_array_free	(*(struct(*(*(void)),int)),int)->(*(*(void)))
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
TRUE	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
FALSE	O
;	O
}	O
g_ptr_array_free	(*(struct(*(*(void)),int)),int)->(*(*(void)))
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
TRUE	O
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
TRUE	O
;	O
}	O
static	O
gboolean	int
load_user_keymap	(*(struct(long,*(struct(*`,int)),*(struct(*`,int)),array(*(char)))),*(char))->(int)
(	O
config_t	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
*	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
,	O
const	O
char	O
*	O
file	*(char)
)	O
{	O
const	O
command_t	struct(*(char),*((*(struct(long,*`,*`,array(*(char)))),int,array(*(char)))->(int)))
cmd	*(int)
[	O
]	O
=	O
{	O
{	O
"bind"	*(char)
,	O
cmd_bind	(*(struct(long,*(struct(*`,int)),*(struct(*`,int)),array(*(char)))),int,array(*(char)))->(int)
}	O
,	O
{	O
"bind-ext"	*(char)
,	O
cmd_bind	(*(struct(long,*(struct(*`,int)),*(struct(*`,int)),array(*(char)))),int,array(*(char)))->(int)
}	O
,	O
{	O
"label"	*(char)
,	O
cmd_label	(*(struct(long,*(struct(*`,int)),*(struct(*`,int)),array(*(char)))),int,array(*(char)))->(int)
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
->	O
keymap	*(struct(*(struct(*(struct`),union(*`,*`,int,*`),char,array(char))),union(*(char),*(()->(int)),int,*(struct(*`,*`,char))),char,array(char)))
=	O
g_array_new	(int,int,int)->(*(struct(*(char),int)))
(	O
TRUE	O
,	O
FALSE	O
,	O
sizeof	O
(	O
edit_key_map_type	struct(long,long)
)	O
)	O
;	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
->	O
ext_keymap	*(struct(*(char),int))
=	O
g_array_new	(int,int,int)->(*(struct(*(char),int)))
(	O
TRUE	O
,	O
FALSE	O
,	O
sizeof	O
(	O
edit_key_map_type	struct(long,long)
)	O
)	O
;	O
if	O
(	O
!	O
parse_file	(*(struct(long,*(struct(*`,int)),*(struct(*`,int)),array(*(char)))),*(char),*(struct(*(char),*((*`,int,array(*(char)))->(int)))))->(int)
(	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
,	O
file	*(char)
,	O
cmd	*(int)
)	O
)	O
{	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	O
;	O
}	O
gboolean	int
edit_load_user_map	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
static	O
config_t	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
;	O
config_t	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
new_cfg	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
;	O
char	O
*	O
file	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
s	*(char)
;	O
if	O
(	O
edit_key_emulation	int
!=	O
EDIT_KEY_EMULATION_USER	int
)	O
return	O
TRUE	O
;	O
file	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
home_dir	*(char)
,	O
MC_USERMAP	*(char)
)	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
file	*(char)
,	O
&	O
s	*(char)
)	O
<	O
0	int
)	O
{	O
char	O
*	O
msg	*(char)
=	O
g_strdup_printf	(*(char))->(*(char))
(	O
_	O
(	O
"%s not found!"	*(char)
)	O
,	O
file	*(char)
)	O
;	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	*(char)
)	O
,	O
msg	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
msg	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
file	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
s	*(char)
.	O
st_mtime	O
!=	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
.	O
mtime	long
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
new_cfg	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
,	O
0	int
,	O
sizeof	O
(	O
new_cfg	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
)	O
)	O
;	O
new_cfg	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
.	O
mtime	long
=	O
s	*(char)
.	O
st_mtime	O
;	O
if	O
(	O
!	O
load_user_keymap	(*(struct(long,*(struct(*`,int)),*(struct(*`,int)),array(*(char)))),*(char))->(int)
(	O
&	O
new_cfg	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
,	O
file	*(char)
)	O
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	*(char)
)	O
,	O
error_msg	array(char)
)	O
;	O
cfg_free_maps	(*(struct(long,*(struct(*`,int)),*(struct(*`,int)),array(*(char)))))->(void)
(	O
&	O
new_cfg	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
)	O
;	O
g_free	(*(void))->(void)
(	O
file	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
cfg_free_maps	(*(struct(long,*(struct(*`,int)),*(struct(*`,int)),array(*(char)))))->(void)
(	O
&	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
)	O
;	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
=	O
new_cfg	struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char)))
;	O
}	O
}	O
edit	*(struct)
->	O
user_map	*(struct(long,long))
=	O
(	O
edit_key_map_type	struct(long,long)
*	O
)	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
.	O
keymap	*(struct(*(struct(*(struct`),union(*`,*`,int,*`),char,array(char))),union(*(char),*(()->(int)),int,*(struct(*`,*`,char))),char,array(char)))
->	O
data	*(void)
;	O
edit	*(struct)
->	O
ext_map	*(struct(long,long))
=	O
(	O
edit_key_map_type	struct(long,long)
*	O
)	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
.	O
ext_keymap	*(struct(*(char),int))
->	O
data	*(void)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
edit	*(struct)
->	O
labels	array(*(char))
,	O
cfg	*(struct(long,*(struct(*(char),int)),*(struct(*(char),int)),array(*(char))))
.	O
labels	array(*(char))
,	O
sizeof	O
(	O
edit	*(struct)
->	O
labels	array(*(char))
)	O
)	O
;	O
g_free	(*(void))->(void)
(	O
file	*(char)
)	O
;	O
return	O
TRUE	O
;	O
}	O
