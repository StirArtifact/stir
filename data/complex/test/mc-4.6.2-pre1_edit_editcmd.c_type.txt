struct	O
selection	struct(*(char),int)
{	O
unsigned	O
char	O
*	O
text	*(char)
;	O
int	O
len	int
;	O
}	O
;	O
static	O
int	O
replace_scanf	int
=	O
0	int
;	O
static	O
int	O
replace_regexp	int
=	O
0	int
;	O
static	O
int	O
replace_all	int
=	O
0	int
;	O
static	O
int	O
replace_prompt	int
=	O
1	int
;	O
static	O
int	O
replace_whole	int
=	O
0	int
;	O
static	O
int	O
replace_case	int
=	O
0	int
;	O
static	O
int	O
replace_backwards	int
=	O
0	int
;	O
static	O
int	O
search_create_bookmark	int
=	O
0	int
;	O
int	O
edit_confirm_save	int
=	O
1	int
;	O
static	O
int	O
edit_save_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
;	O
static	O
unsigned	O
char	O
*	O
edit_get_block	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,long,*(int))->(*(char))
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
start	*(int)
,	O
long	O
finish	long
,	O
int	O
*	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
;	O
static	O
inline	O
int	O
my_lower_case	(int)->(int)
(	O
int	O
c	int
)	O
{	O
return	O
tolower	(int)->(int)
(	O
c	int
&	O
0xFF	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
strcasechr	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
int	O
c	int
)	O
{	O
for	O
(	O
c	int
=	O
my_lower_case	(int)->(int)
(	O
c	int
)	O
;	O
my_lower_case	(int)->(int)
(	O
(	O
int	O
)	O
*	O
s	*(char)
)	O
!=	O
c	int
;	O
++	O
s	*(char)
)	O
if	O
(	O
*	O
s	*(char)
==	O
'\0'	O
)	O
return	O
0	int
;	O
return	O
s	*(char)
;	O
}	O
static	O
char	O
*	O
MY_itoa	(int)->(*(char))
(	O
int	O
i	array(int)
)	O
{	O
static	O
char	O
t	long
[	O
14	int
]	O
;	O
char	O
*	O
s	*(char)
=	O
t	long
+	O
13	int
;	O
int	O
j	int
=	O
i	array(int)
;	O
*	O
s	*(char)
--	O
=	O
0	int
;	O
do	O
{	O
*	O
s	*(char)
--	O
=	O
i	array(int)
%	O
10	int
+	O
'0'	O
;	O
}	O
while	O
(	O
(	O
i	array(int)
=	O
i	array(int)
/	O
10	int
)	O
)	O
;	O
if	O
(	O
j	int
<	O
0	int
)	O
*	O
s	*(char)
--	O
=	O
'-'	O
;	O
return	O
++	O
s	*(char)
;	O
}	O
static	O
char	O
*	O
stacked	array(*(char))
[	O
16	int
]	O
;	O
static	O
const	O
char	O
*	O
catstrs	(*(char))->(*(char))
(	O
const	O
char	O
*	O
first	*(char)
,	O
...	O
)	O
{	O
static	O
int	O
i	array(int)
=	O
0	int
;	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
int	O
len	int
;	O
char	O
*	O
data	*(void)
;	O
if	O
(	O
!	O
first	*(char)
)	O
return	O
0	int
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
first	*(char)
)	O
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
first	*(char)
)	O
;	O
while	O
(	O
(	O
data	*(void)
=	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
char	O
*	O
)	O
)	O
!=	O
0	int
)	O
len	int
+=	O
strlen	(*(char))->(long)
(	O
data	*(void)
)	O
;	O
len	int
++	O
;	O
i	array(int)
=	O
(	O
i	array(int)
+	O
1	int
)	O
%	O
16	int
;	O
g_free	(*(void))->(void)
(	O
stacked	array(*(char))
[	O
i	array(int)
]	O
)	O
;	O
stacked	array(*(char))
[	O
i	array(int)
]	O
=	O
g_malloc	(long)->(*(void))
(	O
len	int
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
first	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
stacked	array(*(char))
[	O
i	array(int)
]	O
,	O
first	*(char)
)	O
;	O
while	O
(	O
(	O
data	*(void)
=	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
char	O
*	O
)	O
)	O
!=	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
stacked	array(*(char))
[	O
i	array(int)
]	O
,	O
data	*(void)
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
return	O
stacked	array(*(char))
[	O
i	array(int)
]	O
;	O
}	O
void	O
freestrs	()->(void)
(	O
void	O
)	O
{	O
size_t	long
i	array(int)
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
sizeof	O
(	O
stacked	array(*(char))
)	O
/	O
sizeof	O
(	O
stacked	array(*(char))
[	O
0	int
]	O
)	O
;	O
i	array(int)
++	O
)	O
{	O
g_free	(*(void))->(void)
(	O
stacked	array(*(char))
[	O
i	array(int)
]	O
)	O
;	O
stacked	array(*(char))
[	O
i	array(int)
]	O
=	O
NULL	O
;	O
}	O
}	O
void	O
edit_help_cmd	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
interactive_display	(*(char),*(char))->(void)
(	O
NULL	O
,	O
"[Internal File Editor]"	*(char)
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
}	O
void	O
edit_refresh_cmd	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
{	O
int	O
color	*(int)
;	O
edit_get_syntax_color	(*(struct),long,*(int))->(void)
(	O
edit	*(struct)
,	O
-	O
1	int
,	O
&	O
color	*(int)
)	O
;	O
}	O
touchwin	O
(	O
stdscr	O
)	O
;	O
mc_refresh	()->(void)
(	O
)	O
;	O
doupdate	O
(	O
)	O
;	O
}	O
static	O
int	O
edit_save_file	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
char	O
*	O
p	*(void)
;	O
long	O
filelen	long
=	O
0	int
;	O
char	O
*	O
savename	*(char)
=	O
0	int
;	O
int	O
this_save_mode	int
,	O
fd	int
=	O
-	O
1	int
;	O
if	O
(	O
!	O
filename	*(char)
)	O
return	O
0	int
;	O
if	O
(	O
!	O
*	O
filename	*(char)
)	O
return	O
0	int
;	O
if	O
(	O
*	O
filename	*(char)
!=	O
PATH_SEP	char
&&	O
edit	*(struct)
->	O
dir	*(struct)
)	O
{	O
savename	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
edit	*(struct)
->	O
dir	*(struct)
,	O
filename	*(char)
)	O
;	O
filename	*(char)
=	O
catstrs	(*(char))->(*(char))
(	O
savename	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
g_free	(*(void))->(void)
(	O
savename	*(char)
)	O
;	O
}	O
this_save_mode	int
=	O
option_save_mode	int
;	O
if	O
(	O
this_save_mode	int
!=	O
EDIT_QUICK_SAVE	int
)	O
{	O
if	O
(	O
!	O
vfs_file_is_local	(*(char))->(int)
(	O
filename	*(char)
)	O
||	O
(	O
fd	int
=	O
mc_open	(*(char),int)->(int)
(	O
filename	*(char)
,	O
O_WRONLY	int
|	O
O_BINARY	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
this_save_mode	int
=	O
EDIT_QUICK_SAVE	int
;	O
}	O
if	O
(	O
fd	int
!=	O
-	O
1	int
)	O
mc_close	(int)->(int)
(	O
fd	int
)	O
;	O
}	O
if	O
(	O
this_save_mode	int
==	O
EDIT_QUICK_SAVE	int
&&	O
!	O
edit	*(struct)
->	O
skip_detach_prompt	int
)	O
{	O
int	O
rv	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
rv	int
=	O
mc_stat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
filename	*(char)
,	O
&	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
rv	int
==	O
0	int
&&	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_nlink	long
>	O
1	int
)	O
{	O
rv	int
=	O
edit_query_dialog3	O
(	O
_	O
(	O
"Warning"	*(char)
)	O
,	O
_	O
(	O
" File has hard-links. Detach before saving? "	*(char)
)	O
,	O
_	O
(	O
"&Yes"	*(char)
)	O
,	O
_	O
(	O
"&No"	*(char)
)	O
,	O
_	O
(	O
"&Cancel"	*(char)
)	O
)	O
;	O
switch	O
(	O
rv	int
)	O
{	O
case	O
0	int
:	O
this_save_mode	int
=	O
EDIT_SAFE_SAVE	int
;	O
case	O
1	int
:	O
edit	*(struct)
->	O
skip_detach_prompt	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
rv	int
==	O
0	int
&&	O
edit	*(struct)
->	O
stat1	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
!=	O
0	int
&&	O
edit	*(struct)
->	O
stat1	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
!=	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
)	O
{	O
query_set_sel	(int)->(void)
(	O
1	int
)	O
;	O
rv	int
=	O
edit_query_dialog2	O
(	O
_	O
(	O
"Warning"	*(char)
)	O
,	O
_	O
(	O
"The file has been modified in the meantime. Save anyway?"	*(char)
)	O
,	O
_	O
(	O
"&Yes"	*(char)
)	O
,	O
_	O
(	O
"&Cancel"	*(char)
)	O
)	O
;	O
if	O
(	O
rv	int
!=	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
this_save_mode	int
!=	O
EDIT_QUICK_SAVE	int
)	O
{	O
char	O
*	O
savedir	*(char)
,	O
*	O
saveprefix	*(char)
;	O
const	O
char	O
*	O
slashpos	*(char)
;	O
slashpos	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
filename	*(char)
,	O
PATH_SEP	char
)	O
;	O
if	O
(	O
slashpos	*(char)
)	O
{	O
savedir	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
savedir	*(char)
[	O
slashpos	*(char)
-	O
filename	*(char)
+	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
savedir	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
"."	*(char)
)	O
;	O
saveprefix	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
savedir	*(char)
,	O
"cooledit"	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
savedir	*(char)
)	O
;	O
fd	int
=	O
mc_mkstemps	(*(*(char)),*(char),*(char))->(int)
(	O
&	O
savename	*(char)
,	O
saveprefix	*(char)
,	O
NULL	O
)	O
;	O
g_free	(*(void))->(void)
(	O
saveprefix	*(char)
)	O
;	O
if	O
(	O
!	O
savename	*(char)
)	O
return	O
0	int
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
}	O
else	O
savename	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
mc_chown	(*(char),int,int)->(int)
(	O
savename	*(char)
,	O
edit	*(struct)
->	O
stat1	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_uid	int
,	O
edit	*(struct)
->	O
stat1	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_gid	int
)	O
;	O
mc_chmod	(*(char),int)->(int)
(	O
savename	*(char)
,	O
edit	*(struct)
->	O
stat1	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
;	O
if	O
(	O
(	O
fd	int
=	O
mc_open	(*(char),int)->(int)
(	O
savename	*(char)
,	O
O_CREAT	int
|	O
O_WRONLY	int
|	O
O_TRUNC	int
|	O
O_BINARY	int
,	O
edit	*(struct)
->	O
stat1	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
==	O
-	O
1	int
)	O
goto	O
error_save	O
;	O
if	O
(	O
(	O
p	*(void)
=	O
edit_get_write_filter	(*(char),*(char))->(*(char))
(	O
savename	*(char)
,	O
filename	*(char)
)	O
)	O
)	O
{	O
FILE	struct
*	O
file	*(char)
;	O
mc_close	(int)->(int)
(	O
fd	int
)	O
;	O
file	*(char)
=	O
(	O
FILE	struct
*	O
)	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
p	*(void)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
file	*(char)
)	O
{	O
filelen	long
=	O
edit_write_stream	(*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
edit	*(struct)
,	O
file	*(char)
)	O
;	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(char)
)	O
;	O
}	O
else	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	*(char)
)	O
,	O
get_sys_error	O
(	O
catstrs	(*(char))->(*(char))
(	O
_	O
(	O
" Cannot open pipe for writing: "	*(char)
)	O
,	O
p	*(void)
,	O
" "	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
)	O
;	O
g_free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
goto	O
error_save	O
;	O
}	O
g_free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
}	O
else	O
{	O
long	O
buf	*(char)
;	O
buf	*(char)
=	O
0	int
;	O
filelen	long
=	O
edit	*(struct)
->	O
last_byte	long
;	O
while	O
(	O
buf	*(char)
<=	O
(	O
edit	*(struct)
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
)	O
-	O
1	int
)	O
{	O
if	O
(	O
mc_write	(int,*(void),int)->(int)
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
buf	*(char)
]	O
,	O
EDIT_BUF_SIZE	O
)	O
!=	O
EDIT_BUF_SIZE	O
)	O
{	O
mc_close	(int)->(int)
(	O
fd	int
)	O
;	O
goto	O
error_save	O
;	O
}	O
buf	*(char)
++	O
;	O
}	O
if	O
(	O
mc_write	(int,*(void),int)->(int)
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
buf	*(char)
]	O
,	O
edit	*(struct)
->	O
curs1	long
&	O
M_EDIT_BUF_SIZE	O
)	O
!=	O
(	O
edit	*(struct)
->	O
curs1	long
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
{	O
filelen	long
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
edit	*(struct)
->	O
curs2	long
)	O
{	O
edit	*(struct)
->	O
curs2	long
--	O
;	O
buf	*(char)
=	O
(	O
edit	*(struct)
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
)	O
;	O
if	O
(	O
mc_write	(int,*(void),int)->(int)
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
buf	*(char)
]	O
+	O
EDIT_BUF_SIZE	O
-	O
(	O
edit	*(struct)
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
-	O
1	int
,	O
1	int
+	O
(	O
edit	*(struct)
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
!=	O
1	int
+	O
(	O
edit	*(struct)
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
{	O
filelen	long
=	O
-	O
1	int
;	O
}	O
else	O
{	O
while	O
(	O
--	O
buf	*(char)
>=	O
0	int
)	O
{	O
if	O
(	O
mc_write	(int,*(void),int)->(int)
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
buf	*(char)
]	O
,	O
EDIT_BUF_SIZE	O
)	O
!=	O
EDIT_BUF_SIZE	O
)	O
{	O
filelen	long
=	O
-	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
edit	*(struct)
->	O
curs2	long
++	O
;	O
}	O
if	O
(	O
mc_close	(int)->(int)
(	O
fd	int
)	O
)	O
goto	O
error_save	O
;	O
if	O
(	O
mc_stat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
savename	*(char)
,	O
&	O
edit	*(struct)
->	O
stat1	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
-	O
1	int
)	O
goto	O
error_save	O
;	O
}	O
if	O
(	O
filelen	long
!=	O
edit	*(struct)
->	O
last_byte	long
)	O
goto	O
error_save	O
;	O
if	O
(	O
this_save_mode	int
==	O
EDIT_DO_BACKUP	int
)	O
{	O
assert	O
(	O
option_backup_ext	*(char)
!=	O
NULL	O
)	O
;	O
if	O
(	O
mc_rename	(*(char),*(char))->(int)
(	O
filename	*(char)
,	O
catstrs	(*(char))->(*(char))
(	O
filename	*(char)
,	O
option_backup_ext	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
==	O
-	O
1	int
)	O
goto	O
error_save	O
;	O
}	O
if	O
(	O
this_save_mode	int
!=	O
EDIT_QUICK_SAVE	int
)	O
if	O
(	O
mc_rename	(*(char),*(char))->(int)
(	O
savename	*(char)
,	O
filename	*(char)
)	O
==	O
-	O
1	int
)	O
goto	O
error_save	O
;	O
g_free	(*(void))->(void)
(	O
savename	*(char)
)	O
;	O
return	O
1	int
;	O
error_save	O
:	O
g_free	(*(void))->(void)
(	O
savename	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
void	O
menu_save_mode_cmd	()->(void)
(	O
void	O
)	O
{	O
static	O
char	O
*	O
str_result	*(*(char))
;	O
static	O
int	O
save_mode_new	int
;	O
static	O
const	O
char	O
*	O
str	*(char)
[	O
]	O
=	O
{	O
N_	O
(	O
"Quick save "	*(char)
)	O
,	O
N_	O
(	O
"Safe save "	*(char)
)	O
,	O
N_	O
(	O
"Do backups -->"	*(char)
)	O
}	O
;	O
static	O
QuickWidget	struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
]	O
=	O
{	O
{	O
quick_button	int
,	O
18	int
,	O
DLG_X	int
,	O
7	int
,	O
DLG_Y	int
,	O
N_	O
(	O
"&Cancel"	*(char)
)	O
,	O
0	int
,	O
B_CANCEL	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
6	int
,	O
DLG_X	int
,	O
7	int
,	O
DLG_Y	int
,	O
N_	O
(	O
"&OK"	*(char)
)	O
,	O
0	int
,	O
B_ENTER	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_input	int
,	O
23	int
,	O
DLG_X	int
,	O
5	int
,	O
DLG_Y	int
,	O
0	int
,	O
9	int
,	O
0	int
,	O
0	int
,	O
&	O
str_result	*(*(char))
,	O
"edit-backup-ext"	*(char)
}	O
,	O
{	O
quick_label	int
,	O
22	int
,	O
DLG_X	int
,	O
4	int
,	O
DLG_Y	int
,	O
N_	O
(	O
"Extension:"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_radio	int
,	O
4	int
,	O
DLG_X	int
,	O
3	int
,	O
DLG_Y	int
,	O
""	*(char)
,	O
3	int
,	O
0	int
,	O
&	O
save_mode_new	int
,	O
(	O
char	O
*	O
*	O
)	O
str	*(char)
,	O
NULL	O
}	O
,	O
NULL_QuickWidget	O
}	O
;	O
static	O
QuickDialog	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
dialog	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
=	O
{	O
DLG_X	int
,	O
DLG_Y	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
N_	O
(	O
" Edit Save Mode "	*(char)
)	O
,	O
"[Edit Save Mode]"	*(char)
,	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
,	O
0	int
}	O
;	O
static	O
int	O
i18n_flag	int
=	O
0	int
;	O
if	O
(	O
!	O
i18n_flag	int
)	O
{	O
size_t	long
i	array(int)
;	O
size_t	long
maxlen	long
=	O
0	int
;	O
int	O
dlg_x	int
;	O
size_t	long
l1	long
;	O
l1	long
=	O
strlen	(*(char))->(long)
(	O
_	O
(	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
0	int
]	O
.	O
text	*(char)
)	O
)	O
+	O
strlen	(*(char))->(long)
(	O
_	O
(	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
1	int
]	O
.	O
text	*(char)
)	O
)	O
+	O
5	int
;	O
maxlen	long
=	O
max	long
(	O
maxlen	long
,	O
l1	long
)	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
3	int
;	O
i	array(int)
++	O
)	O
{	O
str	*(char)
[	O
i	array(int)
]	O
=	O
_	O
(	O
str	*(char)
[	O
i	array(int)
]	O
)	O
;	O
maxlen	long
=	O
max	long
(	O
maxlen	long
,	O
strlen	(*(char))->(long)
(	O
str	*(char)
[	O
i	array(int)
]	O
)	O
+	O
7	int
)	O
;	O
}	O
i18n_flag	int
=	O
1	int
;	O
dlg_x	int
=	O
maxlen	long
+	O
strlen	(*(char))->(long)
(	O
_	O
(	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
3	int
]	O
.	O
text	*(char)
)	O
)	O
+	O
5	int
+	O
1	int
;	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
2	int
]	O
.	O
hotkey_pos	int
=	O
strlen	(*(char))->(long)
(	O
_	O
(	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
3	int
]	O
.	O
text	*(char)
)	O
)	O
;	O
dlg_x	int
=	O
min	long
(	O
COLS	O
,	O
dlg_x	int
)	O
;	O
dialog	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
.	O
xlen	int
=	O
dlg_x	int
;	O
i	array(int)
=	O
(	O
dlg_x	int
-	O
l1	long
)	O
/	O
3	int
;	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
1	int
]	O
.	O
relative_x	int
=	O
i	array(int)
;	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
0	int
]	O
.	O
relative_x	int
=	O
i	array(int)
+	O
strlen	(*(char))->(long)
(	O
_	O
(	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
1	int
]	O
.	O
text	*(char)
)	O
)	O
+	O
i	array(int)
+	O
4	int
;	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
2	int
]	O
.	O
relative_x	int
=	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
3	int
]	O
.	O
relative_x	int
=	O
maxlen	long
+	O
2	int
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
sizeof	O
(	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
)	O
/	O
sizeof	O
(	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
0	int
]	O
)	O
;	O
i	array(int)
++	O
)	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
i	array(int)
]	O
.	O
x_divisions	int
=	O
dlg_x	int
;	O
}	O
assert	O
(	O
option_backup_ext	*(char)
!=	O
NULL	O
)	O
;	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
2	int
]	O
.	O
text	*(char)
=	O
option_backup_ext	*(char)
;	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
4	int
]	O
.	O
value	*(void)
=	O
option_save_mode	int
;	O
if	O
(	O
quick_dialog	(*(struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*`,int,int,*`,*`,*`)),int)))->(int)
(	O
&	O
dialog	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
)	O
!=	O
B_ENTER	int
)	O
return	O
;	O
option_save_mode	int
=	O
save_mode_new	int
;	O
g_free	(*(void))->(void)
(	O
option_backup_ext	*(char)
)	O
;	O
option_backup_ext	*(char)
=	O
str_result	*(*(char))
;	O
str_result	*(*(char))
=	O
NULL	O
;	O
}	O
void	O
edit_set_filename	(*(struct),*(char))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
const	O
char	O
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
g_free	(*(void))->(void)
(	O
edit	*(struct)
->	O
filename	*(char)
)	O
;	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
""	*(char)
;	O
edit	*(struct)
->	O
filename	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
edit	*(struct)
->	O
dir	*(struct)
==	O
NULL	O
&&	O
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
PATH_SEP	char
)	O
edit	*(struct)
->	O
dir	*(struct)
=	O
g_strdup	(*(char))->(*(char))
(	O
vfs_get_current_dir	()->(*(char))
(	O
)	O
)	O
;	O
}	O
int	O
edit_save_as_cmd	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
char	O
*	O
exp	*(char)
;	O
int	O
save_lock	int
=	O
0	int
;	O
int	O
different_filename	int
=	O
0	int
;	O
exp	*(char)
=	O
edit_get_save_file	O
(	O
edit	*(struct)
->	O
filename	*(char)
,	O
_	O
(	O
" Save As "	*(char)
)	O
)	O
;	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
KEY_PRESS	int
+	O
edit	*(struct)
->	O
start_display	long
)	O
;	O
if	O
(	O
exp	*(char)
)	O
{	O
if	O
(	O
!	O
*	O
exp	*(char)
)	O
{	O
g_free	(*(void))->(void)
(	O
exp	*(char)
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
int	O
rv	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
edit	*(struct)
->	O
filename	*(char)
,	O
exp	*(char)
)	O
)	O
{	O
int	O
file	*(char)
;	O
different_filename	int
=	O
1	int
;	O
if	O
(	O
(	O
file	*(char)
=	O
mc_open	(*(char),int)->(int)
(	O
exp	*(char)
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
mc_close	(int)->(int)
(	O
file	*(char)
)	O
;	O
if	O
(	O
edit_query_dialog2	O
(	O
_	O
(	O
"Warning"	*(char)
)	O
,	O
_	O
(	O
" A file already exists with this name. "	*(char)
)	O
,	O
_	O
(	O
"&Overwrite"	*(char)
)	O
,	O
_	O
(	O
"&Cancel"	*(char)
)	O
)	O
)	O
{	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
g_free	(*(void))->(void)
(	O
exp	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
save_lock	int
=	O
edit_lock_file	(*(char))->(int)
(	O
exp	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
edit	*(struct)
->	O
locked	int
&&	O
!	O
edit	*(struct)
->	O
delete_file	int
)	O
save_lock	int
=	O
edit_lock_file	(*(char))->(int)
(	O
exp	*(char)
)	O
;	O
}	O
rv	int
=	O
edit_save_file	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char))->(int)
(	O
edit	*(struct)
,	O
exp	*(char)
)	O
;	O
switch	O
(	O
rv	int
)	O
{	O
case	O
1	int
:	O
if	O
(	O
different_filename	int
)	O
{	O
if	O
(	O
save_lock	int
)	O
edit_unlock_file	(*(char))->(int)
(	O
exp	*(char)
)	O
;	O
if	O
(	O
edit	*(struct)
->	O
locked	int
)	O
edit	*(struct)
->	O
locked	int
=	O
edit_unlock_file	(*(char))->(int)
(	O
edit	*(struct)
->	O
filename	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
edit	*(struct)
->	O
locked	int
||	O
save_lock	int
)	O
edit	*(struct)
->	O
locked	int
=	O
edit_unlock_file	(*(char))->(int)
(	O
edit	*(struct)
->	O
filename	*(char)
)	O
;	O
}	O
edit_set_filename	(*(struct),*(char))->(void)
(	O
edit	*(struct)
,	O
exp	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
exp	*(char)
)	O
;	O
edit	*(struct)
->	O
modified	long
=	O
0	int
;	O
edit	*(struct)
->	O
delete_file	int
=	O
0	int
;	O
if	O
(	O
different_filename	int
)	O
edit_load_syntax	(*(struct),*(*(*(char))),*(char))->(void)
(	O
edit	*(struct)
,	O
NULL	O
,	O
option_syntax_type	*(char)
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
1	int
;	O
default	O
:	O
edit_error_dialog	O
(	O
_	O
(	O
" Save As "	*(char)
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot save file. "	*(char)
)	O
)	O
)	O
;	O
case	O
-	O
1	int
:	O
if	O
(	O
save_lock	int
)	O
edit_unlock_file	(*(char))->(int)
(	O
exp	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
exp	*(char)
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
static	O
cb_ret_t	enum(int,int)
raw_callback	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))
(	O
struct	O
Dlg_head	struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))))))
*	O
h	*(struct)
,	O
dlg_msg_t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int)
msg	*(char)
,	O
int	O
parm	int
)	O
{	O
switch	O
(	O
msg	*(char)
)	O
{	O
case	O
DLG_KEY	int
:	O
h	*(struct)
->	O
running	int
=	O
0	int
;	O
h	*(struct)
->	O
ret_value	int
=	O
parm	int
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_dlg_callback	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))
(	O
h	*(struct)
,	O
msg	*(char)
,	O
parm	int
)	O
;	O
}	O
}	O
int	O
edit_raw_key_query	(*(char),*(char),int)->(int)
(	O
const	O
char	O
*	O
heading	*(char)
,	O
const	O
char	O
*	O
query	*(char)
,	O
int	O
cancel	int
)	O
{	O
int	O
w	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
strlen	(*(char))->(long)
(	O
query	*(char)
)	O
+	O
7	int
;	O
struct	O
Dlg_head	struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))))))
*	O
raw_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
create_dlg	(int,int,int,int,*(int),*((*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(char),*(char),int)->(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))
(	O
0	int
,	O
0	int
,	O
7	int
,	O
w	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
,	O
dialog_colors	array(int)
,	O
raw_callback	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))
,	O
NULL	O
,	O
heading	*(char)
,	O
DLG_CENTER	O
|	O
DLG_TRYUP	O
|	O
DLG_WANT_TAB	O
)	O
;	O
add_widget	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),*(void))->(int)
(	O
raw_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
,	O
input_new	(int,int,int,int,*(char),*(char))->(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))))
(	O
3	int
-	O
cancel	int
,	O
w	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
-	O
5	int
,	O
INPUT_COLOR	O
,	O
2	int
,	O
""	*(char)
,	O
0	int
)	O
)	O
;	O
add_widget	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),*(void))->(int)
(	O
raw_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
,	O
label_new	(int,int,*(char))->(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,*(char),int)))
(	O
3	int
-	O
cancel	int
,	O
2	int
,	O
query	*(char)
)	O
)	O
;	O
if	O
(	O
cancel	int
)	O
add_widget	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),*(void))->(int)
(	O
raw_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
,	O
button_new	(int,int,int,int,*(char),*((int)->(int)))->(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,*(char),int,int,*((int)->(int)))))
(	O
4	int
,	O
w	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
/	O
2	int
-	O
5	int
,	O
B_CANCEL	int
,	O
NORMAL_BUTTON	int
,	O
_	O
(	O
"Cancel"	*(char)
)	O
,	O
0	int
)	O
)	O
;	O
run_dlg	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))->(int)
(	O
raw_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
;	O
w	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
raw_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
ret_value	int
;	O
destroy_dlg	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
raw_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
;	O
if	O
(	O
cancel	int
)	O
{	O
if	O
(	O
w	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
==	O
XCTRL	O
(	O
'g'	O
)	O
||	O
w	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
==	O
XCTRL	O
(	O
'c'	O
)	O
||	O
w	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
==	O
ESC_CHAR	char
||	O
w	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
==	O
B_CANCEL	int
)	O
return	O
0	int
;	O
}	O
return	O
w	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
}	O
static	O
FILE	struct
*	O
edit_open_macro_file	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
const	O
char	O
*	O
r	*(struct)
)	O
{	O
const	O
char	O
*	O
filename	*(char)
;	O
int	O
file	*(char)
;	O
filename	*(char)
=	O
catstrs	(*(char))->(*(char))
(	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
MACRO_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
(	O
file	*(char)
=	O
open	(*(char),int)->(int)
(	O
filename	*(char)
,	O
O_CREAT	int
|	O
O_RDWR	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
|	O
S_IRGRP	O
|	O
S_IROTH	O
)	O
)	O
==	O
-	O
1	int
)	O
return	O
0	int
;	O
close	*((*(void))->(int))
(	O
file	*(char)
)	O
;	O
return	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
r	*(struct)
)	O
;	O
}	O
static	O
int	O
saved_macro	array(int)
[	O
MAX_MACROS	int
+	O
1	int
]	O
;	O
static	O
int	O
saved_macros_loaded	int
=	O
0	int
;	O
static	O
int	O
macro_exists	(int)->(int)
(	O
int	O
k	int
)	O
{	O
int	O
i	array(int)
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
MAX_MACROS	int
&&	O
saved_macro	array(int)
[	O
i	array(int)
]	O
;	O
i	array(int)
++	O
)	O
if	O
(	O
saved_macro	array(int)
[	O
i	array(int)
]	O
==	O
k	int
)	O
return	O
i	array(int)
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
edit_delete_macro	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
k	int
)	O
{	O
struct	O
macro	struct(short,short)
macro	struct(short,short)
[	O
MAX_MACRO_LENGTH	int
]	O
;	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
*	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
;	O
int	O
s	*(char)
,	O
i	array(int)
,	O
n	long
,	O
j	int
=	O
0	int
;	O
(	O
void	O
)	O
edit	*(struct)
;	O
if	O
(	O
saved_macros_loaded	int
)	O
if	O
(	O
(	O
j	int
=	O
macro_exists	(int)->(int)
(	O
k	int
)	O
)	O
<	O
0	int
)	O
return	O
0	int
;	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
catstrs	(*(char))->(*(char))
(	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
TEMP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
!	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Delete macro "	*(char)
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot open temp file "	*(char)
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
edit_open_macro_file	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Delete macro "	*(char)
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot open macro file "	*(char)
)	O
)	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
n	long
=	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
"key '%d 0': "	*(char)
)	O
,	O
&	O
s	*(char)
)	O
;	O
if	O
(	O
!	O
n	long
||	O
n	long
==	O
EOF	O
)	O
break	O
;	O
n	long
=	O
0	int
;	O
while	O
(	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%hd %hd, "	*(char)
,	O
&	O
macro	struct(short,short)
[	O
n	long
]	O
.	O
command	*(char)
,	O
&	O
macro	struct(short,short)
[	O
n	long
]	O
.	O
ch	int
)	O
)	O
n	long
++	O
;	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
";\n"	*(char)
)	O
;	O
if	O
(	O
s	*(char)
!=	O
k	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
,	O
(	O
"key '%d 0': "	*(char)
)	O
,	O
s	*(char)
)	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
n	long
;	O
i	array(int)
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
,	O
"%hd %hd, "	*(char)
,	O
macro	struct(short,short)
[	O
i	array(int)
]	O
.	O
command	*(char)
,	O
macro	struct(short,short)
[	O
i	array(int)
]	O
.	O
ch	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
,	O
";\n"	*(char)
)	O
;	O
}	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
)	O
;	O
if	O
(	O
rename	(*(char),*(char))->(int)
(	O
catstrs	(*(char))->(*(char))
(	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
TEMP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
,	O
catstrs	(*(char))->(*(char))
(	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
MACRO_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Delete macro "	*(char)
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot overwrite macro file "	*(char)
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
saved_macros_loaded	int
)	O
memmove	(*(void),*(void),long)->(*(void))
(	O
saved_macro	array(int)
+	O
j	int
,	O
saved_macro	array(int)
+	O
j	int
+	O
1	int
,	O
sizeof	O
(	O
int	O
)	O
*	O
(	O
MAX_MACROS	int
-	O
j	int
-	O
1	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_save_macro_cmd	(*(struct),array(struct(short,short)),int)->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
struct	O
macro	struct(short,short)
macro	struct(short,short)
[	O
]	O
,	O
int	O
n	long
)	O
{	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
s	*(char)
,	O
i	array(int)
;	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
KEY_PRESS	int
+	O
edit	*(struct)
->	O
start_display	long
)	O
;	O
s	*(char)
=	O
edit_raw_key_query	(*(char),*(char),int)->(int)
(	O
_	O
(	O
" Save macro "	*(char)
)	O
,	O
_	O
(	O
" Press the macro's new hotkey: "	*(char)
)	O
,	O
1	int
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
if	O
(	O
s	*(char)
)	O
{	O
if	O
(	O
edit_delete_macro	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(int)
(	O
edit	*(struct)
,	O
s	*(char)
)	O
)	O
return	O
0	int
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
edit_open_macro_file	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
"a+"	*(char)
)	O
;	O
if	O
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
"key '%d 0': "	*(char)
)	O
,	O
s	*(char)
)	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
n	long
;	O
i	array(int)
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%hd %hd, "	*(char)
,	O
macro	struct(short,short)
[	O
i	array(int)
]	O
.	O
command	*(char)
,	O
macro	struct(short,short)
[	O
i	array(int)
]	O
.	O
ch	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
";\n"	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
saved_macros_loaded	int
)	O
{	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
MAX_MACROS	int
&&	O
saved_macro	array(int)
[	O
i	array(int)
]	O
;	O
i	array(int)
++	O
)	O
;	O
saved_macro	array(int)
[	O
i	array(int)
]	O
=	O
s	*(char)
;	O
}	O
return	O
1	int
;	O
}	O
else	O
edit_error_dialog	O
(	O
_	O
(	O
" Save macro "	*(char)
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot open macro file "	*(char)
)	O
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
edit_delete_macro_cmd	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
command	*(char)
;	O
command	*(char)
=	O
edit_raw_key_query	(*(char),*(char),int)->(int)
(	O
_	O
(	O
" Delete macro "	*(char)
)	O
,	O
_	O
(	O
" Press macro hotkey: "	*(char)
)	O
,	O
1	int
)	O
;	O
if	O
(	O
!	O
command	*(char)
)	O
return	O
;	O
edit_delete_macro	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(int)
(	O
edit	*(struct)
,	O
command	*(char)
)	O
;	O
}	O
int	O
edit_load_macro_cmd	(*(struct),array(struct(short,short)),*(int),int)->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
struct	O
macro	struct(short,short)
macro	struct(short,short)
[	O
]	O
,	O
int	O
*	O
n	long
,	O
int	O
k	int
)	O
{	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
s	*(char)
,	O
i	array(int)
=	O
0	int
,	O
found	int
=	O
0	int
;	O
(	O
void	O
)	O
edit	*(struct)
;	O
if	O
(	O
saved_macros_loaded	int
)	O
if	O
(	O
macro_exists	(int)->(int)
(	O
k	int
)	O
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
edit_open_macro_file	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
"r"	*(char)
)	O
)	O
)	O
{	O
struct	O
macro	struct(short,short)
dummy	array(*(void))
;	O
do	O
{	O
int	O
u	union(struct(long,*(struct),array(long)),array(long))
;	O
u	union(struct(long,*(struct),array(long)),array(long))
=	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
"key '%d 0': "	*(char)
)	O
,	O
&	O
s	*(char)
)	O
;	O
if	O
(	O
!	O
u	union(struct(long,*(struct),array(long)),array(long))
||	O
u	union(struct(long,*(struct),array(long)),array(long))
==	O
EOF	O
)	O
break	O
;	O
if	O
(	O
!	O
saved_macros_loaded	int
)	O
saved_macro	array(int)
[	O
i	array(int)
++	O
]	O
=	O
s	*(char)
;	O
if	O
(	O
!	O
found	int
)	O
{	O
*	O
n	long
=	O
0	int
;	O
while	O
(	O
*	O
n	long
<	O
MAX_MACRO_LENGTH	int
&&	O
2	int
==	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%hd %hd, "	*(char)
,	O
&	O
macro	struct(short,short)
[	O
*	O
n	long
]	O
.	O
command	*(char)
,	O
&	O
macro	struct(short,short)
[	O
*	O
n	long
]	O
.	O
ch	int
)	O
)	O
(	O
*	O
n	long
)	O
++	O
;	O
}	O
else	O
{	O
while	O
(	O
2	int
==	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%hd %hd, "	*(char)
,	O
&	O
dummy	array(*(void))
.	O
command	*(char)
,	O
&	O
dummy	array(*(void))
.	O
ch	int
)	O
)	O
;	O
}	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
";\n"	*(char)
)	O
;	O
if	O
(	O
s	*(char)
==	O
k	int
)	O
found	int
=	O
1	int
;	O
}	O
while	O
(	O
!	O
found	int
||	O
!	O
saved_macros_loaded	int
)	O
;	O
if	O
(	O
!	O
saved_macros_loaded	int
)	O
{	O
saved_macro	array(int)
[	O
i	array(int)
]	O
=	O
0	int
;	O
saved_macros_loaded	int
=	O
1	int
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
found	int
;	O
}	O
else	O
edit_error_dialog	O
(	O
_	O
(	O
" Load macro "	*(char)
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot open macro file "	*(char)
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_save_confirm_cmd	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
const	O
char	O
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
if	O
(	O
edit_confirm_save	int
)	O
{	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
catstrs	(*(char))->(*(char))
(	O
_	O
(	O
" Confirm save file? : "	*(char)
)	O
,	O
edit	*(struct)
->	O
filename	*(char)
,	O
" "	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
edit_query_dialog2	O
(	O
_	O
(	O
" Save file "	*(char)
)	O
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"&Save"	*(char)
)	O
,	O
_	O
(	O
"&Cancel"	*(char)
)	O
)	O
)	O
return	O
0	int
;	O
}	O
return	O
edit_save_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
;	O
}	O
static	O
int	O
edit_save_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
res	int
,	O
save_lock	int
=	O
0	int
;	O
if	O
(	O
!	O
edit	*(struct)
->	O
locked	int
&&	O
!	O
edit	*(struct)
->	O
delete_file	int
)	O
save_lock	int
=	O
edit_lock_file	(*(char))->(int)
(	O
edit	*(struct)
->	O
filename	*(char)
)	O
;	O
res	int
=	O
edit_save_file	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char))->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
filename	*(char)
)	O
;	O
if	O
(	O
(	O
res	int
>	O
0	int
&&	O
edit	*(struct)
->	O
locked	int
)	O
||	O
save_lock	int
)	O
edit	*(struct)
->	O
locked	int
=	O
edit_unlock_file	(*(char))->(int)
(	O
edit	*(struct)
->	O
filename	*(char)
)	O
;	O
if	O
(	O
!	O
res	int
)	O
return	O
edit_save_as_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
if	O
(	O
res	int
>	O
0	int
)	O
{	O
edit	*(struct)
->	O
delete_file	int
=	O
0	int
;	O
edit	*(struct)
->	O
modified	long
=	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
int	O
edit_new_cmd	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
modified	long
)	O
{	O
if	O
(	O
edit_query_dialog2	O
(	O
_	O
(	O
"Warning"	*(char)
)	O
,	O
_	O
(	O
" Current text was modified without a file save. \n Continue discards these changes. "	*(char)
)	O
,	O
_	O
(	O
"C&ontinue"	*(char)
)	O
,	O
_	O
(	O
"&Cancel"	*(char)
)	O
)	O
)	O
{	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
}	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
edit_renew	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
}	O
static	O
int	O
edit_load_file_from_filename	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
char	O
*	O
exp	*(char)
)	O
{	O
int	O
prev_locked	int
=	O
edit	*(struct)
->	O
locked	int
;	O
char	O
*	O
prev_filename	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
edit	*(struct)
->	O
filename	*(char)
)	O
;	O
if	O
(	O
!	O
edit_reload	(*(struct),*(char))->(int)
(	O
edit	*(struct)
,	O
exp	*(char)
)	O
)	O
{	O
g_free	(*(void))->(void)
(	O
prev_filename	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
prev_locked	int
)	O
edit_unlock_file	(*(char))->(int)
(	O
prev_filename	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
prev_filename	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_load_cmd	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
char	O
*	O
exp	*(char)
;	O
if	O
(	O
edit	*(struct)
->	O
modified	long
)	O
{	O
if	O
(	O
edit_query_dialog2	O
(	O
_	O
(	O
"Warning"	*(char)
)	O
,	O
_	O
(	O
" Current text was modified without a file save. \n"	*(char)
" Continue discards these changes. "	*(char)
)	O
,	O
_	O
(	O
"C&ontinue"	*(char)
)	O
,	O
_	O
(	O
"&Cancel"	*(char)
)	O
)	O
)	O
{	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
}	O
exp	*(char)
=	O
edit_get_load_file	O
(	O
edit	*(struct)
->	O
filename	*(char)
,	O
_	O
(	O
" Load "	*(char)
)	O
)	O
;	O
if	O
(	O
exp	*(char)
)	O
{	O
if	O
(	O
*	O
exp	*(char)
)	O
edit_load_file_from_filename	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char))->(int)
(	O
edit	*(struct)
,	O
exp	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
exp	*(char)
)	O
;	O
}	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
int	O
eval_marks	(*(struct),*(long),*(long))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
*	O
start_mark	*(long)
,	O
long	O
*	O
end_mark	*(long)
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
mark1	long
!=	O
edit	*(struct)
->	O
mark2	long
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
mark2	long
>=	O
0	int
)	O
{	O
*	O
start_mark	*(long)
=	O
min	long
(	O
edit	*(struct)
->	O
mark1	long
,	O
edit	*(struct)
->	O
mark2	long
)	O
;	O
*	O
end_mark	*(long)
=	O
max	long
(	O
edit	*(struct)
->	O
mark1	long
,	O
edit	*(struct)
->	O
mark2	long
)	O
;	O
}	O
else	O
{	O
*	O
start_mark	*(long)
=	O
min	long
(	O
edit	*(struct)
->	O
mark1	long
,	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
*	O
end_mark	*(long)
=	O
max	long
(	O
edit	*(struct)
->	O
mark1	long
,	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit	*(struct)
->	O
column2	int
=	O
edit	*(struct)
->	O
curs_col	long
;	O
}	O
return	O
0	int
;	O
}	O
else	O
{	O
*	O
start_mark	*(long)
=	O
*	O
end_mark	*(long)
=	O
0	int
;	O
edit	*(struct)
->	O
column2	int
=	O
edit	*(struct)
->	O
column1	int
=	O
0	int
;	O
return	O
1	int
;	O
}	O
}	O
static	O
void	O
edit_insert_column_of_text	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char),int,int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
unsigned	O
char	O
*	O
data	*(void)
,	O
int	O
size	long
,	O
int	O
width	int
)	O
{	O
long	O
cursor	long
;	O
int	O
i	array(int)
,	O
col	int
;	O
cursor	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
col	int
=	O
edit_get_col	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
size	long
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
data	*(void)
[	O
i	array(int)
]	O
==	O
'\n'	O
)	O
{	O
int	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
long	O
p	*(void)
;	O
if	O
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
!=	O
'\n'	O
)	O
{	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
width	int
-	O
(	O
edit_get_col	(*(struct))->(int)
(	O
edit	*(struct)
)	O
-	O
col	int
)	O
;	O
while	O
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
>	O
0	int
)	O
{	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
' '	O
)	O
;	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
-=	O
space_width	int
;	O
}	O
}	O
for	O
(	O
p	*(void)
=	O
edit	*(struct)
->	O
curs1	long
;	O
;	O
p	*(void)
++	O
)	O
{	O
if	O
(	O
p	*(void)
==	O
edit	*(struct)
->	O
last_byte	long
)	O
{	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
last_byte	long
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit_insert_ahead	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
'\n'	O
)	O
;	O
p	*(void)
++	O
;	O
break	O
;	O
}	O
if	O
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
p	*(void)
)	O
==	O
'\n'	O
)	O
{	O
p	*(void)
++	O
;	O
break	O
;	O
}	O
}	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
p	*(void)
,	O
col	int
,	O
0	int
)	O
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
col	int
-	O
edit_get_col	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
while	O
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
>=	O
space_width	int
)	O
{	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
' '	O
)	O
;	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
-=	O
space_width	int
;	O
}	O
continue	O
;	O
}	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
data	*(void)
[	O
i	array(int)
]	O
)	O
;	O
}	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
cursor	long
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
}	O
void	O
edit_block_copy_cmd	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
long	O
start_mark	*(long)
,	O
end_mark	*(long)
,	O
current	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
int	O
size	long
;	O
unsigned	O
char	O
*	O
copy_buf	*(char)
;	O
edit_update_curs_col	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
eval_marks	(*(struct),*(long),*(long))->(int)
(	O
edit	*(struct)
,	O
&	O
start_mark	*(long)
,	O
&	O
end_mark	*(long)
)	O
)	O
return	O
;	O
copy_buf	*(char)
=	O
edit_get_block	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,long,*(int))->(*(char))
(	O
edit	*(struct)
,	O
start_mark	*(long)
,	O
end_mark	*(long)
,	O
&	O
size	long
)	O
;	O
edit_push_markers	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
column_highlighting	int
)	O
{	O
edit_insert_column_of_text	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char),int,int)->(void)
(	O
edit	*(struct)
,	O
copy_buf	*(char)
,	O
size	long
,	O
abs	(int)->(int)
(	O
edit	*(struct)
->	O
column2	int
-	O
edit	*(struct)
->	O
column1	int
)	O
)	O
;	O
}	O
else	O
{	O
while	O
(	O
size	long
--	O
)	O
edit_insert_ahead	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
copy_buf	*(char)
[	O
size	long
]	O
)	O
;	O
}	O
g_free	(*(void))->(void)
(	O
copy_buf	*(char)
)	O
;	O
edit_scroll_screen_over_cursor	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
column_highlighting	int
)	O
{	O
edit_set_markers	(*(struct),long,long,int,int)->(void)
(	O
edit	*(struct)
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
COLUMN_ON	int
)	O
;	O
column_highlighting	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
start_mark	*(long)
<	O
current	long
&&	O
end_mark	*(long)
>	O
current	long
)	O
edit_set_markers	(*(struct),long,long,int,int)->(void)
(	O
edit	*(struct)
,	O
start_mark	*(long)
,	O
end_mark	*(long)
+	O
end_mark	*(long)
-	O
start_mark	*(long)
,	O
0	int
,	O
0	int
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
void	O
edit_block_move_cmd	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
long	O
count	int
;	O
long	O
current	long
;	O
unsigned	O
char	O
*	O
copy_buf	*(char)
;	O
long	O
start_mark	*(long)
,	O
end_mark	*(long)
;	O
int	O
deleted	int
=	O
0	int
;	O
int	O
x	array(long)
=	O
0	int
;	O
if	O
(	O
eval_marks	(*(struct),*(long),*(long))->(int)
(	O
edit	*(struct)
,	O
&	O
start_mark	*(long)
,	O
&	O
end_mark	*(long)
)	O
)	O
return	O
;	O
if	O
(	O
column_highlighting	int
)	O
{	O
edit_update_curs_col	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
x	array(long)
=	O
edit	*(struct)
->	O
curs_col	long
;	O
if	O
(	O
start_mark	*(long)
<=	O
edit	*(struct)
->	O
curs1	long
&&	O
end_mark	*(long)
>=	O
edit	*(struct)
->	O
curs1	long
)	O
if	O
(	O
(	O
x	array(long)
>	O
edit	*(struct)
->	O
column1	int
&&	O
x	array(long)
<	O
edit	*(struct)
->	O
column2	int
)	O
||	O
(	O
x	array(long)
>	O
edit	*(struct)
->	O
column2	int
&&	O
x	array(long)
<	O
edit	*(struct)
->	O
column1	int
)	O
)	O
return	O
;	O
}	O
else	O
if	O
(	O
start_mark	*(long)
<=	O
edit	*(struct)
->	O
curs1	long
&&	O
end_mark	*(long)
>=	O
edit	*(struct)
->	O
curs1	long
)	O
return	O
;	O
if	O
(	O
(	O
end_mark	*(long)
-	O
start_mark	*(long)
)	O
>	O
option_max_undo	int
/	O
2	int
)	O
if	O
(	O
edit_query_dialog2	O
(	O
_	O
(	O
"Warning"	*(char)
)	O
,	O
_	O
(	O
" Block is large, you may not be able to undo this action. "	*(char)
)	O
,	O
_	O
(	O
"C&ontinue"	*(char)
)	O
,	O
_	O
(	O
"&Cancel"	*(char)
)	O
)	O
)	O
return	O
;	O
edit_push_markers	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
current	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
if	O
(	O
column_highlighting	int
)	O
{	O
int	O
size	long
,	O
c1	int
,	O
c2	int
,	O
line	int
;	O
line	int
=	O
edit	*(struct)
->	O
curs_line	long
;	O
if	O
(	O
edit	*(struct)
->	O
mark2	long
<	O
0	int
)	O
edit_mark_cmd	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
c1	int
=	O
min	long
(	O
edit	*(struct)
->	O
column1	int
,	O
edit	*(struct)
->	O
column2	int
)	O
;	O
c2	int
=	O
max	long
(	O
edit	*(struct)
->	O
column1	int
,	O
edit	*(struct)
->	O
column2	int
)	O
;	O
copy_buf	*(char)
=	O
edit_get_block	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,long,*(int))->(*(char))
(	O
edit	*(struct)
,	O
start_mark	*(long)
,	O
end_mark	*(long)
,	O
&	O
size	long
)	O
;	O
if	O
(	O
x	array(long)
<	O
c2	int
)	O
{	O
edit_block_delete_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
deleted	int
=	O
1	int
;	O
}	O
edit_move_to_line	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
line	int
)	O
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
,	O
x	array(long)
,	O
0	int
)	O
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit_insert_column_of_text	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char),int,int)->(void)
(	O
edit	*(struct)
,	O
copy_buf	*(char)
,	O
size	long
,	O
c2	int
-	O
c1	int
)	O
;	O
if	O
(	O
!	O
deleted	int
)	O
{	O
line	int
=	O
edit	*(struct)
->	O
curs_line	long
;	O
edit_update_curs_col	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
x	array(long)
=	O
edit	*(struct)
->	O
curs_col	long
;	O
edit_block_delete_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
edit_move_to_line	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
line	int
)	O
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
,	O
x	array(long)
,	O
0	int
)	O
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
}	O
edit_set_markers	(*(struct),long,long,int,int)->(void)
(	O
edit	*(struct)
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
COLUMN_ON	int
)	O
;	O
column_highlighting	int
=	O
0	int
;	O
}	O
else	O
{	O
copy_buf	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
end_mark	*(long)
-	O
start_mark	*(long)
)	O
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
start_mark	*(long)
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit_scroll_screen_over_cursor	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
count	int
=	O
start_mark	*(long)
;	O
while	O
(	O
count	int
<	O
end_mark	*(long)
)	O
{	O
copy_buf	*(char)
[	O
end_mark	*(long)
-	O
count	int
-	O
1	int
]	O
=	O
edit_delete	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
count	int
++	O
;	O
}	O
edit_scroll_screen_over_cursor	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
current	long
-	O
edit	*(struct)
->	O
curs1	long
-	O
(	O
(	O
(	O
current	long
-	O
edit	*(struct)
->	O
curs1	long
)	O
>	O
0	int
)	O
?	O
end_mark	*(long)
-	O
start_mark	*(long)
:	O
0	int
)	O
)	O
;	O
edit_scroll_screen_over_cursor	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
while	O
(	O
count	int
--	O
>	O
start_mark	*(long)
)	O
edit_insert_ahead	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
copy_buf	*(char)
[	O
end_mark	*(long)
-	O
count	int
-	O
1	int
]	O
)	O
;	O
edit_set_markers	(*(struct),long,long,int,int)->(void)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
,	O
edit	*(struct)
->	O
curs1	long
+	O
end_mark	*(long)
-	O
start_mark	*(long)
,	O
0	int
,	O
0	int
)	O
;	O
}	O
edit_scroll_screen_over_cursor	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
g_free	(*(void))->(void)
(	O
copy_buf	*(char)
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
static	O
void	O
edit_delete_column_of_text	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
long	O
p	*(void)
,	O
q	long
,	O
r	*(struct)
,	O
m1	long
,	O
m2	long
;	O
int	O
b	*(void)
,	O
c	int
,	O
d	double
;	O
int	O
n	long
;	O
eval_marks	(*(struct),*(long),*(long))->(int)
(	O
edit	*(struct)
,	O
&	O
m1	long
,	O
&	O
m2	long
)	O
;	O
n	long
=	O
edit_move_forward	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
m1	long
,	O
0	int
,	O
m2	long
)	O
+	O
1	int
;	O
c	int
=	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
m1	long
)	O
,	O
0	int
,	O
m1	long
)	O
;	O
d	double
=	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
m2	long
)	O
,	O
0	int
,	O
m2	long
)	O
;	O
b	*(void)
=	O
min	long
(	O
c	int
,	O
d	double
)	O
;	O
c	int
=	O
max	long
(	O
c	int
,	O
d	double
)	O
;	O
while	O
(	O
n	long
--	O
)	O
{	O
r	*(struct)
=	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
p	*(void)
=	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
r	*(struct)
,	O
b	*(void)
,	O
0	int
)	O
;	O
q	long
=	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
r	*(struct)
,	O
c	int
,	O
0	int
)	O
;	O
if	O
(	O
p	*(void)
<	O
m1	long
)	O
p	*(void)
=	O
m1	long
;	O
if	O
(	O
q	long
>	O
m2	long
)	O
q	long
=	O
m2	long
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
p	*(void)
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
while	O
(	O
q	long
>	O
p	*(void)
)	O
{	O
if	O
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
!=	O
'\n'	O
)	O
edit_delete	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
q	long
--	O
;	O
}	O
if	O
(	O
n	long
)	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit_move_forward	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
,	O
1	int
,	O
0	int
)	O
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
}	O
}	O
static	O
int	O
edit_block_delete	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
long	O
count	int
;	O
long	O
start_mark	*(long)
,	O
end_mark	*(long)
;	O
if	O
(	O
eval_marks	(*(struct),*(long),*(long))->(int)
(	O
edit	*(struct)
,	O
&	O
start_mark	*(long)
,	O
&	O
end_mark	*(long)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
column_highlighting	int
&&	O
edit	*(struct)
->	O
mark2	long
<	O
0	int
)	O
edit_mark_cmd	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
(	O
end_mark	*(long)
-	O
start_mark	*(long)
)	O
>	O
option_max_undo	int
/	O
2	int
)	O
{	O
if	O
(	O
edit_query_dialog2	O
(	O
_	O
(	O
"Warning"	*(char)
)	O
,	O
_	O
(	O
" Block is large, you may not be able to undo this action. "	*(char)
)	O
,	O
_	O
(	O
"C&ontinue"	*(char)
)	O
,	O
_	O
(	O
"&Cancel"	*(char)
)	O
)	O
)	O
{	O
return	O
1	int
;	O
}	O
}	O
edit_push_markers	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
start_mark	*(long)
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit_scroll_screen_over_cursor	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
count	int
=	O
start_mark	*(long)
;	O
if	O
(	O
start_mark	*(long)
<	O
end_mark	*(long)
)	O
{	O
if	O
(	O
column_highlighting	int
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
mark2	long
<	O
0	int
)	O
edit_mark_cmd	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
edit_delete_column_of_text	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
}	O
else	O
{	O
while	O
(	O
count	int
<	O
end_mark	*(long)
)	O
{	O
edit_delete	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
count	int
++	O
;	O
}	O
}	O
}	O
edit_set_markers	(*(struct),long,long,int,int)->(void)
(	O
edit	*(struct)
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_block_delete_cmd	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
long	O
start_mark	*(long)
,	O
end_mark	*(long)
;	O
if	O
(	O
eval_marks	(*(struct),*(long),*(long))->(int)
(	O
edit	*(struct)
,	O
&	O
start_mark	*(long)
,	O
&	O
end_mark	*(long)
)	O
)	O
{	O
edit_delete_line	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
return	O
edit_block_delete	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
;	O
}	O
static	O
int	O
edit_replace_prompt	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char),int,int)->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
char	O
*	O
replace_text	*(char)
,	O
int	O
xpos	int
,	O
int	O
ypos	int
)	O
{	O
QuickWidget	struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
]	O
=	O
{	O
{	O
quick_button	int
,	O
63	int
,	O
CONFIRM_DLG_WIDTH	int
,	O
3	int
,	O
CONFIRM_DLG_HEIGTH	int
,	O
N_	O
(	O
"&Cancel"	*(char)
)	O
,	O
0	int
,	O
B_CANCEL	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
50	int
,	O
CONFIRM_DLG_WIDTH	int
,	O
3	int
,	O
CONFIRM_DLG_HEIGTH	int
,	O
N_	O
(	O
"O&ne"	*(char)
)	O
,	O
0	int
,	O
B_REPLACE_ONE	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
37	int
,	O
CONFIRM_DLG_WIDTH	int
,	O
3	int
,	O
CONFIRM_DLG_HEIGTH	int
,	O
N_	O
(	O
"A&ll"	*(char)
)	O
,	O
0	int
,	O
B_REPLACE_ALL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
21	int
,	O
CONFIRM_DLG_WIDTH	int
,	O
3	int
,	O
CONFIRM_DLG_HEIGTH	int
,	O
N_	O
(	O
"&Skip"	*(char)
)	O
,	O
0	int
,	O
B_SKIP_REPLACE	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
4	int
,	O
CONFIRM_DLG_WIDTH	int
,	O
3	int
,	O
CONFIRM_DLG_HEIGTH	int
,	O
N_	O
(	O
"&Replace"	*(char)
)	O
,	O
0	int
,	O
B_ENTER	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
CONFIRM_DLG_WIDTH	int
,	O
2	int
,	O
CONFIRM_DLG_HEIGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
NULL_QuickWidget	O
}	O
;	O
GString	struct
*	O
label_text	*(struct(*(char),long,long))
=	O
g_string_new	(*(char))->(*(struct(*(char),long,long)))
(	O
_	O
(	O
" Replace with: "	*(char)
)	O
)	O
;	O
if	O
(	O
*	O
replace_text	*(char)
)	O
{	O
size_t	long
label_len	long
;	O
label_len	long
=	O
label_text	*(struct(*(char),long,long))
->	O
len	int
;	O
g_string_append	(*(struct(*(char),long,long)),*(char))->(*(struct(*(char),long,long)))
(	O
label_text	*(struct(*(char),long,long))
,	O
replace_text	*(char)
)	O
;	O
convert_to_display	O
(	O
label_text	*(struct(*(char),long,long))
->	O
str	*(char)
+	O
label_len	long
)	O
;	O
}	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
5	int
]	O
.	O
text	*(char)
=	O
label_text	*(struct(*(char),long,long))
->	O
str	*(char)
;	O
{	O
int	O
retval	*(void)
;	O
QuickDialog	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
Quick_input	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
=	O
{	O
CONFIRM_DLG_WIDTH	int
,	O
CONFIRM_DLG_HEIGTH	int
,	O
0	int
,	O
0	int
,	O
N_	O
(	O
" Confirm replace "	*(char)
)	O
,	O
"[Input Line Keys]"	*(char)
,	O
0	int
,	O
0	int
}	O
;	O
Quick_input	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
.	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
=	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
;	O
Quick_input	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
.	O
xpos	int
=	O
xpos	int
;	O
if	O
(	O
(	O
edit	*(struct)
->	O
curs_row	long
>=	O
ypos	int
-	O
1	int
)	O
&&	O
(	O
edit	*(struct)
->	O
curs_row	long
<=	O
ypos	int
+	O
CONFIRM_DLG_HEIGTH	int
-	O
1	int
)	O
)	O
ypos	int
-=	O
CONFIRM_DLG_HEIGTH	int
;	O
Quick_input	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
.	O
ypos	int
=	O
ypos	int
;	O
retval	*(void)
=	O
quick_dialog	(*(struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*`,int,int,*`,*`,*`)),int)))->(int)
(	O
&	O
Quick_input	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
)	O
;	O
g_string_free	(*(struct(*(char),long,long)),int)->(*(char))
(	O
label_text	*(struct(*(char),long,long))
,	O
TRUE	O
)	O
;	O
return	O
retval	*(void)
;	O
}	O
}	O
static	O
void	O
edit_replace_dialog	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char),*(char),*(char),*(*(char)),*(*(char)),*(*(char)))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
const	O
char	O
*	O
search_default	*(char)
,	O
const	O
char	O
*	O
replace_default	*(char)
,	O
const	O
char	O
*	O
argorder_default	*(char)
,	O
char	O
*	O
*	O
search_text	*(*(char))
,	O
char	O
*	O
*	O
replace_text	*(char)
,	O
char	O
*	O
*	O
arg_order	*(*(char))
)	O
{	O
int	O
treplace_scanf	int
=	O
replace_scanf	int
;	O
int	O
treplace_regexp	int
=	O
replace_regexp	int
;	O
int	O
treplace_all	int
=	O
replace_all	int
;	O
int	O
treplace_prompt	int
=	O
replace_prompt	int
;	O
int	O
treplace_backwards	int
=	O
replace_backwards	int
;	O
int	O
treplace_whole	int
=	O
replace_whole	int
;	O
int	O
treplace_case	int
=	O
replace_case	int
;	O
QuickWidget	struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
]	O
=	O
{	O
{	O
quick_button	int
,	O
6	int
,	O
10	int
,	O
12	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Cancel"	*(char)
)	O
,	O
0	int
,	O
B_CANCEL	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
2	int
,	O
10	int
,	O
12	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"&OK"	*(char)
)	O
,	O
0	int
,	O
B_ENTER	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
33	int
,	O
REPLACE_DLG_WIDTH	int
,	O
11	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"scanf &Expression"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
33	int
,	O
REPLACE_DLG_WIDTH	int
,	O
10	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"replace &All"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
33	int
,	O
REPLACE_DLG_WIDTH	int
,	O
9	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"pro&Mpt on replace"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
4	int
,	O
REPLACE_DLG_WIDTH	int
,	O
11	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Backwards"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
4	int
,	O
REPLACE_DLG_WIDTH	int
,	O
10	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Regular expression"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
4	int
,	O
REPLACE_DLG_WIDTH	int
,	O
9	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Whole words only"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
4	int
,	O
REPLACE_DLG_WIDTH	int
,	O
8	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"case &Sensitive"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
REPLACE_DLG_WIDTH	int
,	O
7	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
""	*(char)
,	O
52	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"edit-argord"	*(char)
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
REPLACE_DLG_WIDTH	int
,	O
6	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
" Enter replacement argument order eg. 3,2,1,4 "	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
REPLACE_DLG_WIDTH	int
,	O
5	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
""	*(char)
,	O
52	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"edit-replace"	*(char)
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
REPLACE_DLG_WIDTH	int
,	O
4	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
" Enter replacement string:"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
REPLACE_DLG_WIDTH	int
,	O
3	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
""	*(char)
,	O
52	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"edit-search"	*(char)
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
REPLACE_DLG_WIDTH	int
,	O
2	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
" Enter search string:"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
NULL_QuickWidget	O
}	O
;	O
(	O
void	O
)	O
edit	*(struct)
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
2	int
]	O
.	O
result	long
=	O
&	O
treplace_scanf	int
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
3	int
]	O
.	O
result	long
=	O
&	O
treplace_all	int
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
4	int
]	O
.	O
result	long
=	O
&	O
treplace_prompt	int
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
5	int
]	O
.	O
result	long
=	O
&	O
treplace_backwards	int
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
6	int
]	O
.	O
result	long
=	O
&	O
treplace_regexp	int
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
7	int
]	O
.	O
result	long
=	O
&	O
treplace_whole	int
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
8	int
]	O
.	O
result	long
=	O
&	O
treplace_case	int
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
9	int
]	O
.	O
str_result	*(*(char))
=	O
arg_order	*(*(char))
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
9	int
]	O
.	O
text	*(char)
=	O
argorder_default	*(char)
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
11	int
]	O
.	O
str_result	*(*(char))
=	O
replace_text	*(char)
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
11	int
]	O
.	O
text	*(char)
=	O
replace_default	*(char)
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
13	int
]	O
.	O
str_result	*(*(char))
=	O
search_text	*(*(char))
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
13	int
]	O
.	O
text	*(char)
=	O
search_default	*(char)
;	O
{	O
QuickDialog	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
Quick_input	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
=	O
{	O
REPLACE_DLG_WIDTH	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
-	O
1	int
,	O
0	int
,	O
N_	O
(	O
" Replace "	*(char)
)	O
,	O
"[Input Line Keys]"	*(char)
,	O
0	int
,	O
0	int
}	O
;	O
Quick_input	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
.	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
=	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
;	O
if	O
(	O
quick_dialog	(*(struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*`,int,int,*`,*`,*`)),int)))->(int)
(	O
&	O
Quick_input	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
)	O
!=	O
B_CANCEL	int
)	O
{	O
replace_scanf	int
=	O
treplace_scanf	int
;	O
replace_backwards	int
=	O
treplace_backwards	int
;	O
replace_regexp	int
=	O
treplace_regexp	int
;	O
replace_all	int
=	O
treplace_all	int
;	O
replace_prompt	int
=	O
treplace_prompt	int
;	O
replace_whole	int
=	O
treplace_whole	int
;	O
replace_case	int
=	O
treplace_case	int
;	O
return	O
;	O
}	O
else	O
{	O
*	O
arg_order	*(*(char))
=	O
NULL	O
;	O
*	O
replace_text	*(char)
=	O
NULL	O
;	O
*	O
search_text	*(*(char))
=	O
NULL	O
;	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
edit_search_dialog	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(*(char)))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
char	O
*	O
*	O
search_text	*(*(char))
)	O
{	O
int	O
treplace_scanf	int
=	O
replace_scanf	int
;	O
int	O
treplace_regexp	int
=	O
replace_regexp	int
;	O
int	O
treplace_whole	int
=	O
replace_whole	int
;	O
int	O
treplace_case	int
=	O
replace_case	int
;	O
int	O
treplace_backwards	int
=	O
replace_backwards	int
;	O
QuickWidget	struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
]	O
=	O
{	O
{	O
quick_button	int
,	O
6	int
,	O
10	int
,	O
7	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Cancel"	*(char)
)	O
,	O
0	int
,	O
B_CANCEL	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
2	int
,	O
10	int
,	O
7	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"&OK"	*(char)
)	O
,	O
0	int
,	O
B_ENTER	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
33	int
,	O
SEARCH_DLG_WIDTH	int
,	O
6	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"scanf &Expression"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
33	int
,	O
SEARCH_DLG_WIDTH	int
,	O
5	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Backwards"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
4	int
,	O
SEARCH_DLG_WIDTH	int
,	O
6	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Regular expression"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
4	int
,	O
SEARCH_DLG_WIDTH	int
,	O
5	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Whole words only"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
4	int
,	O
SEARCH_DLG_WIDTH	int
,	O
4	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"case &Sensitive"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
SEARCH_DLG_WIDTH	int
,	O
3	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
""	*(char)
,	O
52	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"edit-search"	*(char)
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
SEARCH_DLG_WIDTH	int
,	O
2	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
" Enter search string:"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
NULL_QuickWidget	O
}	O
;	O
(	O
void	O
)	O
edit	*(struct)
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
2	int
]	O
.	O
result	long
=	O
&	O
treplace_scanf	int
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
3	int
]	O
.	O
result	long
=	O
&	O
treplace_backwards	int
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
4	int
]	O
.	O
result	long
=	O
&	O
treplace_regexp	int
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
5	int
]	O
.	O
result	long
=	O
&	O
treplace_whole	int
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
6	int
]	O
.	O
result	long
=	O
&	O
treplace_case	int
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
7	int
]	O
.	O
str_result	*(*(char))
=	O
search_text	*(*(char))
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
7	int
]	O
.	O
text	*(char)
=	O
*	O
search_text	*(*(char))
;	O
{	O
QuickDialog	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
Quick_input	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
=	O
{	O
SEARCH_DLG_WIDTH	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
-	O
1	int
,	O
0	int
,	O
N_	O
(	O
"Search"	*(char)
)	O
,	O
"[Input Line Keys]"	*(char)
,	O
0	int
,	O
0	int
}	O
;	O
Quick_input	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
.	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
=	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
;	O
if	O
(	O
quick_dialog	(*(struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*`,int,int,*`,*`,*`)),int)))->(int)
(	O
&	O
Quick_input	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
)	O
!=	O
B_CANCEL	int
)	O
{	O
replace_scanf	int
=	O
treplace_scanf	int
;	O
replace_backwards	int
=	O
treplace_backwards	int
;	O
replace_regexp	int
=	O
treplace_regexp	int
;	O
replace_whole	int
=	O
treplace_whole	int
;	O
replace_case	int
=	O
treplace_case	int
;	O
}	O
else	O
{	O
*	O
search_text	*(*(char))
=	O
NULL	O
;	O
}	O
}	O
}	O
static	O
long	O
sargs	array(array(long))
[	O
NUM_REPL_ARGS	int
]	O
[	O
256	int
/	O
sizeof	O
(	O
long	O
)	O
]	O
;	O
static	O
int	O
string_regexp_search	(*(char),*(char),int,int,int,*(int),*(void))->(int)
(	O
char	O
*	O
pattern	*(char)
,	O
char	O
*	O
string	*(char)
,	O
int	O
match_type	int
,	O
int	O
match_bol	int
,	O
int	O
icase	int
,	O
int	O
*	O
found_len	int
,	O
void	O
*	O
d	double
)	O
{	O
static	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
r	*(struct)
;	O
static	O
char	O
*	O
old_pattern	*(char)
=	O
NULL	O
;	O
static	O
int	O
old_type	int
,	O
old_icase	int
;	O
regmatch_t	struct(int,int)
*	O
pmatch	*(struct(int,int))
;	O
static	O
regmatch_t	struct(int,int)
s	*(char)
[	O
1	int
]	O
;	O
pmatch	*(struct(int,int))
=	O
(	O
regmatch_t	struct(int,int)
*	O
)	O
d	double
;	O
if	O
(	O
!	O
pmatch	*(struct(int,int))
)	O
pmatch	*(struct(int,int))
=	O
s	*(char)
;	O
if	O
(	O
!	O
old_pattern	*(char)
||	O
strcmp	(*(char),*(char))->(int)
(	O
old_pattern	*(char)
,	O
pattern	*(char)
)	O
||	O
old_type	int
!=	O
match_type	int
||	O
old_icase	int
!=	O
icase	int
)	O
{	O
if	O
(	O
old_pattern	*(char)
)	O
{	O
regfree	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)))->(void)
(	O
&	O
r	*(struct)
)	O
;	O
g_free	(*(void))->(void)
(	O
old_pattern	*(char)
)	O
;	O
old_pattern	*(char)
=	O
0	int
;	O
}	O
if	O
(	O
regcomp	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int)->(int)
(	O
&	O
r	*(struct)
,	O
pattern	*(char)
,	O
REG_EXTENDED	int
|	O
(	O
icase	int
?	O
REG_ICASE	O
:	O
0	int
)	O
)	O
)	O
{	O
*	O
found_len	int
=	O
0	int
;	O
return	O
-	O
3	int
;	O
}	O
old_pattern	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
pattern	*(char)
)	O
;	O
old_type	int
=	O
match_type	int
;	O
old_icase	int
=	O
icase	int
;	O
}	O
if	O
(	O
regexec	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),long,array(struct(int,int)),int)->(int)
(	O
&	O
r	*(struct)
,	O
string	*(char)
,	O
d	double
?	O
NUM_REPL_ARGS	int
:	O
1	int
,	O
pmatch	*(struct(int,int))
,	O
(	O
(	O
match_bol	int
||	O
match_type	int
!=	O
match_normal	int
)	O
?	O
0	int
:	O
REG_NOTBOL	int
)	O
)	O
!=	O
0	int
)	O
{	O
*	O
found_len	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
found_len	int
=	O
pmatch	*(struct(int,int))
[	O
0	int
]	O
.	O
rm_eo	int
-	O
pmatch	*(struct(int,int))
[	O
0	int
]	O
.	O
rm_so	int
;	O
return	O
(	O
pmatch	*(struct(int,int))
[	O
0	int
]	O
.	O
rm_so	int
)	O
;	O
}	O
typedef	O
int	O
(	O
*	O
edit_getbyte_fn	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
)	O
(	O
WEdit	struct
*	O
,	O
long	O
)	O
;	O
static	O
long	O
edit_find_string	(long,*(char),*(int),long,*((*(struct(struct`,int,int,*`,*`,long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*`,long,*`,long,long,long,int,struct`,int,*`,*`,long,struct`,*`,*`,int,int,array(struct(short,short)),*`,*`,int,array(*(char)))),long)->(int)),*(void),int,*(void))->(long)
(	O
long	O
start	*(int)
,	O
unsigned	O
char	O
*	O
exp	*(char)
,	O
int	O
*	O
len	int
,	O
long	O
last_byte	long
,	O
edit_getbyte_fn	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
,	O
void	O
*	O
data	*(void)
,	O
int	O
once_only	int
,	O
void	O
*	O
d	double
)	O
{	O
long	O
p	*(void)
,	O
q	long
=	O
0	int
;	O
long	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
exp	*(char)
)	O
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
0	int
;	O
int	O
n	long
=	O
0	int
;	O
for	O
(	O
p	*(void)
=	O
0	int
;	O
p	*(void)
<	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
p	*(void)
++	O
)	O
if	O
(	O
exp	*(char)
[	O
p	*(void)
]	O
==	O
'%'	O
)	O
if	O
(	O
exp	*(char)
[	O
++	O
p	*(void)
]	O
!=	O
'%'	O
)	O
n	long
++	O
;	O
if	O
(	O
replace_scanf	int
||	O
replace_regexp	int
)	O
{	O
int	O
c	int
;	O
unsigned	O
char	O
*	O
buf	*(char)
;	O
unsigned	O
char	O
mbuf	array(char)
[	O
MAX_REPL_LEN	int
*	O
2	int
+	O
3	int
]	O
;	O
replace_scanf	int
=	O
(	O
!	O
replace_regexp	int
)	O
;	O
buf	*(char)
=	O
mbuf	array(char)
;	O
if	O
(	O
replace_scanf	int
)	O
{	O
unsigned	O
char	O
e	*(struct)
[	O
MAX_REPL_LEN	int
]	O
;	O
if	O
(	O
n	long
>=	O
NUM_REPL_ARGS	int
)	O
return	O
-	O
3	int
;	O
if	O
(	O
replace_case	int
)	O
{	O
for	O
(	O
p	*(void)
=	O
start	*(int)
;	O
p	*(void)
<	O
last_byte	long
&&	O
p	*(void)
<	O
start	*(int)
+	O
MAX_REPL_LEN	int
;	O
p	*(void)
++	O
)	O
buf	*(char)
[	O
p	*(void)
-	O
start	*(int)
]	O
=	O
(	O
*	O
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
)	O
(	O
data	*(void)
,	O
p	*(void)
)	O
;	O
}	O
else	O
{	O
for	O
(	O
p	*(void)
=	O
0	int
;	O
exp	*(char)
[	O
p	*(void)
]	O
!=	O
0	int
;	O
p	*(void)
++	O
)	O
exp	*(char)
[	O
p	*(void)
]	O
=	O
my_lower_case	(int)->(int)
(	O
exp	*(char)
[	O
p	*(void)
]	O
)	O
;	O
for	O
(	O
p	*(void)
=	O
start	*(int)
;	O
p	*(void)
<	O
last_byte	long
&&	O
p	*(void)
<	O
start	*(int)
+	O
MAX_REPL_LEN	int
;	O
p	*(void)
++	O
)	O
{	O
c	int
=	O
(	O
*	O
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
)	O
(	O
data	*(void)
,	O
p	*(void)
)	O
;	O
buf	*(char)
[	O
p	*(void)
-	O
start	*(int)
]	O
=	O
my_lower_case	(int)->(int)
(	O
c	int
)	O
;	O
}	O
}	O
buf	*(char)
[	O
(	O
q	long
=	O
p	*(void)
-	O
start	*(int)
)	O
]	O
=	O
0	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
e	*(struct)
,	O
(	O
char	O
*	O
)	O
exp	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
e	*(struct)
,	O
"%n"	*(char)
)	O
;	O
exp	*(char)
=	O
e	*(struct)
;	O
while	O
(	O
q	long
)	O
{	O
*	O
(	O
(	O
int	O
*	O
)	O
sargs	array(array(long))
[	O
n	long
]	O
)	O
=	O
0	int
;	O
if	O
(	O
n	long
==	O
sscanf	(*(char),*(char))->(int)
(	O
(	O
char	O
*	O
)	O
buf	*(char)
,	O
(	O
char	O
*	O
)	O
exp	*(char)
,	O
SCANF_ARGS	O
)	O
)	O
{	O
if	O
(	O
*	O
(	O
(	O
int	O
*	O
)	O
sargs	array(array(long))
[	O
n	long
]	O
)	O
)	O
{	O
*	O
len	int
=	O
*	O
(	O
(	O
int	O
*	O
)	O
sargs	array(array(long))
[	O
n	long
]	O
)	O
;	O
return	O
start	*(int)
;	O
}	O
}	O
if	O
(	O
once_only	int
)	O
return	O
-	O
2	int
;	O
if	O
(	O
q	long
+	O
start	*(int)
<	O
last_byte	long
)	O
{	O
if	O
(	O
replace_case	int
)	O
{	O
buf	*(char)
[	O
q	long
]	O
=	O
(	O
*	O
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
)	O
(	O
data	*(void)
,	O
q	long
+	O
start	*(int)
)	O
;	O
}	O
else	O
{	O
c	int
=	O
(	O
*	O
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
)	O
(	O
data	*(void)
,	O
q	long
+	O
start	*(int)
)	O
;	O
buf	*(char)
[	O
q	long
]	O
=	O
my_lower_case	(int)->(int)
(	O
c	int
)	O
;	O
}	O
q	long
++	O
;	O
}	O
buf	*(char)
[	O
q	long
]	O
=	O
0	int
;	O
start	*(int)
++	O
;	O
buf	*(char)
++	O
;	O
if	O
(	O
buf	*(char)
==	O
mbuf	array(char)
+	O
MAX_REPL_LEN	int
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
mbuf	array(char)
,	O
buf	*(char)
,	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
buf	*(char)
)	O
+	O
1	int
)	O
;	O
buf	*(char)
=	O
mbuf	array(char)
;	O
}	O
q	long
--	O
;	O
}	O
}	O
else	O
{	O
long	O
offset	long
=	O
0	int
;	O
int	O
found_start	long
,	O
match_bol	int
,	O
move_win	int
=	O
0	int
;	O
while	O
(	O
start	*(int)
+	O
offset	long
<	O
last_byte	long
)	O
{	O
match_bol	int
=	O
(	O
offset	long
==	O
0	int
||	O
(	O
*	O
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
)	O
(	O
data	*(void)
,	O
start	*(int)
+	O
offset	long
-	O
1	int
)	O
==	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
move_win	int
)	O
{	O
p	*(void)
=	O
start	*(int)
+	O
offset	long
;	O
q	long
=	O
0	int
;	O
}	O
for	O
(	O
;	O
p	*(void)
<	O
last_byte	long
&&	O
q	long
<	O
MAX_REPL_LEN	int
;	O
p	*(void)
++	O
,	O
q	long
++	O
)	O
{	O
mbuf	array(char)
[	O
q	long
]	O
=	O
(	O
*	O
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
)	O
(	O
data	*(void)
,	O
p	*(void)
)	O
;	O
if	O
(	O
mbuf	array(char)
[	O
q	long
]	O
==	O
'\n'	O
)	O
{	O
q	long
++	O
;	O
break	O
;	O
}	O
}	O
offset	long
+=	O
q	long
;	O
mbuf	array(char)
[	O
q	long
]	O
=	O
0	int
;	O
buf	*(char)
=	O
mbuf	array(char)
;	O
while	O
(	O
q	long
)	O
{	O
found_start	long
=	O
string_regexp_search	(*(char),*(char),int,int,int,*(int),*(void))->(int)
(	O
(	O
char	O
*	O
)	O
exp	*(char)
,	O
(	O
char	O
*	O
)	O
buf	*(char)
,	O
match_normal	int
,	O
match_bol	int
,	O
!	O
replace_case	int
,	O
len	int
,	O
d	double
)	O
;	O
if	O
(	O
found_start	long
<=	O
-	O
2	int
)	O
{	O
*	O
len	int
=	O
0	int
;	O
return	O
-	O
3	int
;	O
}	O
else	O
if	O
(	O
found_start	long
==	O
-	O
1	int
)	O
break	O
;	O
else	O
if	O
(	O
*	O
len	int
==	O
0	int
)	O
{	O
q	long
--	O
;	O
buf	*(char)
++	O
;	O
match_bol	int
=	O
0	int
;	O
continue	O
;	O
}	O
else	O
return	O
(	O
start	*(int)
+	O
offset	long
-	O
q	long
+	O
found_start	long
)	O
;	O
}	O
if	O
(	O
once_only	int
)	O
return	O
-	O
2	int
;	O
if	O
(	O
buf	*(char)
[	O
q	long
-	O
1	int
]	O
!=	O
'\n'	O
)	O
{	O
buf	*(char)
=	O
mbuf	array(char)
+	O
MAX_REPL_LEN	int
/	O
2	int
;	O
q	long
=	O
strlen	(*(char))->(long)
(	O
(	O
const	O
char	O
*	O
)	O
buf	*(char)
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
mbuf	array(char)
,	O
buf	*(char)
,	O
q	long
)	O
;	O
p	*(void)
=	O
start	*(int)
+	O
q	long
;	O
move_win	int
=	O
1	int
;	O
}	O
else	O
move_win	int
=	O
0	int
;	O
}	O
}	O
}	O
else	O
{	O
*	O
len	int
=	O
strlen	(*(char))->(long)
(	O
(	O
const	O
char	O
*	O
)	O
exp	*(char)
)	O
;	O
if	O
(	O
replace_case	int
)	O
{	O
for	O
(	O
p	*(void)
=	O
start	*(int)
;	O
p	*(void)
<=	O
last_byte	long
-	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
p	*(void)
++	O
)	O
{	O
if	O
(	O
(	O
*	O
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
)	O
(	O
data	*(void)
,	O
p	*(void)
)	O
==	O
(	O
unsigned	O
char	O
)	O
exp	*(char)
[	O
0	int
]	O
)	O
{	O
for	O
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
0	int
,	O
q	long
=	O
0	int
;	O
q	long
<	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
&&	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
<	O
1	int
;	O
q	long
++	O
)	O
if	O
(	O
(	O
*	O
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
)	O
(	O
data	*(void)
,	O
q	long
+	O
p	*(void)
)	O
!=	O
(	O
unsigned	O
char	O
)	O
exp	*(char)
[	O
q	long
]	O
)	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
1	int
;	O
if	O
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
0	int
)	O
return	O
p	*(void)
;	O
}	O
if	O
(	O
once_only	int
)	O
return	O
-	O
2	int
;	O
}	O
}	O
else	O
{	O
for	O
(	O
p	*(void)
=	O
0	int
;	O
exp	*(char)
[	O
p	*(void)
]	O
!=	O
0	int
;	O
p	*(void)
++	O
)	O
exp	*(char)
[	O
p	*(void)
]	O
=	O
my_lower_case	(int)->(int)
(	O
exp	*(char)
[	O
p	*(void)
]	O
)	O
;	O
for	O
(	O
p	*(void)
=	O
start	*(int)
;	O
p	*(void)
<=	O
last_byte	long
-	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
p	*(void)
++	O
)	O
{	O
if	O
(	O
my_lower_case	(int)->(int)
(	O
(	O
*	O
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
)	O
(	O
data	*(void)
,	O
p	*(void)
)	O
)	O
==	O
(	O
unsigned	O
char	O
)	O
exp	*(char)
[	O
0	int
]	O
)	O
{	O
for	O
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
0	int
,	O
q	long
=	O
0	int
;	O
q	long
<	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
&&	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
<	O
1	int
;	O
q	long
++	O
)	O
if	O
(	O
my_lower_case	(int)->(int)
(	O
(	O
*	O
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
)	O
(	O
data	*(void)
,	O
q	long
+	O
p	*(void)
)	O
)	O
!=	O
(	O
unsigned	O
char	O
)	O
exp	*(char)
[	O
q	long
]	O
)	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
1	int
;	O
if	O
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
0	int
)	O
return	O
p	*(void)
;	O
}	O
if	O
(	O
once_only	int
)	O
return	O
-	O
2	int
;	O
}	O
}	O
}	O
return	O
-	O
2	int
;	O
}	O
static	O
long	O
edit_find_forwards	(long,*(char),*(int),long,*((*(struct(struct`,int,int,*`,*`,long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*`,long,*`,long,long,long,int,struct`,int,*`,*`,long,struct`,*`,*`,int,int,array(struct(short,short)),*`,*`,int,array(*(char)))),long)->(int)),*(void),int,*(void))->(long)
(	O
long	O
search_start	long
,	O
unsigned	O
char	O
*	O
exp	*(char)
,	O
int	O
*	O
len	int
,	O
long	O
last_byte	long
,	O
edit_getbyte_fn	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
,	O
void	O
*	O
data	*(void)
,	O
int	O
once_only	int
,	O
void	O
*	O
d	double
)	O
{	O
long	O
p	*(void)
;	O
p	*(void)
=	O
search_start	long
;	O
while	O
(	O
(	O
p	*(void)
=	O
edit_find_string	(long,*(char),*(int),long,*((*(struct(struct`,int,int,*`,*`,long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*`,long,*`,long,long,long,int,struct`,int,*`,*`,long,struct`,*`,*`,int,int,array(struct(short,short)),*`,*`,int,array(*(char)))),long)->(int)),*(void),int,*(void))->(long)
(	O
p	*(void)
,	O
exp	*(char)
,	O
len	int
,	O
last_byte	long
,	O
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
,	O
data	*(void)
,	O
once_only	int
,	O
d	double
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
replace_whole	int
)	O
{	O
if	O
(	O
!	O
strcasechr	(*(char),int)->(*(char))
(	O
option_whole_chars_search	*(char)
,	O
(	O
*	O
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
)	O
(	O
data	*(void)
,	O
p	*(void)
-	O
1	int
)	O
)	O
&&	O
!	O
strcasechr	(*(char),int)->(*(char))
(	O
option_whole_chars_search	*(char)
,	O
(	O
*	O
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
)	O
(	O
data	*(void)
,	O
p	*(void)
+	O
*	O
len	int
)	O
)	O
)	O
return	O
p	*(void)
;	O
if	O
(	O
once_only	int
)	O
return	O
-	O
2	int
;	O
}	O
else	O
return	O
p	*(void)
;	O
if	O
(	O
once_only	int
)	O
break	O
;	O
p	*(void)
++	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
static	O
long	O
edit_find	(long,*(char),*(int),long,*((*(struct(struct`,int,int,*`,*`,long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*`,long,*`,long,long,long,int,struct`,int,*`,*`,long,struct`,*`,*`,int,int,array(struct(short,short)),*`,*`,int,array(*(char)))),long)->(int)),*(void),*(void))->(long)
(	O
long	O
search_start	long
,	O
unsigned	O
char	O
*	O
exp	*(char)
,	O
int	O
*	O
len	int
,	O
long	O
last_byte	long
,	O
edit_getbyte_fn	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
,	O
void	O
*	O
data	*(void)
,	O
void	O
*	O
d	double
)	O
{	O
long	O
p	*(void)
;	O
if	O
(	O
replace_backwards	int
)	O
{	O
while	O
(	O
search_start	long
>=	O
0	int
)	O
{	O
p	*(void)
=	O
edit_find_forwards	(long,*(char),*(int),long,*((*(struct(struct`,int,int,*`,*`,long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*`,long,*`,long,long,long,int,struct`,int,*`,*`,long,struct`,*`,*`,int,int,array(struct(short,short)),*`,*`,int,array(*(char)))),long)->(int)),*(void),int,*(void))->(long)
(	O
search_start	long
,	O
exp	*(char)
,	O
len	int
,	O
last_byte	long
,	O
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
,	O
data	*(void)
,	O
1	int
,	O
d	double
)	O
;	O
if	O
(	O
p	*(void)
==	O
search_start	long
)	O
return	O
p	*(void)
;	O
search_start	long
--	O
;	O
}	O
}	O
else	O
{	O
return	O
edit_find_forwards	(long,*(char),*(int),long,*((*(struct(struct`,int,int,*`,*`,long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*`,long,*`,long,long,long,int,struct`,int,*`,*`,long,struct`,*`,*`,int,int,array(struct(short,short)),*`,*`,int,array(*(char)))),long)->(int)),*(void),int,*(void))->(long)
(	O
search_start	long
,	O
exp	*(char)
,	O
len	int
,	O
last_byte	long
,	O
get_byte	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct`),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)),int,*(struct`),*(*`),long,struct(short,char,char,char,char),*(char),*(struct`),int,int,array(struct(short,short)),*(struct`),*(struct`),int,array(*(char)))),long)->(int))
,	O
data	*(void)
,	O
0	int
,	O
d	double
)	O
;	O
}	O
return	O
-	O
2	int
;	O
}	O
static	O
int	O
snprintf_p	(*(char),long,*(char))->(int)
(	O
char	O
*	O
str	*(char)
,	O
size_t	long
size	long
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
__attribute__	O
(	O
(	O
format	*(char)
(	O
printf	(*(char))->(int)
,	O
3	int
,	O
4	int
)	O
)	O
)	O
;	O
static	O
int	O
snprintf_p	(*(char),long,*(char))->(int)
(	O
char	O
*	O
str	*(char)
,	O
size_t	long
size	long
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
size_t	long
n	long
;	O
const	O
char	O
*	O
q	long
,	O
*	O
p	*(void)
;	O
char	O
*	O
s	*(char)
=	O
str	*(char)
,	O
*	O
e	*(struct)
=	O
str	*(char)
+	O
size	long
;	O
char	O
q1	array(char)
[	O
40	int
]	O
;	O
char	O
*	O
p1	*(char)
;	O
int	O
nargs	int
=	O
0	int
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
p	*(void)
=	O
q	long
=	O
fmt	*(char)
;	O
while	O
(	O
(	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
'%'	O
)	O
)	O
)	O
{	O
n	long
=	O
p	*(void)
-	O
q	long
;	O
if	O
(	O
n	long
>=	O
(	O
size_t	long
)	O
(	O
e	*(struct)
-	O
s	*(char)
)	O
)	O
goto	O
nospc	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
s	*(char)
,	O
q	long
,	O
n	long
)	O
;	O
s	*(char)
+=	O
n	long
;	O
q	long
=	O
p	*(void)
;	O
p1	*(char)
=	O
q1	array(char)
;	O
*	O
p1	*(char)
++	O
=	O
*	O
p	*(void)
++	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'%'	O
)	O
{	O
p	*(void)
++	O
;	O
*	O
s	*(char)
++	O
=	O
'%'	O
;	O
if	O
(	O
s	*(char)
==	O
e	*(struct)
)	O
goto	O
nospc	O
;	O
q	long
=	O
p	*(void)
;	O
continue	O
;	O
}	O
if	O
(	O
*	O
p	*(void)
==	O
'n'	O
)	O
goto	O
err	long
;	O
if	O
(	O
++	O
nargs	int
==	O
16	int
)	O
goto	O
err	long
;	O
if	O
(	O
*	O
p	*(void)
==	O
'#'	O
)	O
*	O
p1	*(char)
++	O
=	O
*	O
p	*(void)
++	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'0'	O
)	O
*	O
p1	*(char)
++	O
=	O
*	O
p	*(void)
++	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'-'	O
)	O
*	O
p1	*(char)
++	O
=	O
*	O
p	*(void)
++	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'+'	O
)	O
*	O
p1	*(char)
++	O
=	O
*	O
p	*(void)
++	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'*'	O
)	O
{	O
p	*(void)
++	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p1	*(char)
,	O
MY_itoa	(int)->(*(char))
(	O
*	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
int	O
*	O
)	O
)	O
)	O
;	O
p1	*(char)
+=	O
strlen	(*(char))->(long)
(	O
p1	*(char)
)	O
;	O
}	O
else	O
{	O
while	O
(	O
is_digit	O
(	O
*	O
p	*(void)
)	O
&&	O
p1	*(char)
<	O
q1	array(char)
+	O
20	int
)	O
*	O
p1	*(char)
++	O
=	O
*	O
p	*(void)
++	O
;	O
if	O
(	O
is_digit	O
(	O
*	O
p	*(void)
)	O
)	O
goto	O
err	long
;	O
}	O
if	O
(	O
*	O
p	*(void)
==	O
'.'	O
)	O
*	O
p1	*(char)
++	O
=	O
*	O
p	*(void)
++	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'*'	O
)	O
{	O
p	*(void)
++	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p1	*(char)
,	O
MY_itoa	(int)->(*(char))
(	O
*	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
int	O
*	O
)	O
)	O
)	O
;	O
p1	*(char)
+=	O
strlen	(*(char))->(long)
(	O
p1	*(char)
)	O
;	O
}	O
else	O
{	O
while	O
(	O
is_digit	O
(	O
*	O
p	*(void)
)	O
&&	O
p1	*(char)
<	O
q1	array(char)
+	O
32	int
)	O
*	O
p1	*(char)
++	O
=	O
*	O
p	*(void)
++	O
;	O
if	O
(	O
is_digit	O
(	O
*	O
p	*(void)
)	O
)	O
goto	O
err	long
;	O
}	O
if	O
(	O
*	O
p	*(void)
==	O
's'	O
)	O
{	O
snprint	O
(	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
char	O
*	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
p	*(void)
==	O
'h'	O
)	O
{	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"diouxX"	*(char)
,	O
*	O
p	*(void)
)	O
)	O
snprint	O
(	O
*	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
short	O
*	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
p	*(void)
==	O
'l'	O
)	O
{	O
*	O
p1	*(char)
++	O
=	O
*	O
p	*(void)
++	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"diouxX"	*(char)
,	O
*	O
p	*(void)
)	O
)	O
snprint	O
(	O
*	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
long	O
*	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"cdiouxX"	*(char)
,	O
*	O
p	*(void)
)	O
)	O
{	O
snprint	O
(	O
*	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
int	O
*	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
p	*(void)
==	O
'L'	O
)	O
{	O
*	O
p1	*(char)
++	O
=	O
*	O
p	*(void)
++	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"EefgG"	*(char)
,	O
*	O
p	*(void)
)	O
)	O
snprint	O
(	O
*	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
double	O
*	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"EefgG"	*(char)
,	O
*	O
p	*(void)
)	O
)	O
{	O
snprint	O
(	O
*	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
double	O
*	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"DOU"	*(char)
,	O
*	O
p	*(void)
)	O
)	O
{	O
snprint	O
(	O
*	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
long	O
*	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
p	*(void)
==	O
'p'	O
)	O
{	O
snprint	O
(	O
*	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
void	O
*	O
*	O
)	O
)	O
;	O
}	O
else	O
goto	O
err	long
;	O
q	long
=	O
p	*(void)
;	O
}	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
n	long
=	O
strlen	(*(char))->(long)
(	O
q	long
)	O
;	O
if	O
(	O
n	long
>=	O
(	O
size_t	long
)	O
(	O
e	*(struct)
-	O
s	*(char)
)	O
)	O
return	O
-	O
1	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
s	*(char)
,	O
q	long
,	O
n	long
+	O
1	int
)	O
;	O
return	O
s	*(char)
+	O
n	long
-	O
str	*(char)
;	O
nospc	O
:	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
return	O
-	O
1	int
;	O
err	long
:	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
return	O
-	O
2	int
;	O
}	O
static	O
void	O
regexp_error	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
(	O
void	O
)	O
edit	*(struct)
;	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	*(char)
)	O
,	O
_	O
(	O
" Invalid regular expression, or scanf expression with too many conversions "	*(char)
)	O
)	O
;	O
}	O
void	O
edit_replace_cmd	(*(struct),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
again	int
)	O
{	O
static	O
regmatch_t	struct(int,int)
pmatch	*(struct(int,int))
[	O
NUM_REPL_ARGS	int
]	O
;	O
static	O
char	O
*	O
saved1	*(char)
=	O
NULL	O
;	O
static	O
char	O
*	O
saved2	*(char)
=	O
NULL	O
;	O
static	O
char	O
*	O
saved3	*(char)
=	O
NULL	O
;	O
char	O
*	O
input1	*(char)
=	O
NULL	O
;	O
char	O
*	O
input2	*(char)
=	O
NULL	O
;	O
char	O
*	O
input3	*(char)
=	O
NULL	O
;	O
int	O
replace_yes	int
;	O
int	O
replace_continue	int
;	O
int	O
treplace_prompt	int
=	O
0	int
;	O
long	O
times_replaced	long
=	O
0	int
,	O
last_search	long
;	O
int	O
argord	array(int)
[	O
NUM_REPL_ARGS	int
]	O
;	O
if	O
(	O
!	O
edit	*(struct)
)	O
{	O
g_free	(*(void))->(void)
(	O
saved1	*(char)
)	O
,	O
saved1	*(char)
=	O
NULL	O
;	O
g_free	(*(void))->(void)
(	O
saved2	*(char)
)	O
,	O
saved2	*(char)
=	O
NULL	O
;	O
g_free	(*(void))->(void)
(	O
saved3	*(char)
)	O
,	O
saved3	*(char)
=	O
NULL	O
;	O
return	O
;	O
}	O
last_search	long
=	O
edit	*(struct)
->	O
last_byte	long
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
if	O
(	O
again	int
&&	O
!	O
saved1	*(char)
&&	O
!	O
saved2	*(char)
)	O
again	int
=	O
0	int
;	O
if	O
(	O
again	int
)	O
{	O
input1	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
saved1	*(char)
?	O
saved1	*(char)
:	O
""	*(char)
)	O
;	O
input2	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
saved2	*(char)
?	O
saved2	*(char)
:	O
""	*(char)
)	O
;	O
input3	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
saved3	*(char)
?	O
saved3	*(char)
:	O
""	*(char)
)	O
;	O
}	O
else	O
{	O
char	O
*	O
disp1	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
saved1	*(char)
?	O
saved1	*(char)
:	O
""	*(char)
)	O
;	O
char	O
*	O
disp2	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
saved2	*(char)
?	O
saved2	*(char)
:	O
""	*(char)
)	O
;	O
char	O
*	O
disp3	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
saved3	*(char)
?	O
saved3	*(char)
:	O
""	*(char)
)	O
;	O
convert_to_display	O
(	O
disp1	*(char)
)	O
;	O
convert_to_display	O
(	O
disp2	*(char)
)	O
;	O
convert_to_display	O
(	O
disp3	*(char)
)	O
;	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
KEY_PRESS	int
+	O
edit	*(struct)
->	O
start_display	long
)	O
;	O
edit_replace_dialog	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char),*(char),*(char),*(*(char)),*(*(char)),*(*(char)))->(void)
(	O
edit	*(struct)
,	O
disp1	*(char)
,	O
disp2	*(char)
,	O
disp3	*(char)
,	O
&	O
input1	*(char)
,	O
&	O
input2	*(char)
,	O
&	O
input3	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
disp1	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
disp2	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
disp3	*(char)
)	O
;	O
convert_from_input	O
(	O
input1	*(char)
)	O
;	O
convert_from_input	O
(	O
input2	*(char)
)	O
;	O
convert_from_input	O
(	O
input3	*(char)
)	O
;	O
treplace_prompt	int
=	O
replace_prompt	int
;	O
if	O
(	O
input1	*(char)
==	O
NULL	O
||	O
*	O
input1	*(char)
==	O
'\0'	O
)	O
{	O
edit	*(struct)
->	O
force	int
=	O
REDRAW_COMPLETELY	O
;	O
goto	O
cleanup	O
;	O
}	O
g_free	(*(void))->(void)
(	O
saved1	*(char)
)	O
,	O
saved1	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
input1	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
saved2	*(char)
)	O
,	O
saved2	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
input2	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
saved3	*(char)
)	O
,	O
saved3	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
input3	*(char)
)	O
;	O
}	O
{	O
const	O
char	O
*	O
s	*(char)
;	O
int	O
ord	int
;	O
size_t	long
i	array(int)
;	O
s	*(char)
=	O
input3	*(char)
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
NUM_REPL_ARGS	int
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
s	*(char)
!=	O
NULL	O
&&	O
*	O
s	*(char)
!=	O
'\0'	O
)	O
{	O
ord	int
=	O
atoi	(*(char))->(int)
(	O
s	*(char)
)	O
;	O
if	O
(	O
(	O
ord	int
>	O
0	int
)	O
&&	O
(	O
ord	int
<=	O
NUM_REPL_ARGS	int
)	O
)	O
argord	array(int)
[	O
i	array(int)
]	O
=	O
ord	int
-	O
1	int
;	O
else	O
argord	array(int)
[	O
i	array(int)
]	O
=	O
i	array(int)
;	O
s	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
s	*(char)
,	O
','	O
)	O
;	O
if	O
(	O
s	*(char)
!=	O
NULL	O
)	O
s	*(char)
++	O
;	O
}	O
else	O
argord	array(int)
[	O
i	array(int)
]	O
=	O
i	array(int)
;	O
}	O
}	O
replace_continue	int
=	O
replace_all	int
;	O
if	O
(	O
edit	*(struct)
->	O
found_len	int
&&	O
edit	*(struct)
->	O
search_start	long
==	O
edit	*(struct)
->	O
found_start	long
+	O
1	int
&&	O
replace_backwards	int
)	O
edit	*(struct)
->	O
search_start	long
--	O
;	O
if	O
(	O
edit	*(struct)
->	O
found_len	int
&&	O
edit	*(struct)
->	O
search_start	long
==	O
edit	*(struct)
->	O
found_start	long
-	O
1	int
&&	O
!	O
replace_backwards	int
)	O
edit	*(struct)
->	O
search_start	long
++	O
;	O
do	O
{	O
int	O
len	int
=	O
0	int
;	O
long	O
new_start	long
;	O
new_start	long
=	O
edit_find	(long,*(char),*(int),long,*((*(struct(struct`,int,int,*`,*`,long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*`,long,*`,long,long,long,int,struct`,int,*`,*`,long,struct`,*`,*`,int,int,array(struct(short,short)),*`,*`,int,array(*(char)))),long)->(int)),*(void),*(void))->(long)
(	O
edit	*(struct)
->	O
search_start	long
,	O
(	O
unsigned	O
char	O
*	O
)	O
input1	*(char)
,	O
&	O
len	int
,	O
last_search	long
,	O
edit_get_byte	(*(struct),long)->(int)
,	O
(	O
void	O
*	O
)	O
edit	*(struct)
,	O
pmatch	*(struct(int,int))
)	O
;	O
if	O
(	O
new_start	long
==	O
-	O
3	int
)	O
{	O
regexp_error	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
}	O
edit	*(struct)
->	O
search_start	long
=	O
new_start	long
;	O
if	O
(	O
edit	*(struct)
->	O
search_start	long
>=	O
0	int
)	O
{	O
int	O
i	array(int)
;	O
edit	*(struct)
->	O
found_start	long
=	O
edit	*(struct)
->	O
search_start	long
;	O
i	array(int)
=	O
edit	*(struct)
->	O
found_len	int
=	O
len	int
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
search_start	long
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit_scroll_screen_over_cursor	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
replace_yes	int
=	O
1	int
;	O
if	O
(	O
treplace_prompt	int
)	O
{	O
int	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
edit	*(struct)
->	O
curs_row	long
-	O
edit	*(struct)
->	O
num_widget_lines	int
/	O
3	int
;	O
if	O
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
>	O
0	int
)	O
edit_scroll_downward	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
;	O
if	O
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
<	O
0	int
)	O
edit_scroll_upward	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
-	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
;	O
edit_scroll_screen_over_cursor	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit_render_keypress	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
edit_push_key_press	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
switch	O
(	O
edit_replace_prompt	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char),int,int)->(int)
(	O
edit	*(struct)
,	O
input2	*(char)
,	O
(	O
edit	*(struct)
->	O
num_widget_columns	int
-	O
CONFIRM_DLG_WIDTH	int
)	O
/	O
2	int
,	O
edit	*(struct)
->	O
num_widget_lines	int
*	O
2	int
/	O
3	int
)	O
)	O
{	O
case	O
B_ENTER	int
:	O
break	O
;	O
case	O
B_SKIP_REPLACE	O
:	O
replace_yes	int
=	O
0	int
;	O
break	O
;	O
case	O
B_REPLACE_ALL	O
:	O
treplace_prompt	int
=	O
0	int
;	O
replace_continue	int
=	O
1	int
;	O
break	O
;	O
case	O
B_REPLACE_ONE	O
:	O
replace_continue	int
=	O
0	int
;	O
break	O
;	O
case	O
B_CANCEL	int
:	O
replace_yes	int
=	O
0	int
;	O
replace_continue	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
replace_yes	int
)	O
{	O
if	O
(	O
replace_scanf	int
)	O
{	O
char	O
repl_str	array(char)
[	O
MAX_REPL_LEN	int
+	O
2	int
]	O
;	O
int	O
ret	int
=	O
0	int
;	O
if	O
(	O
replace_regexp	int
)	O
{	O
int	O
k	int
,	O
j	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
NUM_REPL_ARGS	int
&&	O
pmatch	*(struct(int,int))
[	O
k	int
]	O
.	O
rm_eo	int
>=	O
0	int
;	O
k	int
++	O
)	O
{	O
unsigned	O
char	O
*	O
t	long
;	O
if	O
(	O
pmatch	*(struct(int,int))
[	O
k	int
]	O
.	O
rm_eo	int
-	O
pmatch	*(struct(int,int))
[	O
k	int
]	O
.	O
rm_so	int
>	O
255	int
)	O
{	O
ret	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
t	long
=	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
sargs	array(array(long))
[	O
k	int
-	O
1	int
]	O
[	O
0	int
]	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
pmatch	*(struct(int,int))
[	O
k	int
]	O
.	O
rm_eo	int
-	O
pmatch	*(struct(int,int))
[	O
k	int
]	O
.	O
rm_so	int
&&	O
j	int
<	O
255	int
;	O
j	int
++	O
,	O
t	long
++	O
)	O
*	O
t	long
=	O
(	O
unsigned	O
char	O
)	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
search_start	long
-	O
pmatch	*(struct(int,int))
[	O
0	int
]	O
.	O
rm_so	int
+	O
pmatch	*(struct(int,int))
[	O
k	int
]	O
.	O
rm_so	int
+	O
j	int
)	O
;	O
*	O
t	long
=	O
'\0'	O
;	O
}	O
for	O
(	O
;	O
k	int
<=	O
NUM_REPL_ARGS	int
;	O
k	int
++	O
)	O
sargs	array(array(long))
[	O
k	int
-	O
1	int
]	O
[	O
0	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
!	O
ret	int
)	O
ret	int
=	O
snprintf_p	(*(char),long,*(char))->(int)
(	O
repl_str	array(char)
,	O
MAX_REPL_LEN	int
+	O
2	int
,	O
input2	*(char)
,	O
PRINTF_ARGS	O
)	O
;	O
if	O
(	O
ret	int
>=	O
0	int
)	O
{	O
times_replaced	long
++	O
;	O
while	O
(	O
i	array(int)
--	O
)	O
edit_delete	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
while	O
(	O
repl_str	array(char)
[	O
++	O
i	array(int)
]	O
)	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
repl_str	array(char)
[	O
i	array(int)
]	O
)	O
;	O
}	O
else	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Replace "	*(char)
)	O
,	O
ret	int
==	O
-	O
2	int
?	O
_	O
(	O
" Error in replacement format string. "	*(char)
)	O
:	O
_	O
(	O
" Replacement too long. "	*(char)
)	O
)	O
;	O
replace_continue	int
=	O
0	int
;	O
}	O
}	O
else	O
{	O
times_replaced	long
++	O
;	O
while	O
(	O
i	array(int)
--	O
)	O
edit_delete	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
while	O
(	O
input2	*(char)
[	O
++	O
i	array(int)
]	O
)	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
input2	*(char)
[	O
i	array(int)
]	O
)	O
;	O
}	O
edit	*(struct)
->	O
found_len	int
=	O
i	array(int)
;	O
}	O
if	O
(	O
replace_backwards	int
)	O
{	O
last_search	long
=	O
edit	*(struct)
->	O
search_start	long
;	O
edit	*(struct)
->	O
search_start	long
--	O
;	O
}	O
else	O
{	O
edit	*(struct)
->	O
search_start	long
+=	O
i	array(int)
;	O
last_search	long
=	O
edit	*(struct)
->	O
last_byte	long
;	O
}	O
edit_scroll_screen_over_cursor	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
}	O
else	O
{	O
const	O
char	O
*	O
msg	*(char)
=	O
_	O
(	O
" Replace "	*(char)
)	O
;	O
edit	*(struct)
->	O
search_start	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
edit_update_curs_col	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit_render_keypress	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
times_replaced	long
)	O
{	O
message	*(char)
(	O
0	int
,	O
msg	*(char)
,	O
_	O
(	O
" %ld replacements made. "	*(char)
)	O
,	O
times_replaced	long
)	O
;	O
}	O
else	O
query_dialog	(*(char),*(char),int,int)->(int)
(	O
msg	*(char)
,	O
_	O
(	O
" Search string not found "	*(char)
)	O
,	O
D_NORMAL	int
,	O
1	int
,	O
_	O
(	O
"&OK"	*(char)
)	O
)	O
;	O
replace_continue	int
=	O
0	int
;	O
}	O
}	O
while	O
(	O
replace_continue	int
)	O
;	O
edit	*(struct)
->	O
force	int
=	O
REDRAW_COMPLETELY	O
;	O
edit_scroll_screen_over_cursor	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
cleanup	O
:	O
g_free	(*(void))->(void)
(	O
input1	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
input2	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
input3	*(char)
)	O
;	O
}	O
void	O
edit_search_cmd	(*(struct),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
again	int
)	O
{	O
static	O
char	O
*	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
NULL	O
;	O
char	O
*	O
exp	*(char)
=	O
""	*(char)
;	O
if	O
(	O
!	O
edit	*(struct)
)	O
{	O
g_free	(*(void))->(void)
(	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
;	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
NULL	O
;	O
return	O
;	O
}	O
exp	*(char)
=	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
?	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
:	O
exp	*(char)
;	O
if	O
(	O
again	int
)	O
{	O
if	O
(	O
!	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
return	O
;	O
exp	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
;	O
}	O
else	O
{	O
edit_search_dialog	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(*(char)))->(void)
(	O
edit	*(struct)
,	O
&	O
exp	*(char)
)	O
;	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
KEY_PRESS	int
+	O
edit	*(struct)
->	O
start_display	long
)	O
;	O
}	O
if	O
(	O
exp	*(char)
)	O
{	O
if	O
(	O
*	O
exp	*(char)
)	O
{	O
int	O
len	int
=	O
0	int
;	O
g_free	(*(void))->(void)
(	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
;	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
g_strdup	(*(char))->(*(char))
(	O
exp	*(char)
)	O
;	O
if	O
(	O
search_create_bookmark	int
)	O
{	O
int	O
found	int
=	O
0	int
,	O
books	int
=	O
0	int
;	O
int	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
0	int
,	O
l_last	int
=	O
-	O
1	int
;	O
long	O
p	*(void)
,	O
q	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
p	*(void)
=	O
edit_find	(long,*(char),*(int),long,*((*(struct(struct`,int,int,*`,*`,long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*`,long,*`,long,long,long,int,struct`,int,*`,*`,long,struct`,*`,*`,int,int,array(struct(short,short)),*`,*`,int,array(*(char)))),long)->(int)),*(void),*(void))->(long)
(	O
q	long
,	O
(	O
unsigned	O
char	O
*	O
)	O
exp	*(char)
,	O
&	O
len	int
,	O
edit	*(struct)
->	O
last_byte	long
,	O
edit_get_byte	(*(struct),long)->(int)
,	O
(	O
void	O
*	O
)	O
edit	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
p	*(void)
<	O
0	int
)	O
break	O
;	O
found	int
++	O
;	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
+=	O
edit_count_lines	(*(struct),long,int)->(int)
(	O
edit	*(struct)
,	O
q	long
,	O
p	*(void)
)	O
;	O
if	O
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
!=	O
l_last	int
)	O
{	O
book_mark_insert	(*(struct),int,int)->(void)
(	O
edit	*(struct)
,	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
,	O
BOOK_MARK_FOUND_COLOR	O
)	O
;	O
books	int
++	O
;	O
}	O
l_last	int
=	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
q	long
=	O
p	*(void)
+	O
1	int
;	O
}	O
if	O
(	O
found	int
)	O
{	O
message	*(char)
(	O
0	int
,	O
_	O
(	O
"Search"	*(char)
)	O
,	O
_	O
(	O
" %d items found, %d bookmarks added "	*(char)
)	O
,	O
found	int
,	O
books	int
)	O
;	O
}	O
else	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
"Search"	*(char)
)	O
,	O
_	O
(	O
" Search string not found "	*(char)
)	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
edit	*(struct)
->	O
found_len	int
&&	O
edit	*(struct)
->	O
search_start	long
==	O
edit	*(struct)
->	O
found_start	long
+	O
1	int
&&	O
replace_backwards	int
)	O
edit	*(struct)
->	O
search_start	long
--	O
;	O
if	O
(	O
edit	*(struct)
->	O
found_len	int
&&	O
edit	*(struct)
->	O
search_start	long
==	O
edit	*(struct)
->	O
found_start	long
-	O
1	int
&&	O
!	O
replace_backwards	int
)	O
edit	*(struct)
->	O
search_start	long
++	O
;	O
edit	*(struct)
->	O
search_start	long
=	O
edit_find	(long,*(char),*(int),long,*((*(struct(struct`,int,int,*`,*`,long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*`,long,*`,long,long,long,int,struct`,int,*`,*`,long,struct`,*`,*`,int,int,array(struct(short,short)),*`,*`,int,array(*(char)))),long)->(int)),*(void),*(void))->(long)
(	O
edit	*(struct)
->	O
search_start	long
,	O
(	O
unsigned	O
char	O
*	O
)	O
exp	*(char)
,	O
&	O
len	int
,	O
edit	*(struct)
->	O
last_byte	long
,	O
edit_get_byte	(*(struct),long)->(int)
,	O
(	O
void	O
*	O
)	O
edit	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
edit	*(struct)
->	O
search_start	long
>=	O
0	int
)	O
{	O
edit	*(struct)
->	O
found_start	long
=	O
edit	*(struct)
->	O
search_start	long
;	O
edit	*(struct)
->	O
found_len	int
=	O
len	int
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
search_start	long
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit_scroll_screen_over_cursor	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
replace_backwards	int
)	O
edit	*(struct)
->	O
search_start	long
--	O
;	O
else	O
edit	*(struct)
->	O
search_start	long
++	O
;	O
}	O
else	O
if	O
(	O
edit	*(struct)
->	O
search_start	long
==	O
-	O
3	int
)	O
{	O
edit	*(struct)
->	O
search_start	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
regexp_error	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
}	O
else	O
{	O
edit	*(struct)
->	O
search_start	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
edit_error_dialog	O
(	O
_	O
(	O
"Search"	*(char)
)	O
,	O
_	O
(	O
" Search string not found "	*(char)
)	O
)	O
;	O
}	O
}	O
}	O
g_free	(*(void))->(void)
(	O
exp	*(char)
)	O
;	O
}	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
edit_scroll_screen_over_cursor	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
}	O
int	O
edit_ok_to_exit	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
if	O
(	O
!	O
edit	*(struct)
->	O
modified	long
)	O
return	O
1	int
;	O
switch	O
(	O
edit_query_dialog3	O
(	O
_	O
(	O
"Quit"	*(char)
)	O
,	O
_	O
(	O
" File was modified, Save with exit? "	*(char)
)	O
,	O
_	O
(	O
"&Cancel quit"	*(char)
)	O
,	O
_	O
(	O
"&Yes"	*(char)
)	O
,	O
_	O
(	O
"&No"	*(char)
)	O
)	O
)	O
{	O
case	O
1	int
:	O
edit_push_markers	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
edit_set_markers	(*(struct),long,long,int,int)->(void)
(	O
edit	*(struct)
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
edit_save_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
)	O
return	O
0	int
;	O
break	O
;	O
case	O
2	int
:	O
break	O
;	O
case	O
0	int
:	O
case	O
-	O
1	int
:	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
unsigned	O
char	O
*	O
edit_get_block	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,long,*(int))->(*(char))
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
start	*(int)
,	O
long	O
finish	long
,	O
int	O
*	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
{	O
unsigned	O
char	O
*	O
s	*(char)
,	O
*	O
r	*(struct)
;	O
r	*(struct)
=	O
s	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
finish	long
-	O
start	*(int)
+	O
1	int
)	O
;	O
if	O
(	O
column_highlighting	int
)	O
{	O
*	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
0	int
;	O
while	O
(	O
start	*(int)
<	O
finish	long
)	O
{	O
int	O
c	int
,	O
x	array(long)
;	O
x	array(long)
=	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
start	*(int)
)	O
,	O
0	int
,	O
start	*(int)
)	O
;	O
c	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
start	*(int)
)	O
;	O
if	O
(	O
(	O
x	array(long)
>=	O
edit	*(struct)
->	O
column1	int
&&	O
x	array(long)
<	O
edit	*(struct)
->	O
column2	int
)	O
||	O
(	O
x	array(long)
>=	O
edit	*(struct)
->	O
column2	int
&&	O
x	array(long)
<	O
edit	*(struct)
->	O
column1	int
)	O
||	O
c	int
==	O
'\n'	O
)	O
{	O
*	O
s	*(char)
++	O
=	O
c	int
;	O
(	O
*	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
++	O
;	O
}	O
start	*(int)
++	O
;	O
}	O
}	O
else	O
{	O
*	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
finish	long
-	O
start	*(int)
;	O
while	O
(	O
start	*(int)
<	O
finish	long
)	O
*	O
s	*(char)
++	O
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
start	*(int)
++	O
)	O
;	O
}	O
*	O
s	*(char)
=	O
0	int
;	O
return	O
r	*(struct)
;	O
}	O
int	O
edit_save_block	(*(struct),*(char),long,long)->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
const	O
char	O
*	O
filename	*(char)
,	O
long	O
start	*(int)
,	O
long	O
finish	long
)	O
{	O
int	O
len	int
,	O
file	*(char)
;	O
if	O
(	O
(	O
file	*(char)
=	O
mc_open	(*(char),int)->(int)
(	O
filename	*(char)
,	O
O_CREAT	int
|	O
O_WRONLY	int
|	O
O_TRUNC	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
|	O
S_IRGRP	O
|	O
S_IROTH	O
|	O
O_BINARY	int
)	O
)	O
==	O
-	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
column_highlighting	int
)	O
{	O
unsigned	O
char	O
*	O
block	int
,	O
*	O
p	*(void)
;	O
int	O
r	*(struct)
;	O
p	*(void)
=	O
block	int
=	O
edit_get_block	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,long,*(int))->(*(char))
(	O
edit	*(struct)
,	O
start	*(int)
,	O
finish	long
,	O
&	O
len	int
)	O
;	O
while	O
(	O
len	int
)	O
{	O
r	*(struct)
=	O
mc_write	(int,*(void),int)->(int)
(	O
file	*(char)
,	O
p	*(void)
,	O
len	int
)	O
;	O
if	O
(	O
r	*(struct)
<	O
0	int
)	O
break	O
;	O
p	*(void)
+=	O
r	*(struct)
;	O
len	int
-=	O
r	*(struct)
;	O
}	O
g_free	(*(void))->(void)
(	O
block	int
)	O
;	O
}	O
else	O
{	O
unsigned	O
char	O
*	O
buf	*(char)
;	O
int	O
i	array(int)
=	O
start	*(int)
,	O
end	*(struct)
;	O
len	int
=	O
finish	long
-	O
start	*(int)
;	O
buf	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
TEMP_BUF_LEN	int
)	O
;	O
while	O
(	O
start	*(int)
!=	O
finish	long
)	O
{	O
end	*(struct)
=	O
min	long
(	O
finish	long
,	O
start	*(int)
+	O
TEMP_BUF_LEN	int
)	O
;	O
for	O
(	O
;	O
i	array(int)
<	O
end	*(struct)
;	O
i	array(int)
++	O
)	O
buf	*(char)
[	O
i	array(int)
-	O
start	*(int)
]	O
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
;	O
len	int
-=	O
mc_write	(int,*(void),int)->(int)
(	O
file	*(char)
,	O
(	O
char	O
*	O
)	O
buf	*(char)
,	O
end	*(struct)
-	O
start	*(int)
)	O
;	O
start	*(int)
=	O
end	*(struct)
;	O
}	O
g_free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
}	O
mc_close	(int)->(int)
(	O
file	*(char)
)	O
;	O
if	O
(	O
len	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
edit_save_block_to_clip_file	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,long)->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
start	*(int)
,	O
long	O
finish	long
)	O
{	O
return	O
edit_save_block	(*(struct),*(char),long,long)->(int)
(	O
edit	*(struct)
,	O
catstrs	(*(char))->(*(char))
(	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
CLIP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
,	O
start	*(int)
,	O
finish	long
)	O
;	O
}	O
void	O
edit_paste_from_history	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
(	O
void	O
)	O
edit	*(struct)
;	O
edit_error_dialog	O
(	O
_	O
(	O
" Error "	*(char)
)	O
,	O
_	O
(	O
" This function is not implemented. "	*(char)
)	O
)	O
;	O
}	O
int	O
edit_copy_to_X_buf_cmd	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
long	O
start_mark	*(long)
,	O
end_mark	*(long)
;	O
if	O
(	O
eval_marks	(*(struct),*(long),*(long))->(int)
(	O
edit	*(struct)
,	O
&	O
start_mark	*(long)
,	O
&	O
end_mark	*(long)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
edit_save_block_to_clip_file	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,long)->(int)
(	O
edit	*(struct)
,	O
start_mark	*(long)
,	O
end_mark	*(long)
)	O
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Copy to clipboard "	*(char)
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Unable to save to file. "	*(char)
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
edit_mark_cmd	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_cut_to_X_buf_cmd	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
long	O
start_mark	*(long)
,	O
end_mark	*(long)
;	O
if	O
(	O
eval_marks	(*(struct),*(long),*(long))->(int)
(	O
edit	*(struct)
,	O
&	O
start_mark	*(long)
,	O
&	O
end_mark	*(long)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
edit_save_block_to_clip_file	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,long)->(int)
(	O
edit	*(struct)
,	O
start_mark	*(long)
,	O
end_mark	*(long)
)	O
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Cut to clipboard "	*(char)
)	O
,	O
_	O
(	O
" Unable to save to file. "	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
edit_block_delete_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
edit_mark_cmd	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
void	O
edit_paste_from_X_buf_cmd	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
edit_insert_file	(*(struct),*(char))->(int)
(	O
edit	*(struct)
,	O
catstrs	(*(char))->(*(char))
(	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
CLIP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
}	O
void	O
edit_goto_cmd	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
char	O
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
static	O
long	O
line	int
=	O
0	int
;	O
long	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
char	O
*	O
error	*(struct(int,int,*(char)))
;	O
char	O
s	*(char)
[	O
32	int
]	O
;	O
g_snprintf	(*(char),long,*(char))->(int)
(	O
s	*(char)
,	O
sizeof	O
(	O
s	*(char)
)	O
,	O
"%ld"	*(char)
,	O
line	int
)	O
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
input_dialog	(*(char),*(char),*(char))->(*(char))
(	O
_	O
(	O
" Goto line "	*(char)
)	O
,	O
_	O
(	O
" Enter line: "	*(char)
)	O
,	O
line	int
?	O
s	*(char)
:	O
""	*(char)
)	O
;	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
return	O
;	O
if	O
(	O
!	O
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
g_free	(*(void))->(void)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
;	O
}	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
error	*(struct(int,int,*(char)))
,	O
0	int
)	O
;	O
if	O
(	O
*	O
error	*(struct(int,int,*(char)))
)	O
{	O
g_free	(*(void))->(void)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
;	O
}	O
line	int
=	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
if	O
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
<	O
0	int
)	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
edit	*(struct)
->	O
total_lines	long
+	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
+	O
2	int
;	O
edit_move_display	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
-	O
edit	*(struct)
->	O
num_widget_lines	int
/	O
2	int
-	O
1	int
)	O
;	O
edit_move_to_line	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
-	O
1	int
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
g_free	(*(void))->(void)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
int	O
edit_save_block_cmd	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
long	O
start_mark	*(long)
,	O
end_mark	*(long)
;	O
char	O
*	O
exp	*(char)
;	O
if	O
(	O
eval_marks	(*(struct),*(long),*(long))->(int)
(	O
edit	*(struct)
,	O
&	O
start_mark	*(long)
,	O
&	O
end_mark	*(long)
)	O
)	O
return	O
1	int
;	O
exp	*(char)
=	O
edit_get_save_file	O
(	O
catstrs	(*(char))->(*(char))
(	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
CLIP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
,	O
_	O
(	O
" Save Block "	*(char)
)	O
)	O
;	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
KEY_PRESS	int
+	O
edit	*(struct)
->	O
start_display	long
)	O
;	O
if	O
(	O
exp	*(char)
)	O
{	O
if	O
(	O
!	O
*	O
exp	*(char)
)	O
{	O
g_free	(*(void))->(void)
(	O
exp	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
edit_save_block	(*(struct),*(char),long,long)->(int)
(	O
edit	*(struct)
,	O
exp	*(char)
,	O
start_mark	*(long)
,	O
end_mark	*(long)
)	O
)	O
{	O
g_free	(*(void))->(void)
(	O
exp	*(char)
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
1	int
;	O
}	O
else	O
{	O
g_free	(*(void))->(void)
(	O
exp	*(char)
)	O
;	O
edit_error_dialog	O
(	O
_	O
(	O
" Save Block "	*(char)
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot save file. "	*(char)
)	O
)	O
)	O
;	O
}	O
}	O
}	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_insert_file_cmd	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
char	O
*	O
exp	*(char)
=	O
edit_get_load_file	O
(	O
catstrs	(*(char))->(*(char))
(	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
CLIP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
,	O
_	O
(	O
" Insert File "	*(char)
)	O
)	O
;	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
KEY_PRESS	int
+	O
edit	*(struct)
->	O
start_display	long
)	O
;	O
if	O
(	O
exp	*(char)
)	O
{	O
if	O
(	O
!	O
*	O
exp	*(char)
)	O
{	O
g_free	(*(void))->(void)
(	O
exp	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
edit_insert_file	(*(struct),*(char))->(int)
(	O
edit	*(struct)
,	O
exp	*(char)
)	O
)	O
{	O
g_free	(*(void))->(void)
(	O
exp	*(char)
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
1	int
;	O
}	O
else	O
{	O
g_free	(*(void))->(void)
(	O
exp	*(char)
)	O
;	O
edit_error_dialog	O
(	O
_	O
(	O
" Insert File "	*(char)
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot insert file. "	*(char)
)	O
)	O
)	O
;	O
}	O
}	O
}	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_sort_cmd	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
static	O
char	O
*	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
0	int
;	O
char	O
*	O
exp	*(char)
;	O
long	O
start_mark	*(long)
,	O
end_mark	*(long)
;	O
int	O
e	*(struct)
;	O
if	O
(	O
eval_marks	(*(struct),*(long),*(long))->(int)
(	O
edit	*(struct)
,	O
&	O
start_mark	*(long)
,	O
&	O
end_mark	*(long)
)	O
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Sort block "	*(char)
)	O
,	O
_	O
(	O
" You must first highlight a block of text. "	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
edit_save_block	(*(struct),*(char),long,long)->(int)
(	O
edit	*(struct)
,	O
catstrs	(*(char))->(*(char))
(	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
BLOCK_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
,	O
start_mark	*(long)
,	O
end_mark	*(long)
)	O
;	O
exp	*(char)
=	O
input_dialog	(*(char),*(char),*(char))->(*(char))
(	O
_	O
(	O
" Run Sort "	*(char)
)	O
,	O
_	O
(	O
" Enter sort options (see manpage) separated by whitespace: "	*(char)
)	O
,	O
(	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
!=	O
NULL	O
)	O
?	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
:	O
""	*(char)
)	O
;	O
if	O
(	O
!	O
exp	*(char)
)	O
return	O
1	int
;	O
g_free	(*(void))->(void)
(	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
;	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
exp	*(char)
;	O
e	*(struct)
=	O
system	(*(char))->(int)
(	O
catstrs	(*(char))->(*(char))
(	O
" sort "	*(char)
,	O
exp	*(char)
,	O
" "	*(char)
,	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
BLOCK_FILE	O
,	O
" > "	*(char)
,	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
TEMP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
if	O
(	O
e	*(struct)
)	O
{	O
if	O
(	O
e	*(struct)
==	O
-	O
1	int
||	O
e	*(struct)
==	O
127	int
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Sort "	*(char)
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot execute sort command "	*(char)
)	O
)	O
)	O
;	O
}	O
else	O
{	O
char	O
q	long
[	O
8	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
q	long
,	O
"%d "	*(char)
,	O
e	*(struct)
)	O
;	O
edit_error_dialog	O
(	O
_	O
(	O
" Sort "	*(char)
)	O
,	O
catstrs	(*(char))->(*(char))
(	O
_	O
(	O
" Sort returned non-zero: "	*(char)
)	O
,	O
q	long
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
}	O
return	O
-	O
1	int
;	O
}	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
if	O
(	O
edit_block_delete_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
)	O
return	O
1	int
;	O
edit_insert_file	(*(struct),*(char))->(int)
(	O
edit	*(struct)
,	O
catstrs	(*(char))->(*(char))
(	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
TEMP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_ext_cmd	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
char	O
*	O
exp	*(char)
;	O
int	O
e	*(struct)
;	O
exp	*(char)
=	O
input_dialog	(*(char),*(char),*(char))->(*(char))
(	O
_	O
(	O
"Paste output of external command"	*(char)
)	O
,	O
_	O
(	O
"Enter shell command(s):"	*(char)
)	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
exp	*(char)
)	O
return	O
1	int
;	O
e	*(struct)
=	O
system	(*(char))->(int)
(	O
catstrs	(*(char))->(*(char))
(	O
exp	*(char)
,	O
" > "	*(char)
,	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
TEMP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
g_free	(*(void))->(void)
(	O
exp	*(char)
)	O
;	O
if	O
(	O
e	*(struct)
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
"External command"	*(char)
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
"Cannot execute command"	*(char)
)	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
edit_insert_file	(*(struct),*(char))->(int)
(	O
edit	*(struct)
,	O
catstrs	(*(char))->(*(char))
(	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
TEMP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
edit_block_process_cmd	(*(struct),*(char),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
const	O
char	O
*	O
shell_cmd	*(char)
,	O
int	O
block	int
)	O
{	O
long	O
start_mark	*(long)
,	O
end_mark	*(long)
;	O
char	O
buf	*(char)
[	O
BUFSIZ	int
]	O
;	O
FILE	struct
*	O
script_home	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
FILE	struct
*	O
script_src	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
FILE	struct
*	O
block_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
const	O
char	O
*	O
o	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
h	*(struct)
=	O
NULL	O
;	O
const	O
char	O
*	O
b	*(void)
=	O
NULL	O
;	O
char	O
*	O
quoted_name	*(char)
=	O
NULL	O
;	O
o	*(char)
=	O
catstrs	(*(char))->(*(char))
(	O
mc_home	*(char)
,	O
shell_cmd	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
h	*(struct)
=	O
catstrs	(*(char))->(*(char))
(	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
EDIT_DIR	O
,	O
shell_cmd	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
b	*(void)
=	O
catstrs	(*(char))->(*(char))
(	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
BLOCK_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
script_home	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
h	*(struct)
,	O
"r"	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
!	O
(	O
script_home	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
h	*(struct)
,	O
"w"	*(char)
)	O
)	O
)	O
{	O
edit_error_dialog	O
(	O
""	*(char)
,	O
get_sys_error	O
(	O
catstrs	(*(char))->(*(char))
(	O
_	O
(	O
"Error creating script:"	*(char)
)	O
,	O
h	*(struct)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
(	O
script_src	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
o	*(char)
,	O
"r"	*(char)
)	O
)	O
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
script_home	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
unlink	(*(char))->(int)
(	O
h	*(struct)
)	O
;	O
edit_error_dialog	O
(	O
""	*(char)
,	O
get_sys_error	O
(	O
catstrs	(*(char))->(*(char))
(	O
_	O
(	O
"Error reading script:"	*(char)
)	O
,	O
o	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
script_src	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
buf	*(char)
,	O
script_home	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
script_home	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
edit_error_dialog	O
(	O
""	*(char)
,	O
get_sys_error	O
(	O
catstrs	(*(char))->(*(char))
(	O
_	O
(	O
"Error closing script:"	*(char)
)	O
,	O
h	*(struct)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
)	O
;	O
return	O
;	O
}	O
chmod	(*(char),int)->(int)
(	O
h	*(struct)
,	O
0700	int
)	O
;	O
edit_error_dialog	O
(	O
""	*(char)
,	O
get_sys_error	O
(	O
catstrs	(*(char))->(*(char))
(	O
_	O
(	O
"Script created:"	*(char)
)	O
,	O
h	*(struct)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
)	O
;	O
}	O
open_error_pipe	()->(void)
(	O
)	O
;	O
if	O
(	O
block	int
)	O
{	O
if	O
(	O
eval_marks	(*(struct),*(long),*(long))->(int)
(	O
edit	*(struct)
,	O
&	O
start_mark	*(long)
,	O
&	O
end_mark	*(long)
)	O
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
"Process block"	*(char)
)	O
,	O
_	O
(	O
" You must first highlight a block of text. "	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
edit_save_block	(*(struct),*(char),long,long)->(int)
(	O
edit	*(struct)
,	O
b	*(void)
,	O
start_mark	*(long)
,	O
end_mark	*(long)
)	O
;	O
quoted_name	*(char)
=	O
name_quote	(*(char),int)->(*(char))
(	O
edit	*(struct)
->	O
filename	*(char)
,	O
0	int
)	O
;	O
system	(*(char))->(int)
(	O
catstrs	(*(char))->(*(char))
(	O
" "	*(char)
,	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
EDIT_DIR	O
,	O
shell_cmd	*(char)
,	O
" "	*(char)
,	O
quoted_name	*(char)
,	O
" "	*(char)
,	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
BLOCK_FILE	O
" /dev/null"	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
}	O
else	O
{	O
system	(*(char))->(int)
(	O
catstrs	(*(char))->(*(char))
(	O
" "	*(char)
,	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
EDIT_DIR	O
,	O
shell_cmd	*(char)
,	O
" "	*(char)
,	O
quoted_name	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
}	O
g_free	(*(void))->(void)
(	O
quoted_name	*(char)
)	O
;	O
close_error_pipe	(int,*(char))->(int)
(	O
0	int
,	O
0	int
)	O
;	O
edit_refresh_cmd	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
if	O
(	O
block	int
)	O
{	O
if	O
(	O
edit_block_delete_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
)	O
return	O
;	O
edit_insert_file	(*(struct),*(char))->(int)
(	O
edit	*(struct)
,	O
b	*(void)
)	O
;	O
if	O
(	O
(	O
block_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
b	*(void)
,	O
"w"	*(char)
)	O
)	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
block_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
;	O
}	O
return	O
;	O
}	O
int	O
edit_print_string	(*(struct),*(char))->(int)
(	O
WEdit	struct
*	O
e	*(struct)
,	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	array(int)
=	O
0	int
;	O
while	O
(	O
s	*(char)
[	O
i	array(int)
]	O
)	O
edit_execute_cmd	(*(struct),int,int)->(void)
(	O
e	*(struct)
,	O
-	O
1	int
,	O
(	O
unsigned	O
char	O
)	O
s	*(char)
[	O
i	array(int)
++	O
]	O
)	O
;	O
e	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
edit_update_screen	(*(struct))->(void)
(	O
e	*(struct)
)	O
;	O
return	O
i	array(int)
;	O
}	O
static	O
void	O
pipe_mail	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char),*(char),*(char))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
char	O
*	O
to	char
,	O
char	O
*	O
subject	*(char)
,	O
char	O
*	O
cc	*(char)
)	O
{	O
FILE	struct
*	O
p	*(void)
=	O
0	int
;	O
char	O
*	O
s	*(char)
;	O
to	char
=	O
name_quote	(*(char),int)->(*(char))
(	O
to	char
,	O
0	int
)	O
;	O
subject	*(char)
=	O
name_quote	(*(char),int)->(*(char))
(	O
subject	*(char)
,	O
0	int
)	O
;	O
cc	*(char)
=	O
name_quote	(*(char),int)->(*(char))
(	O
cc	*(char)
,	O
0	int
)	O
;	O
s	*(char)
=	O
g_strconcat	(*(char))->(*(char))
(	O
"mail -s "	*(char)
,	O
subject	*(char)
,	O
*	O
cc	*(char)
?	O
" -c "	*(char)
:	O
""	*(char)
,	O
cc	*(char)
,	O
" "	*(char)
,	O
to	char
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
g_free	(*(void))->(void)
(	O
to	char
)	O
;	O
g_free	(*(void))->(void)
(	O
subject	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
cc	*(char)
)	O
;	O
if	O
(	O
s	*(char)
)	O
{	O
p	*(void)
=	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
s	*(char)
,	O
"w"	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
}	O
if	O
(	O
p	*(void)
)	O
{	O
long	O
i	array(int)
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
edit	*(struct)
->	O
last_byte	long
;	O
i	array(int)
++	O
)	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
,	O
p	*(void)
)	O
;	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
p	*(void)
)	O
;	O
}	O
}	O
void	O
edit_mail_dialog	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
char	O
*	O
tmail_to	*(char)
;	O
char	O
*	O
tmail_subject	*(char)
;	O
char	O
*	O
tmail_cc	*(char)
;	O
static	O
char	O
*	O
mail_cc_last	*(char)
=	O
0	int
;	O
static	O
char	O
*	O
mail_subject_last	*(char)
=	O
0	int
;	O
static	O
char	O
*	O
mail_to_last	*(char)
=	O
0	int
;	O
QuickDialog	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
Quick_input	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
=	O
{	O
50	int
,	O
MAIL_DLG_HEIGHT	int
,	O
-	O
1	int
,	O
0	int
,	O
N_	O
(	O
" Mail "	*(char)
)	O
,	O
"[Input Line Keys]"	*(char)
,	O
0	int
,	O
0	int
}	O
;	O
QuickWidget	struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
]	O
=	O
{	O
{	O
quick_button	int
,	O
6	int
,	O
10	int
,	O
9	int
,	O
MAIL_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Cancel"	*(char)
)	O
,	O
0	int
,	O
B_CANCEL	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
2	int
,	O
10	int
,	O
9	int
,	O
MAIL_DLG_HEIGHT	int
,	O
N_	O
(	O
"&OK"	*(char)
)	O
,	O
0	int
,	O
B_ENTER	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
50	int
,	O
8	int
,	O
MAIL_DLG_HEIGHT	int
,	O
""	*(char)
,	O
44	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"mail-dlg-input"	*(char)
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
50	int
,	O
7	int
,	O
MAIL_DLG_HEIGHT	int
,	O
N_	O
(	O
" Copies to"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
50	int
,	O
6	int
,	O
MAIL_DLG_HEIGHT	int
,	O
""	*(char)
,	O
44	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"mail-dlg-input-2"	*(char)
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
50	int
,	O
5	int
,	O
MAIL_DLG_HEIGHT	int
,	O
N_	O
(	O
" Subject"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
50	int
,	O
4	int
,	O
MAIL_DLG_HEIGHT	int
,	O
""	*(char)
,	O
44	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"mail-dlg-input-3"	*(char)
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
50	int
,	O
3	int
,	O
MAIL_DLG_HEIGHT	int
,	O
N_	O
(	O
" To"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
50	int
,	O
2	int
,	O
MAIL_DLG_HEIGHT	int
,	O
N_	O
(	O
" mail -s <subject> -c <cc> <to>"	*(char)
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
NULL_QuickWidget	O
}	O
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
2	int
]	O
.	O
str_result	*(*(char))
=	O
&	O
tmail_cc	*(char)
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
2	int
]	O
.	O
text	*(char)
=	O
mail_cc_last	*(char)
?	O
mail_cc_last	*(char)
:	O
""	*(char)
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
4	int
]	O
.	O
str_result	*(*(char))
=	O
&	O
tmail_subject	*(char)
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
4	int
]	O
.	O
text	*(char)
=	O
mail_subject_last	*(char)
?	O
mail_subject_last	*(char)
:	O
""	*(char)
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
6	int
]	O
.	O
str_result	*(*(char))
=	O
&	O
tmail_to	*(char)
;	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
[	O
6	int
]	O
.	O
text	*(char)
=	O
mail_to_last	*(char)
?	O
mail_to_last	*(char)
:	O
""	*(char)
;	O
Quick_input	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
.	O
widgets	*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
=	O
quick_widgets	array(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char)))
;	O
if	O
(	O
quick_dialog	(*(struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*`,int,int,*`,*`,*`)),int)))->(int)
(	O
&	O
Quick_input	struct(int,int,int,int,*(char),*(char),*(struct(int,int,int,int,int,*(char),int,int,*(int),*(*(char)),*(char))),int)
)	O
!=	O
B_CANCEL	int
)	O
{	O
g_free	(*(void))->(void)
(	O
mail_cc_last	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
mail_subject_last	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
mail_to_last	*(char)
)	O
;	O
mail_cc_last	*(char)
=	O
tmail_cc	*(char)
;	O
mail_subject_last	*(char)
=	O
tmail_subject	*(char)
;	O
mail_to_last	*(char)
=	O
tmail_to	*(char)
;	O
pipe_mail	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char),*(char),*(char))->(void)
(	O
edit	*(struct)
,	O
mail_to_last	*(char)
,	O
mail_subject_last	*(char)
,	O
mail_cc_last	*(char)
)	O
;	O
}	O
}	O
static	O
int	O
edit_find_word_start	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(long),*(int))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
*	O
word_start	*(long)
,	O
int	O
*	O
word_len	*(int)
)	O
{	O
int	O
i	array(int)
,	O
c	int
,	O
last	int
;	O
if	O
(	O
edit	*(struct)
->	O
curs1	long
<=	O
0	int
)	O
return	O
0	int
;	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
-	O
1	int
)	O
;	O
if	O
(	O
isspace	(int)->(int)
(	O
c	int
)	O
||	O
!	O
(	O
isalnum	(int)->(int)
(	O
c	int
)	O
||	O
c	int
==	O
'_'	O
)	O
)	O
return	O
0	int
;	O
for	O
(	O
i	array(int)
=	O
2	int
;	O
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
curs1	long
-	O
i	array(int)
<	O
0	int
)	O
return	O
0	int
;	O
last	int
=	O
c	int
;	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
-	O
i	array(int)
)	O
;	O
if	O
(	O
!	O
(	O
isalnum	(int)->(int)
(	O
c	int
)	O
||	O
c	int
==	O
'_'	O
)	O
)	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
last	int
)	O
)	O
return	O
0	int
;	O
*	O
word_start	*(long)
=	O
edit	*(struct)
->	O
curs1	long
-	O
(	O
i	array(int)
-	O
1	int
)	O
;	O
*	O
word_len	*(int)
=	O
i	array(int)
-	O
1	int
;	O
break	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
edit_set_search_parameters	(int,int,int,int,int)->(void)
(	O
int	O
rs	int
,	O
int	O
rb	int
,	O
int	O
rr	int
,	O
int	O
rw	int
,	O
int	O
rc	*(int)
)	O
{	O
replace_scanf	int
=	O
rs	int
;	O
replace_backwards	int
=	O
rb	int
;	O
replace_regexp	int
=	O
rr	int
;	O
replace_whole	int
=	O
rw	int
;	O
replace_case	int
=	O
rc	*(int)
;	O
}	O
static	O
int	O
edit_collect_completions	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,int,*(char),*(struct(*(char),int)),*(int))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
start	*(int)
,	O
int	O
word_len	*(int)
,	O
char	O
*	O
match_expr	*(char)
,	O
struct	O
selection	struct(*(char),int)
*	O
compl	*(struct(*(char),int))
,	O
int	O
*	O
num	int
)	O
{	O
int	O
len	int
,	O
max_len	long
=	O
0	int
,	O
i	array(int)
,	O
skip	int
;	O
unsigned	O
char	O
*	O
bufpos	*(char)
;	O
while	O
(	O
*	O
num	int
<	O
MAX_WORD_COMPLETIONS	int
)	O
{	O
start	*(int)
=	O
edit_find	(long,*(char),*(int),long,*((*(struct(struct`,int,int,*`,*`,long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*`,long,*`,long,long,long,int,struct`,int,*`,*`,long,struct`,*`,*`,int,int,array(struct(short,short)),*`,*`,int,array(*(char)))),long)->(int)),*(void),*(void))->(long)
(	O
start	*(int)
-	O
1	int
,	O
(	O
unsigned	O
char	O
*	O
)	O
match_expr	*(char)
,	O
&	O
len	int
,	O
edit	*(struct)
->	O
last_byte	long
,	O
edit_get_byte	(*(struct),long)->(int)
,	O
(	O
void	O
*	O
)	O
edit	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
start	*(int)
<	O
0	int
)	O
break	O
;	O
bufpos	*(char)
=	O
&	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
start	*(int)
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
start	*(int)
&	O
M_EDIT_BUF_SIZE	O
]	O
;	O
skip	int
=	O
0	int
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
*	O
num	int
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
(	O
char	O
*	O
)	O
&	O
compl	*(struct(*(char),int))
[	O
i	array(int)
]	O
.	O
text	*(char)
[	O
word_len	*(int)
]	O
,	O
(	O
char	O
*	O
)	O
&	O
bufpos	*(char)
[	O
word_len	*(int)
]	O
,	O
max	long
(	O
len	int
,	O
compl	*(struct(*(char),int))
[	O
i	array(int)
]	O
.	O
len	int
)	O
-	O
word_len	*(int)
)	O
==	O
0	int
)	O
{	O
skip	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
skip	int
)	O
continue	O
;	O
compl	*(struct(*(char),int))
[	O
*	O
num	int
]	O
.	O
text	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
len	int
+	O
1	int
)	O
;	O
compl	*(struct(*(char),int))
[	O
*	O
num	int
]	O
.	O
len	int
=	O
len	int
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
len	int
;	O
i	array(int)
++	O
)	O
compl	*(struct(*(char),int))
[	O
*	O
num	int
]	O
.	O
text	*(char)
[	O
i	array(int)
]	O
=	O
*	O
(	O
bufpos	*(char)
+	O
i	array(int)
)	O
;	O
compl	*(struct(*(char),int))
[	O
*	O
num	int
]	O
.	O
text	*(char)
[	O
i	array(int)
]	O
=	O
'\0'	O
;	O
(	O
*	O
num	int
)	O
++	O
;	O
if	O
(	O
len	int
>	O
max_len	long
)	O
max_len	long
=	O
len	int
;	O
}	O
return	O
max_len	long
;	O
}	O
static	O
void	O
edit_completion_dialog	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int,int,*(struct(*(char),int)),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
max_len	long
,	O
int	O
word_len	*(int)
,	O
struct	O
selection	struct(*(char),int)
*	O
compl	*(struct(*(char),int))
,	O
int	O
num_compl	int
)	O
{	O
int	O
start_x	int
,	O
start_y	int
,	O
offset	long
,	O
i	array(int)
;	O
char	O
*	O
curr	*(char)
=	O
NULL	O
;	O
Dlg_head	struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))))))
*	O
compl_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
WListbox	struct
*	O
compl_list	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
int	O
compl_dlg_h	int
;	O
int	O
compl_dlg_w	int
;	O
compl_dlg_h	int
=	O
num_compl	int
+	O
2	int
;	O
compl_dlg_w	int
=	O
max_len	long
+	O
4	int
;	O
start_x	int
=	O
edit	*(struct)
->	O
curs_col	long
+	O
edit	*(struct)
->	O
start_col	long
-	O
(	O
compl_dlg_w	int
/	O
2	int
)	O
;	O
start_y	int
=	O
edit	*(struct)
->	O
curs_row	long
+	O
EDIT_TEXT_VERTICAL_OFFSET	int
+	O
1	int
;	O
if	O
(	O
start_x	int
<	O
0	int
)	O
start_x	int
=	O
0	int
;	O
if	O
(	O
compl_dlg_w	int
>	O
COLS	O
)	O
compl_dlg_w	int
=	O
COLS	O
;	O
if	O
(	O
compl_dlg_h	int
>	O
LINES	O
-	O
2	int
)	O
compl_dlg_h	int
=	O
LINES	O
-	O
2	int
;	O
offset	long
=	O
start_x	int
+	O
compl_dlg_w	int
-	O
COLS	O
;	O
if	O
(	O
offset	long
>	O
0	int
)	O
start_x	int
-=	O
offset	long
;	O
offset	long
=	O
start_y	int
+	O
compl_dlg_h	int
-	O
LINES	O
;	O
if	O
(	O
offset	long
>	O
0	int
)	O
start_y	int
-=	O
(	O
offset	long
+	O
1	int
)	O
;	O
compl_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
create_dlg	(int,int,int,int,*(int),*((*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(char),*(char),int)->(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))
(	O
start_y	int
,	O
start_x	int
,	O
compl_dlg_h	int
,	O
compl_dlg_w	int
,	O
dialog_colors	array(int)
,	O
NULL	O
,	O
"[Completion]"	*(char)
,	O
NULL	O
,	O
DLG_COMPACT	O
)	O
;	O
compl_list	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
listbox_new	(int,int,int,int,*((*(struct(struct`,*`,*`,*`,int,int,int,int,int,int,*`,int,int)))->(int)))->(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),int,int,int,int,int,int,*((*`)->(int)),int,int)))
(	O
1	int
,	O
1	int
,	O
compl_dlg_w	int
-	O
2	int
,	O
compl_dlg_h	int
-	O
2	int
,	O
NULL	O
)	O
;	O
add_widget	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),*(void))->(int)
(	O
compl_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
,	O
compl_list	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
num_compl	int
;	O
i	array(int)
++	O
)	O
listbox_add_item	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),int,int,int,int,int,int,*((*`)->(int)),int,int)),enum(int,int,int),int,*(char),*(void))->(*(char))
(	O
compl_list	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
,	O
LISTBOX_APPEND_AT_END	int
,	O
0	int
,	O
(	O
char	O
*	O
)	O
compl	*(struct(*(char),int))
[	O
i	array(int)
]	O
.	O
text	*(char)
,	O
NULL	O
)	O
;	O
run_dlg	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))->(int)
(	O
compl_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
;	O
if	O
(	O
compl_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
ret_value	int
==	O
B_ENTER	int
)	O
{	O
listbox_get_current	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),int,int,int,int,int,int,*((*`)->(int)),int,int)),*(*(char)),*(*(char)))->(void)
(	O
compl_list	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
,	O
&	O
curr	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
curr	*(char)
)	O
for	O
(	O
curr	*(char)
+=	O
word_len	*(int)
;	O
*	O
curr	*(char)
;	O
curr	*(char)
++	O
)	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
*	O
curr	*(char)
)	O
;	O
}	O
destroy_dlg	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
compl_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
;	O
}	O
void	O
edit_complete_word_cmd	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
word_len	*(int)
=	O
0	int
,	O
i	array(int)
,	O
num_compl	int
=	O
0	int
,	O
max_len	long
;	O
long	O
word_start	*(long)
=	O
0	int
;	O
unsigned	O
char	O
*	O
bufpos	*(char)
;	O
char	O
*	O
match_expr	*(char)
;	O
struct	O
selection	struct(*(char),int)
compl	*(struct(*(char),int))
[	O
MAX_WORD_COMPLETIONS	int
]	O
;	O
int	O
old_rs	int
=	O
replace_scanf	int
;	O
int	O
old_rb	int
=	O
replace_backwards	int
;	O
int	O
old_rr	int
=	O
replace_regexp	int
;	O
int	O
old_rw	int
=	O
replace_whole	int
;	O
int	O
old_rc	int
=	O
replace_case	int
;	O
if	O
(	O
!	O
edit_find_word_start	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(long),*(int))->(int)
(	O
edit	*(struct)
,	O
&	O
word_start	*(long)
,	O
&	O
word_len	*(int)
)	O
)	O
return	O
;	O
bufpos	*(char)
=	O
&	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
word_start	*(long)
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
word_start	*(long)
&	O
M_EDIT_BUF_SIZE	O
]	O
;	O
match_expr	*(char)
=	O
g_strdup_printf	(*(char))->(*(char))
(	O
"%.*s[a-zA-Z_0-9]+"	*(char)
,	O
word_len	*(int)
,	O
bufpos	*(char)
)	O
;	O
edit_set_search_parameters	(int,int,int,int,int)->(void)
(	O
0	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
)	O
;	O
max_len	long
=	O
edit_collect_completions	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,int,*(char),*(struct(*(char),int)),*(int))->(int)
(	O
edit	*(struct)
,	O
word_start	*(long)
,	O
word_len	*(int)
,	O
match_expr	*(char)
,	O
(	O
struct	O
selection	struct(*(char),int)
*	O
)	O
&	O
compl	*(struct(*(char),int))
,	O
&	O
num_compl	int
)	O
;	O
if	O
(	O
num_compl	int
>	O
0	int
)	O
{	O
if	O
(	O
num_compl	int
==	O
1	int
)	O
{	O
for	O
(	O
i	array(int)
=	O
word_len	*(int)
;	O
i	array(int)
<	O
compl	*(struct(*(char),int))
[	O
0	int
]	O
.	O
len	int
;	O
i	array(int)
++	O
)	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
*	O
(	O
compl	*(struct(*(char),int))
[	O
0	int
]	O
.	O
text	*(char)
+	O
i	array(int)
)	O
)	O
;	O
}	O
else	O
{	O
edit_completion_dialog	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int,int,*(struct(*(char),int)),int)->(void)
(	O
edit	*(struct)
,	O
max_len	long
,	O
word_len	*(int)
,	O
(	O
struct	O
selection	struct(*(char),int)
*	O
)	O
&	O
compl	*(struct(*(char),int))
,	O
num_compl	int
)	O
;	O
}	O
}	O
g_free	(*(void))->(void)
(	O
match_expr	*(char)
)	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
num_compl	int
;	O
i	array(int)
++	O
)	O
g_free	(*(void))->(void)
(	O
compl	*(struct(*(char),int))
[	O
i	array(int)
]	O
.	O
text	*(char)
)	O
;	O
edit_set_search_parameters	(int,int,int,int,int)->(void)
(	O
old_rs	int
,	O
old_rb	int
,	O
old_rr	int
,	O
old_rw	int
,	O
old_rc	int
)	O
;	O
}	O
void	O
edit_select_codepage_cmd	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
}	O
void	O
edit_insert_literal_cmd	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
char_for_insertion	int
=	O
edit_raw_key_query	(*(char),*(char),int)->(int)
(	O
_	O
(	O
" Insert Literal "	*(char)
)	O
,	O
_	O
(	O
" Press any key: "	*(char)
)	O
,	O
0	int
)	O
;	O
edit_execute_key_command	(*(struct),int,int)->(void)
(	O
edit	*(struct)
,	O
-	O
1	int
,	O
ascii_alpha_to_cntrl	(int)->(int)
(	O
char_for_insertion	int
)	O
)	O
;	O
}	O
void	O
edit_execute_macro_cmd	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
command	*(char)
=	O
CK_Macro	O
(	O
edit_raw_key_query	(*(char),*(char),int)->(int)
(	O
_	O
(	O
" Execute Macro "	*(char)
)	O
,	O
_	O
(	O
" Press macro hotkey: "	*(char)
)	O
,	O
1	int
)	O
)	O
;	O
if	O
(	O
command	*(char)
==	O
CK_Macro	O
(	O
0	int
)	O
)	O
command	*(char)
=	O
CK_Insert_Char	O
;	O
edit_execute_key_command	(*(struct),int,int)->(void)
(	O
edit	*(struct)
,	O
command	*(char)
,	O
-	O
1	int
)	O
;	O
}	O
void	O
edit_begin_end_macro_cmd	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
command	*(char)
;	O
if	O
(	O
edit	*(struct)
)	O
{	O
command	*(char)
=	O
edit	*(struct)
->	O
macro_i	int
<	O
0	int
?	O
CK_Begin_Record_Macro	int
:	O
CK_End_Record_Macro	int
;	O
edit_execute_key_command	(*(struct),int,int)->(void)
(	O
edit	*(struct)
,	O
command	*(char)
,	O
-	O
1	int
)	O
;	O
}	O
}	O
