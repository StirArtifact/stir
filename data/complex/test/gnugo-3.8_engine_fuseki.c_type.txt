static	O
int	O
horizontally_symmetric	int
;	O
static	O
int	O
vertically_symmetric	int
;	O
static	O
int	O
diagonally_symmetric	int
;	O
static	O
int	O
openregion	(int,int,int,int)->(int)
(	O
int	O
i1	int
,	O
int	O
i2	int
,	O
int	O
j1	int
,	O
int	O
j2	int
)	O
{	O
int	O
x	int
,	O
y	int
;	O
if	O
(	O
i1	int
>	O
i2	int
)	O
return	O
openregion	(int,int,int,int)->(int)
(	O
i2	int
,	O
i1	int
,	O
j1	int
,	O
j2	int
)	O
;	O
if	O
(	O
j1	int
>	O
j2	int
)	O
return	O
openregion	(int,int,int,int)->(int)
(	O
i1	int
,	O
i2	int
,	O
j2	int
,	O
j1	int
)	O
;	O
if	O
(	O
i1	int
<	O
0	int
)	O
i1	int
=	O
0	int
;	O
if	O
(	O
j1	int
<	O
0	int
)	O
j1	int
=	O
0	int
;	O
if	O
(	O
i2	int
>=	O
board_size	int
)	O
i2	int
=	O
board_size	int
-	O
1	int
;	O
if	O
(	O
j2	int
>=	O
board_size	int
)	O
j2	int
=	O
board_size	int
-	O
1	int
;	O
for	O
(	O
x	int
=	O
i1	int
;	O
x	int
<=	O
i2	int
;	O
x	int
++	O
)	O
for	O
(	O
y	int
=	O
j1	int
;	O
y	int
<=	O
j2	int
;	O
y	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
x	int
,	O
y	int
)	O
!=	O
EMPTY	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
set_symmetries	()->(void)
(	O
void	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
horizontally_symmetric	int
=	O
1	int
;	O
vertically_symmetric	int
=	O
1	int
;	O
diagonally_symmetric	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
&&	O
(	O
vertically_symmetric	int
||	O
horizontally_symmetric	int
||	O
diagonally_symmetric	int
)	O
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
!=	O
board	*(char)
[	O
POS	O
(	O
i	int
,	O
board_size	int
-	O
1	int
-	O
j	int
)	O
]	O
)	O
horizontally_symmetric	int
=	O
0	int
;	O
if	O
(	O
board	*(char)
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
!=	O
board	*(char)
[	O
POS	O
(	O
board_size	int
-	O
1	int
-	O
i	int
,	O
j	int
)	O
]	O
)	O
vertically_symmetric	int
=	O
0	int
;	O
if	O
(	O
board	*(char)
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
!=	O
board	*(char)
[	O
POS	O
(	O
board_size	int
-	O
1	int
-	O
j	int
,	O
board_size	int
-	O
1	int
-	O
i	int
)	O
]	O
)	O
diagonally_symmetric	int
=	O
0	int
;	O
}	O
}	O
static	O
int	O
corners	array(array(int))
[	O
]	O
[	O
2	int
]	O
=	O
{	O
{	O
3	int
,	O
3	int
}	O
,	O
{	O
3	int
,	O
4	int
}	O
,	O
{	O
4	int
,	O
3	int
}	O
,	O
{	O
4	int
,	O
4	int
}	O
,	O
{	O
5	int
,	O
3	int
}	O
,	O
{	O
3	int
,	O
5	int
}	O
,	O
{	O
5	int
,	O
4	int
}	O
,	O
{	O
4	int
,	O
5	int
}	O
,	O
}	O
;	O
static	O
int	O
small_board	array(int)
[	O
]	O
=	O
{	O
50	int
,	O
18	int
,	O
17	int
,	O
15	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
}	O
;	O
static	O
int	O
medium_board	array(int)
[	O
]	O
=	O
{	O
30	int
,	O
20	int
,	O
20	int
,	O
22	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
}	O
;	O
static	O
int	O
large_board	array(int)
[	O
]	O
=	O
{	O
15	int
,	O
15	int
,	O
15	int
,	O
35	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
}	O
;	O
static	O
void	O
choose_corner_move	(int,*(int),*(int))->(void)
(	O
int	O
corner	int
,	O
int	O
*	O
m	int
,	O
int	O
*	O
n	int
)	O
{	O
int	O
*	O
table	*(int)
=	O
0	int
;	O
int	O
sum_of_weights	int
=	O
0	int
;	O
int	O
i	int
;	O
int	O
q	*(struct)
;	O
if	O
(	O
board_size	int
<=	O
11	int
)	O
table	*(int)
=	O
small_board	array(int)
;	O
else	O
if	O
(	O
board_size	int
<=	O
15	int
)	O
table	*(int)
=	O
medium_board	array(int)
;	O
else	O
table	*(int)
=	O
large_board	array(int)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
8	int
;	O
i	int
++	O
)	O
sum_of_weights	int
+=	O
table	*(int)
[	O
i	int
]	O
;	O
q	*(struct)
=	O
gg_rand	()->(int)
(	O
)	O
%	O
sum_of_weights	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
8	int
;	O
i	int
++	O
)	O
{	O
q	*(struct)
-=	O
table	*(int)
[	O
i	int
]	O
;	O
if	O
(	O
q	*(struct)
<	O
0	int
)	O
break	O
;	O
}	O
*	O
m	int
=	O
corners	array(array(int))
[	O
i	int
]	O
[	O
0	int
]	O
;	O
*	O
n	int
=	O
corners	array(array(int))
[	O
i	int
]	O
[	O
1	int
]	O
;	O
switch	O
(	O
corner	int
)	O
{	O
case	O
UPPER_LEFT	int
:	O
*	O
m	int
=	O
*	O
m	int
-	O
1	int
;	O
*	O
n	int
=	O
*	O
n	int
-	O
1	int
;	O
break	O
;	O
case	O
UPPER_RIGHT	int
:	O
*	O
m	int
=	O
*	O
m	int
-	O
1	int
;	O
*	O
n	int
=	O
board_size	int
-	O
*	O
n	int
;	O
break	O
;	O
case	O
LOWER_LEFT	int
:	O
*	O
m	int
=	O
board_size	int
-	O
*	O
m	int
;	O
*	O
n	int
=	O
*	O
n	int
-	O
1	int
;	O
break	O
;	O
case	O
LOWER_RIGHT	int
:	O
*	O
m	int
=	O
board_size	int
-	O
*	O
m	int
;	O
*	O
n	int
=	O
board_size	int
-	O
*	O
n	int
;	O
break	O
;	O
}	O
}	O
static	O
void	O
announce_move	(int,int,int)->(void)
(	O
int	O
move	*(int)
,	O
int	O
value	*(char)
,	O
int	O
color	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
board	*(char)
[	O
move	*(int)
]	O
!=	O
EMPTY	int
)	O
return	O
;	O
if	O
(	O
horizontally_symmetric	int
)	O
{	O
i	int
=	O
I	O
(	O
move	*(int)
)	O
;	O
j	int
=	O
J	O
(	O
move	*(int)
)	O
;	O
if	O
(	O
(	O
2	int
*	O
j	int
<	O
board_size	int
-	O
1	int
)	O
^	O
(	O
color	int
==	O
WHITE	int
)	O
)	O
move	*(int)
=	O
POS	O
(	O
i	int
,	O
board_size	int
-	O
1	int
-	O
j	int
)	O
;	O
}	O
if	O
(	O
vertically_symmetric	int
)	O
{	O
i	int
=	O
I	O
(	O
move	*(int)
)	O
;	O
j	int
=	O
J	O
(	O
move	*(int)
)	O
;	O
if	O
(	O
(	O
2	int
*	O
i	int
>	O
board_size	int
-	O
1	int
)	O
^	O
(	O
color	int
==	O
WHITE	int
)	O
)	O
move	*(int)
=	O
POS	O
(	O
board_size	int
-	O
1	int
-	O
i	int
,	O
j	int
)	O
;	O
}	O
if	O
(	O
diagonally_symmetric	int
)	O
{	O
i	int
=	O
I	O
(	O
move	*(int)
)	O
;	O
j	int
=	O
J	O
(	O
move	*(int)
)	O
;	O
if	O
(	O
(	O
board_size	int
-	O
1	int
-	O
j	int
>	O
i	int
)	O
^	O
(	O
color	int
==	O
WHITE	int
)	O
)	O
move	*(int)
=	O
POS	O
(	O
board_size	int
-	O
1	int
-	O
j	int
,	O
board_size	int
-	O
1	int
-	O
i	int
)	O
;	O
}	O
if	O
(	O
set_minimum_move_value	(int,float)->(int)
(	O
move	*(int)
,	O
value	*(char)
)	O
)	O
TRACE	O
(	O
"Fuseki Player suggests %1m with value %d\n"	*(char)
,	O
move	*(int)
,	O
value	*(char)
)	O
;	O
}	O
static	O
int	O
fuseki_moves	array(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
static	O
int	O
fuseki_value	array(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
static	O
int	O
num_fuseki_moves	int
;	O
static	O
int	O
fuseki_total_value	int
;	O
static	O
void	O
fuseki_callback	(int,*(struct(struct(array(long)),int,*(char),int,int)),int)->(void)
(	O
int	O
move	*(int)
,	O
struct	O
fullboard_pattern	struct(struct(array(long)),int,*(char),int,int)
*	O
pattern	*(struct)
,	O
int	O
ll	int
)	O
{	O
TRACE	O
(	O
"Fuseki database move at %1m with relative weight %d, pattern %s+%d\n"	*(char)
,	O
move	*(int)
,	O
pattern	*(struct)
->	O
value	*(char)
,	O
pattern	*(struct)
->	O
name	short
,	O
ll	int
)	O
;	O
fuseki_moves	array(int)
[	O
num_fuseki_moves	int
]	O
=	O
move	*(int)
;	O
fuseki_value	array(int)
[	O
num_fuseki_moves	int
]	O
=	O
pattern	*(struct)
->	O
value	*(char)
;	O
fuseki_total_value	int
+=	O
pattern	*(struct)
->	O
value	*(char)
;	O
num_fuseki_moves	int
++	O
;	O
}	O
static	O
int	O
search_fuseki_database	(int)->(int)
(	O
int	O
color	int
)	O
{	O
struct	O
fullboard_pattern	struct(struct(array(long)),int,*(char),int,int)
*	O
database	*(struct)
;	O
int	O
q	*(struct)
;	O
int	O
k	int
;	O
if	O
(	O
stones_on_board	(int)->(int)
(	O
BLACK	int
|	O
WHITE	int
)	O
>	O
MAX_FUSEKI_DATABASE_STONES	int
)	O
return	O
0	int
;	O
if	O
(	O
board_size	int
==	O
9	int
)	O
database	*(struct)
=	O
fuseki9	array(struct(struct(array(long)),int,*(char),int,int))
;	O
else	O
if	O
(	O
board_size	int
==	O
13	int
)	O
database	*(struct)
=	O
fuseki13	array(struct(struct(array(long)),int,*(char),int,int))
;	O
else	O
if	O
(	O
board_size	int
==	O
19	int
)	O
database	*(struct)
=	O
fuseki19	array(struct(struct(array(long)),int,*(char),int,int))
;	O
else	O
return	O
0	int
;	O
num_fuseki_moves	int
=	O
0	int
;	O
fuseki_total_value	int
=	O
0	int
;	O
fullboard_matchpat	(*((int,*(struct),int)->(void)),int,*(struct))->(void)
(	O
fuseki_callback	(int,*(struct(struct(array(long)),int,*(char),int,int)),int)->(void)
,	O
color	int
,	O
database	*(struct)
)	O
;	O
if	O
(	O
num_fuseki_moves	int
==	O
0	int
)	O
return	O
0	int
;	O
q	*(struct)
=	O
gg_rand	()->(int)
(	O
)	O
%	O
fuseki_total_value	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_fuseki_moves	int
;	O
k	int
++	O
)	O
{	O
q	*(struct)
-=	O
fuseki_value	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
q	*(struct)
<	O
0	int
)	O
break	O
;	O
}	O
gg_assert	O
(	O
k	int
<	O
num_fuseki_moves	int
)	O
;	O
announce_move	(int,int,int)->(void)
(	O
fuseki_moves	array(int)
[	O
k	int
]	O
,	O
75	int
,	O
color	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_fuseki_moves	int
;	O
k	int
++	O
)	O
set_minimum_move_value	(int,float)->(int)
(	O
fuseki_moves	array(int)
[	O
k	int
]	O
,	O
74	int
)	O
;	O
return	O
1	int
;	O
}	O
void	O
fuseki	(int)->(void)
(	O
int	O
color	int
)	O
{	O
int	O
i	int
=	O
-	O
1	int
;	O
int	O
j	int
=	O
-	O
1	int
;	O
int	O
width	int
;	O
int	O
empty_corner_value	int
=	O
EMPTY_CORNER_VALUE	int
*	O
board_size	int
/	O
19	int
;	O
if	O
(	O
disable_fuseki	int
)	O
return	O
;	O
set_symmetries	()->(void)
(	O
)	O
;	O
if	O
(	O
fusekidb	int
&&	O
search_fuseki_database	(int)->(int)
(	O
color	int
)	O
)	O
return	O
;	O
if	O
(	O
board_size	int
==	O
9	int
&&	O
stones_on_board	(int)->(int)
(	O
color	int
)	O
>	O
0	int
)	O
empty_corner_value	int
=	O
5	int
;	O
if	O
(	O
board_size	int
<=	O
11	int
)	O
{	O
int	O
middle	int
=	O
board_size	int
/	O
2	int
;	O
if	O
(	O
openregion	(int,int,int,int)->(int)
(	O
middle	int
-	O
2	int
,	O
middle	int
+	O
2	int
,	O
middle	int
-	O
2	int
,	O
middle	int
+	O
2	int
)	O
)	O
{	O
announce_move	(int,int,int)->(void)
(	O
POS	O
(	O
middle	int
,	O
middle	int
)	O
,	O
45	int
,	O
color	int
)	O
;	O
}	O
}	O
if	O
(	O
board_size	int
<	O
9	int
)	O
return	O
;	O
if	O
(	O
board_size	int
>=	O
18	int
)	O
width	int
=	O
8	int
;	O
else	O
if	O
(	O
board_size	int
==	O
9	int
)	O
width	int
=	O
5	int
;	O
else	O
width	int
=	O
board_size	int
/	O
2	int
;	O
if	O
(	O
openregion	(int,int,int,int)->(int)
(	O
0	int
,	O
width	int
-	O
1	int
,	O
board_size	int
-	O
width	int
,	O
board_size	int
-	O
1	int
)	O
)	O
{	O
choose_corner_move	(int,*(int),*(int))->(void)
(	O
UPPER_RIGHT	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
announce_move	(int,int,int)->(void)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
empty_corner_value	int
,	O
color	int
)	O
;	O
}	O
if	O
(	O
openregion	(int,int,int,int)->(int)
(	O
board_size	int
-	O
width	int
,	O
board_size	int
-	O
1	int
,	O
0	int
,	O
width	int
-	O
1	int
)	O
)	O
{	O
choose_corner_move	(int,*(int),*(int))->(void)
(	O
LOWER_LEFT	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
announce_move	(int,int,int)->(void)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
empty_corner_value	int
,	O
color	int
)	O
;	O
}	O
if	O
(	O
openregion	(int,int,int,int)->(int)
(	O
board_size	int
-	O
width	int
,	O
board_size	int
-	O
1	int
,	O
board_size	int
-	O
width	int
,	O
board_size	int
-	O
1	int
)	O
)	O
{	O
choose_corner_move	(int,*(int),*(int))->(void)
(	O
LOWER_RIGHT	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
announce_move	(int,int,int)->(void)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
empty_corner_value	int
,	O
color	int
)	O
;	O
}	O
if	O
(	O
openregion	(int,int,int,int)->(int)
(	O
0	int
,	O
width	int
-	O
1	int
,	O
0	int
,	O
width	int
-	O
1	int
)	O
)	O
{	O
choose_corner_move	(int,*(int),*(int))->(void)
(	O
UPPER_LEFT	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
announce_move	(int,int,int)->(void)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
empty_corner_value	int
,	O
color	int
)	O
;	O
}	O
}	O
