int	O
*	O
register_fresh_stat	(*(struct),*(int))->(*(int))
(	O
struct	O
node	O
*	O
np	*(struct)
,	O
int	O
*	O
p	*(int)
)	O
{	O
int	O
*	O
ret	*(int)
;	O
ret	*(int)
=	O
xdr_decode_fattr	(*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn_stat	O
)	O
;	O
np	*(struct)
->	O
nn	O
->	O
stat_updated	long
=	O
mapped_time	*(struct)
->	O
seconds	O
;	O
switch	O
(	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
)	O
{	O
case	O
NOT_POSSIBLE	int
:	O
case	O
POSSIBLE	int
:	O
break	O
;	O
case	O
SYMLINK	int
:	O
np	*(struct)
->	O
nn_stat	O
.	O
st_size	long
=	O
strlen	O
(	O
np	*(struct)
->	O
nn	O
->	O
transarg	union(*(char),long)
.	O
name	*(char)
)	O
;	O
np	*(struct)
->	O
nn_stat	O
.	O
st_mode	int
=	O
(	O
(	O
np	*(struct)
->	O
nn_stat	O
.	O
st_mode	int
&	O
~	O
S_IFMT	O
)	O
|	O
S_IFLNK	O
)	O
;	O
break	O
;	O
case	O
CHRDEV	int
:	O
np	*(struct)
->	O
nn_stat	O
.	O
st_rdev	long
=	O
np	*(struct)
->	O
nn	O
->	O
transarg	union(*(char),long)
.	O
indexes	long
;	O
np	*(struct)
->	O
nn_stat	O
.	O
st_mode	int
=	O
(	O
(	O
np	*(struct)
->	O
nn_stat	O
.	O
st_mode	int
&	O
~	O
S_IFMT	O
)	O
|	O
S_IFCHR	O
)	O
;	O
break	O
;	O
case	O
BLKDEV	int
:	O
np	*(struct)
->	O
nn_stat	O
.	O
st_rdev	long
=	O
np	*(struct)
->	O
nn	O
->	O
transarg	union(*(char),long)
.	O
indexes	long
;	O
np	*(struct)
->	O
nn_stat	O
.	O
st_mode	int
=	O
(	O
(	O
np	*(struct)
->	O
nn_stat	O
.	O
st_mode	int
&	O
~	O
S_IFMT	O
)	O
|	O
S_IFBLK	O
)	O
;	O
break	O
;	O
case	O
FIFO	int
:	O
np	*(struct)
->	O
nn_stat	O
.	O
st_mode	int
=	O
(	O
(	O
np	*(struct)
->	O
nn_stat	O
.	O
st_mode	int
&	O
~	O
S_IFMT	O
)	O
|	O
S_IFIFO	O
)	O
;	O
break	O
;	O
case	O
SOCK	int
:	O
np	*(struct)
->	O
nn_stat	O
.	O
st_mode	int
=	O
(	O
(	O
np	*(struct)
->	O
nn_stat	O
.	O
st_mode	int
&	O
~	O
S_IFMT	O
)	O
|	O
S_IFSOCK	O
)	O
;	O
break	O
;	O
}	O
np	*(struct)
->	O
nn_stat	O
.	O
st_fsid	O
=	O
getpid	()->(int)
(	O
)	O
;	O
np	*(struct)
->	O
nn_stat	O
.	O
st_fstype	O
=	O
FSTYPE_NFS	O
;	O
np	*(struct)
->	O
nn_stat	O
.	O
st_gen	O
=	O
0	int
;	O
np	*(struct)
->	O
nn_stat	O
.	O
st_author	O
=	O
np	*(struct)
->	O
nn_stat	O
.	O
st_uid	int
;	O
np	*(struct)
->	O
nn_stat	O
.	O
st_flags	O
=	O
0	int
;	O
np	*(struct)
->	O
nn_translated	O
=	O
np	*(struct)
->	O
nn_stat	O
.	O
st_mode	int
&	O
S_IFMT	O
;	O
return	O
ret	*(int)
;	O
}	O
int	O
*	O
process_returned_stat	(*(struct),*(int),int)->(*(int))
(	O
struct	O
node	O
*	O
np	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
mod	int
)	O
{	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
return	O
register_fresh_stat	(*(struct),*(int))->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
)	O
;	O
else	O
{	O
int	O
attrs_exist	int
;	O
attrs_exist	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
attrs_exist	int
)	O
p	*(int)
=	O
register_fresh_stat	(*(struct),*(int))->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
)	O
;	O
else	O
if	O
(	O
mod	int
)	O
np	*(struct)
->	O
nn	O
->	O
stat_updated	long
=	O
0	int
;	O
return	O
p	*(int)
;	O
}	O
}	O
int	O
*	O
process_wcc_stat	(*(struct),*(int),int)->(*(int))
(	O
struct	O
node	O
*	O
np	*(struct)
,	O
int	O
*	O
p	*(int)
,	O
int	O
mod	int
)	O
{	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
return	O
register_fresh_stat	(*(struct),*(int))->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
)	O
;	O
else	O
{	O
int	O
attrs_exist	int
;	O
attrs_exist	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
attrs_exist	int
)	O
{	O
p	*(int)
+=	O
2	int
*	O
sizeof	O
(	O
int	O
)	O
;	O
p	*(int)
+=	O
2	int
*	O
sizeof	O
(	O
int	O
)	O
;	O
p	*(int)
+=	O
2	int
*	O
sizeof	O
(	O
int	O
)	O
;	O
}	O
return	O
process_returned_stat	(*(struct),*(int),int)->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
,	O
mod	int
)	O
;	O
}	O
}	O
error_t	int
netfs_validate_stat	(*(struct),*(struct))->(int)
(	O
struct	O
node	O
*	O
np	*(struct)
,	O
struct	O
iouser	O
*	O
cred	*(struct)
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
if	O
(	O
mapped_time	*(struct)
->	O
seconds	O
-	O
np	*(struct)
->	O
nn	O
->	O
stat_updated	long
<	O
stat_timeout	int
)	O
return	O
0	int
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_GETATTR	O
(	O
protocol_version	int
)	O
,	O
(	O
struct	O
iouser	O
*	O
)	O
-	O
1	int
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
np	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
}	O
if	O
(	O
!	O
err	int
)	O
register_fresh_stat	(*(struct),*(int))->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
)	O
;	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_chown	(*(struct),*(struct),int,int)->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
uid_t	int
uid	int
,	O
gid_t	int
gid	int
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_SETATTR	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
np	*(struct)
,	O
gid	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_sattr_ids	(*(int),int,int)->(*(int))
(	O
p	*(int)
,	O
uid	int
,	O
gid	int
)	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
0	int
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
!	O
err	int
||	O
protocol_version	int
==	O
3	int
)	O
p	*(int)
=	O
process_wcc_stat	(*(struct),*(int),int)->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
,	O
!	O
err	int
)	O
;	O
}	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_chauthor	(*(struct),*(struct),int)->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
rp	*(struct)
,	O
uid_t	int
author	int
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
error_t	int
netfs_attempt_chmod	(*(struct),*(struct),int)->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
mode_t	int
mode	int
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
if	O
(	O
(	O
mode	int
&	O
S_IFMT	O
)	O
!=	O
0	int
)	O
{	O
err	int
=	O
netfs_validate_stat	(*(struct),*(struct))->(int)
(	O
np	*(struct)
,	O
cred	*(struct)
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
if	O
(	O
(	O
mode	int
&	O
S_IFMT	O
)	O
!=	O
(	O
np	*(struct)
->	O
nn_stat	O
.	O
st_mode	int
&	O
S_IFMT	O
)	O
)	O
{	O
char	O
*	O
f	*(char)
=	O
0	int
;	O
if	O
(	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
==	O
NOT_POSSIBLE	int
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
==	O
SYMLINK	int
)	O
f	*(char)
=	O
np	*(struct)
->	O
nn	O
->	O
transarg	union(*(char),long)
.	O
name	*(char)
;	O
switch	O
(	O
mode	int
&	O
S_IFMT	O
)	O
{	O
default	O
:	O
return	O
EOPNOTSUPP	int
;	O
case	O
S_IFIFO	O
:	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
=	O
FIFO	int
;	O
np	*(struct)
->	O
nn	O
->	O
stat_updated	long
=	O
0	int
;	O
break	O
;	O
case	O
S_IFSOCK	O
:	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
=	O
SOCK	int
;	O
np	*(struct)
->	O
nn	O
->	O
stat_updated	long
=	O
0	int
;	O
}	O
if	O
(	O
f	*(char)
)	O
free	()->(int)
(	O
f	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_SETATTR	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
np	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_sattr_mode	(*(int),int)->(*(int))
(	O
p	*(int)
,	O
mode	int
)	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
0	int
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
!	O
err	int
||	O
protocol_version	int
==	O
3	int
)	O
p	*(int)
=	O
process_wcc_stat	(*(struct),*(int),int)->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
,	O
!	O
err	int
)	O
;	O
}	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_chflags	(*(struct),*(struct),int)->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
int	O
flags	int
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
error_t	int
netfs_attempt_utimes	(*(struct),*(struct),*(struct(long,long)),*(struct(long,long)))->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
struct	O
timespec	struct(long,long)
*	O
atime	*(struct(long,long))
,	O
struct	O
timespec	struct(long,long)
*	O
mtime	*(struct(long,long))
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
struct	O
timeval	struct(long,long)
tv	struct(long,long)
;	O
struct	O
timespec	struct(long,long)
current	struct(long,long)
;	O
if	O
(	O
!	O
atime	*(struct(long,long))
||	O
!	O
mtime	*(struct(long,long))
)	O
{	O
maptime_read	()->(int)
(	O
mapped_time	*(struct)
,	O
&	O
tv	struct(long,long)
)	O
;	O
current	struct(long,long)
.	O
tv_sec	long
=	O
tv	struct(long,long)
.	O
tv_sec	long
;	O
current	struct(long,long)
.	O
tv_nsec	long
=	O
tv	struct(long,long)
.	O
tv_usec	long
*	O
1000	int
;	O
}	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_SETATTR	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
np	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_sattr_times	(*(int),*(struct(long,long)),*(struct(long,long)))->(*(int))
(	O
p	*(int)
,	O
atime	*(struct(long,long))
?	O
:	O
&	O
current	struct(long,long)
,	O
mtime	*(struct(long,long))
?	O
:	O
&	O
current	struct(long,long)
)	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
0	int
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
!	O
err	int
||	O
protocol_version	int
==	O
3	int
)	O
p	*(int)
=	O
process_wcc_stat	(*(struct),*(int),int)->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
,	O
!	O
err	int
)	O
;	O
}	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_set_size	(*(struct),*(struct),long)->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
off_t	long
size	long
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_SETATTR	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
np	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_sattr_size	(*(int),long)->(*(int))
(	O
p	*(int)
,	O
size	long
)	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
0	int
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
!	O
err	int
||	O
protocol_version	int
==	O
3	int
)	O
p	*(int)
=	O
process_wcc_stat	(*(struct),*(int),int)->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
,	O
!	O
err	int
)	O
;	O
}	O
if	O
(	O
err	int
==	O
EACCES	int
)	O
{	O
int	O
error	int
=	O
netfs_validate_stat	(*(struct),*(struct))->(int)
(	O
np	*(struct)
,	O
cred	*(struct)
)	O
;	O
if	O
(	O
!	O
error	int
&&	O
np	*(struct)
->	O
nn_stat	O
.	O
st_size	long
==	O
size	long
)	O
err	int
=	O
0	int
;	O
}	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_statfs	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
struct	O
statfs	O
*	O
st	*(struct)
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFS2PROC_STATFS	int
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
np	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
}	O
if	O
(	O
!	O
err	int
)	O
{	O
p	*(int)
++	O
;	O
st	*(struct)
->	O
f_bsize	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
st	*(struct)
->	O
f_blocks	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
st	*(struct)
->	O
f_bfree	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
st	*(struct)
->	O
f_bavail	O
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
st	*(struct)
->	O
f_type	O
=	O
FSTYPE_NFS	O
;	O
st	*(struct)
->	O
f_files	O
=	O
0	int
;	O
st	*(struct)
->	O
f_ffree	O
=	O
0	int
;	O
st	*(struct)
->	O
f_fsid	O
=	O
getpid	()->(int)
(	O
)	O
;	O
st	*(struct)
->	O
f_namelen	O
=	O
0	int
;	O
}	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_sync	(*(struct),*(struct),int)->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
int	O
wait	int
)	O
{	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_syncfs	(*(struct),int)->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
int	O
wait	int
)	O
{	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_read	(*(struct),*(struct),long,*(long),*(void))->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
off_t	long
offset	long
,	O
size_t	long
*	O
len	long
,	O
void	O
*	O
data	array(char)
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
size_t	long
trans_len	long
;	O
error_t	int
err	int
;	O
size_t	long
amt	long
,	O
thisamt	long
;	O
int	O
eof	int
;	O
for	O
(	O
amt	long
=	O
*	O
len	long
;	O
amt	long
;	O
)	O
{	O
thisamt	long
=	O
amt	long
;	O
if	O
(	O
thisamt	long
>	O
read_size	int
)	O
thisamt	long
=	O
read_size	int
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_READ	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
np	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
offset	long
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
thisamt	long
)	O
;	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
0	int
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
!	O
err	int
||	O
protocol_version	int
==	O
3	int
)	O
p	*(int)
=	O
process_returned_stat	(*(struct),*(int),int)->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
,	O
!	O
err	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
trans_len	long
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
trans_len	long
>	O
thisamt	long
)	O
trans_len	long
=	O
thisamt	long
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
{	O
eof	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
}	O
else	O
eof	int
=	O
(	O
trans_len	long
<	O
thisamt	long
)	O
;	O
memcpy	O
(	O
data	array(char)
,	O
p	*(int)
,	O
trans_len	long
)	O
;	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
data	array(char)
+=	O
trans_len	long
;	O
offset	long
+=	O
trans_len	long
;	O
amt	long
-=	O
trans_len	long
;	O
if	O
(	O
eof	int
)	O
{	O
*	O
len	long
-=	O
amt	long
;	O
return	O
0	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_write	(*(struct),*(struct),long,*(long),*(void))->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
off_t	long
offset	long
,	O
size_t	long
*	O
len	long
,	O
void	O
*	O
data	array(char)
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
size_t	long
amt	long
,	O
thisamt	long
;	O
size_t	long
count	long
;	O
for	O
(	O
amt	long
=	O
*	O
len	long
;	O
amt	long
;	O
)	O
{	O
thisamt	long
=	O
amt	long
;	O
if	O
(	O
thisamt	long
>	O
write_size	int
)	O
thisamt	long
=	O
write_size	int
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_WRITE	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
thisamt	long
,	O
&	O
rpcbuf	*(void)
,	O
np	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
0	int
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
offset	long
)	O
;	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
0	int
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
FILE_SYNC	int
)	O
;	O
p	*(int)
=	O
xdr_encode_data	(*(int),*(char),long)->(*(int))
(	O
p	*(int)
,	O
data	array(char)
,	O
thisamt	long
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
!	O
err	int
||	O
protocol_version	int
==	O
3	int
)	O
p	*(int)
=	O
process_wcc_stat	(*(struct),*(int),int)->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
,	O
!	O
err	int
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
{	O
count	long
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
p	*(int)
++	O
;	O
p	*(int)
+=	O
NFS3_WRITEVERFSIZE	int
/	O
sizeof	O
(	O
int	O
)	O
;	O
}	O
else	O
count	long
=	O
thisamt	long
;	O
amt	long
-=	O
count	long
;	O
data	array(char)
+=	O
count	long
;	O
offset	long
+=	O
count	long
;	O
}	O
}	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
if	O
(	O
err	int
==	O
EINTR	int
&&	O
amt	long
!=	O
*	O
len	long
)	O
{	O
*	O
len	long
-=	O
amt	long
;	O
return	O
0	int
;	O
}	O
if	O
(	O
err	int
)	O
{	O
*	O
len	long
=	O
0	int
;	O
return	O
err	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
error_t	int
verify_nonexistent	(*(struct),*(struct),*(char))->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
dir	*(struct)
,	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
assert	()->(int)
(	O
protocol_version	int
==	O
2	int
)	O
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_LOOKUP	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
dir	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
dir	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
name	*(char)
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
}	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
return	O
EEXIST	int
;	O
else	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_lookup	(*(struct),*(struct),*(char),*(*(struct)))->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
char	O
*	O
name	*(char)
,	O
struct	O
node	O
*	O
*	O
newnp	*(*(struct))
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
char	O
dirhandle	array(char)
[	O
NFS3_FHSIZE	int
]	O
;	O
size_t	long
dirlen	long
;	O
*	O
newnp	*(*(struct))
=	O
check_lookup_cache	(*(struct),*(char))->(*(struct))
(	O
np	*(struct)
,	O
name	*(char)
)	O
;	O
if	O
(	O
*	O
newnp	*(*(struct))
)	O
{	O
if	O
(	O
*	O
newnp	*(*(struct))
==	O
(	O
struct	O
node	O
*	O
)	O
-	O
1	int
)	O
{	O
*	O
newnp	*(*(struct))
=	O
0	int
;	O
return	O
ENOENT	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_LOOKUP	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
np	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
name	*(char)
)	O
;	O
dirlen	long
=	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
.	O
size	long
;	O
memcpy	O
(	O
dirhandle	array(char)
,	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
.	O
data	array(char)
,	O
dirlen	long
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
p	*(int)
=	O
xdr_decode_fhandle	(*(int),*(*(struct)))->(*(int))
(	O
p	*(int)
,	O
newnp	*(*(struct))
)	O
;	O
p	*(int)
=	O
process_returned_stat	(*(struct),*(int),int)->(*(int))
(	O
*	O
newnp	*(*(struct))
,	O
p	*(int)
,	O
1	int
)	O
;	O
}	O
if	O
(	O
err	int
)	O
*	O
newnp	*(*(struct))
=	O
0	int
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
{	O
if	O
(	O
*	O
newnp	*(*(struct))
)	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
(	O
*	O
newnp	*(*(struct))
)	O
->	O
lock	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
p	*(int)
=	O
process_returned_stat	(*(struct),*(int),int)->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
,	O
0	int
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
*	O
newnp	*(*(struct))
)	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
(	O
*	O
newnp	*(*(struct))
)	O
->	O
lock	O
)	O
;	O
}	O
}	O
else	O
*	O
newnp	*(*(struct))
=	O
0	int
;	O
enter_lookup_cache	(*(char),long,*(struct),*(char))->(void)
(	O
dirhandle	array(char)
,	O
dirlen	long
,	O
*	O
newnp	*(*(struct))
,	O
name	*(char)
)	O
;	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_mkdir	(*(struct),*(struct),*(char),int)->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
char	O
*	O
name	*(char)
,	O
mode_t	int
mode	int
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
uid_t	int
owner	int
;	O
struct	O
node	O
*	O
newnp	*(*(struct))
;	O
if	O
(	O
cred	*(struct)
->	O
uids	O
->	O
num	O
)	O
owner	int
=	O
cred	*(struct)
->	O
uids	O
->	O
ids	O
[	O
0	int
]	O
;	O
else	O
{	O
err	int
=	O
netfs_validate_stat	(*(struct),*(struct))->(int)
(	O
np	*(struct)
,	O
cred	*(struct)
)	O
;	O
owner	int
=	O
err	int
?	O
0	int
:	O
np	*(struct)
->	O
nn_stat	O
.	O
st_uid	int
;	O
mode	int
&=	O
~	O
S_ISUID	O
;	O
}	O
purge_lookup_cache	(*(struct),*(char),long)->(void)
(	O
np	*(struct)
,	O
name	*(char)
,	O
strlen	O
(	O
name	*(char)
)	O
)	O
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_MKDIR	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
np	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
name	*(char)
)	O
;	O
p	*(int)
=	O
xdr_encode_create_state	(*(int),int,int)->(*(int))
(	O
p	*(int)
,	O
mode	int
,	O
owner	int
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
}	O
if	O
(	O
!	O
err	int
)	O
{	O
p	*(int)
=	O
xdr_decode_fhandle	(*(int),*(*(struct)))->(*(int))
(	O
p	*(int)
,	O
&	O
newnp	*(*(struct))
)	O
;	O
p	*(int)
=	O
process_returned_stat	(*(struct),*(int),int)->(*(int))
(	O
newnp	*(*(struct))
,	O
p	*(int)
,	O
1	int
)	O
;	O
if	O
(	O
!	O
netfs_validate_stat	(*(struct),*(struct))->(int)
(	O
newnp	*(*(struct))
,	O
(	O
struct	O
iouser	O
*	O
)	O
-	O
1	int
)	O
&&	O
newnp	*(*(struct))
->	O
nn_stat	O
.	O
st_uid	int
!=	O
owner	int
)	O
netfs_attempt_chown	(*(struct),*(struct),int,int)->(int)
(	O
(	O
struct	O
iouser	O
*	O
)	O
-	O
1	int
,	O
newnp	*(*(struct))
,	O
owner	int
,	O
newnp	*(*(struct))
->	O
nn_stat	O
.	O
st_gid	int
)	O
;	O
netfs_nput	()->(int)
(	O
newnp	*(*(struct))
)	O
;	O
}	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_rmdir	(*(struct),*(struct),*(char))->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
purge_lookup_cache	(*(struct),*(char),long)->(void)
(	O
np	*(struct)
,	O
name	*(char)
,	O
strlen	O
(	O
name	*(char)
)	O
)	O
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_RMDIR	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
np	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
name	*(char)
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
p	*(int)
=	O
process_wcc_stat	(*(struct),*(int),int)->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
,	O
!	O
err	int
)	O
;	O
}	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_link	(*(struct),*(struct),*(struct),*(char),int)->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
dir	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
char	O
*	O
name	*(char)
,	O
int	O
excl	int
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
!	O
excl	int
)	O
{	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
netfs_attempt_unlink	()->(int)
(	O
cred	*(struct)
,	O
dir	*(struct)
,	O
name	*(char)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
}	O
switch	O
(	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
)	O
{	O
case	O
POSSIBLE	int
:	O
case	O
NOT_POSSIBLE	int
:	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_LINK	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
dir	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
return	O
errno	O
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
purge_lookup_cache	(*(struct),*(char),long)->(void)
(	O
dir	*(struct)
,	O
name	*(char)
,	O
strlen	O
(	O
name	*(char)
)	O
)	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
dir	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
name	*(char)
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
break	O
;	O
case	O
SYMLINK	int
:	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_SYMLINK	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
dir	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
return	O
errno	O
;	O
}	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
dir	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
name	*(char)
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
err	int
=	O
netfs_validate_stat	(*(struct),*(struct))->(int)
(	O
np	*(struct)
,	O
cred	*(struct)
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
{	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
np	*(struct)
->	O
nn	O
->	O
transarg	union(*(char),long)
.	O
name	*(char)
)	O
;	O
p	*(int)
=	O
xdr_encode_sattr_stat	(*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn_stat	O
)	O
;	O
}	O
else	O
{	O
p	*(int)
=	O
xdr_encode_sattr_stat	(*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn_stat	O
)	O
;	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
np	*(struct)
->	O
nn	O
->	O
transarg	union(*(char),long)
.	O
name	*(char)
)	O
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
purge_lookup_cache	(*(struct),*(char),long)->(void)
(	O
dir	*(struct)
,	O
name	*(char)
,	O
strlen	O
(	O
name	*(char)
)	O
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
protocol_version	int
==	O
2	int
&&	O
!	O
err	int
)	O
{	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_LOOKUP	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
dir	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
return	O
errno	O
;	O
}	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
dir	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
name	*(char)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
}	O
if	O
(	O
!	O
err	int
)	O
{	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
p	*(int)
=	O
recache_handle	(*(int),*(struct))->(*(int))
(	O
p	*(int)
,	O
np	*(struct)
)	O
;	O
p	*(int)
=	O
process_returned_stat	(*(struct),*(int),int)->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
,	O
1	int
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
}	O
if	O
(	O
err	int
)	O
err	int
=	O
EGRATUITOUS	O
;	O
}	O
else	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
{	O
if	O
(	O
!	O
err	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
p	*(int)
=	O
recache_handle	(*(int),*(struct))->(*(int))
(	O
p	*(int)
,	O
np	*(struct)
)	O
;	O
p	*(int)
=	O
process_returned_stat	(*(struct),*(int),int)->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
,	O
1	int
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
}	O
p	*(int)
=	O
process_wcc_stat	(*(struct),*(int),int)->(*(int))
(	O
dir	*(struct)
,	O
p	*(int)
,	O
!	O
err	int
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
}	O
else	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
}	O
else	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
break	O
;	O
case	O
CHRDEV	int
:	O
case	O
BLKDEV	int
:	O
case	O
FIFO	int
:	O
case	O
SOCK	int
:	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
{	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
err	int
=	O
verify_nonexistent	(*(struct),*(struct),*(char))->(int)
(	O
cred	*(struct)
,	O
dir	*(struct)
,	O
name	*(char)
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_CREATE	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
dir	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
return	O
errno	O
;	O
}	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
dir	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
name	*(char)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
err	int
=	O
netfs_validate_stat	(*(struct),*(struct))->(int)
(	O
np	*(struct)
,	O
cred	*(struct)
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
p	*(int)
=	O
xdr_encode_sattr_stat	(*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn_stat	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
purge_lookup_cache	(*(struct),*(char),long)->(void)
(	O
dir	*(struct)
,	O
name	*(char)
,	O
strlen	O
(	O
name	*(char)
)	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
}	O
if	O
(	O
!	O
err	int
)	O
{	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
p	*(int)
=	O
recache_handle	(*(int),*(struct))->(*(int))
(	O
p	*(int)
,	O
np	*(struct)
)	O
;	O
register_fresh_stat	(*(struct),*(int))->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
}	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
}	O
else	O
{	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFS3PROC_MKNOD	int
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
dir	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
return	O
errno	O
;	O
}	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
dir	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
name	*(char)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
err	int
=	O
netfs_validate_stat	(*(struct),*(struct))->(int)
(	O
np	*(struct)
,	O
cred	*(struct)
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
hurd_mode_to_nfs_type	(int)->(int)
(	O
np	*(struct)
->	O
nn_stat	O
.	O
st_mode	int
)	O
)	O
;	O
p	*(int)
=	O
xdr_encode_sattr_stat	(*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn_stat	O
)	O
;	O
if	O
(	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
==	O
BLKDEV	int
||	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
==	O
CHRDEV	int
)	O
{	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
major	()->(int)
(	O
np	*(struct)
->	O
nn_stat	O
.	O
st_rdev	long
)	O
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
minor	()->(int)
(	O
np	*(struct)
->	O
nn_stat	O
.	O
st_rdev	long
)	O
)	O
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
purge_lookup_cache	(*(struct),*(char),long)->(void)
(	O
dir	*(struct)
,	O
name	*(char)
,	O
strlen	O
(	O
name	*(char)
)	O
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
p	*(int)
=	O
recache_handle	(*(int),*(struct))->(*(int))
(	O
p	*(int)
,	O
np	*(struct)
)	O
;	O
p	*(int)
=	O
process_returned_stat	(*(struct),*(int),int)->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
,	O
1	int
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
p	*(int)
=	O
process_wcc_stat	(*(struct),*(int),int)->(*(int))
(	O
dir	*(struct)
,	O
p	*(int)
,	O
!	O
err	int
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
}	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
==	O
SYMLINK	int
)	O
free	()->(int)
(	O
np	*(struct)
->	O
nn	O
->	O
transarg	union(*(char),long)
.	O
name	*(char)
)	O
;	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
=	O
NOT_POSSIBLE	int
;	O
if	O
(	O
np	*(struct)
->	O
nn	O
->	O
dead_dir	*(struct)
)	O
{	O
struct	O
node	O
*	O
dir	*(struct)
=	O
np	*(struct)
->	O
nn	O
->	O
dead_dir	*(struct)
;	O
char	O
*	O
name	*(char)
=	O
np	*(struct)
->	O
nn	O
->	O
dead_name	*(char)
;	O
np	*(struct)
->	O
nn	O
->	O
dead_dir	*(struct)
=	O
0	int
;	O
np	*(struct)
->	O
nn	O
->	O
dead_name	*(char)
=	O
0	int
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
netfs_attempt_unlink	()->(int)
(	O
(	O
struct	O
iouser	O
*	O
)	O
-	O
1	int
,	O
dir	*(struct)
,	O
name	*(char)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
}	O
else	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_mkfile	(*(struct),*(struct),int,*(*(struct)))->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
dir	*(struct)
,	O
mode_t	int
mode	int
,	O
struct	O
node	O
*	O
*	O
newnp	*(*(struct))
)	O
{	O
error_t	int
err	int
;	O
char	O
*	O
name	*(char)
;	O
static	O
int	O
n	int
=	O
0	int
;	O
name	*(char)
=	O
malloc	O
(	O
50	int
)	O
;	O
if	O
(	O
!	O
name	*(char)
)	O
return	O
ENOMEM	int
;	O
do	O
{	O
sprintf	O
(	O
name	*(char)
,	O
".nfstmpgnu.%d"	*(char)
,	O
n	int
++	O
)	O
;	O
err	int
=	O
netfs_attempt_create_file	()->(int)
(	O
cred	*(struct)
,	O
dir	*(struct)
,	O
name	*(char)
,	O
mode	int
,	O
newnp	*(*(struct))
)	O
;	O
if	O
(	O
err	int
==	O
EEXIST	int
)	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
}	O
while	O
(	O
err	int
==	O
EEXIST	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
free	()->(int)
(	O
name	*(char)
)	O
;	O
return	O
err	int
;	O
}	O
assert	()->(int)
(	O
!	O
(	O
*	O
newnp	*(*(struct))
)	O
->	O
nn	O
->	O
dead_dir	*(struct)
)	O
;	O
assert	()->(int)
(	O
!	O
(	O
*	O
newnp	*(*(struct))
)	O
->	O
nn	O
->	O
dead_name	*(char)
)	O
;	O
netfs_nref	()->(int)
(	O
dir	*(struct)
)	O
;	O
(	O
*	O
newnp	*(*(struct))
)	O
->	O
nn	O
->	O
dead_dir	*(struct)
=	O
dir	*(struct)
;	O
(	O
*	O
newnp	*(*(struct))
)	O
->	O
nn	O
->	O
dead_name	*(char)
=	O
name	*(char)
;	O
if	O
(	O
(	O
*	O
newnp	*(*(struct))
)	O
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
==	O
NOT_POSSIBLE	int
)	O
(	O
*	O
newnp	*(*(struct))
)	O
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
=	O
POSSIBLE	int
;	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_create_file	()->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
char	O
*	O
name	*(char)
,	O
mode_t	int
mode	int
,	O
struct	O
node	O
*	O
*	O
newnp	*(*(struct))
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
uid_t	int
owner	int
;	O
if	O
(	O
cred	*(struct)
->	O
uids	O
->	O
num	O
)	O
owner	int
=	O
cred	*(struct)
->	O
uids	O
->	O
ids	O
[	O
0	int
]	O
;	O
else	O
{	O
err	int
=	O
netfs_validate_stat	(*(struct),*(struct))->(int)
(	O
np	*(struct)
,	O
cred	*(struct)
)	O
;	O
owner	int
=	O
err	int
?	O
0	int
:	O
np	*(struct)
->	O
nn_stat	O
.	O
st_uid	int
;	O
mode	int
&=	O
~	O
S_ISUID	O
;	O
}	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
{	O
err	int
=	O
verify_nonexistent	(*(struct),*(struct),*(char))->(int)
(	O
cred	*(struct)
,	O
np	*(struct)
,	O
name	*(char)
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
return	O
err	int
;	O
}	O
}	O
purge_lookup_cache	(*(struct),*(char),long)->(void)
(	O
np	*(struct)
,	O
name	*(char)
,	O
strlen	O
(	O
name	*(char)
)	O
)	O
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_CREATE	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
np	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
name	*(char)
)	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
{	O
int	O
verf	int
=	O
*	O
(	O
int	O
*	O
)	O
rpcbuf	*(void)
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
ntohl	()->(int)
(	O
EXCLUSIVE	int
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
ntohl	()->(int)
(	O
verf	int
)	O
;	O
p	*(int)
++	O
;	O
}	O
else	O
p	*(int)
=	O
xdr_encode_create_state	(*(int),int,int)->(*(int))
(	O
p	*(int)
,	O
mode	int
,	O
owner	int
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
p	*(int)
=	O
xdr_decode_fhandle	(*(int),*(*(struct)))->(*(int))
(	O
p	*(int)
,	O
newnp	*(*(struct))
)	O
;	O
p	*(int)
=	O
process_returned_stat	(*(struct),*(int),int)->(*(int))
(	O
*	O
newnp	*(*(struct))
,	O
p	*(int)
,	O
1	int
)	O
;	O
}	O
if	O
(	O
err	int
)	O
*	O
newnp	*(*(struct))
=	O
0	int
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
{	O
if	O
(	O
*	O
newnp	*(*(struct))
)	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
(	O
*	O
newnp	*(*(struct))
)	O
->	O
lock	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
p	*(int)
=	O
process_wcc_stat	(*(struct),*(int),int)->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
,	O
1	int
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
*	O
newnp	*(*(struct))
)	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
(	O
*	O
newnp	*(*(struct))
)	O
->	O
lock	O
)	O
;	O
}	O
if	O
(	O
*	O
newnp	*(*(struct))
&&	O
!	O
netfs_validate_stat	(*(struct),*(struct))->(int)
(	O
*	O
newnp	*(*(struct))
,	O
(	O
struct	O
iouser	O
*	O
)	O
-	O
1	int
)	O
&&	O
(	O
*	O
newnp	*(*(struct))
)	O
->	O
nn_stat	O
.	O
st_uid	int
!=	O
owner	int
)	O
netfs_attempt_chown	(*(struct),*(struct),int,int)->(int)
(	O
(	O
struct	O
iouser	O
*	O
)	O
-	O
1	int
,	O
*	O
newnp	*(*(struct))
,	O
owner	int
,	O
(	O
*	O
newnp	*(*(struct))
)	O
->	O
nn_stat	O
.	O
st_gid	int
)	O
;	O
}	O
else	O
*	O
newnp	*(*(struct))
=	O
0	int
;	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_unlink	()->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
dir	*(struct)
,	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
struct	O
node	O
*	O
np	*(struct)
;	O
err	int
=	O
netfs_attempt_lookup	(*(struct),*(struct),*(char),*(*(struct)))->(int)
(	O
cred	*(struct)
,	O
dir	*(struct)
,	O
name	*(char)
,	O
&	O
np	*(struct)
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
return	O
err	int
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
purge_lookup_cache_node	(*(struct))->(void)
(	O
np	*(struct)
)	O
;	O
struct	O
references	O
result	struct
;	O
refcounts_references	()->(int)
(	O
&	O
np	*(struct)
->	O
refcounts	O
,	O
&	O
result	struct
)	O
;	O
if	O
(	O
result	struct
.	O
hard	O
>	O
1	int
)	O
{	O
char	O
*	O
newname	*(char)
=	O
0	int
;	O
int	O
n	int
=	O
0	int
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
newname	*(char)
=	O
malloc	O
(	O
50	int
)	O
;	O
if	O
(	O
!	O
newname	*(char)
)	O
{	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
netfs_nrele	()->(int)
(	O
np	*(struct)
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
do	O
{	O
sprintf	O
(	O
newname	*(char)
,	O
".nfs%txgnu.%d"	*(char)
,	O
(	O
ptrdiff_t	long
)	O
np	*(struct)
,	O
n	int
++	O
)	O
;	O
err	int
=	O
netfs_attempt_link	(*(struct),*(struct),*(struct),*(char),int)->(int)
(	O
cred	*(struct)
,	O
dir	*(struct)
,	O
np	*(struct)
,	O
newname	*(char)
,	O
1	int
)	O
;	O
}	O
while	O
(	O
err	int
==	O
EEXIST	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
free	()->(int)
(	O
newname	*(char)
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
netfs_nrele	()->(int)
(	O
np	*(struct)
)	O
;	O
return	O
err	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
np	*(struct)
->	O
nn	O
->	O
dead_dir	*(struct)
)	O
netfs_nrele	()->(int)
(	O
np	*(struct)
->	O
nn	O
->	O
dead_dir	*(struct)
)	O
;	O
netfs_nref	()->(int)
(	O
dir	*(struct)
)	O
;	O
np	*(struct)
->	O
nn	O
->	O
dead_dir	*(struct)
=	O
dir	*(struct)
;	O
if	O
(	O
np	*(struct)
->	O
nn	O
->	O
dead_name	*(char)
)	O
free	()->(int)
(	O
np	*(struct)
->	O
nn	O
->	O
dead_name	*(char)
)	O
;	O
np	*(struct)
->	O
nn	O
->	O
dead_name	*(char)
=	O
newname	*(char)
;	O
if	O
(	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
==	O
NOT_POSSIBLE	int
)	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
=	O
POSSIBLE	int
;	O
netfs_nput	()->(int)
(	O
np	*(struct)
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
dir	*(struct)
->	O
lock	O
)	O
;	O
}	O
else	O
netfs_nrele	()->(int)
(	O
np	*(struct)
)	O
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_REMOVE	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
dir	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
dir	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
name	*(char)
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
p	*(int)
=	O
process_wcc_stat	(*(struct),*(int),int)->(*(int))
(	O
dir	*(struct)
,	O
p	*(int)
,	O
!	O
err	int
)	O
;	O
}	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_rename	(*(struct),*(struct),*(char),*(struct),*(char),int)->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
fromdir	*(struct)
,	O
char	O
*	O
fromname	*(char)
,	O
struct	O
node	O
*	O
todir	*(struct)
,	O
char	O
*	O
toname	*(char)
,	O
int	O
excl	int
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
if	O
(	O
excl	int
)	O
{	O
struct	O
node	O
*	O
np	*(struct)
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fromdir	*(struct)
->	O
lock	O
)	O
;	O
err	int
=	O
netfs_attempt_lookup	(*(struct),*(struct),*(char),*(*(struct)))->(int)
(	O
cred	*(struct)
,	O
fromdir	*(struct)
,	O
fromname	*(char)
,	O
&	O
np	*(struct)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fromdir	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
err	int
=	O
netfs_attempt_link	(*(struct),*(struct),*(struct),*(char),int)->(int)
(	O
cred	*(struct)
,	O
todir	*(struct)
,	O
np	*(struct)
,	O
toname	*(char)
,	O
1	int
)	O
;	O
netfs_nput	()->(int)
(	O
np	*(struct)
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fromdir	*(struct)
->	O
lock	O
)	O
;	O
err	int
=	O
netfs_attempt_unlink	()->(int)
(	O
cred	*(struct)
,	O
fromdir	*(struct)
,	O
fromname	*(char)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fromdir	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
todir	*(struct)
->	O
lock	O
)	O
;	O
netfs_attempt_unlink	()->(int)
(	O
cred	*(struct)
,	O
todir	*(struct)
,	O
toname	*(char)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
todir	*(struct)
->	O
lock	O
)	O
;	O
return	O
err	int
;	O
}	O
return	O
0	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fromdir	*(struct)
->	O
lock	O
)	O
;	O
purge_lookup_cache	(*(struct),*(char),long)->(void)
(	O
fromdir	*(struct)
,	O
fromname	*(char)
,	O
strlen	O
(	O
fromname	*(char)
)	O
)	O
;	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_RENAME	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
fromdir	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fromdir	*(struct)
->	O
lock	O
)	O
;	O
return	O
errno	O
;	O
}	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
fromdir	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
fromname	*(char)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fromdir	*(struct)
->	O
lock	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
todir	*(struct)
->	O
lock	O
)	O
;	O
purge_lookup_cache	(*(struct),*(char),long)->(void)
(	O
todir	*(struct)
,	O
toname	*(char)
,	O
strlen	O
(	O
toname	*(char)
)	O
)	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
todir	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
toname	*(char)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
todir	*(struct)
->	O
lock	O
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
{	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fromdir	*(struct)
->	O
lock	O
)	O
;	O
p	*(int)
=	O
process_wcc_stat	(*(struct),*(int),int)->(*(int))
(	O
fromdir	*(struct)
,	O
p	*(int)
,	O
!	O
err	int
)	O
;	O
p	*(int)
=	O
process_wcc_stat	(*(struct),*(int),int)->(*(int))
(	O
todir	*(struct)
,	O
p	*(int)
,	O
!	O
err	int
)	O
;	O
}	O
}	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_readlink	(*(struct),*(struct),*(char))->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
char	O
*	O
buf	*(void)
)	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
if	O
(	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
==	O
SYMLINK	int
)	O
{	O
strcpy	O
(	O
buf	*(void)
,	O
np	*(struct)
->	O
nn	O
->	O
transarg	union(*(char),long)
.	O
name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_READLINK	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
np	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
p	*(int)
=	O
process_returned_stat	(*(struct),*(int),int)->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
err	int
)	O
p	*(int)
=	O
xdr_decode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
buf	*(void)
)	O
;	O
}	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_check_open_permissions	(*(struct),*(struct),int,int)->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
int	O
flags	int
,	O
int	O
newnode	int
)	O
{	O
int	O
modes	int
;	O
if	O
(	O
newnode	int
||	O
(	O
flags	int
&	O
(	O
O_READ	O
|	O
O_WRITE	O
|	O
O_EXEC	O
)	O
)	O
==	O
0	int
)	O
return	O
0	int
;	O
netfs_report_access	()->(int)
(	O
cred	*(struct)
,	O
np	*(struct)
,	O
&	O
modes	int
)	O
;	O
if	O
(	O
(	O
flags	int
&	O
(	O
O_READ	O
|	O
O_WRITE	O
|	O
O_EXEC	O
)	O
)	O
==	O
(	O
flags	int
&	O
modes	int
)	O
)	O
return	O
0	int
;	O
else	O
return	O
EACCES	int
;	O
}	O
error_t	int
netfs_report_access	()->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
int	O
*	O
types	*(int)
)	O
{	O
error_t	int
err	int
;	O
err	int
=	O
netfs_validate_stat	(*(struct),*(struct))->(int)
(	O
np	*(struct)
,	O
cred	*(struct)
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
{	O
*	O
types	*(int)
=	O
0	int
;	O
if	O
(	O
fshelp_access	()->(int)
(	O
&	O
np	*(struct)
->	O
nn_stat	O
,	O
S_IREAD	O
,	O
cred	*(struct)
)	O
==	O
0	int
)	O
*	O
types	*(int)
|=	O
O_READ	O
;	O
if	O
(	O
fshelp_access	()->(int)
(	O
&	O
np	*(struct)
->	O
nn_stat	O
,	O
S_IWRITE	O
,	O
cred	*(struct)
)	O
==	O
0	int
)	O
*	O
types	*(int)
|=	O
O_WRITE	O
;	O
if	O
(	O
fshelp_access	()->(int)
(	O
&	O
np	*(struct)
->	O
nn_stat	O
,	O
S_IEXEC	O
,	O
cred	*(struct)
)	O
==	O
0	int
)	O
*	O
types	*(int)
|=	O
O_EXEC	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
error_t	int
err	int
;	O
int	O
ret	*(int)
;	O
int	O
write_check	int
,	O
execute_check	int
;	O
if	O
(	O
S_ISDIR	O
(	O
np	*(struct)
->	O
nn_stat	O
.	O
st_mode	int
)	O
)	O
{	O
write_check	int
=	O
ACCESS3_MODIFY	int
|	O
ACCESS3_DELETE	int
|	O
ACCESS3_EXTEND	int
;	O
execute_check	int
=	O
ACCESS3_LOOKUP	int
;	O
}	O
else	O
{	O
write_check	int
=	O
ACCESS3_MODIFY	int
;	O
execute_check	int
=	O
ACCESS3_EXECUTE	int
;	O
}	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFS3PROC_ACCESS	int
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
np	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
return	O
errno	O
;	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
np	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
ACCESS3_READ	int
|	O
write_check	int
|	O
execute_check	int
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
p	*(int)
=	O
process_returned_stat	(*(struct),*(int),int)->(*(int))
(	O
np	*(struct)
,	O
p	*(int)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
ret	*(int)
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
*	O
types	*(int)
=	O
(	O
(	O
ret	*(int)
&	O
ACCESS3_READ	int
?	O
O_READ	O
:	O
0	int
)	O
|	O
(	O
ret	*(int)
&	O
write_check	int
?	O
O_WRITE	O
:	O
0	int
)	O
|	O
(	O
ret	*(int)
&	O
execute_check	int
?	O
O_EXEC	O
:	O
0	int
)	O
)	O
;	O
}	O
}	O
return	O
err	int
;	O
}	O
}	O
static	O
error_t	int
fetch_directory	(*(struct),*(struct),*(*(void)),*(long),*(int))->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
dir	*(struct)
,	O
void	O
*	O
*	O
bufp	*(*(void))
,	O
size_t	long
*	O
bufsizep	*(long)
,	O
int	O
*	O
totalentries	*(int)
)	O
{	O
void	O
*	O
buf	*(void)
;	O
int	O
cookie	int
;	O
int	O
*	O
p	*(int)
;	O
void	O
*	O
rpcbuf	*(void)
;	O
struct	O
dirent	O
*	O
entry	*(struct)
;	O
void	O
*	O
bp	*(void)
;	O
int	O
bufmalloced	int
;	O
int	O
eof	int
;	O
error_t	int
err	int
;	O
int	O
isnext	int
;	O
bufmalloced	int
=	O
read_size	int
;	O
buf	*(void)
=	O
malloc	O
(	O
bufmalloced	int
)	O
;	O
if	O
(	O
!	O
buf	*(void)
)	O
return	O
ENOMEM	int
;	O
bp	*(void)
=	O
buf	*(void)
;	O
cookie	int
=	O
0	int
;	O
eof	int
=	O
0	int
;	O
*	O
totalentries	*(int)
=	O
0	int
;	O
while	O
(	O
!	O
eof	int
)	O
{	O
p	*(int)
=	O
nfs_initialize_rpc	(int,*(struct),long,*(*(void)),*(struct),int)->(*(int))
(	O
NFSPROC_READDIR	O
(	O
protocol_version	int
)	O
,	O
cred	*(struct)
,	O
0	int
,	O
&	O
rpcbuf	*(void)
,	O
dir	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(int)
)	O
{	O
free	()->(int)
(	O
buf	*(void)
)	O
;	O
return	O
errno	O
;	O
}	O
p	*(int)
=	O
xdr_encode_fhandle	(*(int),*(struct(long,array(char))))->(*(int))
(	O
p	*(int)
,	O
&	O
dir	*(struct)
->	O
nn	O
->	O
handle	struct(long,array(char))
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
cookie	int
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
ntohl	()->(int)
(	O
read_size	int
)	O
;	O
err	int
=	O
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
&	O
rpcbuf	*(void)
,	O
&	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	(int)->(int)
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
;	O
p	*(int)
++	O
;	O
}	O
if	O
(	O
err	int
)	O
{	O
free	()->(int)
(	O
buf	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
isnext	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
while	O
(	O
isnext	int
)	O
{	O
ino_t	long
fileno	long
;	O
int	O
namlen	int
;	O
int	O
reclen	int
;	O
fileno	long
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
namlen	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
reclen	int
=	O
sizeof	O
(	O
struct	O
dirent	O
)	O
+	O
namlen	int
;	O
reclen	int
=	O
(	O
reclen	int
+	O
3	int
)	O
&	O
~	O
3	int
;	O
if	O
(	O
bp	*(void)
+	O
reclen	int
>	O
buf	*(void)
+	O
bufmalloced	int
)	O
{	O
char	O
*	O
newbuf	*(char)
;	O
newbuf	*(char)
=	O
realloc	O
(	O
buf	*(void)
,	O
bufmalloced	int
*=	O
2	int
)	O
;	O
assert	()->(int)
(	O
newbuf	*(char)
)	O
;	O
if	O
(	O
newbuf	*(char)
!=	O
buf	*(void)
)	O
bp	*(void)
=	O
newbuf	*(char)
+	O
(	O
bp	*(void)
-	O
buf	*(void)
)	O
;	O
buf	*(void)
=	O
newbuf	*(char)
;	O
}	O
entry	*(struct)
=	O
(	O
struct	O
dirent	O
*	O
)	O
bp	*(void)
;	O
entry	*(struct)
->	O
d_fileno	O
=	O
fileno	long
;	O
entry	*(struct)
->	O
d_reclen	O
=	O
reclen	int
;	O
entry	*(struct)
->	O
d_type	O
=	O
DT_UNKNOWN	O
;	O
entry	*(struct)
->	O
d_namlen	O
=	O
namlen	int
;	O
memcpy	O
(	O
entry	*(struct)
->	O
d_name	O
,	O
p	*(int)
,	O
namlen	int
)	O
;	O
entry	*(struct)
->	O
d_name	O
[	O
namlen	int
]	O
=	O
'\0'	O
;	O
p	*(int)
+=	O
INTSIZE	O
(	O
namlen	int
)	O
;	O
bp	*(void)
=	O
bp	*(void)
+	O
entry	*(struct)
->	O
d_reclen	O
;	O
++	O
*	O
totalentries	*(int)
;	O
cookie	int
=	O
*	O
(	O
p	*(int)
++	O
)	O
;	O
isnext	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
}	O
eof	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
free	()->(int)
(	O
rpcbuf	*(void)
)	O
;	O
}	O
*	O
bufp	*(*(void))
=	O
buf	*(void)
;	O
*	O
bufsizep	*(long)
=	O
bufmalloced	int
;	O
return	O
0	int
;	O
}	O
error_t	int
netfs_get_dirents	(*(struct),*(struct),int,int,*(*(char)),*(int),int,*(int))->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
int	O
entry	*(struct)
,	O
int	O
nentries	int
,	O
char	O
*	O
*	O
data	array(char)
,	O
mach_msg_type_number_t	O
*	O
datacnt	*(int)
,	O
vm_size_t	O
bufsiz	int
,	O
int	O
*	O
amt	long
)	O
{	O
void	O
*	O
buf	*(void)
=	O
NULL	O
;	O
size_t	long
our_bufsiz	long
,	O
allocsize	long
;	O
void	O
*	O
bp	*(void)
;	O
char	O
*	O
userdp	*(char)
;	O
error_t	int
err	int
;	O
int	O
totalentries	*(int)
;	O
int	O
thisentry	int
;	O
err	int
=	O
fetch_directory	(*(struct),*(struct),*(*(void)),*(long),*(int))->(int)
(	O
cred	*(struct)
,	O
np	*(struct)
,	O
&	O
buf	*(void)
,	O
&	O
our_bufsiz	long
,	O
&	O
totalentries	*(int)
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
if	O
(	O
!	O
bufsiz	int
||	O
bufsiz	int
>	O
our_bufsiz	long
)	O
allocsize	long
=	O
round_page	()->(int)
(	O
our_bufsiz	long
)	O
;	O
else	O
allocsize	long
=	O
round_page	()->(int)
(	O
bufsiz	int
)	O
;	O
if	O
(	O
allocsize	long
>	O
*	O
datacnt	*(int)
)	O
*	O
data	array(char)
=	O
mmap	(*(void),long,int,int,int,long)->(*(void))
(	O
0	int
,	O
allocsize	long
,	O
PROT_READ	int
|	O
PROT_WRITE	int
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
bp	*(void)
=	O
buf	*(void)
;	O
for	O
(	O
thisentry	int
=	O
0	int
;	O
thisentry	int
<	O
entry	*(struct)
;	O
)	O
{	O
struct	O
dirent	O
*	O
entry	*(struct)
=	O
(	O
struct	O
dirent	O
*	O
)	O
bp	*(void)
;	O
bp	*(void)
+=	O
entry	*(struct)
->	O
d_reclen	O
;	O
thisentry	int
++	O
;	O
}	O
{	O
int	O
entries_copied	int
;	O
for	O
(	O
entries_copied	int
=	O
0	int
,	O
userdp	*(char)
=	O
*	O
data	array(char)
;	O
(	O
nentries	int
==	O
-	O
1	int
||	O
entries_copied	int
<	O
nentries	int
)	O
&&	O
(	O
!	O
bufsiz	int
||	O
userdp	*(char)
-	O
*	O
data	array(char)
<	O
bufsiz	int
)	O
&&	O
thisentry	int
<	O
totalentries	*(int)
;	O
)	O
{	O
struct	O
dirent	O
*	O
entry	*(struct)
=	O
(	O
struct	O
dirent	O
*	O
)	O
bp	*(void)
;	O
memcpy	O
(	O
userdp	*(char)
,	O
bp	*(void)
,	O
entry	*(struct)
->	O
d_reclen	O
)	O
;	O
bp	*(void)
+=	O
entry	*(struct)
->	O
d_reclen	O
;	O
userdp	*(char)
+=	O
entry	*(struct)
->	O
d_reclen	O
;	O
entries_copied	int
++	O
;	O
thisentry	int
++	O
;	O
}	O
*	O
amt	long
=	O
entries_copied	int
;	O
}	O
free	()->(int)
(	O
buf	*(void)
)	O
;	O
if	O
(	O
allocsize	long
>	O
*	O
datacnt	*(int)
&&	O
round_page	()->(int)
(	O
userdp	*(char)
-	O
*	O
data	array(char)
)	O
<	O
round_page	()->(int)
(	O
allocsize	long
)	O
)	O
munmap	(*(void),long)->(int)
(	O
(	O
caddr_t	*(char)
)	O
round_page	()->(int)
(	O
userdp	*(char)
)	O
,	O
round_page	()->(int)
(	O
allocsize	long
)	O
-	O
round_page	()->(int)
(	O
userdp	*(char)
-	O
*	O
data	array(char)
)	O
)	O
;	O
*	O
datacnt	*(int)
=	O
userdp	*(char)
-	O
*	O
data	array(char)
;	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_mksymlink	(*(struct),*(struct),*(char))->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
char	O
*	O
arg	*(void)
)	O
{	O
if	O
(	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
==	O
NOT_POSSIBLE	int
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
==	O
SYMLINK	int
)	O
free	()->(int)
(	O
np	*(struct)
->	O
nn	O
->	O
transarg	union(*(char),long)
.	O
name	*(char)
)	O
;	O
np	*(struct)
->	O
nn	O
->	O
transarg	union(*(char),long)
.	O
name	*(char)
=	O
malloc	O
(	O
strlen	O
(	O
arg	*(void)
)	O
+	O
1	int
)	O
;	O
strcpy	O
(	O
np	*(struct)
->	O
nn	O
->	O
transarg	union(*(char),long)
.	O
name	*(char)
,	O
arg	*(void)
)	O
;	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
=	O
SYMLINK	int
;	O
np	*(struct)
->	O
nn	O
->	O
stat_updated	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_mkdev	(*(struct),*(struct),int,long)->(int)
(	O
struct	O
iouser	O
*	O
cred	*(struct)
,	O
struct	O
node	O
*	O
np	*(struct)
,	O
mode_t	int
type	int
,	O
dev_t	long
indexes	long
)	O
{	O
if	O
(	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
==	O
NOT_POSSIBLE	int
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
==	O
SYMLINK	int
)	O
free	()->(int)
(	O
np	*(struct)
->	O
nn	O
->	O
transarg	union(*(char),long)
.	O
name	*(char)
)	O
;	O
np	*(struct)
->	O
nn	O
->	O
transarg	union(*(char),long)
.	O
indexes	long
=	O
indexes	long
;	O
if	O
(	O
type	int
==	O
S_IFBLK	O
)	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
=	O
BLKDEV	int
;	O
else	O
np	*(struct)
->	O
nn	O
->	O
dtrans	enum(int,int,int,int,int,int,int)
=	O
CHRDEV	int
;	O
np	*(struct)
->	O
nn	O
->	O
stat_updated	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
