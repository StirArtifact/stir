struct	O
wget_thread_st	struct(long)
{	O
gl_thread_t	long
tid	long
;	O
}	O
;	O
struct	O
wget_thread_mutex_st	struct(union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long))
{	O
gl_lock_t	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
mutex	*(*(struct))
;	O
}	O
;	O
struct	O
wget_thread_cond_st	struct(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
{	O
gl_cond_t	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
;	O
}	O
;	O
int	O
wget_thread_mutex_init	(*(*(struct)))->(int)
(	O
wget_thread_mutex	*(struct)
*	O
mutex	*(*(struct))
)	O
{	O
*	O
mutex	*(*(struct))
=	O
wget_malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
wget_thread_mutex_st	struct(union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long))
)	O
)	O
;	O
if	O
(	O
!	O
*	O
mutex	*(*(struct))
)	O
return	O
WGET_E_MEMORY	int
;	O
return	O
glthread_lock_init	O
(	O
&	O
(	O
(	O
*	O
mutex	*(*(struct))
)	O
->	O
mutex	*(*(struct))
)	O
)	O
;	O
}	O
int	O
wget_thread_mutex_destroy	(*(*(struct)))->(int)
(	O
wget_thread_mutex	*(struct)
*	O
mutex	*(*(struct))
)	O
{	O
int	O
rc	int
=	O
glthread_lock_destroy	O
(	O
&	O
(	O
*	O
mutex	*(*(struct))
)	O
->	O
mutex	*(*(struct))
)	O
;	O
xfree	O
(	O
*	O
mutex	*(*(struct))
)	O
;	O
return	O
rc	int
;	O
}	O
void	O
wget_thread_mutex_lock	(*(struct))->(void)
(	O
wget_thread_mutex	*(struct)
mutex	*(*(struct))
)	O
{	O
glthread_lock_lock	O
(	O
&	O
mutex	*(*(struct))
->	O
mutex	*(*(struct))
)	O
;	O
}	O
void	O
wget_thread_mutex_unlock	(*(struct))->(void)
(	O
wget_thread_mutex	*(struct)
mutex	*(*(struct))
)	O
{	O
glthread_lock_unlock	O
(	O
&	O
mutex	*(*(struct))
->	O
mutex	*(*(struct))
)	O
;	O
}	O
int	O
wget_thread_cond_init	(*(*(struct)))->(int)
(	O
wget_thread_cond	*(struct)
*	O
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
)	O
{	O
*	O
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
=	O
wget_malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
wget_thread_cond_st	struct(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
)	O
)	O
;	O
if	O
(	O
!	O
*	O
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
)	O
return	O
WGET_E_MEMORY	int
;	O
return	O
glthread_cond_init	O
(	O
&	O
(	O
(	O
*	O
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
)	O
->	O
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
)	O
)	O
;	O
}	O
int	O
wget_thread_cond_destroy	(*(*(struct)))->(int)
(	O
wget_thread_cond	*(struct)
*	O
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
)	O
{	O
int	O
rc	int
=	O
glthread_cond_destroy	O
(	O
&	O
(	O
*	O
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
)	O
->	O
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
)	O
;	O
xfree	O
(	O
*	O
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
wget_thread_cond_signal	(*(struct))->(int)
(	O
wget_thread_cond	*(struct)
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
)	O
{	O
return	O
glthread_cond_broadcast	O
(	O
&	O
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
->	O
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
)	O
;	O
}	O
int	O
wget_thread_cond_wait	(*(struct),*(struct),long long)->(int)
(	O
wget_thread_cond	*(struct)
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
,	O
wget_thread_mutex	*(struct)
mutex	*(*(struct))
,	O
long	O
long	O
ms	int
)	O
{	O
if	O
(	O
ms	int
<=	O
0	int
)	O
return	O
glthread_cond_wait	O
(	O
&	O
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
->	O
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
,	O
&	O
mutex	*(*(struct))
->	O
mutex	*(*(struct))
)	O
;	O
struct	O
timespec	struct(long,long)
ts	struct(long,long)
;	O
gettime	(*(struct(long,long)))->(void)
(	O
&	O
ts	struct(long,long)
)	O
;	O
ms	int
+=	O
ts	struct(long,long)
.	O
tv_sec	long
*	O
1000LL	int
+	O
ts	struct(long,long)
.	O
tv_nsec	long
/	O
1000000	int
;	O
ts	struct(long,long)
.	O
tv_sec	long
=	O
ms	int
/	O
1000	int
;	O
ts	struct(long,long)
.	O
tv_nsec	long
=	O
(	O
ms	int
%	O
1000	int
)	O
*	O
1000000	int
;	O
return	O
glthread_cond_timedwait	O
(	O
&	O
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
->	O
cond	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
,	O
&	O
mutex	*(*(struct))
->	O
mutex	*(*(struct))
,	O
&	O
ts	struct(long,long)
)	O
;	O
}	O
int	O
wget_thread_start	(*(*(struct)),*((*(void))->(*(void))),*(void),int)->(int)
(	O
wget_thread	*(struct)
*	O
thread	long
,	O
void	O
*	O
(	O
*	O
start_routine	*((*(void))->(*(void)))
)	O
(	O
void	O
*	O
)	O
,	O
void	O
*	O
arg	*(void)
,	O
WGET_GCC_UNUSED	O
int	O
flags	int
)	O
{	O
if	O
(	O
wget_thread_support	()->(bool)
(	O
)	O
)	O
{	O
*	O
thread	long
=	O
wget_malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
wget_thread_st	struct(long)
)	O
)	O
;	O
if	O
(	O
!	O
*	O
thread	long
)	O
return	O
WGET_E_MEMORY	int
;	O
return	O
glthread_create	O
(	O
&	O
(	O
(	O
*	O
thread	long
)	O
->	O
tid	long
)	O
,	O
start_routine	*((*(void))->(*(void)))
,	O
arg	*(void)
)	O
;	O
}	O
*	O
thread	long
=	O
NULL	O
;	O
start_routine	*((*(void))->(*(void)))
(	O
arg	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
wget_thread_cancel	(*(struct))->(int)
(	O
WGET_GCC_UNUSED	O
wget_thread	*(struct)
thread	long
)	O
{	O
return	O
0	int
;	O
}	O
int	O
wget_thread_kill	(*(struct),int)->(int)
(	O
WGET_GCC_UNUSED	O
wget_thread	*(struct)
thread	long
,	O
WGET_GCC_UNUSED	O
int	O
sig	int
)	O
{	O
return	O
0	int
;	O
}	O
int	O
wget_thread_join	(*(*(struct)))->(int)
(	O
wget_thread	*(struct)
*	O
thread	long
)	O
{	O
if	O
(	O
thread	long
&&	O
*	O
thread	long
&&	O
(	O
*	O
thread	long
)	O
->	O
tid	long
)	O
{	O
int	O
rc	int
=	O
glthread_join	O
(	O
(	O
*	O
thread	long
)	O
->	O
tid	long
,	O
NULL	O
)	O
;	O
xfree	O
(	O
*	O
thread	long
)	O
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
wget_thread_support	()->(bool)
(	O
)	O
)	O
{	O
errno	O
=	O
ESRCH	int
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
wget_thread_id	long
wget_thread_self	()->(long)
(	O
void	O
)	O
{	O
return	O
gl_thread_self	O
(	O
)	O
;	O
}	O
bool	bool
wget_thread_support	()->(bool)
(	O
void	O
)	O
{	O
return	O
true	int
;	O
}	O
