miGC	struct
*	O
miNewGC	O
(	O
int	O
npixels	int
,	O
const	O
miPixel	struct(char,union(char,array(char)))
*	O
pixels	*(struct(char,union(char,array(char))))
)	O
{	O
miGC	struct
*	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
;	O
int	O
i	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
=	O
(	O
miGC	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miGC	struct
)	O
)	O
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
fillRule	int
=	O
MI_EVEN_ODD_RULE	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
joinStyle	int
=	O
MI_JOIN_MITER	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
capStyle	int
=	O
MI_CAP_BUTT	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
lineStyle	int
=	O
MI_LINE_SOLID	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
arcMode	int
=	O
MI_ARC_PIE_SLICE	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
lineWidth	int
=	O
(	O
unsigned	O
int	O
)	O
0	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
miterLimit	double
=	O
10.43	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
dashOffset	int
=	O
0	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
numInDashList	int
=	O
2	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
dash	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
2	int
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
dash	*(int)
[	O
i	int
]	O
=	O
4	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
numPixels	int
=	O
npixels	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
pixels	*(struct(char,union(char,array(char))))
=	O
(	O
miPixel	struct(char,union(char,array(char)))
*	O
)	O
mi_xmalloc	O
(	O
npixels	int
*	O
sizeof	O
(	O
miPixel	struct(char,union(char,array(char)))
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npixels	int
;	O
i	int
++	O
)	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
pixels	*(struct(char,union(char,array(char))))
[	O
i	int
]	O
=	O
pixels	*(struct(char,union(char,array(char))))
[	O
i	int
]	O
;	O
return	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
;	O
}	O
void	O
miDeleteGC	O
(	O
miGC	struct
*	O
pGC	*(struct)
)	O
{	O
if	O
(	O
pGC	*(struct)
==	O
(	O
miGC	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
pGC	*(struct)
->	O
dash	*(int)
)	O
free	(*(void))->(void)
(	O
pGC	*(struct)
->	O
dash	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
)	O
;	O
free	(*(void))->(void)
(	O
pGC	*(struct)
)	O
;	O
}	O
miGC	struct
*	O
miCopyGC	O
(	O
const	O
miGC	struct
*	O
pGC	*(struct)
)	O
{	O
miGC	struct
*	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
;	O
int	O
i	int
;	O
if	O
(	O
pGC	*(struct)
==	O
(	O
const	O
miGC	struct
*	O
)	O
pGC	*(struct)
)	O
return	O
(	O
miGC	struct
*	O
)	O
NULL	O
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
=	O
(	O
miGC	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miGC	struct
)	O
)	O
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
fillRule	int
=	O
pGC	*(struct)
->	O
fillRule	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
joinStyle	int
=	O
pGC	*(struct)
->	O
joinStyle	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
capStyle	int
=	O
pGC	*(struct)
->	O
capStyle	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
lineStyle	int
=	O
pGC	*(struct)
->	O
lineStyle	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
arcMode	int
=	O
pGC	*(struct)
->	O
arcMode	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
lineWidth	int
=	O
pGC	*(struct)
->	O
lineWidth	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
miterLimit	double
=	O
pGC	*(struct)
->	O
miterLimit	double
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
dashOffset	int
=	O
pGC	*(struct)
->	O
dashOffset	int
;	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
numInDashList	int
=	O
pGC	*(struct)
->	O
numInDashList	int
;	O
if	O
(	O
pGC	*(struct)
->	O
numInDashList	int
==	O
0	int
)	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
dash	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
NULL	O
;	O
else	O
{	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
dash	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
pGC	*(struct)
->	O
numInDashList	int
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pGC	*(struct)
->	O
numInDashList	int
;	O
i	int
++	O
)	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
dash	*(int)
[	O
i	int
]	O
=	O
pGC	*(struct)
->	O
dash	*(int)
[	O
i	int
]	O
;	O
}	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
pixels	*(struct(char,union(char,array(char))))
=	O
(	O
miPixel	struct(char,union(char,array(char)))
*	O
)	O
mi_xmalloc	O
(	O
pGC	*(struct)
->	O
numPixels	int
*	O
sizeof	O
(	O
miPixel	struct(char,union(char,array(char)))
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pGC	*(struct)
->	O
numPixels	int
;	O
i	int
++	O
)	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
->	O
pixels	*(struct(char,union(char,array(char))))
[	O
i	int
]	O
=	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
[	O
i	int
]	O
;	O
return	O
new_gc	*(struct(int,*(struct(char,union(char,array(char)))),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int))
;	O
}	O
void	O
miSetGCAttrib	O
(	O
miGC	struct
*	O
pGC	*(struct)
,	O
miGCAttribute	enum(int,int,int,int,int,int)
attribute	enum(int,int,int,int,int,int)
,	O
int	O
value	*(void)
)	O
{	O
if	O
(	O
pGC	*(struct)
==	O
(	O
miGC	struct
*	O
)	O
NULL	O
||	O
value	*(void)
<	O
0	int
)	O
return	O
;	O
switch	O
(	O
(	O
int	O
)	O
attribute	enum(int,int,int,int,int,int)
)	O
{	O
case	O
(	O
int	O
)	O
MI_GC_FILL_RULE	int
:	O
pGC	*(struct)
->	O
fillRule	int
=	O
value	*(void)
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_GC_JOIN_STYLE	int
:	O
pGC	*(struct)
->	O
joinStyle	int
=	O
value	*(void)
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_GC_CAP_STYLE	int
:	O
pGC	*(struct)
->	O
capStyle	int
=	O
value	*(void)
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_GC_LINE_STYLE	int
:	O
pGC	*(struct)
->	O
lineStyle	int
=	O
value	*(void)
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_GC_ARC_MODE	int
:	O
pGC	*(struct)
->	O
arcMode	int
=	O
value	*(void)
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_GC_LINE_WIDTH	int
:	O
if	O
(	O
value	*(void)
>=	O
0	int
)	O
pGC	*(struct)
->	O
lineWidth	int
=	O
(	O
unsigned	O
int	O
)	O
value	*(void)
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
void	O
miSetGCAttribs	O
(	O
miGC	struct
*	O
pGC	*(struct)
,	O
int	O
nattributes	int
,	O
const	O
miGCAttribute	enum(int,int,int,int,int,int)
*	O
attributes	*(enum(int,int,int,int,int,int))
,	O
const	O
int	O
*	O
values	*(int)
)	O
{	O
int	O
i	int
;	O
miGCAttribute	enum(int,int,int,int,int,int)
attribute	enum(int,int,int,int,int,int)
;	O
int	O
value	*(void)
;	O
if	O
(	O
nattributes	int
<=	O
0	int
||	O
pGC	*(struct)
==	O
(	O
miGC	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nattributes	int
;	O
i	int
++	O
)	O
{	O
attribute	enum(int,int,int,int,int,int)
=	O
*	O
attributes	*(enum(int,int,int,int,int,int))
++	O
;	O
value	*(void)
=	O
*	O
values	*(int)
++	O
;	O
if	O
(	O
value	*(void)
<	O
0	int
)	O
continue	O
;	O
switch	O
(	O
(	O
int	O
)	O
attribute	enum(int,int,int,int,int,int)
)	O
{	O
case	O
(	O
int	O
)	O
MI_GC_FILL_RULE	int
:	O
pGC	*(struct)
->	O
fillRule	int
=	O
value	*(void)
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_GC_JOIN_STYLE	int
:	O
pGC	*(struct)
->	O
joinStyle	int
=	O
value	*(void)
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_GC_CAP_STYLE	int
:	O
pGC	*(struct)
->	O
capStyle	int
=	O
value	*(void)
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_GC_LINE_STYLE	int
:	O
pGC	*(struct)
->	O
lineStyle	int
=	O
value	*(void)
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_GC_ARC_MODE	int
:	O
pGC	*(struct)
->	O
arcMode	int
=	O
value	*(void)
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_GC_LINE_WIDTH	int
:	O
if	O
(	O
value	*(void)
>=	O
0	int
)	O
pGC	*(struct)
->	O
lineWidth	int
=	O
(	O
unsigned	O
int	O
)	O
value	*(void)
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
void	O
miSetGCMiterLimit	O
(	O
miGC	struct
*	O
pGC	*(struct)
,	O
double	O
value	*(void)
)	O
{	O
if	O
(	O
pGC	*(struct)
==	O
(	O
miGC	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
pGC	*(struct)
->	O
miterLimit	double
=	O
value	*(void)
;	O
}	O
void	O
miSetGCDashes	O
(	O
miGC	struct
*	O
pGC	*(struct)
,	O
int	O
ndashes	int
,	O
const	O
unsigned	O
int	O
*	O
dashes	*(int)
,	O
int	O
offset	array(short)
)	O
{	O
int	O
i	int
;	O
if	O
(	O
pGC	*(struct)
==	O
(	O
miGC	struct
*	O
)	O
NULL	O
||	O
ndashes	int
<	O
0	int
)	O
return	O
;	O
if	O
(	O
pGC	*(struct)
->	O
dash	*(int)
)	O
free	(*(void))->(void)
(	O
pGC	*(struct)
->	O
dash	*(int)
)	O
;	O
pGC	*(struct)
->	O
dashOffset	int
=	O
offset	array(short)
;	O
pGC	*(struct)
->	O
numInDashList	int
=	O
ndashes	int
;	O
if	O
(	O
ndashes	int
==	O
0	int
)	O
pGC	*(struct)
->	O
dash	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
NULL	O
;	O
else	O
{	O
pGC	*(struct)
->	O
dash	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
ndashes	int
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ndashes	int
;	O
i	int
++	O
)	O
pGC	*(struct)
->	O
dash	*(int)
[	O
i	int
]	O
=	O
dashes	*(int)
[	O
i	int
]	O
;	O
}	O
}	O
void	O
miSetGCPixels	O
(	O
miGC	struct
*	O
pGC	*(struct)
,	O
int	O
npixels	int
,	O
const	O
miPixel	struct(char,union(char,array(char)))
*	O
pixels	*(struct(char,union(char,array(char))))
)	O
{	O
int	O
i	int
;	O
if	O
(	O
pGC	*(struct)
==	O
(	O
miGC	struct
*	O
)	O
NULL	O
||	O
npixels	int
<	O
2	int
)	O
return	O
;	O
free	(*(void))->(void)
(	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
)	O
;	O
pGC	*(struct)
->	O
numPixels	int
=	O
npixels	int
;	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
=	O
(	O
miPixel	struct(char,union(char,array(char)))
*	O
)	O
mi_xmalloc	O
(	O
npixels	int
*	O
sizeof	O
(	O
miPixel	struct(char,union(char,array(char)))
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npixels	int
;	O
i	int
++	O
)	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
[	O
i	int
]	O
=	O
pixels	*(struct(char,union(char,array(char))))
[	O
i	int
]	O
;	O
}	O
