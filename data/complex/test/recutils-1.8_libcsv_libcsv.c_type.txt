static	O
char	O
*	O
csv_errors	array(*(char))
[	O
]	O
=	O
{	O
"success"	*(char)
,	O
"error parsing data while strict checking enabled"	*(char)
,	O
"memory exhausted while increasing buffer size"	*(char)
,	O
"data size too large"	*(char)
,	O
"invalid status code"	*(char)
}	O
;	O
int	O
csv_error	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))))->(int)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
{	O
return	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
status	int
;	O
}	O
char	O
*	O
csv_strerror	(int)->(*(char))
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
>=	O
CSV_EINVALID	int
||	O
status	int
<	O
0	int
)	O
return	O
csv_errors	array(*(char))
[	O
CSV_EINVALID	int
]	O
;	O
else	O
return	O
csv_errors	array(*(char))
[	O
status	int
]	O
;	O
}	O
int	O
csv_get_opts	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))))->(int)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
return	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
options	char
;	O
}	O
int	O
csv_set_opts	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))),char)->(int)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
unsigned	O
char	O
options	char
)	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
options	char
=	O
options	char
;	O
return	O
0	int
;	O
}	O
int	O
csv_init	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))),char)->(int)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
unsigned	O
char	O
options	char
)	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_buf	*(char)
=	O
NULL	O
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
pstate	int
=	O
ROW_NOT_BEGUN	int
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quoted	int
=	O
0	int
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
spaces	long
=	O
0	int
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_pos	long
=	O
0	int
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_size	long
=	O
0	int
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
status	int
=	O
0	int
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
options	char
=	O
options	char
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quote_char	char
=	O
CSV_QUOTE	int
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
delim_char	char
=	O
CSV_COMMA	int
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
is_space	*((char)->(int))
=	O
NULL	O
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
is_term	*((char)->(int))
=	O
NULL	O
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
blk_size	long
=	O
MEM_BLK_SIZE	int
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
malloc_func	*((long)->(*(void)))
=	O
NULL	O
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
realloc_func	*((*(void),long)->(*(void)))
=	O
realloc	(*(void),long)->(*(void))
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
free_func	*((*(void))->(void))
=	O
free	(*(void))->(void)
;	O
return	O
0	int
;	O
}	O
void	O
csv_free	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))))->(void)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_buf	*(char)
)	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
free_func	*((*(void))->(void))
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_buf	*(char)
)	O
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_buf	*(char)
=	O
NULL	O
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_size	long
=	O
0	int
;	O
return	O
;	O
}	O
int	O
csv_fini	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))),*((*(void),long,*(void))->(void)),*((int,*(void))->(void)),*(void))->(int)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
void	O
(	O
*	O
cb1	*((*(void),long,*(void))->(void))
)	O
(	O
void	O
*	O
,	O
size_t	long
,	O
void	O
*	O
)	O
,	O
void	O
(	O
*	O
cb2	*((int,*(void))->(void))
)	O
(	O
int	O
c	char
,	O
void	O
*	O
)	O
,	O
void	O
*	O
data	*(void)
)	O
{	O
int	O
quoted	int
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quoted	int
;	O
int	O
pstate	int
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
pstate	int
;	O
size_t	long
spaces	long
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
spaces	long
;	O
size_t	long
entry_pos	long
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_pos	long
;	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
pstate	int
==	O
FIELD_BEGUN	int
&&	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quoted	int
&&	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
options	char
&	O
CSV_STRICT	int
&&	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
options	char
&	O
CSV_STRICT_FINI	int
)	O
{	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
status	int
=	O
CSV_EPARSE	int
;	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
pstate	int
)	O
{	O
case	O
FIELD_MIGHT_HAVE_ENDED	int
:	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_pos	long
-=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
spaces	long
+	O
1	int
;	O
case	O
FIELD_NOT_BEGUN	int
:	O
case	O
FIELD_BEGUN	int
:	O
quoted	int
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quoted	int
,	O
pstate	int
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
pstate	int
;	O
spaces	long
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
spaces	long
,	O
entry_pos	long
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_pos	long
;	O
SUBMIT_FIELD	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
;	O
SUBMIT_ROW	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
-	O
1	int
)	O
;	O
case	O
ROW_NOT_BEGUN	int
:	O
;	O
}	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
spaces	long
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quoted	int
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_pos	long
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
status	int
=	O
0	int
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
pstate	int
=	O
ROW_NOT_BEGUN	int
;	O
return	O
0	int
;	O
}	O
void	O
csv_set_delim	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))),char)->(void)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
unsigned	O
char	O
c	char
)	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
delim_char	char
=	O
c	char
;	O
}	O
void	O
csv_set_quote	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))),char)->(void)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
unsigned	O
char	O
c	char
)	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quote_char	char
=	O
c	char
;	O
}	O
unsigned	O
char	O
csv_get_delim	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))))->(char)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
{	O
return	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
delim_char	char
;	O
}	O
unsigned	O
char	O
csv_get_quote	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))))->(char)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
{	O
return	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quote_char	char
;	O
}	O
void	O
csv_set_space_func	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))),*((char)->(int)))->(void)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
int	O
(	O
*	O
f	*((char)->(int))
)	O
(	O
unsigned	O
char	O
)	O
)	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
is_space	*((char)->(int))
=	O
f	*((char)->(int))
;	O
}	O
void	O
csv_set_term_func	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))),*((char)->(int)))->(void)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
int	O
(	O
*	O
f	*((char)->(int))
)	O
(	O
unsigned	O
char	O
)	O
)	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
is_term	*((char)->(int))
=	O
f	*((char)->(int))
;	O
}	O
void	O
csv_set_realloc_func	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))),*((*(void),long)->(*(void))))->(void)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
void	O
*	O
(	O
*	O
f	*((char)->(int))
)	O
(	O
void	O
*	O
,	O
size_t	long
)	O
)	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
&&	O
f	*((char)->(int))
)	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
realloc_func	*((*(void),long)->(*(void)))
=	O
f	*((char)->(int))
;	O
}	O
void	O
csv_set_free_func	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))),*((*(void))->(void)))->(void)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
void	O
(	O
*	O
f	*((char)->(int))
)	O
(	O
void	O
*	O
)	O
)	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
&&	O
f	*((char)->(int))
)	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
free_func	*((*(void))->(void))
=	O
f	*((char)->(int))
;	O
}	O
void	O
csv_set_blk_size	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))),long)->(void)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
blk_size	long
=	O
size	long
;	O
}	O
size_t	long
csv_get_buffer_size	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))))->(long)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
return	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_size	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
csv_increase_buffer	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))))->(int)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
{	O
size_t	long
to_add	long
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
blk_size	long
;	O
void	O
*	O
vp	*(void)
;	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_size	long
>=	O
SIZE_MAX	O
-	O
to_add	long
)	O
to_add	long
=	O
SIZE_MAX	O
-	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_size	long
;	O
if	O
(	O
!	O
to_add	long
)	O
{	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
status	int
=	O
CSV_ETOOBIG	int
;	O
return	O
-	O
1	int
;	O
}	O
while	O
(	O
(	O
vp	*(void)
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
realloc_func	*((*(void),long)->(*(void)))
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_buf	*(char)
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_size	long
+	O
to_add	long
)	O
)	O
==	O
NULL	O
)	O
{	O
to_add	long
/=	O
2	int
;	O
if	O
(	O
!	O
to_add	long
)	O
{	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
status	int
=	O
CSV_ENOMEM	int
;	O
return	O
-	O
1	int
;	O
}	O
}	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_buf	*(char)
=	O
vp	*(void)
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_size	long
+=	O
to_add	long
;	O
return	O
0	int
;	O
}	O
size_t	long
csv_parse	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))),*(void),long,*((*(void),long,*(void))->(void)),*((int,*(void))->(void)),*(void))->(long)
(	O
struct	O
csv_parser	struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))
*	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
const	O
void	O
*	O
s	*(void)
,	O
size_t	long
len	long
,	O
void	O
(	O
*	O
cb1	*((*(void),long,*(void))->(void))
)	O
(	O
void	O
*	O
,	O
size_t	long
,	O
void	O
*	O
)	O
,	O
void	O
(	O
*	O
cb2	*((int,*(void))->(void))
)	O
(	O
int	O
c	char
,	O
void	O
*	O
)	O
,	O
void	O
*	O
data	*(void)
)	O
{	O
unsigned	O
const	O
char	O
*	O
us	*(char)
=	O
s	*(void)
;	O
unsigned	O
char	O
c	char
;	O
size_t	long
pos	long
=	O
0	int
;	O
unsigned	O
char	O
delim	char
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
delim_char	char
;	O
unsigned	O
char	O
quote	char
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quote_char	char
;	O
int	O
(	O
*	O
is_space	*((char)->(int))
)	O
(	O
unsigned	O
char	O
)	O
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
is_space	*((char)->(int))
;	O
int	O
(	O
*	O
is_term	*((char)->(int))
)	O
(	O
unsigned	O
char	O
)	O
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
is_term	*((char)->(int))
;	O
int	O
quoted	int
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quoted	int
;	O
int	O
pstate	int
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
pstate	int
;	O
size_t	long
spaces	long
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
spaces	long
;	O
size_t	long
entry_pos	long
=	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_pos	long
;	O
if	O
(	O
!	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_buf	*(char)
&&	O
pos	long
<	O
len	long
)	O
{	O
if	O
(	O
csv_increase_buffer	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))))->(int)
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
!=	O
0	int
)	O
{	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quoted	int
=	O
quoted	int
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
pstate	int
=	O
pstate	int
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
spaces	long
=	O
spaces	long
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_pos	long
=	O
entry_pos	long
;	O
return	O
pos	long
;	O
}	O
}	O
while	O
(	O
pos	long
<	O
len	long
)	O
{	O
if	O
(	O
entry_pos	long
==	O
(	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
options	char
&	O
CSV_APPEND_NULL	int
)	O
?	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_size	long
-	O
1	int
:	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_size	long
)	O
)	O
{	O
if	O
(	O
csv_increase_buffer	(*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*`)),*((*`,long)->(*`)),*((*`)->(void)))))->(int)
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
!=	O
0	int
)	O
{	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quoted	int
=	O
quoted	int
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
pstate	int
=	O
pstate	int
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
spaces	long
=	O
spaces	long
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_pos	long
=	O
entry_pos	long
;	O
return	O
pos	long
;	O
}	O
}	O
c	char
=	O
us	*(char)
[	O
pos	long
++	O
]	O
;	O
switch	O
(	O
pstate	int
)	O
{	O
case	O
ROW_NOT_BEGUN	int
:	O
case	O
FIELD_NOT_BEGUN	int
:	O
if	O
(	O
is_space	*((char)->(int))
?	O
is_space	*((char)->(int))
(	O
c	char
)	O
:	O
c	char
==	O
CSV_SPACE	int
||	O
c	char
==	O
CSV_TAB	int
)	O
{	O
continue	O
;	O
}	O
else	O
if	O
(	O
is_term	*((char)->(int))
?	O
is_term	*((char)->(int))
(	O
c	char
)	O
:	O
c	char
==	O
CSV_CR	int
||	O
c	char
==	O
CSV_LF	int
)	O
{	O
if	O
(	O
pstate	int
==	O
FIELD_NOT_BEGUN	int
)	O
{	O
SUBMIT_FIELD	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
;	O
SUBMIT_ROW	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
(	O
unsigned	O
char	O
)	O
c	char
)	O
;	O
}	O
else	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
options	char
&	O
CSV_REPALL_NL	int
)	O
{	O
SUBMIT_ROW	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
(	O
unsigned	O
char	O
)	O
c	char
)	O
;	O
}	O
}	O
continue	O
;	O
}	O
else	O
if	O
(	O
c	char
==	O
delim	char
)	O
{	O
SUBMIT_FIELD	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
c	char
==	O
quote	char
)	O
{	O
pstate	int
=	O
FIELD_BEGUN	int
;	O
quoted	int
=	O
1	int
;	O
}	O
else	O
{	O
pstate	int
=	O
FIELD_BEGUN	int
;	O
quoted	int
=	O
0	int
;	O
SUBMIT_CHAR	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
c	char
)	O
;	O
}	O
break	O
;	O
case	O
FIELD_BEGUN	int
:	O
if	O
(	O
c	char
==	O
quote	char
)	O
{	O
if	O
(	O
quoted	int
)	O
{	O
SUBMIT_CHAR	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
c	char
)	O
;	O
pstate	int
=	O
FIELD_MIGHT_HAVE_ENDED	int
;	O
}	O
else	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
options	char
&	O
CSV_STRICT	int
)	O
{	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
status	int
=	O
CSV_EPARSE	int
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quoted	int
=	O
quoted	int
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
pstate	int
=	O
pstate	int
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
spaces	long
=	O
spaces	long
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_pos	long
=	O
entry_pos	long
;	O
return	O
pos	long
-	O
1	int
;	O
}	O
SUBMIT_CHAR	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
c	char
)	O
;	O
spaces	long
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
c	char
==	O
delim	char
)	O
{	O
if	O
(	O
quoted	int
)	O
{	O
SUBMIT_CHAR	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
c	char
)	O
;	O
}	O
else	O
{	O
SUBMIT_FIELD	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
is_term	*((char)->(int))
?	O
is_term	*((char)->(int))
(	O
c	char
)	O
:	O
c	char
==	O
CSV_CR	int
||	O
c	char
==	O
CSV_LF	int
)	O
{	O
if	O
(	O
!	O
quoted	int
)	O
{	O
SUBMIT_FIELD	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
;	O
SUBMIT_ROW	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
(	O
unsigned	O
char	O
)	O
c	char
)	O
;	O
}	O
else	O
{	O
SUBMIT_CHAR	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
c	char
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
quoted	int
&&	O
(	O
is_space	*((char)->(int))
?	O
is_space	*((char)->(int))
(	O
c	char
)	O
:	O
c	char
==	O
CSV_SPACE	int
||	O
c	char
==	O
CSV_TAB	int
)	O
)	O
{	O
SUBMIT_CHAR	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
c	char
)	O
;	O
spaces	long
++	O
;	O
}	O
else	O
{	O
SUBMIT_CHAR	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
c	char
)	O
;	O
spaces	long
=	O
0	int
;	O
}	O
break	O
;	O
case	O
FIELD_MIGHT_HAVE_ENDED	int
:	O
if	O
(	O
c	char
==	O
delim	char
)	O
{	O
entry_pos	long
-=	O
spaces	long
+	O
1	int
;	O
SUBMIT_FIELD	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
;	O
}	O
else	O
if	O
(	O
is_term	*((char)->(int))
?	O
is_term	*((char)->(int))
(	O
c	char
)	O
:	O
c	char
==	O
CSV_CR	int
||	O
c	char
==	O
CSV_LF	int
)	O
{	O
entry_pos	long
-=	O
spaces	long
+	O
1	int
;	O
SUBMIT_FIELD	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
)	O
;	O
SUBMIT_ROW	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
(	O
unsigned	O
char	O
)	O
c	char
)	O
;	O
}	O
else	O
if	O
(	O
is_space	*((char)->(int))
?	O
is_space	*((char)->(int))
(	O
c	char
)	O
:	O
c	char
==	O
CSV_SPACE	int
||	O
c	char
==	O
CSV_TAB	int
)	O
{	O
SUBMIT_CHAR	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
c	char
)	O
;	O
spaces	long
++	O
;	O
}	O
else	O
if	O
(	O
c	char
==	O
quote	char
)	O
{	O
if	O
(	O
spaces	long
)	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
options	char
&	O
CSV_STRICT	int
)	O
{	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
status	int
=	O
CSV_EPARSE	int
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quoted	int
=	O
quoted	int
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
pstate	int
=	O
pstate	int
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
spaces	long
=	O
spaces	long
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_pos	long
=	O
entry_pos	long
;	O
return	O
pos	long
-	O
1	int
;	O
}	O
spaces	long
=	O
0	int
;	O
SUBMIT_CHAR	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
c	char
)	O
;	O
}	O
else	O
{	O
pstate	int
=	O
FIELD_BEGUN	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
options	char
&	O
CSV_STRICT	int
)	O
{	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
status	int
=	O
CSV_EPARSE	int
;	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quoted	int
=	O
quoted	int
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
pstate	int
=	O
pstate	int
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
spaces	long
=	O
spaces	long
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_pos	long
=	O
entry_pos	long
;	O
return	O
pos	long
-	O
1	int
;	O
}	O
pstate	int
=	O
FIELD_BEGUN	int
;	O
spaces	long
=	O
0	int
;	O
SUBMIT_CHAR	O
(	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
,	O
c	char
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
quoted	int
=	O
quoted	int
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
pstate	int
=	O
pstate	int
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
spaces	long
=	O
spaces	long
,	O
p	*(struct(int,int,long,*(char),long,long,int,char,char,char,*((char)->(int)),*((char)->(int)),long,*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void))))
->	O
entry_pos	long
=	O
entry_pos	long
;	O
return	O
pos	long
;	O
}	O
size_t	long
csv_write	(*(void),long,*(void),long)->(long)
(	O
void	O
*	O
dest	*(void)
,	O
size_t	long
dest_size	long
,	O
const	O
void	O
*	O
src	*(void)
,	O
size_t	long
src_size	long
)	O
{	O
unsigned	O
char	O
*	O
cdest	*(char)
=	O
dest	*(void)
;	O
const	O
unsigned	O
char	O
*	O
csrc	*(char)
=	O
src	*(void)
;	O
size_t	long
chars	long
=	O
0	int
;	O
if	O
(	O
src	*(void)
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
cdest	*(char)
==	O
NULL	O
)	O
dest_size	long
=	O
0	int
;	O
if	O
(	O
dest_size	long
>	O
0	int
)	O
*	O
cdest	*(char)
++	O
=	O
'"'	O
;	O
chars	long
++	O
;	O
while	O
(	O
src_size	long
)	O
{	O
if	O
(	O
*	O
csrc	*(char)
==	O
'"'	O
)	O
{	O
if	O
(	O
dest_size	long
>	O
chars	long
)	O
*	O
cdest	*(char)
++	O
=	O
'"'	O
;	O
if	O
(	O
chars	long
<	O
SIZE_MAX	O
)	O
chars	long
++	O
;	O
}	O
if	O
(	O
dest_size	long
>	O
chars	long
)	O
*	O
cdest	*(char)
++	O
=	O
*	O
csrc	*(char)
;	O
if	O
(	O
chars	long
<	O
SIZE_MAX	O
)	O
chars	long
++	O
;	O
src_size	long
--	O
;	O
csrc	*(char)
++	O
;	O
}	O
if	O
(	O
dest_size	long
>	O
chars	long
)	O
*	O
cdest	*(char)
=	O
'"'	O
;	O
if	O
(	O
chars	long
<	O
SIZE_MAX	O
)	O
chars	long
++	O
;	O
return	O
chars	long
;	O
}	O
int	O
csv_fwrite	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),long)->(int)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
const	O
void	O
*	O
src	*(void)
,	O
size_t	long
src_size	long
)	O
{	O
const	O
unsigned	O
char	O
*	O
csrc	*(char)
=	O
src	*(void)
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
||	O
src	*(void)
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'"'	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
return	O
EOF	O
;	O
while	O
(	O
src_size	long
)	O
{	O
if	O
(	O
*	O
csrc	*(char)
==	O
'"'	O
)	O
{	O
if	O
(	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'"'	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
return	O
EOF	O
;	O
}	O
if	O
(	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
*	O
csrc	*(char)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
return	O
EOF	O
;	O
src_size	long
--	O
;	O
csrc	*(char)
++	O
;	O
}	O
if	O
(	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'"'	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
{	O
return	O
EOF	O
;	O
}	O
return	O
0	int
;	O
}	O
size_t	long
csv_write2	(*(void),long,*(void),long,char)->(long)
(	O
void	O
*	O
dest	*(void)
,	O
size_t	long
dest_size	long
,	O
const	O
void	O
*	O
src	*(void)
,	O
size_t	long
src_size	long
,	O
unsigned	O
char	O
quote	char
)	O
{	O
unsigned	O
char	O
*	O
cdest	*(char)
=	O
dest	*(void)
;	O
const	O
unsigned	O
char	O
*	O
csrc	*(char)
=	O
src	*(void)
;	O
size_t	long
chars	long
=	O
0	int
;	O
if	O
(	O
src	*(void)
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
dest	*(void)
==	O
NULL	O
)	O
dest_size	long
=	O
0	int
;	O
if	O
(	O
dest_size	long
>	O
0	int
)	O
*	O
cdest	*(char)
++	O
=	O
quote	char
;	O
chars	long
++	O
;	O
while	O
(	O
src_size	long
)	O
{	O
if	O
(	O
*	O
csrc	*(char)
==	O
quote	char
)	O
{	O
if	O
(	O
dest_size	long
>	O
chars	long
)	O
*	O
cdest	*(char)
++	O
=	O
quote	char
;	O
if	O
(	O
chars	long
<	O
SIZE_MAX	O
)	O
chars	long
++	O
;	O
}	O
if	O
(	O
dest_size	long
>	O
chars	long
)	O
*	O
cdest	*(char)
++	O
=	O
*	O
csrc	*(char)
;	O
if	O
(	O
chars	long
<	O
SIZE_MAX	O
)	O
chars	long
++	O
;	O
src_size	long
--	O
;	O
csrc	*(char)
++	O
;	O
}	O
if	O
(	O
dest_size	long
>	O
chars	long
)	O
*	O
cdest	*(char)
=	O
quote	char
;	O
if	O
(	O
chars	long
<	O
SIZE_MAX	O
)	O
chars	long
++	O
;	O
return	O
chars	long
;	O
}	O
int	O
csv_fwrite2	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),long,char)->(int)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
const	O
void	O
*	O
src	*(void)
,	O
size_t	long
src_size	long
,	O
unsigned	O
char	O
quote	char
)	O
{	O
const	O
unsigned	O
char	O
*	O
csrc	*(char)
=	O
src	*(void)
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
||	O
src	*(void)
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
quote	char
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
return	O
EOF	O
;	O
while	O
(	O
src_size	long
)	O
{	O
if	O
(	O
*	O
csrc	*(char)
==	O
quote	char
)	O
{	O
if	O
(	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
quote	char
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
return	O
EOF	O
;	O
}	O
if	O
(	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
*	O
csrc	*(char)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
return	O
EOF	O
;	O
src_size	long
--	O
;	O
csrc	*(char)
++	O
;	O
}	O
if	O
(	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
quote	char
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
{	O
return	O
EOF	O
;	O
}	O
return	O
0	int
;	O
}	O
