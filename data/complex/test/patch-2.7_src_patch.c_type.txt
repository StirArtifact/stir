static	O
FILE	struct
*	O
create_output_file	(*(char),int)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
char	O
const	O
*	O
,	O
int	O
)	O
;	O
static	O
lin	long
locate_hunk	(long)->(long)
(	O
lin	long
)	O
;	O
static	O
bool	bool
apply_hunk	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)),long)->(bool)
(	O
struct	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
*	O
,	O
lin	long
)	O
;	O
static	O
bool	bool
patch_match	(long,long,long,long)->(bool)
(	O
lin	long
,	O
lin	long
,	O
lin	long
,	O
lin	long
)	O
;	O
static	O
bool	bool
spew_output	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(bool)
(	O
struct	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
*	O
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
)	O
;	O
static	O
int	O
numeric_string	(*(char),bool,*(char))->(int)
(	O
char	O
const	O
*	O
,	O
bool	bool
,	O
char	O
const	O
*	O
)	O
;	O
static	O
void	O
cleanup	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
get_some_switches	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
init_output	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)))->(void)
(	O
struct	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
*	O
)	O
;	O
static	O
FILE	struct
*	O
open_outfile	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
char	O
const	O
*	O
)	O
;	O
static	O
void	O
init_reject	(*(char))->(void)
(	O
char	O
const	O
*	O
)	O
;	O
static	O
void	O
reinitialize_almost_everything	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
remove_if_needed	(*(char),*(int))->(void)
(	O
char	O
const	O
*	O
,	O
int	O
*	O
)	O
;	O
static	O
void	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
FILE	struct
*	O
,	O
int	O
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
void	O
abort_hunk	(*(char),bool,bool)->(void)
(	O
char	O
const	O
*	O
,	O
bool	bool
,	O
bool	bool
)	O
;	O
static	O
void	O
abort_hunk_context	(bool,bool)->(void)
(	O
bool	bool
,	O
bool	bool
)	O
;	O
static	O
void	O
abort_hunk_unified	(bool,bool)->(void)
(	O
bool	bool
,	O
bool	bool
)	O
;	O
static	O
void	O
output_file	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,bool)->(void)
(	O
char	O
const	O
*	O
,	O
int	O
*	O
,	O
const	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
,	O
char	O
const	O
*	O
,	O
const	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
,	O
mode_t	int
,	O
bool	bool
)	O
;	O
static	O
void	O
init_files_to_delete	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
init_files_to_output	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
delete_files	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
output_files	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(void)
(	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
const	O
*	O
)	O
;	O
static	O
bool	bool
merge	bool
;	O
static	O
enum	O
diff	enum(int,int,int,int,int,int,int)
reject_format	enum(int,int,int,int,int,int,int)
=	O
NO_DIFF	int
;	O
static	O
bool	bool
make_backups	bool
;	O
static	O
bool	bool
backup_if_mismatch	bool
;	O
static	O
char	O
const	O
*	O
version_control	*(char)
;	O
static	O
char	O
const	O
*	O
version_control_context	*(char)
;	O
static	O
bool	bool
remove_empty_files	bool
;	O
static	O
bool	bool
explicit_inname	bool
;	O
static	O
enum	O
{	O
RO_IGNORE	int
,	O
RO_WARN	int
,	O
RO_FAIL	int
}	O
read_only_behavior	enum(int,int,int)
=	O
RO_WARN	int
;	O
static	O
bool	bool
reverse_flag_specified	bool
;	O
static	O
char	O
const	O
*	O
do_defines	*(char)
;	O
static	O
char	O
const	O
if_defined	array(char)
[	O
]	O
=	O
"\n#ifdef %s\n"	*(char)
;	O
static	O
char	O
const	O
not_defined	array(char)
[	O
]	O
=	O
"\n#ifndef %s\n"	*(char)
;	O
static	O
char	O
const	O
else_defined	array(char)
[	O
]	O
=	O
"\n#else\n"	*(char)
;	O
static	O
char	O
const	O
end_defined	array(char)
[	O
]	O
=	O
"\n#endif\n"	*(char)
;	O
static	O
int	O
Argc	int
;	O
static	O
char	O
*	O
*	O
Argv	*(*(char))
;	O
static	O
FILE	struct
*	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
static	O
char	O
const	O
*	O
patchname	*(char)
;	O
static	O
char	O
*	O
rejname	*(char)
;	O
static	O
char	O
const	O
*	O
TMPREJNAME	*(char)
;	O
static	O
int	O
TMPREJNAME_needs_removal	int
;	O
static	O
lin	long
maxfuzz	long
=	O
2	int
;	O
static	O
char	O
serrbuf	array(char)
[	O
BUFSIZ	int
]	O
;	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
char	O
const	O
*	O
val	array(int)
;	O
bool	bool
somefailed	bool
=	O
false	int
;	O
struct	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
tmpoutst	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
char	O
numbuf	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
bool	bool
written_to_rejname	bool
=	O
false	int
;	O
bool	bool
apply_empty_patch	bool
=	O
false	int
;	O
mode_t	int
file_type	int
;	O
int	O
outfd	int
=	O
-	O
1	int
;	O
bool	bool
have_git_diff	bool
=	O
false	int
;	O
exit_failure	int
=	O
2	int
;	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
init_time	()->(void)
(	O
)	O
;	O
setbuf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
serrbuf	array(char)
)	O
;	O
bufsize	long
=	O
8	int
*	O
1024	int
;	O
buf	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
bufsize	long
)	O
;	O
strippath	int
=	O
-	O
1	int
;	O
val	array(int)
=	O
getenv	(*(char))->(*(char))
(	O
"QUOTING_STYLE"	*(char)
)	O
;	O
{	O
int	O
i	int
=	O
val	array(int)
?	O
argmatch	(*(char),*(*(char)),*(char),long)->(long)
(	O
val	array(int)
,	O
quoting_style_args	array(*(char))
,	O
0	int
,	O
0	int
)	O
:	O
-	O
1	int
;	O
set_quoting_style	(*(struct),enum(int,int,int,int,int,int,int,int,int))->(void)
(	O
(	O
struct	O
quoting_options	O
*	O
)	O
0	int
,	O
i	int
<	O
0	int
?	O
shell_quoting_style	int
:	O
(	O
enum	O
quoting_style	enum(int,int,int,int,int,int,int,int,int)
)	O
i	int
)	O
;	O
}	O
posixly_correct	bool
=	O
getenv	(*(char))->(*(char))
(	O
"POSIXLY_CORRECT"	*(char)
)	O
!=	O
0	int
;	O
backup_if_mismatch	bool
=	O
!	O
posixly_correct	bool
;	O
patch_get	int
=	O
(	O
(	O
val	array(int)
=	O
getenv	(*(char))->(*(char))
(	O
"PATCH_GET"	*(char)
)	O
)	O
?	O
numeric_string	(*(char),bool,*(char))->(int)
(	O
val	array(int)
,	O
true	int
,	O
"PATCH_GET value"	*(char)
)	O
:	O
0	int
)	O
;	O
val	array(int)
=	O
getenv	(*(char))->(*(char))
(	O
"SIMPLE_BACKUP_SUFFIX"	*(char)
)	O
;	O
simple_backup_suffix	*(char)
=	O
val	array(int)
&&	O
*	O
val	array(int)
?	O
val	array(int)
:	O
".orig"	*(char)
;	O
if	O
(	O
(	O
version_control	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"PATCH_VERSION_CONTROL"	*(char)
)	O
)	O
)	O
version_control_context	*(char)
=	O
"$PATCH_VERSION_CONTROL"	*(char)
;	O
else	O
if	O
(	O
(	O
version_control	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"VERSION_CONTROL"	*(char)
)	O
)	O
)	O
version_control_context	*(char)
=	O
"$VERSION_CONTROL"	*(char)
;	O
Argc	int
=	O
argc	int
;	O
Argv	*(*(char))
=	O
argv	*(*(char))
;	O
get_some_switches	()->(void)
(	O
)	O
;	O
if	O
(	O
set_utc	bool
)	O
setenv	(*(char),*(char),int)->(int)
(	O
"TZ"	*(char)
,	O
"UTC"	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
make_backups	bool
|	O
backup_if_mismatch	bool
)	O
backup_type	enum(int,int,int,int)
=	O
get_version	(*(char),*(char))->(enum(int,int,int,int))
(	O
version_control_context	*(char)
,	O
version_control	*(char)
)	O
;	O
init_backup_hash_table	()->(void)
(	O
)	O
;	O
init_files_to_delete	()->(void)
(	O
)	O
;	O
init_files_to_output	()->(void)
(	O
)	O
;	O
init_output	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)))->(void)
(	O
&	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
)	O
;	O
if	O
(	O
outfile	*(char)
)	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
open_outfile	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
outfile	*(char)
)	O
;	O
set_signals	(bool)->(void)
(	O
false	int
)	O
;	O
if	O
(	O
inname	*(char)
&&	O
outfile	*(char)
)	O
{	O
apply_empty_patch	bool
=	O
true	int
;	O
file_type	int
=	O
S_IFREG	O
;	O
inerrno	int
=	O
-	O
1	int
;	O
}	O
for	O
(	O
open_patch_file	(*(char))->(void)
(	O
patchname	*(char)
)	O
;	O
there_is_another_patch	(bool,*(int))->(bool)
(	O
!	O
(	O
inname	*(char)
||	O
posixly_correct	bool
)	O
,	O
&	O
file_type	int
)	O
||	O
apply_empty_patch	bool
;	O
reinitialize_almost_everything	()->(void)
(	O
)	O
,	O
apply_empty_patch	bool
=	O
false	int
)	O
{	O
int	O
hunk	int
=	O
0	int
;	O
int	O
failed	int
=	O
0	int
;	O
bool	bool
mismatch	bool
=	O
false	int
;	O
char	O
const	O
*	O
outname	*(char)
=	O
NULL	O
;	O
if	O
(	O
have_git_diff	bool
!=	O
pch_git_diff	()->(bool)
(	O
)	O
)	O
{	O
have_git_diff	bool
=	O
!	O
have_git_diff	bool
;	O
output_files	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(void)
(	O
NULL	O
)	O
;	O
}	O
if	O
(	O
TMPREJNAME_needs_removal	int
)	O
{	O
if	O
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
}	O
remove_if_needed	(*(char),*(int))->(void)
(	O
TMPREJNAME	*(char)
,	O
&	O
TMPREJNAME_needs_removal	int
)	O
;	O
}	O
if	O
(	O
TMPOUTNAME_needs_removal	int
)	O
{	O
if	O
(	O
outfd	int
!=	O
-	O
1	int
)	O
{	O
close	*((*(void))->(int))
(	O
outfd	int
)	O
;	O
outfd	int
=	O
-	O
1	int
;	O
}	O
remove_if_needed	(*(char),*(int))->(void)
(	O
TMPOUTNAME	*(char)
,	O
&	O
TMPOUTNAME_needs_removal	int
)	O
;	O
}	O
if	O
(	O
!	O
skip_rest_of_patch	bool
&&	O
!	O
file_type	int
)	O
{	O
say	(*(char))->(void)
(	O
"File %s: can't change file type from 0%o to 0%o.\n"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
inname	*(char)
)	O
,	O
pch_mode	(bool)->(int)
(	O
reverse	bool
)	O
&	O
S_IFMT	O
,	O
pch_mode	(bool)->(int)
(	O
!	O
reverse	bool
)	O
&	O
S_IFMT	O
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
somefailed	bool
=	O
true	int
;	O
}	O
if	O
(	O
!	O
skip_rest_of_patch	bool
)	O
{	O
if	O
(	O
outfile	*(char)
)	O
outname	*(char)
=	O
outfile	*(char)
;	O
else	O
if	O
(	O
pch_copy	()->(bool)
(	O
)	O
||	O
pch_rename	()->(bool)
(	O
)	O
)	O
outname	*(char)
=	O
pch_name	(enum(int,int,int,int))->(*(char))
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
inname	*(char)
,	O
pch_name	(enum(int,int,int,int))->(*(char))
(	O
OLD	int
)	O
)	O
)	O
;	O
else	O
outname	*(char)
=	O
inname	*(char)
;	O
}	O
if	O
(	O
pch_git_diff	()->(bool)
(	O
)	O
&&	O
!	O
skip_rest_of_patch	bool
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
outstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
outerrno	int
=	O
0	int
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
inname	*(char)
,	O
outname	*(char)
)	O
)	O
{	O
if	O
(	O
inerrno	int
==	O
-	O
1	int
)	O
inerrno	int
=	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
inname	*(char)
,	O
&	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
?	O
errno	O
:	O
0	int
;	O
outstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
=	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
outerrno	int
=	O
inerrno	int
;	O
}	O
else	O
outerrno	int
=	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
outname	*(char)
,	O
&	O
outstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
?	O
errno	O
:	O
0	int
;	O
if	O
(	O
!	O
outerrno	int
)	O
{	O
if	O
(	O
has_queued_output	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(bool)
(	O
&	O
outstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
{	O
output_files	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(void)
(	O
&	O
outstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
outerrno	int
=	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
outname	*(char)
,	O
&	O
outstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
?	O
errno	O
:	O
0	int
;	O
inerrno	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
outerrno	int
)	O
set_queued_output	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),bool)->(void)
(	O
&	O
outstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
true	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
skip_rest_of_patch	bool
)	O
{	O
if	O
(	O
!	O
get_input_file	(*(char),*(char),int)->(bool)
(	O
inname	*(char)
,	O
outname	*(char)
,	O
file_type	int
)	O
)	O
{	O
skip_rest_of_patch	bool
=	O
true	int
;	O
somefailed	bool
=	O
true	int
;	O
}	O
}	O
if	O
(	O
read_only_behavior	enum(int,int,int)
!=	O
RO_IGNORE	int
&&	O
!	O
inerrno	int
&&	O
!	O
S_ISLNK	O
(	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
&&	O
access	(*(char),int)->(int)
(	O
inname	*(char)
,	O
W_OK	int
)	O
!=	O
0	int
)	O
{	O
say	(*(char))->(void)
(	O
"File %s is read-only; "	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
inname	*(char)
)	O
)	O
;	O
if	O
(	O
read_only_behavior	enum(int,int,int)
==	O
RO_WARN	int
)	O
say	(*(char))->(void)
(	O
"trying to patch anyway\n"	*(char)
)	O
;	O
else	O
{	O
say	(*(char))->(void)
(	O
"refusing to patch\n"	*(char)
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
somefailed	bool
=	O
true	int
;	O
}	O
}	O
tmpoutst	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
=	O
-	O
1	int
;	O
outfd	int
=	O
make_tempfile	(*(*(char)),char,*(char),int,int)->(int)
(	O
&	O
TMPOUTNAME	*(char)
,	O
'o'	O
,	O
outname	*(char)
,	O
O_WRONLY	int
|	O
binary_transput	int
,	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
;	O
TMPOUTNAME_needs_removal	int
=	O
1	int
;	O
if	O
(	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
ED_DIFF	int
)	O
{	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
zero_output	bool
=	O
false	int
;	O
somefailed	bool
|=	O
skip_rest_of_patch	bool
;	O
do_ed_script	(*(char),*(char),*(int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
inname	*(char)
,	O
TMPOUTNAME	*(char)
,	O
&	O
TMPOUTNAME_needs_removal	int
,	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
dry_run	bool
&&	O
!	O
outfile	*(char)
&&	O
!	O
skip_rest_of_patch	bool
)	O
{	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
outfd	int
,	O
&	O
tmpoutst	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"%s"	*(char)
,	O
TMPOUTNAME	*(char)
)	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
zero_output	bool
=	O
tmpoutst	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
==	O
0	int
;	O
}	O
close	*((*(void))->(int))
(	O
outfd	int
)	O
;	O
outfd	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
int	O
got_hunk	int
;	O
bool	bool
apply_anyway	bool
=	O
merge	bool
;	O
if	O
(	O
!	O
skip_rest_of_patch	bool
&&	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
GIT_BINARY_DIFF	int
)	O
{	O
say	(*(char))->(void)
(	O
"File %s: git binary diffs are not supported.\n"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
outname	*(char)
)	O
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
somefailed	bool
=	O
true	int
;	O
}	O
if	O
(	O
!	O
skip_rest_of_patch	bool
&&	O
!	O
outfile	*(char)
)	O
{	O
init_output	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)))->(void)
(	O
&	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
)	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
outfd	int
,	O
binary_transput	int
?	O
"wb"	*(char)
:	O
"w"	*(char)
)	O
;	O
if	O
(	O
!	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
pfatal	(*(char))->(void)
(	O
"%s"	*(char)
,	O
TMPOUTNAME	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
skip_rest_of_patch	bool
)	O
{	O
scan_input	(*(char),int)->(void)
(	O
inname	*(char)
,	O
file_type	int
)	O
;	O
if	O
(	O
verbosity	enum(int,int,int)
!=	O
SILENT	int
)	O
{	O
bool	bool
renamed	bool
=	O
strcmp	(*(char),*(char))->(int)
(	O
inname	*(char)
,	O
outname	*(char)
)	O
;	O
say	(*(char))->(void)
(	O
"patching %s %s%c"	*(char)
,	O
S_ISLNK	O
(	O
file_type	int
)	O
?	O
"symbolic link"	*(char)
:	O
"file"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
outname	*(char)
)	O
,	O
renamed	bool
?	O
' '	O
:	O
'\n'	O
)	O
;	O
if	O
(	O
renamed	bool
)	O
say	(*(char))->(void)
(	O
"(%s from %s)\n"	*(char)
,	O
pch_copy	()->(bool)
(	O
)	O
?	O
"copied"	*(char)
:	O
(	O
pch_rename	()->(bool)
(	O
)	O
?	O
"renamed"	*(char)
:	O
"read"	*(char)
)	O
,	O
inname	*(char)
)	O
;	O
if	O
(	O
verbosity	enum(int,int,int)
==	O
VERBOSE	int
)	O
say	(*(char))->(void)
(	O
"Using Plan %s...\n"	*(char)
,	O
using_plan_a	bool
?	O
"A"	*(char)
:	O
"B"	*(char)
)	O
;	O
}	O
}	O
while	O
(	O
0	int
<	O
(	O
got_hunk	int
=	O
another_hunk	(enum(int,int,int,int,int,int,int),bool)->(int)
(	O
diff_type	enum(int,int,int,int,int,int,int)
,	O
reverse	bool
)	O
)	O
)	O
{	O
lin	long
where	long
=	O
0	int
;	O
lin	long
newwhere	long
;	O
lin	long
fuzz	long
=	O
0	int
;	O
lin	long
mymaxfuzz	long
;	O
if	O
(	O
merge	bool
)	O
{	O
mymaxfuzz	long
=	O
0	int
;	O
}	O
else	O
{	O
lin	long
prefix_context	long
=	O
pch_prefix_context	()->(long)
(	O
)	O
;	O
lin	long
suffix_context	long
=	O
pch_suffix_context	()->(long)
(	O
)	O
;	O
lin	long
context	*(char)
=	O
(	O
prefix_context	long
<	O
suffix_context	long
?	O
suffix_context	long
:	O
prefix_context	long
)	O
;	O
mymaxfuzz	long
=	O
(	O
maxfuzz	long
<	O
context	*(char)
?	O
maxfuzz	long
:	O
context	*(char)
)	O
;	O
}	O
hunk	int
++	O
;	O
if	O
(	O
!	O
skip_rest_of_patch	bool
)	O
{	O
do	O
{	O
where	long
=	O
locate_hunk	(long)->(long)
(	O
fuzz	long
)	O
;	O
if	O
(	O
!	O
where	long
||	O
fuzz	long
||	O
in_offset	long
)	O
mismatch	bool
=	O
true	int
;	O
if	O
(	O
hunk	int
==	O
1	int
&&	O
!	O
where	long
&&	O
!	O
(	O
force	bool
|	O
apply_anyway	bool
)	O
&&	O
reverse	bool
==	O
reverse_flag_specified	bool
)	O
{	O
if	O
(	O
!	O
pch_swap	()->(bool)
(	O
)	O
)	O
{	O
say	(*(char))->(void)
(	O
"Not enough memory to try swapped hunk!  Assuming unswapped.\n"	*(char)
)	O
;	O
continue	O
;	O
}	O
where	long
=	O
locate_hunk	(long)->(long)
(	O
fuzz	long
)	O
;	O
if	O
(	O
where	long
&&	O
(	O
ok_to_reverse	(*(char))->(bool)
(	O
"%s patch detected!"	*(char)
,	O
(	O
reverse	bool
?	O
"Unreversed"	*(char)
:	O
"Reversed (or previously applied)"	*(char)
)	O
)	O
)	O
)	O
reverse	bool
=	O
!	O
reverse	bool
;	O
else	O
{	O
if	O
(	O
!	O
pch_swap	()->(bool)
(	O
)	O
)	O
fatal	(*(char))->(void)
(	O
"lost hunk on alloc error!"	*(char)
)	O
;	O
if	O
(	O
where	long
)	O
{	O
apply_anyway	bool
=	O
true	int
;	O
fuzz	long
--	O
;	O
where	long
=	O
0	int
;	O
}	O
}	O
}	O
}	O
while	O
(	O
!	O
skip_rest_of_patch	bool
&&	O
!	O
where	long
&&	O
++	O
fuzz	long
<=	O
mymaxfuzz	long
)	O
;	O
if	O
(	O
skip_rest_of_patch	bool
)	O
{	O
if	O
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
&&	O
!	O
outfile	*(char)
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
0	int
;	O
outfd	int
=	O
-	O
1	int
;	O
}	O
}	O
}	O
newwhere	long
=	O
(	O
where	long
?	O
where	long
:	O
pch_first	()->(long)
(	O
)	O
)	O
+	O
out_offset	long
;	O
if	O
(	O
skip_rest_of_patch	bool
||	O
(	O
merge	bool
&&	O
!	O
merge_hunk	(int,*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)),long,*(bool))->(bool)
(	O
hunk	int
,	O
&	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
,	O
where	long
,	O
&	O
somefailed	bool
)	O
)	O
||	O
(	O
!	O
merge	bool
&&	O
(	O
(	O
where	long
==	O
1	int
&&	O
pch_says_nonexistent	(bool)->(int)
(	O
reverse	bool
)	O
==	O
2	int
&&	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
||	O
!	O
where	long
||	O
!	O
apply_hunk	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)),long)->(bool)
(	O
&	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
,	O
where	long
)	O
)	O
)	O
)	O
{	O
abort_hunk	(*(char),bool,bool)->(void)
(	O
outname	*(char)
,	O
!	O
failed	int
,	O
reverse	bool
)	O
;	O
failed	int
++	O
;	O
if	O
(	O
verbosity	enum(int,int,int)
==	O
VERBOSE	int
||	O
(	O
!	O
skip_rest_of_patch	bool
&&	O
verbosity	enum(int,int,int)
!=	O
SILENT	int
)	O
)	O
say	(*(char))->(void)
(	O
"Hunk #%d %s at %s.\n"	*(char)
,	O
hunk	int
,	O
skip_rest_of_patch	bool
?	O
"ignored"	*(char)
:	O
"FAILED"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf	array(char)
,	O
newwhere	long
)	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
merge	bool
&&	O
(	O
verbosity	enum(int,int,int)
==	O
VERBOSE	int
||	O
(	O
verbosity	enum(int,int,int)
!=	O
SILENT	int
&&	O
(	O
fuzz	long
||	O
in_offset	long
)	O
)	O
)	O
)	O
{	O
say	(*(char))->(void)
(	O
"Hunk #%d succeeded at %s"	*(char)
,	O
hunk	int
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf	array(char)
,	O
newwhere	long
)	O
)	O
;	O
if	O
(	O
fuzz	long
)	O
say	(*(char))->(void)
(	O
" with fuzz %s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf	array(char)
,	O
fuzz	long
)	O
)	O
;	O
if	O
(	O
in_offset	long
)	O
say	(*(char))->(void)
(	O
" (offset %s line%s)"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf	array(char)
,	O
in_offset	long
)	O
,	O
"s"	*(char)
+	O
(	O
in_offset	long
==	O
1	int
)	O
)	O
;	O
say	(*(char))->(void)
(	O
".\n"	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
!	O
skip_rest_of_patch	bool
)	O
{	O
if	O
(	O
got_hunk	int
<	O
0	int
&&	O
using_plan_a	bool
)	O
{	O
if	O
(	O
outfile	*(char)
)	O
fatal	(*(char))->(void)
(	O
"out of memory using Plan A"	*(char)
)	O
;	O
say	(*(char))->(void)
(	O
"\n\nRan out of memory using Plan A -- trying again...\n\n"	*(char)
)	O
;	O
if	O
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
0	int
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
!	O
spew_output	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(bool)
(	O
&	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
,	O
&	O
tmpoutst	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
{	O
say	(*(char))->(void)
(	O
"Skipping patch.\n"	*(char)
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
}	O
}	O
}	O
ignore_signals	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
skip_rest_of_patch	bool
&&	O
!	O
outfile	*(char)
)	O
{	O
bool	bool
backup	bool
=	O
make_backups	bool
||	O
(	O
backup_if_mismatch	bool
&&	O
(	O
mismatch	bool
|	O
failed	int
)	O
)	O
;	O
if	O
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
zero_output	bool
&&	O
(	O
remove_empty_files	bool
||	O
(	O
pch_says_nonexistent	(bool)->(int)
(	O
!	O
reverse	bool
)	O
==	O
2	int
&&	O
!	O
posixly_correct	bool
)	O
||	O
S_ISLNK	O
(	O
file_type	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
dry_run	bool
)	O
output_file	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,bool)->(void)
(	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
outname	*(char)
,	O
(	O
inname	*(char)
==	O
outname	*(char)
)	O
?	O
&	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
:	O
NULL	O
,	O
file_type	int
|	O
0	int
,	O
backup	bool
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
zero_output	bool
&&	O
pch_says_nonexistent	(bool)->(int)
(	O
!	O
reverse	bool
)	O
&&	O
!	O
(	O
merge	bool
&&	O
somefailed	bool
)	O
)	O
{	O
mismatch	bool
=	O
true	int
;	O
if	O
(	O
verbosity	enum(int,int,int)
!=	O
SILENT	int
)	O
say	(*(char))->(void)
(	O
"File %s is not empty after patch, as expected\n"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
outname	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
!	O
dry_run	bool
)	O
{	O
mode_t	int
old_mode	int
=	O
pch_mode	(bool)->(int)
(	O
reverse	bool
)	O
;	O
mode_t	int
new_mode	int
=	O
pch_mode	(bool)->(int)
(	O
!	O
reverse	bool
)	O
;	O
bool	bool
set_mode	bool
=	O
new_mode	int
&&	O
old_mode	int
!=	O
new_mode	int
;	O
if	O
(	O
failed	int
<	O
hunk	int
||	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
ED_DIFF	int
||	O
set_mode	bool
||	O
pch_copy	()->(bool)
(	O
)	O
||	O
pch_rename	()->(bool)
(	O
)	O
)	O
{	O
enum	O
file_attributes	enum(int,int,int,int)
attr	enum(int,int,int,int)
=	O
0	int
;	O
struct	O
timespec	struct(long,long)
new_time	struct(long,long)
=	O
pch_timestamp	(bool)->(struct(long,long))
(	O
!	O
reverse	bool
)	O
;	O
mode_t	int
mode	int
=	O
file_type	int
|	O
(	O
(	O
new_mode	int
?	O
new_mode	int
:	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
&	O
S_IRWXUGO	O
)	O
;	O
if	O
(	O
(	O
set_time	bool
|	O
set_utc	bool
)	O
&&	O
new_time	struct(long,long)
.	O
tv_sec	long
!=	O
-	O
1	int
)	O
{	O
struct	O
timespec	struct(long,long)
old_time	struct(long,long)
=	O
pch_timestamp	(bool)->(struct(long,long))
(	O
reverse	bool
)	O
;	O
if	O
(	O
!	O
force	bool
&&	O
!	O
inerrno	int
&&	O
pch_says_nonexistent	(bool)->(int)
(	O
reverse	bool
)	O
!=	O
2	int
&&	O
old_time	struct(long,long)
.	O
tv_sec	long
!=	O
-	O
1	int
&&	O
timespec_cmp	(struct(long,long),struct(long,long))->(int)
(	O
old_time	struct(long,long)
,	O
get_stat_mtime	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(struct(long,long))
(	O
&	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
)	O
say	(*(char))->(void)
(	O
"Not setting time of file %s "	*(char)
"(time mismatch)\n"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
outname	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
!	O
force	bool
&&	O
(	O
mismatch	bool
|	O
failed	int
)	O
)	O
say	(*(char))->(void)
(	O
"Not setting time of file %s "	*(char)
"(contents mismatch)\n"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
outname	*(char)
)	O
)	O
;	O
else	O
attr	enum(int,int,int,int)
|=	O
FA_TIMES	int
;	O
}	O
if	O
(	O
inerrno	int
)	O
set_file_attributes	(*(char),enum(int,int,int,int),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,*(struct(long,long)))->(void)
(	O
TMPOUTNAME	*(char)
,	O
attr	enum(int,int,int,int)
,	O
NULL	O
,	O
NULL	O
,	O
mode	int
,	O
&	O
new_time	struct(long,long)
)	O
;	O
else	O
{	O
attr	enum(int,int,int,int)
|=	O
FA_IDS	int
|	O
FA_MODE	int
|	O
FA_XATTRS	int
;	O
set_file_attributes	(*(char),enum(int,int,int,int),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,*(struct(long,long)))->(void)
(	O
TMPOUTNAME	*(char)
,	O
attr	enum(int,int,int,int)
,	O
inname	*(char)
,	O
&	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
mode	int
,	O
&	O
new_time	struct(long,long)
)	O
;	O
}	O
output_file	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,bool)->(void)
(	O
TMPOUTNAME	*(char)
,	O
&	O
TMPOUTNAME_needs_removal	int
,	O
&	O
tmpoutst	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
outname	*(char)
,	O
NULL	O
,	O
mode	int
,	O
backup	bool
)	O
;	O
if	O
(	O
pch_rename	()->(bool)
(	O
)	O
)	O
output_file	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,bool)->(void)
(	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
inname	*(char)
,	O
&	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
mode	int
,	O
backup	bool
)	O
;	O
}	O
else	O
output_file	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,bool)->(void)
(	O
outname	*(char)
,	O
NULL	O
,	O
&	O
tmpoutst	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
NULL	O
,	O
NULL	O
,	O
file_type	int
|	O
0	int
,	O
backup	bool
)	O
;	O
}	O
}	O
}	O
if	O
(	O
diff_type	enum(int,int,int,int,int,int,int)
!=	O
ED_DIFF	int
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
rejst	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
failed	int
)	O
{	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
&	O
rejst	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
0	int
||	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
write_fatal	()->(void)
(	O
)	O
;	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
somefailed	bool
=	O
true	int
;	O
say	(*(char))->(void)
(	O
"%d out of %d hunk%s %s"	*(char)
,	O
failed	int
,	O
hunk	int
,	O
"s"	*(char)
+	O
(	O
hunk	int
==	O
1	int
)	O
,	O
skip_rest_of_patch	bool
?	O
"ignored"	*(char)
:	O
"FAILED"	*(char)
)	O
;	O
if	O
(	O
outname	*(char)
&&	O
(	O
!	O
rejname	*(char)
||	O
strcmp	(*(char),*(char))->(int)
(	O
rejname	*(char)
,	O
"-"	*(char)
)	O
!=	O
0	int
)	O
)	O
{	O
char	O
*	O
rej	*(char)
=	O
rejname	*(char)
;	O
if	O
(	O
!	O
rejname	*(char)
)	O
{	O
const	O
char	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
simple_backup_suffix	*(char)
;	O
size_t	long
len	long
;	O
simple_backup_suffix	*(char)
=	O
".rej"	*(char)
;	O
rej	*(char)
=	O
find_backup_file_name	(*(char),enum(int,int,int,int))->(*(char))
(	O
outname	*(char)
,	O
simple_backups	int
)	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
rej	*(char)
)	O
;	O
if	O
(	O
rej	*(char)
[	O
len	long
-	O
1	int
]	O
==	O
'~'	O
)	O
rej	*(char)
[	O
len	long
-	O
1	int
]	O
=	O
'#'	O
;	O
simple_backup_suffix	*(char)
=	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
}	O
say	(*(char))->(void)
(	O
" -- saving rejects to file %s\n"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
rej	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
dry_run	bool
)	O
{	O
if	O
(	O
rejname	*(char)
)	O
{	O
if	O
(	O
!	O
written_to_rejname	bool
)	O
{	O
copy_file	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,int,bool)->(void)
(	O
TMPREJNAME	*(char)
,	O
rejname	*(char)
,	O
0	int
,	O
0	int
,	O
S_IFREG	O
|	O
0666	int
,	O
true	int
)	O
;	O
written_to_rejname	bool
=	O
true	int
;	O
}	O
else	O
append_to_file	(*(char),*(char))->(void)
(	O
TMPREJNAME	*(char)
,	O
rejname	*(char)
)	O
;	O
}	O
else	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
oldst	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
olderrno	int
;	O
olderrno	int
=	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
rej	*(char)
,	O
&	O
oldst	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
?	O
errno	O
:	O
0	int
;	O
if	O
(	O
olderrno	int
&&	O
olderrno	int
!=	O
ENOENT	int
)	O
write_fatal	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
olderrno	int
&&	O
lookup_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(enum(int,int,int,int))
(	O
&	O
oldst	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
CREATED	int
)	O
append_to_file	(*(char),*(char))->(void)
(	O
TMPREJNAME	*(char)
,	O
rej	*(char)
)	O
;	O
else	O
move_file	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(char),int,bool)->(void)
(	O
TMPREJNAME	*(char)
,	O
&	O
TMPREJNAME_needs_removal	int
,	O
&	O
rejst	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
rej	*(char)
,	O
S_IFREG	O
|	O
0666	int
,	O
false	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
rejname	*(char)
)	O
free	(*(void))->(void)
(	O
rej	*(char)
)	O
;	O
}	O
else	O
say	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
}	O
}	O
set_signals	(bool)->(void)
(	O
true	int
)	O
;	O
}	O
if	O
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
&&	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
||	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
.	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
)	O
write_fatal	()->(void)
(	O
)	O
;	O
output_files	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(void)
(	O
NULL	O
)	O
;	O
delete_files	()->(void)
(	O
)	O
;	O
cleanup	()->(void)
(	O
)	O
;	O
if	O
(	O
somefailed	bool
)	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
reinitialize_almost_everything	()->(void)
(	O
void	O
)	O
{	O
re_patch	()->(void)
(	O
)	O
;	O
re_input	()->(void)
(	O
)	O
;	O
input_lines	long
=	O
0	int
;	O
last_frozen_line	long
=	O
0	int
;	O
if	O
(	O
inname	*(char)
&&	O
!	O
explicit_inname	bool
)	O
{	O
free	(*(void))->(void)
(	O
inname	*(char)
)	O
;	O
inname	*(char)
=	O
0	int
;	O
}	O
in_offset	long
=	O
0	int
;	O
out_offset	long
=	O
0	int
;	O
diff_type	enum(int,int,int,int,int,int,int)
=	O
NO_DIFF	int
;	O
if	O
(	O
revision	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
revision	*(char)
)	O
;	O
revision	*(char)
=	O
0	int
;	O
}	O
reverse	bool
=	O
reverse_flag_specified	bool
;	O
skip_rest_of_patch	bool
=	O
false	int
;	O
}	O
static	O
char	O
const	O
shortopts	array(char)
[	O
]	O
=	O
"bB:cd:D:eEfF:g:i:l"	*(char)
"nNo:p:r:RstTuvV:x:Y:z:Z"	*(char)
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
const	O
longopts	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"backup"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'b'	O
}	O
,	O
{	O
"prefix"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'B'	O
}	O
,	O
{	O
"context"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'c'	O
}	O
,	O
{	O
"directory"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"ifdef"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'D'	O
}	O
,	O
{	O
"ed"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"remove-empty-files"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'E'	O
}	O
,	O
{	O
"force"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'f'	O
}	O
,	O
{	O
"fuzz"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'F'	O
}	O
,	O
{	O
"get"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'g'	O
}	O
,	O
{	O
"input"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"ignore-whitespace"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"merge"	*(char)
,	O
optional_argument	int
,	O
NULL	O
,	O
'm'	O
}	O
,	O
{	O
"normal"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
{	O
"forward"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'N'	O
}	O
,	O
{	O
"output"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'o'	O
}	O
,	O
{	O
"strip"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'p'	O
}	O
,	O
{	O
"reject-file"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"reverse"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'R'	O
}	O
,	O
{	O
"quiet"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"silent"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"batch"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
't'	O
}	O
,	O
{	O
"set-time"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'T'	O
}	O
,	O
{	O
"unified"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'u'	O
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"version-control"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
"debug"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'x'	O
}	O
,	O
{	O
"basename-prefix"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'Y'	O
}	O
,	O
{	O
"suffix"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'z'	O
}	O
,	O
{	O
"set-utc"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'Z'	O
}	O
,	O
{	O
"dry-run"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
1	int
}	O
,	O
{	O
"verbose"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
2	int
}	O
,	O
{	O
"binary"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
3	int
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
4	int
}	O
,	O
{	O
"backup-if-mismatch"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
5	int
}	O
,	O
{	O
"no-backup-if-mismatch"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
6	int
}	O
,	O
{	O
"posix"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
7	int
}	O
,	O
{	O
"quoting-style"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
8	int
}	O
,	O
{	O
"reject-format"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
9	int
}	O
,	O
{	O
"read-only"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
10	int
}	O
,	O
{	O
NULL	O
,	O
no_argument	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
char	O
const	O
*	O
const	O
option_help	array(*(char))
[	O
]	O
=	O
{	O
"Input options:"	*(char)
,	O
""	*(char)
,	O
"  -p NUM  --strip=NUM  Strip NUM leading components from file names."	*(char)
,	O
"  -F LINES  --fuzz LINES  Set the fuzz factor to LINES for inexact matching."	*(char)
,	O
"  -l  --ignore-whitespace  Ignore white space changes between patch and input."	*(char)
,	O
""	*(char)
,	O
"  -c  --context  Interpret the patch as a context difference."	*(char)
,	O
"  -e  --ed  Interpret the patch as an ed script."	*(char)
,	O
"  -n  --normal  Interpret the patch as a normal difference."	*(char)
,	O
"  -u  --unified  Interpret the patch as a unified difference."	*(char)
,	O
""	*(char)
,	O
"  -N  --forward  Ignore patches that appear to be reversed or already applied."	*(char)
,	O
"  -R  --reverse  Assume patches were created with old and new files swapped."	*(char)
,	O
""	*(char)
,	O
"  -i PATCHFILE  --input=PATCHFILE  Read patch from PATCHFILE instead of stdin."	*(char)
,	O
""	*(char)
,	O
"Output options:"	*(char)
,	O
""	*(char)
,	O
"  -o FILE  --output=FILE  Output patched files to FILE."	*(char)
,	O
"  -r FILE  --reject-file=FILE  Output rejects to FILE."	*(char)
,	O
""	*(char)
,	O
"  -D NAME  --ifdef=NAME  Make merged if-then-else output using NAME."	*(char)
,	O
"  -m  --merge  Merge using conflict markers instead of creating reject files."	*(char)
,	O
"  -E  --remove-empty-files  Remove output files that are empty after patching."	*(char)
,	O
""	*(char)
,	O
"  -Z  --set-utc  Set times of patched files, assuming diff uses UTC (GMT)."	*(char)
,	O
"  -T  --set-time  Likewise, assuming local time."	*(char)
,	O
""	*(char)
,	O
"  --quoting-style=WORD   output file names using quoting style WORD."	*(char)
,	O
"    Valid WORDs are: literal, shell, shell-always, c, escape."	*(char)
,	O
"    Default is taken from QUOTING_STYLE env variable, or 'shell' if unset."	*(char)
,	O
""	*(char)
,	O
"Backup and version control options:"	*(char)
,	O
""	*(char)
,	O
"  -b  --backup  Back up the original contents of each file."	*(char)
,	O
"  --backup-if-mismatch  Back up if the patch does not match exactly."	*(char)
,	O
"  --no-backup-if-mismatch  Back up mismatches only if otherwise requested."	*(char)
,	O
""	*(char)
,	O
"  -V STYLE  --version-control=STYLE  Use STYLE version control."	*(char)
,	O
"	STYLE is either 'simple', 'numbered', or 'existing'."	*(char)
,	O
"  -B PREFIX  --prefix=PREFIX  Prepend PREFIX to backup file names."	*(char)
,	O
"  -Y PREFIX  --basename-prefix=PREFIX  Prepend PREFIX to backup file basenames."	*(char)
,	O
"  -z SUFFIX  --suffix=SUFFIX  Append SUFFIX to backup file names."	*(char)
,	O
""	*(char)
,	O
"  -g NUM  --get=NUM  Get files from RCS etc. if positive; ask if negative."	*(char)
,	O
""	*(char)
,	O
"Miscellaneous options:"	*(char)
,	O
""	*(char)
,	O
"  -t  --batch  Ask no questions; skip bad-Prereq patches; assume reversed."	*(char)
,	O
"  -f  --force  Like -t, but ignore bad-Prereq patches, and assume unreversed."	*(char)
,	O
"  -s  --quiet  --silent  Work silently unless an error occurs."	*(char)
,	O
"  --verbose  Output extra information about the work being done."	*(char)
,	O
"  --dry-run  Do not actually change any files; just print what would happen."	*(char)
,	O
"  --posix  Conform to the POSIX standard."	*(char)
,	O
""	*(char)
,	O
"  -d DIR  --directory=DIR  Change the working directory to DIR first."	*(char)
,	O
"  --reject-format=FORMAT  Create 'context' or 'unified' rejects."	*(char)
,	O
"  --binary  Read and write data in binary mode."	*(char)
,	O
"  --read-only=BEHAVIOR  How to handle read-only input files: 'ignore' that they"	*(char)
,	O
"                        are read-only, 'warn' (default), or 'fail'."	*(char)
,	O
""	*(char)
,	O
"  -v  --version  Output version info."	*(char)
,	O
"  --help  Output this help."	*(char)
,	O
""	*(char)
,	O
"Report bugs to <"	*(char)
PACKAGE_BUGREPORT	*(char)
">."	*(char)
,	O
0	int
}	O
;	O
static	O
void	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
status	int
)	O
{	O
char	O
const	O
*	O
const	O
*	O
p	*(void)
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: Try '%s --help' for more information.\n"	*(char)
,	O
program_name	*(char)
,	O
Argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Usage: %s [OPTION]... [ORIGFILE [PATCHFILE]]\n\n"	*(char)
,	O
Argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
for	O
(	O
p	*(void)
=	O
option_help	array(*(char))
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
*	O
p	*(void)
)	O
;	O
}	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
static	O
void	O
get_some_switches	()->(void)
(	O
void	O
)	O
{	O
int	O
optc	int
;	O
free	(*(void))->(void)
(	O
rejname	*(char)
)	O
;	O
rejname	*(char)
=	O
0	int
;	O
if	O
(	O
optind	int
==	O
Argc	int
)	O
return	O
;	O
while	O
(	O
(	O
optc	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
Argc	int
,	O
Argv	*(*(char))
,	O
shortopts	array(char)
,	O
longopts	array(struct(*(char),int,*(int),int))
,	O
(	O
int	O
*	O
)	O
0	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'b'	O
:	O
make_backups	bool
=	O
true	int
;	O
if	O
(	O
Argc	int
-	O
optind	int
==	O
3	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
Argv	*(*(char))
[	O
optind	int
-	O
1	int
]	O
,	O
"-b"	*(char)
)	O
==	O
0	int
&&	O
!	O
(	O
Argv	*(*(char))
[	O
optind	int
+	O
0	int
]	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
Argv	*(*(char))
[	O
optind	int
+	O
0	int
]	O
[	O
1	int
]	O
)	O
&&	O
!	O
(	O
Argv	*(*(char))
[	O
optind	int
+	O
1	int
]	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
Argv	*(*(char))
[	O
optind	int
+	O
1	int
]	O
[	O
1	int
]	O
)	O
&&	O
!	O
(	O
Argv	*(*(char))
[	O
optind	int
+	O
2	int
]	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
Argv	*(*(char))
[	O
optind	int
+	O
2	int
]	O
[	O
1	int
]	O
)	O
)	O
{	O
optarg	*(char)
=	O
Argv	*(*(char))
[	O
optind	int
++	O
]	O
;	O
if	O
(	O
verbosity	enum(int,int,int)
!=	O
SILENT	int
)	O
say	(*(char))->(void)
(	O
"warning: the '-b %s' option is obsolete; use '-b -z %s' instead\n"	*(char)
,	O
optarg	*(char)
,	O
optarg	*(char)
)	O
;	O
goto	O
case_z	O
;	O
}	O
break	O
;	O
case	O
'B'	O
:	O
if	O
(	O
!	O
*	O
optarg	*(char)
)	O
fatal	(*(char))->(void)
(	O
"backup prefix is empty"	*(char)
)	O
;	O
origprae	*(char)
=	O
savestr	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
diff_type	enum(int,int,int,int,int,int,int)
=	O
CONTEXT_DIFF	int
;	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
chdir	(*(char))->(int)
(	O
optarg	*(char)
)	O
<	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't change to directory %s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
do_defines	*(char)
=	O
savestr	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
diff_type	enum(int,int,int,int,int,int,int)
=	O
ED_DIFF	int
;	O
break	O
;	O
case	O
'E'	O
:	O
remove_empty_files	bool
=	O
true	int
;	O
break	O
;	O
case	O
'f'	O
:	O
force	bool
=	O
true	int
;	O
break	O
;	O
case	O
'F'	O
:	O
maxfuzz	long
=	O
numeric_string	(*(char),bool,*(char))->(int)
(	O
optarg	*(char)
,	O
false	int
,	O
"fuzz factor"	*(char)
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
patch_get	int
=	O
numeric_string	(*(char),bool,*(char))->(int)
(	O
optarg	*(char)
,	O
true	int
,	O
"get option value"	*(char)
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
patchname	*(char)
=	O
savestr	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
canonicalize	bool
=	O
true	int
;	O
break	O
;	O
case	O
'm'	O
:	O
merge	bool
=	O
true	int
;	O
if	O
(	O
optarg	*(char)
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"merge"	*(char)
)	O
)	O
conflict_style	enum(int,int)
=	O
MERGE_MERGE	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"diff3"	*(char)
)	O
)	O
conflict_style	enum(int,int)
=	O
MERGE_DIFF3	int
;	O
else	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
2	int
)	O
;	O
}	O
else	O
conflict_style	enum(int,int)
=	O
MERGE_MERGE	int
;	O
break	O
;	O
case	O
'n'	O
:	O
diff_type	enum(int,int,int,int,int,int,int)
=	O
NORMAL_DIFF	int
;	O
break	O
;	O
case	O
'N'	O
:	O
noreverse	bool
=	O
true	int
;	O
break	O
;	O
case	O
'o'	O
:	O
outfile	*(char)
=	O
savestr	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
strippath	int
=	O
numeric_string	(*(char),bool,*(char))->(int)
(	O
optarg	*(char)
,	O
false	int
,	O
"strip count"	*(char)
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
rejname	*(char)
=	O
savestr	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
reverse	bool
=	O
true	int
;	O
reverse_flag_specified	bool
=	O
true	int
;	O
break	O
;	O
case	O
's'	O
:	O
verbosity	enum(int,int,int)
=	O
SILENT	int
;	O
break	O
;	O
case	O
't'	O
:	O
batch	bool
=	O
true	int
;	O
break	O
;	O
case	O
'T'	O
:	O
set_time	bool
=	O
true	int
;	O
break	O
;	O
case	O
'u'	O
:	O
diff_type	enum(int,int,int,int,int,int,int)
=	O
UNI_DIFF	int
;	O
break	O
;	O
case	O
'v'	O
:	O
version	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'V'	O
:	O
version_control	*(char)
=	O
optarg	*(char)
;	O
version_control_context	*(char)
=	O
"--version-control or -V option"	*(char)
;	O
break	O
;	O
case	O
'x'	O
:	O
debug	int
=	O
numeric_string	(*(char),bool,*(char))->(int)
(	O
optarg	*(char)
,	O
true	int
,	O
"debugging option"	*(char)
)	O
;	O
break	O
;	O
case	O
'Y'	O
:	O
if	O
(	O
!	O
*	O
optarg	*(char)
)	O
fatal	(*(char))->(void)
(	O
"backup basename prefix is empty"	*(char)
)	O
;	O
origbase	*(char)
=	O
savestr	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'z'	O
:	O
case_z	O
:	O
if	O
(	O
!	O
*	O
optarg	*(char)
)	O
fatal	(*(char))->(void)
(	O
"backup suffix is empty"	*(char)
)	O
;	O
origsuff	*(char)
=	O
savestr	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'Z'	O
:	O
set_utc	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
1	int
:	O
dry_run	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
2	int
:	O
verbosity	enum(int,int,int)
=	O
VERBOSE	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
3	int
:	O
no_strip_trailing_cr	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
4	int
:	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
0	int
)	O
;	O
case	O
CHAR_MAX	O
+	O
5	int
:	O
backup_if_mismatch	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
6	int
:	O
backup_if_mismatch	bool
=	O
false	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
7	int
:	O
posixly_correct	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
8	int
:	O
{	O
int	O
i	int
=	O
argmatch	(*(char),*(*(char)),*(char),long)->(long)
(	O
optarg	*(char)
,	O
quoting_style_args	array(*(char))
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
invalid_arg	O
(	O
"quoting style"	*(char)
,	O
optarg	*(char)
,	O
i	int
)	O
;	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
2	int
)	O
;	O
}	O
set_quoting_style	(*(struct),enum(int,int,int,int,int,int,int,int,int))->(void)
(	O
(	O
struct	O
quoting_options	O
*	O
)	O
0	int
,	O
(	O
enum	O
quoting_style	enum(int,int,int,int,int,int,int,int,int)
)	O
i	int
)	O
;	O
}	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
9	int
:	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"context"	*(char)
)	O
==	O
0	int
)	O
reject_format	enum(int,int,int,int,int,int,int)
=	O
NEW_CONTEXT_DIFF	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"unified"	*(char)
)	O
==	O
0	int
)	O
reject_format	enum(int,int,int,int,int,int,int)
=	O
UNI_DIFF	int
;	O
else	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
2	int
)	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
10	int
:	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"ignore"	*(char)
)	O
==	O
0	int
)	O
read_only_behavior	enum(int,int,int)
=	O
RO_IGNORE	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"warn"	*(char)
)	O
==	O
0	int
)	O
read_only_behavior	enum(int,int,int)
=	O
RO_WARN	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"fail"	*(char)
)	O
==	O
0	int
)	O
read_only_behavior	enum(int,int,int)
=	O
RO_FAIL	int
;	O
else	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
2	int
)	O
;	O
break	O
;	O
default	O
:	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
2	int
)	O
;	O
}	O
}	O
if	O
(	O
optind	int
<	O
Argc	int
)	O
{	O
inname	*(char)
=	O
savestr	(*(char))->(*(char))
(	O
Argv	*(*(char))
[	O
optind	int
++	O
]	O
)	O
;	O
explicit_inname	bool
=	O
true	int
;	O
invc	int
=	O
-	O
1	int
;	O
if	O
(	O
optind	int
<	O
Argc	int
)	O
{	O
patchname	*(char)
=	O
savestr	(*(char))->(*(char))
(	O
Argv	*(*(char))
[	O
optind	int
++	O
]	O
)	O
;	O
if	O
(	O
optind	int
<	O
Argc	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s: extra operand\n"	*(char)
,	O
program_name	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
Argv	*(*(char))
[	O
optind	int
]	O
)	O
)	O
;	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
2	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
int	O
numeric_string	(*(char),bool,*(char))->(int)
(	O
char	O
const	O
*	O
string	*(char)
,	O
bool	bool
negative_allowed	bool
,	O
char	O
const	O
*	O
argtype_msgid	*(char)
)	O
{	O
int	O
value	*(char)
=	O
0	int
;	O
char	O
const	O
*	O
p	*(void)
=	O
string	*(char)
;	O
int	O
sign	int
=	O
*	O
p	*(void)
==	O
'-'	O
?	O
-	O
1	int
:	O
1	int
;	O
p	*(void)
+=	O
*	O
p	*(void)
==	O
'-'	O
||	O
*	O
p	*(void)
==	O
'+'	O
;	O
do	O
{	O
int	O
v10	int
=	O
value	*(char)
*	O
10	int
;	O
int	O
digit	int
=	O
*	O
p	*(void)
-	O
'0'	O
;	O
int	O
signed_digit	int
=	O
sign	int
*	O
digit	int
;	O
int	O
next_value	int
=	O
v10	int
+	O
signed_digit	int
;	O
if	O
(	O
9	int
<	O
(	O
unsigned	O
)	O
digit	int
)	O
fatal	(*(char))->(void)
(	O
"%s %s is not a number"	*(char)
,	O
argtype_msgid	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
string	*(char)
)	O
)	O
;	O
if	O
(	O
v10	int
/	O
10	int
!=	O
value	*(char)
||	O
(	O
next_value	int
<	O
v10	int
)	O
!=	O
(	O
signed_digit	int
<	O
0	int
)	O
)	O
fatal	(*(char))->(void)
(	O
"%s %s is too large"	*(char)
,	O
argtype_msgid	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
string	*(char)
)	O
)	O
;	O
value	*(char)
=	O
next_value	int
;	O
}	O
while	O
(	O
*	O
++	O
p	*(void)
)	O
;	O
if	O
(	O
value	*(char)
<	O
0	int
&&	O
!	O
negative_allowed	bool
)	O
fatal	(*(char))->(void)
(	O
"%s %s is negative"	*(char)
,	O
argtype_msgid	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
string	*(char)
)	O
)	O
;	O
return	O
value	*(char)
;	O
}	O
static	O
lin	long
locate_hunk	(long)->(long)
(	O
lin	long
fuzz	long
)	O
{	O
lin	long
first_guess	long
=	O
pch_first	()->(long)
(	O
)	O
+	O
in_offset	long
;	O
lin	long
offset	long
;	O
lin	long
pat_lines	long
=	O
pch_ptrn_lines	()->(long)
(	O
)	O
;	O
lin	long
prefix_context	long
=	O
pch_prefix_context	()->(long)
(	O
)	O
;	O
lin	long
suffix_context	long
=	O
pch_suffix_context	()->(long)
(	O
)	O
;	O
lin	long
context	*(char)
=	O
(	O
prefix_context	long
<	O
suffix_context	long
?	O
suffix_context	long
:	O
prefix_context	long
)	O
;	O
lin	long
prefix_fuzz	long
=	O
fuzz	long
+	O
prefix_context	long
-	O
context	*(char)
;	O
lin	long
suffix_fuzz	long
=	O
fuzz	long
+	O
suffix_context	long
-	O
context	*(char)
;	O
lin	long
max_where	long
=	O
input_lines	long
-	O
(	O
pat_lines	long
-	O
suffix_fuzz	long
)	O
+	O
1	int
;	O
lin	long
min_where	long
=	O
last_frozen_line	long
+	O
1	int
-	O
(	O
prefix_context	long
-	O
prefix_fuzz	long
)	O
;	O
lin	long
max_pos_offset	long
=	O
max_where	long
-	O
first_guess	long
;	O
lin	long
max_neg_offset	long
=	O
first_guess	long
-	O
min_where	long
;	O
lin	long
max_offset	long
=	O
(	O
max_pos_offset	long
<	O
max_neg_offset	long
?	O
max_neg_offset	long
:	O
max_pos_offset	long
)	O
;	O
if	O
(	O
!	O
pat_lines	long
)	O
return	O
first_guess	long
;	O
if	O
(	O
first_guess	long
<=	O
max_neg_offset	long
)	O
max_neg_offset	long
=	O
first_guess	long
-	O
1	int
;	O
if	O
(	O
prefix_fuzz	long
<	O
0	int
&&	O
pch_first	()->(long)
(	O
)	O
<=	O
1	int
)	O
{	O
if	O
(	O
suffix_fuzz	long
<	O
0	int
)	O
if	O
(	O
pat_lines	long
!=	O
input_lines	long
||	O
prefix_context	long
<	O
last_frozen_line	long
)	O
return	O
0	int
;	O
offset	long
=	O
1	int
-	O
first_guess	long
;	O
if	O
(	O
last_frozen_line	long
<=	O
prefix_context	long
&&	O
offset	long
<=	O
max_pos_offset	long
&&	O
patch_match	(long,long,long,long)->(bool)
(	O
first_guess	long
,	O
offset	long
,	O
0	int
,	O
suffix_fuzz	long
)	O
)	O
{	O
in_offset	long
+=	O
offset	long
;	O
return	O
first_guess	long
+	O
offset	long
;	O
}	O
else	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
prefix_fuzz	long
<	O
0	int
)	O
prefix_fuzz	long
=	O
0	int
;	O
if	O
(	O
suffix_fuzz	long
<	O
0	int
)	O
{	O
offset	long
=	O
first_guess	long
-	O
(	O
input_lines	long
-	O
pat_lines	long
+	O
1	int
)	O
;	O
if	O
(	O
offset	long
<=	O
max_neg_offset	long
&&	O
patch_match	(long,long,long,long)->(bool)
(	O
first_guess	long
,	O
-	O
offset	long
,	O
prefix_fuzz	long
,	O
0	int
)	O
)	O
{	O
in_offset	long
-=	O
offset	long
;	O
return	O
first_guess	long
-	O
offset	long
;	O
}	O
else	O
return	O
0	int
;	O
}	O
for	O
(	O
offset	long
=	O
0	int
;	O
offset	long
<=	O
max_offset	long
;	O
offset	long
++	O
)	O
{	O
char	O
numbuf0	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf1	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
if	O
(	O
offset	long
<=	O
max_pos_offset	long
&&	O
patch_match	(long,long,long,long)->(bool)
(	O
first_guess	long
,	O
offset	long
,	O
prefix_fuzz	long
,	O
suffix_fuzz	long
)	O
)	O
{	O
if	O
(	O
debug	int
&	O
1	int
)	O
say	(*(char))->(void)
(	O
"Offset changing from %s to %s\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
in_offset	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
in_offset	long
+	O
offset	long
)	O
)	O
;	O
in_offset	long
+=	O
offset	long
;	O
return	O
first_guess	long
+	O
offset	long
;	O
}	O
if	O
(	O
0	int
<	O
offset	long
&&	O
offset	long
<=	O
max_neg_offset	long
&&	O
patch_match	(long,long,long,long)->(bool)
(	O
first_guess	long
,	O
-	O
offset	long
,	O
prefix_fuzz	long
,	O
suffix_fuzz	long
)	O
)	O
{	O
if	O
(	O
debug	int
&	O
1	int
)	O
say	(*(char))->(void)
(	O
"Offset changing from %s to %s\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
in_offset	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
in_offset	long
-	O
offset	long
)	O
)	O
;	O
in_offset	long
-=	O
offset	long
;	O
return	O
first_guess	long
-	O
offset	long
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
mangled_patch	(long,long)->(void)
(	O
lin	long
old	long
,	O
lin	long
new	long
)	O
{	O
char	O
numbuf0	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf1	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
if	O
(	O
debug	int
&	O
1	int
)	O
say	(*(char))->(void)
(	O
"oldchar = '%c', newchar = '%c'\n"	*(char)
,	O
pch_char	(long)->(char)
(	O
old	long
)	O
,	O
pch_char	(long)->(char)
(	O
new	long
)	O
)	O
;	O
fatal	(*(char))->(void)
(	O
"Out-of-sync patch, lines %s,%s -- mangled text or line numbers, "	*(char)
"maybe?"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
pch_hunk_beg	()->(long)
(	O
)	O
+	O
old	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
pch_hunk_beg	()->(long)
(	O
)	O
+	O
new	long
)	O
)	O
;	O
}	O
static	O
void	O
print_unidiff_range	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,long)->(void)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
lin	long
start	long
,	O
lin	long
count	long
)	O
{	O
char	O
numbuf0	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf1	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
switch	O
(	O
count	long
)	O
{	O
case	O
0	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s,0"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
start	long
-	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
start	long
)	O
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s,%s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
start	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
count	long
)	O
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
print_header_line	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),bool)->(void)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
const	O
char	O
*	O
tag	*(char)
,	O
bool	bool
reverse	bool
)	O
{	O
const	O
char	O
*	O
name	*(char)
=	O
pch_name	(enum(int,int,int,int))->(*(char))
(	O
reverse	bool
)	O
;	O
const	O
char	O
*	O
timestr	*(char)
=	O
pch_timestr	(bool)->(*(char))
(	O
reverse	bool
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s %s%s\n"	*(char)
,	O
tag	*(char)
,	O
name	*(char)
?	O
name	*(char)
:	O
"/dev/null"	*(char)
,	O
timestr	*(char)
?	O
timestr	*(char)
:	O
""	*(char)
)	O
;	O
}	O
static	O
void	O
abort_hunk_unified	(bool,bool)->(void)
(	O
bool	bool
header	bool
,	O
bool	bool
reverse	bool
)	O
{	O
lin	long
old	long
=	O
1	int
;	O
lin	long
lastline	long
=	O
pch_ptrn_lines	()->(long)
(	O
)	O
;	O
lin	long
new	long
=	O
lastline	long
+	O
1	int
;	O
if	O
(	O
header	bool
)	O
{	O
if	O
(	O
pch_name	(enum(int,int,int,int))->(*(char))
(	O
INDEX	int
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Index: %s\n"	*(char)
,	O
pch_name	(enum(int,int,int,int))->(*(char))
(	O
INDEX	int
)	O
)	O
;	O
print_header_line	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),bool)->(void)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"---"	*(char)
,	O
reverse	bool
)	O
;	O
print_header_line	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),bool)->(void)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"+++"	*(char)
,	O
!	O
reverse	bool
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"@@ -"	*(char)
)	O
;	O
print_unidiff_range	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,long)->(void)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
pch_first	()->(long)
(	O
)	O
+	O
out_offset	long
,	O
lastline	long
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" +"	*(char)
)	O
;	O
print_unidiff_range	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,long)->(void)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
pch_newfirst	()->(long)
(	O
)	O
+	O
out_offset	long
,	O
pch_repl_lines	()->(long)
(	O
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" @@\n"	*(char)
)	O
;	O
while	O
(	O
pch_char	(long)->(char)
(	O
new	long
)	O
==	O
'='	O
||	O
pch_char	(long)->(char)
(	O
new	long
)	O
==	O
'\n'	O
)	O
new	long
++	O
;	O
if	O
(	O
diff_type	enum(int,int,int,int,int,int,int)
!=	O
UNI_DIFF	int
)	O
pch_normalize	(enum(int,int,int,int,int,int,int))->(void)
(	O
UNI_DIFF	int
)	O
;	O
for	O
(	O
;	O
;	O
old	long
++	O
,	O
new	long
++	O
)	O
{	O
for	O
(	O
;	O
pch_char	(long)->(char)
(	O
old	long
)	O
==	O
'-'	O
;	O
old	long
++	O
)	O
{	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'-'	O
,	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
pch_write_line	(long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(bool)
(	O
old	long
,	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
for	O
(	O
;	O
pch_char	(long)->(char)
(	O
new	long
)	O
==	O
'+'	O
;	O
new	long
++	O
)	O
{	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'+'	O
,	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
pch_write_line	(long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(bool)
(	O
new	long
,	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
old	long
>	O
lastline	long
)	O
break	O
;	O
if	O
(	O
pch_char	(long)->(char)
(	O
new	long
)	O
!=	O
pch_char	(long)->(char)
(	O
old	long
)	O
)	O
mangled_patch	(long,long)->(void)
(	O
old	long
,	O
new	long
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
pch_write_line	(long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(bool)
(	O
old	long
,	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
pch_char	(long)->(char)
(	O
new	long
)	O
!=	O
'^'	O
)	O
mangled_patch	(long,long)->(void)
(	O
old	long
,	O
new	long
)	O
;	O
}	O
static	O
void	O
abort_hunk_context	(bool,bool)->(void)
(	O
bool	bool
header	bool
,	O
bool	bool
reverse	bool
)	O
{	O
lin	long
i	int
;	O
lin	long
pat_end	long
=	O
pch_end	()->(long)
(	O
)	O
;	O
lin	long
oldfirst	long
=	O
pch_first	()->(long)
(	O
)	O
+	O
out_offset	long
;	O
lin	long
newfirst	long
=	O
pch_newfirst	()->(long)
(	O
)	O
+	O
out_offset	long
;	O
lin	long
oldlast	long
=	O
oldfirst	long
+	O
pch_ptrn_lines	()->(long)
(	O
)	O
-	O
1	int
;	O
lin	long
newlast	long
=	O
newfirst	long
+	O
pch_repl_lines	()->(long)
(	O
)	O
-	O
1	int
;	O
char	O
const	O
*	O
stars	*(char)
=	O
(	O
int	O
)	O
NEW_CONTEXT_DIFF	int
<=	O
(	O
int	O
)	O
diff_type	enum(int,int,int,int,int,int,int)
?	O
" ****"	*(char)
:	O
""	*(char)
;	O
char	O
const	O
*	O
minuses	*(char)
=	O
(	O
int	O
)	O
NEW_CONTEXT_DIFF	int
<=	O
(	O
int	O
)	O
diff_type	enum(int,int,int,int,int,int,int)
?	O
" ----"	*(char)
:	O
" -----"	*(char)
;	O
char	O
const	O
*	O
c_function	*(char)
=	O
pch_c_function	()->(*(char))
(	O
)	O
;	O
if	O
(	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
UNI_DIFF	int
)	O
pch_normalize	(enum(int,int,int,int,int,int,int))->(void)
(	O
NEW_CONTEXT_DIFF	int
)	O
;	O
if	O
(	O
header	bool
)	O
{	O
if	O
(	O
pch_name	(enum(int,int,int,int))->(*(char))
(	O
INDEX	int
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Index: %s\n"	*(char)
,	O
pch_name	(enum(int,int,int,int))->(*(char))
(	O
INDEX	int
)	O
)	O
;	O
print_header_line	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),bool)->(void)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"***"	*(char)
,	O
reverse	bool
)	O
;	O
print_header_line	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),bool)->(void)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"---"	*(char)
,	O
!	O
reverse	bool
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"***************%s\n"	*(char)
,	O
c_function	*(char)
?	O
c_function	*(char)
:	O
""	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
pat_end	long
;	O
i	int
++	O
)	O
{	O
char	O
numbuf0	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf1	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
switch	O
(	O
pch_char	(long)->(char)
(	O
i	int
)	O
)	O
{	O
case	O
'*'	O
:	O
if	O
(	O
oldlast	long
<	O
oldfirst	long
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"*** 0%s\n"	*(char)
,	O
stars	*(char)
)	O
;	O
else	O
if	O
(	O
oldlast	long
==	O
oldfirst	long
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"*** %s%s\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
oldfirst	long
)	O
,	O
stars	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"*** %s,%s%s\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
oldfirst	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
oldlast	long
)	O
,	O
stars	*(char)
)	O
;	O
break	O
;	O
case	O
'='	O
:	O
if	O
(	O
newlast	long
<	O
newfirst	long
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"--- 0%s\n"	*(char)
,	O
minuses	*(char)
)	O
;	O
else	O
if	O
(	O
newlast	long
==	O
newfirst	long
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"--- %s%s\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
newfirst	long
)	O
,	O
minuses	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"--- %s,%s%s\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
newfirst	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
newlast	long
)	O
,	O
minuses	*(char)
)	O
;	O
break	O
;	O
case	O
' '	O
:	O
case	O
'-'	O
:	O
case	O
'+'	O
:	O
case	O
'!'	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%c "	*(char)
,	O
pch_char	(long)->(char)
(	O
i	int
)	O
)	O
;	O
case	O
'\n'	O
:	O
pch_write_line	(long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(bool)
(	O
i	int
,	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
default	O
:	O
fatal	(*(char))->(void)
(	O
"fatal internal error in abort_hunk_context"	*(char)
)	O
;	O
}	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
write_fatal	()->(void)
(	O
)	O
;	O
}	O
}	O
static	O
void	O
abort_hunk	(*(char),bool,bool)->(void)
(	O
char	O
const	O
*	O
outname	*(char)
,	O
bool	bool
header	bool
,	O
bool	bool
reverse	bool
)	O
{	O
if	O
(	O
!	O
TMPREJNAME_needs_removal	int
)	O
init_reject	(*(char))->(void)
(	O
outname	*(char)
)	O
;	O
if	O
(	O
reject_format	enum(int,int,int,int,int,int,int)
==	O
UNI_DIFF	int
||	O
(	O
reject_format	enum(int,int,int,int,int,int,int)
==	O
NO_DIFF	int
&&	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
UNI_DIFF	int
)	O
)	O
abort_hunk_unified	(bool,bool)->(void)
(	O
header	bool
,	O
reverse	bool
)	O
;	O
else	O
abort_hunk_context	(bool,bool)->(void)
(	O
header	bool
,	O
reverse	bool
)	O
;	O
}	O
static	O
bool	bool
apply_hunk	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)),long)->(bool)
(	O
struct	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
*	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
,	O
lin	long
where	long
)	O
{	O
lin	long
old	long
=	O
1	int
;	O
lin	long
lastline	long
=	O
pch_ptrn_lines	()->(long)
(	O
)	O
;	O
lin	long
new	long
=	O
lastline	long
+	O
1	int
;	O
enum	O
{	O
OUTSIDE	int
,	O
IN_IFNDEF	int
,	O
IN_IFDEF	int
,	O
IN_ELSE	int
}	O
def_state	enum(int,int,int,int)
=	O
OUTSIDE	int
;	O
char	O
const	O
*	O
R_do_defines	*(char)
=	O
do_defines	*(char)
;	O
lin	long
pat_end	long
=	O
pch_end	()->(long)
(	O
)	O
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
where	long
--	O
;	O
while	O
(	O
pch_char	(long)->(char)
(	O
new	long
)	O
==	O
'='	O
||	O
pch_char	(long)->(char)
(	O
new	long
)	O
==	O
'\n'	O
)	O
new	long
++	O
;	O
while	O
(	O
old	long
<=	O
lastline	long
)	O
{	O
if	O
(	O
pch_char	(long)->(char)
(	O
old	long
)	O
==	O
'-'	O
)	O
{	O
assert	O
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
)	O
;	O
if	O
(	O
!	O
copy_till	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)),long)->(bool)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
,	O
where	long
+	O
old	long
-	O
1	int
)	O
)	O
return	O
false	int
;	O
if	O
(	O
R_do_defines	*(char)
)	O
{	O
if	O
(	O
def_state	enum(int,int,int,int)
==	O
OUTSIDE	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
+	O
not_defined	array(char)
,	O
R_do_defines	*(char)
)	O
;	O
def_state	enum(int,int,int,int)
=	O
IN_IFNDEF	int
;	O
}	O
else	O
if	O
(	O
def_state	enum(int,int,int,int)
==	O
IN_IFDEF	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
+	O
else_defined	array(char)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
def_state	enum(int,int,int,int)
=	O
IN_ELSE	int
;	O
}	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
write_fatal	()->(void)
(	O
)	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
=	O
pch_write_line	(long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(bool)
(	O
old	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
zero_output	bool
=	O
false	int
;	O
}	O
last_frozen_line	long
++	O
;	O
old	long
++	O
;	O
}	O
else	O
if	O
(	O
new	long
>	O
pat_end	long
)	O
{	O
break	O
;	O
}	O
else	O
if	O
(	O
pch_char	(long)->(char)
(	O
new	long
)	O
==	O
'+'	O
)	O
{	O
if	O
(	O
!	O
copy_till	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)),long)->(bool)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
,	O
where	long
+	O
old	long
-	O
1	int
)	O
)	O
return	O
false	int
;	O
if	O
(	O
R_do_defines	*(char)
)	O
{	O
if	O
(	O
def_state	enum(int,int,int,int)
==	O
IN_IFNDEF	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
+	O
else_defined	array(char)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
def_state	enum(int,int,int,int)
=	O
IN_ELSE	int
;	O
}	O
else	O
if	O
(	O
def_state	enum(int,int,int,int)
==	O
OUTSIDE	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
+	O
if_defined	array(char)
,	O
R_do_defines	*(char)
)	O
;	O
def_state	enum(int,int,int,int)
=	O
IN_IFDEF	int
;	O
}	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
write_fatal	()->(void)
(	O
)	O
;	O
}	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
=	O
pch_write_line	(long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(bool)
(	O
new	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
zero_output	bool
=	O
false	int
;	O
new	long
++	O
;	O
}	O
else	O
if	O
(	O
pch_char	(long)->(char)
(	O
new	long
)	O
!=	O
pch_char	(long)->(char)
(	O
old	long
)	O
)	O
mangled_patch	(long,long)->(void)
(	O
old	long
,	O
new	long
)	O
;	O
else	O
if	O
(	O
pch_char	(long)->(char)
(	O
new	long
)	O
==	O
'!'	O
)	O
{	O
assert	O
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
)	O
;	O
if	O
(	O
!	O
copy_till	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)),long)->(bool)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
,	O
where	long
+	O
old	long
-	O
1	int
)	O
)	O
return	O
false	int
;	O
assert	O
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
)	O
;	O
if	O
(	O
R_do_defines	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
1	int
+	O
not_defined	array(char)
,	O
R_do_defines	*(char)
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
write_fatal	()->(void)
(	O
)	O
;	O
def_state	enum(int,int,int,int)
=	O
IN_IFNDEF	int
;	O
}	O
do	O
{	O
if	O
(	O
R_do_defines	*(char)
)	O
{	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
=	O
pch_write_line	(long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(bool)
(	O
old	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
last_frozen_line	long
++	O
;	O
old	long
++	O
;	O
}	O
while	O
(	O
pch_char	(long)->(char)
(	O
old	long
)	O
==	O
'!'	O
)	O
;	O
if	O
(	O
R_do_defines	*(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
+	O
else_defined	array(char)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
write_fatal	()->(void)
(	O
)	O
;	O
def_state	enum(int,int,int,int)
=	O
IN_ELSE	int
;	O
}	O
do	O
{	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
=	O
pch_write_line	(long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(bool)
(	O
new	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
new	long
++	O
;	O
}	O
while	O
(	O
pch_char	(long)->(char)
(	O
new	long
)	O
==	O
'!'	O
)	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
zero_output	bool
=	O
false	int
;	O
}	O
else	O
{	O
assert	O
(	O
pch_char	(long)->(char)
(	O
new	long
)	O
==	O
' '	O
)	O
;	O
old	long
++	O
;	O
new	long
++	O
;	O
if	O
(	O
R_do_defines	*(char)
&&	O
def_state	enum(int,int,int,int)
!=	O
OUTSIDE	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
+	O
end_defined	array(char)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
write_fatal	()->(void)
(	O
)	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
=	O
true	int
;	O
def_state	enum(int,int,int,int)
=	O
OUTSIDE	int
;	O
}	O
}	O
}	O
if	O
(	O
new	long
<=	O
pat_end	long
&&	O
pch_char	(long)->(char)
(	O
new	long
)	O
==	O
'+'	O
)	O
{	O
if	O
(	O
!	O
copy_till	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)),long)->(bool)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
,	O
where	long
+	O
old	long
-	O
1	int
)	O
)	O
return	O
false	int
;	O
if	O
(	O
R_do_defines	*(char)
)	O
{	O
if	O
(	O
def_state	enum(int,int,int,int)
==	O
OUTSIDE	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
+	O
if_defined	array(char)
,	O
R_do_defines	*(char)
)	O
;	O
def_state	enum(int,int,int,int)
=	O
IN_IFDEF	int
;	O
}	O
else	O
if	O
(	O
def_state	enum(int,int,int,int)
==	O
IN_IFNDEF	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
+	O
else_defined	array(char)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
def_state	enum(int,int,int,int)
=	O
IN_ELSE	int
;	O
}	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
write_fatal	()->(void)
(	O
)	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
zero_output	bool
=	O
false	int
;	O
}	O
do	O
{	O
if	O
(	O
!	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
&&	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
write_fatal	()->(void)
(	O
)	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
=	O
pch_write_line	(long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(bool)
(	O
new	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
zero_output	bool
=	O
false	int
;	O
new	long
++	O
;	O
}	O
while	O
(	O
new	long
<=	O
pat_end	long
&&	O
pch_char	(long)->(char)
(	O
new	long
)	O
==	O
'+'	O
)	O
;	O
}	O
if	O
(	O
R_do_defines	*(char)
&&	O
def_state	enum(int,int,int,int)
!=	O
OUTSIDE	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
+	O
end_defined	array(char)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
write_fatal	()->(void)
(	O
)	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
=	O
true	int
;	O
}	O
out_offset	long
+=	O
pch_repl_lines	()->(long)
(	O
)	O
-	O
pch_ptrn_lines	()->(long)
(	O
)	O
;	O
return	O
true	int
;	O
}	O
static	O
FILE	struct
*	O
create_output_file	(*(char),int)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
char	O
const	O
*	O
name	*(char)
,	O
int	O
open_flags	int
)	O
{	O
int	O
fd	int
=	O
create_file	(*(char),int,int,bool)->(int)
(	O
name	*(char)
,	O
O_WRONLY	int
|	O
binary_transput	int
|	O
open_flags	int
,	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
,	O
true	int
)	O
;	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fd	int
,	O
binary_transput	int
?	O
"wb"	*(char)
:	O
"w"	*(char)
)	O
;	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
pfatal	(*(char))->(void)
(	O
"Can't create file %s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
name	*(char)
)	O
)	O
;	O
return	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
static	O
void	O
init_output	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)))->(void)
(	O
struct	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
*	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
)	O
{	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
=	O
true	int
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
zero_output	bool
=	O
true	int
;	O
}	O
static	O
FILE	struct
*	O
open_outfile	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
char	O
const	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"-"	*(char)
)	O
!=	O
0	int
)	O
return	O
create_output_file	(*(char),int)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
name	*(char)
,	O
0	int
)	O
;	O
else	O
{	O
FILE	struct
*	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
stdout_dup	int
=	O
dup	(int)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
;	O
if	O
(	O
stdout_dup	int
==	O
-	O
1	int
)	O
pfatal	(*(char))->(void)
(	O
"Failed to duplicate standard output"	*(char)
)	O
;	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
stdout_dup	int
,	O
"a"	*(char)
)	O
;	O
if	O
(	O
!	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
pfatal	(*(char))->(void)
(	O
"Failed to duplicate standard output"	*(char)
)	O
;	O
if	O
(	O
dup2	(int,int)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
==	O
-	O
1	int
)	O
pfatal	(*(char))->(void)
(	O
"Failed to redirect messages to standard error"	*(char)
)	O
;	O
return	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
}	O
static	O
void	O
init_reject	(*(char))->(void)
(	O
char	O
const	O
*	O
outname	*(char)
)	O
{	O
int	O
fd	int
;	O
fd	int
=	O
make_tempfile	(*(*(char)),char,*(char),int,int)->(int)
(	O
&	O
TMPREJNAME	*(char)
,	O
'r'	O
,	O
outname	*(char)
,	O
O_WRONLY	int
|	O
binary_transput	int
,	O
0666	int
)	O
;	O
TMPREJNAME_needs_removal	int
=	O
1	int
;	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fd	int
,	O
binary_transput	int
?	O
"wb"	*(char)
:	O
"w"	*(char)
)	O
;	O
if	O
(	O
!	O
rejfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
pfatal	(*(char))->(void)
(	O
"Can't open stream for file %s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
TMPREJNAME	*(char)
)	O
)	O
;	O
}	O
bool	bool
copy_till	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)),long)->(bool)
(	O
struct	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
*	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
,	O
lin	long
lastline	long
)	O
{	O
lin	long
R_last_frozen_line	long
=	O
last_frozen_line	long
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
const	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
size_t	long
size	*(long)
;	O
if	O
(	O
R_last_frozen_line	long
>	O
lastline	long
)	O
{	O
say	(*(char))->(void)
(	O
"misordered hunks! output would be garbled\n"	*(char)
)	O
;	O
return	O
false	int
;	O
}	O
while	O
(	O
R_last_frozen_line	long
<	O
lastline	long
)	O
{	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
ifetch	(long,bool,*(long))->(*(char))
(	O
++	O
R_last_frozen_line	long
,	O
false	int
,	O
&	O
size	*(long)
)	O
;	O
if	O
(	O
size	*(long)
)	O
{	O
if	O
(	O
(	O
!	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
&&	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
||	O
!	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
sizeof	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
size	*(long)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
write_fatal	()->(void)
(	O
)	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
after_newline	bool
=	O
s	enum(int,int,int,int,int,int,int,int,int)
[	O
size	*(long)
-	O
1	int
]	O
==	O
'\n'	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
zero_output	bool
=	O
false	int
;	O
}	O
}	O
last_frozen_line	long
=	O
R_last_frozen_line	long
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
spew_output	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(bool)
(	O
struct	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
*	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
if	O
(	O
debug	int
&	O
256	int
)	O
{	O
char	O
numbuf0	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf1	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
say	(*(char))->(void)
(	O
"il=%s lfl=%s\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
input_lines	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
last_frozen_line	long
)	O
)	O
;	O
}	O
if	O
(	O
last_frozen_line	long
<	O
input_lines	long
)	O
if	O
(	O
!	O
copy_till	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),bool,bool)),long)->(bool)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
,	O
input_lines	long
)	O
)	O
return	O
false	int
;	O
if	O
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
&&	O
!	O
outfile	*(char)
)	O
{	O
if	O
(	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
||	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
!=	O
0	int
||	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
write_fatal	()->(void)
(	O
)	O
;	O
outstate	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,bool)
->	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
0	int
;	O
}	O
return	O
true	int
;	O
}	O
static	O
bool	bool
patch_match	(long,long,long,long)->(bool)
(	O
lin	long
base	int
,	O
lin	long
offset	long
,	O
lin	long
prefix_fuzz	long
,	O
lin	long
suffix_fuzz	long
)	O
{	O
lin	long
pline	long
=	O
1	int
+	O
prefix_fuzz	long
;	O
lin	long
iline	long
;	O
lin	long
pat_lines	long
=	O
pch_ptrn_lines	()->(long)
(	O
)	O
-	O
suffix_fuzz	long
;	O
size_t	long
size	*(long)
;	O
char	O
const	O
*	O
p	*(void)
;	O
for	O
(	O
iline	long
=	O
base	int
+	O
offset	long
+	O
prefix_fuzz	long
;	O
pline	long
<=	O
pat_lines	long
;	O
pline	long
++	O
,	O
iline	long
++	O
)	O
{	O
p	*(void)
=	O
ifetch	(long,bool,*(long))->(*(char))
(	O
iline	long
,	O
offset	long
>=	O
0	int
,	O
&	O
size	*(long)
)	O
;	O
if	O
(	O
canonicalize	bool
)	O
{	O
if	O
(	O
!	O
similar	(*(char),long,*(char),long)->(bool)
(	O
p	*(void)
,	O
size	*(long)
,	O
pfetch	(long)->(*(char))
(	O
pline	long
)	O
,	O
pch_line_len	(long)->(long)
(	O
pline	long
)	O
)	O
)	O
return	O
false	int
;	O
}	O
else	O
if	O
(	O
size	*(long)
!=	O
pch_line_len	(long)->(long)
(	O
pline	long
)	O
||	O
memcmp	(*(void),*(void),long)->(int)
(	O
p	*(void)
,	O
pfetch	(long)->(*(char))
(	O
pline	long
)	O
,	O
size	*(long)
)	O
!=	O
0	int
)	O
return	O
false	int
;	O
}	O
return	O
true	int
;	O
}	O
bool	bool
similar	(*(char),long,*(char),long)->(bool)
(	O
char	O
const	O
*	O
a	struct(long,long)
,	O
size_t	long
alen	long
,	O
char	O
const	O
*	O
b	struct(long,long)
,	O
size_t	long
blen	long
)	O
{	O
alen	long
-=	O
alen	long
&&	O
a	struct(long,long)
[	O
alen	long
-	O
1	int
]	O
==	O
'\n'	O
;	O
blen	long
-=	O
blen	long
&&	O
b	struct(long,long)
[	O
blen	long
-	O
1	int
]	O
==	O
'\n'	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
!	O
blen	long
||	O
(	O
*	O
b	struct(long,long)
==	O
' '	O
||	O
*	O
b	struct(long,long)
==	O
'\t'	O
)	O
)	O
{	O
while	O
(	O
blen	long
&&	O
(	O
*	O
b	struct(long,long)
==	O
' '	O
||	O
*	O
b	struct(long,long)
==	O
'\t'	O
)	O
)	O
b	struct(long,long)
++	O
,	O
blen	long
--	O
;	O
if	O
(	O
alen	long
)	O
{	O
if	O
(	O
!	O
(	O
*	O
a	struct(long,long)
==	O
' '	O
||	O
*	O
a	struct(long,long)
==	O
'\t'	O
)	O
)	O
return	O
false	int
;	O
do	O
a	struct(long,long)
++	O
,	O
alen	long
--	O
;	O
while	O
(	O
alen	long
&&	O
(	O
*	O
a	struct(long,long)
==	O
' '	O
||	O
*	O
a	struct(long,long)
==	O
'\t'	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
alen	long
||	O
!	O
blen	long
)	O
return	O
alen	long
==	O
blen	long
;	O
}	O
else	O
if	O
(	O
!	O
alen	long
||	O
*	O
a	struct(long,long)
++	O
!=	O
*	O
b	struct(long,long)
++	O
)	O
return	O
false	int
;	O
else	O
alen	long
--	O
,	O
blen	long
--	O
;	O
}	O
}	O
struct	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
{	O
char	O
*	O
name	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
bool	bool
backup	bool
;	O
}	O
;	O
static	O
gl_list_t	*(struct)
files_to_delete	*(struct)
;	O
static	O
void	O
init_files_to_delete	()->(void)
(	O
void	O
)	O
{	O
files_to_delete	*(struct)
=	O
gl_list_create_empty	(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*((*(void),*(void))->(bool)),*((*(void))->(long)),*((*(void))->(void)),bool)->(*(struct))
(	O
GL_LINKED_LIST	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
true	int
)	O
;	O
}	O
static	O
void	O
delete_file_later	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),bool)->(void)
(	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
bool	bool
backup	bool
)	O
{	O
struct	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
*	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st_tmp	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
!	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
if	O
(	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
name	*(char)
,	O
&	O
st_tmp	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't get file attributes of %s %s"	*(char)
,	O
"file"	*(char)
,	O
name	*(char)
)	O
;	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
=	O
&	O
st_tmp	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
}	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
)	O
;	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
->	O
name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
->	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
=	O
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
->	O
backup	bool
=	O
backup	bool
;	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
files_to_delete	*(struct)
,	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
)	O
;	O
insert_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),enum(int,int,int,int))->(void)
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
DELETE_LATER	int
)	O
;	O
}	O
static	O
void	O
delete_files	()->(void)
(	O
void	O
)	O
{	O
gl_list_iterator_t	struct(*(struct),*(struct),long,*(void),*(void),long,long)
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
;	O
const	O
void	O
*	O
elt	*(void)
;	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
=	O
gl_list_iterator	(*(struct))->(struct(*(struct),*(struct),long,*(void),*(void),long,long))
(	O
files_to_delete	*(struct)
)	O
;	O
while	O
(	O
gl_list_iterator_next	(*(struct(*(struct),*(struct),long,*(void),*(void),long,long)),*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
,	O
&	O
elt	*(void)
,	O
NULL	O
)	O
)	O
{	O
const	O
struct	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
*	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
=	O
elt	*(void)
;	O
if	O
(	O
lookup_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(enum(int,int,int,int))
(	O
&	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
->	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
==	O
DELETE_LATER	int
)	O
{	O
mode_t	int
mode	int
=	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
->	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
.	O
st_mode	int
;	O
if	O
(	O
verbosity	enum(int,int,int)
==	O
VERBOSE	int
)	O
say	(*(char))->(void)
(	O
"Removing %s %s\n"	*(char)
,	O
S_ISLNK	O
(	O
mode	int
)	O
?	O
"symbolic link"	*(char)
:	O
"file"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
->	O
name	*(char)
)	O
)	O
;	O
move_file	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(char),int,bool)->(void)
(	O
0	int
,	O
0	int
,	O
0	int
,	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
->	O
name	*(char)
,	O
mode	int
,	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
->	O
backup	bool
)	O
;	O
removedirs	(*(char))->(void)
(	O
file_to_delete	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),bool)
->	O
name	*(char)
)	O
;	O
}	O
}	O
gl_list_iterator_free	(*(struct(*(struct),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
}	O
struct	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
{	O
char	O
*	O
from	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
char	O
*	O
to	*(char)
;	O
mode_t	int
mode	int
;	O
bool	bool
backup	bool
;	O
}	O
;	O
static	O
gl_list_t	*(struct)
files_to_output	*(struct)
;	O
static	O
void	O
output_file_later	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(char),int,bool)->(void)
(	O
char	O
const	O
*	O
from	*(char)
,	O
int	O
*	O
from_needs_removal	*(int)
,	O
const	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
char	O
const	O
*	O
to	*(char)
,	O
mode_t	int
mode	int
,	O
bool	bool
backup	bool
)	O
{	O
struct	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
*	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
;	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
)	O
;	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
->	O
from	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
from	*(char)
)	O
;	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
->	O
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
=	O
*	O
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
->	O
to	*(char)
=	O
to	*(char)
?	O
xstrdup	(*(char))->(*(char))
(	O
to	*(char)
)	O
:	O
NULL	O
;	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
->	O
mode	int
=	O
mode	int
;	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
->	O
backup	bool
=	O
backup	bool
;	O
gl_list_add_last	(*(struct),*(void))->(*(struct))
(	O
files_to_output	*(struct)
,	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
)	O
;	O
if	O
(	O
from_needs_removal	*(int)
)	O
*	O
from_needs_removal	*(int)
=	O
0	int
;	O
}	O
static	O
void	O
output_file_now	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(char),int,bool)->(void)
(	O
char	O
const	O
*	O
from	*(char)
,	O
int	O
*	O
from_needs_removal	*(int)
,	O
const	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
char	O
const	O
*	O
to	*(char)
,	O
mode_t	int
mode	int
,	O
bool	bool
backup	bool
)	O
{	O
if	O
(	O
to	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
backup	bool
)	O
create_backup	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),bool)->(void)
(	O
from	*(char)
,	O
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
true	int
)	O
;	O
}	O
else	O
{	O
assert	O
(	O
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
->	O
st_size	long
!=	O
-	O
1	int
)	O
;	O
move_file	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(char),int,bool)->(void)
(	O
from	*(char)
,	O
from_needs_removal	*(int)
,	O
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
to	*(char)
,	O
mode	int
,	O
backup	bool
)	O
;	O
}	O
}	O
static	O
void	O
output_file	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,bool)->(void)
(	O
char	O
const	O
*	O
from	*(char)
,	O
int	O
*	O
from_needs_removal	*(int)
,	O
const	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
char	O
const	O
*	O
to	*(char)
,	O
const	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
mode_t	int
mode	int
,	O
bool	bool
backup	bool
)	O
{	O
if	O
(	O
from	*(char)
==	O
NULL	O
)	O
{	O
delete_file_later	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),bool)->(void)
(	O
to	*(char)
,	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
backup	bool
)	O
;	O
}	O
else	O
if	O
(	O
pch_git_diff	()->(bool)
(	O
)	O
&&	O
pch_says_nonexistent	(bool)->(int)
(	O
reverse	bool
)	O
!=	O
2	int
)	O
{	O
output_file_later	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(char),int,bool)->(void)
(	O
from	*(char)
,	O
from_needs_removal	*(int)
,	O
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
to	*(char)
,	O
mode	int
,	O
backup	bool
)	O
;	O
}	O
else	O
output_file_now	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(char),int,bool)->(void)
(	O
from	*(char)
,	O
from_needs_removal	*(int)
,	O
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
to	*(char)
,	O
mode	int
,	O
backup	bool
)	O
;	O
}	O
static	O
void	O
dispose_file_to_output	(*(void))->(void)
(	O
const	O
void	O
*	O
elt	*(void)
)	O
{	O
const	O
struct	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
*	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
=	O
elt	*(void)
;	O
free	(*(void))->(void)
(	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
->	O
from	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
->	O
to	*(char)
)	O
;	O
}	O
static	O
void	O
init_files_to_output	()->(void)
(	O
void	O
)	O
{	O
files_to_output	*(struct)
=	O
gl_list_create_empty	(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*((*(void),*(void))->(bool)),*((*(void))->(long)),*((*(void))->(void)),bool)->(*(struct))
(	O
GL_LINKED_LIST	O
,	O
NULL	O
,	O
NULL	O
,	O
dispose_file_to_output	(*(void))->(void)
,	O
true	int
)	O
;	O
}	O
static	O
void	O
gl_list_clear	(*(struct))->(void)
(	O
gl_list_t	*(struct)
list	*(struct)
)	O
{	O
while	O
(	O
gl_list_size	(*(struct))->(long)
(	O
list	*(struct)
)	O
>	O
0	int
)	O
gl_list_remove_at	(*(struct),long)->(bool)
(	O
list	*(struct)
,	O
0	int
)	O
;	O
}	O
static	O
void	O
output_files	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(void)
(	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
const	O
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
gl_list_iterator_t	struct(*(struct),*(struct),long,*(void),*(void),long,long)
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
;	O
const	O
void	O
*	O
elt	*(void)
;	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
=	O
gl_list_iterator	(*(struct))->(struct(*(struct),*(struct),long,*(void),*(void),long,long))
(	O
files_to_output	*(struct)
)	O
;	O
while	O
(	O
gl_list_iterator_next	(*(struct(*(struct),*(struct),long,*(void),*(void),long,long)),*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
,	O
&	O
elt	*(void)
,	O
NULL	O
)	O
)	O
{	O
const	O
struct	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
*	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
=	O
elt	*(void)
;	O
int	O
from_needs_removal	*(int)
=	O
1	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
const	O
*	O
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
=	O
&	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
->	O
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
output_file_now	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(char),int,bool)->(void)
(	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
->	O
from	*(char)
,	O
&	O
from_needs_removal	*(int)
,	O
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
->	O
to	*(char)
,	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
->	O
mode	int
,	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
->	O
backup	bool
)	O
;	O
if	O
(	O
from_needs_removal	*(int)
)	O
unlink	(*(char))->(int)
(	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
->	O
from	*(char)
)	O
;	O
if	O
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
&&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_dev	long
==	O
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
->	O
st_dev	long
&&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_ino	long
==	O
from_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
->	O
st_ino	long
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
const	O
void	O
*	O
elt2	*(void)
=	O
gl_list_get_at	(*(struct),long)->(*(void))
(	O
files_to_output	*(struct)
,	O
0	int
)	O
;	O
gl_list_remove_at	(*(struct),long)->(bool)
(	O
files_to_output	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
elt	*(void)
==	O
elt2	*(void)
)	O
break	O
;	O
}	O
gl_list_iterator_free	(*(struct(*(struct),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
return	O
;	O
}	O
}	O
gl_list_iterator_free	(*(struct(*(struct),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
gl_list_clear	(*(struct))->(void)
(	O
files_to_output	*(struct)
)	O
;	O
}	O
static	O
void	O
forget_output_files	()->(void)
(	O
void	O
)	O
{	O
gl_list_iterator_t	struct(*(struct),*(struct),long,*(void),*(void),long,long)
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
=	O
gl_list_iterator	(*(struct))->(struct(*(struct),*(struct),long,*(void),*(void),long,long))
(	O
files_to_output	*(struct)
)	O
;	O
const	O
void	O
*	O
elt	*(void)
;	O
while	O
(	O
gl_list_iterator_next	(*(struct(*(struct),*(struct),long,*(void),*(void),long,long)),*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
,	O
&	O
elt	*(void)
,	O
NULL	O
)	O
)	O
{	O
const	O
struct	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
*	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
=	O
elt	*(void)
;	O
unlink	(*(char))->(int)
(	O
file_to_output	struct(*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),int,bool)
->	O
from	*(char)
)	O
;	O
}	O
gl_list_iterator_free	(*(struct(*(struct),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
gl_list_clear	(*(struct))->(void)
(	O
files_to_output	*(struct)
)	O
;	O
}	O
void	O
fatal_exit	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
cleanup	()->(void)
(	O
)	O
;	O
if	O
(	O
sig	int
)	O
exit_with_signal	(int)->(void)
(	O
sig	int
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
static	O
void	O
remove_if_needed	(*(char),*(int))->(void)
(	O
char	O
const	O
*	O
name	*(char)
,	O
int	O
*	O
needs_removal	*(int)
)	O
{	O
if	O
(	O
*	O
needs_removal	*(int)
)	O
{	O
unlink	(*(char))->(int)
(	O
name	*(char)
)	O
;	O
*	O
needs_removal	*(int)
=	O
0	int
;	O
}	O
}	O
static	O
void	O
cleanup	()->(void)
(	O
void	O
)	O
{	O
remove_if_needed	(*(char),*(int))->(void)
(	O
TMPINNAME	*(char)
,	O
&	O
TMPINNAME_needs_removal	int
)	O
;	O
remove_if_needed	(*(char),*(int))->(void)
(	O
TMPOUTNAME	*(char)
,	O
&	O
TMPOUTNAME_needs_removal	int
)	O
;	O
remove_if_needed	(*(char),*(int))->(void)
(	O
TMPPATNAME	*(char)
,	O
&	O
TMPPATNAME_needs_removal	int
)	O
;	O
remove_if_needed	(*(char),*(int))->(void)
(	O
TMPREJNAME	*(char)
,	O
&	O
TMPREJNAME_needs_removal	int
)	O
;	O
forget_output_files	()->(void)
(	O
)	O
;	O
}	O
