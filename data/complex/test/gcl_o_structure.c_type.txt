static	O
bool	O
structure_subtypep	(int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
if	O
(	O
x	int
==	O
y	int
)	O
return	O
1	int
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_structure	O
||	O
type_of	()->(int)
(	O
y	int
)	O
!=	O
t_structure	O
)	O
FEerror	()->(int)
(	O
"bad call to structure_subtypep"	*(char)
,	O
0	int
)	O
;	O
{	O
if	O
(	O
S_DATA	()->(int)
(	O
y	int
)	O
->	O
included	O
==	O
Cnil	O
)	O
return	O
0	int
;	O
while	O
(	O
(	O
x	int
=	O
S_DATA	()->(int)
(	O
x	int
)	O
->	O
includes	O
)	O
!=	O
Cnil	O
)	O
{	O
if	O
(	O
x	int
==	O
y	int
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
}	O
static	O
void	O
bad_raw_type	()->(void)
(	O
void	O
)	O
{	O
FEerror	()->(int)
(	O
"Bad raw struct type"	*(char)
,	O
0	int
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"STRUCTURE-DEF"	*(char)
,	O
object	O
,	O
fSstructure_def	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x	int
)	O
,	O
""	*(char)
)	O
{	O
check_type_structure	O
(	O
x	int
)	O
;	O
return	O
(	O
x	int
)	O
->	O
str	O
.	O
str_def	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"STRUCTURE-LENGTH"	*(char)
,	O
object	O
,	O
fSstructure_length	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
IO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x	int
)	O
,	O
""	*(char)
)	O
{	O
check_type_structure	O
(	O
x	int
)	O
;	O
return	O
(	O
object	O
)	O
S_DATA	()->(int)
(	O
x	int
)	O
->	O
length	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"STRUCTURE-REF"	*(char)
,	O
object	O
,	O
structure_ref	()->(int)
,	O
SI	O
,	O
3	int
,	O
3	int
,	O
NONE	O
,	O
OO	O
,	O
OI	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x	int
,	O
object	O
name	O
,	O
fixnum	O
i	int
)	O
,	O
""	*(char)
)	O
{	O
unsigned	O
short	O
*	O
s_pos	*(short)
;	O
COERCE_DEF	O
(	O
name	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_structure	O
||	O
(	O
type_of	()->(int)
(	O
name	O
)	O
!=	O
t_structure	O
)	O
||	O
!	O
structure_subtypep	(int,int)->(int)
(	O
x	int
->	O
str	O
.	O
str_def	O
,	O
name	O
)	O
)	O
FEwrong_type_argument	()->(int)
(	O
(	O
type_of	()->(int)
(	O
name	O
)	O
==	O
t_structure	O
?	O
S_DATA	()->(int)
(	O
name	O
)	O
->	O
name	O
:	O
name	O
)	O
,	O
x	int
)	O
;	O
s_pos	*(short)
=	O
&	O
SLOT_POS	()->(int)
(	O
x	int
->	O
str	O
.	O
str_def	O
,	O
0	int
)	O
;	O
switch	O
(	O
(	O
SLOT_TYPE	()->(int)
(	O
x	int
->	O
str	O
.	O
str_def	O
,	O
i	int
)	O
)	O
)	O
{	O
case	O
aet_object	O
:	O
return	O
(	O
STREF	()->(int)
(	O
object	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
)	O
;	O
case	O
aet_fix	O
:	O
return	O
(	O
make_fixnum	()->(int)
(	O
(	O
STREF	()->(int)
(	O
fixnum	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
)	O
)	O
)	O
;	O
case	O
aet_ch	O
:	O
return	O
(	O
code_char	()->(int)
(	O
STREF	()->(int)
(	O
char	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
)	O
)	O
;	O
case	O
aet_bit	O
:	O
case	O
aet_char	O
:	O
return	O
(	O
small_fixnum	()->(int)
(	O
STREF	()->(int)
(	O
char	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
)	O
)	O
;	O
case	O
aet_sf	O
:	O
return	O
(	O
make_shortfloat	()->(int)
(	O
STREF	()->(int)
(	O
shortfloat	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
)	O
)	O
;	O
case	O
aet_lf	O
:	O
return	O
(	O
make_longfloat	()->(int)
(	O
STREF	()->(int)
(	O
longfloat	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
)	O
)	O
;	O
case	O
aet_uchar	O
:	O
return	O
(	O
small_fixnum	()->(int)
(	O
STREF	()->(int)
(	O
unsigned	O
char	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
)	O
)	O
;	O
case	O
aet_ushort	O
:	O
return	O
(	O
make_fixnum	()->(int)
(	O
STREF	()->(int)
(	O
unsigned	O
short	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
)	O
)	O
;	O
case	O
aet_short	O
:	O
return	O
(	O
make_fixnum	()->(int)
(	O
STREF	()->(int)
(	O
short	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
)	O
)	O
;	O
default	O
:	O
bad_raw_type	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
siLstructure_ref1	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
int	O
n	int
=	O
fix	()->(int)
(	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
object	O
def	*(struct)
;	O
check_type_structure	O
(	O
x	int
)	O
;	O
def	*(struct)
=	O
x	int
->	O
str	O
.	O
str_def	O
;	O
if	O
(	O
n	int
>=	O
S_DATA	()->(int)
(	O
def	*(struct)
)	O
->	O
length	O
)	O
FEerror	()->(int)
(	O
"Structure ref out of bounds"	*(char)
,	O
0	int
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
structure_ref	()->(int)
(	O
x	int
,	O
x	int
->	O
str	O
.	O
str_def	O
,	O
n	int
)	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"STRUCTURE-SET"	*(char)
,	O
object	O
,	O
structure_set	()->(int)
,	O
SI	O
,	O
4	int
,	O
4	int
,	O
NONE	O
,	O
OO	O
,	O
OI	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x	int
,	O
object	O
name	O
,	O
fixnum	O
i	int
,	O
object	O
v	O
)	O
,	O
""	*(char)
)	O
{	O
unsigned	O
short	O
*	O
s_pos	*(short)
;	O
COERCE_DEF	O
(	O
name	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_structure	O
||	O
type_of	()->(int)
(	O
name	O
)	O
!=	O
t_structure	O
||	O
!	O
structure_subtypep	(int,int)->(int)
(	O
x	int
->	O
str	O
.	O
str_def	O
,	O
name	O
)	O
)	O
FEwrong_type_argument	()->(int)
(	O
(	O
type_of	()->(int)
(	O
name	O
)	O
==	O
t_structure	O
?	O
S_DATA	()->(int)
(	O
name	O
)	O
->	O
name	O
:	O
name	O
)	O
,	O
x	int
)	O
;	O
s_pos	*(short)
=	O
&	O
SLOT_POS	()->(int)
(	O
x	int
->	O
str	O
.	O
str_def	O
,	O
0	int
)	O
;	O
switch	O
(	O
SLOT_TYPE	()->(int)
(	O
x	int
->	O
str	O
.	O
str_def	O
,	O
i	int
)	O
)	O
{	O
case	O
aet_object	O
:	O
STREF	()->(int)
(	O
object	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
v	O
;	O
break	O
;	O
case	O
aet_fix	O
:	O
(	O
STREF	()->(int)
(	O
fixnum	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
)	O
=	O
fix	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
case	O
aet_ch	O
:	O
STREF	()->(int)
(	O
char	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
char_code	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
case	O
aet_bit	O
:	O
case	O
aet_char	O
:	O
STREF	()->(int)
(	O
char	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
fix	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
case	O
aet_sf	O
:	O
STREF	()->(int)
(	O
shortfloat	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
sf	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
case	O
aet_lf	O
:	O
STREF	()->(int)
(	O
longfloat	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
lf	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
case	O
aet_uchar	O
:	O
STREF	()->(int)
(	O
unsigned	O
char	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
fix	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
case	O
aet_ushort	O
:	O
STREF	()->(int)
(	O
unsigned	O
short	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
fix	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
case	O
aet_short	O
:	O
STREF	()->(int)
(	O
short	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
fix	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
default	O
:	O
bad_raw_type	()->(void)
(	O
)	O
;	O
}	O
return	O
(	O
v	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
siLstructure_subtype_p	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
,	O
y	int
;	O
check_arg	()->(int)
(	O
2	int
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
y	int
=	O
vs_base	O
[	O
1	int
]	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_structure	O
)	O
{	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
goto	O
BOTTOM	O
;	O
}	O
x	int
=	O
x	int
->	O
str	O
.	O
str_def	O
;	O
COERCE_DEF	O
(	O
y	int
)	O
;	O
if	O
(	O
structure_subtypep	(int,int)->(int)
(	O
x	int
,	O
y	int
)	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
BOTTOM	O
:	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
}	O
object	O
structure_to_list	(int)->(int)
(	O
object	O
x	int
)	O
{	O
object	O
*	O
p	O
,	O
s	O
;	O
struct	O
s_data	O
*	O
def	*(struct)
=	O
S_DATA	()->(int)
(	O
x	int
->	O
str	O
.	O
str_def	O
)	O
;	O
int	O
i	int
,	O
n	int
;	O
s	O
=	O
def	*(struct)
->	O
slot_descriptions	O
;	O
vs_push	()->(int)
(	O
def	*(struct)
->	O
name	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
p	O
=	O
&	O
vs_head	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
n	int
=	O
def	*(struct)
->	O
length	O
;	O
!	O
endp	()->(int)
(	O
s	O
)	O
&&	O
i	int
<	O
n	int
;	O
s	O
=	O
s	O
->	O
c	O
.	O
c_cdr	O
,	O
i	int
++	O
)	O
{	O
*	O
p	O
=	O
make_cons	()->(int)
(	O
car	()->(int)
(	O
s	O
->	O
c	O
.	O
c_car	O
)	O
,	O
Cnil	O
)	O
;	O
p	O
=	O
&	O
(	O
(	O
*	O
p	O
)	O
->	O
c	O
.	O
c_cdr	O
)	O
;	O
*	O
p	O
=	O
make_cons	()->(int)
(	O
structure_ref	()->(int)
(	O
x	int
,	O
x	int
->	O
str	O
.	O
str_def	O
,	O
i	int
)	O
,	O
Cnil	O
)	O
;	O
p	O
=	O
&	O
(	O
(	O
*	O
p	O
)	O
->	O
c	O
.	O
c_cdr	O
)	O
;	O
}	O
stack_cons	()->(int)
(	O
)	O
;	O
return	O
(	O
vs_pop	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
siLmake_structure	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
,	O
name	O
,	O
*	O
base	O
;	O
struct	O
s_data	O
*	O
def	*(struct)
=	O
NULL	O
;	O
int	O
narg	int
,	O
i	int
,	O
size	int
;	O
base	O
=	O
vs_base	O
;	O
if	O
(	O
(	O
narg	int
=	O
vs_top	O
-	O
base	O
)	O
==	O
0	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
{	O
BEGIN_NO_INTERRUPT	O
;	O
x	int
=	O
alloc_object	()->(int)
(	O
t_structure	O
)	O
;	O
name	O
=	O
base	O
[	O
0	int
]	O
;	O
COERCE_DEF	O
(	O
name	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
name	O
)	O
!=	O
t_structure	O
||	O
(	O
def	*(struct)
=	O
S_DATA	()->(int)
(	O
name	O
)	O
)	O
->	O
length	O
!=	O
--	O
narg	int
)	O
FEerror	()->(int)
(	O
"Bad make_structure args for type ~a"	*(char)
,	O
1	int
,	O
base	O
[	O
0	int
]	O
)	O
;	O
x	int
->	O
str	O
.	O
str_def	O
=	O
name	O
;	O
x	int
->	O
str	O
.	O
str_self	O
=	O
NULL	O
;	O
size	int
=	O
S_DATA	()->(int)
(	O
name	O
)	O
->	O
size	int
;	O
base	O
[	O
0	int
]	O
=	O
x	int
;	O
x	int
->	O
str	O
.	O
str_self	O
=	O
(	O
object	O
*	O
)	O
(	O
def	*(struct)
->	O
staticp	O
==	O
Cnil	O
?	O
alloc_relblock	()->(int)
(	O
size	int
)	O
:	O
alloc_contblock	()->(int)
(	O
size	int
)	O
)	O
;	O
if	O
(	O
S_DATA	()->(int)
(	O
name	O
)	O
->	O
has_holes	O
!=	O
Cnil	O
)	O
bzero	(*(void),long)->(void)
(	O
x	int
->	O
str	O
.	O
str_self	O
,	O
size	int
)	O
;	O
{	O
unsigned	O
char	O
*	O
s_type	*(char)
;	O
unsigned	O
short	O
*	O
s_pos	*(short)
;	O
s_pos	*(short)
=	O
(	O
&	O
SLOT_POS	()->(int)
(	O
x	int
->	O
str	O
.	O
str_def	O
,	O
0	int
)	O
)	O
;	O
s_type	*(char)
=	O
(	O
&	O
(	O
SLOT_TYPE	()->(int)
(	O
x	int
->	O
str	O
.	O
str_def	O
,	O
0	int
)	O
)	O
)	O
;	O
base	O
=	O
base	O
+	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
narg	int
;	O
i	int
++	O
)	O
{	O
object	O
v	O
=	O
base	O
[	O
i	int
]	O
;	O
switch	O
(	O
s_type	*(char)
[	O
i	int
]	O
)	O
{	O
case	O
aet_object	O
:	O
STREF	()->(int)
(	O
object	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
v	O
;	O
break	O
;	O
case	O
aet_fix	O
:	O
(	O
STREF	()->(int)
(	O
fixnum	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
)	O
=	O
fix	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
case	O
aet_ch	O
:	O
STREF	()->(int)
(	O
char	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
char_code	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
case	O
aet_bit	O
:	O
case	O
aet_char	O
:	O
STREF	()->(int)
(	O
char	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
fix	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
case	O
aet_sf	O
:	O
STREF	()->(int)
(	O
shortfloat	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
sf	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
case	O
aet_lf	O
:	O
STREF	()->(int)
(	O
longfloat	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
lf	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
case	O
aet_uchar	O
:	O
STREF	()->(int)
(	O
unsigned	O
char	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
fix	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
case	O
aet_ushort	O
:	O
STREF	()->(int)
(	O
unsigned	O
short	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
fix	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
case	O
aet_short	O
:	O
STREF	()->(int)
(	O
short	O
,	O
x	int
,	O
s_pos	*(short)
[	O
i	int
]	O
)	O
=	O
fix	()->(int)
(	O
v	O
)	O
;	O
break	O
;	O
default	O
:	O
bad_raw_type	()->(void)
(	O
)	O
;	O
}	O
}	O
vs_top	O
=	O
base	O
;	O
vs_base	O
=	O
base	O
-	O
1	int
;	O
END_NO_INTERRUPT	O
;	O
}	O
}	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
siLcopy_structure	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
,	O
y	int
;	O
struct	O
s_data	O
*	O
def	*(struct)
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
check_type_structure	O
(	O
x	int
)	O
;	O
{	O
BEGIN_NO_INTERRUPT	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
y	int
=	O
alloc_object	()->(int)
(	O
t_structure	O
)	O
;	O
def	*(struct)
=	O
S_DATA	()->(int)
(	O
y	int
->	O
str	O
.	O
str_def	O
=	O
x	int
->	O
str	O
.	O
str_def	O
)	O
;	O
y	int
->	O
str	O
.	O
str_self	O
=	O
NULL	O
;	O
y	int
->	O
str	O
.	O
str_self	O
=	O
(	O
object	O
*	O
)	O
alloc_relblock	()->(int)
(	O
def	*(struct)
->	O
size	int
)	O
;	O
bcopy	(*(void),*(void),long)->(void)
(	O
x	int
->	O
str	O
.	O
str_self	O
,	O
y	int
->	O
str	O
.	O
str_self	O
,	O
def	*(struct)
->	O
size	int
)	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
END_NO_INTERRUPT	O
;	O
}	O
}	O
LFD	(int)->(int)
(	O
siLstructure_name	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_structure	O
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
S_DATA	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
->	O
str	O
.	O
str_def	O
)	O
->	O
name	O
;	O
}	O
LFD	(int)->(int)
(	O
siLstructure_ref	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
3	int
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
structure_ref	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
,	O
vs_base	O
[	O
1	int
]	O
,	O
fix	()->(int)
(	O
vs_base	O
[	O
2	int
]	O
)	O
)	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
}	O
LFD	(int)->(int)
(	O
siLstructure_set	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
4	int
)	O
;	O
structure_set	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
,	O
vs_base	O
[	O
1	int
]	O
,	O
fix	()->(int)
(	O
vs_base	O
[	O
2	int
]	O
)	O
,	O
vs_base	O
[	O
3	int
]	O
)	O
;	O
vs_base	O
=	O
vs_top	O
-	O
1	int
;	O
}	O
LFD	(int)->(int)
(	O
siLstructurep	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
==	O
t_structure	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
LFD	(int)->(int)
(	O
siLrplaca_nthcdr	int
)	O
(	O
void	O
)	O
{	O
int	O
i	int
;	O
object	O
l	O
;	O
check_arg	()->(int)
(	O
3	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
vs_base	O
[	O
1	int
]	O
)	O
!=	O
t_fixnum	O
||	O
fix	()->(int)
(	O
vs_base	O
[	O
1	int
]	O
)	O
<	O
0	int
)	O
FEerror	()->(int)
(	O
"~S is not a non-negative fixnum."	*(char)
,	O
1	int
,	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
!=	O
t_cons	O
)	O
FEerror	()->(int)
(	O
"~S is not a cons."	*(char)
,	O
1	int
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
fix	()->(int)
(	O
vs_base	O
[	O
1	int
]	O
)	O
,	O
l	O
=	O
vs_base	O
[	O
0	int
]	O
;	O
i	int
>	O
0	int
;	O
--	O
i	int
)	O
{	O
l	O
=	O
l	O
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
endp	()->(int)
(	O
l	O
)	O
)	O
FEerror	()->(int)
(	O
"The offset ~S is too big."	*(char)
,	O
1	int
,	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
}	O
take_care	()->(int)
(	O
vs_base	O
[	O
2	int
]	O
)	O
;	O
l	O
->	O
c	O
.	O
c_car	O
=	O
vs_base	O
[	O
2	int
]	O
;	O
vs_base	O
=	O
vs_base	O
+	O
2	int
;	O
}	O
LFD	(int)->(int)
(	O
siLlist_nth	int
)	O
(	O
void	O
)	O
{	O
int	O
i	int
;	O
object	O
l	O
;	O
check_arg	()->(int)
(	O
2	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
!=	O
t_fixnum	O
||	O
fix	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
<	O
0	int
)	O
FEerror	()->(int)
(	O
"~S is not a non-negative fixnum."	*(char)
,	O
1	int
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
vs_base	O
[	O
1	int
]	O
)	O
!=	O
t_cons	O
)	O
FEerror	()->(int)
(	O
"~S is not a cons."	*(char)
,	O
1	int
,	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
fix	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
,	O
l	O
=	O
vs_base	O
[	O
1	int
]	O
;	O
i	int
>	O
0	int
;	O
--	O
i	int
)	O
{	O
l	O
=	O
l	O
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
endp	()->(int)
(	O
l	O
)	O
)	O
FEerror	()->(int)
(	O
"The offset ~S is too big."	*(char)
,	O
1	int
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
vs_base	O
[	O
0	int
]	O
=	O
l	O
->	O
c	O
.	O
c_car	O
;	O
vs_popp	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
siLmake_s_data_structure	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
,	O
y	int
,	O
raw	O
,	O
*	O
base	O
;	O
int	O
i	int
;	O
check_arg	()->(int)
(	O
5	int
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
base	O
=	O
vs_base	O
;	O
raw	O
=	O
vs_base	O
[	O
1	int
]	O
;	O
y	int
=	O
alloc_object	()->(int)
(	O
t_structure	O
)	O
;	O
y	int
->	O
str	O
.	O
str_def	O
=	O
y	int
;	O
y	int
->	O
str	O
.	O
str_self	O
=	O
(	O
object	O
*	O
)	O
(	O
x	int
->	O
v	O
.	O
v_self	O
)	O
;	O
S_DATA	()->(int)
(	O
y	int
)	O
->	O
name	O
=	O
sSs_data	O
;	O
S_DATA	()->(int)
(	O
y	int
)	O
->	O
length	O
=	O
(	O
raw	O
->	O
v	O
.	O
v_dim	O
)	O
;	O
S_DATA	()->(int)
(	O
y	int
)	O
->	O
raw	O
=	O
raw	O
;	O
for	O
(	O
i	int
=	O
3	int
;	O
i	int
<	O
raw	O
->	O
v	O
.	O
v_dim	O
;	O
i	int
++	O
)	O
y	int
->	O
str	O
.	O
str_self	O
[	O
i	int
]	O
=	O
Cnil	O
;	O
S_DATA	()->(int)
(	O
y	int
)	O
->	O
slot_position	O
=	O
base	O
[	O
2	int
]	O
;	O
S_DATA	()->(int)
(	O
y	int
)	O
->	O
slot_descriptions	O
=	O
base	O
[	O
3	int
]	O
;	O
S_DATA	()->(int)
(	O
y	int
)	O
->	O
staticp	O
=	O
base	O
[	O
4	int
]	O
;	O
S_DATA	()->(int)
(	O
y	int
)	O
->	O
size	int
=	O
(	O
raw	O
->	O
v	O
.	O
v_dim	O
)	O
*	O
sizeof	O
(	O
object	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
y	int
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
}	O
short	O
aet_sizes	array(short)
[	O
]	O
=	O
{	O
sizeof	O
(	O
object	O
)	O
,	O
sizeof	O
(	O
char	O
)	O
,	O
sizeof	O
(	O
char	O
)	O
,	O
sizeof	O
(	O
fixnum	O
)	O
,	O
sizeof	O
(	O
float	O
)	O
,	O
sizeof	O
(	O
double	O
)	O
,	O
sizeof	O
(	O
char	O
)	O
,	O
sizeof	O
(	O
char	O
)	O
,	O
sizeof	O
(	O
short	O
)	O
,	O
sizeof	O
(	O
short	O
)	O
}	O
;	O
static	O
void	O
FFN	(int)->(int)
(	O
siLsize_of	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
int	O
i	int
;	O
i	int
=	O
aet_sizes	array(short)
[	O
fix	()->(int)
(	O
fSget_aelttype	()->(int)
(	O
x	int
)	O
)	O
]	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
make_fixnum	()->(int)
(	O
i	int
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
siLaet_type	int
)	O
(	O
void	O
)	O
{	O
vs_base	O
[	O
0	int
]	O
=	O
fSget_aelttype	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
siLalignment	int
)	O
(	O
void	O
)	O
{	O
struct	O
{	O
double	O
x	int
;	O
int	O
y	int
;	O
double	O
z	double
;	O
float	O
x1	float
;	O
int	O
y1	int
;	O
float	O
z1	float
;	O
}	O
joe	struct(double,int,double,float,int,float)
;	O
joe	struct(double,int,double,float,int,float)
.	O
z	double
=	O
3.0	int
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
==	O
sLlong_float	O
)	O
{	O
vs_base	O
[	O
0	int
]	O
=	O
make_fixnum	()->(int)
(	O
(	O
long	O
)	O
&	O
joe	struct(double,int,double,float,int,float)
.	O
z	double
-	O
(	O
long	O
)	O
&	O
joe	struct(double,int,double,float,int,float)
.	O
y	int
)	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
==	O
sLshort_float	O
)	O
{	O
vs_base	O
[	O
0	int
]	O
=	O
make_fixnum	()->(int)
(	O
(	O
long	O
)	O
&	O
(	O
joe	struct(double,int,double,float,int,float)
.	O
z1	float
)	O
-	O
(	O
long	O
)	O
&	O
(	O
joe	struct(double,int,double,float,int,float)
.	O
y1	int
)	O
)	O
;	O
return	O
;	O
}	O
else	O
{	O
FFN	(int)->(int)
(	O
siLsize_of	int
)	O
(	O
)	O
;	O
}	O
}	O
DEF_ORDINARY	()->(int)
(	O
"S-DATA"	*(char)
,	O
sSs_data	O
,	O
SI	O
,	O
""	*(char)
)	O
;	O
void	O
gcl_init_structure_function	()->(void)
(	O
void	O
)	O
{	O
make_si_function	()->(int)
(	O
"MAKE-STRUCTURE"	*(char)
,	O
siLmake_structure	int
)	O
;	O
make_si_function	()->(int)
(	O
"MAKE-S-DATA-STRUCTURE"	*(char)
,	O
siLmake_s_data_structure	int
)	O
;	O
make_si_function	()->(int)
(	O
"COPY-STRUCTURE"	*(char)
,	O
siLcopy_structure	int
)	O
;	O
make_si_function	()->(int)
(	O
"STRUCTURE-NAME"	*(char)
,	O
siLstructure_name	int
)	O
;	O
make_si_function	()->(int)
(	O
"STRUCTURE-REF1"	*(char)
,	O
siLstructure_ref1	int
)	O
;	O
make_si_function	()->(int)
(	O
"STRUCTUREP"	*(char)
,	O
siLstructurep	int
)	O
;	O
make_si_function	()->(int)
(	O
"SIZE-OF"	*(char)
,	O
siLsize_of	int
)	O
;	O
make_si_function	()->(int)
(	O
"ALIGNMENT"	*(char)
,	O
siLalignment	int
)	O
;	O
make_si_function	()->(int)
(	O
"STRUCTURE-SUBTYPE-P"	*(char)
,	O
siLstructure_subtype_p	int
)	O
;	O
make_si_function	()->(int)
(	O
"RPLACA-NTHCDR"	*(char)
,	O
siLrplaca_nthcdr	int
)	O
;	O
make_si_function	()->(int)
(	O
"LIST-NTH"	*(char)
,	O
siLlist_nth	int
)	O
;	O
make_si_function	()->(int)
(	O
"AET-TYPE"	*(char)
,	O
siLaet_type	int
)	O
;	O
}	O
