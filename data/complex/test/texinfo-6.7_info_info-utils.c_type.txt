char	O
*	O
info_parsed_filename	*(char)
=	O
NULL	O
;	O
char	O
*	O
info_parsed_nodename	*(char)
=	O
NULL	O
;	O
int	O
read_bracketed_filename	(*(char),*(*(char)))->(int)
(	O
char	O
*	O
string	*(char)
,	O
char	O
*	O
*	O
filename	*(char)
)	O
{	O
register	O
int	O
i	int
=	O
0	int
;	O
int	O
count	*(int)
=	O
0	int
;	O
int	O
first_close	int
=	O
-	O
1	int
;	O
if	O
(	O
*	O
string	*(char)
!=	O
'('	O
)	O
return	O
0	int
;	O
string	*(char)
++	O
;	O
count	*(int)
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
string	*(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
string	*(char)
[	O
i	int
]	O
==	O
'('	O
)	O
count	*(int)
++	O
;	O
else	O
if	O
(	O
string	*(char)
[	O
i	int
]	O
==	O
')'	O
)	O
{	O
if	O
(	O
first_close	int
==	O
-	O
1	int
)	O
first_close	int
=	O
i	int
;	O
count	*(int)
--	O
;	O
if	O
(	O
count	*(int)
==	O
0	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
count	*(int)
>	O
0	int
)	O
{	O
if	O
(	O
first_close	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
filename	*(char)
)	O
*	O
filename	*(char)
=	O
0	int
;	O
return	O
0	int
;	O
}	O
i	int
=	O
first_close	int
;	O
}	O
if	O
(	O
filename	*(char)
)	O
{	O
*	O
filename	*(char)
=	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
i	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
*	O
filename	*(char)
,	O
string	*(char)
,	O
i	int
)	O
;	O
}	O
return	O
i	int
+	O
2	int
;	O
}	O
void	O
info_parse_node	(*(char))->(void)
(	O
char	O
*	O
string	*(char)
)	O
{	O
int	O
nodename_len	int
;	O
free	(*(void))->(void)
(	O
info_parsed_filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
info_parsed_nodename	*(char)
)	O
;	O
info_parsed_filename	*(char)
=	O
0	int
;	O
info_parsed_nodename	*(char)
=	O
0	int
;	O
if	O
(	O
!	O
string	*(char)
||	O
!	O
*	O
string	*(char)
)	O
return	O
;	O
string	*(char)
+=	O
skip_whitespace_and_newlines	(*(char))->(int)
(	O
string	*(char)
)	O
;	O
string	*(char)
+=	O
read_bracketed_filename	(*(char),*(*(char)))->(int)
(	O
string	*(char)
,	O
&	O
info_parsed_filename	*(char)
)	O
;	O
string	*(char)
+=	O
skip_whitespace_and_newlines	(*(char))->(int)
(	O
string	*(char)
)	O
;	O
nodename_len	int
=	O
read_quoted_string	(*(char),*(char),int,*(*(char)))->(long)
(	O
string	*(char)
,	O
""	*(char)
,	O
0	int
,	O
&	O
info_parsed_nodename	*(char)
)	O
;	O
if	O
(	O
nodename_len	int
!=	O
0	int
)	O
{	O
canonicalize_whitespace	(*(char))->(void)
(	O
info_parsed_nodename	*(char)
)	O
;	O
}	O
}	O
long	O
read_quoted_string	(*(char),*(char),int,*(*(char)))->(long)
(	O
char	O
*	O
start	int
,	O
char	O
*	O
terminator	*(char)
,	O
int	O
lines	int
,	O
char	O
*	O
*	O
output	*(*(char))
)	O
{	O
long	O
len	long
;	O
char	O
*	O
nl	*(char)
=	O
0	int
,	O
saved_char	char
;	O
if	O
(	O
lines	int
)	O
{	O
int	O
i	int
;	O
nl	*(char)
=	O
start	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
lines	int
;	O
i	int
++	O
)	O
{	O
nl	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
nl	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
nl	*(char)
)	O
break	O
;	O
nl	*(char)
++	O
;	O
}	O
if	O
(	O
nl	*(char)
)	O
{	O
saved_char	char
=	O
*	O
nl	*(char)
;	O
*	O
nl	*(char)
=	O
'\0'	O
;	O
}	O
}	O
if	O
(	O
start	int
[	O
0	int
]	O
!=	O
'\177'	O
)	O
{	O
len	long
=	O
strcspn	(*(char),*(char))->(long)
(	O
start	int
,	O
terminator	*(char)
)	O
;	O
if	O
(	O
*	O
terminator	*(char)
&&	O
!	O
start	int
[	O
len	long
]	O
)	O
{	O
len	long
=	O
0	int
;	O
*	O
output	*(*(char))
=	O
0	int
;	O
}	O
else	O
{	O
*	O
output	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
output	*(*(char))
,	O
start	int
,	O
len	long
)	O
;	O
(	O
*	O
output	*(*(char))
)	O
[	O
len	long
]	O
=	O
'\0'	O
;	O
}	O
}	O
else	O
{	O
len	long
=	O
strcspn	(*(char),*(char))->(long)
(	O
start	int
+	O
1	int
,	O
"\177"	*(char)
)	O
;	O
if	O
(	O
*	O
terminator	*(char)
&&	O
!	O
(	O
start	int
+	O
1	int
)	O
[	O
len	long
]	O
)	O
{	O
len	long
=	O
0	int
;	O
*	O
output	*(*(char))
=	O
0	int
;	O
}	O
else	O
{	O
*	O
output	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
output	*(*(char))
,	O
start	int
+	O
1	int
,	O
len	long
)	O
;	O
(	O
*	O
output	*(*(char))
)	O
[	O
len	long
]	O
=	O
'\0'	O
;	O
len	long
+=	O
2	int
;	O
}	O
}	O
if	O
(	O
nl	*(char)
)	O
*	O
nl	*(char)
=	O
saved_char	char
;	O
return	O
len	long
;	O
}	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
info_get_menu_entry_by_label	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),*(char),int)->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
char	O
*	O
label	*(char)
,	O
int	O
sloppy	int
)	O
{	O
register	O
int	O
i	int
;	O
int	O
best_guess	int
=	O
-	O
1	int
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
references	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
references	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
;	O
if	O
(	O
!	O
references	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
references	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
type	enum(int,int,int,int)
!=	O
REFERENCE_MENU_ITEM	int
)	O
continue	O
;	O
if	O
(	O
mbscasecmp	(*(char),*(char))->(int)
(	O
label	*(char)
,	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
)	O
==	O
0	int
)	O
return	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
else	O
if	O
(	O
sloppy	int
&&	O
best_guess	int
==	O
-	O
1	int
&&	O
(	O
mbsncasecmp	(*(char),*(char),long)->(int)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
,	O
label	*(char)
,	O
strlen	(*(char))->(long)
(	O
label	*(char)
)	O
)	O
==	O
0	int
)	O
)	O
best_guess	int
=	O
i	int
;	O
}	O
if	O
(	O
sloppy	int
&&	O
best_guess	int
!=	O
-	O
1	int
)	O
return	O
references	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
best_guess	int
]	O
;	O
return	O
0	int
;	O
}	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
info_concatenate_references	(*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(*(struct(*(char),*(char),*(char),int,int,long,int))))->(*(*(struct(*(char),*(char),*(char),int,int,long,int))))
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
ref1	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
ref2	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
{	O
register	O
int	O
i	int
,	O
j	int
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
result	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
;	O
int	O
size	long
=	O
0	int
;	O
if	O
(	O
ref1	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
ref1	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
size	long
+=	O
i	int
;	O
}	O
if	O
(	O
ref2	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
ref2	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
size	long
+=	O
i	int
;	O
}	O
result	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
=	O
xmalloc	(long)->(*(void))
(	O
(	O
1	int
+	O
size	long
)	O
*	O
sizeof	O
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
)	O
)	O
;	O
j	int
=	O
0	int
;	O
if	O
(	O
ref1	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
ref1	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
result	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
j	int
++	O
]	O
=	O
ref1	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
;	O
}	O
if	O
(	O
ref2	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
ref2	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
result	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
j	int
++	O
]	O
=	O
ref2	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
;	O
}	O
result	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
j	int
]	O
=	O
NULL	O
;	O
return	O
result	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
;	O
}	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
info_copy_reference	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
src	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
{	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
dest	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
)	O
)	O
;	O
dest	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
=	O
src	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
?	O
xstrdup	(*(char))->(*(char))
(	O
src	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
)	O
:	O
NULL	O
;	O
dest	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
=	O
src	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
?	O
xstrdup	(*(char))->(*(char))
(	O
src	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
)	O
:	O
NULL	O
;	O
dest	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
=	O
src	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
?	O
xstrdup	(*(char))->(*(char))
(	O
src	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
)	O
:	O
NULL	O
;	O
dest	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
start	int
=	O
src	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
start	int
;	O
dest	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
end	int
=	O
src	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
end	int
;	O
dest	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
line_number	long
=	O
src	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
line_number	long
;	O
dest	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
type	enum(int,int,int,int)
=	O
src	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
type	enum(int,int,int,int)
;	O
return	O
dest	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
}	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
info_copy_references	(*(*(struct(*(char),*(char),*(char),int,int,long,int))))->(*(*(struct(*(char),*(char),*(char),int,int,long,int))))
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
ref1	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
{	O
int	O
i	int
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
result	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
;	O
int	O
size	long
;	O
if	O
(	O
!	O
ref1	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
ref1	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
size	long
=	O
i	int
;	O
result	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
=	O
xmalloc	(long)->(*(void))
(	O
(	O
1	int
+	O
size	long
)	O
*	O
sizeof	O
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
ref1	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
result	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
=	O
info_copy_reference	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
ref1	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
)	O
;	O
result	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
=	O
NULL	O
;	O
return	O
result	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
;	O
}	O
void	O
info_reference_free	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(void)
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
ref	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
{	O
if	O
(	O
ref	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
{	O
free	(*(void))->(void)
(	O
ref	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
ref	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
ref	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
ref	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
;	O
}	O
}	O
void	O
info_free_references	(*(*(struct(*(char),*(char),*(char),int,int,long,int))))->(void)
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
references	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
{	O
register	O
int	O
i	int
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
if	O
(	O
references	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
references	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
&&	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
references	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
info_reference_free	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(void)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
;	O
free	(*(void))->(void)
(	O
references	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
;	O
}	O
}	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
info_new_reference	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
char	O
*	O
filename	*(char)
,	O
char	O
*	O
nodename	*(char)
)	O
{	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
r	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
)	O
)	O
;	O
r	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
=	O
0	int
;	O
r	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
=	O
filename	*(char)
?	O
xstrdup	(*(char))->(*(char))
(	O
filename	*(char)
)	O
:	O
0	int
;	O
r	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
=	O
nodename	*(char)
?	O
xstrdup	(*(char))->(*(char))
(	O
nodename	*(char)
)	O
:	O
0	int
;	O
r	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
start	int
=	O
0	int
;	O
r	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
end	int
=	O
0	int
;	O
r	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
line_number	long
=	O
0	int
;	O
r	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
type	enum(int,int,int,int)
=	O
0	int
;	O
return	O
r	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
}	O
void	O
canonicalize_whitespace	(*(char))->(void)
(	O
char	O
*	O
string	*(char)
)	O
{	O
register	O
int	O
i	int
,	O
j	int
;	O
int	O
len	long
,	O
whitespace_found	int
,	O
whitespace_loc	int
=	O
0	int
;	O
char	O
*	O
temp	*(char)
;	O
if	O
(	O
!	O
string	*(char)
)	O
return	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
;	O
temp	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
1	int
+	O
len	long
)	O
;	O
whitespace_found	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
0	int
;	O
string	*(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
whitespace_or_newline	O
(	O
string	*(char)
[	O
i	int
]	O
)	O
)	O
{	O
whitespace_found	int
++	O
;	O
whitespace_loc	int
=	O
i	int
;	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
whitespace_found	int
&&	O
whitespace_loc	int
)	O
{	O
whitespace_found	int
=	O
0	int
;	O
if	O
(	O
j	int
)	O
temp	*(char)
[	O
j	int
++	O
]	O
=	O
' '	O
;	O
}	O
temp	*(char)
[	O
j	int
++	O
]	O
=	O
string	*(char)
[	O
i	int
]	O
;	O
}	O
}	O
if	O
(	O
j	int
&&	O
whitespace	O
(	O
temp	*(char)
[	O
j	int
-	O
1	int
]	O
)	O
)	O
j	int
--	O
;	O
temp	*(char)
[	O
j	int
]	O
=	O
'\0'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
string	*(char)
,	O
temp	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
temp	*(char)
)	O
;	O
}	O
int	O
ansi_escape	(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))),*(long))->(int)
(	O
mbi_iterator_t	struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char)))
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
,	O
size_t	long
*	O
plen	*(long)
)	O
{	O
if	O
(	O
raw_escapes_p	int
&&	O
*	O
mbi_cur_ptr	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
==	O
'\033'	O
&&	O
mbi_avail	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
)	O
{	O
mbi_advance	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
;	O
if	O
(	O
*	O
mbi_cur_ptr	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
==	O
'['	O
&&	O
mbi_avail	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
)	O
{	O
ITER_SETBYTES	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
,	O
1	int
)	O
;	O
mbi_advance	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
mbi_cur_ptr	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
)	O
&&	O
mbi_avail	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
)	O
{	O
ITER_SETBYTES	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
,	O
1	int
)	O
;	O
mbi_advance	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
;	O
if	O
(	O
*	O
mbi_cur_ptr	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
==	O
'm'	O
)	O
{	O
*	O
plen	*(long)
=	O
4	int
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
mbi_cur_ptr	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
)	O
&&	O
mbi_avail	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
)	O
{	O
ITER_SETBYTES	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
,	O
1	int
)	O
;	O
mbi_advance	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
;	O
if	O
(	O
*	O
mbi_cur_ptr	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
==	O
'm'	O
)	O
{	O
*	O
plen	*(long)
=	O
5	int
;	O
return	O
1	int
;	O
}	O
}	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
text_buffer	struct(*(char),long,long)
printed_rep	struct(*(char),long,long)
=	O
{	O
0	int
}	O
;	O
char	O
*	O
printed_representation	(*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char)))),*(int),long,*(long),*(long))->(*(char))
(	O
mbi_iterator_t	struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char)))
*	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
,	O
int	O
*	O
delim	*(int)
,	O
size_t	long
pl_chars	long
,	O
size_t	long
*	O
pchars	*(long)
,	O
size_t	long
*	O
pbytes	*(long)
)	O
{	O
struct	O
text_buffer	struct(*(char),long,long)
*	O
rep	*(struct(*(char),long,long))
=	O
&	O
printed_rep	struct(*(char),long,long)
;	O
char	O
*	O
cur_ptr	*(char)
=	O
(	O
char	O
*	O
)	O
mbi_cur_ptr	O
(	O
*	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
;	O
size_t	long
cur_len	long
=	O
mb_len	O
(	O
mbi_cur	O
(	O
*	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
)	O
;	O
text_buffer_reset	O
(	O
&	O
printed_rep	struct(*(char),long,long)
)	O
;	O
if	O
(	O
mb_isprint	O
(	O
mbi_cur	O
(	O
*	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
)	O
)	O
{	O
*	O
pchars	*(long)
=	O
wcwidth	(int)->(int)
(	O
(	O
*	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
.	O
cur	struct(*(char),long,bool,int,array(char))
.	O
wc	int
)	O
;	O
*	O
pbytes	*(long)
=	O
cur_len	long
;	O
return	O
cur_ptr	*(char)
;	O
}	O
else	O
if	O
(	O
cur_len	long
==	O
1	int
)	O
{	O
if	O
(	O
*	O
cur_ptr	*(char)
==	O
'\n'	O
||	O
*	O
cur_ptr	*(char)
==	O
'\r'	O
)	O
{	O
if	O
(	O
*	O
cur_ptr	*(char)
==	O
'\r'	O
&&	O
cur_ptr	*(char)
[	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
*	O
pchars	*(long)
=	O
0	int
;	O
*	O
pbytes	*(long)
=	O
0	int
;	O
return	O
cur_ptr	*(char)
;	O
}	O
*	O
pchars	*(long)
=	O
1	int
;	O
*	O
pbytes	*(long)
=	O
cur_len	long
;	O
*	O
delim	*(int)
=	O
*	O
cur_ptr	*(char)
;	O
text_buffer_add_char	(*(struct(*(char),long,long)),int)->(void)
(	O
rep	*(struct(*(char),long,long))
,	O
' '	O
)	O
;	O
return	O
cur_ptr	*(char)
;	O
}	O
else	O
if	O
(	O
ansi_escape	(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))),*(long))->(int)
(	O
*	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
,	O
&	O
cur_len	long
)	O
)	O
{	O
*	O
pchars	*(long)
=	O
0	int
;	O
*	O
pbytes	*(long)
=	O
cur_len	long
;	O
ITER_SETBYTES	O
(	O
*	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
,	O
cur_len	long
)	O
;	O
return	O
cur_ptr	*(char)
;	O
}	O
else	O
if	O
(	O
*	O
cur_ptr	*(char)
==	O
'\t'	O
)	O
{	O
int	O
i	int
=	O
0	int
;	O
*	O
pchars	*(long)
=	O
(	O
(	O
pl_chars	long
+	O
8	int
)	O
&	O
0xf8	int
)	O
-	O
pl_chars	long
;	O
*	O
pbytes	*(long)
=	O
*	O
pchars	*(long)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
*	O
pbytes	*(long)
;	O
i	int
++	O
)	O
text_buffer_add_char	(*(struct(*(char),long,long)),int)->(void)
(	O
rep	*(struct(*(char),long,long))
,	O
' '	O
)	O
;	O
return	O
text_buffer_base	O
(	O
rep	*(struct(*(char),long,long))
)	O
;	O
}	O
}	O
if	O
(	O
iscntrl	(int)->(int)
(	O
*	O
cur_ptr	*(char)
)	O
&&	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
cur_ptr	*(char)
<	O
127	int
)	O
{	O
*	O
pchars	*(long)
=	O
2	int
;	O
*	O
pbytes	*(long)
=	O
2	int
;	O
text_buffer_add_char	(*(struct(*(char),long,long)),int)->(void)
(	O
rep	*(struct(*(char),long,long))
,	O
'^'	O
)	O
;	O
text_buffer_add_char	(*(struct(*(char),long,long)),int)->(void)
(	O
rep	*(struct(*(char),long,long))
,	O
*	O
cur_ptr	*(char)
|	O
0x40	int
)	O
;	O
return	O
text_buffer_base	O
(	O
rep	*(struct(*(char),long,long))
)	O
;	O
}	O
else	O
if	O
(	O
*	O
cur_ptr	*(char)
==	O
DEL	char
)	O
{	O
*	O
pchars	*(long)
=	O
0	int
;	O
*	O
pbytes	*(long)
=	O
0	int
;	O
return	O
text_buffer_base	O
(	O
rep	*(struct(*(char),long,long))
)	O
;	O
}	O
else	O
{	O
*	O
pchars	*(long)
=	O
4	int
;	O
*	O
pbytes	*(long)
=	O
4	int
;	O
text_buffer_printf	(*(struct(*(char),long,long)),*(char))->(long)
(	O
rep	*(struct(*(char),long,long))
,	O
"\\%o"	*(char)
,	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
cur_ptr	*(char)
)	O
;	O
return	O
text_buffer_base	O
(	O
rep	*(struct(*(char),long,long))
)	O
;	O
}	O
}	O
int	O
preprocess_nodes_p	int
;	O
static	O
int	O
rewrite_p	int
;	O
static	O
char	O
*	O
inptr	*(char)
;	O
static	O
char	O
*	O
input_start	*(char)
;	O
static	O
size_t	long
input_length	long
;	O
struct	O
text_buffer	struct(*(char),long,long)
output_buf	struct(*(char),long,long)
;	O
static	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
*	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
;	O
static	O
int	O
node_offset	int
;	O
static	O
long	O
int	O
output_bytes_difference	long
;	O
static	O
int	O
convert_encoding_p	int
;	O
static	O
int	O
file_is_in_utf8	int
;	O
static	O
iconv_t	*(void)
iconv_to_output	*(void)
;	O
static	O
iconv_t	*(void)
iconv_to_utf8	*(void)
;	O
void	O
init_conversion	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
{	O
char	O
*	O
target_encoding	*(char)
;	O
convert_encoding_p	int
=	O
0	int
;	O
if	O
(	O
!	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
return	O
;	O
file_is_in_utf8	int
=	O
0	int
;	O
if	O
(	O
!	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
encoding	*(char)
)	O
return	O
;	O
target_encoding	*(char)
=	O
nl_langinfo	(int)->(*(char))
(	O
CODESET	int
)	O
;	O
if	O
(	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
target_encoding	*(char)
,	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
encoding	*(char)
)	O
)	O
return	O
;	O
iconv_to_output	*(void)
=	O
iconv_open	(*(char),*(char))->(*(void))
(	O
target_encoding	*(char)
,	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
encoding	*(char)
)	O
;	O
if	O
(	O
iconv_to_output	*(void)
==	O
(	O
iconv_t	*(void)
)	O
-	O
1	int
)	O
return	O
;	O
if	O
(	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
"UTF8"	*(char)
,	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
encoding	*(char)
)	O
||	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
"UTF-8"	*(char)
,	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
encoding	*(char)
)	O
)	O
file_is_in_utf8	int
=	O
1	int
;	O
if	O
(	O
!	O
file_is_in_utf8	int
)	O
{	O
iconv_to_utf8	*(void)
=	O
iconv_open	(*(char),*(char))->(*(void))
(	O
"UTF-8"	*(char)
,	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
encoding	*(char)
)	O
;	O
if	O
(	O
iconv_to_utf8	*(void)
==	O
(	O
iconv_t	*(void)
)	O
-	O
1	int
)	O
{	O
iconv_close	(*(void))->(int)
(	O
iconv_to_output	*(void)
)	O
;	O
return	O
;	O
}	O
}	O
convert_encoding_p	int
=	O
1	int
;	O
rewrite_p	int
=	O
1	int
;	O
}	O
void	O
close_conversion	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
convert_encoding_p	int
)	O
{	O
iconv_close	(*(void))->(int)
(	O
iconv_to_output	*(void)
)	O
;	O
if	O
(	O
!	O
file_is_in_utf8	int
)	O
iconv_close	(*(void))->(int)
(	O
iconv_to_utf8	*(void)
)	O
;	O
}	O
}	O
static	O
void	O
init_output_stream	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
{	O
init_conversion	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
output_bytes_difference	long
=	O
0	int
;	O
if	O
(	O
rewrite_p	int
)	O
text_buffer_init	(*(struct(*(char),long,long)))->(void)
(	O
&	O
output_buf	struct(*(char),long,long)
)	O
;	O
}	O
static	O
size_t	long
saved_offset	long
;	O
static	O
char	O
*	O
saved_inptr	*(char)
;	O
static	O
long	O
saved_difference	long
;	O
void	O
save_conversion_state	()->(void)
(	O
void	O
)	O
{	O
saved_offset	long
=	O
text_buffer_off	O
(	O
&	O
output_buf	struct(*(char),long,long)
)	O
;	O
saved_inptr	*(char)
=	O
inptr	*(char)
;	O
saved_difference	long
=	O
output_bytes_difference	long
;	O
}	O
void	O
reset_conversion	()->(void)
(	O
void	O
)	O
{	O
text_buffer_off	O
(	O
&	O
output_buf	struct(*(char),long,long)
)	O
=	O
saved_offset	long
;	O
inptr	*(char)
=	O
saved_inptr	*(char)
;	O
output_bytes_difference	long
=	O
saved_difference	long
;	O
}	O
static	O
void	O
copy_direct	(long)->(void)
(	O
long	O
n	long
)	O
{	O
text_buffer_add_string	(*(struct(*(char),long,long)),*(char),long)->(long)
(	O
&	O
output_buf	struct(*(char),long,long)
,	O
inptr	*(char)
,	O
n	long
)	O
;	O
inptr	*(char)
+=	O
n	long
;	O
}	O
static	O
int	O
degrade_utf8	(*(*(char)),*(long))->(int)
(	O
char	O
*	O
*	O
from	*(*(char))
,	O
size_t	long
*	O
from_left	*(long)
)	O
{	O
static	O
struct	O
encoding_replacement	struct(*(char),*(char))
{	O
char	O
*	O
from_string	*(char)
;	O
char	O
*	O
to_string	*(char)
;	O
}	O
er	array(struct(*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"\xE2\x80\x98"	*(char)
,	O
"'"	*(char)
}	O
,	O
{	O
"\xE2\x80\x99"	*(char)
,	O
"'"	*(char)
}	O
,	O
{	O
"\xE2\x80\x9C"	*(char)
,	O
"\""	*(char)
}	O
,	O
{	O
"\xE2\x80\x9D"	*(char)
,	O
"\""	*(char)
}	O
,	O
{	O
"\xC2\xA9"	*(char)
,	O
"(C)"	*(char)
}	O
,	O
{	O
"\xC2\xBB"	*(char)
,	O
">>"	*(char)
}	O
,	O
{	O
"\xE2\x86\x92"	*(char)
,	O
"->"	*(char)
}	O
,	O
{	O
"\xE2\x87\x92"	*(char)
,	O
"=>"	*(char)
}	O
,	O
{	O
"\xE2\x8A\xA3"	*(char)
,	O
"-|"	*(char)
}	O
,	O
{	O
"\xE2\x98\x85"	*(char)
,	O
"-!-"	*(char)
}	O
,	O
{	O
"\xE2\x86\xA6"	*(char)
,	O
"==>"	*(char)
}	O
,	O
{	O
"\xE2\x80\x90"	*(char)
,	O
"-"	*(char)
}	O
,	O
{	O
"\xE2\x80\x91"	*(char)
,	O
"-"	*(char)
}	O
,	O
{	O
"\xE2\x80\x92"	*(char)
,	O
"-"	*(char)
}	O
,	O
{	O
"\xE2\x80\x93"	*(char)
,	O
"-"	*(char)
}	O
,	O
{	O
"\xE2\x80\x94"	*(char)
,	O
"--"	*(char)
}	O
,	O
{	O
"\xE2\x88\x92"	*(char)
,	O
"-"	*(char)
}	O
,	O
{	O
"\xE2\x80\xA6"	*(char)
,	O
"..."	*(char)
}	O
,	O
{	O
"\xE2\x80\xA2"	*(char)
,	O
"*"	*(char)
}	O
,	O
{	O
"\xC3\xA0"	*(char)
,	O
"a`"	*(char)
}	O
,	O
{	O
"\xC3\xA2"	*(char)
,	O
"a^"	*(char)
}	O
,	O
{	O
"\xC3\xA4"	*(char)
,	O
"a\""	*(char)
}	O
,	O
{	O
"\xC3\xA6"	*(char)
,	O
"ae"	*(char)
}	O
,	O
{	O
"\xC3\xA9"	*(char)
,	O
"e'"	*(char)
}	O
,	O
{	O
"\xC3\xA8"	*(char)
,	O
"e`"	*(char)
}	O
,	O
{	O
"\xC3\xAA"	*(char)
,	O
"e^"	*(char)
}	O
,	O
{	O
"\xC3\xAB"	*(char)
,	O
"e\""	*(char)
}	O
,	O
{	O
"\xC3\xB6"	*(char)
,	O
"o\""	*(char)
}	O
,	O
{	O
"\xC3\xBC"	*(char)
,	O
"u\""	*(char)
}	O
,	O
{	O
"\xC3\x84"	*(char)
,	O
"A\""	*(char)
}	O
,	O
{	O
"\xC3\x96"	*(char)
,	O
"O\""	*(char)
}	O
,	O
{	O
"\xC3\x9c"	*(char)
,	O
"U\""	*(char)
}	O
,	O
{	O
"\xC3\xB1"	*(char)
,	O
"n~"	*(char)
}	O
,	O
{	O
"\xC3\x87"	*(char)
,	O
"C,"	*(char)
}	O
,	O
{	O
"\xC3\xA7"	*(char)
,	O
"c,"	*(char)
}	O
,	O
{	O
"\xC3\x9f"	*(char)
,	O
"ss"	*(char)
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
struct	O
encoding_replacement	struct(*(char),*(char))
*	O
erp	*(struct(*(char),*(char)))
;	O
for	O
(	O
erp	*(struct(*(char),*(char)))
=	O
er	array(struct(*(char),*(char)))
;	O
erp	*(struct(*(char),*(char)))
->	O
from_string	*(char)
!=	O
0	int
;	O
erp	*(struct(*(char),*(char)))
++	O
)	O
{	O
int	O
width	long
=	O
strlen	(*(char))->(long)
(	O
erp	*(struct(*(char),*(char)))
->	O
from_string	*(char)
)	O
;	O
if	O
(	O
width	long
>	O
*	O
from_left	*(long)
)	O
continue	O
;	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
erp	*(struct(*(char),*(char)))
->	O
from_string	*(char)
,	O
*	O
from	*(*(char))
,	O
width	long
)	O
)	O
{	O
text_buffer_add_string	(*(struct(*(char),long,long)),*(char),long)->(long)
(	O
&	O
output_buf	struct(*(char),long,long)
,	O
erp	*(struct(*(char),*(char)))
->	O
to_string	*(char)
,	O
strlen	(*(char))->(long)
(	O
erp	*(struct(*(char),*(char)))
->	O
to_string	*(char)
)	O
)	O
;	O
*	O
from	*(*(char))
+=	O
width	long
;	O
*	O
from_left	*(long)
-=	O
width	long
;	O
return	O
1	int
;	O
}	O
}	O
text_buffer_add_string	(*(struct(*(char),long,long)),*(char),long)->(long)
(	O
&	O
output_buf	struct(*(char),long,long)
,	O
"?"	*(char)
,	O
1	int
)	O
;	O
(	O
*	O
from	*(*(char))
)	O
++	O
;	O
(	O
*	O
from_left	*(long)
)	O
--	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
copy_converting	(long)->(int)
(	O
long	O
n	long
)	O
{	O
size_t	long
bytes_left	long
,	O
orig_bytes_left	long
;	O
int	O
extra_at_end	int
;	O
size_t	long
iconv_ret	long
;	O
long	O
output_start	long
;	O
size_t	long
utf8_char_free	long
;	O
char	O
utf8_char	array(char)
[	O
4	int
]	O
;	O
char	O
*	O
utf8_char_ptr	*(char)
,	O
*	O
orig_inptr	*(char)
;	O
size_t	long
i	int
;	O
text_buffer_alloc	(*(struct(*(char),long,long)),long)->(void)
(	O
&	O
output_buf	struct(*(char),long,long)
,	O
(	O
size_t	long
)	O
n	long
)	O
;	O
output_start	long
=	O
text_buffer_off	O
(	O
&	O
output_buf	struct(*(char),long,long)
)	O
;	O
bytes_left	long
=	O
n	long
;	O
extra_at_end	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
iconv_ret	long
=	O
text_buffer_iconv	(*(struct(*(char),long,long)),*(void),*(*(char)),*(long))->(long)
(	O
&	O
output_buf	struct(*(char),long,long)
,	O
iconv_to_output	*(void)
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	*(char)
,	O
&	O
bytes_left	long
)	O
;	O
if	O
(	O
iconv_ret	long
!=	O
(	O
size_t	long
)	O
-	O
1	int
&&	O
text_buffer_iconv	(*(struct(*(char),long,long)),*(void),*(*(char)),*(long))->(long)
(	O
&	O
output_buf	struct(*(char),long,long)
,	O
iconv_to_output	*(void)
,	O
NULL	O
,	O
NULL	O
)	O
!=	O
(	O
size_t	long
)	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
errno	O
)	O
{	O
case	O
E2BIG	int
:	O
text_buffer_alloc	(*(struct(*(char),long,long)),long)->(void)
(	O
&	O
output_buf	struct(*(char),long,long)
,	O
n	long
)	O
;	O
continue	O
;	O
case	O
EINVAL	int
:	O
if	O
(	O
inptr	*(char)
-	O
input_start	*(char)
+	O
(	O
bytes_left	long
-	O
1	int
)	O
<=	O
input_length	long
-	O
2	int
)	O
{	O
bytes_left	long
++	O
;	O
extra_at_end	int
++	O
;	O
}	O
else	O
{	O
copy_direct	(long)->(void)
(	O
bytes_left	long
)	O
;	O
bytes_left	long
=	O
0	int
;	O
}	O
continue	O
;	O
default	O
:	O
info_error	(*(char))->(void)
(	O
_	O
(	O
"Error converting file character encoding"	*(char)
)	O
)	O
;	O
inptr	*(char)
+=	O
bytes_left	long
;	O
return	O
0	int
;	O
case	O
EILSEQ	int
:	O
break	O
;	O
}	O
text_buffer_iconv	(*(struct(*(char),long,long)),*(void),*(*(char)),*(long))->(long)
(	O
&	O
output_buf	struct(*(char),long,long)
,	O
iconv_to_output	*(void)
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
file_is_in_utf8	int
)	O
{	O
degrade_utf8	(*(*(char)),*(long))->(int)
(	O
&	O
inptr	*(char)
,	O
&	O
bytes_left	long
)	O
;	O
continue	O
;	O
}	O
utf8_char_ptr	*(char)
=	O
utf8_char	array(char)
;	O
orig_inptr	*(char)
=	O
inptr	*(char)
;	O
orig_bytes_left	long
=	O
bytes_left	long
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
4	int
;	O
i	int
++	O
)	O
{	O
utf8_char_free	long
=	O
i	int
;	O
errno	O
=	O
0	int
;	O
iconv_ret	long
=	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
iconv_to_utf8	*(void)
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	*(char)
,	O
&	O
bytes_left	long
,	O
&	O
utf8_char_ptr	*(char)
,	O
&	O
utf8_char_free	long
)	O
;	O
if	O
(	O
(	O
iconv_ret	long
==	O
(	O
size_t	long
)	O
-	O
1	int
&&	O
errno	O
!=	O
E2BIG	int
)	O
||	O
utf8_char_ptr	*(char)
>	O
utf8_char	array(char)
)	O
break	O
;	O
}	O
if	O
(	O
iconv_ret	long
==	O
(	O
size_t	long
)	O
-	O
1	int
&&	O
errno	O
!=	O
E2BIG	int
)	O
{	O
inptr	*(char)
=	O
orig_inptr	*(char)
;	O
copy_direct	(long)->(void)
(	O
1	int
)	O
;	O
bytes_left	long
=	O
orig_bytes_left	long
-	O
1	int
;	O
}	O
else	O
{	O
utf8_char_ptr	*(char)
=	O
utf8_char	array(char)
;	O
degrade_utf8	(*(*(char)),*(long))->(int)
(	O
&	O
utf8_char_ptr	*(char)
,	O
&	O
i	int
)	O
;	O
if	O
(	O
bytes_left	long
<=	O
0	int
)	O
{	O
utf8_char_ptr	*(char)
=	O
utf8_char	array(char)
;	O
i	int
=	O
4	int
;	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
iconv_to_utf8	*(void)
,	O
NULL	O
,	O
NULL	O
,	O
&	O
utf8_char_ptr	*(char)
,	O
&	O
utf8_char_free	long
)	O
;	O
if	O
(	O
utf8_char_ptr	*(char)
>	O
utf8_char	array(char)
)	O
{	O
utf8_char_ptr	*(char)
=	O
utf8_char	array(char)
;	O
degrade_utf8	(*(*(char)),*(long))->(int)
(	O
&	O
utf8_char_ptr	*(char)
,	O
&	O
i	int
)	O
;	O
}	O
}	O
}	O
}	O
output_bytes_difference	long
+=	O
n	long
-	O
(	O
(	O
signed	O
long	O
)	O
text_buffer_off	O
(	O
&	O
output_buf	struct(*(char),long,long)
)	O
-	O
output_start	long
)	O
;	O
return	O
extra_at_end	int
;	O
}	O
static	O
void	O
copy_input_to_output	(long)->(void)
(	O
long	O
n	long
)	O
{	O
if	O
(	O
rewrite_p	int
)	O
{	O
long	O
bytes_left	long
;	O
bytes_left	long
=	O
n	long
;	O
while	O
(	O
bytes_left	long
>	O
0	int
)	O
{	O
if	O
(	O
!	O
convert_encoding_p	int
)	O
{	O
copy_direct	(long)->(void)
(	O
bytes_left	long
)	O
;	O
bytes_left	long
=	O
0	int
;	O
}	O
else	O
{	O
long	O
bytes_to_convert	long
;	O
long	O
extra_written	long
;	O
bytes_to_convert	long
=	O
bytes_left	long
;	O
if	O
(	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
{	O
char	O
*	O
first_anchor	*(char)
=	O
input_start	*(char)
+	O
(	O
*	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
->	O
nodestart	long
-	O
node_offset	int
;	O
if	O
(	O
first_anchor	*(char)
<	O
inptr	*(char)
+	O
bytes_left	long
)	O
{	O
bytes_to_convert	long
=	O
first_anchor	*(char)
-	O
inptr	*(char)
+	O
1	int
;	O
if	O
(	O
bytes_to_convert	long
<	O
0	int
)	O
{	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
=	O
0	int
;	O
bytes_to_convert	long
=	O
bytes_left	long
;	O
}	O
}	O
}	O
extra_written	long
=	O
copy_converting	(long)->(int)
(	O
bytes_to_convert	long
)	O
;	O
bytes_left	long
-=	O
bytes_to_convert	long
+	O
extra_written	long
;	O
}	O
if	O
(	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
while	O
(	O
(	O
*	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
->	O
nodestart	long
-	O
node_offset	int
<=	O
inptr	*(char)
-	O
input_start	*(char)
)	O
{	O
(	O
*	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
->	O
nodestart_adjusted	long
=	O
(	O
*	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
->	O
nodestart	long
-	O
output_bytes_difference	long
;	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
++	O
;	O
if	O
(	O
!	O
*	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
||	O
(	O
*	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
.	O
nodelen	long
!=	O
0	int
)	O
{	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
=	O
0	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
else	O
inptr	*(char)
+=	O
n	long
;	O
}	O
static	O
void	O
skip_input	(long)->(void)
(	O
long	O
n	long
)	O
{	O
if	O
(	O
preprocess_nodes_p	int
)	O
{	O
inptr	*(char)
+=	O
n	long
;	O
output_bytes_difference	long
+=	O
n	long
;	O
}	O
else	O
if	O
(	O
rewrite_p	int
)	O
{	O
copy_input_to_output	(long)->(void)
(	O
n	long
)	O
;	O
}	O
else	O
{	O
inptr	*(char)
+=	O
n	long
;	O
}	O
}	O
static	O
void	O
write_extra_bytes_to_output	(*(char),long)->(void)
(	O
char	O
*	O
input	*(*(char))
,	O
long	O
n	long
)	O
{	O
if	O
(	O
preprocess_nodes_p	int
)	O
{	O
text_buffer_add_string	(*(struct(*(char),long,long)),*(char),long)->(long)
(	O
&	O
output_buf	struct(*(char),long,long)
,	O
input	*(*(char))
,	O
n	long
)	O
;	O
output_bytes_difference	long
-=	O
n	long
;	O
}	O
}	O
static	O
void	O
write_tag_contents	(*(char),long)->(void)
(	O
char	O
*	O
input	*(*(char))
,	O
long	O
n	long
)	O
{	O
if	O
(	O
rewrite_p	int
)	O
{	O
text_buffer_add_string	(*(struct(*(char),long,long)),*(char),long)->(long)
(	O
&	O
output_buf	struct(*(char),long,long)
,	O
input	*(*(char))
,	O
n	long
)	O
;	O
output_bytes_difference	long
-=	O
n	long
;	O
}	O
}	O
static	O
void	O
skip_tag_contents	(long)->(void)
(	O
long	O
n	long
)	O
{	O
if	O
(	O
rewrite_p	int
)	O
{	O
inptr	*(char)
+=	O
n	long
;	O
output_bytes_difference	long
+=	O
n	long
;	O
}	O
}	O
static	O
void	O
parse_top_node_line	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(void)
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
{	O
char	O
*	O
*	O
store_in	*(*(char))
=	O
0	int
;	O
char	O
*	O
nodename	*(char)
;	O
char	O
*	O
ptr	*(char)
;	O
int	O
value_length	int
;	O
if	O
(	O
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
==	O
'\n'	O
)	O
return	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
prev	*(char)
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
up	*(char)
=	O
0	int
;	O
ptr	*(char)
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
;	O
while	O
(	O
1	int
)	O
{	O
store_in	*(*(char))
=	O
0	int
;	O
ptr	*(char)
+=	O
skip_whitespace	(*(char))->(int)
(	O
ptr	*(char)
)	O
;	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(char)
,	O
INFO_FILE_LABEL	*(char)
,	O
strlen	(*(char))->(long)
(	O
INFO_FILE_LABEL	*(char)
)	O
)	O
)	O
{	O
ptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
INFO_FILE_LABEL	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(char)
,	O
INFO_NODE_LABEL	*(char)
,	O
strlen	(*(char))->(long)
(	O
INFO_NODE_LABEL	*(char)
)	O
)	O
)	O
{	O
ptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
INFO_NODE_LABEL	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(char)
,	O
INFO_PREV_LABEL	*(char)
,	O
strlen	(*(char))->(long)
(	O
INFO_PREV_LABEL	*(char)
)	O
)	O
)	O
{	O
ptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
INFO_PREV_LABEL	*(char)
)	O
;	O
store_in	*(*(char))
=	O
&	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
prev	*(char)
;	O
}	O
else	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(char)
,	O
INFO_ALTPREV_LABEL	*(char)
,	O
strlen	(*(char))->(long)
(	O
INFO_ALTPREV_LABEL	*(char)
)	O
)	O
)	O
{	O
ptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
INFO_ALTPREV_LABEL	*(char)
)	O
;	O
store_in	*(*(char))
=	O
&	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
prev	*(char)
;	O
}	O
else	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(char)
,	O
INFO_NEXT_LABEL	*(char)
,	O
strlen	(*(char))->(long)
(	O
INFO_NEXT_LABEL	*(char)
)	O
)	O
)	O
{	O
ptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
INFO_NEXT_LABEL	*(char)
)	O
;	O
store_in	*(*(char))
=	O
&	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
;	O
}	O
else	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(char)
,	O
INFO_UP_LABEL	*(char)
,	O
strlen	(*(char))->(long)
(	O
INFO_UP_LABEL	*(char)
)	O
)	O
)	O
{	O
ptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
INFO_UP_LABEL	*(char)
)	O
;	O
store_in	*(*(char))
=	O
&	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
up	*(char)
;	O
}	O
else	O
{	O
store_in	*(*(char))
=	O
0	int
;	O
}	O
ptr	*(char)
+=	O
skip_whitespace	(*(char))->(int)
(	O
ptr	*(char)
)	O
;	O
if	O
(	O
*	O
ptr	*(char)
!=	O
'('	O
)	O
value_length	int
=	O
0	int
;	O
else	O
value_length	int
=	O
read_bracketed_filename	(*(char),*(*(char)))->(int)
(	O
ptr	*(char)
,	O
0	int
)	O
;	O
value_length	int
+=	O
read_quoted_string	(*(char),*(char),int,*(*(char)))->(long)
(	O
ptr	*(char)
+	O
value_length	int
,	O
"\n\r\t,"	*(char)
,	O
1	int
,	O
&	O
nodename	*(char)
)	O
;	O
if	O
(	O
store_in	*(*(char))
)	O
{	O
*	O
store_in	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
value_length	int
+	O
1	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
store_in	*(*(char))
,	O
ptr	*(char)
,	O
value_length	int
)	O
;	O
(	O
*	O
store_in	*(*(char))
)	O
[	O
value_length	int
]	O
=	O
'\0'	O
;	O
}	O
free	(*(void))->(void)
(	O
nodename	*(char)
)	O
;	O
ptr	*(char)
+=	O
value_length	int
;	O
if	O
(	O
*	O
ptr	*(char)
==	O
'\n'	O
||	O
!	O
*	O
ptr	*(char)
)	O
break	O
;	O
ptr	*(char)
+=	O
1	int
;	O
}	O
}	O
static	O
int	O
scan_reference_marker	(*(struct(*(char),*(char),*(char),int,int,long,int)),int)->(int)
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
,	O
int	O
in_parentheses	int
)	O
{	O
if	O
(	O
!	O
preprocess_nodes_p	int
)	O
{	O
if	O
(	O
rewrite_p	int
)	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
start	int
=	O
text_buffer_off	O
(	O
&	O
output_buf	struct(*(char),long,long)
)	O
;	O
else	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
start	int
=	O
inptr	*(char)
-	O
input_start	*(char)
;	O
}	O
if	O
(	O
inptr	*(char)
[	O
0	int
]	O
==	O
'\n'	O
)	O
{	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
type	enum(int,int,int,int)
=	O
REFERENCE_MENU_ITEM	int
;	O
if	O
(	O
!	O
preprocess_nodes_p	int
)	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
start	int
++	O
;	O
}	O
else	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
type	enum(int,int,int,int)
=	O
REFERENCE_XREF	int
;	O
if	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
type	enum(int,int,int,int)
==	O
REFERENCE_MENU_ITEM	int
)	O
copy_input_to_output	(long)->(void)
(	O
strlen	(*(char))->(long)
(	O
"\n* "	*(char)
)	O
)	O
;	O
else	O
{	O
if	O
(	O
!	O
strchr	(*(char),int)->(*(char))
(	O
" \t\r\n"	*(char)
,	O
inptr	*(char)
[	O
strlen	(*(char))->(long)
(	O
"*Note"	*(char)
)	O
]	O
)	O
)	O
{	O
copy_input_to_output	(long)->(void)
(	O
strlen	(*(char))->(long)
(	O
"*Note:"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
inptr	*(char)
[	O
1	int
]	O
==	O
'N'	O
)	O
{	O
write_extra_bytes_to_output	(*(char),long)->(void)
(	O
"See"	*(char)
,	O
3	int
)	O
;	O
in_parentheses	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
in_parentheses	int
)	O
{	O
write_extra_bytes_to_output	(*(char),long)->(void)
(	O
"see"	*(char)
,	O
3	int
)	O
;	O
}	O
skip_input	(long)->(void)
(	O
strlen	(*(char))->(long)
(	O
"*Note"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
in_parentheses	int
)	O
skip_input	(long)->(void)
(	O
skip_whitespace	(*(char))->(int)
(	O
inptr	*(char)
)	O
)	O
;	O
}	O
copy_input_to_output	(long)->(void)
(	O
skip_whitespace_and_newlines	(*(char))->(int)
(	O
inptr	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
scan_reference_label	(*(struct(*(char),*(char),*(char),int,int,long,int)),int)->(int)
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
,	O
int	O
in_index	int
)	O
{	O
int	O
max_lines	int
;	O
int	O
len	long
,	O
label_len	int
=	O
0	int
;	O
if	O
(	O
inptr	*(char)
[	O
0	int
]	O
==	O
'('	O
)	O
label_len	int
=	O
read_bracketed_filename	(*(char),*(*(char)))->(int)
(	O
inptr	*(char)
,	O
&	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
)	O
;	O
if	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
type	enum(int,int,int,int)
==	O
REFERENCE_MENU_ITEM	int
)	O
max_lines	int
=	O
1	int
;	O
else	O
max_lines	int
=	O
2	int
;	O
if	O
(	O
!	O
in_index	int
||	O
inptr	*(char)
[	O
label_len	int
]	O
==	O
'\177'	O
)	O
{	O
len	long
=	O
read_quoted_string	(*(char),*(char),int,*(*(char)))->(long)
(	O
inptr	*(char)
+	O
label_len	int
,	O
":"	*(char)
,	O
max_lines	int
,	O
&	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
)	O
;	O
canonicalize_whitespace	(*(char))->(void)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
)	O
;	O
if	O
(	O
!	O
len	long
)	O
return	O
0	int
;	O
label_len	int
+=	O
len	long
;	O
}	O
else	O
{	O
char	O
*	O
p	*(void)
;	O
int	O
n	long
,	O
m	int
=	O
0	int
;	O
p	*(void)
=	O
inptr	*(char)
+	O
label_len	int
;	O
while	O
(	O
1	int
)	O
{	O
n	long
=	O
strcspn	(*(char),*(char))->(long)
(	O
p	*(void)
,	O
":\n\177"	*(char)
)	O
;	O
if	O
(	O
p	*(void)
[	O
n	long
]	O
==	O
':'	O
)	O
{	O
m	int
+=	O
n	long
+	O
1	int
;	O
p	*(void)
+=	O
n	long
+	O
1	int
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
m	int
==	O
0	int
)	O
return	O
0	int
;	O
label_len	int
+=	O
m	int
-	O
1	int
;	O
}	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
label_len	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
,	O
inptr	*(char)
,	O
label_len	int
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
[	O
label_len	int
]	O
=	O
'\0'	O
;	O
canonicalize_whitespace	(*(char))->(void)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
)	O
;	O
if	O
(	O
preprocess_nodes_p	int
)	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
start	int
=	O
text_buffer_off	O
(	O
&	O
output_buf	struct(*(char),long,long)
)	O
;	O
copy_input_to_output	(long)->(void)
(	O
label_len	int
)	O
;	O
if	O
(	O
rewrite_p	int
)	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
end	int
=	O
text_buffer_off	O
(	O
&	O
output_buf	struct(*(char),long,long)
)	O
;	O
else	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
end	int
=	O
inptr	*(char)
-	O
input_start	*(char)
;	O
skip_input	(long)->(void)
(	O
1	int
)	O
;	O
if	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
type	enum(int,int,int,int)
==	O
REFERENCE_MENU_ITEM	int
)	O
write_extra_bytes_to_output	(*(char),long)->(void)
(	O
" "	*(char)
,	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
scan_reference_target	(*(struct(*(char),*(char),*(char),int,int,long,int)),*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),int)->(int)
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
,	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
int	O
in_parentheses	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
type	enum(int,int,int,int)
==	O
REFERENCE_XREF	int
)	O
{	O
int	O
length	int
=	O
0	int
;	O
char	O
*	O
target_start	*(char)
=	O
inptr	*(char)
;	O
char	O
*	O
nl_off	*(char)
=	O
0	int
;	O
int	O
space_at_start_of_line	int
=	O
0	int
;	O
length	int
+=	O
skip_whitespace_and_newlines	(*(char))->(int)
(	O
inptr	*(char)
)	O
;	O
length	int
+=	O
read_bracketed_filename	(*(char),*(*(char)))->(int)
(	O
inptr	*(char)
+	O
length	int
,	O
&	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
)	O
;	O
length	int
+=	O
skip_whitespace_and_newlines	(*(char))->(int)
(	O
inptr	*(char)
+	O
length	int
)	O
;	O
length	int
+=	O
read_quoted_string	(*(char),*(char),int,*(*(char)))->(long)
(	O
inptr	*(char)
+	O
length	int
,	O
",."	*(char)
,	O
2	int
,	O
&	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
)	O
;	O
skip_input	(long)->(void)
(	O
length	int
)	O
;	O
nl_off	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
target_start	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
nl_off	*(char)
)	O
{	O
if	O
(	O
nl_off	*(char)
<	O
inptr	*(char)
)	O
space_at_start_of_line	int
=	O
skip_whitespace	(*(char))->(int)
(	O
nl_off	*(char)
+	O
1	int
)	O
;	O
else	O
nl_off	*(char)
=	O
0	int
;	O
}	O
canonicalize_whitespace	(*(char))->(void)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
)	O
;	O
if	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
)	O
{	O
if	O
(	O
nl_off	*(char)
&&	O
nl_off	*(char)
<	O
target_start	*(char)
+	O
(	O
length	int
-	O
space_at_start_of_line	int
)	O
/	O
2	int
)	O
{	O
int	O
i	int
;	O
write_extra_bytes_to_output	(*(char),long)->(void)
(	O
"\n"	*(char)
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
space_at_start_of_line	int
;	O
i	int
++	O
)	O
write_extra_bytes_to_output	(*(char),long)->(void)
(	O
" "	*(char)
,	O
1	int
)	O
;	O
skip_input	(long)->(void)
(	O
strspn	(*(char),*(char))->(long)
(	O
inptr	*(char)
,	O
" "	*(char)
)	O
)	O
;	O
nl_off	*(char)
=	O
0	int
;	O
}	O
else	O
if	O
(	O
*	O
inptr	*(char)
!=	O
'\n'	O
)	O
{	O
write_extra_bytes_to_output	(*(char),long)->(void)
(	O
" "	*(char)
,	O
1	int
)	O
;	O
}	O
write_extra_bytes_to_output	(*(char),long)->(void)
(	O
"("	*(char)
,	O
1	int
)	O
;	O
write_extra_bytes_to_output	(*(char),long)->(void)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
,	O
strlen	(*(char))->(long)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
)	O
)	O
;	O
write_extra_bytes_to_output	(*(char),long)->(void)
(	O
" manual)"	*(char)
,	O
strlen	(*(char))->(long)
(	O
" manual)"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
in_parentheses	int
&&	O
inptr	*(char)
[	O
0	int
]	O
==	O
'.'	O
)	O
skip_input	(long)->(void)
(	O
1	int
)	O
;	O
copy_input_to_output	(long)->(void)
(	O
strspn	(*(char),*(char))->(long)
(	O
inptr	*(char)
,	O
".),"	*(char)
)	O
)	O
;	O
if	O
(	O
nl_off	*(char)
&&	O
*	O
inptr	*(char)
!=	O
'\n'	O
)	O
{	O
int	O
i	int
;	O
write_extra_bytes_to_output	(*(char),long)->(void)
(	O
"\n"	*(char)
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
space_at_start_of_line	int
;	O
i	int
++	O
)	O
write_extra_bytes_to_output	(*(char),long)->(void)
(	O
" "	*(char)
,	O
1	int
)	O
;	O
skip_input	(long)->(void)
(	O
strspn	(*(char),*(char))->(long)
(	O
inptr	*(char)
,	O
" "	*(char)
)	O
)	O
;	O
}	O
}	O
else	O
{	O
int	O
line_len	int
;	O
int	O
length	int
=	O
0	int
;	O
length	int
=	O
skip_whitespace	(*(char))->(int)
(	O
inptr	*(char)
)	O
;	O
length	int
+=	O
read_bracketed_filename	(*(char),*(*(char)))->(int)
(	O
inptr	*(char)
+	O
length	int
,	O
&	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
)	O
;	O
length	int
+=	O
strspn	(*(char),*(char))->(long)
(	O
inptr	*(char)
+	O
length	int
,	O
" "	*(char)
)	O
;	O
length	int
+=	O
read_quoted_string	(*(char),*(char),int,*(*(char)))->(long)
(	O
inptr	*(char)
+	O
length	int
,	O
",.\t\n"	*(char)
,	O
2	int
,	O
&	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
)	O
;	O
if	O
(	O
inptr	*(char)
[	O
length	int
]	O
==	O
'.'	O
)	O
length	int
++	O
;	O
if	O
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
flags	int
&	O
N_IsDir	int
)	O
{	O
char	O
*	O
linestart	*(char)
;	O
linestart	*(char)
=	O
memrchr	(*(void),int,long)->(*(void))
(	O
input_start	*(char)
,	O
'\n'	O
,	O
inptr	*(char)
-	O
input_start	*(char)
)	O
;	O
if	O
(	O
!	O
linestart	*(char)
)	O
linestart	*(char)
=	O
input_start	*(char)
;	O
else	O
linestart	*(char)
++	O
;	O
line_len	int
=	O
inptr	*(char)
-	O
linestart	*(char)
;	O
}	O
if	O
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
flags	int
&	O
N_IsIndex	int
)	O
copy_input_to_output	(long)->(void)
(	O
length	int
)	O
;	O
else	O
{	O
skip_input	(long)->(void)
(	O
length	int
)	O
;	O
if	O
(	O
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
flags	int
&	O
N_IsDir	int
)	O
&&	O
inptr	*(char)
[	O
strspn	(*(char),*(char))->(long)
(	O
inptr	*(char)
,	O
" "	*(char)
)	O
]	O
==	O
'\n'	O
)	O
{	O
skip_input	(long)->(void)
(	O
strspn	(*(char),*(char))->(long)
(	O
inptr	*(char)
,	O
" "	*(char)
)	O
)	O
;	O
if	O
(	O
line_len	int
<=	O
strspn	(*(char),*(char))->(long)
(	O
inptr	*(char)
+	O
1	int
,	O
" "	*(char)
)	O
)	O
skip_input	(long)->(void)
(	O
1	int
+	O
line_len	int
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
write_extra_bytes_to_output	(*(char),long)->(void)
(	O
" "	*(char)
,	O
1	int
)	O
;	O
}	O
}	O
{	O
char	O
*	O
lineptr	*(char)
=	O
inptr	*(char)
;	O
lineptr	*(char)
+=	O
skip_whitespace	(*(char))->(int)
(	O
inptr	*(char)
)	O
;	O
if	O
(	O
*	O
lineptr	*(char)
==	O
'\n'	O
)	O
lineptr	*(char)
+=	O
1	int
+	O
skip_whitespace	(*(char))->(int)
(	O
lineptr	*(char)
+	O
1	int
)	O
;	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
lineptr	*(char)
,	O
"(line "	*(char)
,	O
strlen	(*(char))->(long)
(	O
"(line "	*(char)
)	O
)	O
)	O
{	O
lineptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
"(line "	*(char)
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
line_number	long
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
lineptr	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
}	O
else	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
line_number	long
=	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
char	O
safe_string_index	(*(char),long,*(char),long)->(char)
(	O
char	O
*	O
ptr	*(char)
,	O
long	O
index	(*(char),int)->(*(char))
,	O
char	O
*	O
base	*(char)
,	O
long	O
len	long
)	O
{	O
long	O
offset	long
=	O
ptr	*(char)
-	O
base	*(char)
;	O
if	O
(	O
offset	long
+	O
index	(*(char),int)->(*(char))
<	O
0	int
||	O
offset	long
+	O
index	(*(char),int)->(*(char))
>=	O
len	long
)	O
return	O
0	int
;	O
return	O
ptr	*(char)
[	O
index	(*(char),int)->(*(char))
]	O
;	O
}	O
static	O
void	O
scan_info_tag	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),*(int),*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
int	O
*	O
in_index	int
,	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
{	O
char	O
*	O
p	*(void)
,	O
*	O
p1	*(char)
;	O
struct	O
text_buffer	struct(*(char),long,long)
*	O
expansion	*(struct(*(char),long,long))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
text_buffer	struct(*(char),long,long)
)	O
)	O
;	O
p	*(void)
=	O
inptr	*(char)
;	O
p1	*(char)
=	O
p	*(void)
;	O
text_buffer_init	(*(struct(*(char),long,long)))->(void)
(	O
expansion	*(struct(*(char),long,long))
)	O
;	O
if	O
(	O
tag_expand	(*(*(char)),*(char),*(struct(*(char),long,long)),*(int))->(int)
(	O
&	O
p1	*(char)
,	O
input_start	*(char)
+	O
input_length	long
,	O
expansion	*(struct(*(char),long,long))
,	O
in_index	int
)	O
)	O
{	O
if	O
(	O
*	O
in_index	int
)	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
flags	int
|=	O
N_IsIndex	int
;	O
if	O
(	O
!	O
rewrite_p	int
)	O
{	O
rewrite_p	int
=	O
1	int
;	O
init_output_stream	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
inptr	*(char)
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
;	O
}	O
copy_input_to_output	(long)->(void)
(	O
p	*(void)
-	O
inptr	*(char)
)	O
;	O
write_tag_contents	(*(char),long)->(void)
(	O
text_buffer_base	O
(	O
expansion	*(struct(*(char),long,long))
)	O
,	O
text_buffer_off	O
(	O
expansion	*(struct(*(char),long,long))
)	O
)	O
;	O
skip_tag_contents	(long)->(void)
(	O
p1	*(char)
-	O
inptr	*(char)
)	O
;	O
}	O
else	O
{	O
copy_input_to_output	(long)->(void)
(	O
p	*(void)
-	O
inptr	*(char)
+	O
1	int
)	O
;	O
}	O
text_buffer_free	(*(struct(*(char),long,long)))->(void)
(	O
expansion	*(struct(*(char),long,long))
)	O
;	O
free	(*(void))->(void)
(	O
expansion	*(struct(*(char),long,long))
)	O
;	O
}	O
static	O
char	O
*	O
forward_to_info_syntax	(*(char))->(*(char))
(	O
char	O
*	O
contents	*(char)
)	O
{	O
while	O
(	O
contents	*(char)
<	O
input_start	*(char)
+	O
input_length	long
-	O
3	int
)	O
{	O
if	O
(	O
looking_at_string	O
(	O
contents	*(char)
,	O
INFO_MENU_ENTRY_LABEL	*(char)
)	O
||	O
looking_at_string	O
(	O
contents	*(char)
,	O
INFO_XREF_LABEL	*(char)
)	O
||	O
!	O
memcmp	(*(void),*(void),long)->(int)
(	O
contents	*(char)
,	O
"\0\b["	*(char)
,	O
3	int
)	O
)	O
return	O
contents	*(char)
;	O
contents	*(char)
++	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
scan_node_contents	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))))->(void)
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
*	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
{	O
int	O
in_menu	int
=	O
0	int
;	O
char	O
*	O
match	*(char)
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
refs	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
=	O
NULL	O
;	O
size_t	long
refs_index	long
=	O
0	int
,	O
refs_slots	long
=	O
0	int
;	O
int	O
in_index	int
=	O
0	int
;	O
rewrite_p	int
=	O
preprocess_nodes_p	int
;	O
init_output_stream	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
if	O
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
{	O
char	O
*	O
file_contents	*(char)
;	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
=	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
+	O
1	int
;	O
if	O
(	O
!	O
*	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
=	O
0	int
;	O
else	O
if	O
(	O
*	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
&&	O
(	O
*	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
.	O
nodelen	long
!=	O
0	int
)	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
=	O
0	int
;	O
if	O
(	O
!	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
subfile	*(char)
)	O
file_contents	*(char)
=	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
;	O
else	O
{	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
f	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
info_find_subfile	(*(char))->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
subfile	*(char)
)	O
;	O
if	O
(	O
!	O
f	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
return	O
;	O
file_contents	*(char)
=	O
f	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
;	O
}	O
node_offset	int
=	O
(	O
*	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
->	O
nodestart	long
+	O
skip_node_separator	(*(char))->(int)
(	O
file_contents	*(char)
+	O
(	O
*	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
->	O
nodestart	long
)	O
;	O
}	O
else	O
anchor_to_adjust	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
=	O
0	int
;	O
refs	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
*	O
refs	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
;	O
refs_slots	long
=	O
1	int
;	O
parse_top_node_line	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(void)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
;	O
inptr	*(char)
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
;	O
input_start	*(char)
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
;	O
input_length	long
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
;	O
while	O
(	O
(	O
match	*(char)
=	O
forward_to_info_syntax	(*(char))->(*(char))
(	O
inptr	*(char)
)	O
)	O
&&	O
match	*(char)
<	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
+	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
)	O
{	O
int	O
in_parentheses	int
=	O
0	int
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
copy_input_to_output	(long)->(void)
(	O
match	*(char)
-	O
inptr	*(char)
)	O
;	O
if	O
(	O
(	O
in_menu	int
&&	O
match	*(char)
[	O
0	int
]	O
==	O
'\n'	O
)	O
||	O
match	*(char)
[	O
0	int
]	O
==	O
'*'	O
)	O
{	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
info_new_reference	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
safe_string_index	(*(char),long,*(char),long)->(char)
(	O
inptr	*(char)
,	O
-	O
1	int
,	O
input_start	*(char)
,	O
input_length	long
)	O
==	O
'('	O
&&	O
safe_string_index	(*(char),long,*(char),long)->(char)
(	O
inptr	*(char)
,	O
1	int
,	O
input_start	*(char)
,	O
input_length	long
)	O
==	O
'n'	O
)	O
in_parentheses	int
=	O
1	int
;	O
save_conversion_state	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
scan_reference_marker	(*(struct(*(char),*(char),*(char),int,int,long,int)),int)->(int)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
,	O
in_parentheses	int
)	O
)	O
goto	O
not_a_reference	O
;	O
if	O
(	O
!	O
scan_reference_label	(*(struct(*(char),*(char),*(char),int,int,long,int)),int)->(int)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
,	O
in_index	int
)	O
)	O
goto	O
not_a_reference	O
;	O
if	O
(	O
*	O
inptr	*(char)
==	O
':'	O
)	O
{	O
int	O
label_len	int
;	O
skip_input	(long)->(void)
(	O
1	int
)	O
;	O
if	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
type	enum(int,int,int,int)
==	O
REFERENCE_MENU_ITEM	int
)	O
write_extra_bytes_to_output	(*(char),long)->(void)
(	O
" "	*(char)
,	O
1	int
)	O
;	O
label_len	int
=	O
strlen	(*(char))->(long)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
)	O
;	O
if	O
(	O
label_len	int
>=	O
2	int
&&	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
[	O
label_len	int
-	O
1	int
]	O
==	O
0177	int
)	O
{	O
char	O
*	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
,	O
'\177'	O
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
,	O
p	*(void)
+	O
1	int
,	O
label_len	int
-	O
(	O
p	*(void)
-	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
)	O
-	O
1	int
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
[	O
label_len	int
-	O
2	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
else	O
{	O
free	(*(void))->(void)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
=	O
0	int
;	O
free	(*(void))->(void)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
=	O
0	int
;	O
if	O
(	O
!	O
scan_reference_target	(*(struct(*(char),*(char),*(char),int,int,long,int)),*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),int)->(int)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
,	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
in_parentheses	int
)	O
)	O
goto	O
not_a_reference	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
char	O
*	O
cur_inptr	*(char)
;	O
not_a_reference	O
:	O
cur_inptr	*(char)
=	O
inptr	*(char)
;	O
reset_conversion	()->(void)
(	O
)	O
;	O
copy_input_to_output	(long)->(void)
(	O
cur_inptr	*(char)
-	O
inptr	*(char)
)	O
;	O
info_reference_free	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(void)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
;	O
continue	O
;	O
}	O
add_pointer_to_array	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
,	O
refs_index	long
,	O
refs	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
refs_slots	long
,	O
50	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
in_menu	int
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
match	*(char)
,	O
INFO_MENU_LABEL	*(char)
,	O
strlen	(*(char))->(long)
(	O
INFO_MENU_LABEL	*(char)
)	O
)	O
)	O
{	O
in_menu	int
=	O
1	int
;	O
skip_input	(long)->(void)
(	O
strlen	(*(char))->(long)
(	O
"\n* Menu:"	*(char)
)	O
)	O
;	O
if	O
(	O
*	O
inptr	*(char)
==	O
'\n'	O
)	O
skip_input	(long)->(void)
(	O
strspn	(*(char),*(char))->(long)
(	O
inptr	*(char)
,	O
"\n"	*(char)
)	O
-	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
match	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
scan_info_tag	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),*(int),*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
&	O
in_index	int
,	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
}	O
else	O
copy_input_to_output	(long)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
inptr	*(char)
<	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
+	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
)	O
copy_input_to_output	(long)->(void)
(	O
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
+	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
)	O
-	O
inptr	*(char)
)	O
;	O
if	O
(	O
rewrite_p	int
)	O
text_buffer_add_string	(*(struct(*(char),long,long)),*(char),long)->(long)
(	O
&	O
output_buf	struct(*(char),long,long)
,	O
"\0"	*(char)
,	O
1	int
)	O
;	O
close_conversion	()->(void)
(	O
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
references	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
=	O
refs	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
;	O
if	O
(	O
rewrite_p	int
)	O
{	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
=	O
text_buffer_base	O
(	O
&	O
output_buf	struct(*(char),long,long)
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
flags	int
|=	O
N_WasRewritten	int
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
=	O
text_buffer_off	O
(	O
&	O
output_buf	struct(*(char),long,long)
)	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
&&	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
{	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
++	O
;	O
while	O
(	O
*	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
&&	O
(	O
*	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
.	O
nodelen	long
==	O
0	int
)	O
{	O
(	O
*	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
->	O
nodestart_adjusted	long
=	O
(	O
*	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
->	O
nodestart	long
-	O
output_bytes_difference	long
;	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
++	O
;	O
}	O
}	O
}	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer_of_window	(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)))->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
WINDOW	struct(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),long,long,struct(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*(struct`),long,long))),long,long)
*	O
window	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
)	O
{	O
if	O
(	O
!	O
window	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
->	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
return	O
NULL	O
;	O
if	O
(	O
window	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
->	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
)	O
return	O
info_find_file	(*(char))->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
window	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
->	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
char	O
*	O
node_printed_rep	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(*(char))
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
{	O
static	O
char	O
*	O
rep	*(struct(*(char),long,long))
;	O
if	O
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
)	O
{	O
char	O
*	O
filename	*(char)
=	O
filename_non_directory	(*(char))->(*(char))
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
)	O
;	O
rep	*(struct(*(char),long,long))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
rep	*(struct(*(char),long,long))
,	O
1	int
+	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
+	O
1	int
+	O
strlen	(*(char))->(long)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodename	*(char)
)	O
+	O
1	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
rep	*(struct(*(char),long,long))
,	O
"(%s)%s"	*(char)
,	O
filename	*(char)
,	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodename	*(char)
)	O
;	O
return	O
rep	*(struct(*(char),long,long))
;	O
}	O
else	O
return	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodename	*(char)
;	O
}	O
char	O
*	O
filename_non_directory	(*(char))->(*(char))
(	O
char	O
*	O
pathname	*(char)
)	O
{	O
register	O
char	O
*	O
filename	*(char)
=	O
pathname	*(char)
+	O
strlen	(*(char))->(long)
(	O
pathname	*(char)
)	O
;	O
if	O
(	O
HAVE_DRIVE	O
(	O
pathname	*(char)
)	O
)	O
pathname	*(char)
+=	O
2	int
;	O
while	O
(	O
filename	*(char)
>	O
pathname	*(char)
&&	O
!	O
IS_SLASH	O
(	O
filename	*(char)
[	O
-	O
1	int
]	O
)	O
)	O
filename	*(char)
--	O
;	O
return	O
filename	*(char)
;	O
}	O
int	O
internal_info_node_p	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(int)
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
{	O
return	O
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
!=	O
NULL	O
)	O
&&	O
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
flags	int
&	O
N_IsInternal	int
)	O
;	O
}	O
void	O
name_internal_node	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),*(char))->(void)
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
char	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
!	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
return	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
=	O
""	*(char)
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
subfile	*(char)
=	O
0	int
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodename	*(char)
=	O
name	*(char)
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
flags	int
|=	O
N_IsInternal	int
;	O
}	O
WINDOW	struct(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),long,long,struct(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*(struct`),long,long))),long,long)
*	O
get_internal_info_window	(*(char))->(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)))
(	O
char	O
*	O
name	*(char)
)	O
{	O
WINDOW	struct(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),long,long,struct(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*(struct`),long,long))),long,long)
*	O
win	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
;	O
for	O
(	O
win	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
=	O
windows	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
;	O
win	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
;	O
win	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
=	O
win	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
)	O
if	O
(	O
internal_info_node_p	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(int)
(	O
win	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
->	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
&&	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
win	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
->	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodename	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
)	O
break	O
;	O
return	O
win	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
;	O
}	O
void	O
text_buffer_init	(*(struct(*(char),long,long)))->(void)
(	O
struct	O
text_buffer	struct(*(char),long,long)
*	O
buf	array(char)
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
buf	array(char)
,	O
0	int
,	O
sizeof	O
*	O
buf	array(char)
)	O
;	O
}	O
void	O
text_buffer_free	(*(struct(*(char),long,long)))->(void)
(	O
struct	O
text_buffer	struct(*(char),long,long)
*	O
buf	array(char)
)	O
{	O
free	(*(void))->(void)
(	O
buf	array(char)
->	O
base	*(char)
)	O
;	O
}	O
size_t	long
text_buffer_vprintf	(*(struct(*(char),long,long)),*(char),array(struct(int,int,*(void),*(void))))->(long)
(	O
struct	O
text_buffer	struct(*(char),long,long)
*	O
buf	array(char)
,	O
const	O
char	O
*	O
format	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
)	O
{	O
ssize_t	long
n	long
;	O
va_list	array(struct(int,int,*(void),*(void)))
ap_copy	array(struct(int,int,*(void),*(void)))
;	O
if	O
(	O
!	O
buf	array(char)
->	O
base	*(char)
)	O
{	O
if	O
(	O
buf	array(char)
->	O
size	long
==	O
0	int
)	O
buf	array(char)
->	O
size	long
=	O
MIN_TEXT_BUF_ALLOC	int
;	O
buf	array(char)
->	O
base	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
buf	array(char)
->	O
size	long
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
va_copy	O
(	O
ap_copy	array(struct(int,int,*(void),*(void)))
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
n	long
=	O
vsnprintf	(*(char),long,*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
buf	array(char)
->	O
base	*(char)
+	O
buf	array(char)
->	O
off	long
,	O
buf	array(char)
->	O
size	long
-	O
buf	array(char)
->	O
off	long
,	O
format	*(char)
,	O
ap_copy	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap_copy	array(struct(int,int,*(void),*(void)))
)	O
;	O
if	O
(	O
n	long
<	O
0	int
||	O
buf	array(char)
->	O
off	long
+	O
n	long
>=	O
buf	array(char)
->	O
size	long
||	O
!	O
memchr	(*(void),int,long)->(*(void))
(	O
buf	array(char)
->	O
base	*(char)
+	O
buf	array(char)
->	O
off	long
,	O
'\0'	O
,	O
buf	array(char)
->	O
size	long
-	O
buf	array(char)
->	O
off	long
+	O
1	int
)	O
)	O
{	O
size_t	long
newlen	long
=	O
buf	array(char)
->	O
size	long
*	O
2	int
;	O
if	O
(	O
newlen	long
<	O
buf	array(char)
->	O
size	long
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
buf	array(char)
->	O
size	long
=	O
newlen	long
;	O
buf	array(char)
->	O
base	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
buf	array(char)
->	O
base	*(char)
,	O
buf	array(char)
->	O
size	long
)	O
;	O
}	O
else	O
{	O
buf	array(char)
->	O
off	long
+=	O
n	long
;	O
break	O
;	O
}	O
}	O
return	O
n	long
;	O
}	O
void	O
text_buffer_alloc	(*(struct(*(char),long,long)),long)->(void)
(	O
struct	O
text_buffer	struct(*(char),long,long)
*	O
buf	array(char)
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
buf	array(char)
->	O
off	long
+	O
len	long
>	O
buf	array(char)
->	O
size	long
)	O
{	O
buf	array(char)
->	O
size	long
=	O
buf	array(char)
->	O
off	long
+	O
len	long
;	O
if	O
(	O
buf	array(char)
->	O
size	long
<	O
MIN_TEXT_BUF_ALLOC	int
)	O
buf	array(char)
->	O
size	long
=	O
MIN_TEXT_BUF_ALLOC	int
;	O
buf	array(char)
->	O
base	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
buf	array(char)
->	O
base	*(char)
,	O
buf	array(char)
->	O
size	long
)	O
;	O
}	O
}	O
size_t	long
text_buffer_space_left	(*(struct(*(char),long,long)))->(long)
(	O
struct	O
text_buffer	struct(*(char),long,long)
*	O
buf	array(char)
)	O
{	O
return	O
buf	array(char)
->	O
size	long
-	O
buf	array(char)
->	O
off	long
;	O
}	O
size_t	long
text_buffer_iconv	(*(struct(*(char),long,long)),*(void),*(*(char)),*(long))->(long)
(	O
struct	O
text_buffer	struct(*(char),long,long)
*	O
buf	array(char)
,	O
iconv_t	*(void)
iconv_state	*(void)
,	O
ICONV_CONST	O
char	O
*	O
*	O
inbuf	*(*(char))
,	O
size_t	long
*	O
inbytesleft	*(long)
)	O
{	O
size_t	long
out_bytes_left	long
;	O
char	O
*	O
outptr	*(char)
;	O
size_t	long
iconv_ret	long
;	O
outptr	*(char)
=	O
text_buffer_base	O
(	O
buf	array(char)
)	O
+	O
text_buffer_off	O
(	O
buf	array(char)
)	O
;	O
out_bytes_left	long
=	O
text_buffer_space_left	(*(struct(*(char),long,long)))->(long)
(	O
buf	array(char)
)	O
;	O
iconv_ret	long
=	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
iconv_state	*(void)
,	O
inbuf	*(*(char))
,	O
inbytesleft	*(long)
,	O
&	O
outptr	*(char)
,	O
&	O
out_bytes_left	long
)	O
;	O
text_buffer_off	O
(	O
buf	array(char)
)	O
=	O
outptr	*(char)
-	O
text_buffer_base	O
(	O
buf	array(char)
)	O
;	O
return	O
iconv_ret	long
;	O
}	O
size_t	long
text_buffer_add_string	(*(struct(*(char),long,long)),*(char),long)->(long)
(	O
struct	O
text_buffer	struct(*(char),long,long)
*	O
buf	array(char)
,	O
const	O
char	O
*	O
str	*(char)
,	O
size_t	long
len	long
)	O
{	O
text_buffer_alloc	(*(struct(*(char),long,long)),long)->(void)
(	O
buf	array(char)
,	O
len	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	array(char)
->	O
base	*(char)
+	O
buf	array(char)
->	O
off	long
,	O
str	*(char)
,	O
len	long
)	O
;	O
buf	array(char)
->	O
off	long
+=	O
len	long
;	O
return	O
len	long
;	O
}	O
size_t	long
text_buffer_fill	(*(struct(*(char),long,long)),int,long)->(long)
(	O
struct	O
text_buffer	struct(*(char),long,long)
*	O
buf	array(char)
,	O
int	O
c	int
,	O
size_t	long
len	long
)	O
{	O
char	O
*	O
p	*(void)
;	O
int	O
i	int
;	O
text_buffer_alloc	(*(struct(*(char),long,long)),long)->(void)
(	O
buf	array(char)
,	O
len	long
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
p	*(void)
=	O
buf	array(char)
->	O
base	*(char)
+	O
buf	array(char)
->	O
off	long
;	O
i	int
<	O
len	long
;	O
i	int
++	O
)	O
*	O
p	*(void)
++	O
=	O
c	int
;	O
buf	array(char)
->	O
off	long
+=	O
len	long
;	O
return	O
len	long
;	O
}	O
void	O
text_buffer_add_char	(*(struct(*(char),long,long)),int)->(void)
(	O
struct	O
text_buffer	struct(*(char),long,long)
*	O
buf	array(char)
,	O
int	O
c	int
)	O
{	O
char	O
ch	char
=	O
c	int
;	O
text_buffer_add_string	(*(struct(*(char),long,long)),*(char),long)->(long)
(	O
buf	array(char)
,	O
&	O
ch	char
,	O
1	int
)	O
;	O
}	O
size_t	long
text_buffer_printf	(*(struct(*(char),long,long)),*(char))->(long)
(	O
struct	O
text_buffer	struct(*(char),long,long)
*	O
buf	array(char)
,	O
const	O
char	O
*	O
format	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
size_t	long
n	long
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
format	*(char)
)	O
;	O
n	long
=	O
text_buffer_vprintf	(*(struct(*(char),long,long)),*(char),array(struct(int,int,*(void),*(void))))->(long)
(	O
buf	array(char)
,	O
format	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
return	O
n	long
;	O
}	O
struct	O
info_namelist_entry	struct(*(struct(*(struct(*(struct`),array(char))),array(char))),array(char))
{	O
struct	O
info_namelist_entry	struct(*(struct(*(struct(*(struct`),array(char))),array(char))),array(char))
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
;	O
char	O
name	*(char)
[	O
1	int
]	O
;	O
}	O
;	O
int	O
info_namelist_add	(*(*(struct)),*(char))->(int)
(	O
struct	O
info_namelist_entry	struct(*(struct(*(struct(*(struct`),array(char))),array(char))),array(char))
*	O
*	O
ptop	*(*(struct))
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
info_namelist_entry	struct(*(struct(*(struct(*(struct`),array(char))),array(char))),array(char))
*	O
p	*(void)
;	O
for	O
(	O
p	*(void)
=	O
*	O
ptop	*(*(struct))
;	O
p	*(void)
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
)	O
if	O
(	O
fncmp	O
(	O
p	*(void)
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
1	int
;	O
p	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
p	*(void)
)	O
+	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
->	O
name	*(char)
,	O
name	*(char)
)	O
;	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
=	O
*	O
ptop	*(*(struct))
;	O
*	O
ptop	*(*(struct))
=	O
p	*(void)
;	O
return	O
0	int
;	O
}	O
void	O
info_namelist_free	(*(struct))->(void)
(	O
struct	O
info_namelist_entry	struct(*(struct(*(struct(*(struct`),array(char))),array(char))),array(char))
*	O
top	*(struct)
)	O
{	O
while	O
(	O
top	*(struct)
)	O
{	O
struct	O
info_namelist_entry	struct(*(struct(*(struct(*(struct`),array(char))),array(char))),array(char))
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
=	O
top	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
;	O
free	(*(void))->(void)
(	O
top	*(struct)
)	O
;	O
top	*(struct)
=	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
;	O
}	O
}	O
