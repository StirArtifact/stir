struct	O
gcide_idx_cache	struct(long,int,*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))))
{	O
size_t	long
pageno	long
;	O
unsigned	O
refcount	int
;	O
struct	O
gcide_idx_page	struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))
*	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
;	O
}	O
;	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
{	O
char	O
*	O
name	*(char)
;	O
int	O
fd	int
;	O
struct	O
gcide_idx_header	struct(array(char),long,long,long,long,long)
header	struct(array(char),long,long,long,long,long)
;	O
size_t	long
cache_size	long
;	O
size_t	long
cache_used	long
;	O
struct	O
gcide_idx_cache	struct(long,int,*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))))
*	O
*	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
;	O
size_t	long
compare_count	long
;	O
}	O
;	O
static	O
void	O
_free_index	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)))->(void)
(	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
)	O
{	O
size_t	long
i	long
;	O
free	(*(void))->(void)
(	O
file	*(char)
->	O
name	*(char)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
file	*(char)
->	O
cache_used	long
;	O
i	long
++	O
)	O
{	O
free	(*(void))->(void)
(	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
[	O
i	long
]	O
->	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
[	O
i	long
]	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
)	O
;	O
}	O
static	O
int	O
_idx_full_read	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),*(void),long)->(int)
(	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
,	O
void	O
*	O
buf	*(void)
,	O
size_t	long
size	long
)	O
{	O
char	O
*	O
p	*(char)
=	O
buf	*(void)
;	O
while	O
(	O
size	long
)	O
{	O
ssize_t	long
rc	int
=	O
read	(int,*(void),long)->(long)
(	O
file	*(char)
->	O
fd	int
,	O
p	*(char)
,	O
size	long
)	O
;	O
if	O
(	O
rc	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EAGAIN	int
)	O
continue	O
;	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"error reading from `%s'"	*(char)
)	O
,	O
file	*(char)
->	O
name	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"short read while reading from `%s'"	*(char)
)	O
,	O
file	*(char)
->	O
name	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
p	*(char)
+=	O
rc	int
;	O
size	long
-=	O
rc	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_open_index	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)))->(int)
(	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
)	O
{	O
off_t	long
total	long
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
_idx_full_read	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),*(void),long)->(int)
(	O
file	*(char)
,	O
&	O
file	*(char)
->	O
header	struct(array(char),long,long,long,long,long)
,	O
sizeof	O
(	O
file	*(char)
->	O
header	struct(array(char),long,long,long,long,long)
)	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
file	*(char)
->	O
header	struct(array(char),long,long,long,long,long)
.	O
ihdr_magic	array(char)
,	O
GCIDE_IDX_MAGIC	*(char)
,	O
GCIDE_IDX_MAGIC_LEN	O
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"file `%s' is not a valid gcide index file"	*(char)
)	O
,	O
file	*(char)
->	O
name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
file	*(char)
->	O
fd	int
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
"fstat `%s'"	*(char)
,	O
file	*(char)
->	O
name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
total	long
=	O
(	O
file	*(char)
->	O
header	struct(array(char),long,long,long,long,long)
.	O
ihdr_num_pages	long
+	O
1	int
)	O
*	O
file	*(char)
->	O
header	struct(array(char),long,long,long,long,long)
.	O
ihdr_pagesize	long
;	O
if	O
(	O
total	long
!=	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"index file `%s' is corrupted"	*(char)
)	O
,	O
file	*(char)
->	O
name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
gcide_idx_file_open	(*(char),long)->(*(struct))
(	O
const	O
char	O
*	O
name	*(char)
,	O
size_t	long
cachesize	long
)	O
{	O
int	O
fd	int
;	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
;	O
file	*(char)
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
file	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
file	*(char)
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
file	*(char)
->	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
file	*(char)
->	O
name	*(char)
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
name	*(char)
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"cannot open index file `%s'"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
)	O
;	O
}	O
file	*(char)
->	O
fd	int
=	O
fd	int
;	O
if	O
(	O
_open_index	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)))->(int)
(	O
file	*(char)
)	O
)	O
{	O
_free_index	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)))->(void)
(	O
file	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
file	*(char)
->	O
cache_size	long
=	O
cachesize	long
;	O
return	O
file	*(char)
;	O
}	O
void	O
gcide_idx_file_close	(*(struct))->(void)
(	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
)	O
{	O
if	O
(	O
file	*(char)
)	O
{	O
close	(int)->(int)
(	O
file	*(char)
->	O
fd	int
)	O
;	O
_free_index	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)))->(void)
(	O
file	*(char)
)	O
;	O
}	O
}	O
size_t	long
gcide_idx_headwords	(*(struct))->(long)
(	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
)	O
{	O
return	O
file	*(char)
->	O
header	struct(array(char),long,long,long,long,long)
.	O
ihdr_num_headwords	long
;	O
}	O
size_t	long
gcide_idx_defs	(*(struct))->(long)
(	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
)	O
{	O
return	O
file	*(char)
->	O
header	struct(array(char),long,long,long,long,long)
.	O
ihdr_num_defs	long
;	O
}	O
static	O
struct	O
gcide_idx_cache	struct(long,int,*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))))
*	O
_cache_alloc	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)))->(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
(	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
)	O
{	O
struct	O
gcide_idx_cache	struct(long,int,*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))))
*	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
;	O
if	O
(	O
!	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
)	O
{	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
=	O
calloc	(long,long)->(*(void))
(	O
file	*(char)
->	O
cache_size	long
,	O
sizeof	O
(	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
file	*(char)
->	O
cache_used	long
<	O
file	*(char)
->	O
cache_size	long
)	O
{	O
if	O
(	O
file	*(char)
->	O
cache_used	long
&&	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
[	O
file	*(char)
->	O
cache_used	long
-	O
1	int
]	O
->	O
refcount	int
==	O
0	int
)	O
return	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
[	O
file	*(char)
->	O
cache_used	long
-	O
1	int
]	O
;	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
)	O
)	O
;	O
if	O
(	O
!	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
->	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
=	O
malloc	(long)->(*(void))
(	O
file	*(char)
->	O
header	struct(array(char),long,long,long,long,long)
.	O
ihdr_pagesize	long
)	O
;	O
if	O
(	O
!	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
->	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
)	O
;	O
return	O
NULL	O
;	O
}	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
[	O
file	*(char)
->	O
cache_used	long
++	O
]	O
=	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
;	O
}	O
else	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
=	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
[	O
file	*(char)
->	O
cache_used	long
-	O
1	int
]	O
;	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
->	O
pageno	long
=	O
0	int
;	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
->	O
refcount	int
=	O
0	int
;	O
return	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
;	O
}	O
static	O
void	O
_cache_promote	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),int)->(void)
(	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
,	O
int	O
n	long
)	O
{	O
int	O
i	long
;	O
unsigned	O
refcount	int
=	O
++	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
[	O
n	long
]	O
->	O
refcount	int
;	O
if	O
(	O
n	long
==	O
0	int
)	O
return	O
;	O
for	O
(	O
i	long
=	O
n	long
-	O
1	int
;	O
i	long
>=	O
0	int
;	O
i	long
--	O
)	O
if	O
(	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
[	O
i	long
]	O
->	O
refcount	int
>=	O
refcount	int
)	O
break	O
;	O
i	long
++	O
;	O
if	O
(	O
i	long
!=	O
n	long
)	O
{	O
struct	O
gcide_idx_cache	struct(long,int,*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))))
*	O
tmp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
=	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
[	O
n	long
]	O
;	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
[	O
n	long
]	O
=	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
[	O
i	long
]	O
;	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
[	O
i	long
]	O
=	O
tmp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
;	O
}	O
}	O
static	O
struct	O
gcide_idx_cache	struct(long,int,*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))))
*	O
_cache_find_page	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),long)->(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
(	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
,	O
size_t	long
n	long
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
file	*(char)
->	O
cache_used	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
[	O
i	long
]	O
->	O
pageno	long
==	O
n	long
)	O
{	O
struct	O
gcide_idx_cache	struct(long,int,*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))))
*	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
=	O
file	*(char)
->	O
cache	*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
[	O
i	long
]	O
;	O
_cache_promote	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),int)->(void)
(	O
file	*(char)
,	O
n	long
)	O
;	O
return	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
struct	O
gcide_idx_page	struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))
*	O
_idx_get_page	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),long)->(*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*`)),array(struct(long,long,long,int,long,long,*(char))))))
(	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
,	O
size_t	long
n	long
)	O
{	O
off_t	long
off	long
;	O
struct	O
gcide_idx_cache	struct(long,int,*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))))
*	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
;	O
struct	O
gcide_idx_page	struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))
*	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
;	O
size_t	long
i	long
;	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
=	O
_cache_find_page	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),long)->(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
(	O
file	*(char)
,	O
n	long
)	O
;	O
if	O
(	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
)	O
return	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
->	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
;	O
off	long
=	O
(	O
n	long
+	O
1	int
)	O
*	O
file	*(char)
->	O
header	struct(array(char),long,long,long,long,long)
.	O
ihdr_pagesize	long
;	O
if	O
(	O
lseek	(int,long,int)->(long)
(	O
file	*(char)
->	O
fd	int
,	O
off	long
,	O
SEEK_SET	int
)	O
!=	O
off	long
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"seek error on `%s' while positioning to %lu"	*(char)
)	O
,	O
file	*(char)
->	O
name	*(char)
,	O
(	O
unsigned	O
long	O
)	O
off	long
)	O
;	O
return	O
NULL	O
;	O
}	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
=	O
_cache_alloc	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)))->(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char))))))))
(	O
file	*(char)
)	O
;	O
if	O
(	O
!	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
)	O
return	O
NULL	O
;	O
if	O
(	O
_idx_full_read	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),*(void),long)->(int)
(	O
file	*(char)
,	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
->	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
,	O
file	*(char)
->	O
header	struct(array(char),long,long,long,long,long)
.	O
ihdr_pagesize	long
)	O
)	O
return	O
NULL	O
;	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
->	O
refcount	int
++	O
;	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
=	O
cp	*(struct(long,int,*(struct(union(struct`,struct`),array(struct(long,long,long,int,long,long,*(char)))))))
->	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_header	union(struct(long,long),struct(long,long,long,int,long,long,*(char)))
.	O
hdr	*(struct)
.	O
phdr_numentries	long
;	O
i	long
++	O
)	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_ref	array(struct(long,long,long,int,long,long,*(char)))
[	O
i	long
]	O
.	O
ref_headword	*(char)
=	O
(	O
char	O
*	O
)	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
+	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_ref	array(struct(long,long,long,int,long,long,*(char)))
[	O
i	long
]	O
.	O
ref_hwoff	long
;	O
return	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
;	O
}	O
int	O
gcide_idx_enumerate	(*(struct),*((*(struct(long,long,long,int,long,long,*`)),*(void))->(int)),*(void))->(int)
(	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
,	O
int	O
(	O
*	O
fun	*((*(struct(long,long,long,int,long,long,*(char))),*(void))->(int))
)	O
(	O
struct	O
gcide_ref	struct(long,long,long,int,long,long,*(char))
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
data	*(void)
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
file	*(char)
->	O
header	struct(array(char),long,long,long,long,long)
.	O
ihdr_num_pages	long
;	O
i	long
++	O
)	O
{	O
int	O
j	int
;	O
struct	O
gcide_idx_page	struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))
*	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
=	O
_idx_get_page	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),long)->(*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*`)),array(struct(long,long,long,int,long,long,*(char))))))
(	O
file	*(char)
,	O
i	long
)	O
;	O
if	O
(	O
!	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
)	O
return	O
-	O
1	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_header	union(struct(long,long),struct(long,long,long,int,long,long,*(char)))
.	O
hdr	*(struct)
.	O
phdr_numentries	long
;	O
j	int
++	O
)	O
if	O
(	O
fun	*((*(struct(long,long,long,int,long,long,*(char))),*(void))->(int))
(	O
&	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_ref	array(struct(long,long,long,int,long,long,*(char)))
[	O
j	int
]	O
,	O
data	*(void)
)	O
)	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_compare	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),*(char),*(struct(long,long,long,int,long,long,*(char))),long)->(int)
(	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
,	O
char	O
*	O
hw	*(char)
,	O
struct	O
gcide_ref	struct(long,long,long,int,long,long,*(char))
*	O
ref	*(struct(long,long,long,int,long,long,*(char)))
,	O
size_t	long
hwlen	long
)	O
{	O
file	*(char)
->	O
compare_count	long
++	O
;	O
if	O
(	O
hwlen	long
)	O
{	O
if	O
(	O
hwlen	long
>	O
ref	*(struct(long,long,long,int,long,long,*(char)))
->	O
ref_hwlen	long
)	O
hwlen	long
=	O
ref	*(struct(long,long,long,int,long,long,*(char)))
->	O
ref_hwlen	long
;	O
return	O
utf8_strncasecmp	(*(char),*(char),long)->(int)
(	O
hw	*(char)
,	O
ref	*(struct(long,long,long,int,long,long,*(char)))
->	O
ref_headword	*(char)
,	O
hwlen	long
)	O
;	O
}	O
return	O
utf8_strcasecmp	(*(char),*(char))->(int)
(	O
hw	*(char)
,	O
ref	*(struct(long,long,long,int,long,long,*(char)))
->	O
ref_headword	*(char)
)	O
;	O
}	O
static	O
size_t	long
_idx_ref_locate	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*`)),array(struct(long,long,long,int,long,long,*(char))))),*(char),long)->(long)
(	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
,	O
struct	O
gcide_idx_page	struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))
*	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
,	O
char	O
*	O
headword	*(char)
,	O
size_t	long
hwlen	long
)	O
{	O
size_t	long
l	long
,	O
u	long
,	O
idx	long
;	O
int	O
res	int
;	O
l	long
=	O
0	int
;	O
u	long
=	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_header	union(struct(long,long),struct(long,long,long,int,long,long,*(char)))
.	O
hdr	*(struct)
.	O
phdr_numentries	long
;	O
while	O
(	O
l	long
<	O
u	long
)	O
{	O
idx	long
=	O
(	O
l	long
+	O
u	long
)	O
/	O
2	int
;	O
res	int
=	O
_compare	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),*(char),*(struct(long,long,long,int,long,long,*(char))),long)->(int)
(	O
file	*(char)
,	O
headword	*(char)
,	O
&	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_ref	array(struct(long,long,long,int,long,long,*(char)))
[	O
idx	long
]	O
,	O
hwlen	long
)	O
;	O
if	O
(	O
res	int
<	O
0	int
)	O
u	long
=	O
idx	long
;	O
else	O
if	O
(	O
res	int
>	O
0	int
)	O
l	long
=	O
idx	long
+	O
1	int
;	O
else	O
return	O
idx	long
;	O
}	O
return	O
REF_NOT_FOUND	O
;	O
}	O
static	O
size_t	long
_idx_page_locate	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),*(char),long)->(long)
(	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
,	O
char	O
*	O
headword	*(char)
,	O
size_t	long
hwlen	long
)	O
{	O
size_t	long
l	long
,	O
u	long
,	O
idx	long
;	O
int	O
res	int
;	O
l	long
=	O
0	int
;	O
u	long
=	O
file	*(char)
->	O
header	struct(array(char),long,long,long,long,long)
.	O
ihdr_num_pages	long
;	O
while	O
(	O
l	long
<	O
u	long
)	O
{	O
struct	O
gcide_idx_page	struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))
*	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
;	O
idx	long
=	O
(	O
l	long
+	O
u	long
)	O
/	O
2	int
;	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
=	O
_idx_get_page	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),long)->(*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*`)),array(struct(long,long,long,int,long,long,*(char))))))
(	O
file	*(char)
,	O
idx	long
)	O
;	O
if	O
(	O
!	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
)	O
return	O
REF_NOT_FOUND	O
;	O
res	int
=	O
_compare	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),*(char),*(struct(long,long,long,int,long,long,*(char))),long)->(int)
(	O
file	*(char)
,	O
headword	*(char)
,	O
&	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_ref	array(struct(long,long,long,int,long,long,*(char)))
[	O
0	int
]	O
,	O
hwlen	long
)	O
;	O
if	O
(	O
res	int
<	O
0	int
)	O
u	long
=	O
idx	long
;	O
else	O
if	O
(	O
res	int
==	O
0	int
)	O
return	O
idx	long
;	O
else	O
{	O
res	int
=	O
_compare	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),*(char),*(struct(long,long,long,int,long,long,*(char))),long)->(int)
(	O
file	*(char)
,	O
headword	*(char)
,	O
&	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_ref	array(struct(long,long,long,int,long,long,*(char)))
[	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_header	union(struct(long,long),struct(long,long,long,int,long,long,*(char)))
.	O
hdr	*(struct)
.	O
phdr_numentries	long
-	O
1	int
]	O
,	O
hwlen	long
)	O
;	O
if	O
(	O
res	int
>	O
0	int
)	O
l	long
=	O
idx	long
+	O
1	int
;	O
else	O
return	O
idx	long
;	O
}	O
}	O
return	O
REF_NOT_FOUND	O
;	O
}	O
struct	O
gcide_iterator	struct(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*`))),long)),*(char),long,long,long,long,long,long,long,long,long,*(char),long,int)
{	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
;	O
char	O
*	O
headword	*(char)
;	O
size_t	long
hwlen	long
;	O
size_t	long
start_pageno	long
;	O
size_t	long
start_refno	long
;	O
size_t	long
cur_pageno	long
;	O
size_t	long
cur_refno	long
;	O
size_t	long
page_numrefs	long
;	O
size_t	long
compare_count	long
;	O
size_t	long
numrefs	long
;	O
size_t	long
curref	long
;	O
char	O
*	O
prevbuf	*(char)
;	O
size_t	long
prevsize	long
;	O
int	O
flags	int
;	O
}	O
;	O
gcide_iterator_t	*(struct)
gcide_idx_locate	(*(struct),*(char),long)->(*(struct))
(	O
struct	O
gcide_idx_file	struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*(struct(union`,array(struct(long,long,long,int,long,long,*(char)))))))),long)
*	O
file	*(char)
,	O
char	O
*	O
headword	*(char)
,	O
size_t	long
hwlen	long
)	O
{	O
size_t	long
pageno	long
,	O
refno	long
;	O
struct	O
gcide_idx_page	struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))
*	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
;	O
struct	O
gcide_iterator	struct(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct(long,int,*`))),long)),*(char),long,long,long,long,long,long,long,long,long,*(char),long,int)
*	O
itr	*((*(void),*(void))->(int))
;	O
file	*(char)
->	O
compare_count	long
=	O
0	int
;	O
pageno	long
=	O
_idx_page_locate	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),*(char),long)->(long)
(	O
file	*(char)
,	O
headword	*(char)
,	O
hwlen	long
)	O
;	O
if	O
(	O
pageno	long
==	O
REF_NOT_FOUND	O
)	O
return	O
NULL	O
;	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
=	O
_idx_get_page	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),long)->(*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*`)),array(struct(long,long,long,int,long,long,*(char))))))
(	O
file	*(char)
,	O
pageno	long
)	O
;	O
if	O
(	O
!	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
)	O
return	O
NULL	O
;	O
refno	long
=	O
_idx_ref_locate	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*`)),array(struct(long,long,long,int,long,long,*(char))))),*(char),long)->(long)
(	O
file	*(char)
,	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
,	O
headword	*(char)
,	O
hwlen	long
)	O
;	O
if	O
(	O
refno	long
==	O
REF_NOT_FOUND	O
)	O
return	O
NULL	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
refno	long
>	O
0	int
)	O
{	O
if	O
(	O
_compare	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),*(char),*(struct(long,long,long,int,long,long,*(char))),long)->(int)
(	O
file	*(char)
,	O
headword	*(char)
,	O
&	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_ref	array(struct(long,long,long,int,long,long,*(char)))
[	O
refno	long
-	O
1	int
]	O
,	O
hwlen	long
)	O
>	O
0	int
)	O
break	O
;	O
--	O
refno	long
;	O
}	O
if	O
(	O
refno	long
==	O
0	int
)	O
{	O
if	O
(	O
pageno	long
==	O
0	int
)	O
break	O
;	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
=	O
_idx_get_page	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),long)->(*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*`)),array(struct(long,long,long,int,long,long,*(char))))))
(	O
file	*(char)
,	O
--	O
pageno	long
)	O
;	O
if	O
(	O
!	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
)	O
return	O
NULL	O
;	O
refno	long
=	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_header	union(struct(long,long),struct(long,long,long,int,long,long,*(char)))
.	O
hdr	*(struct)
.	O
phdr_numentries	long
;	O
}	O
}	O
if	O
(	O
refno	long
==	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_header	union(struct(long,long),struct(long,long,long,int,long,long,*(char)))
.	O
hdr	*(struct)
.	O
phdr_numentries	long
)	O
{	O
pageno	long
++	O
;	O
refno	long
=	O
0	int
;	O
}	O
itr	*((*(void),*(void))->(int))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
itr	*((*(void),*(void))->(int))
)	O
)	O
;	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
hwlen	long
)	O
{	O
itr	*((*(void),*(void))->(int))
->	O
headword	*(char)
=	O
malloc	(long)->(*(void))
(	O
hwlen	long
)	O
;	O
if	O
(	O
itr	*((*(void),*(void))->(int))
->	O
headword	*(char)
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
itr	*((*(void),*(void))->(int))
->	O
headword	*(char)
,	O
headword	*(char)
,	O
hwlen	long
)	O
;	O
}	O
else	O
itr	*((*(void),*(void))->(int))
->	O
headword	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
headword	*(char)
)	O
;	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
->	O
headword	*(char)
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
return	O
NULL	O
;	O
}	O
itr	*((*(void),*(void))->(int))
->	O
hwlen	long
=	O
hwlen	long
;	O
itr	*((*(void),*(void))->(int))
->	O
file	*(char)
=	O
file	*(char)
;	O
itr	*((*(void),*(void))->(int))
->	O
start_pageno	long
=	O
itr	*((*(void),*(void))->(int))
->	O
cur_pageno	long
=	O
pageno	long
;	O
itr	*((*(void),*(void))->(int))
->	O
start_refno	long
=	O
itr	*((*(void),*(void))->(int))
->	O
cur_refno	long
=	O
refno	long
;	O
itr	*((*(void),*(void))->(int))
->	O
page_numrefs	long
=	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_header	union(struct(long,long),struct(long,long,long,int,long,long,*(char)))
.	O
hdr	*(struct)
.	O
phdr_numentries	long
;	O
itr	*((*(void),*(void))->(int))
->	O
curref	long
=	O
itr	*((*(void),*(void))->(int))
->	O
numrefs	long
=	O
0	int
;	O
itr	*((*(void),*(void))->(int))
->	O
compare_count	long
=	O
file	*(char)
->	O
compare_count	long
;	O
return	O
itr	*((*(void),*(void))->(int))
;	O
}	O
void	O
gcide_iterator_free	(*(struct))->(void)
(	O
gcide_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
)	O
{	O
if	O
(	O
itr	*((*(void),*(void))->(int))
)	O
{	O
free	(*(void))->(void)
(	O
itr	*((*(void),*(void))->(int))
->	O
headword	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
}	O
}	O
int	O
gcide_iterator_next	(*(struct))->(int)
(	O
gcide_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
)	O
{	O
struct	O
gcide_idx_page	struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))
*	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
;	O
size_t	long
pageno	long
,	O
refno	long
;	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
)	O
return	O
-	O
1	int
;	O
if	O
(	O
itr	*((*(void),*(void))->(int))
->	O
numrefs	long
&&	O
itr	*((*(void),*(void))->(int))
->	O
curref	long
==	O
itr	*((*(void),*(void))->(int))
->	O
numrefs	long
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
itr	*((*(void),*(void))->(int))
->	O
cur_refno	long
<	O
itr	*((*(void),*(void))->(int))
->	O
page_numrefs	long
-	O
1	int
)	O
{	O
pageno	long
=	O
itr	*((*(void),*(void))->(int))
->	O
cur_pageno	long
;	O
refno	long
=	O
itr	*((*(void),*(void))->(int))
->	O
cur_refno	long
+	O
1	int
;	O
}	O
else	O
if	O
(	O
itr	*((*(void),*(void))->(int))
->	O
cur_pageno	long
==	O
itr	*((*(void),*(void))->(int))
->	O
file	*(char)
->	O
header	struct(array(char),long,long,long,long,long)
.	O
ihdr_num_pages	long
)	O
{	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
->	O
numrefs	long
)	O
itr	*((*(void),*(void))->(int))
->	O
numrefs	long
=	O
itr	*((*(void),*(void))->(int))
->	O
curref	long
+	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
pageno	long
=	O
itr	*((*(void),*(void))->(int))
->	O
cur_pageno	long
+	O
1	int
;	O
refno	long
=	O
0	int
;	O
}	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
=	O
_idx_get_page	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),long)->(*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*`)),array(struct(long,long,long,int,long,long,*(char))))))
(	O
itr	*((*(void),*(void))->(int))
->	O
file	*(char)
,	O
pageno	long
)	O
;	O
if	O
(	O
!	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
->	O
numrefs	long
&&	O
_compare	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),*(char),*(struct(long,long,long,int,long,long,*(char))),long)->(int)
(	O
itr	*((*(void),*(void))->(int))
->	O
file	*(char)
,	O
itr	*((*(void),*(void))->(int))
->	O
headword	*(char)
,	O
&	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_ref	array(struct(long,long,long,int,long,long,*(char)))
[	O
refno	long
]	O
,	O
itr	*((*(void),*(void))->(int))
->	O
hwlen	long
)	O
)	O
{	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
->	O
numrefs	long
)	O
itr	*((*(void),*(void))->(int))
->	O
numrefs	long
=	O
itr	*((*(void),*(void))->(int))
->	O
curref	long
+	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
itr	*((*(void),*(void))->(int))
->	O
page_numrefs	long
=	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_header	union(struct(long,long),struct(long,long,long,int,long,long,*(char)))
.	O
hdr	*(struct)
.	O
phdr_numentries	long
;	O
itr	*((*(void),*(void))->(int))
->	O
cur_pageno	long
=	O
pageno	long
;	O
itr	*((*(void),*(void))->(int))
->	O
cur_refno	long
=	O
refno	long
;	O
itr	*((*(void),*(void))->(int))
->	O
curref	long
++	O
;	O
return	O
0	int
;	O
}	O
int	O
gcide_iterator_rewind	(*(struct))->(int)
(	O
gcide_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
)	O
{	O
struct	O
gcide_idx_page	struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))
*	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
;	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
)	O
return	O
-	O
1	int
;	O
itr	*((*(void),*(void))->(int))
->	O
cur_pageno	long
=	O
itr	*((*(void),*(void))->(int))
->	O
start_pageno	long
;	O
itr	*((*(void),*(void))->(int))
->	O
cur_refno	long
=	O
itr	*((*(void),*(void))->(int))
->	O
start_refno	long
;	O
itr	*((*(void),*(void))->(int))
->	O
curref	long
=	O
0	int
;	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
=	O
_idx_get_page	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),long)->(*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*`)),array(struct(long,long,long,int,long,long,*(char))))))
(	O
itr	*((*(void),*(void))->(int))
->	O
file	*(char)
,	O
itr	*((*(void),*(void))->(int))
->	O
cur_pageno	long
)	O
;	O
if	O
(	O
!	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
)	O
return	O
-	O
1	int
;	O
itr	*((*(void),*(void))->(int))
->	O
page_numrefs	long
=	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_header	union(struct(long,long),struct(long,long,long,int,long,long,*(char)))
.	O
hdr	*(struct)
.	O
phdr_numentries	long
;	O
return	O
0	int
;	O
}	O
struct	O
gcide_ref	struct(long,long,long,int,long,long,*(char))
*	O
gcide_iterator_ref	(*(struct))->(*(struct(long,long,long,int,long,long,*(char))))
(	O
gcide_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
)	O
{	O
struct	O
gcide_idx_page	struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char))))
*	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
;	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
)	O
return	O
NULL	O
;	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
=	O
_idx_get_page	(*(struct(*(char),int,struct(array(char),long,long,long,long,long),long,long,*(*(struct`)),long)),long)->(*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*`)),array(struct(long,long,long,int,long,long,*(char))))))
(	O
itr	*((*(void),*(void))->(int))
->	O
file	*(char)
,	O
itr	*((*(void),*(void))->(int))
->	O
cur_pageno	long
)	O
;	O
if	O
(	O
!	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
)	O
return	O
NULL	O
;	O
return	O
&	O
page	*(struct(union(struct(long,long),struct(long,long,long,int,long,long,*(char))),array(struct(long,long,long,int,long,long,*(char)))))
->	O
ipg_ref	array(struct(long,long,long,int,long,long,*(char)))
[	O
itr	*((*(void),*(void))->(int))
->	O
cur_refno	long
]	O
;	O
}	O
size_t	long
gcide_iterator_count	(*(struct))->(long)
(	O
gcide_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
)	O
{	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
)	O
return	O
0	int
;	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
->	O
numrefs	long
)	O
{	O
while	O
(	O
gcide_iterator_next	(*(struct))->(int)
(	O
itr	*((*(void),*(void))->(int))
)	O
==	O
0	int
)	O
;	O
gcide_iterator_rewind	(*(struct))->(int)
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
}	O
return	O
itr	*((*(void),*(void))->(int))
->	O
numrefs	long
;	O
}	O
size_t	long
gcide_iterator_compare_count	(*(struct))->(long)
(	O
gcide_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
)	O
{	O
return	O
itr	*((*(void),*(void))->(int))
->	O
compare_count	long
;	O
}	O
void	O
gcide_iterator_store_flags	(*(struct),int)->(void)
(	O
gcide_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
,	O
int	O
flags	int
)	O
{	O
itr	*((*(void),*(void))->(int))
->	O
flags	int
=	O
flags	int
;	O
}	O
int	O
gcide_iterator_flags	(*(struct))->(int)
(	O
gcide_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
)	O
{	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
)	O
return	O
0	int
;	O
return	O
itr	*((*(void),*(void))->(int))
->	O
flags	int
;	O
}	O
