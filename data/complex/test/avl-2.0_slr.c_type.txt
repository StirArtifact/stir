static	O
const	O
char	O
*	O
grammar	array(array(*(char)))
[	O
]	O
[	O
2	int
]	O
=	O
{	O
{	O
"S=s"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"s=TDe"	*(char)
,	O
"reduce_declaration"	*(char)
}	O
,	O
{	O
"s=sTDe"	*(char)
,	O
"reduce_declaration"	*(char)
}	O
,	O
{	O
"T=tT"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"T=t"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"t=1"	*(char)
,	O
"reduce_typedef"	*(char)
}	O
,	O
{	O
"t=2"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"t=3iB"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"t=4"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"B=xa}"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"B="	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"x={"	*(char)
,	O
"reduce_struct_definition"	*(char)
}	O
,	O
{	O
"D=d,D"	*(char)
,	O
"reduce_declarator"	*(char)
}	O
,	O
{	O
"D=d"	*(char)
,	O
"reduce_declarator"	*(char)
}	O
,	O
{	O
"d=*Qd"	*(char)
,	O
"reduce_pointer"	*(char)
}	O
,	O
{	O
"d=E"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"Q=Q4"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"Q="	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"E=I"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"E=(d)"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"E=E[a]"	*(char)
,	O
"reduce_array"	*(char)
}	O
,	O
{	O
"E=E(a)"	*(char)
,	O
"reduce_function"	*(char)
}	O
,	O
{	O
"I=i"	*(char)
,	O
"reduce_identifier"	*(char)
}	O
,	O
{	O
"a="	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"a=ab"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"b=(a)"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"b={a}"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"b=[a]"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"b=i"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"b=o"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"b=1"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"b=2"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"b=3"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"b=4"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"b=,"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"b=*"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"b=;"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"e=;"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"e=ya}"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
"y={"	*(char)
,	O
"reduce_function_definition"	*(char)
}	O
,	O
}	O
;	O
static	O
struct	O
production	struct(int,int,*(int),*(char),*(char))
{	O
int	O
left	int
;	O
int	O
n_right	int
;	O
int	O
*	O
right	*(int)
;	O
const	O
char	O
*	O
ascii	*(char)
;	O
const	O
char	O
*	O
reduction	*(char)
;	O
}	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
n_grammar	O
]	O
;	O
static	O
struct	O
{	O
int	O
token	int
;	O
char	O
*	O
name	*(char)
;	O
}	O
tokens	array(struct(int,*(char)))
[	O
]	O
=	O
{	O
{	O
'i'	O
,	O
"lex_identifier"	*(char)
}	O
,	O
{	O
'1'	O
,	O
"lex_typedef"	*(char)
}	O
,	O
{	O
'2'	O
,	O
"lex_type_name"	*(char)
}	O
,	O
{	O
'3'	O
,	O
"lex_struct"	*(char)
}	O
,	O
{	O
'4'	O
,	O
"lex_const"	*(char)
}	O
,	O
{	O
'('	O
,	O
"lex_lparen"	*(char)
}	O
,	O
{	O
')'	O
,	O
"lex_rparen"	*(char)
}	O
,	O
{	O
'['	O
,	O
"lex_lbrack"	*(char)
}	O
,	O
{	O
']'	O
,	O
"lex_rbrack"	*(char)
}	O
,	O
{	O
'{'	O
,	O
"lex_lbrace"	*(char)
}	O
,	O
{	O
'}'	O
,	O
"lex_rbrace"	*(char)
}	O
,	O
{	O
','	O
,	O
"lex_comma"	*(char)
}	O
,	O
{	O
'*'	O
,	O
"lex_pointer"	*(char)
}	O
,	O
{	O
';'	O
,	O
"lex_semicolon"	*(char)
}	O
,	O
{	O
'o'	O
,	O
"lex_other"	*(char)
}	O
,	O
{	O
'$'	O
,	O
"lex_stop"	*(char)
}	O
,	O
}	O
;	O
static	O
int	O
debug	int
=	O
0	int
;	O
static	O
void	O
*	O
xmalloc	(long)->(*(void))
(	O
size_t	long
amt	long
)	O
{	O
void	O
*	O
p	*(void)
;	O
if	O
(	O
amt	long
==	O
0	int
)	O
return	O
NULL	O
;	O
p	*(void)
=	O
malloc	(long)->(*(void))
(	O
amt	long
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"virtual memory exhausted\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
static	O
void	O
*	O
xrealloc	(*(void),long)->(*(void))
(	O
void	O
*	O
ptr	*(void)
,	O
size_t	long
size	long
)	O
{	O
void	O
*	O
vp	*(void)
;	O
if	O
(	O
!	O
size	long
)	O
{	O
if	O
(	O
ptr	*(void)
)	O
free	(*(void))->(void)
(	O
ptr	*(void)
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
ptr	*(void)
)	O
vp	*(void)
=	O
realloc	(*(void),long)->(*(void))
(	O
ptr	*(void)
,	O
size	long
)	O
;	O
else	O
vp	*(void)
=	O
malloc	(long)->(*(void))
(	O
size	long
)	O
;	O
if	O
(	O
!	O
vp	*(void)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"virtual memory exhausted\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
return	O
vp	*(void)
;	O
}	O
struct	O
set	struct(int,*(int))
{	O
int	O
n	int
;	O
int	O
*	O
which	*(int)
;	O
}	O
;	O
static	O
void	O
set_init	(*(struct(int,*(int))))->(void)
(	O
struct	O
set	struct(int,*(int))
*	O
set	struct(int,*(int))
)	O
{	O
set	struct(int,*(int))
->	O
n	int
=	O
0	int
;	O
set	struct(int,*(int))
->	O
which	*(int)
=	O
NULL	O
;	O
}	O
static	O
void	O
set_free	(*(struct(int,*(int))))->(void)
(	O
struct	O
set	struct(int,*(int))
*	O
set	struct(int,*(int))
)	O
{	O
free	(*(void))->(void)
(	O
set	struct(int,*(int))
->	O
which	*(int)
)	O
;	O
}	O
static	O
int	O
set_contains	(*(struct(int,*(int))),int)->(int)
(	O
const	O
struct	O
set	struct(int,*(int))
*	O
set	struct(int,*(int))
,	O
int	O
c	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
set	struct(int,*(int))
->	O
n	int
;	O
i	int
++	O
)	O
if	O
(	O
set	struct(int,*(int))
->	O
which	*(int)
[	O
i	int
]	O
==	O
c	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
set_add	(*(struct(int,*(int))),int)->(int)
(	O
struct	O
set	struct(int,*(int))
*	O
set	struct(int,*(int))
,	O
int	O
c	int
)	O
{	O
if	O
(	O
set_contains	(*(struct(int,*(int))),int)->(int)
(	O
set	struct(int,*(int))
,	O
c	int
)	O
)	O
return	O
0	int
;	O
set	struct(int,*(int))
->	O
which	*(int)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
set	struct(int,*(int))
->	O
which	*(int)
,	O
sizeof	O
*	O
set	struct(int,*(int))
->	O
which	*(int)
*	O
(	O
set	struct(int,*(int))
->	O
n	int
+	O
1	int
)	O
)	O
;	O
set	struct(int,*(int))
->	O
which	*(int)
[	O
set	struct(int,*(int))
->	O
n	int
++	O
]	O
=	O
c	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
set_merge	(*(struct(int,*(int))),*(struct(int,*(int))),int)->(int)
(	O
struct	O
set	struct(int,*(int))
*	O
dst	*(struct(int,*(int)))
,	O
const	O
struct	O
set	struct(int,*(int))
*	O
src	*(struct(int,*(int)))
,	O
int	O
null_also	int
)	O
{	O
int	O
count	int
;	O
int	O
i	int
;	O
count	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
src	*(struct(int,*(int)))
->	O
n	int
;	O
i	int
++	O
)	O
if	O
(	O
null_also	int
||	O
src	*(struct(int,*(int)))
->	O
which	*(int)
[	O
i	int
]	O
!=	O
0	int
)	O
count	int
+=	O
set_add	(*(struct(int,*(int))),int)->(int)
(	O
dst	*(struct(int,*(int)))
,	O
src	*(struct(int,*(int)))
->	O
which	*(int)
[	O
i	int
]	O
)	O
;	O
return	O
count	int
;	O
}	O
static	O
void	O
set_print	(*(struct(int,*(int))))->(void)
(	O
const	O
struct	O
set	struct(int,*(int))
*	O
set	struct(int,*(int))
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
set	struct(int,*(int))
->	O
n	int
;	O
i	int
++	O
)	O
if	O
(	O
set	struct(int,*(int))
->	O
which	*(int)
[	O
i	int
]	O
!=	O
0	int
)	O
putchar	(int)->(int)
(	O
set	struct(int,*(int))
->	O
which	*(int)
[	O
i	int
]	O
)	O
;	O
else	O
putchar	(int)->(int)
(	O
'0'	O
)	O
;	O
}	O
static	O
struct	O
symbol	struct(int,int,int,struct(int,*(int)),struct(int,*(int)))
{	O
int	O
sym	int
;	O
int	O
nonterminal	int
;	O
int	O
nt_index	int
;	O
struct	O
set	struct(int,*(int))
first	struct(int,*(int))
,	O
follow	struct(int,*(int))
;	O
}	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
UCHAR_MAX	O
]	O
;	O
static	O
int	O
n_symbols	int
;	O
static	O
int	O
n_nonterminals	int
;	O
static	O
int	O
n_terminals	int
;	O
struct	O
symbol	struct(int,int,int,struct(int,*(int)),struct(int,*(int)))
*	O
find_symbol	(int)->(*(struct(int,int,int,struct(int,*(int)),struct(int,*(int)))))
(	O
int	O
c	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
if	O
(	O
c	int
==	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
.	O
sym	int
)	O
return	O
&	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
find_unique_symbols	()->(void)
(	O
void	O
)	O
{	O
unsigned	O
char	O
seen	array(char)
[	O
UCHAR_MAX	O
]	O
;	O
size_t	long
i	int
;	O
n_symbols	int
=	O
n_terminals	int
=	O
n_nonterminals	int
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
seen	array(char)
,	O
0	int
,	O
sizeof	O
seen	array(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_grammar	O
;	O
i	int
++	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
seen	array(char)
[	O
(	O
unsigned	O
char	O
)	O
grammar	array(array(*(char)))
[	O
i	int
]	O
[	O
0	int
]	O
[	O
0	int
]	O
]	O
|=	O
2	int
;	O
for	O
(	O
p	*(void)
=	O
grammar	array(array(*(char)))
[	O
i	int
]	O
[	O
0	int
]	O
+	O
2	int
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
seen	array(char)
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	*(void)
]	O
|=	O
1	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
UCHAR_MAX	O
;	O
i	int
++	O
)	O
if	O
(	O
seen	array(char)
[	O
i	int
]	O
)	O
{	O
struct	O
symbol	struct(int,int,int,struct(int,*(int)),struct(int,*(int)))
*	O
sym	int
=	O
&	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
n_symbols	int
]	O
;	O
sym	int
->	O
sym	int
=	O
i	int
;	O
sym	int
->	O
nonterminal	int
=	O
(	O
seen	array(char)
[	O
i	int
]	O
&	O
2	int
)	O
!=	O
0	int
;	O
sym	int
->	O
nt_index	int
=	O
sym	int
->	O
nonterminal	int
?	O
n_nonterminals	int
:	O
-	O
1	int
;	O
n_symbols	int
++	O
;	O
n_nonterminals	int
+=	O
sym	int
->	O
nonterminal	int
;	O
n_terminals	int
+=	O
!	O
sym	int
->	O
nonterminal	int
;	O
}	O
}	O
struct	O
item	struct(int,int)
{	O
int	O
prod	int
;	O
int	O
dot	int
;	O
}	O
;	O
static	O
int	O
item_n_after_dot	(*(struct(int,int)))->(int)
(	O
const	O
struct	O
item	struct(int,int)
*	O
item	struct(int,int)
)	O
{	O
assert	O
(	O
item	struct(int,int)
!=	O
NULL	O
&&	O
item	struct(int,int)
->	O
prod	int
>=	O
0	int
&&	O
item	struct(int,int)
->	O
prod	int
<	O
(	O
int	O
)	O
n_grammar	O
)	O
;	O
return	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
item	struct(int,int)
->	O
prod	int
]	O
.	O
n_right	int
-	O
item	struct(int,int)
->	O
dot	int
;	O
}	O
static	O
int	O
item_symbol_after_dot	(*(struct(int,int)))->(int)
(	O
const	O
struct	O
item	struct(int,int)
*	O
item	struct(int,int)
)	O
{	O
assert	O
(	O
item_n_after_dot	(*(struct(int,int)))->(int)
(	O
item	struct(int,int)
)	O
>=	O
0	int
)	O
;	O
return	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
item	struct(int,int)
->	O
prod	int
]	O
.	O
right	*(int)
[	O
item	struct(int,int)
->	O
dot	int
]	O
;	O
}	O
static	O
void	O
item_print	(*(struct(int,int)))->(void)
(	O
const	O
struct	O
item	struct(int,int)
*	O
item	struct(int,int)
)	O
{	O
const	O
struct	O
production	struct(int,int,*(int),*(char),*(char))
*	O
prod	int
;	O
int	O
i	int
;	O
assert	O
(	O
item	struct(int,int)
!=	O
NULL	O
&&	O
item	struct(int,int)
->	O
prod	int
>=	O
0	int
&&	O
item	struct(int,int)
->	O
prod	int
<	O
(	O
int	O
)	O
n_grammar	O
)	O
;	O
prod	int
=	O
&	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
item	struct(int,int)
->	O
prod	int
]	O
;	O
printf	(*(char))->(int)
(	O
"%c="	*(char)
,	O
prod	int
->	O
left	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
prod	int
->	O
n_right	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
item	struct(int,int)
->	O
dot	int
)	O
putchar	(int)->(int)
(	O
'.'	O
)	O
;	O
putchar	(int)->(int)
(	O
prod	int
->	O
right	*(int)
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
i	int
==	O
item	struct(int,int)
->	O
dot	int
)	O
putchar	(int)->(int)
(	O
'.'	O
)	O
;	O
}	O
struct	O
list	struct(int,int,*(struct(int,int)))
{	O
int	O
n	int
;	O
int	O
m	int
;	O
struct	O
item	struct(int,int)
*	O
contents	*(struct(int,int))
;	O
}	O
;	O
static	O
void	O
list_init	(*(struct(int,int,*(struct(int,int)))))->(void)
(	O
struct	O
list	struct(int,int,*(struct(int,int)))
*	O
list	struct(int,int,*(struct(int,int)))
)	O
{	O
assert	O
(	O
list	struct(int,int,*(struct(int,int)))
!=	O
NULL	O
)	O
;	O
list	struct(int,int,*(struct(int,int)))
->	O
n	int
=	O
list	struct(int,int,*(struct(int,int)))
->	O
m	int
=	O
0	int
;	O
list	struct(int,int,*(struct(int,int)))
->	O
contents	*(struct(int,int))
=	O
NULL	O
;	O
}	O
static	O
void	O
list_free	(*(struct(int,int,*(struct(int,int)))))->(void)
(	O
struct	O
list	struct(int,int,*(struct(int,int)))
*	O
list	struct(int,int,*(struct(int,int)))
)	O
{	O
free	(*(void))->(void)
(	O
list	struct(int,int,*(struct(int,int)))
->	O
contents	*(struct(int,int))
)	O
;	O
}	O
static	O
int	O
list_contains	(*(struct(int,int,*(struct(int,int)))),int,int)->(int)
(	O
struct	O
list	struct(int,int,*(struct(int,int)))
*	O
list	struct(int,int,*(struct(int,int)))
,	O
int	O
prod	int
,	O
int	O
dot	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list	struct(int,int,*(struct(int,int)))
->	O
n	int
;	O
i	int
++	O
)	O
if	O
(	O
list	struct(int,int,*(struct(int,int)))
->	O
contents	*(struct(int,int))
[	O
i	int
]	O
.	O
prod	int
==	O
prod	int
&&	O
list	struct(int,int,*(struct(int,int)))
->	O
contents	*(struct(int,int))
[	O
i	int
]	O
.	O
dot	int
==	O
dot	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
list_add	(*(struct(int,int,*(struct(int,int)))),int,int)->(int)
(	O
struct	O
list	struct(int,int,*(struct(int,int)))
*	O
list	struct(int,int,*(struct(int,int)))
,	O
int	O
prod	int
,	O
int	O
dot	int
)	O
{	O
assert	O
(	O
list	struct(int,int,*(struct(int,int)))
!=	O
NULL	O
)	O
;	O
if	O
(	O
list_contains	(*(struct(int,int,*(struct(int,int)))),int,int)->(int)
(	O
list	struct(int,int,*(struct(int,int)))
,	O
prod	int
,	O
dot	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
list	struct(int,int,*(struct(int,int)))
->	O
n	int
>=	O
list	struct(int,int,*(struct(int,int)))
->	O
m	int
)	O
{	O
if	O
(	O
list	struct(int,int,*(struct(int,int)))
->	O
m	int
==	O
0	int
)	O
list	struct(int,int,*(struct(int,int)))
->	O
m	int
=	O
16	int
;	O
else	O
list	struct(int,int,*(struct(int,int)))
->	O
m	int
*=	O
2	int
;	O
list	struct(int,int,*(struct(int,int)))
->	O
contents	*(struct(int,int))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
list	struct(int,int,*(struct(int,int)))
->	O
contents	*(struct(int,int))
,	O
sizeof	O
*	O
list	struct(int,int,*(struct(int,int)))
->	O
contents	*(struct(int,int))
*	O
list	struct(int,int,*(struct(int,int)))
->	O
m	int
)	O
;	O
}	O
assert	O
(	O
list	struct(int,int,*(struct(int,int)))
->	O
n	int
<	O
list	struct(int,int,*(struct(int,int)))
->	O
m	int
)	O
;	O
list	struct(int,int,*(struct(int,int)))
->	O
contents	*(struct(int,int))
[	O
list	struct(int,int,*(struct(int,int)))
->	O
n	int
]	O
.	O
prod	int
=	O
prod	int
;	O
list	struct(int,int,*(struct(int,int)))
->	O
contents	*(struct(int,int))
[	O
list	struct(int,int,*(struct(int,int)))
->	O
n	int
]	O
.	O
dot	int
=	O
dot	int
;	O
list	struct(int,int,*(struct(int,int)))
->	O
n	int
++	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
list_copy	(*(struct(int,int,*(struct(int,int)))),*(struct(int,int,*(struct(int,int)))))->(void)
(	O
struct	O
list	struct(int,int,*(struct(int,int)))
*	O
dst	*(struct(int,*(int)))
,	O
const	O
struct	O
list	struct(int,int,*(struct(int,int)))
*	O
src	*(struct(int,*(int)))
)	O
{	O
int	O
i	int
;	O
dst	*(struct(int,*(int)))
->	O
n	int
=	O
src	*(struct(int,*(int)))
->	O
n	int
;	O
dst	*(struct(int,*(int)))
->	O
m	int
=	O
src	*(struct(int,*(int)))
->	O
m	int
;	O
dst	*(struct(int,*(int)))
->	O
contents	*(struct(int,int))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
dst	*(struct(int,*(int)))
->	O
contents	*(struct(int,int))
*	O
dst	*(struct(int,*(int)))
->	O
m	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
src	*(struct(int,*(int)))
->	O
n	int
;	O
i	int
++	O
)	O
dst	*(struct(int,*(int)))
->	O
contents	*(struct(int,int))
[	O
i	int
]	O
=	O
src	*(struct(int,*(int)))
->	O
contents	*(struct(int,int))
[	O
i	int
]	O
;	O
}	O
static	O
int	O
list_equal	(*(struct(int,int,*(struct(int,int)))),*(struct(int,int,*(struct(int,int)))))->(int)
(	O
const	O
struct	O
list	struct(int,int,*(struct(int,int)))
*	O
a	*(struct(int,int,*(struct(int,int))))
,	O
const	O
struct	O
list	struct(int,int,*(struct(int,int)))
*	O
b	*(struct(int,int,*(struct(int,int))))
)	O
{	O
int	O
i	int
;	O
if	O
(	O
a	*(struct(int,int,*(struct(int,int))))
->	O
n	int
!=	O
b	*(struct(int,int,*(struct(int,int))))
->	O
n	int
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
a	*(struct(int,int,*(struct(int,int))))
->	O
n	int
;	O
i	int
++	O
)	O
if	O
(	O
a	*(struct(int,int,*(struct(int,int))))
->	O
contents	*(struct(int,int))
[	O
i	int
]	O
.	O
prod	int
!=	O
b	*(struct(int,int,*(struct(int,int))))
->	O
contents	*(struct(int,int))
[	O
i	int
]	O
.	O
prod	int
||	O
a	*(struct(int,int,*(struct(int,int))))
->	O
contents	*(struct(int,int))
[	O
i	int
]	O
.	O
dot	int
!=	O
b	*(struct(int,int,*(struct(int,int))))
->	O
contents	*(struct(int,int))
[	O
i	int
]	O
.	O
dot	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
list_count	(*(struct(int,int,*(struct(int,int)))))->(int)
(	O
const	O
struct	O
list	struct(int,int,*(struct(int,int)))
*	O
list	struct(int,int,*(struct(int,int)))
)	O
{	O
assert	O
(	O
list	struct(int,int,*(struct(int,int)))
!=	O
NULL	O
)	O
;	O
return	O
list	struct(int,int,*(struct(int,int)))
->	O
n	int
;	O
}	O
static	O
const	O
struct	O
item	struct(int,int)
*	O
list_item	(*(struct(int,int,*(struct(int,int)))),int)->(*(struct(int,int)))
(	O
const	O
struct	O
list	struct(int,int,*(struct(int,int)))
*	O
list	struct(int,int,*(struct(int,int)))
,	O
int	O
index	int
)	O
{	O
assert	O
(	O
list	struct(int,int,*(struct(int,int)))
!=	O
NULL	O
&&	O
index	int
>=	O
0	int
&&	O
index	int
<	O
list	struct(int,int,*(struct(int,int)))
->	O
n	int
)	O
;	O
return	O
&	O
list	struct(int,int,*(struct(int,int)))
->	O
contents	*(struct(int,int))
[	O
index	int
]	O
;	O
}	O
static	O
void	O
list_print	(*(struct(int,int,*(struct(int,int)))))->(void)
(	O
const	O
struct	O
list	struct(int,int,*(struct(int,int)))
*	O
list	struct(int,int,*(struct(int,int)))
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list	struct(int,int,*(struct(int,int)))
->	O
n	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
!=	O
0	int
)	O
printf	(*(char))->(int)
(	O
", "	*(char)
)	O
;	O
item_print	(*(struct(int,int)))->(void)
(	O
&	O
list	struct(int,int,*(struct(int,int)))
->	O
contents	*(struct(int,int))
[	O
i	int
]	O
)	O
;	O
}	O
}	O
static	O
void	O
precalc_first	()->(void)
(	O
void	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
{	O
set_init	(*(struct(int,*(int))))->(void)
(	O
&	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
.	O
first	struct(int,*(int))
)	O
;	O
if	O
(	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
.	O
nonterminal	int
)	O
{	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n_grammar	O
;	O
j	long
++	O
)	O
if	O
(	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
j	long
]	O
.	O
left	int
==	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
.	O
sym	int
&&	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
j	long
]	O
.	O
n_right	int
==	O
0	int
)	O
{	O
set_add	(*(struct(int,*(int))),int)->(int)
(	O
&	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
.	O
first	struct(int,*(int))
,	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
set_add	(*(struct(int,*(int))),int)->(int)
(	O
&	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
.	O
first	struct(int,*(int))
,	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
.	O
sym	int
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
added	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_grammar	O
;	O
i	int
++	O
)	O
{	O
struct	O
production	struct(int,int,*(int),*(char),*(char))
*	O
prod	int
=	O
&	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
i	int
]	O
;	O
struct	O
symbol	struct(int,int,int,struct(int,*(int)),struct(int,*(int)))
*	O
X	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
=	O
find_symbol	(int)->(*(struct(int,int,int,struct(int,*(int)),struct(int,*(int)))))
(	O
prod	int
->	O
left	int
)	O
;	O
int	O
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
prod	int
->	O
n_right	int
;	O
j	long
++	O
)	O
{	O
struct	O
symbol	struct(int,int,int,struct(int,*(int)),struct(int,*(int)))
*	O
Y	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
;	O
int	O
k	int
;	O
Y	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
=	O
find_symbol	(int)->(*(struct(int,int,int,struct(int,*(int)),struct(int,*(int)))))
(	O
prod	int
->	O
right	*(int)
[	O
j	long
]	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
Y	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
first	struct(int,*(int))
.	O
n	int
;	O
k	int
++	O
)	O
if	O
(	O
Y	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
first	struct(int,*(int))
.	O
which	*(int)
[	O
k	int
]	O
!=	O
0	int
)	O
added	int
|=	O
set_add	(*(struct(int,*(int))),int)->(int)
(	O
&	O
X	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
first	struct(int,*(int))
,	O
Y	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
first	struct(int,*(int))
.	O
which	*(int)
[	O
k	int
]	O
)	O
;	O
if	O
(	O
!	O
set_contains	(*(struct(int,*(int))),int)->(int)
(	O
&	O
X	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
first	struct(int,*(int))
,	O
0	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
j	long
>=	O
prod	int
->	O
n_right	int
)	O
added	int
|=	O
set_add	(*(struct(int,*(int))),int)->(int)
(	O
&	O
X	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
first	struct(int,*(int))
,	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
added	int
)	O
break	O
;	O
}	O
if	O
(	O
debug	int
)	O
{	O
printf	(*(char))->(int)
(	O
"FIRST function:\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
{	O
struct	O
symbol	struct(int,int,int,struct(int,*(int)),struct(int,*(int)))
*	O
sym	int
=	O
&	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
;	O
printf	(*(char))->(int)
(	O
"\tFIRST(%c) = "	*(char)
,	O
sym	int
->	O
sym	int
)	O
;	O
set_print	(*(struct(int,*(int))))->(void)
(	O
&	O
sym	int
->	O
first	struct(int,*(int))
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
calc_first	(*(struct(int,*(int))),*(int),int)->(void)
(	O
struct	O
set	struct(int,*(int))
*	O
set	struct(int,*(int))
,	O
int	O
*	O
X	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
,	O
int	O
n	int
)	O
{	O
int	O
i	int
;	O
set_init	(*(struct(int,*(int))))->(void)
(	O
set	struct(int,*(int))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
const	O
struct	O
set	struct(int,*(int))
*	O
f	*(struct(int,*(int)))
=	O
&	O
find_symbol	(int)->(*(struct(int,int,int,struct(int,*(int)),struct(int,*(int)))))
(	O
X	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
)	O
->	O
first	struct(int,*(int))
;	O
set_merge	(*(struct(int,*(int))),*(struct(int,*(int))),int)->(int)
(	O
set	struct(int,*(int))
,	O
f	*(struct(int,*(int)))
,	O
0	int
)	O
;	O
if	O
(	O
!	O
set_contains	(*(struct(int,*(int))),int)->(int)
(	O
f	*(struct(int,*(int)))
,	O
0	int
)	O
)	O
return	O
;	O
}	O
set_add	(*(struct(int,*(int))),int)->(int)
(	O
set	struct(int,*(int))
,	O
0	int
)	O
;	O
}	O
static	O
void	O
precalc_follow	()->(void)
(	O
void	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
set_init	(*(struct(int,*(int))))->(void)
(	O
&	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
.	O
follow	struct(int,*(int))
)	O
;	O
set_add	(*(struct(int,*(int))),int)->(int)
(	O
&	O
find_symbol	(int)->(*(struct(int,int,int,struct(int,*(int)),struct(int,*(int)))))
(	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
0	int
]	O
.	O
left	int
)	O
->	O
follow	struct(int,*(int))
,	O
'$'	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
added	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_grammar	O
;	O
i	int
++	O
)	O
{	O
const	O
struct	O
production	struct(int,int,*(int),*(char),*(char))
*	O
prod	int
;	O
struct	O
symbol	struct(int,int,int,struct(int,*(int)),struct(int,*(int)))
*	O
A	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
;	O
int	O
j	long
;	O
prod	int
=	O
&	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
i	int
]	O
;	O
A	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
=	O
find_symbol	(int)->(*(struct(int,int,int,struct(int,*(int)),struct(int,*(int)))))
(	O
prod	int
->	O
left	int
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
prod	int
->	O
n_right	int
-	O
1	int
;	O
j	long
++	O
)	O
{	O
struct	O
symbol	struct(int,int,int,struct(int,*(int)),struct(int,*(int)))
*	O
B	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
;	O
struct	O
set	struct(int,*(int))
first_Beta	struct(int,*(int))
;	O
B	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
=	O
find_symbol	(int)->(*(struct(int,int,int,struct(int,*(int)),struct(int,*(int)))))
(	O
prod	int
->	O
right	*(int)
[	O
j	long
]	O
)	O
;	O
calc_first	(*(struct(int,*(int))),*(int),int)->(void)
(	O
&	O
first_Beta	struct(int,*(int))
,	O
&	O
prod	int
->	O
right	*(int)
[	O
j	long
+	O
1	int
]	O
,	O
prod	int
->	O
n_right	int
-	O
(	O
j	long
+	O
1	int
)	O
)	O
;	O
added	int
|=	O
set_merge	(*(struct(int,*(int))),*(struct(int,*(int))),int)->(int)
(	O
&	O
B	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
follow	struct(int,*(int))
,	O
&	O
first_Beta	struct(int,*(int))
,	O
0	int
)	O
;	O
if	O
(	O
set_contains	(*(struct(int,*(int))),int)->(int)
(	O
&	O
first_Beta	struct(int,*(int))
,	O
0	int
)	O
)	O
added	int
|=	O
set_merge	(*(struct(int,*(int))),*(struct(int,*(int))),int)->(int)
(	O
&	O
B	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
follow	struct(int,*(int))
,	O
&	O
A	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
follow	struct(int,*(int))
,	O
1	int
)	O
;	O
set_free	(*(struct(int,*(int))))->(void)
(	O
&	O
first_Beta	struct(int,*(int))
)	O
;	O
}	O
if	O
(	O
prod	int
->	O
n_right	int
>	O
0	int
)	O
{	O
struct	O
symbol	struct(int,int,int,struct(int,*(int)),struct(int,*(int)))
*	O
B	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
=	O
find_symbol	(int)->(*(struct(int,int,int,struct(int,*(int)),struct(int,*(int)))))
(	O
prod	int
->	O
right	*(int)
[	O
prod	int
->	O
n_right	int
-	O
1	int
]	O
)	O
;	O
added	int
|=	O
set_merge	(*(struct(int,*(int))),*(struct(int,*(int))),int)->(int)
(	O
&	O
B	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
follow	struct(int,*(int))
,	O
&	O
A	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
follow	struct(int,*(int))
,	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
added	int
)	O
break	O
;	O
}	O
if	O
(	O
debug	int
)	O
{	O
printf	(*(char))->(int)
(	O
"FOLLOW function:\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
{	O
struct	O
symbol	struct(int,int,int,struct(int,*(int)),struct(int,*(int)))
*	O
sym	int
=	O
&	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
;	O
if	O
(	O
!	O
sym	int
->	O
nonterminal	int
)	O
continue	O
;	O
printf	(*(char))->(int)
(	O
"\tFOLLOW(%c) = "	*(char)
,	O
sym	int
->	O
sym	int
)	O
;	O
set_print	(*(struct(int,*(int))))->(void)
(	O
&	O
sym	int
->	O
follow	struct(int,*(int))
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
calc_closure	(*(struct(int,int,*(struct(int,int)))),*(struct(int,int,*(struct(int,int)))))->(void)
(	O
struct	O
list	struct(int,int,*(struct(int,int)))
*	O
J	*(struct(int,int,*(struct(int,int))))
,	O
const	O
struct	O
list	struct(int,int,*(struct(int,int)))
*	O
I	*(struct(int,int,*(struct(int,int))))
)	O
{	O
int	O
i	int
;	O
if	O
(	O
I	*(struct(int,int,*(struct(int,int))))
!=	O
J	*(struct(int,int,*(struct(int,int))))
)	O
list_copy	(*(struct(int,int,*(struct(int,int)))),*(struct(int,int,*(struct(int,int)))))->(void)
(	O
J	*(struct(int,int,*(struct(int,int))))
,	O
I	*(struct(int,int,*(struct(int,int))))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list_count	(*(struct(int,int,*(struct(int,int)))))->(int)
(	O
J	*(struct(int,int,*(struct(int,int))))
)	O
;	O
i	int
++	O
)	O
{	O
const	O
struct	O
item	struct(int,int)
*	O
item	struct(int,int)
=	O
list_item	(*(struct(int,int,*(struct(int,int)))),int)->(*(struct(int,int)))
(	O
J	*(struct(int,int,*(struct(int,int))))
,	O
i	int
)	O
;	O
if	O
(	O
item_n_after_dot	(*(struct(int,int)))->(int)
(	O
item	struct(int,int)
)	O
>	O
0	int
)	O
{	O
int	O
t	int
=	O
item_symbol_after_dot	(*(struct(int,int)))->(int)
(	O
item	struct(int,int)
)	O
;	O
if	O
(	O
find_symbol	(int)->(*(struct(int,int,int,struct(int,*(int)),struct(int,*(int)))))
(	O
t	int
)	O
->	O
nonterminal	int
)	O
{	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n_grammar	O
;	O
j	long
++	O
)	O
if	O
(	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
j	long
]	O
.	O
left	int
==	O
t	int
)	O
list_add	(*(struct(int,int,*(struct(int,int)))),int,int)->(int)
(	O
J	*(struct(int,int,*(struct(int,int))))
,	O
j	long
,	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
calc_goto	(*(struct(int,int,*(struct(int,int)))),*(struct(int,int,*(struct(int,int)))),int)->(void)
(	O
struct	O
list	struct(int,int,*(struct(int,int)))
*	O
J	*(struct(int,int,*(struct(int,int))))
,	O
struct	O
list	struct(int,int,*(struct(int,int)))
*	O
I	*(struct(int,int,*(struct(int,int))))
,	O
int	O
X	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
)	O
{	O
int	O
i	int
;	O
if	O
(	O
I	*(struct(int,int,*(struct(int,int))))
!=	O
J	*(struct(int,int,*(struct(int,int))))
)	O
list_init	(*(struct(int,int,*(struct(int,int)))))->(void)
(	O
J	*(struct(int,int,*(struct(int,int))))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list_count	(*(struct(int,int,*(struct(int,int)))))->(int)
(	O
I	*(struct(int,int,*(struct(int,int))))
)	O
;	O
i	int
++	O
)	O
{	O
const	O
struct	O
item	struct(int,int)
*	O
item	struct(int,int)
=	O
list_item	(*(struct(int,int,*(struct(int,int)))),int)->(*(struct(int,int)))
(	O
I	*(struct(int,int,*(struct(int,int))))
,	O
i	int
)	O
;	O
if	O
(	O
item_n_after_dot	(*(struct(int,int)))->(int)
(	O
item	struct(int,int)
)	O
>	O
0	int
&&	O
item_symbol_after_dot	(*(struct(int,int)))->(int)
(	O
item	struct(int,int)
)	O
==	O
X	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
)	O
list_add	(*(struct(int,int,*(struct(int,int)))),int,int)->(int)
(	O
J	*(struct(int,int,*(struct(int,int))))
,	O
item	struct(int,int)
->	O
prod	int
,	O
item	struct(int,int)
->	O
dot	int
+	O
1	int
)	O
;	O
}	O
calc_closure	(*(struct(int,int,*(struct(int,int)))),*(struct(int,int,*(struct(int,int)))))->(void)
(	O
J	*(struct(int,int,*(struct(int,int))))
,	O
J	*(struct(int,int,*(struct(int,int))))
)	O
;	O
}	O
static	O
struct	O
list	struct(int,int,*(struct(int,int)))
C	array(struct(int,int,*(struct(int,int))))
[	O
MAX_LOL_COUNT	int
]	O
;	O
static	O
int	O
nC	int
;	O
static	O
void	O
build_canonical_sets	()->(void)
(	O
void	O
)	O
{	O
int	O
i	int
;	O
nC	int
=	O
1	int
;	O
list_init	(*(struct(int,int,*(struct(int,int)))))->(void)
(	O
&	O
C	array(struct(int,int,*(struct(int,int))))
[	O
0	int
]	O
)	O
;	O
list_add	(*(struct(int,int,*(struct(int,int)))),int,int)->(int)
(	O
&	O
C	array(struct(int,int,*(struct(int,int))))
[	O
0	int
]	O
,	O
0	int
,	O
0	int
)	O
;	O
calc_closure	(*(struct(int,int,*(struct(int,int)))),*(struct(int,int,*(struct(int,int)))))->(void)
(	O
&	O
C	array(struct(int,int,*(struct(int,int))))
[	O
0	int
]	O
,	O
&	O
C	array(struct(int,int,*(struct(int,int))))
[	O
0	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
int	O
X	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
;	O
for	O
(	O
X	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
=	O
0	int
;	O
X	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
<	O
n_symbols	int
;	O
X	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
++	O
)	O
{	O
struct	O
list	struct(int,int,*(struct(int,int)))
list	struct(int,int,*(struct(int,int)))
;	O
calc_goto	(*(struct(int,int,*(struct(int,int)))),*(struct(int,int,*(struct(int,int)))),int)->(void)
(	O
&	O
list	struct(int,int,*(struct(int,int)))
,	O
&	O
C	array(struct(int,int,*(struct(int,int))))
[	O
i	int
]	O
,	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
X	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
]	O
.	O
sym	int
)	O
;	O
if	O
(	O
list_count	(*(struct(int,int,*(struct(int,int)))))->(int)
(	O
&	O
list	struct(int,int,*(struct(int,int)))
)	O
)	O
{	O
int	O
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nC	int
;	O
j	long
++	O
)	O
if	O
(	O
list_equal	(*(struct(int,int,*(struct(int,int)))),*(struct(int,int,*(struct(int,int)))))->(int)
(	O
&	O
list	struct(int,int,*(struct(int,int)))
,	O
&	O
C	array(struct(int,int,*(struct(int,int))))
[	O
j	long
]	O
)	O
)	O
break	O
;	O
if	O
(	O
j	long
>=	O
nC	int
)	O
{	O
assert	O
(	O
nC	int
<	O
MAX_LOL_COUNT	int
)	O
;	O
C	array(struct(int,int,*(struct(int,int))))
[	O
nC	int
++	O
]	O
=	O
list	struct(int,int,*(struct(int,int)))
;	O
}	O
else	O
list_free	(*(struct(int,int,*(struct(int,int)))))->(void)
(	O
&	O
list	struct(int,int,*(struct(int,int)))
)	O
;	O
}	O
else	O
list_free	(*(struct(int,int,*(struct(int,int)))))->(void)
(	O
&	O
list	struct(int,int,*(struct(int,int)))
)	O
;	O
}	O
}	O
if	O
(	O
debug	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Canonical collection of sets:\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
printf	(*(char))->(int)
(	O
"\tI(%d) = "	*(char)
,	O
i	int
)	O
;	O
list_print	(*(struct(int,int,*(struct(int,int)))))->(void)
(	O
&	O
C	array(struct(int,int,*(struct(int,int))))
[	O
i	int
]	O
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
action_name	(array(char),int)->(void)
(	O
char	O
buf	array(char)
[	O
16	int
]	O
,	O
int	O
action	int
)	O
{	O
if	O
(	O
action	int
==	O
0	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	array(char)
,	O
"0"	*(char)
)	O
;	O
else	O
if	O
(	O
action	int
==	O
1	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	array(char)
,	O
"acc"	*(char)
)	O
;	O
else	O
if	O
(	O
action	int
>=	O
2	int
&&	O
action	int
<	O
2	int
+	O
nC	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
"s%d"	*(char)
,	O
action	int
-	O
2	int
)	O
;	O
else	O
{	O
int	O
reduce	int
=	O
action	int
-	O
(	O
2	int
+	O
nC	int
)	O
+	O
1	int
;	O
assert	O
(	O
action	int
>=	O
2	int
+	O
nC	int
&&	O
action	int
<	O
2	int
+	O
nC	int
+	O
n_grammar	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
"r%d"	*(char)
,	O
reduce	int
)	O
;	O
}	O
}	O
static	O
void	O
print_enum_list	(int,int,int)->(void)
(	O
int	O
c	int
,	O
int	O
first	struct(int,*(int))
,	O
int	O
last	int
)	O
{	O
char	O
string	array(char)
[	O
80	int
]	O
;	O
int	O
i	int
;	O
string	array(char)
[	O
0	int
]	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
first	struct(int,*(int))
;	O
i	int
<=	O
last	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strlen	(*(char))->(long)
(	O
string	array(char)
)	O
>	O
65	int
)	O
{	O
printf	(*(char))->(int)
(	O
"    %s\n"	*(char)
,	O
string	array(char)
)	O
;	O
string	array(char)
[	O
0	int
]	O
=	O
0	int
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
string	array(char)
+	O
strlen	(*(char))->(long)
(	O
string	array(char)
)	O
,	O
"%c%d, "	*(char)
,	O
c	int
,	O
i	int
)	O
;	O
}	O
if	O
(	O
strlen	(*(char))->(long)
(	O
string	array(char)
)	O
>	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"    %s\n"	*(char)
,	O
string	array(char)
)	O
;	O
string	array(char)
[	O
0	int
]	O
=	O
0	int
;	O
}	O
}	O
static	O
void	O
set_action	(*(*(char)),int,int,int)->(void)
(	O
unsigned	O
char	O
*	O
*	O
actions	*(*(char))
,	O
int	O
state	int
,	O
int	O
input	int
,	O
int	O
value	int
)	O
{	O
assert	O
(	O
actions	*(*(char))
!=	O
NULL	O
)	O
;	O
assert	O
(	O
state	int
>=	O
0	int
&&	O
state	int
<	O
nC	int
)	O
;	O
assert	O
(	O
input	int
>=	O
0	int
&&	O
input	int
<=	O
n_symbols	int
)	O
;	O
if	O
(	O
actions	*(*(char))
[	O
state	int
]	O
[	O
input	int
]	O
!=	O
0	int
&&	O
actions	*(*(char))
[	O
state	int
]	O
[	O
input	int
]	O
!=	O
value	int
)	O
{	O
char	O
a	*(struct(int,int,*(struct(int,int))))
[	O
16	int
]	O
,	O
b	*(struct(int,int,*(struct(int,int))))
[	O
16	int
]	O
;	O
action_name	(array(char),int)->(void)
(	O
a	*(struct(int,int,*(struct(int,int))))
,	O
value	int
)	O
;	O
action_name	(array(char),int)->(void)
(	O
b	*(struct(int,int,*(struct(int,int))))
,	O
actions	*(*(char))
[	O
state	int
]	O
[	O
input	int
]	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Conflict for state %d, input %c: %s versus %s\n"	*(char)
,	O
state	int
,	O
input	int
<	O
n_symbols	int
?	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
input	int
]	O
.	O
sym	int
:	O
'$'	O
,	O
a	*(struct(int,int,*(struct(int,int))))
,	O
b	*(struct(int,int,*(struct(int,int))))
)	O
;	O
}	O
actions	*(*(char))
[	O
state	int
]	O
[	O
input	int
]	O
=	O
value	int
;	O
}	O
static	O
void	O
build_action_table	()->(void)
(	O
void	O
)	O
{	O
unsigned	O
char	O
*	O
*	O
actions	*(*(char))
;	O
int	O
i	int
;	O
actions	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
actions	*(*(char))
*	O
nC	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
actions	*(*(char))
[	O
i	int
]	O
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
*	O
actions	*(*(char))
*	O
(	O
n_symbols	int
+	O
1	int
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
actions	*(*(char))
[	O
i	int
]	O
,	O
0	int
,	O
sizeof	O
*	O
*	O
actions	*(*(char))
*	O
(	O
n_symbols	int
+	O
1	int
)	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
int	O
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
list_count	(*(struct(int,int,*(struct(int,int)))))->(int)
(	O
&	O
C	array(struct(int,int,*(struct(int,int))))
[	O
i	int
]	O
)	O
;	O
j	long
++	O
)	O
{	O
const	O
struct	O
item	struct(int,int)
*	O
item	struct(int,int)
=	O
list_item	(*(struct(int,int,*(struct(int,int)))),int)->(*(struct(int,int)))
(	O
&	O
C	array(struct(int,int,*(struct(int,int))))
[	O
i	int
]	O
,	O
j	long
)	O
;	O
const	O
struct	O
production	struct(int,int,*(int),*(char),*(char))
*	O
prod	int
=	O
&	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
item	struct(int,int)
->	O
prod	int
]	O
;	O
const	O
struct	O
symbol	struct(int,int,int,struct(int,*(int)),struct(int,*(int)))
*	O
A	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
=	O
find_symbol	(int)->(*(struct(int,int,int,struct(int,*(int)),struct(int,*(int)))))
(	O
prod	int
->	O
left	int
)	O
;	O
if	O
(	O
item_n_after_dot	(*(struct(int,int)))->(int)
(	O
item	struct(int,int)
)	O
>	O
0	int
)	O
{	O
struct	O
symbol	struct(int,int,int,struct(int,*(int)),struct(int,*(int)))
*	O
a	*(struct(int,int,*(struct(int,int))))
;	O
a	*(struct(int,int,*(struct(int,int))))
=	O
find_symbol	(int)->(*(struct(int,int,int,struct(int,*(int)),struct(int,*(int)))))
(	O
item_symbol_after_dot	(*(struct(int,int)))->(int)
(	O
item	struct(int,int)
)	O
)	O
;	O
if	O
(	O
!	O
a	*(struct(int,int,*(struct(int,int))))
->	O
nonterminal	int
)	O
{	O
struct	O
list	struct(int,int,*(struct(int,int)))
list	struct(int,int,*(struct(int,int)))
;	O
int	O
k	int
;	O
calc_goto	(*(struct(int,int,*(struct(int,int)))),*(struct(int,int,*(struct(int,int)))),int)->(void)
(	O
&	O
list	struct(int,int,*(struct(int,int)))
,	O
&	O
C	array(struct(int,int,*(struct(int,int))))
[	O
i	int
]	O
,	O
a	*(struct(int,int,*(struct(int,int))))
->	O
sym	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
nC	int
;	O
k	int
++	O
)	O
if	O
(	O
list_equal	(*(struct(int,int,*(struct(int,int)))),*(struct(int,int,*(struct(int,int)))))->(int)
(	O
&	O
list	struct(int,int,*(struct(int,int)))
,	O
&	O
C	array(struct(int,int,*(struct(int,int))))
[	O
k	int
]	O
)	O
)	O
set_action	(*(*(char)),int,int,int)->(void)
(	O
actions	*(*(char))
,	O
i	int
,	O
a	*(struct(int,int,*(struct(int,int))))
-	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
,	O
2	int
+	O
k	int
)	O
;	O
list_free	(*(struct(int,int,*(struct(int,int)))))->(void)
(	O
&	O
list	struct(int,int,*(struct(int,int)))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
A	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
sym	int
!=	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
0	int
]	O
.	O
left	int
)	O
{	O
const	O
struct	O
set	struct(int,*(int))
*	O
follow_A	*(struct(int,*(int)))
=	O
&	O
A	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
follow	struct(int,*(int))
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
follow_A	*(struct(int,*(int)))
->	O
n	int
;	O
k	int
++	O
)	O
{	O
int	O
c	int
;	O
int	O
index	int
;	O
c	int
=	O
follow_A	*(struct(int,*(int)))
->	O
which	*(int)
[	O
k	int
]	O
;	O
if	O
(	O
c	int
==	O
'$'	O
)	O
index	int
=	O
n_symbols	int
;	O
else	O
index	int
=	O
find_symbol	(int)->(*(struct(int,int,int,struct(int,*(int)),struct(int,*(int)))))
(	O
c	int
)	O
-	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
;	O
set_action	(*(*(char)),int,int,int)->(void)
(	O
actions	*(*(char))
,	O
i	int
,	O
index	int
,	O
2	int
+	O
nC	int
+	O
(	O
prod	int
-	O
G	array(struct(int,int,*(int),*(char),*(char)))
)	O
)	O
;	O
}	O
}	O
if	O
(	O
list_contains	(*(struct(int,int,*(struct(int,int)))),int,int)->(int)
(	O
&	O
C	array(struct(int,int,*(struct(int,int))))
[	O
i	int
]	O
,	O
0	int
,	O
1	int
)	O
)	O
set_action	(*(*(char)),int,int,int)->(void)
(	O
actions	*(*(char))
,	O
i	int
,	O
n_symbols	int
,	O
1	int
)	O
;	O
}	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"/* Actions used in action_table[][] entries. */\n"	*(char)
"enum\n"	*(char)
"  {\n"	*(char)
"    err,\t/* Error. */\n"	*(char)
"    acc,\t/* Accept. */\n"	*(char)
"\n"	*(char)
"    /* Shift actions. */\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
print_enum_list	(int,int,int)->(void)
(	O
's'	O
,	O
0	int
,	O
nC	int
-	O
1	int
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n"	*(char)
"    /* Reduce actions. */\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
print_enum_list	(int,int,int)->(void)
(	O
'r'	O
,	O
1	int
,	O
n_grammar	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
"    n_states = %d,\n"	*(char)
"    n_terminals = %d,\n"	*(char)
"    n_nonterminals = %d,\n"	*(char)
"    n_reductions = %d\n"	*(char)
"  };\n"	*(char)
"\n"	*(char)
"/* Symbolic token names used in parse_table[][] second index. */\n"	*(char)
"enum\n"	*(char)
"  {\n"	*(char)
,	O
nC	int
,	O
n_terminals	int
+	O
1	int
,	O
n_nonterminals	int
,	O
n_grammar	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
{	O
struct	O
symbol	struct(int,int,int,struct(int,*(int)),struct(int,*(int)))
*	O
sym	int
=	O
&	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
;	O
int	O
j	long
;	O
if	O
(	O
sym	int
->	O
nonterminal	int
)	O
continue	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n_tokens	O
;	O
j	long
++	O
)	O
if	O
(	O
tokens	array(struct(int,*(char)))
[	O
j	long
]	O
.	O
token	int
==	O
sym	int
->	O
sym	int
)	O
break	O
;	O
assert	O
(	O
j	long
<	O
n_tokens	O
)	O
;	O
printf	(*(char))->(int)
(	O
"    %s,%*c/* %c */\n"	*(char)
,	O
tokens	array(struct(int,*(char)))
[	O
j	long
]	O
.	O
name	*(char)
,	O
25	int
-	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
tokens	array(struct(int,*(char)))
[	O
j	long
]	O
.	O
name	*(char)
)	O
,	O
' '	O
,	O
sym	int
->	O
sym	int
)	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"    lex_stop                  /* $ */\n"	*(char)
"  };\n"	*(char)
"\n"	*(char)
"/* Action table.  This is action[][] from Fig. 4.30, \"LR parsing\n"	*(char)
"   program\", in Aho, Sethi, and Ullman. */\n"	*(char)
"static const unsigned char action_table[n_states][n_terminals] =\n"	*(char)
"  {\n"	*(char)
"    /*        "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
if	O
(	O
!	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
.	O
nonterminal	int
)	O
printf	(*(char))->(int)
(	O
"  %c "	*(char)
,	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
.	O
sym	int
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"  $ */\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
int	O
j	long
;	O
printf	(*(char))->(int)
(	O
"    /*%3d */ {"	*(char)
,	O
i	int
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<=	O
n_symbols	int
;	O
j	long
++	O
)	O
if	O
(	O
j	long
==	O
n_symbols	int
||	O
!	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
j	long
]	O
.	O
nonterminal	int
)	O
{	O
char	O
buf	array(char)
[	O
16	int
]	O
;	O
if	O
(	O
j	long
!=	O
0	int
)	O
putchar	(int)->(int)
(	O
','	O
)	O
;	O
action_name	(array(char),int)->(void)
(	O
buf	array(char)
,	O
actions	*(*(char))
[	O
i	int
]	O
[	O
j	long
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%3s"	*(char)
,	O
buf	array(char)
)	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"},\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"  };\n\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
free	(*(void))->(void)
(	O
actions	*(*(char))
[	O
i	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
actions	*(*(char))
)	O
;	O
}	O
static	O
void	O
build_goto_table	()->(void)
(	O
void	O
)	O
{	O
unsigned	O
char	O
*	O
*	O
gotos	*(*(char))
;	O
int	O
i	int
;	O
gotos	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
gotos	*(*(char))
*	O
nC	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
gotos	*(*(char))
[	O
i	int
]	O
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
*	O
gotos	*(*(char))
*	O
n_nonterminals	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
gotos	*(*(char))
[	O
i	int
]	O
,	O
0	int
,	O
sizeof	O
*	O
*	O
gotos	*(*(char))
*	O
n_nonterminals	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
int	O
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n_symbols	int
;	O
j	long
++	O
)	O
{	O
struct	O
symbol	struct(int,int,int,struct(int,*(int)),struct(int,*(int)))
*	O
A	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
;	O
struct	O
list	struct(int,int,*(struct(int,int)))
list	struct(int,int,*(struct(int,int)))
;	O
A	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
=	O
&	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
j	long
]	O
;	O
if	O
(	O
A	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
nonterminal	int
)	O
{	O
int	O
k	int
;	O
calc_goto	(*(struct(int,int,*(struct(int,int)))),*(struct(int,int,*(struct(int,int)))),int)->(void)
(	O
&	O
list	struct(int,int,*(struct(int,int)))
,	O
&	O
C	array(struct(int,int,*(struct(int,int))))
[	O
i	int
]	O
,	O
A	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
sym	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
nC	int
;	O
k	int
++	O
)	O
if	O
(	O
list_equal	(*(struct(int,int,*(struct(int,int)))),*(struct(int,int,*(struct(int,int)))))->(int)
(	O
&	O
list	struct(int,int,*(struct(int,int)))
,	O
&	O
C	array(struct(int,int,*(struct(int,int))))
[	O
k	int
]	O
)	O
)	O
{	O
gotos	*(*(char))
[	O
i	int
]	O
[	O
A	*(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
->	O
nt_index	int
]	O
=	O
k	int
;	O
break	O
;	O
}	O
list_free	(*(struct(int,int,*(struct(int,int)))))->(void)
(	O
&	O
list	struct(int,int,*(struct(int,int)))
)	O
;	O
}	O
}	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"/* Go to table.  This is goto[][] from Fig. 4.30, \"LR parsing\n"	*(char)
"   program\", in Aho, Sethi, and Ullman. */\n"	*(char)
"static const unsigned char goto_table[n_states][n_nonterminals] =\n"	*(char)
"  {\n"	*(char)
"    /*        "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
if	O
(	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
.	O
nonterminal	int
)	O
printf	(*(char))->(int)
(	O
" %c "	*(char)
,	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
i	int
]	O
.	O
sym	int
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"*/\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
int	O
j	long
;	O
printf	(*(char))->(int)
(	O
"    /*%3d */ {"	*(char)
,	O
i	int
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n_symbols	int
;	O
j	long
++	O
)	O
{	O
struct	O
symbol	struct(int,int,int,struct(int,*(int)),struct(int,*(int)))
*	O
sym	int
=	O
&	O
symbols	array(struct(int,int,int,struct(int,*(int)),struct(int,*(int))))
[	O
j	long
]	O
;	O
if	O
(	O
sym	int
->	O
nonterminal	int
)	O
{	O
if	O
(	O
sym	int
->	O
nt_index	int
!=	O
0	int
)	O
putchar	(int)->(int)
(	O
','	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%2d"	*(char)
,	O
gotos	*(*(char))
[	O
i	int
]	O
[	O
sym	int
->	O
nt_index	int
]	O
)	O
;	O
}	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"},\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"  };\n\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
free	(*(void))->(void)
(	O
gotos	*(*(char))
[	O
i	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
gotos	*(*(char))
)	O
;	O
}	O
static	O
int	O
compare_strings	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
pa	*(void)
,	O
const	O
void	O
*	O
pb	*(void)
)	O
{	O
const	O
char	O
*	O
a	*(struct(int,int,*(struct(int,int))))
=	O
*	O
(	O
(	O
char	O
*	O
*	O
)	O
pa	*(void)
)	O
;	O
const	O
char	O
*	O
b	*(struct(int,int,*(struct(int,int))))
=	O
*	O
(	O
(	O
char	O
*	O
*	O
)	O
pb	*(void)
)	O
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
a	*(struct(int,int,*(struct(int,int))))
,	O
b	*(struct(int,int,*(struct(int,int))))
)	O
;	O
}	O
static	O
void	O
print_reduce_table	()->(void)
(	O
void	O
)	O
{	O
int	O
i	int
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"/* Reduction rule symbolic names (reduce_table[][2]). */\n"	*(char)
"enum\n"	*(char)
"  {\n"	*(char)
"    reduce_null"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
{	O
const	O
char	O
*	O
*	O
reductions	*(*(char))
;	O
int	O
count	int
;	O
count	int
=	O
0	int
;	O
reductions	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
reductions	*(*(char))
*	O
n_grammar	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_grammar	O
;	O
i	int
++	O
)	O
if	O
(	O
*	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
i	int
]	O
.	O
reduction	*(char)
)	O
reductions	*(*(char))
[	O
count	int
++	O
]	O
=	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
i	int
]	O
.	O
reduction	*(char)
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
reductions	*(*(char))
,	O
count	int
,	O
sizeof	O
*	O
reductions	*(*(char))
,	O
compare_strings	(*(void),*(void))->(int)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
>	O
0	int
&&	O
reductions	*(*(char))
[	O
i	int
-	O
1	int
]	O
==	O
reductions	*(*(char))
[	O
i	int
]	O
)	O
continue	O
;	O
printf	(*(char))->(int)
(	O
",\n    %s"	*(char)
,	O
reductions	*(*(char))
[	O
i	int
]	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
reductions	*(*(char))
)	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n"	*(char)
"  };\n"	*(char)
"\n"	*(char)
"/* Reduction table.  First index is reduction number, from\n"	*(char)
"   parse_table[][] above.  Second index is as follows:\n\n"	*(char)
"   reduce_table[r][0]: Number of grammar symbols on right side of\n"	*(char)
"   production.\n\n"	*(char)
"   reduce_table[r][1]: Second index into goto[][] array, "	*(char)
"corresponding\n"	*(char)
"   to the left side of the production.\n\n"	*(char)
"   reduce_table[r][2]: User-specified symbolic name for this\n"	*(char)
"   production. */\n"	*(char)
"static const unsigned char reduce_table[n_reductions][3] = \n"	*(char)
"  {\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_grammar	O
;	O
i	int
++	O
)	O
{	O
struct	O
production	struct(int,int,*(int),*(char),*(char))
*	O
prod	int
=	O
&	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
i	int
]	O
;	O
printf	(*(char))->(int)
(	O
"    {%3d,%3d, %-30s}, /* %s */\n"	*(char)
,	O
prod	int
->	O
n_right	int
,	O
find_symbol	(int)->(*(struct(int,int,int,struct(int,*(int)),struct(int,*(int)))))
(	O
prod	int
->	O
left	int
)	O
->	O
nt_index	int
,	O
*	O
prod	int
->	O
reduction	*(char)
?	O
prod	int
->	O
reduction	*(char)
:	O
"reduce_null"	*(char)
,	O
prod	int
->	O
ascii	*(char)
)	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"  };\n\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
parse_command_line	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
static	O
const	O
char	O
help	array(char)
[	O
]	O
=	O
"slr, a program to generate an SLR parser for texiweave\n"	*(char)
"\nUsage: %s [OPTION]...\n"	*(char)
"  -d, --debug           turn on debugging\n"	*(char)
"  -h, --help            print this help, then exit\n"	*(char)
"  -v, --version         show version, then exit\n"	*(char)
;	O
static	O
const	O
char	O
version	array(char)
[	O
]	O
=	O
"slr version 1.0\n"	*(char)
"\nCopyright (C) 2000 Free Software Foundation, Inc.\n"	*(char)
"This is free software; see the source for copying conditions.  "	*(char)
"There is NO\n"	*(char)
"WARRANTY; not even for MERCHANTABILITY or FITNESS FOR A "	*(char)
"PARTICULAR PURPOSE.\n\n"	*(char)
"Written by Ben Pfaff <blp@gnu.org>.\n"	*(char)
;	O
const	O
char	O
*	O
short_pgm_name	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
'/'	O
)	O
;	O
if	O
(	O
short_pgm_name	*(char)
!=	O
NULL	O
)	O
short_pgm_name	*(char)
++	O
;	O
else	O
short_pgm_name	*(char)
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
return	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
argc	int
--	O
;	O
argv	*(*(char))
++	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
argv	*(*(char))
,	O
"-d"	*(char)
)	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
argv	*(*(char))
,	O
"--debug"	*(char)
)	O
)	O
debug	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
argv	*(*(char))
,	O
"-h"	*(char)
)	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
argv	*(*(char))
,	O
"--help"	*(char)
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
help	array(char)
,	O
short_pgm_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
argv	*(*(char))
,	O
"-v"	*(char)
)	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
argv	*(*(char))
,	O
"--version"	*(char)
)	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
version	array(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
help	array(char)
,	O
short_pgm_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
initialize_G	()->(void)
(	O
void	O
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_grammar	O
;	O
i	int
++	O
)	O
{	O
int	O
j	long
;	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
i	int
]	O
.	O
left	int
=	O
(	O
unsigned	O
char	O
)	O
grammar	array(array(*(char)))
[	O
i	int
]	O
[	O
0	int
]	O
[	O
0	int
]	O
;	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
i	int
]	O
.	O
n_right	int
=	O
strlen	(*(char))->(long)
(	O
grammar	array(array(*(char)))
[	O
i	int
]	O
[	O
0	int
]	O
+	O
2	int
)	O
;	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
i	int
]	O
.	O
right	*(int)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
i	int
]	O
.	O
right	*(int)
*	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
i	int
]	O
.	O
n_right	int
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
i	int
]	O
.	O
n_right	int
;	O
j	long
++	O
)	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
i	int
]	O
.	O
right	*(int)
[	O
j	long
]	O
=	O
(	O
unsigned	O
char	O
)	O
grammar	array(array(*(char)))
[	O
i	int
]	O
[	O
0	int
]	O
[	O
j	long
+	O
2	int
]	O
;	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
i	int
]	O
.	O
ascii	*(char)
=	O
grammar	array(array(*(char)))
[	O
i	int
]	O
[	O
0	int
]	O
;	O
G	array(struct(int,int,*(int),*(char),*(char)))
[	O
i	int
]	O
.	O
reduction	*(char)
=	O
grammar	array(array(*(char)))
[	O
i	int
]	O
[	O
1	int
]	O
;	O
}	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
parse_command_line	(int,*(*(char)))->(void)
(	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
find_unique_symbols	()->(void)
(	O
)	O
;	O
initialize_G	()->(void)
(	O
)	O
;	O
build_canonical_sets	()->(void)
(	O
)	O
;	O
precalc_first	()->(void)
(	O
)	O
;	O
precalc_follow	()->(void)
(	O
)	O
;	O
build_action_table	()->(void)
(	O
)	O
;	O
build_goto_table	()->(void)
(	O
)	O
;	O
print_reduce_table	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
