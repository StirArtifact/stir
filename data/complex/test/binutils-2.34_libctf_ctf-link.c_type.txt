void	O
ctf_add_type_mapping	O
(	O
ctf_file_t	struct
*	O
src_fp	O
,	O
ctf_id_t	long
src_type	O
,	O
ctf_file_t	struct
*	O
dst_fp	O
,	O
ctf_id_t	long
dst_type	O
)	O
{	O
if	O
(	O
LCTF_TYPE_ISPARENT	O
(	O
src_fp	O
,	O
src_type	O
)	O
&&	O
src_fp	O
->	O
ctf_parent	O
)	O
src_fp	O
=	O
src_fp	O
->	O
ctf_parent	O
;	O
src_type	O
=	O
LCTF_TYPE_TO_INDEX	O
(	O
src_fp	O
,	O
src_type	O
)	O
;	O
if	O
(	O
LCTF_TYPE_ISPARENT	O
(	O
dst_fp	O
,	O
dst_type	O
)	O
&&	O
dst_fp	O
->	O
ctf_parent	O
)	O
dst_fp	O
=	O
dst_fp	O
->	O
ctf_parent	O
;	O
dst_type	O
=	O
LCTF_TYPE_TO_INDEX	O
(	O
dst_fp	O
,	O
dst_type	O
)	O
;	O
if	O
(	O
dst_fp	O
->	O
ctf_link_type_mapping	O
==	O
NULL	O
)	O
{	O
ctf_hash_fun	O
f	O
=	O
ctf_hash_type_mapping_key	O
;	O
ctf_hash_eq_fun	O
e	O
=	O
ctf_hash_eq_type_mapping_key	O
;	O
if	O
(	O
(	O
dst_fp	O
->	O
ctf_link_type_mapping	O
=	O
ctf_dynhash_create	O
(	O
f	O
,	O
e	O
,	O
free	(*(void))->(void)
,	O
NULL	O
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
}	O
ctf_link_type_mapping_key_t	O
*	O
key	O
;	O
key	O
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
struct	O
ctf_link_type_mapping_key	O
)	O
)	O
;	O
if	O
(	O
!	O
key	O
)	O
return	O
;	O
key	O
->	O
cltm_fp	O
=	O
src_fp	O
;	O
key	O
->	O
cltm_idx	O
=	O
src_type	O
;	O
ctf_dynhash_insert	O
(	O
dst_fp	O
->	O
ctf_link_type_mapping	O
,	O
key	O
,	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	long
)	O
dst_type	O
)	O
;	O
}	O
ctf_id_t	long
ctf_type_mapping	O
(	O
ctf_file_t	struct
*	O
src_fp	O
,	O
ctf_id_t	long
src_type	O
,	O
ctf_file_t	struct
*	O
*	O
dst_fp	O
)	O
{	O
ctf_link_type_mapping_key_t	O
key	O
;	O
ctf_file_t	struct
*	O
target_fp	O
=	O
*	O
dst_fp	O
;	O
ctf_id_t	long
dst_type	O
=	O
0	int
;	O
if	O
(	O
LCTF_TYPE_ISPARENT	O
(	O
src_fp	O
,	O
src_type	O
)	O
&&	O
src_fp	O
->	O
ctf_parent	O
)	O
src_fp	O
=	O
src_fp	O
->	O
ctf_parent	O
;	O
src_type	O
=	O
LCTF_TYPE_TO_INDEX	O
(	O
src_fp	O
,	O
src_type	O
)	O
;	O
key	O
.	O
cltm_fp	O
=	O
src_fp	O
;	O
key	O
.	O
cltm_idx	O
=	O
src_type	O
;	O
if	O
(	O
target_fp	O
->	O
ctf_link_type_mapping	O
)	O
dst_type	O
=	O
(	O
uintptr_t	long
)	O
ctf_dynhash_lookup	O
(	O
target_fp	O
->	O
ctf_link_type_mapping	O
,	O
&	O
key	O
)	O
;	O
if	O
(	O
dst_type	O
!=	O
0	int
)	O
{	O
dst_type	O
=	O
LCTF_INDEX_TO_TYPE	O
(	O
target_fp	O
,	O
dst_type	O
,	O
target_fp	O
->	O
ctf_parent	O
!=	O
NULL	O
)	O
;	O
*	O
dst_fp	O
=	O
target_fp	O
;	O
return	O
dst_type	O
;	O
}	O
if	O
(	O
target_fp	O
->	O
ctf_parent	O
)	O
target_fp	O
=	O
target_fp	O
->	O
ctf_parent	O
;	O
else	O
return	O
0	int
;	O
if	O
(	O
target_fp	O
->	O
ctf_link_type_mapping	O
)	O
dst_type	O
=	O
(	O
uintptr_t	long
)	O
ctf_dynhash_lookup	O
(	O
target_fp	O
->	O
ctf_link_type_mapping	O
,	O
&	O
key	O
)	O
;	O
if	O
(	O
dst_type	O
)	O
dst_type	O
=	O
LCTF_INDEX_TO_TYPE	O
(	O
target_fp	O
,	O
dst_type	O
,	O
target_fp	O
->	O
ctf_parent	O
!=	O
NULL	O
)	O
;	O
*	O
dst_fp	O
=	O
target_fp	O
;	O
return	O
dst_type	O
;	O
}	O
static	O
void	O
ctf_arc_close_thunk	O
(	O
void	O
*	O
arc	O
)	O
{	O
ctf_arc_close	(*(struct))->(void)
(	O
(	O
ctf_archive_t	struct
*	O
)	O
arc	O
)	O
;	O
}	O
static	O
void	O
ctf_file_close_thunk	O
(	O
void	O
*	O
file	*(struct)
)	O
{	O
ctf_file_close	(*(struct))->(void)
(	O
(	O
ctf_file_t	struct
*	O
)	O
file	*(struct)
)	O
;	O
}	O
int	O
ctf_link_add_ctf	(*(struct),*(struct),*(char))->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_archive_t	struct
*	O
ctf	O
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
char	O
*	O
dupname	O
=	O
NULL	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_link_outputs	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_LINKADDEDLATE	int
)	O
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_link_inputs	O
==	O
NULL	O
)	O
fp	*(struct)
->	O
ctf_link_inputs	O
=	O
ctf_dynhash_create	O
(	O
ctf_hash_string	O
,	O
ctf_hash_eq_string	O
,	O
free	(*(void))->(void)
,	O
ctf_arc_close_thunk	O
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_link_inputs	O
==	O
NULL	O
)	O
goto	O
oom	O
;	O
if	O
(	O
(	O
dupname	O
=	O
strdup	O
(	O
name	*(char)
)	O
)	O
==	O
NULL	O
)	O
goto	O
oom	O
;	O
if	O
(	O
ctf_dynhash_insert	O
(	O
fp	*(struct)
->	O
ctf_link_inputs	O
,	O
dupname	O
,	O
ctf	O
)	O
<	O
0	int
)	O
goto	O
oom	O
;	O
return	O
0	int
;	O
oom	O
:	O
free	(*(void))->(void)
(	O
fp	*(struct)
->	O
ctf_link_inputs	O
)	O
;	O
fp	*(struct)
->	O
ctf_link_inputs	O
=	O
NULL	O
;	O
free	(*(void))->(void)
(	O
dupname	O
)	O
;	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ENOMEM	O
)	O
)	O
;	O
}	O
static	O
ctf_file_t	struct
*	O
ctf_create_per_cu	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
char	O
*	O
filename	*(char)
,	O
const	O
char	O
*	O
cuname	O
)	O
{	O
ctf_file_t	struct
*	O
cu_fp	O
;	O
const	O
char	O
*	O
ctf_name	O
=	O
NULL	O
;	O
char	O
*	O
dynname	O
=	O
NULL	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_link_cu_mapping	O
)	O
{	O
if	O
(	O
(	O
(	O
ctf_name	O
=	O
ctf_dynhash_lookup	O
(	O
fp	*(struct)
->	O
ctf_link_cu_mapping	O
,	O
filename	*(char)
)	O
)	O
==	O
NULL	O
)	O
&&	O
(	O
(	O
ctf_name	O
=	O
ctf_dynhash_lookup	O
(	O
fp	*(struct)
->	O
ctf_link_cu_mapping	O
,	O
cuname	O
)	O
)	O
==	O
NULL	O
)	O
)	O
ctf_name	O
=	O
filename	*(char)
;	O
}	O
if	O
(	O
ctf_name	O
==	O
NULL	O
)	O
ctf_name	O
=	O
filename	*(char)
;	O
if	O
(	O
(	O
cu_fp	O
=	O
ctf_dynhash_lookup	O
(	O
fp	*(struct)
->	O
ctf_link_outputs	O
,	O
ctf_name	O
)	O
)	O
==	O
NULL	O
)	O
{	O
int	O
err	long
;	O
if	O
(	O
(	O
cu_fp	O
=	O
ctf_create	(*(int))->(*(struct))
(	O
&	O
err	long
)	O
)	O
==	O
NULL	O
)	O
{	O
ctf_dprintf	O
(	O
"Cannot create per-CU CTF archive for CU %s from "	*(char)
"input file %s: %s\n"	*(char)
,	O
cuname	O
,	O
filename	*(char)
,	O
ctf_errmsg	(int)->(*(char))
(	O
err	long
)	O
)	O
;	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
err	long
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
dynname	O
=	O
strdup	O
(	O
ctf_name	O
)	O
)	O
==	O
NULL	O
)	O
goto	O
oom	O
;	O
if	O
(	O
ctf_dynhash_insert	O
(	O
fp	*(struct)
->	O
ctf_link_outputs	O
,	O
dynname	O
,	O
cu_fp	O
)	O
<	O
0	int
)	O
goto	O
oom	O
;	O
ctf_import	(*(struct),*(struct))->(int)
(	O
cu_fp	O
,	O
fp	*(struct)
)	O
;	O
ctf_cuname_set	(*(struct),*(char))->(int)
(	O
cu_fp	O
,	O
cuname	O
)	O
;	O
ctf_parent_name_set	(*(struct),*(char))->(int)
(	O
cu_fp	O
,	O
_CTF_SECTION	O
)	O
;	O
}	O
return	O
cu_fp	O
;	O
oom	O
:	O
free	(*(void))->(void)
(	O
dynname	O
)	O
;	O
ctf_file_close	(*(struct))->(void)
(	O
cu_fp	O
)	O
;	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ENOMEM	O
)	O
;	O
return	O
NULL	O
;	O
}	O
int	O
ctf_link_add_cu_mapping	(*(struct),*(char),*(char))->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
char	O
*	O
from	*(char)
,	O
const	O
char	O
*	O
to	*(char)
)	O
{	O
int	O
err	long
;	O
char	O
*	O
f	O
,	O
*	O
t	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_link_cu_mapping	O
==	O
NULL	O
)	O
fp	*(struct)
->	O
ctf_link_cu_mapping	O
=	O
ctf_dynhash_create	O
(	O
ctf_hash_string	O
,	O
ctf_hash_eq_string	O
,	O
free	(*(void))->(void)
,	O
free	(*(void))->(void)
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_link_cu_mapping	O
==	O
NULL	O
)	O
return	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ENOMEM	O
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_link_outputs	O
==	O
NULL	O
)	O
fp	*(struct)
->	O
ctf_link_outputs	O
=	O
ctf_dynhash_create	O
(	O
ctf_hash_string	O
,	O
ctf_hash_eq_string	O
,	O
free	(*(void))->(void)
,	O
ctf_file_close_thunk	O
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_link_outputs	O
==	O
NULL	O
)	O
return	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ENOMEM	O
)	O
;	O
f	O
=	O
strdup	O
(	O
from	*(char)
)	O
;	O
t	O
=	O
strdup	O
(	O
to	*(char)
)	O
;	O
if	O
(	O
!	O
f	O
||	O
!	O
t	O
)	O
goto	O
oom	O
;	O
if	O
(	O
ctf_create_per_cu	O
(	O
fp	*(struct)
,	O
t	O
,	O
t	O
)	O
==	O
NULL	O
)	O
goto	O
oom_noerrno	O
;	O
err	long
=	O
ctf_dynhash_insert	O
(	O
fp	*(struct)
->	O
ctf_link_cu_mapping	O
,	O
f	O
,	O
t	O
)	O
;	O
if	O
(	O
err	long
)	O
{	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
err	long
)	O
;	O
goto	O
oom_noerrno	O
;	O
}	O
return	O
0	int
;	O
oom	O
:	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
errno	O
)	O
;	O
oom_noerrno	O
:	O
free	(*(void))->(void)
(	O
f	O
)	O
;	O
free	(*(void))->(void)
(	O
t	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
void	O
ctf_link_set_memb_name_changer	(*(struct),*((*(struct),*(char),*(void))->(*(char))),*(void))->(void)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_link_memb_name_changer_f	(*(struct),*(char),*(void))->(*(char))
*	O
changer	O
,	O
void	O
*	O
arg	*(void)
)	O
{	O
fp	*(struct)
->	O
ctf_link_memb_name_changer	O
=	O
changer	O
;	O
fp	*(struct)
->	O
ctf_link_memb_name_changer_arg	O
=	O
arg	*(void)
;	O
}	O
typedef	O
struct	O
ctf_link_in_member_cb_arg	O
{	O
ctf_file_t	struct
*	O
out_fp	O
;	O
const	O
char	O
*	O
file_name	O
;	O
ctf_file_t	struct
*	O
in_fp	O
;	O
ctf_file_t	struct
*	O
main_input_fp	O
;	O
const	O
char	O
*	O
cu_name	O
;	O
char	O
*	O
arcname	O
;	O
int	O
done_main_member	O
;	O
int	O
share_mode	int
;	O
int	O
in_input_cu_file	O
;	O
}	O
ctf_link_in_member_cb_arg_t	O
;	O
static	O
int	O
ctf_link_one_type	O
(	O
ctf_id_t	long
type	long
,	O
int	O
isroot	O
_libctf_unused_	O
,	O
void	O
*	O
arg_	O
)	O
{	O
ctf_link_in_member_cb_arg_t	O
*	O
arg	*(void)
=	O
(	O
ctf_link_in_member_cb_arg_t	O
*	O
)	O
arg_	O
;	O
ctf_file_t	struct
*	O
per_cu_out_fp	O
;	O
int	O
err	long
;	O
if	O
(	O
arg	*(void)
->	O
share_mode	int
!=	O
CTF_LINK_SHARE_UNCONFLICTED	O
)	O
{	O
ctf_dprintf	O
(	O
"Share-duplicated mode not yet implemented.\n"	*(char)
)	O
;	O
return	O
ctf_set_errno	O
(	O
arg	*(void)
->	O
out_fp	O
,	O
ECTF_NOTYET	int
)	O
;	O
}	O
if	O
(	O
!	O
arg	*(void)
->	O
in_input_cu_file	O
)	O
{	O
if	O
(	O
ctf_add_type	(*(struct),*(struct),long)->(long)
(	O
arg	*(void)
->	O
out_fp	O
,	O
arg	*(void)
->	O
in_fp	O
,	O
type	long
)	O
!=	O
CTF_ERR	O
)	O
return	O
0	int
;	O
err	long
=	O
ctf_errno	(*(struct))->(int)
(	O
arg	*(void)
->	O
out_fp	O
)	O
;	O
if	O
(	O
err	long
!=	O
ECTF_CONFLICT	int
)	O
{	O
if	O
(	O
err	long
!=	O
ECTF_NONREPRESENTABLE	int
)	O
ctf_dprintf	O
(	O
"Cannot link type %lx from archive member %s, input file %s "	*(char)
"into output link: %s\n"	*(char)
,	O
type	long
,	O
arg	*(void)
->	O
arcname	O
,	O
arg	*(void)
->	O
file_name	O
,	O
ctf_errmsg	(int)->(*(char))
(	O
err	long
)	O
)	O
;	O
return	O
0	int
;	O
}	O
ctf_set_errno	O
(	O
arg	*(void)
->	O
out_fp	O
,	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
per_cu_out_fp	O
=	O
ctf_create_per_cu	O
(	O
arg	*(void)
->	O
out_fp	O
,	O
arg	*(void)
->	O
file_name	O
,	O
arg	*(void)
->	O
cu_name	O
)	O
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ctf_add_type	(*(struct),*(struct),long)->(long)
(	O
per_cu_out_fp	O
,	O
arg	*(void)
->	O
in_fp	O
,	O
type	long
)	O
!=	O
CTF_ERR	O
)	O
return	O
0	int
;	O
err	long
=	O
ctf_errno	(*(struct))->(int)
(	O
per_cu_out_fp	O
)	O
;	O
if	O
(	O
err	long
!=	O
ECTF_NONREPRESENTABLE	int
)	O
ctf_dprintf	O
(	O
"Cannot link type %lx from CTF archive member %s, input file %s "	*(char)
"into output per-CU CTF archive member %s: %s: skipped\n"	*(char)
,	O
type	long
,	O
arg	*(void)
->	O
arcname	O
,	O
arg	*(void)
->	O
file_name	O
,	O
arg	*(void)
->	O
arcname	O
,	O
ctf_errmsg	(int)->(*(char))
(	O
err	long
)	O
)	O
;	O
if	O
(	O
err	long
==	O
ECTF_CONFLICT	int
)	O
ctf_set_errno	O
(	O
arg	*(void)
->	O
out_fp	O
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
check_variable	O
(	O
const	O
char	O
*	O
name	*(char)
,	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_id_t	long
type	long
,	O
ctf_dvdef_t	O
*	O
*	O
out_dvd	O
)	O
{	O
ctf_dvdef_t	O
*	O
dvd	O
;	O
dvd	O
=	O
ctf_dynhash_lookup	O
(	O
fp	*(struct)
->	O
ctf_dvhash	O
,	O
name	*(char)
)	O
;	O
*	O
out_dvd	O
=	O
dvd	O
;	O
if	O
(	O
!	O
dvd	O
)	O
return	O
1	int
;	O
if	O
(	O
dvd	O
->	O
dvd_type	O
!=	O
type	long
)	O
{	O
ctf_dprintf	O
(	O
"Inexpressible duplicate variable %s skipped.\n"	*(char)
,	O
name	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
ctf_link_one_variable	O
(	O
const	O
char	O
*	O
name	*(char)
,	O
ctf_id_t	long
type	long
,	O
void	O
*	O
arg_	O
)	O
{	O
ctf_link_in_member_cb_arg_t	O
*	O
arg	*(void)
=	O
(	O
ctf_link_in_member_cb_arg_t	O
*	O
)	O
arg_	O
;	O
ctf_file_t	struct
*	O
per_cu_out_fp	O
;	O
ctf_id_t	long
dst_type	O
=	O
0	int
;	O
ctf_file_t	struct
*	O
check_fp	O
;	O
ctf_dvdef_t	O
*	O
dvd	O
;	O
check_fp	O
=	O
arg	*(void)
->	O
out_fp	O
;	O
dst_type	O
=	O
ctf_type_mapping	O
(	O
arg	*(void)
->	O
in_fp	O
,	O
type	long
,	O
&	O
check_fp	O
)	O
;	O
if	O
(	O
dst_type	O
!=	O
0	int
)	O
{	O
if	O
(	O
check_fp	O
==	O
arg	*(void)
->	O
out_fp	O
)	O
{	O
if	O
(	O
check_variable	O
(	O
name	*(char)
,	O
check_fp	O
,	O
dst_type	O
,	O
&	O
dvd	O
)	O
)	O
{	O
if	O
(	O
ctf_add_variable	(*(struct),*(char),long)->(int)
(	O
check_fp	O
,	O
name	*(char)
,	O
dst_type	O
)	O
<	O
0	int
)	O
return	O
(	O
ctf_set_errno	O
(	O
arg	*(void)
->	O
out_fp	O
,	O
ctf_errno	(*(struct))->(int)
(	O
check_fp	O
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
dvd	O
&&	O
dvd	O
->	O
dvd_type	O
==	O
type	long
)	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
(	O
per_cu_out_fp	O
=	O
ctf_create_per_cu	O
(	O
arg	*(void)
->	O
out_fp	O
,	O
arg	*(void)
->	O
file_name	O
,	O
arg	*(void)
->	O
cu_name	O
)	O
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
dst_type	O
==	O
0	int
)	O
{	O
check_fp	O
=	O
per_cu_out_fp	O
;	O
dst_type	O
=	O
ctf_type_mapping	O
(	O
arg	*(void)
->	O
in_fp	O
,	O
type	long
,	O
&	O
check_fp	O
)	O
;	O
if	O
(	O
dst_type	O
==	O
0	int
)	O
{	O
ctf_dprintf	O
(	O
"Type %lx for variable %s in input file %s not "	*(char)
"found: skipped.\n"	*(char)
,	O
type	long
,	O
name	*(char)
,	O
arg	*(void)
->	O
file_name	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
check_variable	O
(	O
name	*(char)
,	O
per_cu_out_fp	O
,	O
dst_type	O
,	O
&	O
dvd	O
)	O
)	O
if	O
(	O
ctf_add_variable	(*(struct),*(char),long)->(int)
(	O
per_cu_out_fp	O
,	O
name	*(char)
,	O
dst_type	O
)	O
<	O
0	int
)	O
return	O
(	O
ctf_set_errno	O
(	O
arg	*(void)
->	O
out_fp	O
,	O
ctf_errno	(*(struct))->(int)
(	O
per_cu_out_fp	O
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ctf_link_one_input_archive_member	O
(	O
ctf_file_t	struct
*	O
in_fp	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
void	O
*	O
arg_	O
)	O
{	O
ctf_link_in_member_cb_arg_t	O
*	O
arg	*(void)
=	O
(	O
ctf_link_in_member_cb_arg_t	O
*	O
)	O
arg_	O
;	O
int	O
err	long
=	O
0	int
;	O
if	O
(	O
strcmp	O
(	O
name	*(char)
,	O
_CTF_SECTION	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
arg	*(void)
->	O
done_main_member	O
)	O
return	O
0	int
;	O
arg	*(void)
->	O
arcname	O
=	O
strdup	O
(	O
".ctf."	*(char)
)	O
;	O
if	O
(	O
arg	*(void)
->	O
arcname	O
)	O
{	O
char	O
*	O
new_name	O
;	O
new_name	O
=	O
ctf_str_append	O
(	O
arg	*(void)
->	O
arcname	O
,	O
arg	*(void)
->	O
file_name	O
)	O
;	O
if	O
(	O
new_name	O
)	O
arg	*(void)
->	O
arcname	O
=	O
new_name	O
;	O
else	O
free	(*(void))->(void)
(	O
arg	*(void)
->	O
arcname	O
)	O
;	O
}	O
}	O
else	O
{	O
arg	*(void)
->	O
arcname	O
=	O
strdup	O
(	O
name	*(char)
)	O
;	O
ctf_import	(*(struct),*(struct))->(int)
(	O
in_fp	O
,	O
arg	*(void)
->	O
main_input_fp	O
)	O
;	O
arg	*(void)
->	O
in_input_cu_file	O
=	O
1	int
;	O
}	O
if	O
(	O
!	O
arg	*(void)
->	O
arcname	O
)	O
return	O
ctf_set_errno	O
(	O
in_fp	O
,	O
ENOMEM	O
)	O
;	O
arg	*(void)
->	O
cu_name	O
=	O
name	*(char)
;	O
if	O
(	O
strncmp	O
(	O
arg	*(void)
->	O
cu_name	O
,	O
".ctf."	*(char)
,	O
strlen	O
(	O
".ctf."	*(char)
)	O
)	O
==	O
0	int
)	O
arg	*(void)
->	O
cu_name	O
+=	O
strlen	O
(	O
".ctf."	*(char)
)	O
;	O
arg	*(void)
->	O
in_fp	O
=	O
in_fp	O
;	O
if	O
(	O
(	O
err	long
=	O
ctf_type_iter_all	(*(struct),*((long,int,*(void))->(int)),*(void))->(int)
(	O
in_fp	O
,	O
ctf_link_one_type	O
,	O
arg	*(void)
)	O
)	O
>	O
-	O
1	int
)	O
err	long
=	O
ctf_variable_iter	(*(struct),*((*(char),long,*(void))->(int)),*(void))->(int)
(	O
in_fp	O
,	O
ctf_link_one_variable	O
,	O
arg	*(void)
)	O
;	O
arg	*(void)
->	O
in_input_cu_file	O
=	O
0	int
;	O
free	(*(void))->(void)
(	O
arg	*(void)
->	O
arcname	O
)	O
;	O
if	O
(	O
err	long
<	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
empty_link_type_mapping	O
(	O
void	O
*	O
key	O
_libctf_unused_	O
,	O
void	O
*	O
value	int
,	O
void	O
*	O
arg	*(void)
_libctf_unused_	O
)	O
{	O
ctf_file_t	struct
*	O
fp	*(struct)
=	O
(	O
ctf_file_t	struct
*	O
)	O
value	int
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_link_type_mapping	O
)	O
ctf_dynhash_empty	O
(	O
fp	*(struct)
->	O
ctf_link_type_mapping	O
)	O
;	O
}	O
static	O
void	O
ctf_link_one_input_archive	O
(	O
void	O
*	O
key	O
,	O
void	O
*	O
value	int
,	O
void	O
*	O
arg_	O
)	O
{	O
const	O
char	O
*	O
file_name	O
=	O
(	O
const	O
char	O
*	O
)	O
key	O
;	O
ctf_archive_t	struct
*	O
arc	O
=	O
(	O
ctf_archive_t	struct
*	O
)	O
value	int
;	O
ctf_link_in_member_cb_arg_t	O
*	O
arg	*(void)
=	O
(	O
ctf_link_in_member_cb_arg_t	O
*	O
)	O
arg_	O
;	O
int	O
err	long
;	O
arg	*(void)
->	O
file_name	O
=	O
file_name	O
;	O
arg	*(void)
->	O
done_main_member	O
=	O
0	int
;	O
if	O
(	O
(	O
arg	*(void)
->	O
main_input_fp	O
=	O
ctf_arc_open_by_name	(*(struct),*(char),*(int))->(*(struct))
(	O
arc	O
,	O
NULL	O
,	O
&	O
err	long
)	O
)	O
==	O
NULL	O
)	O
if	O
(	O
err	long
!=	O
ECTF_ARNNAME	int
)	O
{	O
ctf_dprintf	O
(	O
"Cannot open main archive member in input file %s in the "	*(char)
"link: skipping: %s.\n"	*(char)
,	O
arg	*(void)
->	O
file_name	O
,	O
ctf_errmsg	(int)->(*(char))
(	O
err	long
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
ctf_link_one_input_archive_member	O
(	O
arg	*(void)
->	O
main_input_fp	O
,	O
_CTF_SECTION	O
,	O
arg	*(void)
)	O
<	O
0	int
)	O
{	O
ctf_file_close	(*(struct))->(void)
(	O
arg	*(void)
->	O
main_input_fp	O
)	O
;	O
return	O
;	O
}	O
arg	*(void)
->	O
done_main_member	O
=	O
1	int
;	O
if	O
(	O
ctf_archive_iter	(*(struct),*((*(struct),*(char),*(void))->(int)),*(void))->(int)
(	O
arc	O
,	O
ctf_link_one_input_archive_member	O
,	O
arg	*(void)
)	O
<	O
0	int
)	O
ctf_dprintf	O
(	O
"Cannot traverse archive in input file %s: link "	*(char)
"cannot continue: %s.\n"	*(char)
,	O
arg	*(void)
->	O
file_name	O
,	O
ctf_errmsg	(int)->(*(char))
(	O
ctf_errno	(*(struct))->(int)
(	O
arg	*(void)
->	O
out_fp	O
)	O
)	O
)	O
;	O
else	O
{	O
ctf_set_errno	O
(	O
arg	*(void)
->	O
out_fp	O
,	O
0	int
)	O
;	O
}	O
ctf_file_close	(*(struct))->(void)
(	O
arg	*(void)
->	O
main_input_fp	O
)	O
;	O
if	O
(	O
arg	*(void)
->	O
out_fp	O
->	O
ctf_link_type_mapping	O
)	O
ctf_dynhash_empty	O
(	O
arg	*(void)
->	O
out_fp	O
->	O
ctf_link_type_mapping	O
)	O
;	O
ctf_dynhash_iter	O
(	O
arg	*(void)
->	O
out_fp	O
->	O
ctf_link_outputs	O
,	O
empty_link_type_mapping	O
,	O
NULL	O
)	O
;	O
}	O
int	O
ctf_link	(*(struct),int)->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
int	O
share_mode	int
)	O
{	O
ctf_link_in_member_cb_arg_t	O
arg	*(void)
;	O
memset	O
(	O
&	O
arg	*(void)
,	O
0	int
,	O
sizeof	O
(	O
struct	O
ctf_link_in_member_cb_arg	O
)	O
)	O
;	O
arg	*(void)
.	O
out_fp	O
=	O
fp	*(struct)
;	O
arg	*(void)
.	O
share_mode	int
=	O
share_mode	int
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_link_inputs	O
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_link_outputs	O
==	O
NULL	O
)	O
fp	*(struct)
->	O
ctf_link_outputs	O
=	O
ctf_dynhash_create	O
(	O
ctf_hash_string	O
,	O
ctf_hash_eq_string	O
,	O
free	(*(void))->(void)
,	O
ctf_file_close_thunk	O
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_link_outputs	O
==	O
NULL	O
)	O
return	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ENOMEM	O
)	O
;	O
ctf_dynhash_iter	O
(	O
fp	*(struct)
->	O
ctf_link_inputs	O
,	O
ctf_link_one_input_archive	O
,	O
&	O
arg	*(void)
)	O
;	O
if	O
(	O
ctf_errno	(*(struct))->(int)
(	O
fp	*(struct)
)	O
!=	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
ctf_link_out_string_cb_arg	O
{	O
const	O
char	O
*	O
str	O
;	O
uint32_t	int
offset	long
;	O
int	O
err	long
;	O
}	O
ctf_link_out_string_cb_arg_t	O
;	O
static	O
void	O
ctf_link_intern_extern_string	O
(	O
void	O
*	O
key	O
_libctf_unused_	O
,	O
void	O
*	O
value	int
,	O
void	O
*	O
arg_	O
)	O
{	O
ctf_file_t	struct
*	O
fp	*(struct)
=	O
(	O
ctf_file_t	struct
*	O
)	O
value	int
;	O
ctf_link_out_string_cb_arg_t	O
*	O
arg	*(void)
=	O
(	O
ctf_link_out_string_cb_arg_t	O
*	O
)	O
arg_	O
;	O
fp	*(struct)
->	O
ctf_flags	O
|=	O
LCTF_DIRTY	O
;	O
if	O
(	O
!	O
ctf_str_add_external	O
(	O
fp	*(struct)
,	O
arg	*(void)
->	O
str	O
,	O
arg	*(void)
->	O
offset	long
)	O
)	O
arg	*(void)
->	O
err	long
=	O
ENOMEM	O
;	O
}	O
int	O
ctf_link_add_strtab	(*(struct),*((*(int),*(void))->(*(char))),*(void))->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_link_strtab_string_f	(*(int),*(void))->(*(char))
*	O
add_string	O
,	O
void	O
*	O
arg	*(void)
)	O
{	O
const	O
char	O
*	O
str	O
;	O
uint32_t	int
offset	long
;	O
int	O
err	long
=	O
0	int
;	O
while	O
(	O
(	O
str	O
=	O
add_string	O
(	O
&	O
offset	long
,	O
arg	*(void)
)	O
)	O
!=	O
NULL	O
)	O
{	O
ctf_link_out_string_cb_arg_t	O
iter_arg	O
=	O
{	O
str	O
,	O
offset	long
,	O
0	int
}	O
;	O
fp	*(struct)
->	O
ctf_flags	O
|=	O
LCTF_DIRTY	O
;	O
if	O
(	O
!	O
ctf_str_add_external	O
(	O
fp	*(struct)
,	O
str	O
,	O
offset	long
)	O
)	O
err	long
=	O
ENOMEM	O
;	O
ctf_dynhash_iter	O
(	O
fp	*(struct)
->	O
ctf_link_outputs	O
,	O
ctf_link_intern_extern_string	O
,	O
&	O
iter_arg	O
)	O
;	O
if	O
(	O
iter_arg	O
.	O
err	long
)	O
err	long
=	O
iter_arg	O
.	O
err	long
;	O
}	O
return	O
-	O
err	long
;	O
}	O
int	O
ctf_link_shuffle_syms	(*(struct),*((*(struct(*`,int,int,int)),*(void))->(*(struct(*`,int,int,int)))),*(void))->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
_libctf_unused_	O
,	O
ctf_link_iter_symbol_f	(*(struct(*(char),int,int,int)),*(void))->(*(struct(*(char),int,int,int)))
*	O
add_sym	O
_libctf_unused_	O
,	O
void	O
*	O
arg	*(void)
_libctf_unused_	O
)	O
{	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
ctf_name_list_accum_cb_arg	O
{	O
char	O
*	O
*	O
names	O
;	O
ctf_file_t	struct
*	O
fp	*(struct)
;	O
ctf_file_t	struct
*	O
*	O
files	O
;	O
size_t	long
i	*(struct)
;	O
char	O
*	O
*	O
dynames	O
;	O
size_t	long
ndynames	O
;	O
}	O
ctf_name_list_accum_cb_arg_t	O
;	O
static	O
void	O
ctf_accumulate_archive_names	O
(	O
void	O
*	O
key	O
,	O
void	O
*	O
value	int
,	O
void	O
*	O
arg_	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
key	O
;	O
ctf_file_t	struct
*	O
fp	*(struct)
=	O
(	O
ctf_file_t	struct
*	O
)	O
value	int
;	O
char	O
*	O
*	O
names	O
;	O
ctf_file_t	struct
*	O
*	O
files	O
;	O
ctf_name_list_accum_cb_arg_t	O
*	O
arg	*(void)
=	O
(	O
ctf_name_list_accum_cb_arg_t	O
*	O
)	O
arg_	O
;	O
if	O
(	O
(	O
names	O
=	O
realloc	(*(void),long)->(*(void))
(	O
arg	*(void)
->	O
names	O
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
++	O
(	O
arg	*(void)
->	O
i	*(struct)
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
(	O
arg	*(void)
->	O
i	*(struct)
)	O
--	O
;	O
ctf_set_errno	O
(	O
arg	*(void)
->	O
fp	*(struct)
,	O
ENOMEM	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
files	O
=	O
realloc	(*(void),long)->(*(void))
(	O
arg	*(void)
->	O
files	O
,	O
sizeof	O
(	O
ctf_file_t	struct
*	O
)	O
*	O
arg	*(void)
->	O
i	*(struct)
)	O
)	O
==	O
NULL	O
)	O
{	O
(	O
arg	*(void)
->	O
i	*(struct)
)	O
--	O
;	O
ctf_set_errno	O
(	O
arg	*(void)
->	O
fp	*(struct)
,	O
ENOMEM	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
fp	*(struct)
->	O
ctf_link_memb_name_changer	O
)	O
{	O
char	O
*	O
*	O
dynames	O
;	O
char	O
*	O
dyname	O
;	O
void	O
*	O
nc_arg	O
=	O
fp	*(struct)
->	O
ctf_link_memb_name_changer_arg	O
;	O
dyname	O
=	O
fp	*(struct)
->	O
ctf_link_memb_name_changer	O
(	O
fp	*(struct)
,	O
name	*(char)
,	O
nc_arg	O
)	O
;	O
if	O
(	O
dyname	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
dynames	O
=	O
realloc	(*(void),long)->(*(void))
(	O
arg	*(void)
->	O
dynames	O
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
++	O
(	O
arg	*(void)
->	O
ndynames	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
(	O
arg	*(void)
->	O
ndynames	O
)	O
--	O
;	O
ctf_set_errno	O
(	O
arg	*(void)
->	O
fp	*(struct)
,	O
ENOMEM	O
)	O
;	O
return	O
;	O
}	O
arg	*(void)
->	O
dynames	O
=	O
dynames	O
;	O
name	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
dyname	O
;	O
}	O
}	O
arg	*(void)
->	O
names	O
=	O
names	O
;	O
arg	*(void)
->	O
names	O
[	O
(	O
arg	*(void)
->	O
i	*(struct)
)	O
-	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
name	*(char)
;	O
arg	*(void)
->	O
files	O
=	O
files	O
;	O
arg	*(void)
->	O
files	O
[	O
(	O
arg	*(void)
->	O
i	*(struct)
)	O
-	O
1	int
]	O
=	O
fp	*(struct)
;	O
}	O
static	O
void	O
ctf_change_parent_name	O
(	O
void	O
*	O
key	O
_libctf_unused_	O
,	O
void	O
*	O
value	int
,	O
void	O
*	O
arg	*(void)
)	O
{	O
ctf_file_t	struct
*	O
fp	*(struct)
=	O
(	O
ctf_file_t	struct
*	O
)	O
value	int
;	O
const	O
char	O
*	O
name	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
arg	*(void)
;	O
ctf_parent_name_set	(*(struct),*(char))->(int)
(	O
fp	*(struct)
,	O
name	*(char)
)	O
;	O
}	O
unsigned	O
char	O
*	O
ctf_link_write	(*(struct),*(long),long)->(*(char))
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
size_t	long
*	O
size	long
,	O
size_t	long
threshold	long
)	O
{	O
ctf_name_list_accum_cb_arg_t	O
arg	*(void)
;	O
char	O
*	O
*	O
names	O
;	O
char	O
*	O
transformed_name	O
=	O
NULL	O
;	O
ctf_file_t	struct
*	O
*	O
files	O
;	O
FILE	struct
*	O
f	O
=	O
NULL	O
;	O
int	O
err	long
;	O
long	O
fsize	O
;	O
const	O
char	O
*	O
errloc	O
;	O
unsigned	O
char	O
*	O
buf	*(void)
=	O
NULL	O
;	O
memset	O
(	O
&	O
arg	*(void)
,	O
0	int
,	O
sizeof	O
(	O
ctf_name_list_accum_cb_arg_t	O
)	O
)	O
;	O
arg	*(void)
.	O
fp	*(struct)
=	O
fp	*(struct)
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_link_outputs	O
)	O
{	O
ctf_dynhash_iter	O
(	O
fp	*(struct)
->	O
ctf_link_outputs	O
,	O
ctf_accumulate_archive_names	O
,	O
&	O
arg	*(void)
)	O
;	O
if	O
(	O
ctf_errno	(*(struct))->(int)
(	O
fp	*(struct)
)	O
<	O
0	int
)	O
{	O
errloc	O
=	O
"hash creation"	*(char)
;	O
goto	O
err	long
;	O
}	O
}	O
if	O
(	O
arg	*(void)
.	O
i	*(struct)
==	O
0	int
)	O
return	O
ctf_write_mem	(*(struct),*(long),long)->(*(char))
(	O
fp	*(struct)
,	O
size	long
,	O
threshold	long
)	O
;	O
if	O
(	O
(	O
names	O
=	O
realloc	(*(void),long)->(*(void))
(	O
arg	*(void)
.	O
names	O
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
arg	*(void)
.	O
i	*(struct)
+	O
1	int
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
errloc	O
=	O
"name reallocation"	*(char)
;	O
goto	O
err_no	O
;	O
}	O
arg	*(void)
.	O
names	O
=	O
names	O
;	O
memmove	O
(	O
&	O
(	O
arg	*(void)
.	O
names	O
[	O
1	int
]	O
)	O
,	O
arg	*(void)
.	O
names	O
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
arg	*(void)
.	O
i	*(struct)
)	O
)	O
;	O
arg	*(void)
.	O
names	O
[	O
0	int
]	O
=	O
(	O
char	O
*	O
)	O
_CTF_SECTION	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_link_memb_name_changer	O
)	O
{	O
void	O
*	O
nc_arg	O
=	O
fp	*(struct)
->	O
ctf_link_memb_name_changer_arg	O
;	O
transformed_name	O
=	O
fp	*(struct)
->	O
ctf_link_memb_name_changer	O
(	O
fp	*(struct)
,	O
_CTF_SECTION	O
,	O
nc_arg	O
)	O
;	O
if	O
(	O
transformed_name	O
!=	O
NULL	O
)	O
{	O
arg	*(void)
.	O
names	O
[	O
0	int
]	O
=	O
transformed_name	O
;	O
ctf_dynhash_iter	O
(	O
fp	*(struct)
->	O
ctf_link_outputs	O
,	O
ctf_change_parent_name	O
,	O
transformed_name	O
)	O
;	O
}	O
}	O
if	O
(	O
(	O
files	O
=	O
realloc	(*(void),long)->(*(void))
(	O
arg	*(void)
.	O
files	O
,	O
sizeof	O
(	O
struct	O
ctf_file	O
*	O
)	O
*	O
(	O
arg	*(void)
.	O
i	*(struct)
+	O
1	int
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
errloc	O
=	O
"ctf_file reallocation"	*(char)
;	O
goto	O
err_no	O
;	O
}	O
arg	*(void)
.	O
files	O
=	O
files	O
;	O
memmove	O
(	O
&	O
(	O
arg	*(void)
.	O
files	O
[	O
1	int
]	O
)	O
,	O
arg	*(void)
.	O
files	O
,	O
sizeof	O
(	O
ctf_file_t	struct
*	O
)	O
*	O
(	O
arg	*(void)
.	O
i	*(struct)
)	O
)	O
;	O
arg	*(void)
.	O
files	O
[	O
0	int
]	O
=	O
fp	*(struct)
;	O
if	O
(	O
(	O
f	O
=	O
tmpfile	()->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
)	O
)	O
==	O
NULL	O
)	O
{	O
errloc	O
=	O
"tempfile creation"	*(char)
;	O
goto	O
err_no	O
;	O
}	O
if	O
(	O
(	O
err	long
=	O
ctf_arc_write_fd	(int,*(*(struct)),long,*(*(char)),long)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	O
)	O
,	O
arg	*(void)
.	O
files	O
,	O
arg	*(void)
.	O
i	*(struct)
+	O
1	int
,	O
(	O
const	O
char	O
*	O
*	O
)	O
arg	*(void)
.	O
names	O
,	O
threshold	long
)	O
)	O
<	O
0	int
)	O
{	O
errloc	O
=	O
"archive writing"	*(char)
;	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
err	long
)	O
;	O
goto	O
err	long
;	O
}	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
f	O
,	O
0	int
,	O
SEEK_END	O
)	O
<	O
0	int
)	O
{	O
errloc	O
=	O
"seeking to end"	*(char)
;	O
goto	O
err_no	O
;	O
}	O
if	O
(	O
(	O
fsize	O
=	O
ftell	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
f	O
)	O
)	O
<	O
0	int
)	O
{	O
errloc	O
=	O
"filesize determination"	*(char)
;	O
goto	O
err_no	O
;	O
}	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
f	O
,	O
0	int
,	O
SEEK_SET	O
)	O
<	O
0	int
)	O
{	O
errloc	O
=	O
"filepos resetting"	*(char)
;	O
goto	O
err_no	O
;	O
}	O
if	O
(	O
(	O
buf	*(void)
=	O
malloc	(long)->(*(void))
(	O
fsize	O
)	O
)	O
==	O
NULL	O
)	O
{	O
errloc	O
=	O
"CTF archive buffer allocation"	*(char)
;	O
goto	O
err_no	O
;	O
}	O
while	O
(	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	O
)	O
&&	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buf	*(void)
,	O
fsize	O
,	O
1	int
,	O
f	O
)	O
==	O
0	int
)	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	O
)	O
)	O
{	O
errloc	O
=	O
"reading archive from temporary file"	*(char)
;	O
goto	O
err_no	O
;	O
}	O
*	O
size	long
=	O
fsize	O
;	O
free	(*(void))->(void)
(	O
arg	*(void)
.	O
names	O
)	O
;	O
free	(*(void))->(void)
(	O
arg	*(void)
.	O
files	O
)	O
;	O
free	(*(void))->(void)
(	O
transformed_name	O
)	O
;	O
if	O
(	O
arg	*(void)
.	O
ndynames	O
)	O
{	O
size_t	long
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
arg	*(void)
.	O
ndynames	O
;	O
i	*(struct)
++	O
)	O
free	(*(void))->(void)
(	O
arg	*(void)
.	O
dynames	O
[	O
i	*(struct)
]	O
)	O
;	O
free	(*(void))->(void)
(	O
arg	*(void)
.	O
dynames	O
)	O
;	O
}	O
return	O
buf	*(void)
;	O
err_no	O
:	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
errno	O
)	O
;	O
err	long
:	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
if	O
(	O
f	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	O
)	O
;	O
free	(*(void))->(void)
(	O
arg	*(void)
.	O
names	O
)	O
;	O
free	(*(void))->(void)
(	O
arg	*(void)
.	O
files	O
)	O
;	O
free	(*(void))->(void)
(	O
transformed_name	O
)	O
;	O
if	O
(	O
arg	*(void)
.	O
ndynames	O
)	O
{	O
size_t	long
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
arg	*(void)
.	O
ndynames	O
;	O
i	*(struct)
++	O
)	O
free	(*(void))->(void)
(	O
arg	*(void)
.	O
dynames	O
[	O
i	*(struct)
]	O
)	O
;	O
free	(*(void))->(void)
(	O
arg	*(void)
.	O
dynames	O
)	O
;	O
}	O
ctf_dprintf	O
(	O
"Cannot write archive in link: %s failure: %s\n"	*(char)
,	O
errloc	O
,	O
ctf_errmsg	(int)->(*(char))
(	O
ctf_errno	(*(struct))->(int)
(	O
fp	*(struct)
)	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
