object	O
sSYB	int
;	O
object	O
sSYZ	int
;	O
static	O
void	O
kwote_cdr	()->(void)
(	O
void	O
)	O
{	O
object	O
x	int
;	O
x	int
=	O
vs_head	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_symbol	O
)	O
{	O
if	O
(	O
(	O
enum	O
stype	O
)	O
x	int
->	O
s	O
.	O
s_stype	O
==	O
stp_constant	O
&&	O
x	int
->	O
s	O
.	O
s_dbind	O
==	O
x	int
)	O
return	O
;	O
goto	O
KWOTE	O
;	O
}	O
else	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_cons	O
||	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_vector	O
)	O
goto	O
KWOTE	O
;	O
return	O
;	O
KWOTE	O
:	O
vs_head	O
=	O
make_cons	()->(int)
(	O
vs_head	O
,	O
Cnil	O
)	O
;	O
vs_head	O
=	O
make_cons	()->(int)
(	O
sLquote	O
,	O
vs_head	O
)	O
;	O
}	O
static	O
void	O
kwote_car	()->(void)
(	O
void	O
)	O
{	O
object	O
x	int
;	O
x	int
=	O
vs_top	O
[	O
-	O
2	int
]	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_symbol	O
)	O
{	O
if	O
(	O
(	O
enum	O
stype	O
)	O
x	int
->	O
s	O
.	O
s_stype	O
==	O
stp_constant	O
&&	O
x	int
->	O
s	O
.	O
s_dbind	O
==	O
x	int
)	O
return	O
;	O
goto	O
KWOTE	O
;	O
}	O
else	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_cons	O
||	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_vector	O
)	O
goto	O
KWOTE	O
;	O
return	O
;	O
KWOTE	O
:	O
vs_top	O
[	O
-	O
2	int
]	O
=	O
make_cons	()->(int)
(	O
vs_top	O
[	O
-	O
2	int
]	O
,	O
Cnil	O
)	O
;	O
vs_top	O
[	O
-	O
2	int
]	O
=	O
make_cons	()->(int)
(	O
sLquote	O
,	O
vs_top	O
[	O
-	O
2	int
]	O
)	O
;	O
}	O
static	O
int	O
backq_cdr	(int)->(int)
(	O
object	O
x	int
)	O
{	O
int	O
a	int
,	O
d	int
;	O
cs_check	()->(int)
(	O
x	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_cons	O
)	O
{	O
vs_push	()->(int)
(	O
x	int
)	O
;	O
return	O
(	O
QUOTE	int
)	O
;	O
}	O
if	O
(	O
x	int
->	O
c	O
.	O
c_car	O
==	O
siScomma	O
)	O
{	O
vs_push	()->(int)
(	O
x	int
->	O
c	O
.	O
c_cdr	O
)	O
;	O
return	O
(	O
EVAL	int
)	O
;	O
}	O
if	O
(	O
x	int
->	O
c	O
.	O
c_car	O
==	O
siScomma_at	O
||	O
x	int
->	O
c	O
.	O
c_car	O
==	O
siScomma_dot	O
)	O
FEerror	()->(int)
(	O
",@ or ,. has appeared in an illegal position."	*(char)
,	O
0	int
)	O
;	O
a	int
=	O
backq_car	()->(int)
(	O
x	int
->	O
c	O
.	O
c_car	O
)	O
;	O
d	int
=	O
backq_cdr	(int)->(int)
(	O
x	int
->	O
c	O
.	O
c_cdr	O
)	O
;	O
if	O
(	O
d	int
==	O
QUOTE	int
)	O
switch	O
(	O
a	int
)	O
{	O
case	O
QUOTE	int
:	O
vs_popp	O
;	O
vs_head	O
=	O
x	int
;	O
return	O
(	O
QUOTE	int
)	O
;	O
case	O
EVAL	int
:	O
if	O
(	O
vs_head	O
==	O
Cnil	O
)	O
{	O
stack_cons	()->(int)
(	O
)	O
;	O
return	O
(	O
LIST	int
)	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
vs_head	O
)	O
==	O
t_cons	O
&&	O
vs_head	O
->	O
c	O
.	O
c_cdr	O
==	O
Cnil	O
)	O
{	O
vs_head	O
=	O
vs_head	O
->	O
c	O
.	O
c_car	O
;	O
kwote_cdr	()->(void)
(	O
)	O
;	O
make_list	O
;	O
return	O
(	O
LIST	int
)	O
;	O
}	O
kwote_cdr	()->(void)
(	O
)	O
;	O
make_list	O
;	O
return	O
(	O
LISTA	int
)	O
;	O
case	O
APPEND	int
:	O
if	O
(	O
vs_head	O
==	O
Cnil	O
)	O
{	O
vs_popp	O
;	O
return	O
(	O
EVAL	int
)	O
;	O
}	O
kwote_cdr	()->(void)
(	O
)	O
;	O
make_list	O
;	O
return	O
(	O
APPEND	int
)	O
;	O
case	O
NCONC	int
:	O
if	O
(	O
vs_head	O
==	O
Cnil	O
)	O
{	O
vs_popp	O
;	O
return	O
(	O
EVAL	int
)	O
;	O
}	O
kwote_cdr	()->(void)
(	O
)	O
;	O
make_list	O
;	O
return	O
(	O
NCONC	int
)	O
;	O
default	O
:	O
error	()->(int)
(	O
"backquote botch"	*(char)
)	O
;	O
}	O
if	O
(	O
d	int
==	O
EVAL	int
)	O
switch	O
(	O
a	int
)	O
{	O
case	O
QUOTE	int
:	O
kwote_car	()->(void)
(	O
)	O
;	O
make_list	O
;	O
return	O
(	O
LISTA	int
)	O
;	O
case	O
EVAL	int
:	O
make_list	O
;	O
return	O
(	O
LISTA	int
)	O
;	O
case	O
APPEND	int
:	O
make_list	O
;	O
return	O
(	O
APPEND	int
)	O
;	O
case	O
NCONC	int
:	O
make_list	O
;	O
return	O
(	O
NCONC	int
)	O
;	O
default	O
:	O
error	()->(int)
(	O
"backquote botch"	*(char)
)	O
;	O
}	O
if	O
(	O
a	int
==	O
d	int
)	O
{	O
stack_cons	()->(int)
(	O
)	O
;	O
return	O
(	O
d	int
)	O
;	O
}	O
switch	O
(	O
d	int
)	O
{	O
case	O
LIST	int
:	O
if	O
(	O
a	int
==	O
QUOTE	int
)	O
{	O
kwote_car	()->(void)
(	O
)	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
return	O
(	O
d	int
)	O
;	O
}	O
if	O
(	O
a	int
==	O
EVAL	int
)	O
{	O
stack_cons	()->(int)
(	O
)	O
;	O
return	O
(	O
d	int
)	O
;	O
}	O
attach	O
(	O
sLlist	O
)	O
;	O
break	O
;	O
case	O
LISTA	int
:	O
if	O
(	O
a	int
==	O
QUOTE	int
)	O
{	O
kwote_car	()->(void)
(	O
)	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
return	O
(	O
d	int
)	O
;	O
}	O
if	O
(	O
a	int
==	O
EVAL	int
)	O
{	O
stack_cons	()->(int)
(	O
)	O
;	O
return	O
(	O
d	int
)	O
;	O
}	O
attach	O
(	O
sLlistA	O
)	O
;	O
break	O
;	O
case	O
APPEND	int
:	O
attach	O
(	O
sLappend	O
)	O
;	O
break	O
;	O
case	O
NCONC	int
:	O
attach	O
(	O
sLnconc	O
)	O
;	O
break	O
;	O
default	O
:	O
error	()->(int)
(	O
"backquote botch"	*(char)
)	O
;	O
}	O
switch	O
(	O
a	int
)	O
{	O
case	O
QUOTE	int
:	O
kwote_car	()->(void)
(	O
)	O
;	O
make_list	O
;	O
return	O
(	O
LISTA	int
)	O
;	O
case	O
EVAL	int
:	O
make_list	O
;	O
return	O
(	O
LISTA	int
)	O
;	O
case	O
APPEND	int
:	O
make_list	O
;	O
return	O
(	O
APPEND	int
)	O
;	O
case	O
NCONC	int
:	O
make_list	O
;	O
return	O
(	O
NCONC	int
)	O
;	O
default	O
:	O
error	()->(int)
(	O
"backquote botch"	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
int	O
backq_car	()->(int)
(	O
object	O
x	int
)	O
{	O
int	O
d	int
;	O
cs_check	()->(int)
(	O
x	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_cons	O
)	O
{	O
vs_push	()->(int)
(	O
x	int
)	O
;	O
return	O
(	O
QUOTE	int
)	O
;	O
}	O
if	O
(	O
x	int
->	O
c	O
.	O
c_car	O
==	O
siScomma	O
)	O
{	O
vs_push	()->(int)
(	O
x	int
->	O
c	O
.	O
c_cdr	O
)	O
;	O
return	O
(	O
EVAL	int
)	O
;	O
}	O
if	O
(	O
x	int
->	O
c	O
.	O
c_car	O
==	O
siScomma_at	O
)	O
{	O
vs_push	()->(int)
(	O
x	int
->	O
c	O
.	O
c_cdr	O
)	O
;	O
return	O
(	O
APPEND	int
)	O
;	O
}	O
if	O
(	O
x	int
->	O
c	O
.	O
c_car	O
==	O
siScomma_dot	O
)	O
{	O
vs_push	()->(int)
(	O
x	int
->	O
c	O
.	O
c_cdr	O
)	O
;	O
return	O
(	O
NCONC	int
)	O
;	O
}	O
d	int
=	O
backq_cdr	(int)->(int)
(	O
x	int
)	O
;	O
switch	O
(	O
d	int
)	O
{	O
case	O
QUOTE	int
:	O
return	O
(	O
QUOTE	int
)	O
;	O
case	O
EVAL	int
:	O
return	O
(	O
EVAL	int
)	O
;	O
case	O
LIST	int
:	O
attach	O
(	O
sLlist	O
)	O
;	O
break	O
;	O
case	O
LISTA	int
:	O
attach	O
(	O
sLlistA	O
)	O
;	O
break	O
;	O
case	O
APPEND	int
:	O
attach	O
(	O
sLappend	O
)	O
;	O
break	O
;	O
case	O
NCONC	int
:	O
attach	O
(	O
sLnconc	O
)	O
;	O
break	O
;	O
default	O
:	O
error	()->(int)
(	O
"backquote botch"	*(char)
)	O
;	O
}	O
return	O
(	O
EVAL	int
)	O
;	O
}	O
static	O
object	O
backq	(int)->(int)
(	O
object	O
x	int
)	O
{	O
int	O
a	int
;	O
a	int
=	O
backq_car	()->(int)
(	O
x	int
)	O
;	O
if	O
(	O
a	int
==	O
APPEND	int
||	O
a	int
==	O
NCONC	int
)	O
FEerror	()->(int)
(	O
",@ or ,. has appeared in an illegal position."	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
a	int
==	O
QUOTE	int
)	O
kwote_cdr	()->(void)
(	O
)	O
;	O
return	O
(	O
vs_pop	O
)	O
;	O
}	O
static	O
object	O
fLcomma_reader	(int,int)->(int)
(	O
object	O
x0	int
,	O
object	O
x1	int
)	O
{	O
object	O
w	O
;	O
object	O
in	O
,	O
c	O
;	O
in	O
=	O
x0	int
;	O
if	O
(	O
backq_level	O
<=	O
0	int
)	O
FEerror	()->(int)
(	O
"A comma has appeared out of a backquote."	*(char)
,	O
0	int
)	O
;	O
c	O
=	O
peek_char	()->(int)
(	O
FALSE	O
,	O
in	O
)	O
;	O
if	O
(	O
c	O
==	O
code_char	()->(int)
(	O
'@'	O
)	O
)	O
{	O
w	O
=	O
siScomma_at	O
;	O
read_char	()->(int)
(	O
in	O
)	O
;	O
}	O
else	O
if	O
(	O
c	O
==	O
code_char	()->(int)
(	O
'.'	O
)	O
)	O
{	O
w	O
=	O
siScomma_dot	O
;	O
read_char	()->(int)
(	O
in	O
)	O
;	O
}	O
else	O
w	O
=	O
siScomma	O
;	O
--	O
backq_level	O
;	O
x0	int
=	O
make_cons	()->(int)
(	O
w	O
,	O
read_object	()->(int)
(	O
in	O
)	O
)	O
;	O
backq_level	O
++	O
;	O
RETURN1	()->(int)
(	O
x0	int
)	O
;	O
}	O
static	O
object	O
fLbackquote_reader	(int,int)->(int)
(	O
object	O
x0	int
,	O
object	O
x1	int
)	O
{	O
object	O
in	O
;	O
in	O
=	O
x0	int
;	O
backq_level	O
++	O
;	O
x0	int
=	O
read_object	()->(int)
(	O
in	O
)	O
;	O
--	O
backq_level	O
;	O
x0	int
=	O
backq	(int)->(int)
(	O
x0	int
)	O
;	O
RETURN1	()->(int)
(	O
x0	int
)	O
;	O
}	O
DEF_ORDINARY	()->(int)
(	O
"Y"	*(char)
,	O
sSY	O
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"YB"	*(char)
,	O
sSYB	int
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"YZ"	*(char)
,	O
sSYZ	int
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"LIST*"	*(char)
,	O
sLlistA	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"APPEND"	*(char)
,	O
sLappend	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"NCONC"	*(char)
,	O
sLnconc	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"APPLY"	*(char)
,	O
sLapply	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"VECTOR"	*(char)
,	O
sLvector	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
void	O
gcl_init_backq	()->(void)
(	O
void	O
)	O
{	O
object	O
r	O
;	O
r	O
=	O
standard_readtable	O
;	O
r	O
->	O
rt	O
.	O
rt_self	O
[	O
'`'	O
]	O
.	O
rte_chattrib	O
=	O
cat_terminating	O
;	O
r	O
->	O
rt	O
.	O
rt_self	O
[	O
'`'	O
]	O
.	O
rte_macro	O
=	O
MAKE_AFUN	O
(	O
fLbackquote_reader	(int,int)->(int)
,	O
2	int
)	O
;	O
r	O
->	O
rt	O
.	O
rt_self	O
[	O
','	O
]	O
.	O
rte_chattrib	O
=	O
cat_terminating	O
;	O
r	O
->	O
rt	O
.	O
rt_self	O
[	O
','	O
]	O
.	O
rte_macro	O
=	O
MAKE_AFUN	O
(	O
fLcomma_reader	(int,int)->(int)
,	O
2	int
)	O
;	O
backq_level	O
=	O
0	int
;	O
}	O
