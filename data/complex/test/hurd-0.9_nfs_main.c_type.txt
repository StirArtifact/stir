char	O
*	O
netfs_server_name	*(char)
=	O
"nfs"	*(char)
;	O
char	O
*	O
netfs_server_version	*(char)
=	O
HURD_VERSION	O
;	O
extern	O
char	O
*	O
localhost	()->(*(char))
(	O
)	O
;	O
int	O
stat_timeout	int
=	O
DEFAULT_STAT_TIMEOUT	int
;	O
int	O
cache_timeout	int
=	O
DEFAULT_CACHE_TIMEOUT	int
;	O
int	O
name_cache_timeout	int
=	O
DEFAULT_NAME_CACHE_TIMEOUT	int
;	O
int	O
name_cache_neg_timeout	int
=	O
DEFAULT_NAME_CACHE_NEG_TIMEOUT	int
;	O
int	O
initial_transmit_timeout	int
=	O
1	int
;	O
int	O
max_transmit_timeout	int
=	O
30	int
;	O
int	O
soft_retries	int
=	O
DEFAULT_SOFT_RETRIES	int
;	O
int	O
mounted_soft	int
=	O
0	int
;	O
int	O
read_size	int
=	O
DEFAULT_READ_SIZE	int
;	O
int	O
write_size	int
=	O
DEFAULT_WRITE_SIZE	int
;	O
const	O
char	O
*	O
argp_program_version	*(char)
=	O
STANDARD_HURD_VERSION	()->(int)
(	O
nfs	O
)	O
;	O
static	O
const	O
struct	O
argp_option	O
common_options	int
[	O
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
}	O
,	O
{	O
"soft"	*(char)
,	O
OPT_SOFT	char
,	O
"RETRIES"	*(char)
,	O
OPTION_ARG_OPTIONAL	O
,	O
"File system requests will eventually fail, after RETRIES tries"	*(char)
" (default "	*(char)
_D	O
(	O
SOFT_RETRIES	O
)	O
")"	*(char)
}	O
,	O
{	O
"hard"	*(char)
,	O
OPT_HARD	char
,	O
0	int
,	O
0	int
,	O
"Retry file systems requests until they succeed"	*(char)
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
2	int
}	O
,	O
{	O
"read-size"	*(char)
,	O
OPT_RSIZE	char
,	O
"BYTES"	*(char)
,	O
0	int
,	O
"Max packet size for reads (default "	*(char)
_D	O
(	O
READ_SIZE	O
)	O
")"	*(char)
}	O
,	O
{	O
"rsize"	*(char)
,	O
0	int
,	O
0	int
,	O
OPTION_ALIAS	O
}	O
,	O
{	O
"write-size"	*(char)
,	O
OPT_WSIZE	char
,	O
"BYTES"	*(char)
,	O
0	int
,	O
"Max packet size for writes (default "	*(char)
_D	O
(	O
WRITE_SIZE	O
)	O
")"	*(char)
}	O
,	O
{	O
"wsize"	*(char)
,	O
0	int
,	O
0	int
,	O
OPTION_ALIAS	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"Timeouts:"	*(char)
,	O
3	int
}	O
,	O
{	O
"stat-timeout"	*(char)
,	O
OPT_STAT_TO	O
,	O
"SEC"	*(char)
,	O
0	int
,	O
"Timeout for cached stat information (default "	*(char)
_D	O
(	O
STAT_TIMEOUT	O
)	O
")"	*(char)
}	O
,	O
{	O
"cache-timeout"	*(char)
,	O
OPT_CACHE_TO	O
,	O
"SEC"	*(char)
,	O
0	int
,	O
"Timeout for cached file data (default "	*(char)
_D	O
(	O
CACHE_TIMEOUT	O
)	O
")"	*(char)
}	O
,	O
{	O
"name-cache-timeout"	*(char)
,	O
OPT_NCACHE_TO	O
,	O
"SEC"	*(char)
,	O
0	int
,	O
"Timeout for positive directory cache entries (default "	*(char)
_D	O
(	O
NAME_CACHE_TIMEOUT	O
)	O
")"	*(char)
}	O
,	O
{	O
"name-cache-neg-timeout"	*(char)
,	O
OPT_NCACHE_NEG_TO	O
,	O
"SEC"	*(char)
,	O
0	int
,	O
"Timeout for negative directory cache entires (default "	*(char)
_D	O
(	O
NAME_CACHE_NEG_TIMEOUT	O
)	O
")"	*(char)
}	O
,	O
{	O
"init-transmit-timeout"	*(char)
,	O
OPT_INIT_TR_TO	O
,	O
"SEC"	*(char)
,	O
0	int
}	O
,	O
{	O
"max-transmit-timeout"	*(char)
,	O
OPT_MAX_TR_TO	O
,	O
"SEC"	*(char)
,	O
0	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
error_t	O
parse_common_opt	(int,*(char),*(struct))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	O
*	O
state	*(struct)
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
OPT_SOFT	char
:	O
mounted_soft	int
=	O
1	int
;	O
if	O
(	O
arg	*(char)
)	O
soft_retries	int
=	O
atoi	()->(int)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_HARD	char
:	O
mounted_soft	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_RSIZE	char
:	O
read_size	int
=	O
atoi	()->(int)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_WSIZE	char
:	O
write_size	int
=	O
atoi	()->(int)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_STAT_TO	O
:	O
stat_timeout	int
=	O
atoi	()->(int)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_CACHE_TO	O
:	O
cache_timeout	int
=	O
atoi	()->(int)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_INIT_TR_TO	O
:	O
initial_transmit_timeout	int
=	O
atoi	()->(int)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_MAX_TR_TO	O
:	O
max_transmit_timeout	int
=	O
atoi	()->(int)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_NCACHE_TO	O
:	O
name_cache_timeout	int
=	O
atoi	()->(int)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_NCACHE_NEG_TO	O
:	O
name_cache_neg_timeout	int
=	O
atoi	()->(int)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
const	O
struct	O
argp_option	O
startup_options	int
[	O
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"Server specification:"	*(char)
,	O
10	int
}	O
,	O
{	O
"mount-port"	*(char)
,	O
OPT_MNT_PORT	O
,	O
"PORT"	*(char)
,	O
0	int
,	O
"Port for mount server"	*(char)
}	O
,	O
{	O
"default-mount-port"	*(char)
,	O
OPT_MNT_PORT_D	O
,	O
"PORT"	*(char)
,	O
0	int
,	O
"Port for mount server, if none can be found automatically"	*(char)
}	O
,	O
{	O
"mount-program"	*(char)
,	O
OPT_MNT_PROG	O
,	O
"ID[.VERS]"	*(char)
}	O
,	O
{	O
"nfs-port"	*(char)
,	O
OPT_NFS_PORT	O
,	O
"PORT"	*(char)
,	O
0	int
,	O
"Port for nfs operations"	*(char)
}	O
,	O
{	O
"default-nfs-port"	*(char)
,	O
OPT_NFS_PORT_D	O
,	O
"PORT"	*(char)
,	O
0	int
,	O
"Port for nfs operations, if none can be found automatically"	*(char)
}	O
,	O
{	O
"nfs-program"	*(char)
,	O
OPT_NFS_PROG	O
,	O
"ID[.VERS]"	*(char)
}	O
,	O
{	O
"pmap-port"	*(char)
,	O
OPT_PMAP_PORT	O
,	O
"SVC|PORT"	*(char)
}	O
,	O
{	O
"hold"	*(char)
,	O
OPT_HOLD	O
,	O
0	int
,	O
OPTION_HIDDEN	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
char	O
*	O
args_doc	*(char)
=	O
"REMOTE_FS [HOST]"	*(char)
;	O
static	O
char	O
*	O
doc	*(char)
=	O
"Hurd nfs translator"	*(char)
"\vIf HOST is not specified, an attempt is made to extract"	*(char)
" it from REMOTE_FS using either the `HOST:FS' or `FS@HOST' notations."	*(char)
;	O
static	O
const	O
struct	O
argp_child	O
runtime_argp_children	int
[	O
]	O
=	O
{	O
{	O
&	O
netfs_std_runtime_argp	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
struct	O
argp	struct
runtime_argp	struct
=	O
{	O
common_options	int
,	O
parse_common_opt	(int,*(char),*(struct))->(int)
,	O
0	int
,	O
0	int
,	O
runtime_argp_children	int
}	O
;	O
struct	O
argp	struct
*	O
netfs_runtime_argp	*(struct)
=	O
&	O
runtime_argp	struct
;	O
static	O
char	O
*	O
remote_fs	*(char)
;	O
static	O
char	O
*	O
host	*(char)
;	O
error_t	O
netfs_append_args	(*(*(char)),*(long))->(int)
(	O
char	O
*	O
*	O
argz	*(*(char))
,	O
size_t	long
*	O
argz_len	*(long)
)	O
{	O
char	O
buf	array(char)
[	O
80	int
]	O
;	O
error_t	O
err	O
=	O
0	int
;	O
if	O
(	O
mounted_soft	int
)	O
FOPT	O
(	O
"--soft=%d"	*(char)
,	O
soft_retries	int
)	O
;	O
else	O
err	O
=	O
argz_add	()->(int)
(	O
argz	*(*(char))
,	O
argz_len	*(long)
,	O
"--hard"	*(char)
)	O
;	O
FOPT	O
(	O
"--read-size=%d"	*(char)
,	O
read_size	int
)	O
;	O
FOPT	O
(	O
"--write-size=%d"	*(char)
,	O
write_size	int
)	O
;	O
FOPT	O
(	O
"--stat-timeout=%d"	*(char)
,	O
stat_timeout	int
)	O
;	O
FOPT	O
(	O
"--cache-timeout=%d"	*(char)
,	O
cache_timeout	int
)	O
;	O
FOPT	O
(	O
"--init-transmit-timeout=%d"	*(char)
,	O
initial_transmit_timeout	int
)	O
;	O
FOPT	O
(	O
"--max-transmit-timeout=%d"	*(char)
,	O
max_transmit_timeout	int
)	O
;	O
FOPT	O
(	O
"--name-cache-timeout=%d"	*(char)
,	O
name_cache_timeout	int
)	O
;	O
FOPT	O
(	O
"--name-cache-neg-timeout=%d"	*(char)
,	O
name_cache_neg_timeout	int
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
netfs_append_std_options	()->(int)
(	O
argz	*(*(char))
,	O
argz_len	*(long)
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
char	O
*	O
fs	*(char)
;	O
if	O
(	O
asprintf	()->(int)
(	O
&	O
fs	*(char)
,	O
"%s:%s"	*(char)
,	O
host	*(char)
,	O
remote_fs	*(char)
)	O
)	O
{	O
err	O
=	O
argz_add	()->(int)
(	O
argz	*(*(char))
,	O
argz_len	*(long)
,	O
fs	*(char)
)	O
;	O
free	()->(int)
(	O
fs	*(char)
)	O
;	O
}	O
else	O
err	O
=	O
ENOMEM	O
;	O
}	O
return	O
err	O
;	O
}	O
error_t	O
netfs_get_source	(*(struct),*(char),long)->(int)
(	O
struct	O
protid	O
*	O
cred	*(struct)
,	O
char	O
*	O
source	*(char)
,	O
size_t	long
source_len	long
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
snprintf	O
(	O
source	*(char)
,	O
source_len	long
,	O
"%s:%s"	*(char)
,	O
host	*(char)
,	O
remote_fs	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
extract_nfs_args	(*(char),*(*(char)),*(*(char)))->(*(char))
(	O
char	O
*	O
spec	*(char)
,	O
char	O
*	O
*	O
remote_fs	*(char)
,	O
char	O
*	O
*	O
host	*(char)
)	O
{	O
char	O
*	O
sep	*(char)
;	O
spec	*(char)
=	O
strdup	O
(	O
spec	*(char)
)	O
;	O
if	O
(	O
!	O
spec	*(char)
)	O
return	O
NULL	O
;	O
sep	*(char)
=	O
index	O
(	O
spec	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
sep	*(char)
)	O
{	O
*	O
sep	*(char)
++	O
=	O
'\0'	O
;	O
*	O
host	*(char)
=	O
spec	*(char)
;	O
*	O
remote_fs	*(char)
=	O
sep	*(char)
;	O
return	O
spec	*(char)
;	O
}	O
sep	*(char)
=	O
index	O
(	O
spec	*(char)
,	O
'@'	O
)	O
;	O
if	O
(	O
sep	*(char)
)	O
{	O
*	O
sep	*(char)
++	O
=	O
'\0'	O
;	O
*	O
host	*(char)
=	O
sep	*(char)
;	O
*	O
remote_fs	*(char)
=	O
spec	*(char)
;	O
return	O
spec	*(char)
;	O
}	O
free	()->(int)
(	O
spec	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
parse_startup_opt	(int,*(char),*(struct))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	O
*	O
state	*(struct)
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
OPT_MNT_PORT	O
:	O
mount_port_override	O
=	O
1	int
;	O
case	O
OPT_MNT_PORT_D	O
:	O
mount_port	O
=	O
atoi	()->(int)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_NFS_PORT	O
:	O
nfs_port_override	O
=	O
1	int
;	O
case	O
OPT_NFS_PORT_D	O
:	O
nfs_port	O
=	O
atoi	()->(int)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
ARGP_KEY_ARG	O
:	O
if	O
(	O
state	*(struct)
->	O
arg_num	O
==	O
0	int
)	O
remote_fs	*(char)
=	O
arg	*(char)
;	O
else	O
if	O
(	O
state	*(struct)
->	O
arg_num	O
==	O
1	int
)	O
host	*(char)
=	O
arg	*(char)
;	O
else	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
break	O
;	O
case	O
ARGP_KEY_END	O
:	O
if	O
(	O
!	O
host	*(char)
&&	O
!	O
extract_nfs_args	(*(char),*(*(char)),*(*(char)))->(*(char))
(	O
remote_fs	*(char)
,	O
&	O
remote_fs	*(char)
,	O
&	O
host	*(char)
)	O
)	O
argp_error	()->(int)
(	O
state	*(struct)
,	O
"No HOST specified"	*(char)
)	O
;	O
break	O
;	O
case	O
ARGP_KEY_NO_ARGS	O
:	O
argp_error	()->(int)
(	O
state	*(struct)
,	O
"No REMOTE_FS specified"	*(char)
)	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
pthread_t	long
thread	long
;	O
error_t	O
err	O
;	O
struct	O
argp	struct
common_argp	struct
=	O
{	O
common_options	int
,	O
parse_common_opt	(int,*(char),*(struct))->(int)
}	O
;	O
const	O
struct	O
argp_child	O
argp_children	int
[	O
]	O
=	O
{	O
{	O
&	O
common_argp	struct
}	O
,	O
{	O
&	O
netfs_std_startup_argp	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
struct	O
argp	struct
argp	struct
=	O
{	O
startup_options	int
,	O
parse_startup_opt	(int,*(char),*(struct))->(int)
,	O
args_doc	*(char)
,	O
doc	*(char)
,	O
argp_children	int
}	O
;	O
mach_port_t	O
bootstrap	O
;	O
struct	O
sockaddr_in	O
addr	struct
;	O
int	O
ret	int
;	O
argp_parse	()->(int)
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
task_get_bootstrap_port	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
&	O
bootstrap	O
)	O
;	O
netfs_init	()->(int)
(	O
)	O
;	O
main_udp_socket	O
=	O
socket	(int,int,int)->(int)
(	O
PF_INET	int
,	O
SOCK_DGRAM	O
,	O
0	int
)	O
;	O
addr	struct
.	O
sin_family	O
=	O
AF_INET	O
;	O
addr	struct
.	O
sin_addr	O
.	O
s_addr	O
=	O
INADDR_ANY	O
;	O
addr	struct
.	O
sin_port	O
=	O
htons	()->(int)
(	O
IPPORT_RESERVED	O
)	O
;	O
do	O
{	O
addr	struct
.	O
sin_port	O
=	O
htons	()->(int)
(	O
ntohs	()->(int)
(	O
addr	struct
.	O
sin_port	O
)	O
-	O
1	int
)	O
;	O
ret	int
=	O
bind	(int,union(*(struct(()->(int),array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
main_udp_socket	O
,	O
(	O
struct	O
sockaddr	struct(()->(int),array(char))
*	O
)	O
&	O
addr	struct
,	O
sizeof	O
(	O
struct	O
sockaddr_in	O
)	O
)	O
;	O
if	O
(	O
ret	int
==	O
-	O
1	int
&&	O
errno	O
==	O
EACCES	O
)	O
{	O
ret	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
while	O
(	O
(	O
ret	int
==	O
-	O
1	int
)	O
&&	O
(	O
errno	O
==	O
EADDRINUSE	O
)	O
)	O
;	O
if	O
(	O
ret	int
==	O
-	O
1	int
)	O
error	()->(int)
(	O
1	int
,	O
errno	O
,	O
"binding main udp socket"	*(char)
)	O
;	O
err	O
=	O
maptime_map	()->(int)
(	O
0	int
,	O
0	int
,	O
&	O
mapped_time	O
)	O
;	O
if	O
(	O
err	O
)	O
error	()->(int)
(	O
2	int
,	O
err	O
,	O
"mapping time"	*(char)
)	O
;	O
err	O
=	O
pthread_create	()->(int)
(	O
&	O
thread	long
,	O
NULL	O
,	O
timeout_service_thread	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
pthread_detach	()->(int)
(	O
thread	long
)	O
;	O
else	O
{	O
errno	O
=	O
err	O
;	O
perror	()->(int)
(	O
"pthread_create"	*(char)
)	O
;	O
}	O
err	O
=	O
pthread_create	()->(int)
(	O
&	O
thread	long
,	O
NULL	O
,	O
rpc_receive_thread	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
pthread_detach	()->(int)
(	O
thread	long
)	O
;	O
else	O
{	O
errno	O
=	O
err	O
;	O
perror	()->(int)
(	O
"pthread_create"	*(char)
)	O
;	O
}	O
hostname	O
=	O
localhost	()->(*(char))
(	O
)	O
;	O
netfs_root_node	O
=	O
mount_root	()->(int)
(	O
remote_fs	*(char)
,	O
host	*(char)
)	O
;	O
if	O
(	O
!	O
netfs_root_node	O
)	O
exit	O
(	O
1	int
)	O
;	O
netfs_startup	()->(int)
(	O
bootstrap	O
,	O
0	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
netfs_server_loop	()->(int)
(	O
)	O
;	O
}	O
