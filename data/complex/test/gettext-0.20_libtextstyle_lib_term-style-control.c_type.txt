static	O
inline	O
int	O
nonintr_tcgetattr	()->(int)
(	O
int	O
fd	int
,	O
struct	O
termios	O
*	O
tcp	O
)	O
{	O
int	O
retval	O
;	O
do	O
retval	O
=	O
tcgetattr	O
(	O
fd	int
,	O
tcp	O
)	O
;	O
while	O
(	O
retval	O
<	O
0	int
&&	O
errno	O
==	O
EINTR	O
)	O
;	O
return	O
retval	O
;	O
}	O
static	O
inline	O
int	O
nonintr_tcsetattr	()->(int)
(	O
int	O
fd	int
,	O
int	O
flush_mode	O
,	O
const	O
struct	O
termios	O
*	O
tcp	O
)	O
{	O
int	O
retval	O
;	O
do	O
retval	O
=	O
tcsetattr	O
(	O
fd	int
,	O
flush_mode	O
,	O
tcp	O
)	O
;	O
while	O
(	O
retval	O
<	O
0	int
&&	O
errno	O
==	O
EINTR	O
)	O
;	O
return	O
retval	O
;	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
sprintf_integer	()->(int)
(	O
char	O
*	O
str	O
,	O
int	O
x	O
)	O
{	O
unsigned	O
int	O
y	O
;	O
char	O
buf	O
[	O
20	int
]	O
;	O
char	O
*	O
p	O
;	O
size_t	O
n	O
;	O
if	O
(	O
x	O
<	O
0	int
)	O
{	O
*	O
str	O
++	O
=	O
'-'	O
;	O
y	O
=	O
(	O
unsigned	O
int	O
)	O
(	O
-	O
1	int
-	O
x	O
)	O
+	O
1	int
;	O
}	O
else	O
y	O
=	O
x	O
;	O
p	O
=	O
buf	O
+	O
sizeof	O
(	O
buf	O
)	O
;	O
do	O
{	O
*	O
--	O
p	O
=	O
'0'	O
+	O
(	O
y	O
%	O
10	int
)	O
;	O
y	O
=	O
y	O
/	O
10	int
;	O
}	O
while	O
(	O
y	O
>	O
0	int
)	O
;	O
n	O
=	O
buf	O
+	O
sizeof	O
(	O
buf	O
)	O
-	O
p	O
;	O
memcpy	O
(	O
str	O
,	O
p	O
,	O
n	O
)	O
;	O
str	O
[	O
n	O
]	O
=	O
'\0'	O
;	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
simple_errno_string	()->(int)
(	O
char	O
*	O
str	O
,	O
int	O
errnum	int
)	O
{	O
switch	O
(	O
errnum	int
)	O
{	O
case	O
EBADF	O
:	O
strcpy	O
(	O
str	O
,	O
"EBADF"	*(char)
)	O
;	O
break	O
;	O
case	O
EINTR	O
:	O
strcpy	O
(	O
str	O
,	O
"EINTR"	*(char)
)	O
;	O
break	O
;	O
case	O
EINVAL	O
:	O
strcpy	O
(	O
str	O
,	O
"EINVAL"	*(char)
)	O
;	O
break	O
;	O
case	O
EIO	O
:	O
strcpy	O
(	O
str	O
,	O
"EIO"	*(char)
)	O
;	O
break	O
;	O
case	O
ENOTTY	O
:	O
strcpy	O
(	O
str	O
,	O
"ENOTTY"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
sprintf_integer	()->(int)
(	O
str	O
,	O
errnum	int
)	O
;	O
break	O
;	O
}	O
}	O
static	O
int	O
volatile	O
term_fd	O
=	O
-	O
1	int
;	O
typedef	O
enum	O
{	O
PGRP_UNKNOWN	int
=	O
0	int
,	O
PGRP_NO_TTY	int
,	O
PGRP_IN_FOREGROUND	int
,	O
PGRP_IN_BACKGROUND	int
}	O
pgrp_status_t	enum(int,int,int,int)
;	O
static	O
pgrp_status_t	enum(int,int,int,int)
volatile	O
pgrp_status	enum(int,int,int,int)
=	O
PGRP_UNKNOWN	int
;	O
static	O
_GL_ASYNC_SAFE	O
void	O
update_pgrp_status	()->(void)
(	O
void	O
)	O
{	O
int	O
fd	int
=	O
term_fd	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
pgrp_status	enum(int,int,int,int)
=	O
PGRP_UNKNOWN	int
;	O
log_message	O
(	O
"pgrp_status = PGRP_UNKNOWN\n"	*(char)
)	O
;	O
}	O
else	O
{	O
pid_t	O
p	O
=	O
tcgetpgrp	O
(	O
fd	int
)	O
;	O
if	O
(	O
p	O
<	O
0	int
)	O
{	O
pgrp_status	enum(int,int,int,int)
=	O
PGRP_NO_TTY	int
;	O
log_message	O
(	O
"pgrp_status = PGRP_NO_TTY\n"	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
p	O
==	O
getpgrp	()->(int)
(	O
)	O
)	O
{	O
pgrp_status	enum(int,int,int,int)
=	O
PGRP_IN_FOREGROUND	int
;	O
log_message	O
(	O
"pgrp_status = PGRP_IN_FOREGROUND\n"	*(char)
)	O
;	O
}	O
else	O
{	O
pgrp_status	enum(int,int,int,int)
=	O
PGRP_IN_BACKGROUND	int
;	O
log_message	O
(	O
"pgrp_status = PGRP_IN_BACKGROUND\n"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
static	O
const	O
struct	O
term_style_controller	O
*	O
volatile	O
active_controller	*(struct)
;	O
static	O
struct	O
term_style_user_data	O
*	O
volatile	O
active_user_data	*(struct)
;	O
static	O
struct	O
term_style_control_data	O
*	O
volatile	O
active_control_data	*(struct)
;	O
static	O
int	O
volatile	O
active_fd	int
=	O
-	O
1	int
;	O
static	O
void	O
atexit_handler	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
active_controller	*(struct)
!=	O
NULL	O
)	O
{	O
active_controller	*(struct)
->	O
restore	O
(	O
active_user_data	*(struct)
)	O
;	O
deactivate_term_non_default_mode	O
(	O
active_controller	*(struct)
,	O
active_user_data	*(struct)
)	O
;	O
}	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
tcsetattr_failed	(array(char),*(char))->(void)
(	O
char	O
message	array(char)
[	O
100	int
]	O
,	O
const	O
char	O
*	O
caller	*(char)
)	O
{	O
int	O
errnum	int
=	O
errno	O
;	O
strcpy	O
(	O
message	array(char)
,	O
caller	*(char)
)	O
;	O
strcat	O
(	O
message	array(char)
,	O
": tcsetattr(fd="	*(char)
)	O
;	O
sprintf_integer	()->(int)
(	O
message	array(char)
+	O
strlen	O
(	O
message	array(char)
)	O
,	O
active_fd	int
)	O
;	O
strcat	O
(	O
message	array(char)
,	O
") failed, errno="	*(char)
)	O
;	O
simple_errno_string	()->(int)
(	O
message	array(char)
+	O
strlen	O
(	O
message	array(char)
)	O
,	O
errnum	int
)	O
;	O
strcat	O
(	O
message	array(char)
,	O
"\n"	*(char)
)	O
;	O
}	O
static	O
bool	O
volatile	O
orig_lflag_set	O
;	O
static	O
tcflag_t	O
volatile	O
orig_lflag	O
;	O
static	O
_GL_ASYNC_SAFE	O
void	O
clobber_local_mode	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
pgrp_status	enum(int,int,int,int)
==	O
PGRP_IN_FOREGROUND	int
)	O
{	O
struct	O
termios	O
tc	struct
;	O
if	O
(	O
nonintr_tcgetattr	()->(int)
(	O
active_fd	int
,	O
&	O
tc	struct
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
orig_lflag_set	O
)	O
orig_lflag	O
=	O
tc	struct
.	O
c_lflag	O
;	O
orig_lflag_set	O
=	O
true	O
;	O
tc	struct
.	O
c_lflag	O
&=	O
~	O
ECHO	O
;	O
tc	struct
.	O
c_lflag	O
|=	O
NOFLSH	int
;	O
if	O
(	O
nonintr_tcsetattr	()->(int)
(	O
active_fd	int
,	O
TCSANOW	O
,	O
&	O
tc	struct
)	O
<	O
0	int
)	O
{	O
orig_lflag_set	O
=	O
false	O
;	O
{	O
char	O
message	array(char)
[	O
100	int
]	O
;	O
tcsetattr_failed	(array(char),*(char))->(void)
(	O
message	array(char)
,	O
"term-style-control:clobber_local_mode"	*(char)
)	O
;	O
full_write	O
(	O
STDERR_FILENO	O
,	O
message	array(char)
,	O
strlen	O
(	O
message	array(char)
)	O
)	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
_GL_ASYNC_SAFE	O
bool	O
restore_local_mode	()->(int)
(	O
void	O
)	O
{	O
bool	O
echo_was_off	O
=	O
false	O
;	O
if	O
(	O
orig_lflag_set	O
)	O
{	O
struct	O
termios	O
tc	struct
;	O
if	O
(	O
nonintr_tcgetattr	()->(int)
(	O
active_fd	int
,	O
&	O
tc	struct
)	O
>=	O
0	int
)	O
{	O
echo_was_off	O
=	O
(	O
tc	struct
.	O
c_lflag	O
&	O
ECHO	O
)	O
==	O
0	int
;	O
tc	struct
.	O
c_lflag	O
=	O
orig_lflag	O
;	O
if	O
(	O
nonintr_tcsetattr	()->(int)
(	O
active_fd	int
,	O
TCSADRAIN	O
,	O
&	O
tc	struct
)	O
<	O
0	int
)	O
{	O
char	O
message	array(char)
[	O
100	int
]	O
;	O
tcsetattr_failed	(array(char),*(char))->(void)
(	O
message	array(char)
,	O
"term-style-control:restore_local_mode"	*(char)
)	O
;	O
full_write	O
(	O
STDERR_FILENO	O
,	O
message	array(char)
,	O
strlen	O
(	O
message	array(char)
)	O
)	O
;	O
}	O
}	O
orig_lflag_set	O
=	O
false	O
;	O
}	O
return	O
echo_was_off	O
;	O
}	O
static	O
sigset_t	O
relevant_signal_set	int
;	O
static	O
bool	O
relevant_signal_set_initialized	int
=	O
false	O
;	O
static	O
void	O
init_relevant_signal_set	()->(void)
(	O
)	O
{	O
if	O
(	O
!	O
relevant_signal_set_initialized	int
)	O
{	O
int	O
fatal_signals	array(int)
[	O
64	int
]	O
;	O
size_t	O
num_fatal_signals	O
;	O
size_t	O
i	int
;	O
num_fatal_signals	O
=	O
get_fatal_signals	O
(	O
fatal_signals	array(int)
)	O
;	O
sigemptyset	()->(int)
(	O
&	O
relevant_signal_set	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_fatal_signals	O
;	O
i	int
++	O
)	O
sigaddset	()->(int)
(	O
&	O
relevant_signal_set	int
,	O
fatal_signals	array(int)
[	O
i	int
]	O
)	O
;	O
relevant_signal_set_initialized	int
=	O
true	O
;	O
}	O
}	O
static	O
_GL_ASYNC_SAFE	O
inline	O
void	O
block_relevant_signals	()->(void)
(	O
)	O
{	O
if	O
(	O
!	O
relevant_signal_set_initialized	int
)	O
abort	O
(	O
)	O
;	O
sigprocmask	()->(int)
(	O
SIG_BLOCK	O
,	O
&	O
relevant_signal_set	int
,	O
NULL	O
)	O
;	O
}	O
static	O
_GL_ASYNC_SAFE	O
inline	O
void	O
unblock_relevant_signals	()->(void)
(	O
)	O
{	O
sigprocmask	()->(int)
(	O
SIG_UNBLOCK	O
,	O
&	O
relevant_signal_set	int
,	O
NULL	O
)	O
;	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
show_signal_marker	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
if	O
(	O
active_controller	*(struct)
!=	O
NULL	O
&&	O
active_control_data	*(struct)
->	O
same_as_stderr	O
)	O
switch	O
(	O
sig	int
)	O
{	O
case	O
SIGINT	O
:	O
full_write	O
(	O
STDERR_FILENO	O
,	O
"^C"	*(char)
,	O
2	int
)	O
;	O
break	O
;	O
case	O
SIGTSTP	O
:	O
full_write	O
(	O
STDERR_FILENO	O
,	O
"^Z"	*(char)
,	O
2	int
)	O
;	O
break	O
;	O
case	O
SIGQUIT	O
:	O
full_write	O
(	O
STDERR_FILENO	O
,	O
"^\\"	*(char)
,	O
2	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
fatal_or_stopping_signal_handler	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
bool	O
echo_was_off	O
=	O
false	O
;	O
if	O
(	O
active_controller	*(struct)
!=	O
NULL	O
&&	O
active_control_data	*(struct)
->	O
tty_control	int
!=	O
TTYCTL_NONE	O
)	O
{	O
unsigned	O
int	O
i	int
;	O
block_relevant_signals	()->(void)
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
active_controller	*(struct)
->	O
async_restore	O
(	O
active_user_data	*(struct)
)	O
;	O
if	O
(	O
active_control_data	*(struct)
->	O
tty_control	int
==	O
TTYCTL_FULL	O
)	O
{	O
echo_was_off	O
=	O
restore_local_mode	()->(int)
(	O
)	O
;	O
}	O
unblock_relevant_signals	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
echo_was_off	O
)	O
show_signal_marker	(int)->(void)
(	O
sig	int
)	O
;	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
fatal_signal_handler	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
log_signal_handler_called	O
(	O
sig	int
)	O
;	O
fatal_or_stopping_signal_handler	(int)->(void)
(	O
sig	int
)	O
;	O
}	O
static	O
void	O
ensure_other_signal_handlers	()->(void)
(	O
void	O
)	O
{	O
static	O
bool	O
signal_handlers_installed	int
=	O
false	O
;	O
if	O
(	O
!	O
signal_handlers_installed	int
)	O
{	O
at_fatal_signal	O
(	O
fatal_signal_handler	(int)->(void)
)	O
;	O
signal_handlers_installed	int
=	O
true	O
;	O
}	O
}	O
void	O
activate_term_non_default_mode	O
(	O
const	O
struct	O
term_style_controller	O
*	O
controller	*(struct)
,	O
struct	O
term_style_user_data	O
*	O
user_data	*(struct)
)	O
{	O
struct	O
term_style_control_data	O
*	O
control_data	*(struct)
=	O
controller	*(struct)
->	O
get_control_data	O
(	O
user_data	*(struct)
)	O
;	O
if	O
(	O
!	O
control_data	*(struct)
->	O
non_default_active	O
)	O
{	O
if	O
(	O
control_data	*(struct)
->	O
tty_control	int
!=	O
TTYCTL_NONE	O
)	O
ensure_other_signal_handlers	()->(void)
(	O
)	O
;	O
if	O
(	O
active_controller	*(struct)
!=	O
NULL	O
)	O
{	O
abort	O
(	O
)	O
;	O
}	O
active_fd	int
=	O
control_data	*(struct)
->	O
fd	int
;	O
active_control_data	*(struct)
=	O
control_data	*(struct)
;	O
active_user_data	*(struct)
=	O
user_data	*(struct)
;	O
active_controller	*(struct)
=	O
controller	*(struct)
;	O
if	O
(	O
active_control_data	*(struct)
->	O
tty_control	int
==	O
TTYCTL_FULL	O
)	O
{	O
clobber_local_mode	()->(void)
(	O
)	O
;	O
}	O
control_data	*(struct)
->	O
non_default_active	O
=	O
true	O
;	O
}	O
}	O
void	O
deactivate_term_non_default_mode	O
(	O
const	O
struct	O
term_style_controller	O
*	O
controller	*(struct)
,	O
struct	O
term_style_user_data	O
*	O
user_data	*(struct)
)	O
{	O
struct	O
term_style_control_data	O
*	O
control_data	*(struct)
=	O
controller	*(struct)
->	O
get_control_data	O
(	O
user_data	*(struct)
)	O
;	O
if	O
(	O
control_data	*(struct)
->	O
non_default_active	O
)	O
{	O
if	O
(	O
active_control_data	*(struct)
->	O
tty_control	int
==	O
TTYCTL_FULL	O
)	O
{	O
restore_local_mode	()->(int)
(	O
)	O
;	O
}	O
active_controller	*(struct)
=	O
NULL	O
;	O
active_user_data	*(struct)
=	O
NULL	O
;	O
active_control_data	*(struct)
=	O
NULL	O
;	O
active_fd	int
=	O
-	O
1	int
;	O
control_data	*(struct)
->	O
non_default_active	O
=	O
false	O
;	O
}	O
}	O
void	O
activate_term_style_controller	O
(	O
const	O
struct	O
term_style_controller	O
*	O
controller	*(struct)
,	O
struct	O
term_style_user_data	O
*	O
user_data	*(struct)
,	O
int	O
fd	int
,	O
ttyctl_t	O
tty_control	int
)	O
{	O
struct	O
term_style_control_data	O
*	O
control_data	*(struct)
=	O
controller	*(struct)
->	O
get_control_data	O
(	O
user_data	*(struct)
)	O
;	O
control_data	*(struct)
->	O
fd	int
=	O
fd	int
;	O
if	O
(	O
tty_control	int
==	O
TTYCTL_AUTO	O
)	O
tty_control	int
=	O
TTYCTL_FULL	O
;	O
control_data	*(struct)
->	O
tty_control	int
=	O
tty_control	int
;	O
if	O
(	O
control_data	*(struct)
->	O
tty_control	int
!=	O
TTYCTL_NONE	O
)	O
init_relevant_signal_set	()->(void)
(	O
)	O
;	O
if	O
(	O
control_data	*(struct)
->	O
tty_control	int
==	O
TTYCTL_FULL	O
)	O
{	O
struct	O
stat	O
statbuf1	struct
;	O
struct	O
stat	O
statbuf2	struct
;	O
if	O
(	O
fd	int
==	O
STDERR_FILENO	O
||	O
(	O
fstat	()->(int)
(	O
fd	int
,	O
&	O
statbuf1	struct
)	O
>=	O
0	int
&&	O
fstat	()->(int)
(	O
STDERR_FILENO	O
,	O
&	O
statbuf2	struct
)	O
>=	O
0	int
&&	O
SAME_INODE	()->(int)
(	O
statbuf1	struct
,	O
statbuf2	struct
)	O
)	O
)	O
control_data	*(struct)
->	O
same_as_stderr	O
=	O
true	O
;	O
else	O
control_data	*(struct)
->	O
same_as_stderr	O
=	O
false	O
;	O
}	O
else	O
control_data	*(struct)
->	O
same_as_stderr	O
=	O
false	O
;	O
control_data	*(struct)
->	O
non_default_active	O
=	O
false	O
;	O
term_fd	O
=	O
fd	int
;	O
update_pgrp_status	()->(void)
(	O
)	O
;	O
{	O
static	O
bool	O
registered	int
=	O
false	O
;	O
if	O
(	O
!	O
registered	int
)	O
{	O
atexit	()->(int)
(	O
atexit_handler	()->(void)
)	O
;	O
registered	int
=	O
true	O
;	O
}	O
}	O
}	O
void	O
deactivate_term_style_controller	O
(	O
const	O
struct	O
term_style_controller	O
*	O
controller	*(struct)
,	O
struct	O
term_style_user_data	O
*	O
user_data	*(struct)
)	O
{	O
struct	O
term_style_control_data	O
*	O
control_data	*(struct)
=	O
controller	*(struct)
->	O
get_control_data	O
(	O
user_data	*(struct)
)	O
;	O
if	O
(	O
control_data	*(struct)
->	O
non_default_active	O
)	O
abort	O
(	O
)	O
;	O
term_fd	O
=	O
-	O
1	int
;	O
update_pgrp_status	()->(void)
(	O
)	O
;	O
}	O
