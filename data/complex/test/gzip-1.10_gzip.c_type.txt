static	O
char	O
const	O
*	O
const	O
license_msg	array(*(char))
[	O
]	O
=	O
{	O
"Copyright (C) 2018 Free Software Foundation, Inc."	*(char)
,	O
"Copyright (C) 1993 Jean-loup Gailly."	*(char)
,	O
"This is free software.  You may redistribute copies of it under the terms of"	*(char)
,	O
"the GNU General Public License <https://www.gnu.org/licenses/gpl.html>."	*(char)
,	O
"There is NO WARRANTY, to the extent permitted by law."	*(char)
,	O
0	int
}	O
;	O
DECLARE	O
(	O
uch	char
,	O
inbuf	array(char)
,	O
INBUFSIZ	int
+	O
INBUF_EXTRA	int
)	O
;	O
DECLARE	O
(	O
uch	char
,	O
outbuf	array(char)
,	O
OUTBUFSIZ	int
+	O
OUTBUF_EXTRA	int
)	O
;	O
DECLARE	O
(	O
ush	short
,	O
d_buf	array(short)
,	O
DIST_BUFSIZE	int
)	O
;	O
DECLARE	O
(	O
uch	char
,	O
window	array(char)
,	O
2L	int
*	O
WSIZE	int
)	O
;	O
DECLARE	O
(	O
ush	short
,	O
tab_prefix	O
,	O
1L	int
<<	O
BITS	int
)	O
;	O
static	O
bool	bool
presume_input_tty	bool
;	O
static	O
bool	bool
synchronous	bool
;	O
static	O
int	O
ascii	int
=	O
0	int
;	O
int	O
to_stdout	int
=	O
0	int
;	O
static	O
int	O
decompress	int
=	O
0	int
;	O
static	O
int	O
force	int
=	O
0	int
;	O
static	O
int	O
keep	int
=	O
0	int
;	O
static	O
int	O
no_name	int
=	O
-	O
1	int
;	O
static	O
int	O
no_time	int
=	O
-	O
1	int
;	O
static	O
int	O
recursive	int
=	O
0	int
;	O
static	O
int	O
list	int
=	O
0	int
;	O
int	O
verbose	int
=	O
0	int
;	O
int	O
quiet	int
=	O
0	int
;	O
static	O
int	O
do_lzw	int
=	O
0	int
;	O
int	O
test	int
=	O
0	int
;	O
static	O
int	O
foreground	int
=	O
0	int
;	O
char	O
*	O
program_name	*(char)
;	O
int	O
maxbits	int
=	O
BITS	int
;	O
int	O
method	int
=	O
DEFLATED	int
;	O
int	O
level	int
=	O
6	int
;	O
int	O
exit_code	int
=	O
OK	int
;	O
int	O
save_orig_name	int
;	O
static	O
int	O
last_member	int
;	O
static	O
int	O
part_nb	int
;	O
off_t	long
ifile_size	long
;	O
static	O
char	O
*	O
env	*(char)
;	O
static	O
char	O
const	O
*	O
z_suffix	*(char)
;	O
static	O
size_t	long
z_len	long
;	O
struct	O
timespec	struct(long,long)
time_stamp	struct(long,long)
;	O
static	O
sigset_t	struct(array(long))
caught_signals	struct(array(long))
;	O
static	O
int	O
volatile	O
exiting_signal	int
;	O
static	O
int	O
volatile	O
remove_ofname_fd	int
=	O
-	O
1	int
;	O
static	O
char	O
volatile	O
remove_ofname	array(char)
[	O
MAX_PATH_LEN	int
]	O
;	O
static	O
bool	bool
stdin_was_read	bool
;	O
off_t	long
bytes_in	long
;	O
off_t	long
bytes_out	long
;	O
static	O
off_t	long
total_in	long
;	O
static	O
off_t	long
total_out	long
;	O
char	O
ifname	array(char)
[	O
MAX_PATH_LEN	int
]	O
;	O
char	O
ofname	array(char)
[	O
MAX_PATH_LEN	int
]	O
;	O
static	O
char	O
dfname	array(char)
[	O
MAX_PATH_LEN	int
]	O
;	O
static	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
istat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
ifd	int
;	O
int	O
ofd	int
;	O
static	O
int	O
dfd	int
=	O
-	O
1	int
;	O
unsigned	O
insize	int
;	O
unsigned	O
inptr	int
;	O
unsigned	O
outcnt	int
;	O
int	O
rsync	int
=	O
0	int
;	O
static	O
int	O
handled_sig	array(int)
[	O
]	O
=	O
{	O
SIGINT	int
,	O
SIGHUP	int
,	O
SIGPIPE	int
,	O
SIGTERM	int
,	O
SIGXCPU	int
,	O
SIGXFSZ	int
}	O
;	O
enum	O
{	O
PRESUME_INPUT_TTY_OPTION	int
=	O
CHAR_MAX	O
+	O
1	int
,	O
RSYNCABLE_OPTION	int
,	O
SYNCHRONOUS_OPTION	int
,	O
ENV_OPTION	int
}	O
;	O
static	O
char	O
const	O
shortopts	array(char)
[	O
]	O
=	O
"ab:cdfhH?klLmMnNqrS:tvVZ123456789"	*(char)
;	O
static	O
const	O
struct	O
option	struct(*(char),int,*(int),int)
longopts	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"ascii"	*(char)
,	O
0	int
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"to-stdout"	*(char)
,	O
0	int
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"stdout"	*(char)
,	O
0	int
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"decompress"	*(char)
,	O
0	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"uncompress"	*(char)
,	O
0	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"force"	*(char)
,	O
0	int
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"help"	*(char)
,	O
0	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"keep"	*(char)
,	O
0	int
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"list"	*(char)
,	O
0	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"license"	*(char)
,	O
0	int
,	O
0	int
,	O
'L'	O
}	O
,	O
{	O
"no-name"	*(char)
,	O
0	int
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"name"	*(char)
,	O
0	int
,	O
0	int
,	O
'N'	O
}	O
,	O
{	O
"-presume-input-tty"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
PRESUME_INPUT_TTY_OPTION	int
}	O
,	O
{	O
"quiet"	*(char)
,	O
0	int
,	O
0	int
,	O
'q'	O
}	O
,	O
{	O
"silent"	*(char)
,	O
0	int
,	O
0	int
,	O
'q'	O
}	O
,	O
{	O
"synchronous"	*(char)
,	O
0	int
,	O
0	int
,	O
SYNCHRONOUS_OPTION	int
}	O
,	O
{	O
"recursive"	*(char)
,	O
0	int
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"suffix"	*(char)
,	O
1	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"test"	*(char)
,	O
0	int
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"verbose"	*(char)
,	O
0	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"version"	*(char)
,	O
0	int
,	O
0	int
,	O
'V'	O
}	O
,	O
{	O
"fast"	*(char)
,	O
0	int
,	O
0	int
,	O
'1'	O
}	O
,	O
{	O
"best"	*(char)
,	O
0	int
,	O
0	int
,	O
'9'	O
}	O
,	O
{	O
"lzw"	*(char)
,	O
0	int
,	O
0	int
,	O
'Z'	O
}	O
,	O
{	O
"bits"	*(char)
,	O
1	int
,	O
0	int
,	O
'b'	O
}	O
,	O
{	O
"rsyncable"	*(char)
,	O
0	int
,	O
0	int
,	O
RSYNCABLE_OPTION	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
local	O
noreturn	O
void	O
try_help	()->(void)
(	O
void	O
)	O
;	O
local	O
void	O
help	()->(void)
(	O
void	O
)	O
;	O
local	O
void	O
license	()->(void)
(	O
void	O
)	O
;	O
local	O
void	O
version	()->(void)
(	O
void	O
)	O
;	O
local	O
int	O
input_eof	()->(int)
(	O
void	O
)	O
;	O
local	O
void	O
treat_stdin	()->(void)
(	O
void	O
)	O
;	O
local	O
void	O
treat_file	(*(char))->(void)
(	O
char	O
*	O
iname	*(char)
)	O
;	O
local	O
int	O
create_outfile	()->(int)
(	O
void	O
)	O
;	O
local	O
char	O
*	O
get_suffix	(*(char))->(*(char))
(	O
char	O
*	O
name	*(char)
)	O
;	O
local	O
int	O
open_input_file	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
char	O
*	O
iname	*(char)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
sbuf	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
local	O
void	O
discard_input_bytes	(long,int)->(void)
(	O
size_t	long
nbytes	long
,	O
unsigned	O
int	O
flags	*(short)
)	O
;	O
local	O
int	O
make_ofname	()->(int)
(	O
void	O
)	O
;	O
local	O
void	O
shorten_name	(*(char))->(void)
(	O
char	O
*	O
name	*(char)
)	O
;	O
local	O
int	O
get_method	(int)->(int)
(	O
int	O
in	int
)	O
;	O
local	O
void	O
do_list	(int,int)->(void)
(	O
int	O
ifd	int
,	O
int	O
method	int
)	O
;	O
local	O
int	O
check_ofname	()->(int)
(	O
void	O
)	O
;	O
local	O
void	O
copy_stat	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(void)
(	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
ifstat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
local	O
void	O
install_signal_handlers	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
remove_output_file	(bool)->(void)
(	O
bool	bool
)	O
;	O
static	O
void	O
abort_gzip_signal	(int)->(void)
(	O
int	O
)	O
;	O
local	O
noreturn	O
void	O
do_exit	(int)->(void)
(	O
int	O
exitcode	int
)	O
;	O
static	O
void	O
finish_out	()->(void)
(	O
void	O
)	O
;	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
;	O
static	O
int	O
(	O
*	O
work	*((int,int)->(int))
)	O
(	O
int	O
infile	int
,	O
int	O
outfile	int
)	O
=	O
zip	(int,int)->(int)
;	O
local	O
void	O
treat_dir	(int,*(char))->(void)
(	O
int	O
fd	int
,	O
char	O
*	O
dir	*(char)
)	O
;	O
static	O
void	O
try_help	()->(void)
(	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Try `%s --help' for more information.\n"	*(char)
,	O
program_name	*(char)
)	O
;	O
do_exit	(int)->(void)
(	O
ERROR	int
)	O
;	O
}	O
local	O
void	O
help	()->(void)
(	O
)	O
{	O
static	O
char	O
const	O
*	O
const	O
help_msg	array(*(char))
[	O
]	O
=	O
{	O
"Compress or uncompress FILEs (by default, compress FILES in-place)."	*(char)
,	O
""	*(char)
,	O
"Mandatory arguments to long options are mandatory for short options too."	*(char)
,	O
""	*(char)
,	O
"  -c, --stdout      write on standard output, keep original files unchanged"	*(char)
,	O
"  -d, --decompress  decompress"	*(char)
,	O
"  -f, --force       force overwrite of output file and compress links"	*(char)
,	O
"  -h, --help        give this help"	*(char)
,	O
"  -k, --keep        keep (don't delete) input files"	*(char)
,	O
"  -l, --list        list compressed file contents"	*(char)
,	O
"  -L, --license     display software license"	*(char)
,	O
"  -n, --no-name     do not save or restore the original name and timestamp"	*(char)
,	O
"  -N, --name        save or restore the original name and timestamp"	*(char)
,	O
"  -q, --quiet       suppress all warnings"	*(char)
,	O
"  -r, --recursive   operate recursively on directories"	*(char)
,	O
"      --rsyncable   make rsync-friendly archive"	*(char)
,	O
"  -S, --suffix=SUF  use suffix SUF on compressed files"	*(char)
,	O
"      --synchronous synchronous output (safer if system crashes, but slower)"	*(char)
,	O
"  -t, --test        test compressed file integrity"	*(char)
,	O
"  -v, --verbose     verbose mode"	*(char)
,	O
"  -V, --version     display version number"	*(char)
,	O
"  -1, --fast        compress faster"	*(char)
,	O
"  -9, --best        compress better"	*(char)
,	O
""	*(char)
,	O
"With no FILE, or when FILE is -, read standard input."	*(char)
,	O
""	*(char)
,	O
"Report bugs to <bug-gzip@gnu.org>."	*(char)
,	O
0	int
}	O
;	O
char	O
const	O
*	O
const	O
*	O
p	*(void)
=	O
help_msg	array(*(char))
;	O
printf	(*(char))->(int)
(	O
"Usage: %s [OPTION]... [FILE]...\n"	*(char)
,	O
program_name	*(char)
)	O
;	O
while	O
(	O
*	O
p	*(void)
)	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
*	O
p	*(void)
++	O
)	O
;	O
}	O
local	O
void	O
license	()->(void)
(	O
)	O
{	O
char	O
const	O
*	O
const	O
*	O
p	*(void)
=	O
license_msg	array(*(char))
;	O
printf	(*(char))->(int)
(	O
"%s %s\n"	*(char)
,	O
program_name	*(char)
,	O
Version	*(char)
)	O
;	O
while	O
(	O
*	O
p	*(void)
)	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
*	O
p	*(void)
++	O
)	O
;	O
}	O
local	O
void	O
version	()->(void)
(	O
)	O
{	O
license	()->(void)
(	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Written by Jean-loup Gailly.\n"	*(char)
)	O
;	O
}	O
local	O
void	O
progerror	(*(char))->(void)
(	O
char	O
const	O
*	O
string	*(char)
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: "	*(char)
,	O
program_name	*(char)
)	O
;	O
errno	O
=	O
e	int
;	O
perror	(*(char))->(void)
(	O
string	*(char)
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
file_count	int
;	O
size_t	long
proglen	long
;	O
char	O
*	O
*	O
argv_copy	*(*(char))
;	O
int	O
env_argc	int
;	O
char	O
*	O
*	O
env_argv	*(*(char))
;	O
EXPAND	O
(	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
program_name	*(char)
=	O
gzip_base_name	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
proglen	long
=	O
strlen	(*(char))->(long)
(	O
program_name	*(char)
)	O
;	O
if	O
(	O
4	int
<	O
proglen	long
&&	O
strequ	O
(	O
program_name	*(char)
+	O
proglen	long
-	O
4	int
,	O
".exe"	*(char)
)	O
)	O
program_name	*(char)
[	O
proglen	long
-	O
4	int
]	O
=	O
'\0'	O
;	O
argv_copy	*(*(char))
=	O
argv	*(*(char))
;	O
env	*(char)
=	O
add_envopt	(*(int),*(*(*(char))),*(char))->(*(char))
(	O
&	O
env_argc	int
,	O
&	O
argv_copy	*(*(char))
,	O
OPTIONS_VAR	*(char)
)	O
;	O
env_argv	*(*(char))
=	O
env	*(char)
?	O
argv_copy	*(*(char))
:	O
NULL	O
;	O
z_suffix	*(char)
=	O
Z_SUFFIX	*(char)
;	O
z_len	long
=	O
strlen	(*(char))->(long)
(	O
z_suffix	*(char)
)	O
;	O
while	O
(	O
true	int
)	O
{	O
int	O
optc	int
;	O
int	O
longind	int
=	O
-	O
1	int
;	O
if	O
(	O
env_argv	*(*(char))
)	O
{	O
if	O
(	O
env_argv	*(*(char))
[	O
optind	int
]	O
&&	O
strequ	O
(	O
env_argv	*(*(char))
[	O
optind	int
]	O
,	O
"--"	*(char)
)	O
)	O
optc	int
=	O
ENV_OPTION	int
+	O
'-'	O
;	O
else	O
{	O
optc	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
env_argc	int
,	O
env_argv	*(*(char))
,	O
shortopts	array(char)
,	O
longopts	array(struct(*(char),int,*(int),int))
,	O
&	O
longind	int
)	O
;	O
if	O
(	O
0	int
<=	O
optc	int
)	O
optc	int
+=	O
ENV_OPTION	int
;	O
else	O
{	O
if	O
(	O
optind	int
!=	O
env_argc	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
"%s: %s: non-option in "	*(char)
OPTIONS_VAR	*(char)
" environment variable\n"	*(char)
)	O
,	O
program_name	*(char)
,	O
env_argv	*(*(char))
[	O
optind	int
]	O
)	O
;	O
try_help	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
env_argc	int
!=	O
1	int
&&	O
!	O
quiet	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
"%s: warning: "	*(char)
OPTIONS_VAR	*(char)
" environment variable"	*(char)
" is deprecated; use an alias or script\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
env_argv	*(*(char))
)	O
;	O
env_argv	*(*(char))
=	O
NULL	O
;	O
optind	int
=	O
1	int
;	O
longind	int
=	O
-	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
env_argv	*(*(char))
)	O
optc	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
shortopts	array(char)
,	O
longopts	array(struct(*(char),int,*(int),int))
,	O
&	O
longind	int
)	O
;	O
if	O
(	O
optc	int
<	O
0	int
)	O
break	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'a'	O
:	O
ascii	int
=	O
1	int
;	O
break	O
;	O
case	O
'b'	O
:	O
maxbits	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
for	O
(	O
;	O
*	O
optarg	*(char)
;	O
optarg	*(char)
++	O
)	O
if	O
(	O
!	O
(	O
'0'	O
<=	O
*	O
optarg	*(char)
&&	O
*	O
optarg	*(char)
<=	O
'9'	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: -b operand is not an integer\n"	*(char)
,	O
program_name	*(char)
)	O
;	O
try_help	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
'c'	O
:	O
to_stdout	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
decompress	int
=	O
1	int
;	O
break	O
;	O
case	O
'f'	O
:	O
force	int
++	O
;	O
break	O
;	O
case	O
'h'	O
:	O
case	O
'H'	O
:	O
help	()->(void)
(	O
)	O
;	O
finish_out	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
keep	int
=	O
1	int
;	O
break	O
;	O
case	O
'l'	O
:	O
list	int
=	O
decompress	int
=	O
to_stdout	int
=	O
1	int
;	O
break	O
;	O
case	O
'L'	O
:	O
license	()->(void)
(	O
)	O
;	O
finish_out	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
no_time	int
=	O
1	int
;	O
break	O
;	O
case	O
'M'	O
:	O
no_time	int
=	O
0	int
;	O
break	O
;	O
case	O
'n'	O
:	O
case	O
'n'	O
+	O
ENV_OPTION	int
:	O
no_name	int
=	O
no_time	int
=	O
1	int
;	O
break	O
;	O
case	O
'N'	O
:	O
case	O
'N'	O
+	O
ENV_OPTION	int
:	O
no_name	int
=	O
no_time	int
=	O
0	int
;	O
break	O
;	O
case	O
PRESUME_INPUT_TTY_OPTION	int
:	O
presume_input_tty	bool
=	O
true	int
;	O
break	O
;	O
case	O
'q'	O
:	O
case	O
'q'	O
+	O
ENV_OPTION	int
:	O
quiet	int
=	O
1	int
;	O
verbose	int
=	O
0	int
;	O
break	O
;	O
case	O
'r'	O
:	O
recursive	int
=	O
1	int
;	O
break	O
;	O
case	O
RSYNCABLE_OPTION	int
:	O
case	O
RSYNCABLE_OPTION	int
+	O
ENV_OPTION	int
:	O
rsync	int
=	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
z_len	long
=	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
;	O
z_suffix	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
SYNCHRONOUS_OPTION	int
:	O
synchronous	bool
=	O
true	int
;	O
break	O
;	O
case	O
't'	O
:	O
test	int
=	O
decompress	int
=	O
to_stdout	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
case	O
'v'	O
+	O
ENV_OPTION	int
:	O
verbose	int
++	O
;	O
quiet	int
=	O
0	int
;	O
break	O
;	O
case	O
'V'	O
:	O
version	()->(void)
(	O
)	O
;	O
finish_out	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
'Z'	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: -Z not supported in this version\n"	*(char)
,	O
program_name	*(char)
)	O
;	O
try_help	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
'1'	O
+	O
ENV_OPTION	int
:	O
case	O
'2'	O
+	O
ENV_OPTION	int
:	O
case	O
'3'	O
+	O
ENV_OPTION	int
:	O
case	O
'4'	O
+	O
ENV_OPTION	int
:	O
case	O
'5'	O
+	O
ENV_OPTION	int
:	O
case	O
'6'	O
+	O
ENV_OPTION	int
:	O
case	O
'7'	O
+	O
ENV_OPTION	int
:	O
case	O
'8'	O
+	O
ENV_OPTION	int
:	O
case	O
'9'	O
+	O
ENV_OPTION	int
:	O
optc	int
-=	O
ENV_OPTION	int
;	O
FALLTHROUGH	O
;	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
level	int
=	O
optc	int
-	O
'0'	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
ENV_OPTION	int
<=	O
optc	int
&&	O
optc	int
!=	O
ENV_OPTION	int
+	O
'?'	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: "	*(char)
,	O
program_name	*(char)
)	O
;	O
if	O
(	O
longind	int
<	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"-%c: "	*(char)
,	O
optc	int
-	O
ENV_OPTION	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"--%s: "	*(char)
,	O
longopts	array(struct(*(char),int,*(int),int))
[	O
longind	int
]	O
.	O
name	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
"option not valid in "	*(char)
OPTIONS_VAR	*(char)
" environment variable\n"	*(char)
)	O
)	O
;	O
}	O
try_help	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
no_time	int
<	O
0	int
)	O
no_time	int
=	O
decompress	int
;	O
if	O
(	O
no_name	int
<	O
0	int
)	O
no_name	int
=	O
decompress	int
;	O
file_count	int
=	O
argc	int
-	O
optind	int
;	O
if	O
(	O
ascii	int
&&	O
!	O
quiet	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: option --ascii ignored on this system\n"	*(char)
,	O
program_name	*(char)
)	O
;	O
}	O
if	O
(	O
z_len	long
==	O
0	int
||	O
z_len	long
>	O
MAX_SUFFIX	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: invalid suffix '%s'\n"	*(char)
,	O
program_name	*(char)
,	O
z_suffix	*(char)
)	O
;	O
do_exit	(int)->(void)
(	O
ERROR	int
)	O
;	O
}	O
if	O
(	O
do_lzw	int
&&	O
!	O
decompress	int
)	O
work	*((int,int)->(int))
=	O
lzw	(int,int)->(int)
;	O
ALLOC	O
(	O
uch	char
,	O
inbuf	array(char)
,	O
INBUFSIZ	int
+	O
INBUF_EXTRA	int
)	O
;	O
ALLOC	O
(	O
uch	char
,	O
outbuf	array(char)
,	O
OUTBUFSIZ	int
+	O
OUTBUF_EXTRA	int
)	O
;	O
ALLOC	O
(	O
ush	short
,	O
d_buf	array(short)
,	O
DIST_BUFSIZE	int
)	O
;	O
ALLOC	O
(	O
uch	char
,	O
window	array(char)
,	O
2L	int
*	O
WSIZE	int
)	O
;	O
ALLOC	O
(	O
ush	short
,	O
tab_prefix	O
,	O
1L	int
<<	O
BITS	int
)	O
;	O
exiting_signal	int
=	O
quiet	int
?	O
SIGPIPE	int
:	O
0	int
;	O
install_signal_handlers	()->(void)
(	O
)	O
;	O
if	O
(	O
file_count	int
!=	O
0	int
)	O
{	O
if	O
(	O
to_stdout	int
&&	O
!	O
test	int
&&	O
!	O
list	int
&&	O
(	O
!	O
decompress	int
||	O
!	O
ascii	int
)	O
)	O
{	O
SET_BINARY_MODE	O
(	O
STDOUT_FILENO	int
)	O
;	O
}	O
while	O
(	O
optind	int
<	O
argc	int
)	O
{	O
treat_file	(*(char))->(void)
(	O
argv	*(*(char))
[	O
optind	int
++	O
]	O
)	O
;	O
}	O
}	O
else	O
{	O
treat_stdin	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stdin_was_read	bool
&&	O
close	*((*(void))->(int))
(	O
STDIN_FILENO	int
)	O
!=	O
0	int
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
ifname	array(char)
,	O
"stdin"	*(char)
)	O
;	O
read_error	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
list	int
)	O
{	O
if	O
(	O
!	O
quiet	int
&&	O
1	int
<	O
file_count	int
)	O
do_list	(int,int)->(void)
(	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
if	O
(	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
write_error	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
to_stdout	int
&&	O
(	O
(	O
synchronous	bool
&&	O
fdatasync	(int)->(int)
(	O
STDOUT_FILENO	int
)	O
!=	O
0	int
&&	O
errno	O
!=	O
EINVAL	int
)	O
||	O
close	*((*(void))->(int))
(	O
STDOUT_FILENO	int
)	O
!=	O
0	int
)	O
&&	O
errno	O
!=	O
EBADF	int
)	O
write_error	()->(void)
(	O
)	O
;	O
do_exit	(int)->(void)
(	O
exit_code	int
)	O
;	O
}	O
local	O
int	O
input_eof	()->(int)
(	O
)	O
{	O
if	O
(	O
!	O
decompress	int
||	O
last_member	int
)	O
return	O
1	int
;	O
if	O
(	O
inptr	int
==	O
insize	int
)	O
{	O
if	O
(	O
insize	int
!=	O
INBUFSIZ	int
||	O
fill_inbuf	(int)->(int)
(	O
1	int
)	O
==	O
EOF	O
)	O
return	O
1	int
;	O
inptr	int
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
get_input_size_and_time	()->(void)
(	O
void	O
)	O
{	O
ifile_size	long
=	O
-	O
1	int
;	O
time_stamp	struct(long,long)
.	O
tv_nsec	long
=	O
-	O
1	int
;	O
if	O
(	O
S_ISREG	O
(	O
istat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
ifile_size	long
=	O
istat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
;	O
if	O
(	O
!	O
no_time	int
||	O
list	int
)	O
time_stamp	struct(long,long)
=	O
get_stat_mtime	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(struct(long,long))
(	O
&	O
istat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
}	O
}	O
local	O
void	O
treat_stdin	()->(void)
(	O
)	O
{	O
if	O
(	O
!	O
force	int
&&	O
!	O
list	int
&&	O
(	O
presume_input_tty	bool
||	O
isatty	(int)->(int)
(	O
decompress	int
?	O
STDIN_FILENO	int
:	O
STDOUT_FILENO	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
quiet	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
"%s: compressed data not %s a terminal."	*(char)
" Use -f to force %scompression.\n"	*(char)
"For help, type: %s -h\n"	*(char)
)	O
,	O
program_name	*(char)
,	O
decompress	int
?	O
"read from"	*(char)
:	O
"written to"	*(char)
,	O
decompress	int
?	O
"de"	*(char)
:	O
""	*(char)
,	O
program_name	*(char)
)	O
;	O
do_exit	(int)->(void)
(	O
ERROR	int
)	O
;	O
}	O
if	O
(	O
decompress	int
||	O
!	O
ascii	int
)	O
{	O
SET_BINARY_MODE	O
(	O
STDIN_FILENO	int
)	O
;	O
}	O
if	O
(	O
!	O
test	int
&&	O
!	O
list	int
&&	O
(	O
!	O
decompress	int
||	O
!	O
ascii	int
)	O
)	O
{	O
SET_BINARY_MODE	O
(	O
STDOUT_FILENO	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
ifname	array(char)
,	O
"stdin"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
ofname	array(char)
,	O
"stdout"	*(char)
)	O
;	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
STDIN_FILENO	int
,	O
&	O
istat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
0	int
)	O
{	O
progerror	(*(char))->(void)
(	O
"standard input"	*(char)
)	O
;	O
do_exit	(int)->(void)
(	O
ERROR	int
)	O
;	O
}	O
get_input_size_and_time	()->(void)
(	O
)	O
;	O
clear_bufs	()->(void)
(	O
)	O
;	O
to_stdout	int
=	O
1	int
;	O
part_nb	int
=	O
0	int
;	O
ifd	int
=	O
STDIN_FILENO	int
;	O
stdin_was_read	bool
=	O
true	int
;	O
if	O
(	O
decompress	int
)	O
{	O
method	int
=	O
get_method	(int)->(int)
(	O
ifd	int
)	O
;	O
if	O
(	O
method	int
<	O
0	int
)	O
{	O
do_exit	(int)->(void)
(	O
exit_code	int
)	O
;	O
}	O
}	O
if	O
(	O
list	int
)	O
{	O
do_list	(int,int)->(void)
(	O
ifd	int
,	O
method	int
)	O
;	O
return	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
work	*((int,int)->(int))
(	O
STDIN_FILENO	int
,	O
STDOUT_FILENO	int
)	O
!=	O
OK	int
)	O
return	O
;	O
if	O
(	O
input_eof	()->(int)
(	O
)	O
)	O
break	O
;	O
method	int
=	O
get_method	(int)->(int)
(	O
ifd	int
)	O
;	O
if	O
(	O
method	int
<	O
0	int
)	O
return	O
;	O
bytes_out	long
=	O
0	int
;	O
}	O
if	O
(	O
verbose	int
)	O
{	O
if	O
(	O
test	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" OK\n"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
decompress	int
)	O
{	O
display_ratio	(long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
bytes_in	long
-	O
(	O
bytes_out	long
-	O
header_bytes	long
)	O
,	O
bytes_in	long
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
}	O
}	O
static	O
char	O
const	O
dot	char
=	O
'.'	O
;	O
static	O
bool	bool
atdir_eq	(*(char),long)->(bool)
(	O
char	O
const	O
*	O
dir	*(char)
,	O
ptrdiff_t	long
dirlen	long
)	O
{	O
if	O
(	O
dirlen	long
==	O
0	int
)	O
dir	*(char)
=	O
&	O
dot	char
,	O
dirlen	long
=	O
1	int
;	O
return	O
memcmp	(*(void),*(void),long)->(int)
(	O
dfname	array(char)
,	O
dir	*(char)
,	O
dirlen	long
)	O
==	O
0	int
&&	O
!	O
dfname	array(char)
[	O
dirlen	long
]	O
;	O
}	O
static	O
int	O
atdir_set	(*(char),long)->(int)
(	O
char	O
const	O
*	O
dir	*(char)
,	O
ptrdiff_t	long
dirlen	long
)	O
{	O
enum	O
{	O
try_opening_directories	int
=	O
true	int
}	O
;	O
if	O
(	O
try_opening_directories	int
&&	O
!	O
atdir_eq	(*(char),long)->(bool)
(	O
dir	*(char)
,	O
dirlen	long
)	O
)	O
{	O
if	O
(	O
0	int
<=	O
dfd	int
)	O
close	*((*(void))->(int))
(	O
dfd	int
)	O
;	O
if	O
(	O
dirlen	long
==	O
0	int
)	O
dir	*(char)
=	O
&	O
dot	char
,	O
dirlen	long
=	O
1	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dfname	array(char)
,	O
dir	*(char)
,	O
dirlen	long
)	O
;	O
dfname	array(char)
[	O
dirlen	long
]	O
=	O
'\0'	O
;	O
dfd	int
=	O
open	(*(char),int)->(int)
(	O
dfname	array(char)
,	O
O_SEARCH	O
|	O
O_DIRECTORY	O
)	O
;	O
}	O
return	O
dfd	int
;	O
}	O
local	O
void	O
treat_file	(*(char))->(void)
(	O
iname	*(char)
)	O
char	O
*	O
iname	*(char)
;	O
{	O
if	O
(	O
strequ	O
(	O
iname	*(char)
,	O
"-"	*(char)
)	O
)	O
{	O
int	O
cflag	int
=	O
to_stdout	int
;	O
treat_stdin	()->(void)
(	O
)	O
;	O
to_stdout	int
=	O
cflag	int
;	O
return	O
;	O
}	O
ifd	int
=	O
open_input_file	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
iname	*(char)
,	O
&	O
istat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
ifd	int
<	O
0	int
)	O
return	O
;	O
if	O
(	O
S_ISDIR	O
(	O
istat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
recursive	int
)	O
{	O
treat_dir	(int,*(char))->(void)
(	O
ifd	int
,	O
iname	*(char)
)	O
;	O
return	O
;	O
}	O
close	*((*(void))->(int))
(	O
ifd	int
)	O
;	O
WARN	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s is a directory -- ignored\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
to_stdout	int
)	O
{	O
if	O
(	O
!	O
S_ISREG	O
(	O
istat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
WARN	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s is not a directory or a regular file - ignored\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
)	O
)	O
;	O
close	*((*(void))->(int))
(	O
ifd	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
istat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
S_ISUID	O
)	O
{	O
WARN	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s is set-user-ID on execution - ignored\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
)	O
)	O
;	O
close	*((*(void))->(int))
(	O
ifd	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
istat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
S_ISGID	O
)	O
{	O
WARN	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s is set-group-ID on execution - ignored\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
)	O
)	O
;	O
close	*((*(void))->(int))
(	O
ifd	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
force	int
)	O
{	O
if	O
(	O
istat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
S_ISVTX	O
)	O
{	O
WARN	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s has the sticky bit set - file ignored\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
)	O
)	O
;	O
close	*((*(void))->(int))
(	O
ifd	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
2	int
<=	O
istat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_nlink	long
)	O
{	O
WARN	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s has %lu other link%c -- unchanged\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
,	O
(	O
unsigned	O
long	O
int	O
)	O
istat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_nlink	long
-	O
1	int
,	O
istat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_nlink	long
==	O
2	int
?	O
' '	O
:	O
's'	O
)	O
)	O
;	O
close	*((*(void))->(int))
(	O
ifd	int
)	O
;	O
return	O
;	O
}	O
}	O
}	O
get_input_size_and_time	()->(void)
(	O
)	O
;	O
if	O
(	O
to_stdout	int
&&	O
!	O
list	int
&&	O
!	O
test	int
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
ofname	array(char)
,	O
"stdout"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
make_ofname	()->(int)
(	O
)	O
!=	O
OK	int
)	O
{	O
close	*((*(void))->(int))
(	O
ifd	int
)	O
;	O
return	O
;	O
}	O
clear_bufs	()->(void)
(	O
)	O
;	O
part_nb	int
=	O
0	int
;	O
if	O
(	O
decompress	int
)	O
{	O
method	int
=	O
get_method	(int)->(int)
(	O
ifd	int
)	O
;	O
if	O
(	O
method	int
<	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
ifd	int
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
list	int
)	O
{	O
do_list	(int,int)->(void)
(	O
ifd	int
,	O
method	int
)	O
;	O
if	O
(	O
close	*((*(void))->(int))
(	O
ifd	int
)	O
!=	O
0	int
)	O
read_error	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
to_stdout	int
)	O
{	O
ofd	int
=	O
STDOUT_FILENO	int
;	O
}	O
else	O
{	O
if	O
(	O
create_outfile	()->(int)
(	O
)	O
!=	O
OK	int
)	O
return	O
;	O
if	O
(	O
!	O
decompress	int
&&	O
save_orig_name	int
&&	O
!	O
verbose	int
&&	O
!	O
quiet	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s compressed to %s\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
,	O
ofname	array(char)
)	O
;	O
}	O
}	O
if	O
(	O
!	O
save_orig_name	int
)	O
save_orig_name	int
=	O
!	O
no_name	int
;	O
if	O
(	O
verbose	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s:\t"	*(char)
,	O
ifname	array(char)
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
(	O
*	O
work	*((int,int)->(int))
)	O
(	O
ifd	int
,	O
ofd	int
)	O
!=	O
OK	int
)	O
{	O
method	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
input_eof	()->(int)
(	O
)	O
)	O
break	O
;	O
method	int
=	O
get_method	(int)->(int)
(	O
ifd	int
)	O
;	O
if	O
(	O
method	int
<	O
0	int
)	O
break	O
;	O
bytes_out	long
=	O
0	int
;	O
}	O
if	O
(	O
close	*((*(void))->(int))
(	O
ifd	int
)	O
!=	O
0	int
)	O
read_error	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
to_stdout	int
)	O
{	O
copy_stat	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(void)
(	O
&	O
istat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
(	O
synchronous	bool
&&	O
(	O
(	O
0	int
<=	O
dfd	int
&&	O
fdatasync	(int)->(int)
(	O
dfd	int
)	O
!=	O
0	int
&&	O
errno	O
!=	O
EINVAL	int
)	O
||	O
(	O
fsync	(int)->(int)
(	O
ofd	int
)	O
!=	O
0	int
&&	O
errno	O
!=	O
EINVAL	int
)	O
)	O
)	O
||	O
close	*((*(void))->(int))
(	O
ofd	int
)	O
!=	O
0	int
)	O
write_error	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
keep	int
)	O
{	O
sigset_t	struct(array(long))
oldset	struct(array(long))
;	O
int	O
unlink_errno	int
;	O
char	O
*	O
ifbase	*(char)
=	O
last_component	(*(char))->(*(char))
(	O
ifname	array(char)
)	O
;	O
int	O
ufd	int
=	O
atdir_eq	(*(char),long)->(bool)
(	O
ifname	array(char)
,	O
ifbase	*(char)
-	O
ifname	array(char)
)	O
?	O
dfd	int
:	O
-	O
1	int
;	O
int	O
res	int
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_BLOCK	int
,	O
&	O
caught_signals	struct(array(long))
,	O
&	O
oldset	struct(array(long))
)	O
;	O
remove_ofname_fd	int
=	O
-	O
1	int
;	O
res	int
=	O
ufd	int
<	O
0	int
?	O
xunlink	(*(char))->(int)
(	O
ifname	array(char)
)	O
:	O
unlinkat	(int,*(char),int)->(int)
(	O
ufd	int
,	O
ifbase	*(char)
,	O
0	int
)	O
;	O
unlink_errno	int
=	O
res	int
==	O
0	int
?	O
0	int
:	O
errno	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_SETMASK	int
,	O
&	O
oldset	struct(array(long))
,	O
NULL	O
)	O
;	O
if	O
(	O
unlink_errno	int
)	O
{	O
WARN	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: "	*(char)
,	O
program_name	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
quiet	int
)	O
{	O
errno	O
=	O
unlink_errno	int
;	O
perror	(*(char))->(void)
(	O
ifname	array(char)
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
method	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
to_stdout	int
)	O
remove_output_file	(bool)->(void)
(	O
false	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
verbose	int
)	O
{	O
if	O
(	O
test	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" OK"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
decompress	int
)	O
{	O
display_ratio	(long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
bytes_out	long
-	O
(	O
bytes_in	long
-	O
header_bytes	long
)	O
,	O
bytes_out	long
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
{	O
display_ratio	(long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
bytes_in	long
-	O
(	O
bytes_out	long
-	O
header_bytes	long
)	O
,	O
bytes_in	long
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
!	O
test	int
&&	O
!	O
to_stdout	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" -- %s %s"	*(char)
,	O
keep	int
?	O
"created"	*(char)
:	O
"replaced with"	*(char)
,	O
ofname	array(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
volatile_strcpy	(*(char),*(char))->(void)
(	O
char	O
volatile	O
*	O
dst	*(char)
,	O
char	O
const	O
volatile	O
*	O
src	*(char)
)	O
{	O
while	O
(	O
(	O
*	O
dst	*(char)
++	O
=	O
*	O
src	*(char)
++	O
)	O
)	O
continue	O
;	O
}	O
local	O
int	O
create_outfile	()->(int)
(	O
)	O
{	O
int	O
name_shortened	int
=	O
0	int
;	O
int	O
flags	*(short)
=	O
(	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_EXCL	int
|	O
(	O
ascii	int
&&	O
decompress	int
?	O
0	int
:	O
O_BINARY	int
)	O
)	O
;	O
char	O
const	O
*	O
base	*(char)
=	O
ofname	array(char)
;	O
int	O
atfd	int
=	O
AT_FDCWD	O
;	O
if	O
(	O
!	O
keep	int
)	O
{	O
char	O
const	O
*	O
b	struct(long,long)
=	O
last_component	(*(char))->(*(char))
(	O
ofname	array(char)
)	O
;	O
int	O
f	int
=	O
atdir_set	(*(char),long)->(int)
(	O
ofname	array(char)
,	O
b	struct(long,long)
-	O
ofname	array(char)
)	O
;	O
if	O
(	O
0	int
<=	O
f	int
)	O
{	O
base	*(char)
=	O
b	struct(long,long)
;	O
atfd	int
=	O
f	int
;	O
}	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
open_errno	int
;	O
sigset_t	struct(array(long))
oldset	struct(array(long))
;	O
volatile_strcpy	(*(char),*(char))->(void)
(	O
remove_ofname	array(char)
,	O
ofname	array(char)
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_BLOCK	int
,	O
&	O
caught_signals	struct(array(long))
,	O
&	O
oldset	struct(array(long))
)	O
;	O
remove_ofname_fd	int
=	O
ofd	int
=	O
openat	(int,*(char),int)->(int)
(	O
atfd	int
,	O
base	*(char)
,	O
flags	*(short)
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
;	O
open_errno	int
=	O
errno	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_SETMASK	int
,	O
&	O
oldset	struct(array(long))
,	O
NULL	O
)	O
;	O
if	O
(	O
0	int
<=	O
ofd	int
)	O
break	O
;	O
switch	O
(	O
open_errno	int
)	O
{	O
case	O
ENAMETOOLONG	int
:	O
shorten_name	(*(char))->(void)
(	O
ofname	array(char)
)	O
;	O
name_shortened	int
=	O
1	int
;	O
break	O
;	O
case	O
EEXIST	int
:	O
if	O
(	O
check_ofname	()->(int)
(	O
)	O
!=	O
OK	int
)	O
{	O
close	*((*(void))->(int))
(	O
ifd	int
)	O
;	O
return	O
ERROR	int
;	O
}	O
break	O
;	O
default	O
:	O
progerror	(*(char))->(void)
(	O
ofname	array(char)
)	O
;	O
close	*((*(void))->(int))
(	O
ifd	int
)	O
;	O
return	O
ERROR	int
;	O
}	O
}	O
if	O
(	O
name_shortened	int
&&	O
decompress	int
)	O
{	O
WARN	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s: warning, name truncated\n"	*(char)
,	O
program_name	*(char)
,	O
ofname	array(char)
)	O
)	O
;	O
}	O
return	O
OK	int
;	O
}	O
local	O
char	O
*	O
get_suffix	(*(char))->(*(char))
(	O
name	*(char)
)	O
char	O
*	O
name	*(char)
;	O
{	O
int	O
nlen	int
,	O
slen	int
;	O
char	O
suffix	array(char)
[	O
MAX_SUFFIX	int
+	O
3	int
]	O
;	O
static	O
char	O
const	O
*	O
known_suffixes	array(*(char))
[	O
]	O
=	O
{	O
NULL	O
,	O
".gz"	*(char)
,	O
".z"	*(char)
,	O
".taz"	*(char)
,	O
".tgz"	*(char)
,	O
"-gz"	*(char)
,	O
"-z"	*(char)
,	O
"_z"	*(char)
,	O
NULL	O
,	O
NULL	O
}	O
;	O
char	O
const	O
*	O
*	O
suf	*(*(char))
;	O
bool	bool
suffix_of_builtin	bool
=	O
false	int
;	O
for	O
(	O
suf	*(*(char))
=	O
known_suffixes	array(*(char))
+	O
1	int
;	O
*	O
suf	*(*(char))
;	O
suf	*(*(char))
++	O
)	O
{	O
size_t	long
suflen	long
=	O
strlen	(*(char))->(long)
(	O
*	O
suf	*(*(char))
)	O
;	O
if	O
(	O
z_len	long
<	O
suflen	long
&&	O
strequ	O
(	O
z_suffix	*(char)
,	O
*	O
suf	*(*(char))
+	O
suflen	long
-	O
z_len	long
)	O
)	O
{	O
suffix_of_builtin	bool
=	O
true	int
;	O
break	O
;	O
}	O
}	O
char	O
*	O
z_lower	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
z_suffix	*(char)
)	O
;	O
strlwr	(*(char))->(*(char))
(	O
z_lower	*(char)
)	O
;	O
known_suffixes	array(*(char))
[	O
suffix_of_builtin	bool
?	O
sizeof	O
known_suffixes	array(*(char))
/	O
sizeof	O
*	O
known_suffixes	array(*(char))
-	O
2	int
:	O
0	int
]	O
=	O
z_lower	*(char)
;	O
suf	*(*(char))
=	O
known_suffixes	array(*(char))
+	O
suffix_of_builtin	bool
;	O
nlen	int
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
if	O
(	O
nlen	int
<=	O
MAX_SUFFIX	int
+	O
2	int
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
suffix	array(char)
,	O
name	*(char)
)	O
;	O
}	O
else	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
suffix	array(char)
,	O
name	*(char)
+	O
nlen	int
-	O
MAX_SUFFIX	int
-	O
2	int
)	O
;	O
}	O
strlwr	(*(char))->(*(char))
(	O
suffix	array(char)
)	O
;	O
slen	int
=	O
strlen	(*(char))->(long)
(	O
suffix	array(char)
)	O
;	O
char	O
*	O
match	*(char)
=	O
NULL	O
;	O
do	O
{	O
int	O
s	*(char)
=	O
strlen	(*(char))->(long)
(	O
*	O
suf	*(*(char))
)	O
;	O
if	O
(	O
slen	int
>	O
s	*(char)
&&	O
!	O
ISSLASH	O
(	O
suffix	array(char)
[	O
slen	int
-	O
s	*(char)
-	O
1	int
]	O
)	O
&&	O
strequ	O
(	O
suffix	array(char)
+	O
slen	int
-	O
s	*(char)
,	O
*	O
suf	*(*(char))
)	O
)	O
{	O
match	*(char)
=	O
name	*(char)
+	O
nlen	int
-	O
s	*(char)
;	O
break	O
;	O
}	O
}	O
while	O
(	O
*	O
++	O
suf	*(*(char))
!=	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
z_lower	*(char)
)	O
;	O
return	O
match	*(char)
;	O
}	O
static	O
int	O
open_and_stat	(*(char),int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
char	O
*	O
name	*(char)
,	O
int	O
flags	*(short)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
int	O
fd	int
;	O
int	O
atfd	int
=	O
AT_FDCWD	O
;	O
char	O
const	O
*	O
base	*(char)
=	O
name	*(char)
;	O
if	O
(	O
!	O
to_stdout	int
&&	O
!	O
force	int
)	O
{	O
if	O
(	O
HAVE_WORKING_O_NOFOLLOW	int
)	O
flags	*(short)
|=	O
O_NOFOLLOW	O
;	O
else	O
{	O
if	O
(	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
name	*(char)
,	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
!=	O
0	int
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
S_ISLNK	O
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
)	O
{	O
errno	O
=	O
ELOOP	int
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
keep	int
)	O
{	O
char	O
const	O
*	O
b	struct(long,long)
=	O
last_component	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
int	O
f	int
=	O
atdir_set	(*(char),long)->(int)
(	O
name	*(char)
,	O
b	struct(long,long)
-	O
name	*(char)
)	O
;	O
if	O
(	O
0	int
<=	O
f	int
)	O
{	O
base	*(char)
=	O
b	struct(long,long)
;	O
atfd	int
=	O
f	int
;	O
}	O
}	O
fd	int
=	O
openat	(int,*(char),int)->(int)
(	O
atfd	int
,	O
base	*(char)
,	O
flags	*(short)
)	O
;	O
if	O
(	O
0	int
<=	O
fd	int
&&	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fd	int
,	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
!=	O
0	int
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
errno	O
=	O
e	int
;	O
return	O
-	O
1	int
;	O
}	O
return	O
fd	int
;	O
}	O
static	O
int	O
open_input_file	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
iname	*(char)
,	O
sbuf	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
char	O
*	O
iname	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
sbuf	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
{	O
int	O
ilen	int
;	O
int	O
z_suffix_errno	int
=	O
0	int
;	O
static	O
char	O
const	O
*	O
suffixes	array(*(char))
[	O
]	O
=	O
{	O
NULL	O
,	O
".gz"	*(char)
,	O
".z"	*(char)
,	O
"-z"	*(char)
,	O
".Z"	*(char)
,	O
NULL	O
}	O
;	O
char	O
const	O
*	O
*	O
suf	*(*(char))
=	O
suffixes	array(*(char))
;	O
char	O
const	O
*	O
s	*(char)
;	O
int	O
fd	int
;	O
int	O
open_flags	int
=	O
(	O
O_RDONLY	int
|	O
O_NONBLOCK	int
|	O
O_NOCTTY	int
|	O
(	O
ascii	int
&&	O
!	O
decompress	int
?	O
0	int
:	O
O_BINARY	int
)	O
)	O
;	O
*	O
suf	*(*(char))
=	O
z_suffix	*(char)
;	O
if	O
(	O
sizeof	O
ifname	array(char)
-	O
1	int
<=	O
strlen	(*(char))->(long)
(	O
iname	*(char)
)	O
)	O
goto	O
name_too_long	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
ifname	array(char)
,	O
iname	*(char)
)	O
;	O
fd	int
=	O
open_and_stat	(*(char),int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
ifname	array(char)
,	O
open_flags	int
,	O
sbuf	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
if	O
(	O
0	int
<=	O
fd	int
)	O
return	O
fd	int
;	O
if	O
(	O
!	O
decompress	int
||	O
errno	O
!=	O
ENOENT	int
)	O
{	O
progerror	(*(char))->(void)
(	O
ifname	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
s	*(char)
=	O
get_suffix	(*(char))->(*(char))
(	O
ifname	array(char)
)	O
;	O
if	O
(	O
s	*(char)
!=	O
NULL	O
)	O
{	O
progerror	(*(char))->(void)
(	O
ifname	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
ilen	int
=	O
strlen	(*(char))->(long)
(	O
ifname	array(char)
)	O
;	O
if	O
(	O
strequ	O
(	O
z_suffix	*(char)
,	O
".gz"	*(char)
)	O
)	O
suf	*(*(char))
++	O
;	O
do	O
{	O
char	O
const	O
*	O
s0	*(char)
=	O
s	*(char)
=	O
*	O
suf	*(*(char))
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
ifname	array(char)
,	O
iname	*(char)
)	O
;	O
if	O
(	O
sizeof	O
ifname	array(char)
<=	O
ilen	int
+	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
)	O
goto	O
name_too_long	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
ifname	array(char)
,	O
s	*(char)
)	O
;	O
fd	int
=	O
open_and_stat	(*(char),int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
ifname	array(char)
,	O
open_flags	int
,	O
sbuf	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
if	O
(	O
0	int
<=	O
fd	int
)	O
return	O
fd	int
;	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
{	O
progerror	(*(char))->(void)
(	O
ifname	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
strequ	O
(	O
s0	*(char)
,	O
z_suffix	*(char)
)	O
)	O
z_suffix_errno	int
=	O
errno	O
;	O
}	O
while	O
(	O
*	O
++	O
suf	*(*(char))
!=	O
NULL	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
ifname	array(char)
,	O
iname	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
ifname	array(char)
,	O
z_suffix	*(char)
)	O
;	O
errno	O
=	O
z_suffix_errno	int
;	O
progerror	(*(char))->(void)
(	O
ifname	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
name_too_long	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s: file name too long\n"	*(char)
,	O
program_name	*(char)
,	O
iname	*(char)
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
return	O
-	O
1	int
;	O
}	O
local	O
int	O
make_ofname	()->(int)
(	O
)	O
{	O
char	O
*	O
suff	*(char)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
ofname	array(char)
,	O
ifname	array(char)
)	O
;	O
suff	*(char)
=	O
get_suffix	(*(char))->(*(char))
(	O
ofname	array(char)
)	O
;	O
if	O
(	O
decompress	int
)	O
{	O
if	O
(	O
suff	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
recursive	int
&&	O
(	O
list	int
||	O
test	int
)	O
)	O
return	O
OK	int
;	O
if	O
(	O
verbose	int
||	O
(	O
!	O
recursive	int
&&	O
!	O
quiet	int
)	O
)	O
{	O
WARN	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s: unknown suffix -- ignored\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
)	O
)	O
;	O
}	O
return	O
WARNING	int
;	O
}	O
strlwr	(*(char))->(*(char))
(	O
suff	*(char)
)	O
;	O
if	O
(	O
strequ	O
(	O
suff	*(char)
,	O
".tgz"	*(char)
)	O
||	O
strequ	O
(	O
suff	*(char)
,	O
".taz"	*(char)
)	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
suff	*(char)
,	O
".tar"	*(char)
)	O
;	O
}	O
else	O
{	O
*	O
suff	*(char)
=	O
'\0'	O
;	O
}	O
}	O
else	O
if	O
(	O
suff	*(char)
&&	O
!	O
force	int
)	O
{	O
if	O
(	O
verbose	int
||	O
(	O
!	O
recursive	int
&&	O
!	O
quiet	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s already has %s suffix -- unchanged\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
,	O
suff	*(char)
)	O
;	O
}	O
return	O
WARNING	int
;	O
}	O
else	O
{	O
save_orig_name	int
=	O
0	int
;	O
if	O
(	O
sizeof	O
ofname	array(char)
<=	O
strlen	(*(char))->(long)
(	O
ofname	array(char)
)	O
+	O
z_len	long
)	O
goto	O
name_too_long	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
ofname	array(char)
,	O
z_suffix	*(char)
)	O
;	O
}	O
return	O
OK	int
;	O
name_too_long	O
:	O
WARN	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s: file name too long\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
)	O
)	O
;	O
return	O
WARNING	int
;	O
}	O
static	O
void	O
discard_input_bytes	(long,int)->(void)
(	O
nbytes	long
,	O
flags	*(short)
)	O
size_t	long
nbytes	long
;	O
unsigned	O
int	O
flags	*(short)
;	O
{	O
while	O
(	O
nbytes	long
!=	O
0	int
)	O
{	O
uch	char
c	char
=	O
get_byte	O
(	O
)	O
;	O
if	O
(	O
flags	*(short)
&	O
HEADER_CRC	int
)	O
updcrc	(*(char),int)->(long)
(	O
&	O
c	char
,	O
1	int
)	O
;	O
if	O
(	O
nbytes	long
!=	O
(	O
size_t	long
)	O
-	O
1	int
)	O
nbytes	long
--	O
;	O
else	O
if	O
(	O
!	O
c	char
)	O
break	O
;	O
}	O
}	O
local	O
int	O
get_method	(int)->(int)
(	O
in	int
)	O
int	O
in	int
;	O
{	O
uch	char
flags	*(short)
;	O
uch	char
magic	array(char)
[	O
10	int
]	O
;	O
int	O
imagic0	int
;	O
int	O
imagic1	int
;	O
ulg	long
stamp	long
;	O
if	O
(	O
force	int
&&	O
to_stdout	int
)	O
{	O
imagic0	int
=	O
try_byte	O
(	O
)	O
;	O
magic	array(char)
[	O
0	int
]	O
=	O
imagic0	int
;	O
imagic1	int
=	O
try_byte	O
(	O
)	O
;	O
magic	array(char)
[	O
1	int
]	O
=	O
imagic1	int
;	O
}	O
else	O
{	O
magic	array(char)
[	O
0	int
]	O
=	O
get_byte	O
(	O
)	O
;	O
imagic0	int
=	O
0	int
;	O
if	O
(	O
magic	array(char)
[	O
0	int
]	O
)	O
{	O
magic	array(char)
[	O
1	int
]	O
=	O
get_byte	O
(	O
)	O
;	O
imagic1	int
=	O
0	int
;	O
}	O
else	O
{	O
imagic1	int
=	O
try_byte	O
(	O
)	O
;	O
magic	array(char)
[	O
1	int
]	O
=	O
imagic1	int
;	O
}	O
}	O
method	int
=	O
-	O
1	int
;	O
part_nb	int
++	O
;	O
header_bytes	long
=	O
0	int
;	O
last_member	int
=	O
0	int
;	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
magic	array(char)
,	O
GZIP_MAGIC	*(char)
,	O
2	int
)	O
==	O
0	int
||	O
memcmp	(*(void),*(void),long)->(int)
(	O
magic	array(char)
,	O
OLD_GZIP_MAGIC	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
{	O
method	int
=	O
(	O
int	O
)	O
get_byte	O
(	O
)	O
;	O
if	O
(	O
method	int
!=	O
DEFLATED	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s: unknown method %d -- not supported\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
,	O
method	int
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
return	O
-	O
1	int
;	O
}	O
work	*((int,int)->(int))
=	O
unzip	(int,int)->(int)
;	O
flags	*(short)
=	O
(	O
uch	char
)	O
get_byte	O
(	O
)	O
;	O
if	O
(	O
(	O
flags	*(short)
&	O
ENCRYPTED	int
)	O
!=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s is encrypted -- not supported\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
flags	*(short)
&	O
RESERVED	int
)	O
!=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s has flags 0x%x -- not supported\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
,	O
flags	*(short)
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
if	O
(	O
force	int
<=	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
stamp	long
=	O
(	O
ulg	long
)	O
get_byte	O
(	O
)	O
;	O
stamp	long
|=	O
(	O
(	O
ulg	long
)	O
get_byte	O
(	O
)	O
)	O
<<	O
8	int
;	O
stamp	long
|=	O
(	O
(	O
ulg	long
)	O
get_byte	O
(	O
)	O
)	O
<<	O
16	int
;	O
stamp	long
|=	O
(	O
(	O
ulg	long
)	O
get_byte	O
(	O
)	O
)	O
<<	O
24	int
;	O
if	O
(	O
stamp	long
!=	O
0	int
&&	O
!	O
no_time	int
)	O
{	O
if	O
(	O
stamp	long
<=	O
TYPE_MAXIMUM	O
(	O
time_t	long
)	O
)	O
{	O
time_stamp	struct(long,long)
.	O
tv_sec	long
=	O
stamp	long
;	O
time_stamp	struct(long,long)
.	O
tv_nsec	long
=	O
0	int
;	O
}	O
else	O
{	O
WARN	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s: MTIME %lu out of range for this platform\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
,	O
stamp	long
)	O
)	O
;	O
time_stamp	struct(long,long)
.	O
tv_sec	long
=	O
TYPE_MAXIMUM	O
(	O
time_t	long
)	O
;	O
time_stamp	struct(long,long)
.	O
tv_nsec	long
=	O
TIMESPEC_RESOLUTION	int
-	O
1	int
;	O
}	O
}	O
magic	array(char)
[	O
8	int
]	O
=	O
get_byte	O
(	O
)	O
;	O
magic	array(char)
[	O
9	int
]	O
=	O
get_byte	O
(	O
)	O
;	O
if	O
(	O
flags	*(short)
&	O
HEADER_CRC	int
)	O
{	O
magic	array(char)
[	O
2	int
]	O
=	O
DEFLATED	int
;	O
magic	array(char)
[	O
3	int
]	O
=	O
flags	*(short)
;	O
magic	array(char)
[	O
4	int
]	O
=	O
stamp	long
&	O
0xff	int
;	O
magic	array(char)
[	O
5	int
]	O
=	O
(	O
stamp	long
>>	O
8	int
)	O
&	O
0xff	int
;	O
magic	array(char)
[	O
6	int
]	O
=	O
(	O
stamp	long
>>	O
16	int
)	O
&	O
0xff	int
;	O
magic	array(char)
[	O
7	int
]	O
=	O
stamp	long
>>	O
24	int
;	O
updcrc	(*(char),int)->(long)
(	O
NULL	O
,	O
0	int
)	O
;	O
updcrc	(*(char),int)->(long)
(	O
magic	array(char)
,	O
10	int
)	O
;	O
}	O
if	O
(	O
(	O
flags	*(short)
&	O
EXTRA_FIELD	int
)	O
!=	O
0	int
)	O
{	O
uch	char
lenbuf	array(char)
[	O
2	int
]	O
;	O
unsigned	O
int	O
len	int
=	O
lenbuf	array(char)
[	O
0	int
]	O
=	O
get_byte	O
(	O
)	O
;	O
len	int
|=	O
(	O
lenbuf	array(char)
[	O
1	int
]	O
=	O
get_byte	O
(	O
)	O
)	O
<<	O
8	int
;	O
if	O
(	O
verbose	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s: extra field of %u bytes ignored\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
,	O
len	int
)	O
;	O
}	O
if	O
(	O
flags	*(short)
&	O
HEADER_CRC	int
)	O
updcrc	(*(char),int)->(long)
(	O
lenbuf	array(char)
,	O
2	int
)	O
;	O
discard_input_bytes	(long,int)->(void)
(	O
len	int
,	O
flags	*(short)
)	O
;	O
}	O
if	O
(	O
(	O
flags	*(short)
&	O
ORIG_NAME	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
no_name	int
||	O
(	O
to_stdout	int
&&	O
!	O
list	int
)	O
||	O
part_nb	int
>	O
1	int
)	O
{	O
discard_input_bytes	(long,int)->(void)
(	O
-	O
1	int
,	O
flags	*(short)
)	O
;	O
}	O
else	O
{	O
char	O
*	O
p	*(void)
=	O
gzip_base_name	(*(char))->(*(char))
(	O
ofname	array(char)
)	O
;	O
char	O
*	O
base	*(char)
=	O
p	*(void)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
*	O
p	*(void)
=	O
(	O
char	O
)	O
get_byte	O
(	O
)	O
;	O
if	O
(	O
*	O
p	*(void)
++	O
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
p	*(void)
>=	O
ofname	array(char)
+	O
sizeof	O
(	O
ofname	array(char)
)	O
)	O
{	O
gzip_error	(*(char))->(void)
(	O
"corrupted input -- file name too large"	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
flags	*(short)
&	O
HEADER_CRC	int
)	O
updcrc	(*(char),int)->(long)
(	O
(	O
uch	char
*	O
)	O
base	*(char)
,	O
p	*(void)
-	O
base	*(char)
)	O
;	O
p	*(void)
=	O
gzip_base_name	(*(char))->(*(char))
(	O
base	*(char)
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
base	*(char)
,	O
p	*(void)
,	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
list	int
)	O
{	O
MAKE_LEGAL_NAME	O
(	O
base	*(char)
)	O
;	O
if	O
(	O
base	*(char)
)	O
list	int
=	O
0	int
;	O
}	O
}	O
}	O
if	O
(	O
(	O
flags	*(short)
&	O
COMMENT	int
)	O
!=	O
0	int
)	O
{	O
discard_input_bytes	(long,int)->(void)
(	O
-	O
1	int
,	O
flags	*(short)
)	O
;	O
}	O
if	O
(	O
flags	*(short)
&	O
HEADER_CRC	int
)	O
{	O
unsigned	O
int	O
crc16	int
=	O
updcrc	(*(char),int)->(long)
(	O
magic	array(char)
,	O
0	int
)	O
&	O
0xffff	int
;	O
unsigned	O
int	O
header16	int
=	O
get_byte	O
(	O
)	O
;	O
header16	int
|=	O
(	O
(	O
unsigned	O
int	O
)	O
get_byte	O
(	O
)	O
)	O
<<	O
8	int
;	O
if	O
(	O
header16	int
!=	O
crc16	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s: header checksum 0x%04x != computed checksum 0x%04x\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
,	O
header16	int
,	O
crc16	int
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
if	O
(	O
force	int
<=	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
part_nb	int
==	O
1	int
)	O
{	O
header_bytes	long
=	O
inptr	int
+	O
2	int
*	O
4	int
;	O
}	O
}	O
else	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
magic	array(char)
,	O
PKZIP_MAGIC	*(char)
,	O
2	int
)	O
==	O
0	int
&&	O
inptr	int
==	O
2	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
(	O
char	O
*	O
)	O
inbuf	array(char)
,	O
PKZIP_MAGIC	*(char)
,	O
4	int
)	O
==	O
0	int
)	O
{	O
inptr	int
=	O
0	int
;	O
work	*((int,int)->(int))
=	O
unzip	(int,int)->(int)
;	O
if	O
(	O
check_zipfile	(int)->(int)
(	O
in	int
)	O
!=	O
OK	int
)	O
return	O
-	O
1	int
;	O
last_member	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
magic	array(char)
,	O
PACK_MAGIC	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
{	O
work	*((int,int)->(int))
=	O
unpack	(int,int)->(int)
;	O
method	int
=	O
PACKED	int
;	O
}	O
else	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
magic	array(char)
,	O
LZW_MAGIC	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
{	O
work	*((int,int)->(int))
=	O
unlzw	(int,int)->(int)
;	O
method	int
=	O
COMPRESSED	int
;	O
last_member	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
magic	array(char)
,	O
LZH_MAGIC	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
{	O
work	*((int,int)->(int))
=	O
unlzh	(int,int)->(int)
;	O
method	int
=	O
LZHED	int
;	O
last_member	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
force	int
&&	O
to_stdout	int
&&	O
!	O
list	int
)	O
{	O
method	int
=	O
STORED	int
;	O
work	*((int,int)->(int))
=	O
copy	(int,int)->(int)
;	O
if	O
(	O
imagic1	int
!=	O
EOF	O
)	O
inptr	int
--	O
;	O
last_member	int
=	O
1	int
;	O
if	O
(	O
imagic0	int
!=	O
EOF	O
)	O
{	O
write_buf	(int,*(void),int)->(void)
(	O
STDOUT_FILENO	int
,	O
magic	array(char)
,	O
1	int
)	O
;	O
bytes_out	long
++	O
;	O
}	O
}	O
if	O
(	O
method	int
>=	O
0	int
)	O
return	O
method	int
;	O
if	O
(	O
part_nb	int
==	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n%s: %s: not in gzip format\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
magic	array(char)
[	O
0	int
]	O
==	O
0	int
)	O
{	O
int	O
inbyte	int
;	O
for	O
(	O
inbyte	int
=	O
imagic1	int
;	O
inbyte	int
==	O
0	int
;	O
inbyte	int
=	O
try_byte	O
(	O
)	O
)	O
continue	O
;	O
if	O
(	O
inbyte	int
==	O
EOF	O
)	O
{	O
if	O
(	O
verbose	int
)	O
WARN	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n%s: %s: decompression OK, trailing zero bytes ignored\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
)	O
)	O
;	O
return	O
-	O
3	int
;	O
}	O
}	O
WARN	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n%s: %s: decompression OK, trailing garbage ignored\n"	*(char)
,	O
program_name	*(char)
,	O
ifname	array(char)
)	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
}	O
local	O
void	O
do_list	(int,int)->(void)
(	O
ifd	int
,	O
method	int
)	O
int	O
ifd	int
;	O
int	O
method	int
;	O
{	O
ulg	long
crc	long
;	O
static	O
int	O
first_time	int
=	O
1	int
;	O
static	O
char	O
const	O
*	O
const	O
methods	array(*(char))
[	O
MAX_METHODS	int
]	O
=	O
{	O
"store"	*(char)
,	O
"compr"	*(char)
,	O
"pack "	*(char)
,	O
"lzh  "	*(char)
,	O
""	*(char)
,	O
""	*(char)
,	O
""	*(char)
,	O
""	*(char)
,	O
"defla"	*(char)
}	O
;	O
int	O
positive_off_t_width	int
=	O
INT_STRLEN_BOUND	O
(	O
off_t	long
)	O
-	O
1	int
;	O
if	O
(	O
first_time	int
&&	O
method	int
>=	O
0	int
)	O
{	O
first_time	int
=	O
0	int
;	O
if	O
(	O
verbose	int
)	O
{	O
printf	(*(char))->(int)
(	O
"method  crc     date  time  "	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
quiet	int
)	O
{	O
printf	(*(char))->(int)
(	O
"%*.*s %*.*s  ratio uncompressed_name\n"	*(char)
,	O
positive_off_t_width	int
,	O
positive_off_t_width	int
,	O
"compressed"	*(char)
,	O
positive_off_t_width	int
,	O
positive_off_t_width	int
,	O
"uncompressed"	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
method	int
<	O
0	int
)	O
{	O
if	O
(	O
total_in	long
<=	O
0	int
||	O
total_out	long
<=	O
0	int
)	O
return	O
;	O
if	O
(	O
verbose	int
)	O
{	O
printf	(*(char))->(int)
(	O
"                            "	*(char)
)	O
;	O
}	O
if	O
(	O
verbose	int
||	O
!	O
quiet	int
)	O
{	O
fprint_off	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
total_in	long
,	O
positive_off_t_width	int
)	O
;	O
printf	(*(char))->(int)
(	O
" "	*(char)
)	O
;	O
fprint_off	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
total_out	long
,	O
positive_off_t_width	int
)	O
;	O
printf	(*(char))->(int)
(	O
" "	*(char)
)	O
;	O
}	O
display_ratio	(long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
total_out	long
-	O
(	O
total_in	long
-	O
header_bytes	long
)	O
,	O
total_out	long
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
printf	(*(char))->(int)
(	O
" (totals)\n"	*(char)
)	O
;	O
return	O
;	O
}	O
crc	long
=	O
(	O
ulg	long
)	O
~	O
0	int
;	O
bytes_out	long
=	O
-	O
1L	int
;	O
bytes_in	long
=	O
ifile_size	long
;	O
if	O
(	O
method	int
==	O
DEFLATED	int
&&	O
!	O
last_member	int
)	O
{	O
bytes_in	long
=	O
lseek	(int,long,int)->(long)
(	O
ifd	int
,	O
(	O
off_t	long
)	O
(	O
-	O
8	int
)	O
,	O
SEEK_END	int
)	O
;	O
if	O
(	O
bytes_in	long
!=	O
-	O
1L	int
)	O
{	O
uch	char
buf	*(char)
[	O
8	int
]	O
;	O
bytes_in	long
+=	O
8L	int
;	O
if	O
(	O
read	*((*(void),*(char),long)->(long))
(	O
ifd	int
,	O
(	O
char	O
*	O
)	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
!=	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
{	O
read_error	()->(void)
(	O
)	O
;	O
}	O
crc	long
=	O
LG	O
(	O
buf	*(char)
)	O
;	O
bytes_out	long
=	O
LG	O
(	O
buf	*(char)
+	O
4	int
)	O
;	O
}	O
}	O
if	O
(	O
verbose	int
)	O
{	O
static	O
char	O
const	O
month_abbr	array(array(char))
[	O
]	O
[	O
4	int
]	O
=	O
{	O
"Jan"	*(char)
,	O
"Feb"	*(char)
,	O
"Mar"	*(char)
,	O
"Apr"	*(char)
,	O
"May"	*(char)
,	O
"Jun"	*(char)
,	O
"Jul"	*(char)
,	O
"Aug"	*(char)
,	O
"Sep"	*(char)
,	O
"Oct"	*(char)
,	O
"Nov"	*(char)
,	O
"Dec"	*(char)
}	O
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
=	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
time_stamp	struct(long,long)
.	O
tv_sec	long
)	O
;	O
printf	(*(char))->(int)
(	O
"%5s %08lx "	*(char)
,	O
methods	array(*(char))
[	O
method	int
]	O
,	O
crc	long
)	O
;	O
if	O
(	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
printf	(*(char))->(int)
(	O
"%s%3d %02d:%02d "	*(char)
,	O
month_abbr	array(array(char))
[	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
->	O
tm_mon	int
]	O
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
->	O
tm_mday	int
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
->	O
tm_hour	int
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
->	O
tm_min	int
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"??? ?? ??:?? "	*(char)
)	O
;	O
}	O
fprint_off	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
bytes_in	long
,	O
positive_off_t_width	int
)	O
;	O
printf	(*(char))->(int)
(	O
" "	*(char)
)	O
;	O
fprint_off	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
bytes_out	long
,	O
positive_off_t_width	int
)	O
;	O
printf	(*(char))->(int)
(	O
" "	*(char)
)	O
;	O
if	O
(	O
bytes_in	long
==	O
-	O
1L	int
)	O
{	O
total_in	long
=	O
-	O
1L	int
;	O
bytes_in	long
=	O
bytes_out	long
=	O
header_bytes	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
total_in	long
>=	O
0	int
)	O
{	O
total_in	long
+=	O
bytes_in	long
;	O
}	O
if	O
(	O
bytes_out	long
==	O
-	O
1L	int
)	O
{	O
total_out	long
=	O
-	O
1L	int
;	O
bytes_in	long
=	O
bytes_out	long
=	O
header_bytes	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
total_out	long
>=	O
0	int
)	O
{	O
total_out	long
+=	O
bytes_out	long
;	O
}	O
display_ratio	(long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
bytes_out	long
-	O
(	O
bytes_in	long
-	O
header_bytes	long
)	O
,	O
bytes_out	long
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
printf	(*(char))->(int)
(	O
" %s\n"	*(char)
,	O
ofname	array(char)
)	O
;	O
}	O
local	O
void	O
shorten_name	(*(char))->(void)
(	O
name	*(char)
)	O
char	O
*	O
name	*(char)
;	O
{	O
int	O
len	int
;	O
char	O
*	O
trunc	*(char)
=	O
NULL	O
;	O
int	O
plen	int
;	O
int	O
min_part	int
=	O
MIN_PART	int
;	O
char	O
*	O
p	*(void)
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
if	O
(	O
decompress	int
)	O
{	O
if	O
(	O
len	int
<=	O
1	int
)	O
gzip_error	(*(char))->(void)
(	O
"name too short"	*(char)
)	O
;	O
name	*(char)
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
;	O
}	O
p	*(void)
=	O
get_suffix	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
gzip_error	(*(char))->(void)
(	O
"can't recover suffix\n"	*(char)
)	O
;	O
*	O
p	*(void)
=	O
'\0'	O
;	O
save_orig_name	int
=	O
1	int
;	O
if	O
(	O
len	int
>	O
4	int
&&	O
strequ	O
(	O
p	*(void)
-	O
4	int
,	O
".tar"	*(char)
)	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
-	O
4	int
,	O
".tgz"	*(char)
)	O
;	O
return	O
;	O
}	O
do	O
{	O
p	*(void)
=	O
last_component	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
while	O
(	O
*	O
p	*(void)
)	O
{	O
plen	int
=	O
strcspn	(*(char),*(char))->(long)
(	O
p	*(void)
,	O
PART_SEP	*(char)
)	O
;	O
p	*(void)
+=	O
plen	int
;	O
if	O
(	O
plen	int
>	O
min_part	int
)	O
trunc	*(char)
=	O
p	*(void)
-	O
1	int
;	O
if	O
(	O
*	O
p	*(void)
)	O
p	*(void)
++	O
;	O
}	O
}	O
while	O
(	O
trunc	*(char)
==	O
NULL	O
&&	O
--	O
min_part	int
!=	O
0	int
)	O
;	O
if	O
(	O
trunc	*(char)
!=	O
NULL	O
)	O
{	O
do	O
{	O
trunc	*(char)
[	O
0	int
]	O
=	O
trunc	*(char)
[	O
1	int
]	O
;	O
}	O
while	O
(	O
*	O
trunc	*(char)
++	O
)	O
;	O
trunc	*(char)
--	O
;	O
}	O
else	O
{	O
trunc	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
name	*(char)
,	O
PART_SEP	*(char)
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
trunc	*(char)
)	O
gzip_error	(*(char))->(void)
(	O
"internal error in shorten_name"	*(char)
)	O
;	O
if	O
(	O
trunc	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
trunc	*(char)
--	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
trunc	*(char)
,	O
z_suffix	*(char)
)	O
;	O
}	O
local	O
int	O
check_ofname	()->(int)
(	O
)	O
{	O
if	O
(	O
!	O
force	int
)	O
{	O
int	O
ok	int
=	O
0	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s already exists;"	*(char)
,	O
program_name	*(char)
,	O
ofname	array(char)
)	O
;	O
if	O
(	O
foreground	int
&&	O
(	O
presume_input_tty	bool
||	O
isatty	(int)->(int)
(	O
STDIN_FILENO	int
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" do you wish to overwrite (y or n)? "	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
ok	int
=	O
yesno	()->(bool)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
ok	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\tnot overwritten\n"	*(char)
)	O
;	O
if	O
(	O
exit_code	int
==	O
OK	int
)	O
exit_code	int
=	O
WARNING	int
;	O
return	O
ERROR	int
;	O
}	O
}	O
if	O
(	O
xunlink	(*(char))->(int)
(	O
ofname	array(char)
)	O
)	O
{	O
progerror	(*(char))->(void)
(	O
ofname	array(char)
)	O
;	O
return	O
ERROR	int
;	O
}	O
return	O
OK	int
;	O
}	O
static	O
void	O
do_chown	(int,*(char),int,int)->(void)
(	O
int	O
fd	int
,	O
char	O
const	O
*	O
name	*(char)
,	O
uid_t	int
uid	int
,	O
gid_t	int
gid	int
)	O
{	O
ignore_value	O
(	O
fchown	(int,int,int)->(int)
(	O
fd	int
,	O
uid	int
,	O
gid	int
)	O
)	O
;	O
}	O
local	O
void	O
copy_stat	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(void)
(	O
ifstat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
ifstat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
{	O
mode_t	int
mode	int
=	O
ifstat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
&	O
S_IRWXUGO	O
;	O
int	O
r	struct(long,long)
;	O
bool	bool
restoring	bool
;	O
struct	O
timespec	struct(long,long)
timespec	struct(long,long)
[	O
2	int
]	O
;	O
timespec	struct(long,long)
[	O
0	int
]	O
=	O
get_stat_atime	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(struct(long,long))
(	O
ifstat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
timespec	struct(long,long)
[	O
1	int
]	O
=	O
get_stat_mtime	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(struct(long,long))
(	O
ifstat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
restoring	bool
=	O
(	O
decompress	int
&&	O
0	int
<=	O
time_stamp	struct(long,long)
.	O
tv_nsec	long
&&	O
!	O
(	O
timespec	struct(long,long)
[	O
1	int
]	O
.	O
tv_sec	long
==	O
time_stamp	struct(long,long)
.	O
tv_sec	long
&&	O
timespec	struct(long,long)
[	O
1	int
]	O
.	O
tv_nsec	long
==	O
time_stamp	struct(long,long)
.	O
tv_nsec	long
)	O
)	O
;	O
if	O
(	O
restoring	bool
)	O
timespec	struct(long,long)
[	O
1	int
]	O
=	O
time_stamp	struct(long,long)
;	O
if	O
(	O
fdutimens	(int,*(char),array(struct(long,long)))->(int)
(	O
ofd	int
,	O
ofname	array(char)
,	O
timespec	struct(long,long)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
restoring	bool
&&	O
1	int
<	O
verbose	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: timestamp restored\n"	*(char)
,	O
ofname	array(char)
)	O
;	O
}	O
}	O
else	O
{	O
int	O
e	int
=	O
errno	O
;	O
WARN	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: "	*(char)
,	O
program_name	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
quiet	int
)	O
{	O
errno	O
=	O
e	int
;	O
perror	(*(char))->(void)
(	O
ofname	array(char)
)	O
;	O
}	O
}	O
do_chown	(int,*(char),int,int)->(void)
(	O
ofd	int
,	O
ofname	array(char)
,	O
-	O
1	int
,	O
ifstat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_gid	int
)	O
;	O
r	struct(long,long)
=	O
fchmod	(int,int)->(int)
(	O
ofd	int
,	O
mode	int
)	O
;	O
if	O
(	O
r	struct(long,long)
!=	O
0	int
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
WARN	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: "	*(char)
,	O
program_name	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
quiet	int
)	O
{	O
errno	O
=	O
e	int
;	O
perror	(*(char))->(void)
(	O
ofname	array(char)
)	O
;	O
}	O
}	O
do_chown	(int,*(char),int,int)->(void)
(	O
ofd	int
,	O
ofname	array(char)
,	O
ifstat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_uid	int
,	O
-	O
1	int
)	O
;	O
}	O
local	O
void	O
treat_dir	(int,*(char))->(void)
(	O
fd	int
,	O
dir	*(char)
)	O
int	O
fd	int
;	O
char	O
*	O
dir	*(char)
;	O
{	O
DIR	struct
*	O
dirp	*(struct)
;	O
char	O
nbuf	array(char)
[	O
MAX_PATH_LEN	int
]	O
;	O
char	O
*	O
entries	*(char)
;	O
char	O
const	O
*	O
entry	*(char)
;	O
size_t	long
entrylen	long
;	O
dirp	*(struct)
=	O
fdopendir	(int)->(*(struct))
(	O
fd	int
)	O
;	O
if	O
(	O
dirp	*(struct)
==	O
NULL	O
)	O
{	O
progerror	(*(char))->(void)
(	O
dir	*(char)
)	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
return	O
;	O
}	O
entries	*(char)
=	O
streamsavedir	(*(struct),enum(int,int,int))->(*(char))
(	O
dirp	*(struct)
,	O
SAVEDIR_SORT_NONE	int
)	O
;	O
if	O
(	O
!	O
entries	*(char)
)	O
progerror	(*(char))->(void)
(	O
dir	*(char)
)	O
;	O
if	O
(	O
closedir	(*(struct))->(int)
(	O
dirp	*(struct)
)	O
!=	O
0	int
)	O
progerror	(*(char))->(void)
(	O
dir	*(char)
)	O
;	O
if	O
(	O
!	O
entries	*(char)
)	O
return	O
;	O
for	O
(	O
entry	*(char)
=	O
entries	*(char)
;	O
*	O
entry	*(char)
;	O
entry	*(char)
+=	O
entrylen	long
+	O
1	int
)	O
{	O
size_t	long
len	int
=	O
strlen	(*(char))->(long)
(	O
dir	*(char)
)	O
;	O
entrylen	long
=	O
strlen	(*(char))->(long)
(	O
entry	*(char)
)	O
;	O
if	O
(	O
strequ	O
(	O
entry	*(char)
,	O
"."	*(char)
)	O
||	O
strequ	O
(	O
entry	*(char)
,	O
".."	*(char)
)	O
)	O
continue	O
;	O
if	O
(	O
len	int
+	O
entrylen	long
<	O
MAX_PATH_LEN	int
-	O
2	int
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
nbuf	array(char)
,	O
dir	*(char)
)	O
;	O
if	O
(	O
*	O
last_component	(*(char))->(*(char))
(	O
nbuf	array(char)
)	O
&&	O
!	O
ISSLASH	O
(	O
nbuf	array(char)
[	O
len	int
-	O
1	int
]	O
)	O
)	O
nbuf	array(char)
[	O
len	int
++	O
]	O
=	O
'/'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
nbuf	array(char)
+	O
len	int
,	O
entry	*(char)
)	O
;	O
treat_file	(*(char))->(void)
(	O
nbuf	array(char)
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s/%s: pathname too long\n"	*(char)
,	O
program_name	*(char)
,	O
dir	*(char)
,	O
entry	*(char)
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
}	O
}	O
free	(*(void))->(void)
(	O
entries	*(char)
)	O
;	O
}	O
static	O
void	O
install_signal_handlers	()->(void)
(	O
)	O
{	O
int	O
nsigs	int
=	O
sizeof	O
handled_sig	array(int)
/	O
sizeof	O
handled_sig	array(int)
[	O
0	int
]	O
;	O
int	O
i	int
;	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
caught_signals	struct(array(long))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nsigs	int
;	O
i	int
++	O
)	O
{	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
handled_sig	array(int)
[	O
i	int
]	O
,	O
NULL	O
,	O
&	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
if	O
(	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
!=	O
SIG_IGN	O
)	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
caught_signals	struct(array(long))
,	O
handled_sig	array(int)
[	O
i	int
]	O
)	O
;	O
}	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
=	O
abort_gzip_signal	(int)->(void)
;	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
=	O
caught_signals	struct(array(long))
;	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nsigs	int
;	O
i	int
++	O
)	O
if	O
(	O
sigismember	(*(struct(array(long))),int)->(int)
(	O
&	O
caught_signals	struct(array(long))
,	O
handled_sig	array(int)
[	O
i	int
]	O
)	O
)	O
{	O
if	O
(	O
i	int
==	O
0	int
)	O
foreground	int
=	O
1	int
;	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
handled_sig	array(int)
[	O
i	int
]	O
,	O
&	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
NULL	O
)	O
;	O
}	O
}	O
local	O
void	O
do_exit	(int)->(void)
(	O
exitcode	int
)	O
int	O
exitcode	int
;	O
{	O
static	O
int	O
in_exit	int
=	O
0	int
;	O
if	O
(	O
in_exit	int
)	O
exit	(int)->(void)
(	O
exitcode	int
)	O
;	O
in_exit	int
=	O
1	int
;	O
free	(*(void))->(void)
(	O
env	*(char)
)	O
;	O
env	*(char)
=	O
NULL	O
;	O
FREE	O
(	O
inbuf	array(char)
)	O
;	O
FREE	O
(	O
outbuf	array(char)
)	O
;	O
FREE	O
(	O
d_buf	array(short)
)	O
;	O
FREE	O
(	O
window	array(char)
)	O
;	O
FREE	O
(	O
tab_prefix	O
)	O
;	O
exit	(int)->(void)
(	O
exitcode	int
)	O
;	O
}	O
static	O
void	O
finish_out	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
write_error	()->(void)
(	O
)	O
;	O
do_exit	(int)->(void)
(	O
OK	int
)	O
;	O
}	O
static	O
void	O
remove_output_file	(bool)->(void)
(	O
bool	bool
signals_already_blocked	bool
)	O
{	O
int	O
fd	int
;	O
sigset_t	struct(array(long))
oldset	struct(array(long))
;	O
if	O
(	O
!	O
signals_already_blocked	bool
)	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_BLOCK	int
,	O
&	O
caught_signals	struct(array(long))
,	O
&	O
oldset	struct(array(long))
)	O
;	O
fd	int
=	O
remove_ofname_fd	int
;	O
if	O
(	O
0	int
<=	O
fd	int
)	O
{	O
char	O
fname	*(char)
[	O
MAX_PATH_LEN	int
]	O
;	O
remove_ofname_fd	int
=	O
-	O
1	int
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
volatile_strcpy	(*(char),*(char))->(void)
(	O
fname	*(char)
,	O
remove_ofname	array(char)
)	O
;	O
xunlink	(*(char))->(int)
(	O
fname	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
signals_already_blocked	bool
)	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_SETMASK	int
,	O
&	O
oldset	struct(array(long))
,	O
NULL	O
)	O
;	O
}	O
void	O
abort_gzip	()->(void)
(	O
void	O
)	O
{	O
remove_output_file	(bool)->(void)
(	O
false	int
)	O
;	O
do_exit	(int)->(void)
(	O
ERROR	int
)	O
;	O
}	O
static	O
void	O
abort_gzip_signal	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
remove_output_file	(bool)->(void)
(	O
true	int
)	O
;	O
if	O
(	O
sig	int
==	O
exiting_signal	int
)	O
_exit	(int)->(void)
(	O
WARNING	int
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
sig	int
,	O
SIG_DFL	O
)	O
;	O
raise	(int)->(int)
(	O
sig	int
)	O
;	O
}	O
