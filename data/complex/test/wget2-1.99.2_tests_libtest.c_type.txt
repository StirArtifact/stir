static	O
int	O
http_server_port	int
,	O
https_server_port	int
,	O
ocsp_server_port	int
,	O
h2_server_port	int
,	O
keep_tmpfiles	int
,	O
reject_http_connection	int
,	O
reject_https_connection	int
;	O
static	O
wget_vector	struct
*	O
request_urls	*(struct)
;	O
static	O
wget_test_url_t	struct(*(char),*(char),*(char),*(char),array(*(char)),array(*(char)),array(*(char)),array(*(char)),array(*(char)),long,*(char),*(char),*(char),long,bool,bool)
*	O
urls	*(*(struct))
;	O
static	O
size_t	long
nurls	long
;	O
static	O
char	O
tmpdir	array(char)
[	O
128	int
]	O
;	O
static	O
char	O
server_send_content_length	char
=	O
1	int
;	O
static	O
struct	O
MHD_Daemon	O
*	O
httpdaemon	*(struct)
,	O
*	O
httpsdaemon	*(struct)
,	O
*	O
ocspdaemon	*(struct)
,	O
*	O
h2daemon	*(struct)
;	O
struct	O
query_string	struct(*(struct(*(char),long,long,bool,bool,bool)),int)
{	O
wget_buffer	struct(*(char),long,long,bool,bool,bool)
*	O
params	*(struct)
;	O
int	O
it	int
;	O
}	O
;	O
static	O
char	O
*	O
key_pem	*(char)
,	O
*	O
cert_pem	*(char)
;	O
enum	O
SERVER_MODE	enum(int,int,int,int,int)
{	O
HTTP_MODE	int
,	O
HTTPS_MODE	int
,	O
OCSP_MODE	int
,	O
OCSP_STAP_MODE	int
,	O
H2_MODE	int
}	O
;	O
static	O
enum	O
PASS	enum(int,int,int)
{	O
HTTP_1_1_PASS	int
,	O
H2_PASS	int
,	O
END_PASS	int
}	O
proto_pass	enum(int,int,int)
;	O
static	O
char	O
*	O
_scan_directory	(*(char))->(*(char))
(	O
const	O
char	O
*	O
data	*(void)
)	O
{	O
return	O
strchr	(*(char),int)->(*(char))
(	O
data	*(void)
,	O
'/'	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
_parse_hostname	(*(char))->(*(char))
(	O
const	O
char	O
*	O
data	*(void)
)	O
{	O
if	O
(	O
data	*(void)
)	O
{	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
data	*(void)
,	O
"http://"	*(char)
,	O
7	int
)	O
)	O
{	O
return	O
strchr	(*(char),int)->(*(char))
(	O
data	*(void)
+=	O
7	int
,	O
'/'	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
data	*(void)
,	O
"https://"	*(char)
,	O
8	int
)	O
)	O
{	O
return	O
strchr	(*(char),int)->(*(char))
(	O
data	*(void)
+=	O
8	int
,	O
'/'	O
)	O
;	O
}	O
}	O
return	O
data	*(void)
;	O
}	O
static	O
void	O
_replace_space_with_plus	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(void)
(	O
wget_buffer	struct(*(char),long,long,bool,bool,bool)
*	O
buf	*(char)
,	O
const	O
char	O
*	O
data	*(void)
)	O
{	O
for	O
(	O
;	O
*	O
data	*(void)
;	O
data	*(void)
++	O
)	O
wget_buffer_memcat	(*(struct(*(char),long,long,bool,bool,bool)),*(void),long)->(long)
(	O
buf	*(char)
,	O
*	O
data	*(void)
==	O
' '	O
?	O
"+"	*(char)
:	O
data	*(void)
,	O
1	int
)	O
;	O
}	O
static	O
int	O
_print_query_string	(*(void),enum(int,int,int,int,int,int),*(char),*(char))->(int)
(	O
void	O
*	O
cls	*(void)
,	O
enum	O
MHD_ValueKind	enum(int,int,int,int,int,int)
kind	enum(int,int,int,int,int,int)
WGET_GCC_UNUSED	O
,	O
const	O
char	O
*	O
key	int
,	O
const	O
char	O
*	O
value	*(void)
)	O
{	O
struct	O
query_string	struct(*(struct(*(char),long,long,bool,bool,bool)),int)
*	O
query	*(char)
=	O
cls	*(void)
;	O
if	O
(	O
key	int
&&	O
!	O
query	*(char)
->	O
it	int
)	O
{	O
wget_buffer_strcpy	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
query	*(char)
->	O
params	*(struct)
,	O
"?"	*(char)
)	O
;	O
_replace_space_with_plus	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(void)
(	O
query	*(char)
->	O
params	*(struct)
,	O
key	int
)	O
;	O
if	O
(	O
value	*(void)
)	O
{	O
wget_buffer_strcat	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
query	*(char)
->	O
params	*(struct)
,	O
"="	*(char)
)	O
;	O
_replace_space_with_plus	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(void)
(	O
query	*(char)
->	O
params	*(struct)
,	O
value	*(void)
)	O
;	O
}	O
}	O
if	O
(	O
key	int
&&	O
query	*(char)
->	O
it	int
)	O
{	O
wget_buffer_strcat	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
query	*(char)
->	O
params	*(struct)
,	O
"&"	*(char)
)	O
;	O
_replace_space_with_plus	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(void)
(	O
query	*(char)
->	O
params	*(struct)
,	O
key	int
)	O
;	O
if	O
(	O
value	*(void)
)	O
{	O
wget_buffer_strcat	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
query	*(char)
->	O
params	*(struct)
,	O
"="	*(char)
)	O
;	O
_replace_space_with_plus	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(void)
(	O
query	*(char)
->	O
params	*(struct)
,	O
value	*(void)
)	O
;	O
}	O
}	O
query	*(char)
->	O
it	int
++	O
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
_print_header_range	(*(void),enum(int,int,int,int,int,int),*(char),*(char))->(int)
(	O
void	O
*	O
cls	*(void)
,	O
enum	O
MHD_ValueKind	enum(int,int,int,int,int,int)
kind	enum(int,int,int,int,int,int)
WGET_GCC_UNUSED	O
,	O
const	O
char	O
*	O
key	int
,	O
const	O
char	O
*	O
value	*(void)
)	O
{	O
wget_buffer	struct(*(char),long,long,bool,bool,bool)
*	O
header_range	*(struct(*(char),long,long,bool,bool,bool))
=	O
cls	*(void)
;	O
if	O
(	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
key	int
,	O
MHD_HTTP_HEADER_RANGE	*(char)
)	O
)	O
{	O
wget_buffer_strcpy	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
header_range	*(struct(*(char),long,long,bool,bool,bool))
,	O
key	int
)	O
;	O
if	O
(	O
value	*(void)
)	O
{	O
wget_buffer_strcat	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
header_range	*(struct(*(char),long,long,bool,bool,bool))
,	O
value	*(void)
)	O
;	O
}	O
}	O
return	O
MHD_YES	int
;	O
}	O
struct	O
ResponseContentCallbackParam	struct(*(char),long)
{	O
const	O
char	O
*	O
response_data	*(char)
;	O
size_t	long
response_size	long
;	O
}	O
;	O
static	O
ssize_t	long
_callback	(*(void),long,*(char),long)->(long)
(	O
void	O
*	O
cls	*(void)
,	O
uint64_t	long
pos	int
,	O
char	O
*	O
buf	*(char)
,	O
size_t	long
buf_size	long
)	O
{	O
size_t	long
size_to_copy	long
;	O
struct	O
ResponseContentCallbackParam	struct(*(char),long)
*	O
const	O
param	*(*(char))
=	O
(	O
struct	O
ResponseContentCallbackParam	struct(*(char),long)
*	O
)	O
cls	*(void)
;	O
if	O
(	O
pos	int
>=	O
param	*(*(char))
->	O
response_size	long
)	O
return	O
MHD_CONTENT_READER_END_OF_STREAM	O
;	O
buf_size	long
=	O
(	O
param	*(*(char))
->	O
response_size	long
/	O
2	int
)	O
+	O
1	int
;	O
if	O
(	O
buf_size	long
<	O
(	O
param	*(*(char))
->	O
response_size	long
-	O
pos	int
)	O
)	O
size_to_copy	long
=	O
buf_size	long
;	O
else	O
size_to_copy	long
=	O
param	*(*(char))
->	O
response_size	long
-	O
pos	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	*(char)
,	O
param	*(*(char))
->	O
response_data	*(char)
+	O
pos	int
,	O
size_to_copy	long
)	O
;	O
return	O
size_to_copy	long
;	O
}	O
static	O
void	O
_free_callback_param	(*(void))->(void)
(	O
void	O
*	O
cls	*(void)
)	O
{	O
wget_free	*((*(void))->(void))
(	O
cls	*(void)
)	O
;	O
}	O
static	O
int	O
_answer_to_connection	(*(void),*(struct),*(char),*(char),*(char),*(char),*(long),*(*(void)))->(int)
(	O
void	O
*	O
cls	*(void)
WGET_GCC_UNUSED	O
,	O
struct	O
MHD_Connection	O
*	O
connection	*(struct)
,	O
const	O
char	O
*	O
url	*(char)
,	O
const	O
char	O
*	O
method	array(char)
,	O
const	O
char	O
*	O
version	int
WGET_GCC_UNUSED	O
,	O
const	O
char	O
*	O
upload_data	*(char)
WGET_GCC_UNUSED	O
,	O
size_t	long
*	O
upload_data_size	*(long)
WGET_GCC_UNUSED	O
,	O
void	O
*	O
*	O
con_cls	*(*(void))
WGET_GCC_UNUSED	O
)	O
{	O
struct	O
MHD_Response	O
*	O
response	*(struct)
=	O
NULL	O
;	O
struct	O
query_string	struct(*(struct(*(char),long,long,bool,bool,bool)),int)
query	*(char)
;	O
int	O
ret	int
=	O
0	int
;	O
time_t	long
modified	long
;	O
const	O
char	O
*	O
modified_val	*(char)
,	O
*	O
to_bytes_string	*(char)
=	O
""	*(char)
;	O
ssize_t	long
from_bytes	long
,	O
to_bytes	long
;	O
size_t	long
body_len	long
;	O
char	O
content_len	array(char)
[	O
100	int
]	O
,	O
content_range	array(char)
[	O
100	int
]	O
;	O
bool	bool
https	bool
=	O
!	O
!	O
MHD_get_connection_info	(*(struct),enum(int,int,int,int,int,int,int,int,int,int,int))->(*(union(int,int,int,int,int,long,*(void),*(void),*(struct(short,array(char))),*(struct),*(void))))
(	O
connection	*(struct)
,	O
MHD_CONNECTION_INFO_PROTOCOL	int
)	O
;	O
query	*(char)
.	O
params	*(struct)
=	O
wget_buffer_alloc	(long)->(*(struct(*(char),long,long,bool,bool,bool)))
(	O
1024	int
)	O
;	O
query	*(char)
.	O
it	int
=	O
0	int
;	O
MHD_get_connection_values	(*(struct),enum(int,int,int,int,int,int),*((*(void),enum(int,int,int,int,int,int),*(char),*(char))->(int)),*(void))->(int)
(	O
connection	*(struct)
,	O
MHD_GET_ARGUMENT_KIND	int
,	O
&	O
_print_query_string	(*(void),enum(int,int,int,int,int,int),*(char),*(char))->(int)
,	O
&	O
query	*(char)
)	O
;	O
modified_val	*(char)
=	O
MHD_lookup_connection_value	(*(struct),enum(int,int,int,int,int,int),*(char))->(*(char))
(	O
connection	*(struct)
,	O
MHD_HEADER_KIND	int
,	O
MHD_HTTP_HEADER_IF_MODIFIED_SINCE	*(char)
)	O
;	O
modified	long
=	O
0	int
;	O
if	O
(	O
modified_val	*(char)
)	O
modified	long
=	O
wget_http_parse_full_date	(*(char))->(long)
(	O
modified_val	*(char)
)	O
;	O
wget_buffer	struct(*(char),long,long,bool,bool,bool)
*	O
header_range	*(struct(*(char),long,long,bool,bool,bool))
=	O
wget_buffer_alloc	(long)->(*(struct(*(char),long,long,bool,bool,bool)))
(	O
1024	int
)	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
method	array(char)
,	O
"GET"	*(char)
)	O
)	O
MHD_get_connection_values	(*(struct),enum(int,int,int,int,int,int),*((*(void),enum(int,int,int,int,int,int),*(char),*(char))->(int)),*(void))->(int)
(	O
connection	*(struct)
,	O
MHD_HEADER_KIND	int
,	O
&	O
_print_header_range	(*(void),enum(int,int,int,int,int,int),*(char),*(char))->(int)
,	O
header_range	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
from_bytes	long
=	O
to_bytes	long
=	O
body_len	long
=	O
0	int
;	O
if	O
(	O
*	O
header_range	*(struct(*(char),long,long,bool,bool,bool))
->	O
data	*(void)
)	O
{	O
const	O
char	O
*	O
from_bytes_string	*(char)
;	O
const	O
char	O
*	O
range_string	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
header_range	*(struct(*(char),long,long,bool,bool,bool))
->	O
data	*(void)
,	O
'='	O
)	O
;	O
to_bytes_string	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
range_string	*(char)
,	O
'-'	O
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
to_bytes_string	*(char)
,	O
"-"	*(char)
)	O
)	O
to_bytes	long
=	O
(	O
ssize_t	long
)	O
atoi	(*(char))->(int)
(	O
to_bytes_string	*(char)
+	O
1	int
)	O
;	O
from_bytes_string	*(char)
=	O
wget_strmemdup	(*(void),long)->(*(char))
(	O
range_string	*(char)
,	O
to_bytes_string	*(char)
-	O
range_string	*(char)
)	O
;	O
from_bytes	long
=	O
(	O
ssize_t	long
)	O
atoi	(*(char))->(int)
(	O
from_bytes_string	*(char)
+	O
1	int
)	O
;	O
wget_xfree	O
(	O
from_bytes_string	*(char)
)	O
;	O
}	O
wget_buffer	struct(*(char),long,long,bool,bool,bool)
*	O
url_full	*(struct(*(char),long,long,bool,bool,bool))
=	O
wget_buffer_alloc	(long)->(*(struct(*(char),long,long,bool,bool,bool)))
(	O
1024	int
)	O
;	O
wget_buffer_strcpy	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
url_full	*(struct(*(char),long,long,bool,bool,bool))
,	O
url	*(char)
)	O
;	O
if	O
(	O
query	*(char)
.	O
params	*(struct)
->	O
data	*(void)
)	O
wget_buffer_strcat	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
url_full	*(struct(*(char),long,long,bool,bool,bool))
,	O
query	*(char)
.	O
params	*(struct)
->	O
data	*(void)
)	O
;	O
wget_buffer_free	(*(*(struct(*(char),long,long,bool,bool,bool))))->(void)
(	O
&	O
query	*(char)
.	O
params	*(struct)
)	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
url_full	*(struct(*(char),long,long,bool,bool,bool))
->	O
data	*(void)
,	O
"/"	*(char)
)	O
)	O
wget_buffer_strcat	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
url_full	*(struct(*(char),long,long,bool,bool,bool))
,	O
"index.html"	*(char)
)	O
;	O
unsigned	O
int	O
found	int
=	O
0	int
,	O
chunked	int
=	O
0	int
;	O
for	O
(	O
unsigned	O
it1	int
=	O
0	int
;	O
it1	int
<	O
nurls	long
&&	O
!	O
found	int
;	O
it1	int
++	O
)	O
{	O
if	O
(	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
http_only	bool
&&	O
https	bool
)	O
continue	O
;	O
if	O
(	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
https_only	bool
&&	O
!	O
https	bool
)	O
continue	O
;	O
const	O
char	O
*	O
dir	array(char)
=	O
_scan_directory	(*(char))->(*(char))
(	O
url_full	*(struct(*(char),long,long,bool,bool,bool))
->	O
data	*(void)
+	O
1	int
)	O
;	O
if	O
(	O
dir	array(char)
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dir	array(char)
,	O
"/"	*(char)
)	O
)	O
wget_buffer_strcat	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
url_full	*(struct(*(char),long,long,bool,bool,bool))
,	O
"index.html"	*(char)
)	O
;	O
const	O
char	O
*	O
host	*(char)
=	O
_parse_hostname	(*(char))->(*(char))
(	O
url_full	*(struct(*(char),long,long,bool,bool,bool))
->	O
data	*(void)
)	O
;	O
if	O
(	O
host	*(char)
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
host	*(char)
,	O
"/"	*(char)
)	O
)	O
wget_buffer_strcat	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
url_full	*(struct(*(char),long,long,bool,bool,bool))
,	O
"index.html"	*(char)
)	O
;	O
wget_buffer	struct(*(char),long,long,bool,bool,bool)
*	O
url_iri	*(struct(*(char),long,long,bool,bool,bool))
=	O
wget_buffer_alloc	(long)->(*(struct(*(char),long,long,bool,bool,bool)))
(	O
1024	int
)	O
;	O
wget_buffer_strcpy	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
url_iri	*(struct(*(char),long,long,bool,bool,bool))
,	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
name	*(char)
)	O
;	O
MHD_http_unescape	(*(char))->(long)
(	O
url_iri	*(struct(*(char),long,long,bool,bool,bool))
->	O
data	*(void)
)	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
_parse_hostname	(*(char))->(*(char))
(	O
url_full	*(struct(*(char),long,long,bool,bool,bool))
->	O
data	*(void)
)	O
,	O
_parse_hostname	(*(char))->(*(char))
(	O
url_iri	*(struct(*(char),long,long,bool,bool,bool))
->	O
data	*(void)
)	O
)	O
)	O
{	O
size_t	long
body_length	long
=	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
body_len	long
?	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
body_len	long
:	O
(	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
body	*(char)
?	O
strlen	(*(char))->(long)
(	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
body	*(char)
)	O
:	O
0	int
)	O
;	O
int	O
bad_request	int
=	O
0	int
;	O
for	O
(	O
unsigned	O
it2	int
=	O
0	int
;	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
expected_req_headers	array(*(char))
[	O
it2	int
]	O
;	O
it2	int
++	O
)	O
{	O
const	O
char	O
*	O
header	*(struct(*(char),long,long,bool,bool,bool))
=	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
expected_req_headers	array(*(char))
[	O
it2	int
]	O
;	O
if	O
(	O
header	*(struct(*(char),long,long,bool,bool,bool))
)	O
{	O
const	O
char	O
*	O
header_value	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
header	*(struct(*(char),long,long,bool,bool,bool))
,	O
':'	O
)	O
;	O
const	O
char	O
*	O
header_key	*(char)
=	O
wget_strmemdup	(*(void),long)->(*(char))
(	O
header	*(struct(*(char),long,long,bool,bool,bool))
,	O
header_value	*(char)
-	O
header	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
const	O
char	O
*	O
got_val	*(char)
=	O
MHD_lookup_connection_value	(*(struct),enum(int,int,int,int,int,int),*(char))->(*(char))
(	O
connection	*(struct)
,	O
MHD_HEADER_KIND	int
,	O
header_key	*(char)
)	O
;	O
if	O
(	O
!	O
got_val	*(char)
||	O
strcmp	(*(char),*(char))->(int)
(	O
got_val	*(char)
,	O
header_value	*(char)
+	O
2	int
)	O
)	O
{	O
bad_request	int
=	O
1	int
;	O
wget_xfree	O
(	O
header_key	*(char)
)	O
;	O
break	O
;	O
}	O
wget_xfree	O
(	O
header_key	*(char)
)	O
;	O
}	O
}	O
for	O
(	O
unsigned	O
it2	int
=	O
0	int
;	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
unexpected_req_headers	array(*(char))
[	O
it2	int
]	O
&&	O
!	O
bad_request	int
;	O
it2	int
++	O
)	O
{	O
const	O
char	O
*	O
header_key	*(char)
=	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
unexpected_req_headers	array(*(char))
[	O
it2	int
]	O
;	O
const	O
char	O
*	O
got_val	*(char)
=	O
MHD_lookup_connection_value	(*(struct),enum(int,int,int,int,int,int),*(char))->(*(char))
(	O
connection	*(struct)
,	O
MHD_HEADER_KIND	int
,	O
header_key	*(char)
)	O
;	O
if	O
(	O
got_val	*(char)
)	O
{	O
bad_request	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
bad_request	int
)	O
{	O
response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
0	int
,	O
(	O
void	O
*	O
)	O
""	*(char)
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
ret	int
=	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_BAD_REQUEST	int
,	O
response	*(struct)
)	O
;	O
wget_buffer_free	(*(*(struct(*(char),long,long,bool,bool,bool))))->(void)
(	O
&	O
url_iri	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
wget_strcmp	(*(char),*(char))->(int)
(	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
name	*(char)
+	O
3	int
,	O
"bad.txt"	*(char)
)	O
)	O
{	O
response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
body_length	long
,	O
(	O
void	O
*	O
)	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
body	*(char)
,	O
MHD_RESPMEM_MUST_COPY	int
)	O
;	O
ret	int
=	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_OK	int
,	O
response	*(struct)
)	O
;	O
MHD_add_response_header	(*(struct),*(char),*(char))->(int)
(	O
response	*(struct)
,	O
"Transfer-Encoding"	*(char)
,	O
"chunked"	*(char)
)	O
;	O
MHD_add_response_header	(*(struct),*(char),*(char))->(int)
(	O
response	*(struct)
,	O
"Connection"	*(char)
,	O
"close"	*(char)
)	O
;	O
wget_buffer_free	(*(*(struct(*(char),long,long,bool,bool,bool))))->(void)
(	O
&	O
url_iri	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
for	O
(	O
int	O
it2	int
=	O
0	int
;	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
headers	*(struct)
[	O
it2	int
]	O
;	O
it2	int
++	O
)	O
{	O
const	O
char	O
*	O
header	*(struct(*(char),long,long,bool,bool,bool))
=	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
headers	*(struct)
[	O
it2	int
]	O
;	O
if	O
(	O
header	*(struct(*(char),long,long,bool,bool,bool))
)	O
{	O
const	O
char	O
*	O
header_value	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
header	*(struct(*(char),long,long,bool,bool,bool))
,	O
':'	O
)	O
;	O
const	O
char	O
*	O
header_key	*(char)
=	O
wget_strmemdup	(*(void),long)->(*(char))
(	O
header	*(struct(*(char),long,long,bool,bool,bool))
,	O
header_value	*(char)
-	O
header	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
header_key	*(char)
,	O
"Transfer-Encoding"	*(char)
)	O
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
header_value	*(char)
+	O
2	int
,	O
"chunked"	*(char)
)	O
)	O
chunked	int
=	O
1	int
;	O
wget_xfree	O
(	O
header_key	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
chunked	int
==	O
1	int
)	O
{	O
struct	O
ResponseContentCallbackParam	struct(*(char),long)
*	O
callback_param	*(struct(*(char),long))
=	O
wget_malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
ResponseContentCallbackParam	struct(*(char),long)
)	O
)	O
;	O
callback_param	*(struct(*(char),long))
->	O
response_data	*(char)
=	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
body	*(char)
;	O
callback_param	*(struct(*(char),long))
->	O
response_size	long
=	O
body_length	long
;	O
response	*(struct)
=	O
MHD_create_response_from_callback	(long,long,*((*(void),long,*(char),long)->(long)),*(void),*((*(void))->(void)))->(*(struct))
(	O
MHD_SIZE_UNKNOWN	O
,	O
1024	int
,	O
&	O
_callback	(*(void),long,*(char),long)->(long)
,	O
callback_param	*(struct(*(char),long))
,	O
&	O
_free_callback_param	(*(void))->(void)
)	O
;	O
ret	int
=	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_OK	int
,	O
response	*(struct)
)	O
;	O
wget_buffer_free	(*(*(struct(*(char),long,long,bool,bool,bool))))->(void)
(	O
&	O
url_iri	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
atoi	(*(char))->(int)
(	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
code	short
)	O
/	O
100	int
==	O
3	int
)	O
{	O
response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
0	int
,	O
(	O
void	O
*	O
)	O
""	*(char)
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
for	O
(	O
unsigned	O
it2	int
=	O
0	int
;	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
headers	*(struct)
[	O
it2	int
]	O
;	O
it2	int
++	O
)	O
{	O
const	O
char	O
*	O
header	*(struct(*(char),long,long,bool,bool,bool))
=	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
headers	*(struct)
[	O
it2	int
]	O
;	O
if	O
(	O
header	*(struct(*(char),long,long,bool,bool,bool))
)	O
{	O
const	O
char	O
*	O
header_value	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
header	*(struct(*(char),long,long,bool,bool,bool))
,	O
':'	O
)	O
;	O
const	O
char	O
*	O
header_key	*(char)
=	O
wget_strmemdup	(*(void),long)->(*(char))
(	O
header	*(struct(*(char),long,long,bool,bool,bool))
,	O
header_value	*(char)
-	O
header	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
MHD_add_response_header	(*(struct),*(char),*(char))->(int)
(	O
response	*(struct)
,	O
header_key	*(char)
,	O
header_value	*(char)
+	O
2	int
)	O
;	O
wget_xfree	O
(	O
header_key	*(char)
)	O
;	O
}	O
}	O
ret	int
=	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_FOUND	int
,	O
response	*(struct)
)	O
;	O
wget_buffer_free	(*(*(struct(*(char),long,long,bool,bool,bool))))->(void)
(	O
&	O
url_iri	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
atoi	(*(char))->(int)
(	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
code	short
)	O
!=	O
200	int
)	O
{	O
response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
body_length	long
,	O
(	O
void	O
*	O
)	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
body	*(char)
,	O
MHD_RESPMEM_MUST_COPY	int
)	O
;	O
ret	int
=	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_NOT_FOUND	int
,	O
response	*(struct)
)	O
;	O
wget_buffer_free	(*(*(struct(*(char),long,long,bool,bool,bool))))->(void)
(	O
&	O
url_iri	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
wget_strcmp	(*(char),*(char))->(int)
(	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
auth_method	*(char)
,	O
"Basic"	*(char)
)	O
)	O
{	O
char	O
*	O
pass	*(char)
=	O
NULL	O
;	O
char	O
*	O
user	*(char)
=	O
MHD_basic_auth_get_username_password	(*(struct),*(*(char)))->(*(char))
(	O
connection	*(struct)
,	O
&	O
pass	*(char)
)	O
;	O
if	O
(	O
(	O
user	*(char)
==	O
NULL	O
&&	O
pass	*(char)
==	O
NULL	O
)	O
||	O
wget_strcmp	(*(char),*(char))->(int)
(	O
user	*(char)
,	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
auth_username	*(char)
)	O
||	O
wget_strcmp	(*(char),*(char))->(int)
(	O
pass	*(char)
,	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
auth_password	*(char)
)	O
)	O
{	O
response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
strlen	(*(char))->(long)
(	O
"DENIED"	*(char)
)	O
,	O
(	O
void	O
*	O
)	O
"DENIED"	*(char)
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
ret	int
=	O
MHD_queue_basic_auth_fail_response	(*(struct),*(char),*(struct))->(int)
(	O
connection	*(struct)
,	O
"basic@example.com"	*(char)
,	O
response	*(struct)
)	O
;	O
MHD_free	(*(void))->(void)
(	O
user	*(char)
)	O
;	O
MHD_free	(*(void))->(void)
(	O
pass	*(char)
)	O
;	O
wget_buffer_free	(*(*(struct(*(char),long,long,bool,bool,bool))))->(void)
(	O
&	O
url_iri	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
MHD_free	(*(void))->(void)
(	O
user	*(char)
)	O
;	O
MHD_free	(*(void))->(void)
(	O
pass	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
wget_strcmp	(*(char),*(char))->(int)
(	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
auth_method	*(char)
,	O
"Digest"	*(char)
)	O
)	O
{	O
const	O
char	O
*	O
realm	*(char)
=	O
"digest@example.com"	*(char)
;	O
char	O
*	O
user	*(char)
=	O
MHD_digest_auth_get_username	(*(struct))->(*(char))
(	O
connection	*(struct)
)	O
;	O
if	O
(	O
wget_strcmp	(*(char),*(char))->(int)
(	O
user	*(char)
,	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
auth_username	*(char)
)	O
)	O
{	O
response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
strlen	(*(char))->(long)
(	O
"DENIED"	*(char)
)	O
,	O
(	O
void	O
*	O
)	O
"DENIED"	*(char)
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
ret	int
=	O
MHD_queue_auth_fail_response	(*(struct),*(char),*(char),*(struct),int)->(int)
(	O
connection	*(struct)
,	O
realm	*(char)
,	O
TEST_OPAQUE_STR	*(char)
,	O
response	*(struct)
,	O
MHD_NO	int
)	O
;	O
MHD_free	(*(void))->(void)
(	O
user	*(char)
)	O
;	O
wget_buffer_free	(*(*(struct(*(char),long,long,bool,bool,bool))))->(void)
(	O
&	O
url_iri	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
ret	int
=	O
MHD_digest_auth_check	(*(struct),*(char),*(char),*(char),int)->(int)
(	O
connection	*(struct)
,	O
realm	*(char)
,	O
user	*(char)
,	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
auth_password	*(char)
,	O
300	int
)	O
;	O
MHD_free	(*(void))->(void)
(	O
user	*(char)
)	O
;	O
if	O
(	O
(	O
ret	int
==	O
MHD_INVALID_NONCE	O
)	O
||	O
(	O
ret	int
==	O
MHD_NO	int
)	O
)	O
{	O
response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
strlen	(*(char))->(long)
(	O
"DENIED"	*(char)
)	O
,	O
(	O
void	O
*	O
)	O
"DENIED"	*(char)
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
if	O
(	O
response	*(struct)
)	O
{	O
ret	int
=	O
MHD_queue_auth_fail_response	(*(struct),*(char),*(char),*(struct),int)->(int)
(	O
connection	*(struct)
,	O
realm	*(char)
,	O
TEST_OPAQUE_STR	*(char)
,	O
response	*(struct)
,	O
(	O
ret	int
==	O
MHD_INVALID_NONCE	O
)	O
?	O
MHD_YES	int
:	O
MHD_NO	int
)	O
;	O
found	int
=	O
1	int
;	O
}	O
else	O
ret	int
=	O
MHD_NO	int
;	O
wget_buffer_free	(*(*(struct(*(char),long,long,bool,bool,bool))))->(void)
(	O
&	O
url_iri	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
modified	long
&&	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
modified	long
<=	O
modified	long
)	O
{	O
response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
0	int
,	O
(	O
void	O
*	O
)	O
""	*(char)
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
ret	int
=	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_NOT_MODIFIED	int
,	O
response	*(struct)
)	O
;	O
}	O
else	O
if	O
(	O
*	O
header_range	*(struct(*(char),long,long,bool,bool,bool))
->	O
data	*(void)
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
to_bytes_string	*(char)
,	O
"-"	*(char)
)	O
)	O
to_bytes	long
=	O
body_length	long
-	O
1	int
;	O
body_len	long
=	O
to_bytes	long
-	O
from_bytes	long
+	O
1	int
;	O
if	O
(	O
from_bytes	long
>	O
to_bytes	long
||	O
from_bytes	long
>=	O
(	O
int	O
)	O
body_length	long
)	O
{	O
response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
0	int
,	O
(	O
void	O
*	O
)	O
""	*(char)
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
ret	int
=	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_RANGE_NOT_SATISFIABLE	int
,	O
response	*(struct)
)	O
;	O
}	O
else	O
{	O
response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
body_len	long
,	O
(	O
void	O
*	O
)	O
(	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
body	*(char)
+	O
from_bytes	long
)	O
,	O
MHD_RESPMEM_MUST_COPY	int
)	O
;	O
MHD_add_response_header	(*(struct),*(char),*(char))->(int)
(	O
response	*(struct)
,	O
MHD_HTTP_HEADER_ACCEPT_RANGES	*(char)
,	O
"bytes"	*(char)
)	O
;	O
wget_snprintf	(*(char),long,*(char))->(long)
(	O
content_range	array(char)
,	O
sizeof	O
(	O
content_range	array(char)
)	O
,	O
"%zd-%zd/%zu"	*(char)
,	O
from_bytes	long
,	O
to_bytes	long
,	O
body_len	long
)	O
;	O
MHD_add_response_header	(*(struct),*(char),*(char))->(int)
(	O
response	*(struct)
,	O
MHD_HTTP_HEADER_CONTENT_RANGE	*(char)
,	O
content_range	array(char)
)	O
;	O
wget_snprintf	(*(char),long,*(char))->(long)
(	O
content_len	array(char)
,	O
sizeof	O
(	O
content_len	array(char)
)	O
,	O
"%zu"	*(char)
,	O
body_len	long
)	O
;	O
MHD_add_response_header	(*(struct),*(char),*(char))->(int)
(	O
response	*(struct)
,	O
MHD_HTTP_HEADER_CONTENT_LENGTH	*(char)
,	O
content_len	array(char)
)	O
;	O
ret	int
=	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_PARTIAL_CONTENT	int
,	O
response	*(struct)
)	O
;	O
}	O
}	O
else	O
{	O
response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
body_length	long
,	O
(	O
void	O
*	O
)	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
body	*(char)
,	O
MHD_RESPMEM_MUST_COPY	int
)	O
;	O
ret	int
=	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_OK	int
,	O
response	*(struct)
)	O
;	O
}	O
if	O
(	O
*	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
headers	*(struct)
)	O
{	O
for	O
(	O
unsigned	O
int	O
it2	int
=	O
0	int
;	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
headers	*(struct)
[	O
it2	int
]	O
!=	O
NULL	O
;	O
it2	int
++	O
)	O
{	O
const	O
char	O
*	O
header	*(struct(*(char),long,long,bool,bool,bool))
=	O
urls	*(*(struct))
[	O
it1	int
]	O
.	O
headers	*(struct)
[	O
it2	int
]	O
;	O
if	O
(	O
header	*(struct(*(char),long,long,bool,bool,bool))
)	O
{	O
const	O
char	O
*	O
header_value	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
header	*(struct(*(char),long,long,bool,bool,bool))
,	O
':'	O
)	O
;	O
const	O
char	O
*	O
header_key	*(char)
=	O
wget_strmemdup	(*(void),long)->(*(char))
(	O
header	*(struct(*(char),long,long,bool,bool,bool))
,	O
header_value	*(char)
-	O
header	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
MHD_add_response_header	(*(struct),*(char),*(char))->(int)
(	O
response	*(struct)
,	O
header_key	*(char)
,	O
header_value	*(char)
+	O
2	int
)	O
;	O
wget_xfree	O
(	O
header_key	*(char)
)	O
;	O
}	O
}	O
}	O
found	int
=	O
1	int
;	O
}	O
wget_buffer_free	(*(*(struct(*(char),long,long,bool,bool,bool))))->(void)
(	O
&	O
url_iri	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
}	O
if	O
(	O
!	O
found	int
)	O
{	O
response	*(struct)
=	O
MHD_create_response_from_buffer	(long,*(void),enum(int,int,int))->(*(struct))
(	O
0	int
,	O
(	O
void	O
*	O
)	O
""	*(char)
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
ret	int
=	O
MHD_queue_response	(*(struct),int,*(struct))->(int)
(	O
connection	*(struct)
,	O
MHD_HTTP_NOT_FOUND	int
,	O
response	*(struct)
)	O
;	O
}	O
wget_buffer_free	(*(*(struct(*(char),long,long,bool,bool,bool))))->(void)
(	O
&	O
url_full	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
wget_buffer_free	(*(*(struct(*(char),long,long,bool,bool,bool))))->(void)
(	O
&	O
header_range	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
char	O
server_version	array(char)
[	O
50	int
]	O
;	O
wget_snprintf	(*(char),long,*(char))->(long)
(	O
server_version	array(char)
,	O
sizeof	O
(	O
server_version	array(char)
)	O
,	O
"Libmicrohttpd/%08x"	*(char)
,	O
(	O
unsigned	O
int	O
)	O
MHD_VERSION	int
)	O
;	O
MHD_add_response_header	(*(struct),*(char),*(char))->(int)
(	O
response	*(struct)
,	O
"Server"	*(char)
,	O
server_version	array(char)
)	O
;	O
MHD_destroy_response	(*(struct))->(void)
(	O
response	*(struct)
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
void	O
_http_server_stop	()->(void)
(	O
void	O
)	O
{	O
MHD_stop_daemon	(*(struct))->(void)
(	O
httpdaemon	*(struct)
)	O
;	O
MHD_stop_daemon	(*(struct))->(void)
(	O
httpsdaemon	*(struct)
)	O
;	O
MHD_stop_daemon	(*(struct))->(void)
(	O
ocspdaemon	*(struct)
)	O
;	O
MHD_stop_daemon	(*(struct))->(void)
(	O
h2daemon	*(struct)
)	O
;	O
wget_xfree	O
(	O
key_pem	*(char)
)	O
;	O
wget_xfree	O
(	O
cert_pem	*(char)
)	O
;	O
}	O
static	O
int	O
_check_to_accept	(*(void),*(struct(short,array(char))),int)->(int)
(	O
void	O
*	O
cls	*(void)
,	O
WGET_GCC_UNUSED	O
const	O
struct	O
sockaddr	struct(short,array(char))
*	O
addr	*(struct(short,array(char)))
,	O
WGET_GCC_UNUSED	O
socklen_t	int
addrlen	int
)	O
{	O
int	O
server_mode	int
=	O
(	O
int	O
)	O
(	O
ptrdiff_t	long
)	O
cls	*(void)
;	O
if	O
(	O
server_mode	int
==	O
HTTP_MODE	int
)	O
return	O
reject_http_connection	int
?	O
MHD_NO	int
:	O
MHD_YES	int
;	O
return	O
reject_https_connection	int
?	O
MHD_NO	int
:	O
MHD_YES	int
;	O
}	O
static	O
int	O
_http_server_start	(int)->(int)
(	O
int	O
SERVER_MODE	enum(int,int,int,int,int)
)	O
{	O
uint16_t	short
port_num	short
=	O
0	int
;	O
if	O
(	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
HTTP_MODE	int
)	O
{	O
static	O
char	O
rnd	array(char)
[	O
8	int
]	O
=	O
"realrnd"	*(char)
;	O
httpdaemon	*(struct)
=	O
MHD_start_daemon	(int,short,*((*(void),*(struct(short,array(char))),int)->(int)),*(void),*((*(void),*(struct),*(char),*(char),*(char),*(char),*(long),*(*(void)))->(int)),*(void))->(*(struct))
(	O
MHD_USE_SELECT_INTERNALLY	int
,	O
port_num	short
,	O
_check_to_accept	(*(void),*(struct(short,array(char))),int)->(int)
,	O
(	O
void	O
*	O
)	O
(	O
ptrdiff_t	long
)	O
SERVER_MODE	enum(int,int,int,int,int)
,	O
&	O
_answer_to_connection	(*(void),*(struct),*(char),*(char),*(char),*(char),*(long),*(*(void)))->(int)
,	O
NULL	O
,	O
MHD_OPTION_DIGEST_AUTH_RANDOM	int
,	O
sizeof	O
(	O
rnd	array(char)
)	O
,	O
rnd	array(char)
,	O
MHD_OPTION_NONCE_NC_SIZE	int
,	O
300	int
,	O
MHD_OPTION_END	int
)	O
;	O
if	O
(	O
!	O
httpdaemon	*(struct)
)	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
HTTPS_MODE	int
||	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
H2_MODE	int
)	O
{	O
size_t	long
size	*(long)
;	O
if	O
(	O
!	O
ocspdaemon	*(struct)
)	O
{	O
key_pem	*(char)
=	O
wget_read_file	(*(char),*(long))->(*(char))
(	O
SRCDIR	O
"/certs/x509-server-key.pem"	*(char)
,	O
&	O
size	*(long)
)	O
;	O
cert_pem	*(char)
=	O
wget_read_file	(*(char),*(long))->(*(char))
(	O
SRCDIR	O
"/certs/x509-server-cert.pem"	*(char)
,	O
&	O
size	*(long)
)	O
;	O
if	O
(	O
(	O
key_pem	*(char)
==	O
NULL	O
)	O
||	O
(	O
cert_pem	*(char)
==	O
NULL	O
)	O
)	O
{	O
wget_error_printf	(*(char))->(void)
(	O
_	O
(	O
"The key/certificate files could not be read.\n"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
HTTPS_MODE	int
)	O
{	O
httpsdaemon	*(struct)
=	O
MHD_start_daemon	(int,short,*((*(void),*(struct(short,array(char))),int)->(int)),*(void),*((*(void),*(struct),*(char),*(char),*(char),*(char),*(long),*(*(void)))->(int)),*(void))->(*(struct))
(	O
MHD_USE_SELECT_INTERNALLY	int
|	O
MHD_USE_TLS	int
|	O
MHD_USE_POST_HANDSHAKE_AUTH_SUPPORT	int
,	O
port_num	short
,	O
_check_to_accept	(*(void),*(struct(short,array(char))),int)->(int)
,	O
(	O
void	O
*	O
)	O
(	O
ptrdiff_t	long
)	O
SERVER_MODE	enum(int,int,int,int,int)
,	O
&	O
_answer_to_connection	(*(void),*(struct),*(char),*(char),*(char),*(char),*(long),*(*(void)))->(int)
,	O
NULL	O
,	O
MHD_OPTION_HTTPS_MEM_KEY	int
,	O
key_pem	*(char)
,	O
MHD_OPTION_HTTPS_MEM_CERT	int
,	O
cert_pem	*(char)
,	O
MHD_OPTION_CONNECTION_MEMORY_LIMIT	int
,	O
(	O
size_t	long
)	O
1	int
*	O
1024	int
*	O
1024	int
,	O
MHD_OPTION_END	int
)	O
;	O
if	O
(	O
!	O
httpsdaemon	*(struct)
)	O
{	O
wget_error_printf	(*(char))->(void)
(	O
_	O
(	O
"Cannot start the HTTPS server.\n"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
h2daemon	*(struct)
)	O
{	O
wget_error_printf	(*(char))->(void)
(	O
_	O
(	O
"Cannot start the h2 server.\n"	*(char)
)	O
)	O
;	O
wget_error_printf	(*(char))->(void)
(	O
_	O
(	O
"HTTP/2 support for MHD not found.\n"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
OCSP_MODE	int
)	O
{	O
if	O
(	O
!	O
ocspdaemon	*(struct)
)	O
return	O
1	int
;	O
}	O
if	O
(	O
0	int
)	O
{	O
}	O
else	O
if	O
(	O
MHD_NO	int
!=	O
MHD_is_feature_supported	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(int)
(	O
MHD_FEATURE_AUTODETECT_BIND_PORT	int
)	O
)	O
{	O
const	O
union	O
MHD_DaemonInfo	union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
*	O
dinfo	*(union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))
=	O
NULL	O
;	O
if	O
(	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
HTTP_MODE	int
)	O
dinfo	*(union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))
=	O
MHD_get_daemon_info	(*(struct),enum(int,int,int,int,int,int,int,int))->(*(union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))))
(	O
httpdaemon	*(struct)
,	O
MHD_DAEMON_INFO_BIND_PORT	int
)	O
;	O
else	O
if	O
(	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
HTTPS_MODE	int
||	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
OCSP_STAP_MODE	int
)	O
dinfo	*(union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))
=	O
MHD_get_daemon_info	(*(struct),enum(int,int,int,int,int,int,int,int))->(*(union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))))
(	O
httpsdaemon	*(struct)
,	O
MHD_DAEMON_INFO_BIND_PORT	int
)	O
;	O
if	O
(	O
!	O
dinfo	*(union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))
||	O
dinfo	*(union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))
->	O
port	short
==	O
0	int
)	O
return	O
1	int
;	O
port_num	short
=	O
dinfo	*(union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))
->	O
port	short
;	O
if	O
(	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
HTTP_MODE	int
)	O
http_server_port	int
=	O
port_num	short
;	O
else	O
if	O
(	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
HTTPS_MODE	int
||	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
OCSP_STAP_MODE	int
)	O
https_server_port	int
=	O
port_num	short
;	O
}	O
else	O
{	O
const	O
union	O
MHD_DaemonInfo	union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
*	O
dinfo	*(union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))
=	O
NULL	O
;	O
int	O
sock_fd	int
;	O
if	O
(	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
HTTP_MODE	int
)	O
dinfo	*(union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))
=	O
MHD_get_daemon_info	(*(struct),enum(int,int,int,int,int,int,int,int))->(*(union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))))
(	O
httpdaemon	*(struct)
,	O
MHD_DAEMON_INFO_LISTEN_FD	int
)	O
;	O
else	O
if	O
(	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
HTTPS_MODE	int
||	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
OCSP_STAP_MODE	int
)	O
dinfo	*(union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))
=	O
MHD_get_daemon_info	(*(struct),enum(int,int,int,int,int,int,int,int))->(*(union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))))
(	O
httpsdaemon	*(struct)
,	O
MHD_DAEMON_INFO_LISTEN_FD	int
)	O
;	O
if	O
(	O
!	O
dinfo	*(union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))
)	O
return	O
1	int
;	O
sock_fd	int
=	O
dinfo	*(union(long,long,int,short,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))
->	O
listen_fd	int
;	O
struct	O
sockaddr_storage	struct(short,array(char),long)
addr_store	struct(short,array(char),long)
;	O
struct	O
sockaddr	struct(short,array(char))
*	O
addr	*(struct(short,array(char)))
=	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
addr_store	struct(short,array(char),long)
;	O
socklen_t	int
addr_len	int
=	O
sizeof	O
(	O
addr_store	struct(short,array(char),long)
)	O
;	O
if	O
(	O
getsockname	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(int)
(	O
sock_fd	int
,	O
addr	*(struct(short,array(char)))
,	O
&	O
addr_len	int
)	O
==	O
0	int
)	O
{	O
char	O
s_port	int
[	O
NI_MAXSERV	int
]	O
;	O
if	O
(	O
getnameinfo	(*(struct(short,array(char))),int,*(char),int,*(char),int,int)->(int)
(	O
addr	*(struct(short,array(char)))
,	O
addr_len	int
,	O
NULL	O
,	O
0	int
,	O
s_port	int
,	O
sizeof	O
(	O
s_port	int
)	O
,	O
NI_NUMERICSERV	int
)	O
==	O
0	int
)	O
{	O
port_num	short
=	O
(	O
uint16_t	short
)	O
atoi	(*(char))->(int)
(	O
s_port	int
)	O
;	O
if	O
(	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
HTTP_MODE	int
)	O
http_server_port	int
=	O
port_num	short
;	O
else	O
if	O
(	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
HTTPS_MODE	int
||	O
SERVER_MODE	enum(int,int,int,int,int)
==	O
OCSP_STAP_MODE	int
)	O
https_server_port	int
=	O
port_num	short
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
_remove_directory	(*(char))->(void)
(	O
const	O
char	O
*	O
dirname	*(char)
)	O
;	O
static	O
void	O
_empty_directory	(*(char))->(void)
(	O
const	O
char	O
*	O
dirname	*(char)
)	O
{	O
DIR	struct
*	O
dir	array(char)
;	O
size_t	long
dirlen	long
=	O
strlen	(*(char))->(long)
(	O
dirname	*(char)
)	O
;	O
if	O
(	O
(	O
dir	array(char)
=	O
opendir	(*(char))->(*(struct))
(	O
dirname	*(char)
)	O
)	O
)	O
{	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dp	*(struct(long,long,short,char,array(char)))
;	O
while	O
(	O
(	O
dp	*(struct(long,long,short,char,array(char)))
=	O
readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
dir	array(char)
)	O
)	O
)	O
{	O
if	O
(	O
*	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
==	O
'.'	O
&&	O
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
1	int
]	O
==	O
0	int
||	O
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
1	int
]	O
==	O
'.'	O
&&	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
2	int
]	O
==	O
0	int
)	O
)	O
)	O
continue	O
;	O
char	O
fname	*(char)
[	O
dirlen	long
+	O
1	int
+	O
strlen	(*(char))->(long)
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
+	O
1	int
]	O
;	O
wget_snprintf	(*(char),long,*(char))->(long)
(	O
fname	*(char)
,	O
sizeof	O
(	O
fname	*(char)
)	O
,	O
"%s/%s"	*(char)
,	O
dirname	*(char)
,	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
;	O
if	O
(	O
unlink	(*(char))->(int)
(	O
fname	*(char)
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EISDIR	int
||	O
errno	O
==	O
EPERM	int
||	O
errno	O
==	O
EACCES	int
)	O
_remove_directory	(*(char))->(void)
(	O
fname	*(char)
)	O
;	O
else	O
wget_error_printf	(*(char))->(void)
(	O
_	O
(	O
"Failed to unlink %s (%d)\n"	*(char)
)	O
,	O
fname	*(char)
,	O
errno	O
)	O
;	O
}	O
}	O
closedir	(*(struct))->(int)
(	O
dir	array(char)
)	O
;	O
wget_debug_printf	(*(char))->(void)
(	O
"Removed test directory '%s'\n"	*(char)
,	O
dirname	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
wget_error_printf	(*(char))->(void)
(	O
_	O
(	O
"Failed to opendir %s (%d)\n"	*(char)
)	O
,	O
dirname	*(char)
,	O
errno	O
)	O
;	O
}	O
static	O
void	O
_remove_directory	(*(char))->(void)
(	O
const	O
char	O
*	O
dirname	*(char)
)	O
{	O
_empty_directory	(*(char))->(void)
(	O
dirname	*(char)
)	O
;	O
if	O
(	O
rmdir	(*(char))->(int)
(	O
dirname	*(char)
)	O
==	O
-	O
1	int
&&	O
errno	O
!=	O
ENOENT	int
)	O
wget_error_printf	(*(char))->(void)
(	O
_	O
(	O
"Failed to rmdir %s (%d)\n"	*(char)
)	O
,	O
dirname	*(char)
,	O
errno	O
)	O
;	O
}	O
void	O
wget_test_stop_server	()->(void)
(	O
void	O
)	O
{	O
wget_vector_free	(*(*(struct)))->(void)
(	O
&	O
request_urls	*(struct)
)	O
;	O
for	O
(	O
wget_test_url_t	struct(*(char),*(char),*(char),*(char),array(*(char)),array(*(char)),array(*(char)),array(*(char)),array(*(char)),long,*(char),*(char),*(char),long,bool,bool)
*	O
url	*(char)
=	O
urls	*(*(struct))
;	O
url	*(char)
<	O
urls	*(*(struct))
+	O
nurls	long
;	O
url	*(char)
++	O
)	O
{	O
if	O
(	O
url	*(char)
->	O
body_original	*(char)
)	O
{	O
wget_xfree	O
(	O
url	*(char)
->	O
body	*(char)
)	O
;	O
url	*(char)
->	O
body_original	*(char)
=	O
NULL	O
;	O
}	O
for	O
(	O
size_t	long
it	int
=	O
0	int
;	O
it	int
<	O
countof	O
(	O
url	*(char)
->	O
headers	*(struct)
)	O
;	O
it	int
++	O
)	O
{	O
if	O
(	O
url	*(char)
->	O
headers_original	array(*(char))
[	O
it	int
]	O
)	O
{	O
wget_xfree	O
(	O
url	*(char)
->	O
headers	*(struct)
[	O
it	int
]	O
)	O
;	O
url	*(char)
->	O
headers_original	array(*(char))
[	O
it	int
]	O
=	O
NULL	O
;	O
}	O
}	O
}	O
if	O
(	O
chdir	(*(char))->(int)
(	O
".."	*(char)
)	O
!=	O
0	int
)	O
wget_error_printf	(*(char))->(void)
(	O
_	O
(	O
"Failed to chdir ..\n"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
keep_tmpfiles	int
)	O
_remove_directory	(*(char))->(void)
(	O
tmpdir	array(char)
)	O
;	O
wget_global_deinit	()->(void)
(	O
)	O
;	O
_http_server_stop	()->(void)
(	O
)	O
;	O
}	O
static	O
char	O
*	O
_insert_ports	(*(char))->(*(char))
(	O
const	O
char	O
*	O
src	*(char)
)	O
{	O
if	O
(	O
!	O
src	*(char)
||	O
(	O
!	O
strstr	(*(char),*(char))->(*(char))
(	O
src	*(char)
,	O
"{{port}}"	*(char)
)	O
&&	O
!	O
strstr	(*(char),*(char))->(*(char))
(	O
src	*(char)
,	O
"{{sslport}}"	*(char)
)	O
&&	O
!	O
strstr	(*(char),*(char))->(*(char))
(	O
src	*(char)
,	O
"{{ocspport}}"	*(char)
)	O
)	O
)	O
return	O
NULL	O
;	O
size_t	long
srclen	long
=	O
strlen	(*(char))->(long)
(	O
src	*(char)
)	O
+	O
1	int
;	O
char	O
*	O
ret	int
=	O
wget_malloc	(long)->(*(void))
(	O
srclen	long
)	O
;	O
char	O
*	O
dst	*(char)
=	O
ret	int
;	O
while	O
(	O
*	O
src	*(char)
)	O
{	O
if	O
(	O
*	O
src	*(char)
==	O
'{'	O
)	O
{	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
src	*(char)
,	O
"{{port}}"	*(char)
,	O
8	int
)	O
)	O
{	O
if	O
(	O
proto_pass	enum(int,int,int)
==	O
HTTP_1_1_PASS	int
)	O
{	O
dst	*(char)
+=	O
wget_snprintf	(*(char),long,*(char))->(long)
(	O
dst	*(char)
,	O
srclen	long
-	O
(	O
dst	*(char)
-	O
ret	int
)	O
,	O
"%d"	*(char)
,	O
http_server_port	int
)	O
;	O
}	O
src	*(char)
+=	O
8	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
src	*(char)
,	O
"{{sslport}}"	*(char)
,	O
11	int
)	O
)	O
{	O
if	O
(	O
proto_pass	enum(int,int,int)
==	O
HTTP_1_1_PASS	int
)	O
{	O
dst	*(char)
+=	O
wget_snprintf	(*(char),long,*(char))->(long)
(	O
dst	*(char)
,	O
srclen	long
-	O
(	O
dst	*(char)
-	O
ret	int
)	O
,	O
"%d"	*(char)
,	O
https_server_port	int
)	O
;	O
}	O
src	*(char)
+=	O
11	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
src	*(char)
,	O
"{{ocspport}}"	*(char)
,	O
12	int
)	O
)	O
{	O
dst	*(char)
+=	O
wget_snprintf	(*(char),long,*(char))->(long)
(	O
dst	*(char)
,	O
srclen	long
-	O
(	O
dst	*(char)
-	O
ret	int
)	O
,	O
"%d"	*(char)
,	O
ocsp_server_port	int
)	O
;	O
src	*(char)
+=	O
12	int
;	O
continue	O
;	O
}	O
}	O
*	O
dst	*(char)
++	O
=	O
*	O
src	*(char)
++	O
;	O
}	O
*	O
dst	*(char)
=	O
0	int
;	O
return	O
ret	int
;	O
}	O
static	O
void	O
_write_msg	(*(char),long)->(void)
(	O
const	O
char	O
*	O
msg	*(char)
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
isatty	(int)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
{	O
if	O
(	O
len	long
&&	O
msg	*(char)
[	O
len	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
len	long
--	O
;	O
wget_fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(long)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\033[33m%.*s\033[m\n"	*(char)
,	O
(	O
int	O
)	O
len	long
,	O
msg	*(char)
)	O
;	O
}	O
else	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
msg	*(char)
,	O
1	int
,	O
len	long
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
void	O
wget_test_start_server	(int)->(void)
(	O
int	O
first_key	int
,	O
...	O
)	O
{	O
int	O
rc	int
,	O
key	int
;	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
;	O
bool	bool
start_http	bool
=	O
1	int
;	O
bool	bool
ocsp_stap	bool
=	O
0	int
;	O
bool	bool
start_https	bool
=	O
1	int
;	O
wget_global_init	(int)->(void)
(	O
WGET_DEBUG_FUNC	int
,	O
_write_msg	(*(char),long)->(void)
,	O
WGET_ERROR_FUNC	int
,	O
_write_msg	(*(char),long)->(void)
,	O
WGET_INFO_FUNC	int
,	O
_write_msg	(*(char),long)->(void)
,	O
0	int
)	O
;	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
first_key	int
)	O
;	O
for	O
(	O
key	int
=	O
first_key	int
;	O
key	int
;	O
key	int
=	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
int	O
)	O
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
WGET_TEST_RESPONSE_URLS	int
:	O
urls	*(*(struct))
=	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
wget_test_url_t	struct(*(char),*(char),*(char),*(char),array(*(char)),array(*(char)),array(*(char)),array(*(char)),array(*(char)),long,*(char),*(char),*(char),long,bool,bool)
*	O
)	O
;	O
nurls	long
=	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
size_t	long
)	O
;	O
break	O
;	O
case	O
WGET_TEST_SERVER_SEND_CONTENT_LENGTH	int
:	O
server_send_content_length	char
=	O
!	O
!	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
int	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_HTTPS_ONLY	int
:	O
start_http	bool
=	O
0	int
;	O
break	O
;	O
case	O
WGET_TEST_HTTP_ONLY	int
:	O
start_https	bool
=	O
0	int
;	O
break	O
;	O
case	O
WGET_TEST_H2_ONLY	int
:	O
start_http	bool
=	O
0	int
;	O
start_https	bool
=	O
0	int
;	O
break	O
;	O
case	O
WGET_TEST_HTTP_REJECT_CONNECTIONS	int
:	O
reject_http_connection	int
=	O
1	int
;	O
break	O
;	O
case	O
WGET_TEST_HTTPS_REJECT_CONNECTIONS	int
:	O
reject_https_connection	int
=	O
1	int
;	O
break	O
;	O
case	O
WGET_TEST_FEATURE_MHD	int
:	O
break	O
;	O
case	O
WGET_TEST_FEATURE_TLS	int
:	O
break	O
;	O
case	O
WGET_TEST_FEATURE_IDN	int
:	O
wget_error_printf	(*(char))->(void)
(	O
_	O
(	O
"Support for LibIDN not found. Skipping\n"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
WGET_TEST_EXIT_SKIP	int
)	O
;	O
break	O
;	O
case	O
WGET_TEST_FEATURE_PLUGIN	int
:	O
break	O
;	O
case	O
WGET_TEST_FEATURE_OCSP	int
:	O
wget_error_printf	(*(char))->(void)
(	O
_	O
(	O
"Test requires GnuTLS with OCSP support. Skipping\n"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
WGET_TEST_EXIT_SKIP	int
)	O
;	O
break	O
;	O
case	O
WGET_TEST_FEATURE_OCSP_STAPLING	int
:	O
wget_error_printf	(*(char))->(void)
(	O
_	O
(	O
"MHD or GnuTLS version insufficient. Skipping\n"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
WGET_TEST_EXIT_SKIP	int
)	O
;	O
case	O
WGET_TEST_SKIP_H2	int
:	O
break	O
;	O
default	O
:	O
wget_error_printf	(*(char))->(void)
(	O
_	O
(	O
"Unknown option %d\n"	*(char)
)	O
,	O
key	int
)	O
;	O
}	O
}	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
atexit	(*(()->(void)))->(int)
(	O
wget_test_stop_server	()->(void)
)	O
;	O
wget_snprintf	(*(char),long,*(char))->(long)
(	O
tmpdir	array(char)
,	O
sizeof	O
(	O
tmpdir	array(char)
)	O
,	O
".test_%d"	*(char)
,	O
(	O
int	O
)	O
getpid	()->(int)
(	O
)	O
)	O
;	O
_remove_directory	(*(char))->(void)
(	O
tmpdir	array(char)
)	O
;	O
if	O
(	O
mkdir	(*(char),int)->(int)
(	O
tmpdir	array(char)
,	O
0755	int
)	O
!=	O
0	int
)	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Failed to create tmpdir (%d)\n"	*(char)
)	O
,	O
errno	O
)	O
;	O
if	O
(	O
chdir	(*(char))->(int)
(	O
tmpdir	array(char)
)	O
!=	O
0	int
)	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Failed to change to tmpdir (%d)\n"	*(char)
)	O
,	O
errno	O
)	O
;	O
if	O
(	O
start_http	bool
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
_http_server_start	(int)->(int)
(	O
HTTP_MODE	int
)	O
)	O
!=	O
0	int
)	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Failed to start HTTP server, error %d\n"	*(char)
)	O
,	O
rc	int
)	O
;	O
}	O
if	O
(	O
start_https	bool
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
_http_server_start	(int)->(int)
(	O
HTTPS_MODE	int
)	O
)	O
!=	O
0	int
)	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Failed to start HTTPS server, error %d\n"	*(char)
)	O
,	O
rc	int
)	O
;	O
}	O
}	O
static	O
void	O
_scan_for_unexpected	(*(char),*(struct(*(char),*(char),long,char,long,*(char))))->(void)
(	O
const	O
char	O
*	O
dirname	*(char)
,	O
const	O
wget_test_file_t	struct(*(char),*(char),long,char,long,*(char))
*	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
)	O
{	O
DIR	struct
*	O
dir	array(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
size_t	long
dirlen	long
=	O
strlen	(*(char))->(long)
(	O
dirname	*(char)
)	O
;	O
wget_info_printf	(*(char))->(void)
(	O
"Entering %s\n"	*(char)
,	O
dirname	*(char)
)	O
;	O
if	O
(	O
(	O
dir	array(char)
=	O
opendir	(*(char))->(*(struct))
(	O
dirname	*(char)
)	O
)	O
)	O
{	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dp	*(struct(long,long,short,char,array(char)))
;	O
while	O
(	O
(	O
dp	*(struct(long,long,short,char,array(char)))
=	O
readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
dir	array(char)
)	O
)	O
)	O
{	O
char	O
fname	*(char)
[	O
dirlen	long
+	O
1	int
+	O
strlen	(*(char))->(long)
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
+	O
1	int
]	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
,	O
"."	*(char)
)	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
,	O
".."	*(char)
)	O
)	O
continue	O
;	O
if	O
(	O
*	O
dirname	*(char)
==	O
'.'	O
&&	O
dirname	*(char)
[	O
1	int
]	O
==	O
0	int
)	O
wget_snprintf	(*(char),long,*(char))->(long)
(	O
fname	*(char)
,	O
sizeof	O
(	O
fname	*(char)
)	O
,	O
"%s"	*(char)
,	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
;	O
else	O
wget_snprintf	(*(char),long,*(char))->(long)
(	O
fname	*(char)
,	O
sizeof	O
(	O
fname	*(char)
)	O
,	O
"%s/%s"	*(char)
,	O
dirname	*(char)
,	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
;	O
wget_info_printf	(*(char))->(void)
(	O
" - %s/%s\n"	*(char)
,	O
dirname	*(char)
,	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
fname	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
&&	O
S_ISDIR	O
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
_scan_for_unexpected	(*(char),*(struct(*(char),*(char),long,char,long,*(char))))->(void)
(	O
fname	*(char)
,	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
)	O
{	O
size_t	long
it	int
;	O
wget_info_printf	(*(char))->(void)
(	O
_	O
(	O
"search %s\n"	*(char)
)	O
,	O
fname	*(char)
)	O
;	O
for	O
(	O
it	int
=	O
0	int
;	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
;	O
it	int
++	O
)	O
{	O
const	O
char	O
*	O
restricted_fname	*(char)
=	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
restricted_fname	*(char)
,	O
fname	*(char)
)	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
)	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Unexpected file %s/%s found\n"	*(char)
)	O
,	O
tmpdir	array(char)
,	O
fname	*(char)
)	O
;	O
}	O
else	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Unexpected file %s/%s found\n"	*(char)
)	O
,	O
tmpdir	array(char)
,	O
fname	*(char)
)	O
;	O
}	O
closedir	(*(struct))->(int)
(	O
dir	array(char)
)	O
;	O
}	O
else	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Failed to diropen %s\n"	*(char)
)	O
,	O
dirname	*(char)
)	O
;	O
}	O
void	O
wget_test	(int)->(void)
(	O
int	O
first_key	int
,	O
...	O
)	O
{	O
if	O
(	O
!	O
httpdaemon	*(struct)
&&	O
!	O
httpsdaemon	*(struct)
)	O
exit	(int)->(void)
(	O
WGET_TEST_EXIT_SKIP	int
)	O
;	O
for	O
(	O
proto_pass	enum(int,int,int)
=	O
0	int
;	O
proto_pass	enum(int,int,int)
<	O
END_PASS	int
;	O
proto_pass	enum(int,int,int)
++	O
)	O
{	O
if	O
(	O
proto_pass	enum(int,int,int)
==	O
HTTP_1_1_PASS	int
&&	O
!	O
httpdaemon	*(struct)
&&	O
!	O
httpsdaemon	*(struct)
)	O
continue	O
;	O
if	O
(	O
proto_pass	enum(int,int,int)
==	O
H2_PASS	int
)	O
{	O
continue	O
;	O
if	O
(	O
!	O
h2daemon	*(struct)
)	O
continue	O
;	O
}	O
for	O
(	O
wget_test_url_t	struct(*(char),*(char),*(char),*(char),array(*(char)),array(*(char)),array(*(char)),array(*(char)),array(*(char)),long,*(char),*(char),*(char),long,bool,bool)
*	O
url	*(char)
=	O
urls	*(*(struct))
;	O
url	*(char)
<	O
urls	*(*(struct))
+	O
nurls	long
;	O
url	*(char)
++	O
)	O
{	O
char	O
*	O
p	*(char)
=	O
_insert_ports	(*(char))->(*(char))
(	O
url	*(char)
->	O
body	*(char)
)	O
;	O
if	O
(	O
p	*(char)
)	O
{	O
url	*(char)
->	O
body_original	*(char)
=	O
url	*(char)
->	O
body	*(char)
;	O
url	*(char)
->	O
body	*(char)
=	O
p	*(char)
;	O
}	O
for	O
(	O
unsigned	O
it	int
=	O
0	int
;	O
it	int
<	O
countof	O
(	O
url	*(char)
->	O
headers	*(struct)
)	O
&&	O
url	*(char)
->	O
headers	*(struct)
[	O
it	int
]	O
;	O
it	int
++	O
)	O
{	O
p	*(char)
=	O
_insert_ports	(*(char))->(*(char))
(	O
url	*(char)
->	O
headers	*(struct)
[	O
it	int
]	O
)	O
;	O
if	O
(	O
p	*(char)
)	O
{	O
url	*(char)
->	O
headers_original	array(*(char))
[	O
it	int
]	O
=	O
url	*(char)
->	O
headers	*(struct)
[	O
it	int
]	O
;	O
url	*(char)
->	O
headers	*(struct)
[	O
it	int
]	O
=	O
p	*(char)
;	O
}	O
}	O
}	O
const	O
char	O
*	O
request_url	*(char)
,	O
*	O
options	*(char)
=	O
""	*(char)
,	O
*	O
executable	*(char)
;	O
const	O
wget_test_file_t	struct(*(char),*(char),long,char,long,*(char))
*	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
=	O
NULL	O
,	O
*	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
=	O
NULL	O
;	O
wget_buffer	struct(*(char),long,long,bool,bool,bool)
*	O
cmd	*(struct(*(char),long,long,bool,bool,bool))
=	O
wget_buffer_alloc	(long)->(*(struct(*(char),long,long,bool,bool,bool)))
(	O
1024	int
)	O
;	O
unsigned	O
it	int
;	O
int	O
key	int
,	O
fd	array(int)
,	O
rc	int
,	O
expected_error_code2	int
=	O
-	O
1	int
,	O
expected_error_code	int
=	O
0	int
;	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
;	O
char	O
server_send_content_length_old	char
=	O
server_send_content_length	char
;	O
bool	bool
options_alloc	bool
=	O
0	int
;	O
if	O
(	O
proto_pass	enum(int,int,int)
==	O
H2_PASS	int
)	O
executable	*(char)
=	O
BUILDDIR	O
"/../src/wget2_noinstall"	*(char)
EXEEXT	O
" -d --no-config --no-local-db --max-threads=1 --prefer-family=ipv4 --no-proxy --timeout 10 --https-enforce=hard --ca-certificate="	*(char)
SRCDIR	O
"/certs/x509-ca-cert.pem --no-ocsp"	*(char)
;	O
else	O
executable	*(char)
=	O
BUILDDIR	O
"/../src/wget2_noinstall"	*(char)
EXEEXT	O
" -d --no-config --no-local-db --max-threads=1 --prefer-family=ipv4 --no-proxy --timeout 10"	*(char)
;	O
keep_tmpfiles	int
=	O
0	int
;	O
if	O
(	O
!	O
request_urls	*(struct)
)	O
{	O
request_urls	*(struct)
=	O
wget_vector_create	(int,*((*(void),*(void))->(int)))->(*(struct))
(	O
8	int
,	O
NULL	O
)	O
;	O
wget_vector_set_destructor	(*(struct),*((*(void))->(void)))->(void)
(	O
request_urls	*(struct)
,	O
NULL	O
)	O
;	O
}	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
first_key	int
)	O
;	O
for	O
(	O
key	int
=	O
first_key	int
;	O
key	int
;	O
key	int
=	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
int	O
)	O
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
WGET_TEST_REQUEST_URL	int
:	O
if	O
(	O
(	O
request_url	*(char)
=	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
const	O
char	O
*	O
)	O
)	O
)	O
wget_vector_add	(*(struct),*(void))->(int)
(	O
request_urls	*(struct)
,	O
request_url	*(char)
)	O
;	O
break	O
;	O
case	O
WGET_TEST_REQUEST_URLS	int
:	O
while	O
(	O
(	O
request_url	*(char)
=	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
const	O
char	O
*	O
)	O
)	O
)	O
wget_vector_add	(*(struct),*(void))->(int)
(	O
request_urls	*(struct)
,	O
request_url	*(char)
)	O
;	O
break	O
;	O
case	O
WGET_TEST_EXPECTED_ERROR_CODE	int
:	O
expected_error_code	int
=	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
int	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_EXPECTED_ERROR_CODE2	int
:	O
expected_error_code2	int
=	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
int	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_EXPECTED_FILES	int
:	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
=	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
const	O
wget_test_file_t	struct(*(char),*(char),long,char,long,*(char))
*	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_EXISTING_FILES	int
:	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
=	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
const	O
wget_test_file_t	struct(*(char),*(char),long,char,long,*(char))
*	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_OPTIONS	int
:	O
{	O
options	*(char)
=	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
const	O
char	O
*	O
)	O
;	O
const	O
char	O
*	O
tmp	*(char)
=	O
_insert_ports	(*(char))->(*(char))
(	O
options	*(char)
)	O
;	O
if	O
(	O
tmp	*(char)
)	O
{	O
options	*(char)
=	O
tmp	*(char)
;	O
options_alloc	bool
=	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
WGET_TEST_KEEP_TMPFILES	int
:	O
keep_tmpfiles	int
=	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
int	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_EXECUTABLE	int
:	O
executable	*(char)
=	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
const	O
char	O
*	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_SERVER_SEND_CONTENT_LENGTH	int
:	O
server_send_content_length	char
=	O
!	O
!	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
int	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_POST_HANDSHAKE_AUTH	int
:	O
if	O
(	O
va_arg	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
int	O
)	O
)	O
{	O
}	O
break	O
;	O
case	O
WGET_TEST_OCSP_RESP_FILE	int
:	O
break	O
;	O
default	O
:	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Unknown option %d [%s]\n"	*(char)
)	O
,	O
key	int
,	O
options	*(char)
)	O
;	O
}	O
}	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
wget_buffer_printf	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
cmd	*(struct(*(char),long,long,bool,bool,bool))
,	O
"../%s"	*(char)
,	O
tmpdir	array(char)
)	O
;	O
_empty_directory	(*(char))->(void)
(	O
cmd	*(struct(*(char),long,long,bool,bool,bool))
->	O
data	*(void)
)	O
;	O
if	O
(	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
)	O
{	O
for	O
(	O
it	int
=	O
0	int
;	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
;	O
it	int
++	O
)	O
{	O
mkdir_path	(*(char),bool)->(void)
(	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
hardlink	*(char)
)	O
{	O
if	O
(	O
link	(*(char),*(char))->(int)
(	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
hardlink	*(char)
,	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
)	O
!=	O
0	int
)	O
{	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Failed to link %s/%s -> %s/%s [%s]\n"	*(char)
)	O
,	O
tmpdir	array(char)
,	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
hardlink	*(char)
,	O
tmpdir	array(char)
,	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
,	O
options	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
fd	array(int)
=	O
open	(*(char),int)->(int)
(	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
,	O
O_CREAT	int
|	O
O_WRONLY	int
|	O
O_TRUNC	int
|	O
O_BINARY	int
,	O
0644	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
const	O
char	O
*	O
existing_content	*(char)
=	O
_insert_ports	(*(char))->(*(char))
(	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
content	*(char)
)	O
;	O
if	O
(	O
!	O
existing_content	*(char)
)	O
existing_content	*(char)
=	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
content	*(char)
;	O
ssize_t	long
nbytes	long
=	O
write	(int,*(void),long)->(long)
(	O
fd	array(int)
,	O
existing_content	*(char)
,	O
strlen	(*(char))->(long)
(	O
existing_content	*(char)
)	O
)	O
;	O
close	(int)->(int)
(	O
fd	array(int)
)	O
;	O
if	O
(	O
nbytes	long
!=	O
(	O
ssize_t	long
)	O
strlen	(*(char))->(long)
(	O
existing_content	*(char)
)	O
)	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Failed to write %zu bytes to file %s/%s [%s]\n"	*(char)
)	O
,	O
strlen	(*(char))->(long)
(	O
existing_content	*(char)
)	O
,	O
tmpdir	array(char)
,	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
,	O
options	*(char)
)	O
;	O
if	O
(	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
timestamp	long
)	O
{	O
if	O
(	O
utime	(*(char),*(struct(long,long)))->(int)
(	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
,	O
&	O
(	O
struct	O
utimbuf	struct(long,long)
)	O
{	O
0	int
,	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
timestamp	long
}	O
)	O
)	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Failed to set mtime of %s/%s [%s]\n"	*(char)
)	O
,	O
tmpdir	array(char)
,	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
,	O
options	*(char)
)	O
;	O
}	O
if	O
(	O
existing_content	*(char)
!=	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
content	*(char)
)	O
wget_xfree	O
(	O
existing_content	*(char)
)	O
;	O
}	O
else	O
{	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Failed to write open file %s/%s [%s] (%d,%s)\n"	*(char)
)	O
,	O
tmpdir	array(char)
,	O
*	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
==	O
'/'	O
?	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
+	O
1	int
:	O
existing_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
,	O
options	*(char)
,	O
errno	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
}	O
const	O
char	O
*	O
valgrind	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"VALGRIND_TESTS"	*(char)
)	O
;	O
if	O
(	O
!	O
valgrind	*(char)
||	O
!	O
*	O
valgrind	*(char)
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
valgrind	*(char)
,	O
"0"	*(char)
)	O
)	O
{	O
const	O
char	O
*	O
emulator	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"EMULATOR"	*(char)
)	O
;	O
if	O
(	O
emulator	*(char)
&&	O
*	O
emulator	*(char)
)	O
wget_buffer_printf	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
cmd	*(struct(*(char),long,long,bool,bool,bool))
,	O
"%s %s %s"	*(char)
,	O
emulator	*(char)
,	O
executable	*(char)
,	O
options	*(char)
)	O
;	O
else	O
wget_buffer_printf	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
cmd	*(struct(*(char),long,long,bool,bool,bool))
,	O
"%s %s"	*(char)
,	O
executable	*(char)
,	O
options	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
valgrind	*(char)
,	O
"1"	*(char)
)	O
)	O
{	O
wget_buffer_printf	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
cmd	*(struct(*(char),long,long,bool,bool,bool))
,	O
"valgrind --error-exitcode=301 --leak-check=yes --show-reachable=yes --track-origins=yes --child-silent-after-fork=yes --suppressions="	*(char)
SRCDIR	O
"/valgrind-suppressions %s %s"	*(char)
,	O
executable	*(char)
,	O
options	*(char)
)	O
;	O
}	O
else	O
wget_buffer_printf	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
cmd	*(struct(*(char),long,long,bool,bool,bool))
,	O
"%s %s %s"	*(char)
,	O
valgrind	*(char)
,	O
executable	*(char)
,	O
options	*(char)
)	O
;	O
for	O
(	O
it	int
=	O
0	int
;	O
it	int
<	O
(	O
size_t	long
)	O
wget_vector_size	(*(struct))->(int)
(	O
request_urls	*(struct)
)	O
;	O
it	int
++	O
)	O
{	O
request_url	*(char)
=	O
wget_vector_get	(*(struct),int)->(*(void))
(	O
request_urls	*(struct)
,	O
it	int
)	O
;	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
request_url	*(char)
,	O
"http://"	*(char)
,	O
7	int
)	O
||	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
request_url	*(char)
,	O
"https://"	*(char)
,	O
8	int
)	O
)	O
{	O
char	O
*	O
tmp	*(char)
=	O
_insert_ports	(*(char))->(*(char))
(	O
request_url	*(char)
)	O
;	O
wget_buffer_printf_append	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
cmd	*(struct(*(char),long,long,bool,bool,bool))
,	O
" \"%s\""	*(char)
,	O
tmp	*(char)
?	O
tmp	*(char)
:	O
request_url	*(char)
)	O
;	O
wget_xfree	O
(	O
tmp	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
proto_pass	enum(int,int,int)
==	O
HTTP_1_1_PASS	int
)	O
{	O
wget_buffer_printf_append	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
cmd	*(struct(*(char),long,long,bool,bool,bool))
,	O
" \"http://localhost:%d/%s\""	*(char)
,	O
http_server_port	int
,	O
request_url	*(char)
)	O
;	O
}	O
}	O
}	O
wget_buffer_strcat	(*(struct(*(char),long,long,bool,bool,bool)),*(char))->(long)
(	O
cmd	*(struct(*(char),long,long,bool,bool,bool))
,	O
" 2>&1"	*(char)
)	O
;	O
wget_info_printf	(*(char))->(void)
(	O
"cmd=%s\n"	*(char)
,	O
cmd	*(struct(*(char),long,long,bool,bool,bool))
->	O
data	*(void)
)	O
;	O
wget_error_printf	(*(char))->(void)
(	O
_	O
(	O
"\n  Testing '%s'\n"	*(char)
)	O
,	O
cmd	*(struct(*(char),long,long,bool,bool,bool))
->	O
data	*(void)
)	O
;	O
FILE	struct
*	O
pp	*(struct)
;	O
if	O
(	O
(	O
pp	*(struct)
=	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
cmd	*(struct(*(char),long,long,bool,bool,bool))
->	O
data	*(void)
,	O
"r"	*(char)
)	O
)	O
)	O
{	O
char	O
buf	*(char)
[	O
4096	int
]	O
;	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
pp	*(struct)
)	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
buf	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
rc	int
=	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pp	*(struct)
)	O
;	O
}	O
else	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Failed to execute test (%d) [%s]\n"	*(char)
)	O
,	O
errno	O
,	O
options	*(char)
)	O
;	O
if	O
(	O
!	O
WIFEXITED	O
(	O
rc	int
)	O
)	O
{	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Unexpected error code %d, expected %d [%s]\n"	*(char)
)	O
,	O
rc	int
,	O
expected_error_code	int
,	O
options	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
WEXITSTATUS	O
(	O
rc	int
)	O
!=	O
expected_error_code	int
)	O
{	O
if	O
(	O
expected_error_code2	int
>=	O
0	int
)	O
{	O
if	O
(	O
WEXITSTATUS	O
(	O
rc	int
)	O
!=	O
expected_error_code2	int
)	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Unexpected error code %d, expected %d or %d [%s]\n"	*(char)
)	O
,	O
WEXITSTATUS	O
(	O
rc	int
)	O
,	O
expected_error_code	int
,	O
expected_error_code2	int
,	O
options	*(char)
)	O
;	O
}	O
else	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Unexpected error code %d, expected %d [%s]\n"	*(char)
)	O
,	O
WEXITSTATUS	O
(	O
rc	int
)	O
,	O
expected_error_code	int
,	O
options	*(char)
)	O
;	O
}	O
if	O
(	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
)	O
{	O
for	O
(	O
it	int
=	O
0	int
;	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
;	O
it	int
++	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
const	O
char	O
*	O
fname	*(char)
=	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
name	*(char)
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
fname	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
0	int
)	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Missing expected file '%s/%s' [%s]\n"	*(char)
)	O
,	O
tmpdir	array(char)
,	O
fname	*(char)
,	O
options	*(char)
)	O
;	O
if	O
(	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
content	*(char)
)	O
{	O
char	O
*	O
content	*(char)
=	O
wget_malloc	(long)->(*(void))
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
?	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
:	O
1	int
)	O
;	O
if	O
(	O
(	O
fd	array(int)
=	O
open	(*(char),int)->(int)
(	O
fname	*(char)
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
ssize_t	long
nbytes	long
=	O
read	(int,*(void),long)->(long)
(	O
fd	array(int)
,	O
content	*(char)
,	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
;	O
close	(int)->(int)
(	O
fd	array(int)
)	O
;	O
if	O
(	O
nbytes	long
!=	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Failed to read %lld bytes from file '%s/%s', just got %zd [%s]\n"	*(char)
)	O
,	O
(	O
long	O
long	O
)	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
,	O
tmpdir	array(char)
,	O
fname	*(char)
,	O
nbytes	long
,	O
options	*(char)
)	O
;	O
const	O
char	O
*	O
expected_content	*(char)
=	O
_insert_ports	(*(char))->(*(char))
(	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
content	*(char)
)	O
;	O
bool	bool
expected_content_alloc	bool
=	O
0	int
;	O
if	O
(	O
!	O
expected_content	*(char)
)	O
expected_content	*(char)
=	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
content	*(char)
;	O
else	O
expected_content_alloc	bool
=	O
1	int
;	O
size_t	long
content_length	long
=	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
content_length	long
?	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
content_length	long
:	O
strlen	(*(char))->(long)
(	O
expected_content	*(char)
)	O
;	O
if	O
(	O
content_length	long
!=	O
(	O
size_t	long
)	O
nbytes	long
||	O
memcmp	(*(void),*(void),long)->(int)
(	O
expected_content	*(char)
,	O
content	*(char)
,	O
nbytes	long
)	O
!=	O
0	int
)	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Unexpected content in %s [%s]\n"	*(char)
)	O
,	O
fname	*(char)
,	O
options	*(char)
)	O
;	O
if	O
(	O
expected_content_alloc	bool
)	O
wget_xfree	O
(	O
expected_content	*(char)
)	O
;	O
}	O
wget_xfree	O
(	O
content	*(char)
)	O
;	O
}	O
if	O
(	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
timestamp	long
&&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
!=	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
[	O
it	int
]	O
.	O
timestamp	long
)	O
wget_error_printf_exit	(*(char))->(void)
(	O
_	O
(	O
"Unexpected timestamp '%s/%s' [%s]\n"	*(char)
)	O
,	O
tmpdir	array(char)
,	O
fname	*(char)
,	O
options	*(char)
)	O
;	O
}	O
}	O
_scan_for_unexpected	(*(char),*(struct(*(char),*(char),long,char,long,*(char))))->(void)
(	O
"."	*(char)
,	O
expected_files	*(struct(*(char),*(char),long,char,long,*(char)))
)	O
;	O
wget_vector_clear	(*(struct))->(void)
(	O
request_urls	*(struct)
)	O
;	O
wget_buffer_free	(*(*(struct(*(char),long,long,bool,bool,bool))))->(void)
(	O
&	O
cmd	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
if	O
(	O
options_alloc	bool
)	O
wget_xfree	O
(	O
options	*(char)
)	O
;	O
server_send_content_length	char
=	O
server_send_content_length_old	char
;	O
for	O
(	O
wget_test_url_t	struct(*(char),*(char),*(char),*(char),array(*(char)),array(*(char)),array(*(char)),array(*(char)),array(*(char)),long,*(char),*(char),*(char),long,bool,bool)
*	O
url	*(char)
=	O
urls	*(*(struct))
;	O
url	*(char)
<	O
urls	*(*(struct))
+	O
nurls	long
;	O
url	*(char)
++	O
)	O
{	O
if	O
(	O
url	*(char)
->	O
body_original	*(char)
)	O
{	O
wget_xfree	O
(	O
url	*(char)
->	O
body	*(char)
)	O
;	O
url	*(char)
->	O
body	*(char)
=	O
url	*(char)
->	O
body_original	*(char)
;	O
url	*(char)
->	O
body_original	*(char)
=	O
NULL	O
;	O
}	O
for	O
(	O
it	int
=	O
0	int
;	O
it	int
<	O
countof	O
(	O
url	*(char)
->	O
headers	*(struct)
)	O
&&	O
url	*(char)
->	O
headers	*(struct)
[	O
it	int
]	O
;	O
it	int
++	O
)	O
{	O
if	O
(	O
url	*(char)
->	O
headers_original	array(*(char))
[	O
it	int
]	O
)	O
{	O
wget_xfree	O
(	O
url	*(char)
->	O
headers	*(struct)
[	O
it	int
]	O
)	O
;	O
url	*(char)
->	O
headers	*(struct)
[	O
it	int
]	O
=	O
url	*(char)
->	O
headers_original	array(*(char))
[	O
it	int
]	O
;	O
url	*(char)
->	O
headers_original	array(*(char))
[	O
it	int
]	O
=	O
NULL	O
;	O
}	O
}	O
}	O
}	O
}	O
int	O
wget_test_get_http_server_port	()->(int)
(	O
void	O
)	O
{	O
return	O
proto_pass	enum(int,int,int)
==	O
H2_PASS	int
?	O
h2_server_port	int
:	O
http_server_port	int
;	O
}	O
int	O
wget_test_get_https_server_port	()->(int)
(	O
void	O
)	O
{	O
return	O
proto_pass	enum(int,int,int)
==	O
H2_PASS	int
?	O
h2_server_port	int
:	O
https_server_port	int
;	O
}	O
int	O
wget_test_get_h2_server_port	()->(int)
(	O
void	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
int	O
wget_test_get_ocsp_server_port	()->(int)
(	O
void	O
)	O
{	O
return	O
ocsp_server_port	int
;	O
}	O
int	O
wget_test_check_file_system	()->(int)
(	O
void	O
)	O
{	O
static	O
char	O
fname	*(char)
[	O
3	int
]	O
[	O
3	int
]	O
=	O
{	O
"Ab"	*(char)
,	O
"ab"	*(char)
,	O
"AB"	*(char)
}	O
;	O
char	O
buf	*(char)
[	O
sizeof	O
(	O
fname	*(char)
[	O
0	int
]	O
)	O
]	O
;	O
int	O
flags	int
=	O
0	int
,	O
fd	array(int)
;	O
ssize_t	long
rc	int
;	O
_empty_directory	(*(char))->(void)
(	O
tmpdir	array(char)
)	O
;	O
for	O
(	O
unsigned	O
it	int
=	O
0	int
;	O
it	int
<	O
countof	O
(	O
fname	*(char)
)	O
;	O
it	int
++	O
)	O
{	O
if	O
(	O
(	O
fd	array(int)
=	O
open	(*(char),int)->(int)
(	O
fname	*(char)
[	O
it	int
]	O
,	O
O_WRONLY	int
|	O
O_TRUNC	int
|	O
O_CREAT	int
|	O
O_BINARY	int
,	O
0644	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
rc	int
=	O
write	(int,*(void),long)->(long)
(	O
fd	array(int)
,	O
fname	*(char)
[	O
it	int
]	O
,	O
sizeof	O
(	O
fname	*(char)
[	O
0	int
]	O
)	O
)	O
;	O
close	(int)->(int)
(	O
fd	array(int)
)	O
;	O
if	O
(	O
rc	int
!=	O
sizeof	O
(	O
fname	*(char)
[	O
0	int
]	O
)	O
)	O
{	O
wget_debug_printf	(*(char))->(void)
(	O
"%s: Failed to write to '%s/%s' (%d) %zd %zu\n"	*(char)
,	O
__func__	O
,	O
tmpdir	array(char)
,	O
fname	*(char)
[	O
it	int
]	O
,	O
errno	O
,	O
rc	int
,	O
sizeof	O
(	O
fname	*(char)
[	O
0	int
]	O
)	O
)	O
;	O
goto	O
out	*(*(char))
;	O
}	O
}	O
else	O
{	O
wget_debug_printf	(*(char))->(void)
(	O
"%s: Failed to write open '%s/%s'\n"	*(char)
,	O
__func__	O
,	O
tmpdir	array(char)
,	O
fname	*(char)
[	O
it	int
]	O
)	O
;	O
goto	O
out	*(*(char))
;	O
}	O
}	O
for	O
(	O
unsigned	O
it	int
=	O
0	int
;	O
it	int
<	O
countof	O
(	O
fname	*(char)
)	O
;	O
it	int
++	O
)	O
{	O
if	O
(	O
(	O
fd	array(int)
=	O
open	(*(char),int)->(int)
(	O
fname	*(char)
[	O
it	int
]	O
,	O
O_RDONLY	int
|	O
O_BINARY	int
,	O
0644	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
rc	int
=	O
read	(int,*(void),long)->(long)
(	O
fd	array(int)
,	O
buf	*(char)
,	O
sizeof	O
(	O
fname	*(char)
[	O
0	int
]	O
)	O
)	O
;	O
close	(int)->(int)
(	O
fd	array(int)
)	O
;	O
if	O
(	O
rc	int
!=	O
sizeof	O
(	O
fname	*(char)
[	O
0	int
]	O
)	O
)	O
{	O
wget_debug_printf	(*(char))->(void)
(	O
"%s: Failed to read from '%s/%s'\n"	*(char)
,	O
__func__	O
,	O
tmpdir	array(char)
,	O
fname	*(char)
[	O
it	int
]	O
)	O
;	O
goto	O
out	*(*(char))
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
fname	*(char)
[	O
it	int
]	O
)	O
)	O
{	O
wget_debug_printf	(*(char))->(void)
(	O
"%s: Found case-mangling file system\n"	*(char)
,	O
__func__	O
)	O
;	O
flags	int
=	O
WGET_TEST_FS_CASEMATTERS	int
;	O
goto	O
out	*(*(char))
;	O
}	O
}	O
else	O
{	O
wget_debug_printf	(*(char))->(void)
(	O
"%s: Failed to read open '%s/%s'\n"	*(char)
,	O
__func__	O
,	O
tmpdir	array(char)
,	O
fname	*(char)
[	O
it	int
]	O
)	O
;	O
goto	O
out	*(*(char))
;	O
}	O
}	O
wget_debug_printf	(*(char))->(void)
(	O
"%s: Found case-respecting file system\n"	*(char)
,	O
__func__	O
)	O
;	O
out	*(*(char))
:	O
_empty_directory	(*(char))->(void)
(	O
tmpdir	array(char)
)	O
;	O
return	O
flags	int
;	O
}	O
