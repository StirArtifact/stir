error_t	O
fshelp_fetch_root	(*(struct),*(void),int,*(struct),int,int,int,*(int),*(char),*(int))->(int)
(	O
struct	O
transbox	O
*	O
box	*(struct)
,	O
void	O
*	O
cookie	*(void)
,	O
file_t	O
dotdot	int
,	O
struct	O
iouser	O
*	O
user	*(struct)
,	O
int	O
flags	int
,	O
fshelp_fetch_root_callback1_t	O
callback1	int
,	O
fshelp_fetch_root_callback2_t	O
callback2	int
,	O
retry_type	O
*	O
retry	*(int)
,	O
char	O
*	O
retryname	*(char)
,	O
file_t	O
*	O
root	*(int)
)	O
{	O
error_t	O
err	O
;	O
mach_port_t	O
control	O
;	O
int	O
cancel	int
;	O
int	O
i	int
;	O
start_over	O
:	O
if	O
(	O
box	*(struct)
->	O
active	O
!=	O
MACH_PORT_NULL	O
)	O
assert	O
(	O
(	O
box	*(struct)
->	O
flags	int
&	O
TRANSBOX_STARTING	O
)	O
==	O
0	int
)	O
;	O
else	O
{	O
uid_t	O
uid	*(int)
,	O
gid	*(int)
;	O
char	O
*	O
argz	*(char)
;	O
size_t	O
argz_len	*(int)
;	O
error_t	O
err	O
;	O
mach_port_t	O
ports	O
[	O
INIT_PORT_MAX	O
]	O
;	O
int	O
ints	int
[	O
INIT_INT_MAX	O
]	O
;	O
mach_port_t	O
fds	O
[	O
STDERR_FILENO	O
+	O
1	int
]	O
;	O
auth_t	O
ourauth	O
,	O
newauth	O
;	O
mach_port_t	O
reauth	()->(int)
(	O
mach_port_t	O
port	O
)	O
{	O
mach_port_t	O
rend	O
,	O
ret	O
;	O
error_t	O
err	O
;	O
if	O
(	O
port	O
==	O
MACH_PORT_NULL	O
)	O
return	O
port	O
;	O
if	O
(	O
ourauth	O
==	O
MACH_PORT_NULL	O
)	O
return	O
port	O
;	O
rend	O
=	O
mach_reply_port	O
(	O
)	O
;	O
err	O
=	O
io_reauthenticate	O
(	O
port	O
,	O
rend	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
auth_user_authenticate	O
(	O
newauth	O
,	O
rend	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
,	O
&	O
ret	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
port	O
)	O
;	O
if	O
(	O
err	O
)	O
ret	O
=	O
MACH_PORT_NULL	O
;	O
mach_port_mod_refs	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
rend	O
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
-	O
1	int
)	O
;	O
return	O
ret	O
;	O
}	O
error_t	O
fetch_underlying	O
(	O
int	O
flags	int
,	O
mach_port_t	O
*	O
underlying	O
,	O
mach_msg_type_name_t	O
*	O
underlying_type	O
,	O
task_t	O
task	O
,	O
void	O
*	O
cookie	*(void)
)	O
{	O
return	O
(	O
*	O
callback2	int
)	O
(	O
box	*(struct)
->	O
cookie	*(void)
,	O
cookie	*(void)
,	O
flags	int
,	O
underlying	O
,	O
underlying_type	O
)	O
;	O
}	O
if	O
(	O
box	*(struct)
->	O
flags	int
&	O
TRANSBOX_STARTING	O
)	O
{	O
box	*(struct)
->	O
flags	int
|=	O
TRANSBOX_WANTED	O
;	O
cancel	int
=	O
pthread_hurd_cond_wait_np	O
(	O
&	O
box	*(struct)
->	O
wakeup	O
,	O
box	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
cancel	int
)	O
return	O
EINTR	O
;	O
goto	O
start_over	O
;	O
}	O
box	*(struct)
->	O
flags	int
|=	O
TRANSBOX_STARTING	O
;	O
pthread_mutex_unlock	()->(int)
(	O
box	*(struct)
->	O
lock	O
)	O
;	O
err	O
=	O
(	O
*	O
callback1	int
)	O
(	O
box	*(struct)
->	O
cookie	*(void)
,	O
cookie	*(void)
,	O
&	O
uid	*(int)
,	O
&	O
gid	*(int)
,	O
&	O
argz	*(char)
,	O
&	O
argz_len	*(int)
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
return_error	O
;	O
ourauth	O
=	O
getauth	()->(int)
(	O
)	O
;	O
if	O
(	O
ourauth	O
==	O
MACH_PORT_NULL	O
)	O
newauth	O
=	O
ourauth	O
;	O
else	O
{	O
uid_t	O
uidarray	O
[	O
2	int
]	O
=	O
{	O
uid	*(int)
,	O
uid	*(int)
}	O
;	O
gid_t	O
gidarray	O
[	O
2	int
]	O
=	O
{	O
gid	*(int)
,	O
gid	*(int)
}	O
;	O
err	O
=	O
auth_makeauth	()->(int)
(	O
ourauth	O
,	O
0	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
0	int
,	O
uidarray	O
,	O
1	int
,	O
uidarray	O
,	O
2	int
,	O
gidarray	O
,	O
1	int
,	O
gidarray	O
,	O
2	int
,	O
&	O
newauth	O
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
return_error	O
;	O
}	O
memset	O
(	O
ports	O
,	O
0	int
,	O
INIT_PORT_MAX	O
*	O
sizeof	O
(	O
mach_port_t	O
)	O
)	O
;	O
memset	O
(	O
fds	O
,	O
0	int
,	O
(	O
STDERR_FILENO	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
mach_port_t	O
)	O
)	O
;	O
memset	O
(	O
ints	int
,	O
0	int
,	O
INIT_INT_MAX	O
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
ports	O
[	O
INIT_PORT_CWDIR	O
]	O
=	O
dotdot	int
;	O
ports	O
[	O
INIT_PORT_CRDIR	O
]	O
=	O
reauth	()->(int)
(	O
getcrdir	()->(int)
(	O
)	O
)	O
;	O
ports	O
[	O
INIT_PORT_AUTH	O
]	O
=	O
newauth	O
;	O
fds	O
[	O
STDERR_FILENO	O
]	O
=	O
reauth	()->(int)
(	O
getdport	()->(int)
(	O
STDERR_FILENO	O
)	O
)	O
;	O
err	O
=	O
fshelp_start_translator_long	()->(int)
(	O
fetch_underlying	O
,	O
cookie	*(void)
,	O
argz	*(char)
,	O
argz	*(char)
,	O
argz_len	*(int)
,	O
fds	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
STDERR_FILENO	O
+	O
1	int
,	O
ports	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
INIT_PORT_MAX	O
,	O
ints	int
,	O
INIT_INT_MAX	O
,	O
uid	*(int)
,	O
0	int
,	O
&	O
control	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
STDERR_FILENO	O
;	O
i	int
++	O
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
fds	O
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
INIT_PORT_MAX	O
;	O
i	int
++	O
)	O
if	O
(	O
i	int
!=	O
INIT_PORT_CWDIR	O
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
ports	O
[	O
i	int
]	O
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
box	*(struct)
->	O
lock	O
)	O
;	O
free	()->(int)
(	O
argz	*(char)
)	O
;	O
return_error	O
:	O
box	*(struct)
->	O
flags	int
&=	O
~	O
TRANSBOX_STARTING	O
;	O
if	O
(	O
box	*(struct)
->	O
flags	int
&	O
TRANSBOX_WANTED	O
)	O
{	O
box	*(struct)
->	O
flags	int
&=	O
~	O
TRANSBOX_WANTED	O
;	O
pthread_cond_broadcast	()->(int)
(	O
&	O
box	*(struct)
->	O
wakeup	O
)	O
;	O
}	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
if	O
(	O
!	O
MACH_PORT_VALID	()->(int)
(	O
control	O
)	O
)	O
return	O
EDIED	O
;	O
box	*(struct)
->	O
active	O
=	O
control	O
;	O
}	O
control	O
=	O
box	*(struct)
->	O
active	O
;	O
mach_port_mod_refs	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
control	O
,	O
MACH_PORT_RIGHT_SEND	O
,	O
1	int
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
box	*(struct)
->	O
lock	O
)	O
;	O
err	O
=	O
fsys_getroot	()->(int)
(	O
control	O
,	O
dotdot	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
user	*(struct)
->	O
uids	O
->	O
ids	O
,	O
user	*(struct)
->	O
uids	O
->	O
num	O
,	O
user	*(struct)
->	O
gids	O
->	O
ids	O
,	O
user	*(struct)
->	O
gids	O
->	O
num	O
,	O
flags	int
,	O
retry	*(int)
,	O
retryname	*(char)
,	O
root	*(int)
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
box	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
||	O
err	O
==	O
MIG_SERVER_DIED	O
)	O
&&	O
control	O
==	O
box	*(struct)
->	O
active	O
)	O
fshelp_set_active	()->(int)
(	O
box	*(struct)
,	O
MACH_PORT_NULL	O
,	O
0	int
)	O
;	O
else	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
control	O
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
||	O
err	O
==	O
MIG_SERVER_DIED	O
)	O
goto	O
start_over	O
;	O
return	O
err	O
;	O
}	O
error_t	O
fshelp_short_circuited_callback1	(*(void),*(void),*(int),*(int),*(*(char)),*(int))->(int)
(	O
void	O
*	O
cookie1	*(void)
,	O
void	O
*	O
cookie2	*(void)
,	O
uid_t	O
*	O
uid	*(int)
,	O
gid_t	O
*	O
gid	*(int)
,	O
char	O
*	O
*	O
argz	*(char)
,	O
size_t	O
*	O
argz_len	*(int)
)	O
{	O
struct	O
fshelp_stat_cookie2	O
*	O
statc	*(struct)
=	O
cookie2	*(void)
;	O
switch	O
(	O
*	O
statc	*(struct)
->	O
modep	O
&	O
S_IFMT	O
)	O
{	O
case	O
S_IFCHR	O
:	O
case	O
S_IFBLK	O
:	O
if	O
(	O
asprintf	()->(int)
(	O
argz	*(char)
,	O
"%s%c%d%c%d"	*(char)
,	O
(	O
S_ISCHR	()->(int)
(	O
*	O
statc	*(struct)
->	O
modep	O
)	O
?	O
_HURD_CHRDEV	O
:	O
_HURD_BLKDEV	O
)	O
,	O
0	int
,	O
major	()->(int)
(	O
statc	*(struct)
->	O
statp	O
->	O
st_rdev	O
)	O
,	O
0	int
,	O
minor	()->(int)
(	O
statc	*(struct)
->	O
statp	O
->	O
st_rdev	O
)	O
)	O
<	O
0	int
)	O
return	O
ENOMEM	O
;	O
*	O
argz_len	*(int)
=	O
strlen	O
(	O
*	O
argz	*(char)
)	O
+	O
1	int
;	O
*	O
argz_len	*(int)
+=	O
strlen	O
(	O
*	O
argz	*(char)
+	O
*	O
argz_len	*(int)
)	O
+	O
1	int
;	O
*	O
argz_len	*(int)
+=	O
strlen	O
(	O
*	O
argz	*(char)
+	O
*	O
argz_len	*(int)
)	O
+	O
1	int
;	O
break	O
;	O
case	O
S_IFIFO	O
:	O
if	O
(	O
asprintf	()->(int)
(	O
argz	*(char)
,	O
"%s"	*(char)
,	O
_HURD_FIFO	O
)	O
<	O
0	int
)	O
return	O
ENOMEM	O
;	O
*	O
argz_len	*(int)
=	O
strlen	O
(	O
*	O
argz	*(char)
)	O
+	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
ENOENT	O
;	O
}	O
*	O
uid	*(int)
=	O
statc	*(struct)
->	O
statp	O
->	O
st_uid	O
;	O
*	O
gid	*(int)
=	O
statc	*(struct)
->	O
statp	O
->	O
st_gid	O
;	O
return	O
0	int
;	O
}	O
