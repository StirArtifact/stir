struct	O
process	O
{	O
struct	O
process	O
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
,	O
*	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
int	O
type	enum(int,int,int)
;	O
unsigned	O
timeout	int
;	O
pid_t	int
pid	int
;	O
time_t	long
start	O
;	O
union	O
{	O
struct	O
process	O
*	O
redir	array(*(struct(*(struct(*(struct`),*(struct`),int,int,int,long)),*(struct(*(struct`),*(struct`),int,int,int,long)),int,int,int,long)))
[	O
2	int
]	O
;	O
struct	O
process	O
*	O
master	*(struct(*(struct(*(struct`),*(struct`),int,int,int,long)),*(struct(*(struct`),*(struct`),int,int,int,long)),int,int,int,long))
;	O
}	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
;	O
}	O
;	O
struct	O
process	O
*	O
proc_list	O
;	O
struct	O
process	O
*	O
proc_avail	O
;	O
struct	O
process	O
*	O
proc_unlink	O
(	O
struct	O
process	O
*	O
*	O
root	O
,	O
struct	O
process	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
{	O
if	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
else	O
*	O
root	O
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
if	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
NULL	O
;	O
return	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
}	O
struct	O
process	O
*	O
proc_pop	O
(	O
struct	O
process	O
*	O
*	O
pp	O
)	O
{	O
if	O
(	O
*	O
pp	O
)	O
return	O
proc_unlink	O
(	O
pp	O
,	O
*	O
pp	O
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
proc_push	O
(	O
struct	O
process	O
*	O
*	O
pp	O
,	O
struct	O
process	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
{	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
NULL	O
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
*	O
pp	O
;	O
if	O
(	O
*	O
pp	O
)	O
(	O
*	O
pp	O
)	O
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
*	O
pp	O
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
}	O
struct	O
process	O
*	O
register_process	O
(	O
int	O
type	enum(int,int,int)
,	O
pid_t	int
pid	int
,	O
time_t	long
t	O
,	O
unsigned	O
timeout	int
)	O
{	O
struct	O
process	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
if	O
(	O
proc_avail	O
)	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
proc_pop	O
(	O
&	O
proc_avail	O
)	O
;	O
else	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
,	O
0	int
,	O
sizeof	O
(	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
)	O
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
type	enum(int,int,int)
=	O
type	enum(int,int,int)
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
timeout	int
=	O
timeout	int
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
pid	int
=	O
pid	int
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
start	O
=	O
t	O
;	O
proc_push	O
(	O
&	O
proc_list	O
,	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
;	O
return	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
}	O
void	O
deregister_process	O
(	O
pid_t	int
pid	int
,	O
time_t	long
t	O
)	O
{	O
struct	O
process	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
for	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
proc_list	O
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
if	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
pid	int
==	O
pid	int
)	O
{	O
if	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
else	O
proc_list	O
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
if	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
free	(*(void))->(void)
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
;	O
break	O
;	O
}	O
}	O
struct	O
process	O
*	O
process_lookup	(int)->(*(struct))
(	O
pid_t	int
pid	int
)	O
{	O
struct	O
process	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
for	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
proc_list	O
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
if	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
pid	int
==	O
pid	int
)	O
return	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
return	O
NULL	O
;	O
}	O
static	O
void	O
print_status	O
(	O
pid_t	int
pid	int
,	O
int	O
status	O
,	O
sigset_t	struct(array(long))
*	O
mask	struct(int,int)
)	O
{	O
if	O
(	O
WIFEXITED	O
(	O
status	O
)	O
)	O
{	O
if	O
(	O
WEXITSTATUS	O
(	O
status	O
)	O
==	O
0	int
)	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"process %lu exited successfully"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
pid	int
)	O
)	O
;	O
else	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	O
,	O
_	O
(	O
"process %lu failed with status %d"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
pid	int
,	O
WEXITSTATUS	O
(	O
status	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
WIFSIGNALED	O
(	O
status	O
)	O
)	O
{	O
int	O
prio	int
;	O
if	O
(	O
sigismember	(*(struct(array(long))),int)->(int)
(	O
mask	struct(int,int)
,	O
WTERMSIG	O
(	O
status	O
)	O
)	O
)	O
prio	int
=	O
LOG_DEBUG	O
;	O
else	O
prio	int
=	O
LOG_ERR	O
;	O
diag	(int,*(char))->(void)
(	O
prio	int
,	O
_	O
(	O
"process %lu terminated on signal %d"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
pid	int
,	O
WTERMSIG	O
(	O
status	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
WIFSTOPPED	O
(	O
status	O
)	O
)	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	O
,	O
_	O
(	O
"process %lu stopped on signal %d"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
pid	int
,	O
WSTOPSIG	O
(	O
status	O
)	O
)	O
;	O
else	O
if	O
(	O
WCOREDUMP	O
(	O
status	O
)	O
)	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	O
,	O
_	O
(	O
"process %lu dumped core"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
pid	int
)	O
;	O
else	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	O
,	O
_	O
(	O
"process %lu terminated with unrecognized status"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
pid	int
)	O
;	O
}	O
void	O
process_cleanup	(int)->(void)
(	O
int	O
expect_term	int
)	O
{	O
pid_t	int
pid	int
;	O
int	O
status	O
;	O
while	O
(	O
(	O
pid	int
=	O
waitpid	(int,*(int),int)->(int)
(	O
-	O
1	int
,	O
&	O
status	O
,	O
WNOHANG	O
)	O
)	O
>	O
0	int
)	O
{	O
sigset_t	struct(array(long))
set	O
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
set	O
)	O
;	O
if	O
(	O
pid	int
==	O
self_test_pid	int
)	O
{	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
set	O
,	O
SIGHUP	O
)	O
;	O
print_status	O
(	O
pid	int
,	O
status	O
,	O
&	O
set	O
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
status	O
)	O
)	O
exit_code	int
=	O
WEXITSTATUS	O
(	O
status	O
)	O
;	O
else	O
if	O
(	O
WIFSIGNALED	O
(	O
status	O
)	O
)	O
{	O
if	O
(	O
WTERMSIG	O
(	O
status	O
)	O
==	O
SIGHUP	O
)	O
exit_code	int
=	O
0	int
;	O
else	O
exit_code	int
=	O
2	int
;	O
}	O
else	O
exit_code	int
=	O
2	int
;	O
stop	int
=	O
1	int
;	O
}	O
else	O
{	O
struct	O
process	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
process_lookup	(int)->(*(struct))
(	O
pid	int
)	O
;	O
if	O
(	O
expect_term	int
)	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
set	O
,	O
SIGTERM	O
)	O
;	O
if	O
(	O
!	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
{	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
set	O
,	O
SIGTERM	O
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
set	O
,	O
SIGKILL	O
)	O
;	O
}	O
print_status	O
(	O
pid	int
,	O
status	O
,	O
&	O
set	O
)	O
;	O
if	O
(	O
!	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
continue	O
;	O
if	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
type	enum(int,int,int)
==	O
PROC_HANDLER	O
)	O
{	O
if	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
redir	array(*(struct(*(struct(*(struct`),*(struct`),int,int,int,long)),*(struct(*(struct`),*(struct`),int,int,int,long)),int,int,int,long)))
[	O
REDIR_OUT	O
]	O
)	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
redir	array(*(struct(*(struct(*(struct`),*(struct`),int,int,int,long)),*(struct(*(struct`),*(struct`),int,int,int,long)),int,int,int,long)))
[	O
REDIR_OUT	O
]	O
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
master	*(struct(*(struct(*(struct`),*(struct`),int,int,int,long)),*(struct(*(struct`),*(struct`),int,int,int,long)),int,int,int,long))
=	O
NULL	O
;	O
if	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
redir	array(*(struct(*(struct(*(struct`),*(struct`),int,int,int,long)),*(struct(*(struct`),*(struct`),int,int,int,long)),int,int,int,long)))
[	O
REDIR_ERR	O
]	O
)	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
redir	array(*(struct(*(struct(*(struct`),*(struct`),int,int,int,long)),*(struct(*(struct`),*(struct`),int,int,int,long)),int,int,int,long)))
[	O
REDIR_ERR	O
]	O
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
master	*(struct(*(struct(*(struct`),*(struct`),int,int,int,long)),*(struct(*(struct`),*(struct`),int,int,int,long)),int,int,int,long))
=	O
NULL	O
;	O
}	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
pid	int
=	O
0	int
;	O
proc_unlink	O
(	O
&	O
proc_list	O
,	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
;	O
proc_push	O
(	O
&	O
proc_avail	O
,	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
;	O
}	O
}	O
}	O
void	O
process_timeouts	()->(void)
(	O
)	O
{	O
struct	O
process	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
time_t	long
now	O
=	O
time	(*(long))->(long)
(	O
NULL	O
)	O
;	O
time_t	long
alarm_time	O
=	O
0	int
,	O
x	O
;	O
debug	O
(	O
2	int
,	O
(	O
_	O
(	O
"begin scanning process list"	*(char)
)	O
)	O
)	O
;	O
for	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
proc_list	O
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
{	O
x	O
=	O
now	O
-	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
start	O
;	O
if	O
(	O
x	O
>=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
timeout	int
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	O
,	O
_	O
(	O
"process %lu timed out"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
pid	int
)	O
;	O
kill	(int,int)->(int)
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
pid	int
,	O
SIGKILL	O
)	O
;	O
}	O
else	O
if	O
(	O
alarm_time	O
==	O
0	int
||	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
timeout	int
-	O
x	O
<	O
alarm_time	O
)	O
alarm_time	O
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
timeout	int
-	O
x	O
;	O
}	O
if	O
(	O
alarm_time	O
)	O
{	O
debug	O
(	O
2	int
,	O
(	O
_	O
(	O
"scheduling alarm in %lu seconds"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
alarm_time	O
)	O
)	O
;	O
alarm	(int)->(int)
(	O
alarm_time	O
)	O
;	O
}	O
debug	O
(	O
2	int
,	O
(	O
"end scanning process list"	*(char)
)	O
)	O
;	O
}	O
int	O
switchpriv	O
(	O
struct	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
*	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
)	O
{	O
if	O
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
uid	int
==	O
0	int
||	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
uid	int
==	O
getuid	()->(int)
(	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
setgroups	(long,*(int))->(int)
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
gidc	long
,	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
gidv	*(int)
)	O
<	O
0	int
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	O
,	O
"setgroups: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
setregid	(int,int)->(int)
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
gidv	*(int)
[	O
0	int
]	O
,	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
gidv	*(int)
[	O
0	int
]	O
)	O
<	O
0	int
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	O
,	O
"setregid(%lu,%lu): %s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
gidv	*(int)
[	O
0	int
]	O
,	O
(	O
unsigned	O
long	O
)	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
gidv	*(int)
[	O
0	int
]	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
setreuid	(int,int)->(int)
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
uid	int
,	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
uid	int
)	O
<	O
0	int
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	O
,	O
"setreuid(%lu,%lu): %s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
uid	int
,	O
(	O
unsigned	O
long	O
)	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
uid	int
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
typedef	O
fd_set	struct(array(long))
*	O
bigfd_set	O
;	O
static	O
void	O
close_fds	O
(	O
bigfd_set	O
fdset	O
)	O
{	O
int	O
i	O
;	O
for	O
(	O
i	O
=	O
dup	(int)->(int)
(	O
0	int
)	O
;	O
i	O
>=	O
0	int
;	O
i	O
--	O
)	O
{	O
if	O
(	O
fdset	O
&&	O
BIGFD_ISSET	O
(	O
i	O
,	O
fdset	O
)	O
)	O
continue	O
;	O
close	(int)->(int)
(	O
i	O
)	O
;	O
}	O
}	O
static	O
void	O
redir_exit	O
(	O
int	O
sig	O
)	O
{	O
_exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
int	O
open_redirector	O
(	O
const	O
char	O
*	O
tag	*(char)
,	O
int	O
prio	int
,	O
struct	O
process	O
*	O
*	O
return_proc	O
)	O
{	O
int	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
[	O
2	int
]	O
;	O
FILE	struct
*	O
fp	*(struct)
;	O
char	O
buf	O
[	O
512	int
]	O
;	O
pid_t	int
pid	int
;	O
bigfd_set	O
fdset	O
;	O
if	O
(	O
pipe	(array(int))->(int)
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	O
,	O
_	O
(	O
"cannot start redirector for %s, pipe failed: %s"	*(char)
)	O
,	O
tag	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
pid	int
=	O
fork	()->(int)
(	O
)	O
)	O
{	O
case	O
0	int
:	O
fdset	O
=	O
BIGFD_SET_ALLOC	O
(	O
)	O
;	O
BIGFD_SET	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
[	O
0	int
]	O
,	O
fdset	O
)	O
;	O
if	O
(	O
facility	int
<=	O
0	int
)	O
BIGFD_SET	O
(	O
2	int
,	O
fdset	O
)	O
;	O
close_fds	O
(	O
fdset	O
)	O
;	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
signal_setup	(*((int)->(void)))->(void)
(	O
redir_exit	O
)	O
;	O
fp	*(struct)
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
[	O
0	int
]	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct)
==	O
NULL	O
)	O
_exit	(int)->(void)
(	O
1	int
)	O
;	O
if	O
(	O
facility	int
>	O
0	int
)	O
openlog	(*(char),int,int)->(void)
(	O
tag	*(char)
,	O
LOG_PID	O
,	O
facility	int
)	O
;	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	O
,	O
sizeof	O
(	O
buf	O
)	O
,	O
fp	*(struct)
)	O
>	O
0	int
)	O
{	O
int	O
len	long
=	O
strlen	(*(char))->(long)
(	O
buf	O
)	O
;	O
if	O
(	O
len	long
&&	O
buf	O
[	O
len	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
buf	O
[	O
len	long
-	O
1	int
]	O
=	O
0	int
;	O
diag	(int,*(char))->(void)
(	O
prio	int
,	O
"%s"	*(char)
,	O
buf	O
)	O
;	O
}	O
_exit	(int)->(void)
(	O
0	int
)	O
;	O
case	O
-	O
1	int
:	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	O
,	O
_	O
(	O
"cannot run redirector `%s': fork failed: %s"	*(char)
)	O
,	O
tag	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
default	O
:	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"redirector for %s started, pid=%lu"	*(char)
)	O
,	O
tag	*(char)
,	O
(	O
unsigned	O
long	O
)	O
pid	int
)	O
)	O
;	O
close	(int)->(int)
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
[	O
0	int
]	O
)	O
;	O
*	O
return_proc	O
=	O
register_process	O
(	O
PROC_REDIR	O
,	O
pid	int
,	O
time	(*(long))->(long)
(	O
NULL	O
)	O
,	O
0	int
)	O
;	O
return	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
[	O
1	int
]	O
;	O
}	O
}	O
static	O
void	O
runcmd	O
(	O
const	O
char	O
*	O
cmd	*(char)
,	O
char	O
*	O
*	O
envhint	O
,	O
event_mask	struct(int,int)
*	O
event	*(struct(int,int))
,	O
const	O
char	O
*	O
file	*(char)
,	O
int	O
shell	O
)	O
{	O
char	O
*	O
kve	*(*(char))
[	O
13	int
]	O
;	O
char	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
,	O
*	O
q	O
;	O
char	O
buf	O
[	O
1024	int
]	O
;	O
int	O
i	O
=	O
0	int
,	O
j	O
;	O
char	O
*	O
*	O
argv	*(*(char))
;	O
char	O
*	O
xargv	O
[	O
4	int
]	O
;	O
struct	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
kve	*(*(char))
[	O
i	O
++	O
]	O
=	O
"file"	*(char)
;	O
kve	*(*(char))
[	O
i	O
++	O
]	O
=	O
(	O
char	O
*	O
)	O
file	*(char)
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	O
,	O
sizeof	O
buf	O
,	O
"%d"	*(char)
,	O
event	*(struct(int,int))
->	O
sys_mask	int
)	O
;	O
kve	*(*(char))
[	O
i	O
++	O
]	O
=	O
"sysev_code"	*(char)
;	O
kve	*(*(char))
[	O
i	O
++	O
]	O
=	O
estrdup	(*(char))->(*(char))
(	O
buf	O
)	O
;	O
if	O
(	O
self_test_pid	int
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	O
,	O
sizeof	O
buf	O
,	O
"%lu"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
self_test_pid	int
)	O
;	O
kve	*(*(char))
[	O
i	O
++	O
]	O
=	O
"self_test_pid"	*(char)
;	O
kve	*(*(char))
[	O
i	O
++	O
]	O
=	O
estrdup	(*(char))->(*(char))
(	O
buf	O
)	O
;	O
}	O
q	O
=	O
buf	O
;	O
for	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
trans_tokfirst	(*(struct(*(char),int)),int,*(int))->(*(char))
(	O
sysev_transtab	array(struct(*(char),int))
,	O
event	*(struct(int,int))
->	O
sys_mask	int
,	O
&	O
j	O
)	O
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
trans_toknext	(*(struct(*(char),int)),int,*(int))->(*(char))
(	O
sysev_transtab	array(struct(*(char),int))
,	O
event	*(struct(int,int))
->	O
sys_mask	int
,	O
&	O
j	O
)	O
)	O
{	O
if	O
(	O
q	O
>	O
buf	O
)	O
*	O
q	O
++	O
=	O
' '	O
;	O
while	O
(	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
*	O
q	O
++	O
=	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
++	O
;	O
}	O
*	O
q	O
=	O
0	int
;	O
if	O
(	O
q	O
>	O
buf	O
)	O
{	O
kve	*(*(char))
[	O
i	O
++	O
]	O
=	O
"sysev_name"	*(char)
;	O
kve	*(*(char))
[	O
i	O
++	O
]	O
=	O
estrdup	(*(char))->(*(char))
(	O
buf	O
)	O
;	O
}	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
trans_toktostr	(*(struct(*(char),int)),int)->(*(char))
(	O
genev_transtab	array(struct(*(char),int))
,	O
event	*(struct(int,int))
->	O
gen_mask	int
)	O
;	O
if	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	O
,	O
sizeof	O
buf	O
,	O
"%d"	*(char)
,	O
event	*(struct(int,int))
->	O
gen_mask	int
)	O
;	O
kve	*(*(char))
[	O
i	O
++	O
]	O
=	O
"genev_code"	*(char)
;	O
kve	*(*(char))
[	O
i	O
++	O
]	O
=	O
estrdup	(*(char))->(*(char))
(	O
buf	O
)	O
;	O
kve	*(*(char))
[	O
i	O
++	O
]	O
=	O
"genev_name"	*(char)
;	O
kve	*(*(char))
[	O
i	O
++	O
]	O
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
}	O
kve	*(*(char))
[	O
i	O
++	O
]	O
=	O
0	int
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_env	*(*(char))
=	O
(	O
const	O
char	O
*	O
*	O
)	O
kve	*(*(char))
;	O
if	O
(	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
cmd	*(char)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
WRDSF_NOCMD	O
|	O
WRDSF_QUOTE	O
|	O
WRDSF_SQUEEZE_DELIMS	O
|	O
WRDSF_CESCAPES	O
|	O
WRDSF_ENV	O
|	O
WRDSF_ENV_KV	O
|	O
(	O
shell	O
?	O
WRDSF_NOSPLIT	O
:	O
0	int
)	O
)	O
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	O
,	O
"wordsplit: %s"	*(char)
,	O
wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
;	O
_exit	(int)->(void)
(	O
127	int
)	O
;	O
}	O
if	O
(	O
shell	O
)	O
{	O
xargv	O
[	O
0	int
]	O
=	O
"/bin/sh"	*(char)
;	O
xargv	O
[	O
1	int
]	O
=	O
"-c"	*(char)
;	O
xargv	O
[	O
2	int
]	O
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
;	O
xargv	O
[	O
3	int
]	O
=	O
NULL	O
;	O
argv	*(*(char))
=	O
xargv	O
;	O
}	O
else	O
argv	*(*(char))
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
;	O
execve	(*(char),array(*(char)),array(*(char)))->(int)
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
argv	*(*(char))
,	O
environ_setup	(*(*(char)),*(*(char)))->(*(*(char)))
(	O
envhint	O
,	O
kve	*(*(char))
)	O
)	O
;	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	O
,	O
"execve: %s \"%s\": %s"	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
,	O
cmd	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
_exit	(int)->(void)
(	O
127	int
)	O
;	O
}	O
static	O
int	O
prog_handler_run	O
(	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wp	*(struct)
,	O
event_mask	struct(int,int)
*	O
event	*(struct(int,int))
,	O
const	O
char	O
*	O
dirname	*(char)
,	O
const	O
char	O
*	O
file	*(char)
,	O
void	O
*	O
data	*(void)
)	O
{	O
pid_t	int
pid	int
;	O
int	O
redir_fd	O
[	O
2	int
]	O
=	O
{	O
-	O
1	int
,	O
-	O
1	int
}	O
;	O
struct	O
process	O
*	O
redir_proc	O
[	O
2	int
]	O
=	O
{	O
NULL	O
,	O
NULL	O
}	O
;	O
struct	O
process	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
struct	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
*	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
=	O
data	*(void)
;	O
if	O
(	O
!	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
command	*(char)
)	O
return	O
0	int
;	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"starting %s, dir=%s, file=%s"	*(char)
)	O
,	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
command	*(char)
,	O
dirname	*(char)
,	O
file	*(char)
)	O
)	O
;	O
if	O
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
flags	int
&	O
HF_STDERR	O
)	O
redir_fd	O
[	O
REDIR_ERR	O
]	O
=	O
open_redirector	O
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
command	*(char)
,	O
LOG_ERR	O
,	O
&	O
redir_proc	O
[	O
REDIR_ERR	O
]	O
)	O
;	O
if	O
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
flags	int
&	O
HF_STDOUT	O
)	O
redir_fd	O
[	O
REDIR_OUT	O
]	O
=	O
open_redirector	O
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
command	*(char)
,	O
LOG_INFO	O
,	O
&	O
redir_proc	O
[	O
REDIR_OUT	O
]	O
)	O
;	O
pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
pid	int
==	O
-	O
1	int
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	O
,	O
"fork: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
close	(int)->(int)
(	O
redir_fd	O
[	O
REDIR_OUT	O
]	O
)	O
;	O
close	(int)->(int)
(	O
redir_fd	O
[	O
REDIR_ERR	O
]	O
)	O
;	O
if	O
(	O
redir_proc	O
[	O
REDIR_OUT	O
]	O
)	O
kill	(int,int)->(int)
(	O
redir_proc	O
[	O
REDIR_OUT	O
]	O
->	O
pid	int
,	O
SIGKILL	O
)	O
;	O
if	O
(	O
redir_proc	O
[	O
REDIR_ERR	O
]	O
)	O
kill	(int,int)->(int)
(	O
redir_proc	O
[	O
REDIR_ERR	O
]	O
->	O
pid	int
,	O
SIGKILL	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
bigfd_set	O
fdset	O
=	O
BIGFD_SET_ALLOC	O
(	O
)	O
;	O
if	O
(	O
switchpriv	O
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
)	O
)	O
_exit	(int)->(void)
(	O
127	int
)	O
;	O
if	O
(	O
chdir	(*(char))->(int)
(	O
dirname	*(char)
)	O
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	O
,	O
_	O
(	O
"cannot change to %s: %s"	*(char)
)	O
,	O
dirname	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
_exit	(int)->(void)
(	O
127	int
)	O
;	O
}	O
if	O
(	O
redir_fd	O
[	O
REDIR_OUT	O
]	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
redir_fd	O
[	O
REDIR_OUT	O
]	O
!=	O
1	int
&&	O
dup2	(int,int)->(int)
(	O
redir_fd	O
[	O
REDIR_OUT	O
]	O
,	O
1	int
)	O
==	O
-	O
1	int
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	O
,	O
"dup2: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
_exit	(int)->(void)
(	O
127	int
)	O
;	O
}	O
BIGFD_SET	O
(	O
1	int
,	O
fdset	O
)	O
;	O
}	O
if	O
(	O
redir_fd	O
[	O
REDIR_ERR	O
]	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
redir_fd	O
[	O
REDIR_ERR	O
]	O
!=	O
2	int
&&	O
dup2	(int,int)->(int)
(	O
redir_fd	O
[	O
REDIR_ERR	O
]	O
,	O
2	int
)	O
==	O
-	O
1	int
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_ERR	O
,	O
"dup2: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
_exit	(int)->(void)
(	O
127	int
)	O
;	O
}	O
BIGFD_SET	O
(	O
2	int
,	O
fdset	O
)	O
;	O
}	O
close_fds	O
(	O
fdset	O
)	O
;	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
signal_setup	(*((int)->(void)))->(void)
(	O
SIG_DFL	O
)	O
;	O
runcmd	O
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
command	*(char)
,	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
env	*(*(char))
,	O
event	*(struct(int,int))
,	O
file	*(char)
,	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
flags	int
&	O
HF_SHELL	O
)	O
;	O
}	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"%s running; dir=%s, file=%s, pid=%lu"	*(char)
)	O
,	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
command	*(char)
,	O
dirname	*(char)
,	O
file	*(char)
,	O
(	O
unsigned	O
long	O
)	O
pid	int
)	O
)	O
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
register_process	O
(	O
PROC_HANDLER	O
,	O
pid	int
,	O
time	(*(long))->(long)
(	O
NULL	O
)	O
,	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
timeout	int
)	O
;	O
if	O
(	O
redir_proc	O
[	O
REDIR_OUT	O
]	O
)	O
{	O
redir_proc	O
[	O
REDIR_OUT	O
]	O
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
master	*(struct(*(struct(*(struct`),*(struct`),int,int,int,long)),*(struct(*(struct`),*(struct`),int,int,int,long)),int,int,int,long))
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
redir_proc	O
[	O
REDIR_OUT	O
]	O
->	O
timeout	int
=	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
timeout	int
;	O
}	O
if	O
(	O
redir_proc	O
[	O
REDIR_ERR	O
]	O
)	O
{	O
redir_proc	O
[	O
REDIR_ERR	O
]	O
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
master	*(struct(*(struct(*(struct`),*(struct`),int,int,int,long)),*(struct(*(struct`),*(struct`),int,int,int,long)),int,int,int,long))
=	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
redir_proc	O
[	O
REDIR_ERR	O
]	O
->	O
timeout	int
=	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
timeout	int
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
redir	array(*(struct(*(struct(*(struct`),*(struct`),int,int,int,long)),*(struct(*(struct`),*(struct`),int,int,int,long)),int,int,int,long)))
,	O
redir_proc	O
,	O
sizeof	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
redir	array(*(struct(*(struct(*(struct`),*(struct`),int,int,int,long)),*(struct(*(struct`),*(struct`),int,int,int,long)),int,int,int,long)))
)	O
)	O
;	O
close	(int)->(int)
(	O
redir_fd	O
[	O
REDIR_OUT	O
]	O
)	O
;	O
close	(int)->(int)
(	O
redir_fd	O
[	O
REDIR_ERR	O
]	O
)	O
;	O
if	O
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
flags	int
&	O
HF_NOWAIT	O
)	O
{	O
return	O
0	int
;	O
}	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"waiting for %s (%lu) to terminate"	*(char)
)	O
,	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
command	*(char)
,	O
(	O
unsigned	O
long	O
)	O
pid	int
)	O
)	O
;	O
while	O
(	O
time	(*(long))->(long)
(	O
NULL	O
)	O
-	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
start	O
<	O
2	int
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
timeout	int
)	O
{	O
sleep	(int)->(int)
(	O
1	int
)	O
;	O
process_cleanup	(int)->(void)
(	O
1	int
)	O
;	O
if	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
pid	int
==	O
0	int
)	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
envfree	O
(	O
char	O
*	O
*	O
env	*(*(char))
)	O
{	O
int	O
i	O
;	O
if	O
(	O
!	O
env	*(*(char))
)	O
return	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
env	*(*(char))
[	O
i	O
]	O
;	O
i	O
++	O
)	O
free	(*(void))->(void)
(	O
env	*(*(char))
[	O
i	O
]	O
)	O
;	O
free	(*(void))->(void)
(	O
env	*(*(char))
)	O
;	O
}	O
void	O
prog_handler_free	(*(struct(int,*(char),int,*(int),long,int,*(*(char)))))->(void)
(	O
struct	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
*	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
)	O
{	O
free	(*(void))->(void)
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
command	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
gidv	*(int)
)	O
;	O
envfree	O
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
env	*(*(char))
)	O
;	O
}	O
static	O
void	O
prog_handler_free_data	O
(	O
void	O
*	O
ptr	*(void)
)	O
{	O
prog_handler_free	(*(struct(int,*(char),int,*(int),long,int,*(*(char)))))->(void)
(	O
(	O
struct	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
*	O
)	O
ptr	*(void)
)	O
;	O
}	O
struct	O
handler	struct(long,struct(int,int),*(struct),*((*(struct),*(struct(int,int)),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))
*	O
prog_handler_alloc	(struct(int,int),*(struct),*(struct(int,*(char),int,*(int),long,int,*(*(char)))))->(*(struct(long,struct(int,int),*(struct),*((*`,*`,*`,*`,*`)->(int)),*((*`)->(void)),*(void))))
(	O
event_mask	struct(int,int)
ev_mask	struct(int,int)
,	O
filpatlist_t	*(struct)
fpat	*(struct)
,	O
struct	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
{	O
struct	O
handler	struct(long,struct(int,int),*(struct),*((*(struct),*(struct(int,int)),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))
*	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
=	O
handler_alloc	(struct(int,int))->(*(struct(long,struct(int,int),*(struct),*((*`,*`,*`,*`,*`)->(int)),*((*`)->(void)),*(void))))
(	O
ev_mask	struct(int,int)
)	O
;	O
struct	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
*	O
mem	O
;	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
fnames	*(struct)
=	O
fpat	*(struct)
;	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
run	*((*(struct),*(struct(int,int)),*(char),*(char),*(void))->(int))
=	O
prog_handler_run	O
;	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
free	(*(void))->(void)
=	O
prog_handler_free_data	O
;	O
mem	O
=	O
emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
mem	O
)	O
)	O
;	O
*	O
mem	O
=	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
data	*(void)
=	O
mem	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
,	O
0	int
,	O
sizeof	O
(	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
)	O
;	O
return	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
;	O
}	O
size_t	long
prog_handler_envrealloc	(*(struct(int,*(char),int,*(int),long,int,*(*(char)))),long)->(long)
(	O
struct	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
*	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
,	O
size_t	long
count	long
)	O
{	O
size_t	long
i	O
;	O
if	O
(	O
!	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
env	*(*(char))
)	O
{	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
env	*(*(char))
=	O
ecalloc	(long,long)->(*(void))
(	O
count	long
+	O
1	int
,	O
sizeof	O
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
env	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
i	O
=	O
0	int
;	O
}	O
else	O
{	O
for	O
(	O
i	O
=	O
0	int
;	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
env	*(*(char))
[	O
i	O
]	O
;	O
i	O
++	O
)	O
;	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
env	*(*(char))
=	O
erealloc	(*(void),long)->(*(void))
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
env	*(*(char))
,	O
(	O
i	O
+	O
count	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
env	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
env	*(*(char))
+	O
i	O
,	O
0	int
,	O
(	O
count	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
->	O
env	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
}	O
return	O
i	O
;	O
}	O
