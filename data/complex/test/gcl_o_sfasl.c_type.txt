struct	O
node	O
*	O
find_sym	()->(*(struct))
(	O
)	O
;	O
int	O
node_compare	()->(int)
(	O
)	O
;	O
void	O
*	O
malloc	()->(*(void))
(	O
)	O
;	O
void	O
*	O
bsearch	()->(*(void))
(	O
)	O
;	O
struct	O
reloc	O
relocation_info	struct
;	O
int	O
debug	int
;	O
struct	O
sfasl_info	struct(*(struct),*(char),*(char),*(char),*(char),int,*(char))
{	O
struct	O
syment	O
*	O
s_symbol_table	*(struct)
;	O
char	O
*	O
s_start_address	*(char)
;	O
char	O
*	O
s_start_data	*(char)
;	O
char	O
*	O
s_start_bss	*(char)
;	O
char	O
*	O
s_my_string_table	*(char)
;	O
int	O
s_extra_bss	int
;	O
char	O
*	O
s_the_start	*(char)
;	O
}	O
;	O
struct	O
sfasl_info	struct(*(struct),*(char),*(char),*(char),*(char),int,*(char))
*	O
sfaslp	*(struct(*(struct),*(char),*(char),*(char),*(char),int,*(char)))
;	O
int	O
get_extra_bss	(*(struct),int,int,*(int),int)->(int)
(	O
struct	O
syment	O
*	O
sym_table	*(struct)
,	O
int	O
length	int
,	O
int	O
start	int
,	O
int	O
*	O
ptr	*(int)
,	O
int	O
bsssize	int
)	O
;	O
void	O
relocate_symbols	(int)->(void)
(	O
unsigned	O
int	O
length	int
)	O
;	O
void	O
set_symbol_address	(*(struct),*(char))->(void)
(	O
struct	O
syment	O
*	O
sym	*(struct)
,	O
char	O
*	O
string	*(char)
)	O
;	O
int	O
fasload	O
(	O
faslfile	O
)	O
object	O
faslfile	O
;	O
{	O
long	O
fasl_vector_start	O
;	O
struct	O
filehdr	O
fileheader	O
;	O
struct	O
sfasl_info	struct(*(struct),*(char),*(char),*(char),*(char),int,*(char))
sfasl_info_buf	O
;	O
int	O
textsize	O
,	O
datasize	O
,	O
bsssize	int
,	O
nsyms	O
;	O
object	O
memory	O
,	O
data	O
;	O
FILE	O
*	O
fp	O
;	O
char	O
filename	O
[	O
MAXPATHLEN	int
]	O
;	O
int	O
i	O
;	O
int	O
init_address	O
=	O
0	int
;	O
object	O
*	O
old_vs_base	O
=	O
vs_base	O
;	O
object	O
*	O
old_vs_top	O
=	O
vs_top	O
;	O
sfaslp	*(struct(*(struct),*(char),*(char),*(char),*(char),int,*(char)))
=	O
&	O
sfasl_info_buf	O
;	O
extra_bss	O
=	O
0	int
;	O
coerce_to_filename	O
(	O
faslfile	O
,	O
filename	O
)	O
;	O
faslfile	O
=	O
open_stream	O
(	O
faslfile	O
,	O
smm_input	O
,	O
Cnil	O
,	O
sKerror	O
)	O
;	O
vs_push	O
(	O
faslfile	O
)	O
;	O
fp	O
=	O
faslfile	O
->	O
sm	O
.	O
sm_fp	O
;	O
HEADER_SEEK	O
(	O
fp	O
)	O
;	O
if	O
(	O
!	O
fread	O
(	O
(	O
char	O
*	O
)	O
&	O
fileheader	O
,	O
sizeof	O
(	O
struct	O
filehdr	O
)	O
,	O
1	int
,	O
fp	O
)	O
)	O
FEerror	()->(int)
(	O
"Could not get the header"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
nsyms	O
=	O
NSYMS	O
(	O
fileheader	O
)	O
;	O
symbol_table	O
=	O
(	O
struct	O
syment	O
*	O
)	O
OUR_ALLOCA	O
(	O
sizeof	O
(	O
struct	O
syment	O
)	O
*	O
(	O
unsigned	O
int	O
)	O
nsyms	O
)	O
;	O
fseek	O
(	O
fp	O
,	O
(	O
int	O
)	O
(	O
N_SYMOFF	O
(	O
fileheader	O
)	O
)	O
,	O
0	int
)	O
;	O
{	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nsyms	O
;	O
i	O
++	O
)	O
{	O
fread	O
(	O
(	O
char	O
*	O
)	O
&	O
symbol_table	O
[	O
i	O
]	O
,	O
SYMESZ	O
,	O
1	int
,	O
fp	O
)	O
;	O
dprintf	O
(	O
symbol	O
table	O
%	O
d	O
,	O
i	O
)	O
;	O
if	O
(	O
debug	int
)	O
describe_sym	O
(	O
i	O
)	O
;	O
dprintf	O
(	O
at	O
%	O
d	O
,	O
&	O
symbol_table	O
[	O
i	O
]	O
)	O
;	O
}	O
}	O
{	O
int	O
ii	O
=	O
0	int
;	O
if	O
(	O
!	O
fread	O
(	O
(	O
char	O
*	O
)	O
&	O
ii	O
,	O
sizeof	O
(	O
int	O
)	O
,	O
1	int
,	O
fp	O
)	O
)	O
{	O
FEerror	()->(int)
(	O
"The string table of this file did not have any length"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
}	O
fseek	O
(	O
fp	O
,	O
-	O
4	int
,	O
1	int
)	O
;	O
my_string_table	O
=	O
OUR_ALLOCA	O
(	O
(	O
unsigned	O
int	O
)	O
ii	O
)	O
;	O
dprintf	O
(	O
string	*(char)
table	O
leng	O
=	O
%	O
d	O
,	O
ii	O
)	O
;	O
if	O
(	O
ii	O
!=	O
fread	O
(	O
my_string_table	O
,	O
1	int
,	O
ii	O
,	O
fp	O
)	O
)	O
FEerror	()->(int)
(	O
"Could not read whole string table"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
}	O
while	O
(	O
(	O
i	O
=	O
getc	O
(	O
fp	O
)	O
)	O
==	O
0	int
)	O
;	O
ungetc	O
(	O
i	O
,	O
fp	O
)	O
;	O
fasl_vector_start	O
=	O
ftell	O
(	O
fp	O
)	O
;	O
if	O
(	O
!	O
(	O
(	O
c_table	O
.	O
ptable	O
)	O
&&	O
*	O
(	O
c_table	O
.	O
ptable	O
)	O
)	O
)	O
build_symbol_table	O
(	O
)	O
;	O
extra_bss	O
=	O
get_extra_bss	(*(struct),int,int,*(int),int)->(int)
(	O
symbol_table	O
,	O
nsyms	O
,	O
datasize	O
+	O
textsize	O
+	O
bsssize	int
,	O
&	O
init_address	O
,	O
bsssize	int
)	O
;	O
{	O
BEGIN_NO_INTERRUPT	O
;	O
memory	O
=	O
alloc_object	O
(	O
t_cfdata	O
)	O
;	O
memory	O
->	O
cfd	O
.	O
cfd_self	O
=	O
0	int
;	O
memory	O
->	O
cfd	O
.	O
cfd_start	O
=	O
0	int
;	O
memory	O
->	O
cfd	O
.	O
cfd_size	O
=	O
datasize	O
+	O
textsize	O
+	O
bsssize	int
+	O
extra_bss	O
;	O
vs_push	O
(	O
memory	O
)	O
;	O
the_start	O
=	O
start_address	O
=	O
memory	O
->	O
cfd	O
.	O
cfd_start	O
=	O
alloc_contblock	O
(	O
memory	O
->	O
cfd	O
.	O
cfd_size	O
)	O
;	O
sfaslp	*(struct(*(struct),*(char),*(char),*(char),*(char),int,*(char)))
->	O
s_start_data	*(char)
=	O
start_address	O
+	O
textsize	O
;	O
sfaslp	*(struct(*(struct),*(char),*(char),*(char),*(char),int,*(char)))
->	O
s_start_bss	*(char)
=	O
start_address	O
+	O
textsize	O
+	O
datasize	O
;	O
END_NO_INTERRUPT	O
;	O
}	O
dprintf	O
(	O
code	O
size	O
%	O
d	O
,	O
datasize	O
+	O
textsize	O
+	O
bsssize	int
+	O
extra_bss	O
)	O
;	O
if	O
(	O
fseek	O
(	O
fp	O
,	O
N_TXTOFF	O
(	O
fileheader	O
)	O
,	O
0	int
)	O
<	O
0	int
)	O
FEerror	()->(int)
(	O
"file seek error"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
SAFE_FREAD	O
(	O
the_start	O
,	O
textsize	O
+	O
datasize	O
,	O
1	int
,	O
fp	O
)	O
;	O
dprintf	O
(	O
read	O
into	O
memory	O
text	O
+	O
data	O
%	O
d	O
bytes	O
,	O
textsize	O
+	O
datasize	O
)	O
;	O
dprintf	O
(	O
the_start	O
%	O
x	O
,	O
the_start	O
)	O
;	O
relocate_symbols	(int)->(void)
(	O
NSYMS	O
(	O
fileheader	O
)	O
)	O
;	O
dprintf	O
(	O
END	O
OF	O
RELOCATION	O
\	O
n	O
,	O
0	int
)	O
;	O
dprintf	O
(	O
invoking	O
init	O
function	O
at	O
%	O
x	O
,	O
start_address	O
)	O
dprintf	O
(	O
textsize	O
is	O
%	O
x	O
,	O
textsize	O
)	O
;	O
dprintf	O
(	O
datasize	O
is	O
%	O
x	O
,	O
datasize	O
)	O
;	O
fseek	O
(	O
fp	O
,	O
fasl_vector_start	O
,	O
0	int
)	O
;	O
if	O
(	O
feof	O
(	O
fp	O
)	O
)	O
{	O
data	O
=	O
0	int
;	O
}	O
else	O
{	O
data	O
=	O
read_fasl_vector	O
(	O
faslfile	O
)	O
;	O
vs_push	O
(	O
data	O
)	O
;	O
}	O
close_stream	O
(	O
faslfile	O
)	O
;	O
ALLOCA_FREE	O
(	O
my_string_table	O
)	O
;	O
ALLOCA_FREE	O
(	O
symbol_table	O
)	O
;	O
call_init	O
(	O
init_address	O
,	O
memory	O
,	O
data	O
,	O
0	int
)	O
;	O
vs_base	O
=	O
old_vs_base	O
;	O
vs_top	O
=	O
old_vs_top	O
;	O
if	O
(	O
symbol_value	O
(	O
sLAload_verboseA	O
)	O
!=	O
Cnil	O
)	O
printf	O
(	O
"start address -T %x "	*(char)
,	O
memory	O
->	O
cfd	O
.	O
cfd_start	O
)	O
;	O
return	O
(	O
memory	O
->	O
cfd	O
.	O
cfd_size	O
)	O
;	O
{	O
FILE	O
*	O
out	O
;	O
out	O
=	O
fopen	O
(	O
"/tmp/sfasltest"	*(char)
,	O
"w"	*(char)
)	O
;	O
fwrite	O
(	O
(	O
char	O
*	O
)	O
&	O
fileheader	O
,	O
sizeof	O
(	O
struct	O
filehdr	O
)	O
,	O
1	int
,	O
out	O
)	O
;	O
fwrite	O
(	O
start_address	O
,	O
sizeof	O
(	O
char	O
)	O
,	O
datasize	O
+	O
textsize	O
,	O
out	O
)	O
;	O
fclose	O
(	O
out	O
)	O
;	O
}	O
printf	O
(	O
"\n(start %x)\n"	*(char)
,	O
start_address	O
)	O
;	O
}	O
int	O
get_extra_bss	(*(struct),int,int,*(int),int)->(int)
(	O
sym_table	*(struct)
,	O
length	int
,	O
start	int
,	O
ptr	*(int)
,	O
bsssize	int
)	O
int	O
length	int
,	O
bsssize	int
;	O
struct	O
syment	O
*	O
sym_table	*(struct)
;	O
int	O
*	O
ptr	*(int)
;	O
{	O
int	O
result	int
=	O
start	int
;	O
struct	O
syment	O
*	O
end	*(struct)
,	O
*	O
sym	*(struct)
;	O
end	*(struct)
=	O
sym_table	*(struct)
+	O
length	int
;	O
for	O
(	O
sym	*(struct)
=	O
sym_table	*(struct)
;	O
sym	*(struct)
<	O
end	*(struct)
;	O
sym	*(struct)
++	O
)	O
{	O
{	O
int	O
val	int
=	O
sym	*(struct)
->	O
n_value	int
;	O
if	O
(	O
val	int
&&	O
c_table	O
.	O
ptable	O
&&	O
(	O
0	int
==	O
find_sym	()->(*(struct))
(	O
sym	*(struct)
,	O
0	int
)	O
)	O
)	O
{	O
sym	*(struct)
->	O
n_value	int
=	O
result	int
;	O
result	int
+=	O
val	int
;	O
}	O
}	O
sym	*(struct)
+=	O
NUM_AUX	()->(int)
(	O
sym	*(struct)
)	O
;	O
}	O
return	O
(	O
result	int
-	O
start	int
)	O
;	O
}	O
void	O
relocate_symbols	(int)->(void)
(	O
length	int
)	O
unsigned	O
int	O
length	int
;	O
{	O
struct	O
syment	O
*	O
end	*(struct)
,	O
*	O
sym	*(struct)
;	O
unsigned	O
int	O
typ	int
;	O
char	O
*	O
str	*(char)
;	O
char	O
tem	char
[	O
SYMNMLEN	O
+	O
1	int
]	O
;	O
tem	char
[	O
SYMNMLEN	O
]	O
=	O
0	int
;	O
int	O
n_value	int
=	O
(	O
int	O
)	O
start_address	O
;	O
end	*(struct)
=	O
symbol_table	O
+	O
length	int
;	O
for	O
(	O
sym	*(struct)
=	O
symbol_table	O
;	O
sym	*(struct)
<	O
end	*(struct)
;	O
sym	*(struct)
++	O
)	O
{	O
typ	int
=	O
NTYPE	()->(int)
(	O
sym	*(struct)
)	O
;	O
switch	O
(	O
typ	int
)	O
{	O
str	*(char)
=	O
SYM_NAME	()->(int)
(	O
sym	*(struct)
)	O
;	O
dprintf	O
(	O
for	O
sym	*(struct)
%	O
s	O
,	O
str	*(char)
)	O
dprintf	O
(	O
new	O
value	O
will	O
be	O
start	int
%	O
x	O
,	O
start_address	O
)	O
;	O
sym	*(struct)
->	O
n_value	int
=	O
n_value	int
;	O
break	O
;	O
case	O
N_UNDEF	O
:	O
str	*(char)
=	O
SYM_NAME	()->(int)
(	O
sym	*(struct)
)	O
;	O
dprintf	O
(	O
undef	O
symbol	O
%	O
s	O
,	O
str	*(char)
)	O
;	O
dprintf	O
(	O
symbol	O
diff	O
%	O
d	O
,	O
sym	*(struct)
-	O
symbol_table	O
)	O
;	O
describe_sym	O
(	O
sym	*(struct)
-	O
symbol_table	O
)	O
;	O
set_symbol_address	(*(struct),*(char))->(void)
(	O
sym	*(struct)
,	O
str	*(char)
)	O
;	O
describe_sym	O
(	O
sym	*(struct)
-	O
symbol_table	O
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
sym	*(struct)
+=	O
NUM_AUX	()->(int)
(	O
sym	*(struct)
)	O
;	O
}	O
}	O
struct	O
node	O
*	O
find_sym	()->(*(struct))
(	O
sym	*(struct)
,	O
name	*(char)
)	O
struct	O
syment	O
*	O
sym	*(struct)
;	O
char	O
*	O
name	*(char)
;	O
{	O
char	O
tem	char
[	O
SYMNMLEN	O
+	O
1	int
]	O
;	O
tem	char
[	O
SYMNMLEN	O
]	O
=	O
0	int
;	O
if	O
(	O
name	*(char)
==	O
0	int
)	O
name	*(char)
=	O
SYM_NAME	()->(int)
(	O
sym	*(struct)
)	O
;	O
return	O
find_sym_ptable	()->(int)
(	O
name	*(char)
)	O
;	O
}	O
void	O
set_symbol_address	(*(struct),*(char))->(void)
(	O
sym	*(struct)
,	O
string	*(char)
)	O
struct	O
syment	O
*	O
sym	*(struct)
;	O
char	O
*	O
string	*(char)
;	O
{	O
struct	O
node	O
*	O
answ	*(struct)
;	O
if	O
(	O
c_table	O
.	O
ptable	O
)	O
{	O
dprintf	O
(	O
string	*(char)
%	O
s	O
,	O
string	*(char)
)	O
;	O
answ	*(struct)
=	O
find_sym	()->(*(struct))
(	O
sym	*(struct)
,	O
string	*(char)
)	O
;	O
dprintf	O
(	O
answ	*(struct)
%	O
d	O
,	O
(	O
answ	*(struct)
?	O
answ	*(struct)
->	O
address	O
:	O
-	O
1	int
)	O
)	O
;	O
if	O
(	O
answ	*(struct)
)	O
{	O
}	O
else	O
{	O
fprintf	()->(int)
(	O
stdout	O
,	O
"undefined %s symbol"	*(char)
,	O
string	*(char)
)	O
;	O
fflush	()->(int)
(	O
stdout	O
)	O
;	O
}	O
}	O
else	O
{	O
FEerror	()->(int)
(	O
"symbol table not loaded"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
}	O
}	O
