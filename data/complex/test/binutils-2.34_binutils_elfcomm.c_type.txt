void	O
error	O
(	O
const	O
char	O
*	O
message	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
args	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
va_start	O
(	O
args	O
,	O
message	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: Error: "	*(char)
)	O
,	O
program_name	O
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
message	*(char)
,	O
args	O
)	O
;	O
va_end	O
(	O
args	O
)	O
;	O
}	O
void	O
warn	O
(	O
const	O
char	O
*	O
message	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
args	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
va_start	O
(	O
args	O
,	O
message	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: Warning: "	*(char)
)	O
,	O
program_name	O
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
message	*(char)
,	O
args	O
)	O
;	O
va_end	O
(	O
args	O
)	O
;	O
}	O
void	O
(	O
*	O
byte_put	O
)	O
(	O
unsigned	O
char	O
*	O
,	O
elf_vma	O
,	O
int	O
)	O
;	O
void	O
byte_put_little_endian	O
(	O
unsigned	O
char	O
*	O
field	O
,	O
elf_vma	O
value	long
,	O
int	O
size	long
)	O
{	O
switch	O
(	O
size	long
)	O
{	O
case	O
8	int
:	O
field	O
[	O
7	int
]	O
=	O
(	O
(	O
(	O
value	long
>>	O
24	int
)	O
>>	O
24	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
field	O
[	O
6	int
]	O
=	O
(	O
(	O
value	long
>>	O
24	int
)	O
>>	O
24	int
)	O
&	O
0xff	int
;	O
field	O
[	O
5	int
]	O
=	O
(	O
(	O
value	long
>>	O
24	int
)	O
>>	O
16	int
)	O
&	O
0xff	int
;	O
field	O
[	O
4	int
]	O
=	O
(	O
(	O
value	long
>>	O
24	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
case	O
4	int
:	O
field	O
[	O
3	int
]	O
=	O
(	O
value	long
>>	O
24	int
)	O
&	O
0xff	int
;	O
case	O
3	int
:	O
field	O
[	O
2	int
]	O
=	O
(	O
value	long
>>	O
16	int
)	O
&	O
0xff	int
;	O
case	O
2	int
:	O
field	O
[	O
1	int
]	O
=	O
(	O
value	long
>>	O
8	int
)	O
&	O
0xff	int
;	O
case	O
1	int
:	O
field	O
[	O
0	int
]	O
=	O
value	long
&	O
0xff	int
;	O
break	O
;	O
default	O
:	O
error	O
(	O
_	O
(	O
"Unhandled data length: %d\n"	*(char)
)	O
,	O
size	long
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
void	O
byte_put_big_endian	O
(	O
unsigned	O
char	O
*	O
field	O
,	O
elf_vma	O
value	long
,	O
int	O
size	long
)	O
{	O
switch	O
(	O
size	long
)	O
{	O
case	O
8	int
:	O
field	O
[	O
7	int
]	O
=	O
value	long
&	O
0xff	int
;	O
field	O
[	O
6	int
]	O
=	O
(	O
value	long
>>	O
8	int
)	O
&	O
0xff	int
;	O
field	O
[	O
5	int
]	O
=	O
(	O
value	long
>>	O
16	int
)	O
&	O
0xff	int
;	O
field	O
[	O
4	int
]	O
=	O
(	O
value	long
>>	O
24	int
)	O
&	O
0xff	int
;	O
value	long
>>=	O
16	int
;	O
value	long
>>=	O
16	int
;	O
case	O
4	int
:	O
field	O
[	O
3	int
]	O
=	O
value	long
&	O
0xff	int
;	O
value	long
>>=	O
8	int
;	O
case	O
3	int
:	O
field	O
[	O
2	int
]	O
=	O
value	long
&	O
0xff	int
;	O
value	long
>>=	O
8	int
;	O
case	O
2	int
:	O
field	O
[	O
1	int
]	O
=	O
value	long
&	O
0xff	int
;	O
value	long
>>=	O
8	int
;	O
case	O
1	int
:	O
field	O
[	O
0	int
]	O
=	O
value	long
&	O
0xff	int
;	O
break	O
;	O
default	O
:	O
error	O
(	O
_	O
(	O
"Unhandled data length: %d\n"	*(char)
)	O
,	O
size	long
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
elf_vma	O
(	O
*	O
byte_get	O
)	O
(	O
const	O
unsigned	O
char	O
*	O
,	O
int	O
)	O
;	O
elf_vma	O
byte_get_little_endian	O
(	O
const	O
unsigned	O
char	O
*	O
field	O
,	O
int	O
size	long
)	O
{	O
switch	O
(	O
size	long
)	O
{	O
case	O
1	int
:	O
return	O
*	O
field	O
;	O
case	O
2	int
:	O
return	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
;	O
case	O
3	int
:	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
;	O
case	O
4	int
:	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
case	O
5	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
4	int
]	O
)	O
)	O
<<	O
32	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
4	int
)	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
case	O
6	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
4	int
]	O
)	O
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
5	int
]	O
)	O
)	O
<<	O
40	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
4	int
)	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
case	O
7	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
4	int
]	O
)	O
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
5	int
]	O
)	O
)	O
<<	O
40	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
6	int
]	O
)	O
)	O
<<	O
48	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
4	int
)	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
case	O
8	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
4	int
]	O
)	O
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
5	int
]	O
)	O
)	O
<<	O
40	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
6	int
]	O
)	O
)	O
<<	O
48	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
7	int
]	O
)	O
)	O
<<	O
56	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
4	int
)	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
default	O
:	O
error	O
(	O
_	O
(	O
"Unhandled data length: %d\n"	*(char)
)	O
,	O
size	long
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
elf_vma	O
byte_get_big_endian	O
(	O
const	O
unsigned	O
char	O
*	O
field	O
,	O
int	O
size	long
)	O
{	O
switch	O
(	O
size	long
)	O
{	O
case	O
1	int
:	O
return	O
*	O
field	O
;	O
case	O
2	int
:	O
return	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
int	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
<<	O
8	int
)	O
;	O
case	O
3	int
:	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
<<	O
16	int
)	O
;	O
case	O
4	int
:	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
case	O
5	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
4	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
<<	O
32	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
4	int
)	O
{	O
field	O
+=	O
1	int
;	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
}	O
case	O
6	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
5	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
4	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
<<	O
40	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
4	int
)	O
{	O
field	O
+=	O
2	int
;	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
}	O
case	O
7	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
6	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
5	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
4	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
40	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
<<	O
48	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
4	int
)	O
{	O
field	O
+=	O
3	int
;	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
}	O
case	O
8	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
7	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
6	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
5	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
4	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
40	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
48	int
)	O
|	O
(	O
(	O
(	O
elf_vma	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
<<	O
56	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	O
)	O
==	O
4	int
)	O
{	O
field	O
+=	O
4	int
;	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
3	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
2	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
1	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	O
[	O
0	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
}	O
default	O
:	O
error	O
(	O
_	O
(	O
"Unhandled data length: %d\n"	*(char)
)	O
,	O
size	long
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
elf_vma	O
byte_get_signed	O
(	O
const	O
unsigned	O
char	O
*	O
field	O
,	O
int	O
size	long
)	O
{	O
elf_vma	O
x	O
=	O
byte_get	O
(	O
field	O
,	O
size	long
)	O
;	O
switch	O
(	O
size	long
)	O
{	O
case	O
1	int
:	O
return	O
(	O
x	O
^	O
0x80	int
)	O
-	O
0x80	int
;	O
case	O
2	int
:	O
return	O
(	O
x	O
^	O
0x8000	int
)	O
-	O
0x8000	int
;	O
case	O
3	int
:	O
return	O
(	O
x	O
^	O
0x800000	int
)	O
-	O
0x800000	int
;	O
case	O
4	int
:	O
return	O
(	O
x	O
^	O
0x80000000	int
)	O
-	O
0x80000000	int
;	O
case	O
5	int
:	O
case	O
6	int
:	O
case	O
7	int
:	O
case	O
8	int
:	O
return	O
x	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
void	O
byte_get_64	O
(	O
const	O
unsigned	O
char	O
*	O
field	O
,	O
elf_vma	O
*	O
high	O
,	O
elf_vma	O
*	O
low	O
)	O
{	O
if	O
(	O
byte_get	O
==	O
byte_get_big_endian	O
)	O
{	O
*	O
high	O
=	O
byte_get_big_endian	O
(	O
field	O
,	O
4	int
)	O
;	O
*	O
low	O
=	O
byte_get_big_endian	O
(	O
field	O
+	O
4	int
,	O
4	int
)	O
;	O
}	O
else	O
{	O
*	O
high	O
=	O
byte_get_little_endian	O
(	O
field	O
+	O
4	int
,	O
4	int
)	O
;	O
*	O
low	O
=	O
byte_get_little_endian	O
(	O
field	O
,	O
4	int
)	O
;	O
}	O
return	O
;	O
}	O
char	O
*	O
adjust_relative_path	O
(	O
const	O
char	O
*	O
file_name	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
unsigned	O
long	O
name_len	O
)	O
{	O
char	O
*	O
member_file_name	O
;	O
const	O
char	O
*	O
base_name	O
=	O
lbasename	(*(char))->(*(char))
(	O
file_name	O
)	O
;	O
size_t	long
amt	O
;	O
if	O
(	O
IS_ABSOLUTE_PATH	O
(	O
name	*(char)
)	O
||	O
base_name	O
==	O
file_name	O
)	O
{	O
amt	O
=	O
name_len	O
+	O
1	int
;	O
if	O
(	O
amt	O
==	O
0	int
)	O
return	O
NULL	O
;	O
member_file_name	O
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
amt	O
)	O
;	O
if	O
(	O
member_file_name	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory\n"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
member_file_name	O
,	O
name	*(char)
,	O
name_len	O
)	O
;	O
member_file_name	O
[	O
name_len	O
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
size_t	long
prefix_len	O
=	O
base_name	O
-	O
file_name	O
;	O
amt	O
=	O
prefix_len	O
+	O
name_len	O
+	O
1	int
;	O
if	O
(	O
amt	O
<	O
prefix_len	O
||	O
amt	O
<	O
name_len	O
)	O
{	O
error	O
(	O
_	O
(	O
"Abnormal length of thin archive member name: %lx\n"	*(char)
)	O
,	O
name_len	O
)	O
;	O
return	O
NULL	O
;	O
}	O
member_file_name	O
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
amt	O
)	O
;	O
if	O
(	O
member_file_name	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory\n"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
member_file_name	O
,	O
file_name	O
,	O
prefix_len	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
member_file_name	O
+	O
prefix_len	O
,	O
name	*(char)
,	O
name_len	O
)	O
;	O
member_file_name	O
[	O
prefix_len	O
+	O
name_len	O
]	O
=	O
'\0'	O
;	O
}	O
return	O
member_file_name	O
;	O
}	O
static	O
bfd_boolean	int
process_archive_index_and_symbols	O
(	O
struct	O
archive_info	O
*	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
unsigned	O
int	O
sizeof_ar_index	O
,	O
bfd_boolean	int
read_symbols	O
)	O
{	O
size_t	long
got	O
;	O
unsigned	O
long	O
size	long
;	O
char	O
fmag_save	O
;	O
fmag_save	O
=	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_fmag	O
[	O
0	int
]	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_fmag	O
[	O
0	int
]	O
=	O
0	int
;	O
size	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_size	O
,	O
NULL	O
,	O
10	int
)	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_fmag	O
[	O
0	int
]	O
=	O
fmag_save	O
;	O
if	O
(	O
(	O
signed	O
long	O
)	O
size	long
<	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: invalid archive header size: %ld\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
,	O
size	long
)	O
;	O
return	O
FALSE	O
;	O
}	O
size	long
=	O
size	long
+	O
(	O
size	long
&	O
1	int
)	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
next_arhdr_offset	O
+=	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
+	O
size	long
;	O
if	O
(	O
!	O
read_symbols	O
)	O
{	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file	*(void)
,	O
size	long
,	O
SEEK_CUR	O
)	O
!=	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: failed to skip archive symbol table\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
else	O
{	O
unsigned	O
long	O
i	*(struct)
;	O
unsigned	O
char	O
integer_buffer	O
[	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_num	O
]	O
;	O
unsigned	O
char	O
*	O
index_buffer	O
;	O
assert	O
(	O
sizeof_ar_index	O
<=	O
sizeof	O
integer_buffer	O
)	O
;	O
if	O
(	O
size	long
<	O
sizeof_ar_index	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: the archive index is empty\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
got	O
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
integer_buffer	O
,	O
1	int
,	O
sizeof_ar_index	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file	*(void)
)	O
;	O
if	O
(	O
got	O
!=	O
sizeof_ar_index	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: failed to read archive index\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_num	O
=	O
byte_get_big_endian	O
(	O
integer_buffer	O
,	O
sizeof_ar_index	O
)	O
;	O
size	long
-=	O
sizeof_ar_index	O
;	O
if	O
(	O
size	long
<	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_num	O
*	O
sizeof_ar_index	O
||	O
size	long
<	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_num	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: the archive index is supposed to have 0x%lx entries of %d bytes, but the size is only 0x%lx\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
,	O
(	O
long	O
)	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_num	O
,	O
sizeof_ar_index	O
,	O
size	long
)	O
;	O
return	O
FALSE	O
;	O
}	O
index_buffer	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_num	O
*	O
sizeof_ar_index	O
)	O
;	O
if	O
(	O
index_buffer	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory whilst trying to read archive symbol index\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
got	O
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
index_buffer	O
,	O
sizeof_ar_index	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_num	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file	*(void)
)	O
;	O
if	O
(	O
got	O
!=	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_num	O
)	O
{	O
free	(*(void))->(void)
(	O
index_buffer	O
)	O
;	O
error	O
(	O
_	O
(	O
"%s: failed to read archive index\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
size	long
-=	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_num	O
*	O
sizeof_ar_index	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_array	O
=	O
(	O
elf_vma	O
*	O
)	O
malloc	(long)->(*(void))
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_num	O
*	O
sizeof	O
(	O
*	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_array	O
)	O
)	O
;	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_array	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
index_buffer	O
)	O
;	O
error	O
(	O
_	O
(	O
"Out of memory whilst trying to convert the archive symbol index\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_num	O
;	O
i	*(struct)
++	O
)	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_array	O
[	O
i	*(struct)
]	O
=	O
byte_get_big_endian	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
index_buffer	O
+	O
(	O
i	*(struct)
*	O
sizeof_ar_index	O
)	O
)	O
,	O
sizeof_ar_index	O
)	O
;	O
free	(*(void))->(void)
(	O
index_buffer	O
)	O
;	O
if	O
(	O
size	long
<	O
1	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: the archive has an index but no symbols\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
sym_table	O
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
size	long
)	O
;	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
sym_table	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory whilst trying to read archive index symbol table\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
sym_size	O
=	O
size	long
;	O
got	O
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
sym_table	O
,	O
1	int
,	O
size	long
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file	*(void)
)	O
;	O
if	O
(	O
got	O
!=	O
size	long
)	O
{	O
error	O
(	O
_	O
(	O
"%s: failed to read archive index symbol table\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
got	O
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
,	O
1	int
,	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file	*(void)
)	O
;	O
if	O
(	O
got	O
!=	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
&&	O
got	O
!=	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: failed to read archive header following archive index\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
int	O
setup_archive	O
(	O
struct	O
archive_info	O
*	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
const	O
char	O
*	O
file_name	O
,	O
FILE	struct
*	O
file	*(void)
,	O
bfd_boolean	int
is_thin_archive	int
,	O
bfd_boolean	int
read_symbols	O
)	O
{	O
size_t	long
got	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
=	O
strdup	(*(char))->(*(char))
(	O
file_name	O
)	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file	*(void)
=	O
file	*(void)
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_num	O
=	O
0	int
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_array	O
=	O
NULL	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
sym_table	O
=	O
NULL	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
sym_size	O
=	O
0	int
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
=	O
NULL	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
=	O
0	int
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
nested_member_origin	O
=	O
0	int
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
is_thin_archive	int
=	O
is_thin_archive	int
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
uses_64bit_indices	O
=	O
FALSE	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
next_arhdr_offset	O
=	O
SARMAG	O
;	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
file	*(void)
,	O
SARMAG	O
,	O
SEEK_SET	O
)	O
!=	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: failed to seek to first archive header\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
return	O
1	int
;	O
}	O
got	O
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
,	O
1	int
,	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
,	O
file	*(void)
)	O
;	O
if	O
(	O
got	O
!=	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
)	O
{	O
if	O
(	O
got	O
==	O
0	int
)	O
return	O
0	int
;	O
error	O
(	O
_	O
(	O
"%s: failed to read archive header\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
const_strneq	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_name	O
,	O
"/               "	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
process_archive_index_and_symbols	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
4	int
,	O
read_symbols	O
)	O
)	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
const_strneq	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_name	O
,	O
"/SYM64/         "	*(char)
)	O
)	O
{	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
uses_64bit_indices	O
=	O
TRUE	int
;	O
if	O
(	O
!	O
process_archive_index_and_symbols	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
8	int
,	O
read_symbols	O
)	O
)	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
read_symbols	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"%s has no archive index\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
if	O
(	O
const_strneq	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_name	O
,	O
"//              "	*(char)
)	O
)	O
{	O
char	O
fmag_save	O
=	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_fmag	O
[	O
0	int
]	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_fmag	O
[	O
0	int
]	O
=	O
0	int
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_size	O
,	O
NULL	O
,	O
10	int
)	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_fmag	O
[	O
0	int
]	O
=	O
fmag_save	O
;	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
<	O
8	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: long name table is too small, (size = %ld)\n"	*(char)
)	O
,	O
file_name	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
signed	O
long	O
)	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
<	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: long name table is too big, (size = 0x%lx)\n"	*(char)
)	O
,	O
file_name	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
)	O
;	O
return	O
1	int
;	O
}	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
next_arhdr_offset	O
+=	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
+	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
+	O
1	int
)	O
;	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory reading long symbol names in archive\n"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
,	O
1	int
,	O
file	*(void)
)	O
!=	O
1	int
)	O
{	O
free	(*(void))->(void)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
)	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
=	O
NULL	O
;	O
error	O
(	O
_	O
(	O
"%s: failed to read long symbol name string table\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
&	O
1	int
)	O
!=	O
0	int
)	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(void)
)	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
[	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
]	O
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
setup_nested_archive	O
(	O
struct	O
archive_info	O
*	O
nested_arch	O
,	O
const	O
char	O
*	O
member_file_name	O
)	O
{	O
FILE	struct
*	O
member_file	O
;	O
if	O
(	O
nested_arch	O
->	O
file_name	O
!=	O
NULL	O
&&	O
streq	O
(	O
nested_arch	O
->	O
file_name	O
,	O
member_file_name	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
nested_arch	O
->	O
file	*(void)
!=	O
NULL	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
nested_arch	O
->	O
file	*(void)
)	O
;	O
release_archive	O
(	O
nested_arch	O
)	O
;	O
member_file	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
member_file_name	O
,	O
"rb"	*(char)
)	O
;	O
if	O
(	O
member_file	O
==	O
NULL	O
)	O
return	O
1	int
;	O
return	O
setup_archive	O
(	O
nested_arch	O
,	O
member_file_name	O
,	O
member_file	O
,	O
FALSE	O
,	O
FALSE	O
)	O
;	O
}	O
void	O
release_archive	O
(	O
struct	O
archive_info	O
*	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
)	O
;	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_array	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
index_array	O
)	O
;	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
sym_table	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
sym_table	O
)	O
;	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
)	O
;	O
}	O
char	O
*	O
get_archive_member_name	O
(	O
struct	O
archive_info	O
*	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
struct	O
archive_info	O
*	O
nested_arch	O
)	O
{	O
unsigned	O
long	O
j	O
,	O
k	O
;	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_name	O
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
char	O
*	O
endp	O
;	O
char	O
*	O
member_file_name	O
;	O
char	O
*	O
member_name	O
;	O
char	O
fmag_save	O
;	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
==	O
NULL	O
||	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
==	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"Archive member uses long names, but no longname table found\n"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
nested_member_origin	O
=	O
0	int
;	O
fmag_save	O
=	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_fmag	O
[	O
0	int
]	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_fmag	O
[	O
0	int
]	O
=	O
0	int
;	O
k	O
=	O
j	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_name	O
+	O
1	int
,	O
&	O
endp	O
,	O
10	int
)	O
;	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
is_thin_archive	int
&&	O
endp	O
!=	O
NULL	O
&&	O
*	O
endp	O
==	O
':'	O
)	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
nested_member_origin	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
endp	O
+	O
1	int
,	O
NULL	O
,	O
10	int
)	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_fmag	O
[	O
0	int
]	O
=	O
fmag_save	O
;	O
if	O
(	O
j	O
>	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
)	O
{	O
error	O
(	O
_	O
(	O
"Found long name index (%ld) beyond end of long name table\n"	*(char)
)	O
,	O
j	O
)	O
;	O
return	O
NULL	O
;	O
}	O
while	O
(	O
(	O
j	O
<	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
)	O
&&	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
[	O
j	O
]	O
!=	O
'\n'	O
)	O
&&	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
[	O
j	O
]	O
!=	O
'\0'	O
)	O
)	O
j	O
++	O
;	O
if	O
(	O
j	O
>	O
0	int
&&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
[	O
j	O
-	O
1	int
]	O
==	O
'/'	O
)	O
j	O
--	O
;	O
if	O
(	O
j	O
>	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
)	O
j	O
=	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames_size	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
[	O
j	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
is_thin_archive	int
||	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
nested_member_origin	O
==	O
0	int
)	O
return	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
+	O
k	O
;	O
if	O
(	O
k	O
>=	O
j	O
)	O
{	O
error	O
(	O
_	O
(	O
"Invalid Thin archive member name\n"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
member_file_name	O
=	O
adjust_relative_path	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
+	O
k	O
,	O
j	O
-	O
k	O
)	O
;	O
if	O
(	O
member_file_name	O
!=	O
NULL	O
&&	O
setup_nested_archive	O
(	O
nested_arch	O
,	O
member_file_name	O
)	O
==	O
0	int
)	O
{	O
member_name	O
=	O
get_archive_member_name_at	O
(	O
nested_arch	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
nested_member_origin	O
,	O
NULL	O
)	O
;	O
if	O
(	O
member_name	O
!=	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
member_file_name	O
)	O
;	O
return	O
member_name	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
member_file_name	O
)	O
;	O
return	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
longnames	O
+	O
k	O
;	O
}	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
sizeof	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_name	O
)	O
;	O
j	O
++	O
)	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_name	O
[	O
j	O
]	O
==	O
'/'	O
)	O
{	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_name	O
[	O
j	O
]	O
=	O
'\0'	O
;	O
return	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_name	O
;	O
}	O
{	O
char	O
*	O
name	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_name	O
)	O
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
name	*(char)
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_name	O
,	O
sizeof	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_name	O
)	O
)	O
;	O
name	*(char)
[	O
sizeof	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_name	O
)	O
]	O
=	O
'\0'	O
;	O
return	O
name	*(char)
;	O
}	O
}	O
char	O
*	O
get_archive_member_name_at	O
(	O
struct	O
archive_info	O
*	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
unsigned	O
long	O
offset	long
,	O
struct	O
archive_info	O
*	O
nested_arch	O
)	O
{	O
size_t	long
got	O
;	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file	*(void)
,	O
offset	long
,	O
SEEK_SET	O
)	O
!=	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: failed to seek to next file name\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
)	O
;	O
return	O
NULL	O
;	O
}	O
got	O
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
,	O
1	int
,	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file	*(void)
)	O
;	O
if	O
(	O
got	O
!=	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: failed to read archive header\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
arhdr	O
.	O
ar_fmag	O
,	O
ARFMAG	O
,	O
2	int
)	O
!=	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: did not find a valid archive header\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
get_archive_member_name	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
nested_arch	O
)	O
;	O
}	O
char	O
*	O
make_qualified_name	O
(	O
struct	O
archive_info	O
*	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
struct	O
archive_info	O
*	O
nested_arch	O
,	O
const	O
char	O
*	O
member_name	O
)	O
{	O
const	O
char	O
*	O
error_name	O
=	O
_	O
(	O
"<corrupt>"	*(char)
)	O
;	O
size_t	long
len	long
;	O
char	O
*	O
name	*(char)
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
)	O
+	O
strlen	(*(char))->(long)
(	O
member_name	O
)	O
+	O
3	int
;	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
is_thin_archive	int
&&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
nested_member_origin	O
!=	O
0	int
)	O
{	O
if	O
(	O
nested_arch	O
->	O
file_name	O
)	O
len	long
+=	O
strlen	(*(char))->(long)
(	O
nested_arch	O
->	O
file_name	O
)	O
+	O
2	int
;	O
else	O
len	long
+=	O
strlen	(*(char))->(long)
(	O
error_name	O
)	O
+	O
2	int
;	O
}	O
name	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
len	long
)	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory\n"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
is_thin_archive	int
&&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
nested_member_origin	O
!=	O
0	int
)	O
{	O
if	O
(	O
nested_arch	O
->	O
file_name	O
)	O
snprintf	(*(char),long,*(char))->(int)
(	O
name	*(char)
,	O
len	long
,	O
"%s[%s(%s)]"	*(char)
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
,	O
nested_arch	O
->	O
file_name	O
,	O
member_name	O
)	O
;	O
else	O
snprintf	(*(char),long,*(char))->(int)
(	O
name	*(char)
,	O
len	long
,	O
"%s[%s(%s)]"	*(char)
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
,	O
error_name	O
,	O
member_name	O
)	O
;	O
}	O
else	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
is_thin_archive	int
)	O
snprintf	(*(char),long,*(char))->(int)
(	O
name	*(char)
,	O
len	long
,	O
"%s[%s]"	*(char)
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
,	O
member_name	O
)	O
;	O
else	O
snprintf	(*(char),long,*(char))->(int)
(	O
name	*(char)
,	O
len	long
,	O
"%s(%s)"	*(char)
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
->	O
file_name	O
,	O
member_name	O
)	O
;	O
return	O
name	*(char)
;	O
}	O
