jmp_buf	array(struct(array(long),int,struct(array(long))))
jmp_state	array(struct(array(long),int,struct(array(long))))
;	O
static	O
int	O
mutex	int
=	O
0	int
;	O
static	O
int	O
window_lines_	int
=	O
22	int
;	O
static	O
int	O
window_columns_	int
=	O
72	int
;	O
static	O
char	O
sighup_pending	char
=	O
0	int
;	O
static	O
char	O
sigint_pending	char
=	O
0	int
;	O
static	O
void	O
sighup_handler	(int)->(void)
(	O
int	O
signum	int
)	O
{	O
signum	int
=	O
0	int
;	O
if	O
(	O
mutex	int
)	O
sighup_pending	char
=	O
1	int
;	O
else	O
{	O
char	O
hb	array(char)
[	O
]	O
=	O
"ed.hup"	*(char)
;	O
sighup_pending	char
=	O
0	int
;	O
if	O
(	O
last_addr	()->(int)
(	O
)	O
&&	O
modified	()->(char)
(	O
)	O
&&	O
write_file	(*(char),*(char),int,int)->(int)
(	O
hb	array(char)
,	O
"w"	*(char)
,	O
1	int
,	O
last_addr	()->(int)
(	O
)	O
)	O
<	O
0	int
)	O
{	O
char	O
*	O
s	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
;	O
int	O
n	int
=	O
(	O
s	*(char)
?	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
:	O
0	int
)	O
;	O
int	O
m	char
=	O
(	O
(	O
!	O
n	int
||	O
*	O
(	O
s	*(char)
+	O
n	int
-	O
1	int
)	O
!=	O
'/'	O
)	O
?	O
1	int
:	O
0	int
)	O
;	O
char	O
*	O
hup	*(char)
=	O
(	O
(	O
n	int
+	O
m	char
+	O
(	O
int	O
)	O
sizeof	O
(	O
hb	array(char)
)	O
<	O
path_max	(*(char))->(int)
(	O
0	int
)	O
)	O
?	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
n	int
+	O
m	char
+	O
sizeof	O
(	O
hb	array(char)
)	O
)	O
:	O
0	int
)	O
;	O
if	O
(	O
n	int
&&	O
hup	*(char)
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
hup	*(char)
,	O
s	*(char)
,	O
n	int
)	O
;	O
if	O
(	O
m	char
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
hup	*(char)
+	O
n	int
,	O
"/"	*(char)
,	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
hup	*(char)
+	O
n	int
+	O
m	char
,	O
hb	array(char)
,	O
sizeof	O
(	O
hb	array(char)
)	O
)	O
;	O
if	O
(	O
write_file	(*(char),*(char),int,int)->(int)
(	O
hup	*(char)
,	O
"w"	*(char)
,	O
1	int
,	O
last_addr	()->(int)
(	O
)	O
)	O
>=	O
0	int
)	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
sigint_handler	(int)->(void)
(	O
int	O
signum	int
)	O
{	O
if	O
(	O
mutex	int
)	O
sigint_pending	char
=	O
1	int
;	O
else	O
{	O
sigset_t	struct(array(long))
set	struct(array(long))
;	O
sigint_pending	char
=	O
0	int
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
set	struct(array(long))
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
set	struct(array(long))
,	O
signum	int
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_UNBLOCK	int
,	O
&	O
set	struct(array(long))
,	O
0	int
)	O
;	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
jmp_state	array(struct(array(long),int,struct(array(long))))
,	O
-	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
sigwinch_handler	(int)->(void)
(	O
int	O
signum	int
)	O
{	O
struct	O
winsize	struct(short,short,short,short)
ws	struct(short,short,short,short)
;	O
if	O
(	O
ioctl	(int,long)->(int)
(	O
0	int
,	O
TIOCGWINSZ	int
,	O
(	O
char	O
*	O
)	O
&	O
ws	struct(short,short,short,short)
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
ws	struct(short,short,short,short)
.	O
ws_row	short
>	O
2	int
&&	O
ws	struct(short,short,short,short)
.	O
ws_row	short
<	O
600	int
)	O
window_lines_	int
=	O
ws	struct(short,short,short,short)
.	O
ws_row	short
-	O
2	int
;	O
if	O
(	O
ws	struct(short,short,short,short)
.	O
ws_col	short
>	O
8	int
&&	O
ws	struct(short,short,short,short)
.	O
ws_col	short
<	O
1800	int
)	O
window_columns_	int
=	O
ws	struct(short,short,short,short)
.	O
ws_col	short
-	O
8	int
;	O
}	O
signum	int
=	O
0	int
;	O
}	O
static	O
int	O
set_signal	(int,*((int)->(void)))->(int)
(	O
int	O
signum	int
,	O
void	O
(	O
*	O
handler	*((int)->(void))
)	O
(	O
int	O
)	O
)	O
{	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
new_action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
new_action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
=	O
handler	*((int)->(void))
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
new_action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
new_action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
SA_RESTART	int
;	O
return	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
signum	int
,	O
&	O
new_action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
0	int
)	O
;	O
}	O
void	O
enable_interrupts	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
--	O
mutex	int
<=	O
0	int
)	O
{	O
mutex	int
=	O
0	int
;	O
if	O
(	O
sighup_pending	char
)	O
sighup_handler	(int)->(void)
(	O
SIGHUP	int
)	O
;	O
if	O
(	O
sigint_pending	char
)	O
sigint_handler	(int)->(void)
(	O
SIGINT	int
)	O
;	O
}	O
}	O
void	O
disable_interrupts	()->(void)
(	O
void	O
)	O
{	O
++	O
mutex	int
;	O
}	O
void	O
set_signals	()->(void)
(	O
void	O
)	O
{	O
sigwinch_handler	(int)->(void)
(	O
SIGWINCH	int
)	O
;	O
if	O
(	O
isatty	(int)->(int)
(	O
0	int
)	O
)	O
set_signal	(int,*((int)->(void)))->(int)
(	O
SIGWINCH	int
,	O
sigwinch_handler	(int)->(void)
)	O
;	O
set_signal	(int,*((int)->(void)))->(int)
(	O
SIGHUP	int
,	O
sighup_handler	(int)->(void)
)	O
;	O
set_signal	(int,*((int)->(void)))->(int)
(	O
SIGQUIT	int
,	O
SIG_IGN	O
)	O
;	O
set_signal	(int,*((int)->(void)))->(int)
(	O
SIGINT	int
,	O
sigint_handler	(int)->(void)
)	O
;	O
}	O
void	O
set_window_lines	(int)->(void)
(	O
const	O
int	O
lines	int
)	O
{	O
window_lines_	int
=	O
lines	int
;	O
}	O
int	O
window_columns	()->(int)
(	O
void	O
)	O
{	O
return	O
window_columns_	int
;	O
}	O
int	O
window_lines	()->(int)
(	O
void	O
)	O
{	O
return	O
window_lines_	int
;	O
}	O
char	O
parse_int	(*(int),*(char),*(*(char)))->(char)
(	O
int	O
*	O
i	*(int)
,	O
const	O
char	O
*	O
str	*(char)
,	O
const	O
char	O
*	O
*	O
tail	*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int))
)	O
{	O
char	O
*	O
tmp	*(char)
;	O
errno	O
=	O
0	int
;	O
*	O
i	*(int)
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
str	*(char)
,	O
&	O
tmp	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
tail	*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int))
)	O
*	O
tail	*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int))
=	O
tmp	*(char)
;	O
if	O
(	O
tmp	*(char)
==	O
str	*(char)
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Bad numerical result"	*(char)
)	O
;	O
*	O
i	*(int)
=	O
0	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
errno	O
==	O
ERANGE	int
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Numerical result out of range"	*(char)
)	O
;	O
*	O
i	*(int)
=	O
0	int
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
char	O
resize_buffer	(*(*(char)),*(int),int)->(char)
(	O
char	O
*	O
*	O
buf	*(*(char))
,	O
int	O
*	O
size	*(int)
,	O
int	O
min_size	int
)	O
{	O
if	O
(	O
*	O
size	*(int)
<	O
min_size	int
)	O
{	O
const	O
int	O
new_size	int
=	O
(	O
min_size	int
<	O
512	int
?	O
512	int
:	O
(	O
min_size	int
/	O
512	int
)	O
*	O
1024	int
)	O
;	O
void	O
*	O
new_buf	*(void)
=	O
0	int
;	O
disable_interrupts	()->(void)
(	O
)	O
;	O
if	O
(	O
*	O
buf	*(*(char))
)	O
new_buf	*(void)
=	O
realloc	(*(void),long)->(*(void))
(	O
*	O
buf	*(*(char))
,	O
new_size	int
)	O
;	O
else	O
new_buf	*(void)
=	O
malloc	(long)->(*(void))
(	O
new_size	int
)	O
;	O
if	O
(	O
!	O
new_buf	*(void)
)	O
{	O
show_strerror	(*(char),int)->(void)
(	O
0	int
,	O
errno	O
)	O
;	O
set_error_msg	(*(char))->(void)
(	O
"Memory exhausted"	*(char)
)	O
;	O
enable_interrupts	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
*	O
size	*(int)
=	O
new_size	int
;	O
*	O
buf	*(*(char))
=	O
(	O
char	O
*	O
)	O
new_buf	*(void)
;	O
enable_interrupts	()->(void)
(	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
char	O
resize_line_buffer	(*(*(*(struct(*`,*`,long,int)))),*(int),int)->(char)
(	O
const	O
line_t	struct(*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),long,int)
*	O
*	O
*	O
buf	*(*(char))
,	O
int	O
*	O
size	*(int)
,	O
int	O
min_size	int
)	O
{	O
if	O
(	O
*	O
size	*(int)
<	O
min_size	int
)	O
{	O
const	O
int	O
new_size	int
=	O
(	O
min_size	int
<	O
512	int
?	O
512	int
:	O
(	O
min_size	int
/	O
512	int
)	O
*	O
1024	int
)	O
;	O
void	O
*	O
new_buf	*(void)
=	O
0	int
;	O
disable_interrupts	()->(void)
(	O
)	O
;	O
if	O
(	O
*	O
buf	*(*(char))
)	O
new_buf	*(void)
=	O
realloc	(*(void),long)->(*(void))
(	O
*	O
buf	*(*(char))
,	O
new_size	int
)	O
;	O
else	O
new_buf	*(void)
=	O
malloc	(long)->(*(void))
(	O
new_size	int
)	O
;	O
if	O
(	O
!	O
new_buf	*(void)
)	O
{	O
show_strerror	(*(char),int)->(void)
(	O
0	int
,	O
errno	O
)	O
;	O
set_error_msg	(*(char))->(void)
(	O
"Memory exhausted"	*(char)
)	O
;	O
enable_interrupts	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
*	O
size	*(int)
=	O
new_size	int
;	O
*	O
buf	*(*(char))
=	O
(	O
const	O
line_t	struct(*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),long,int)
*	O
*	O
)	O
new_buf	*(void)
;	O
enable_interrupts	()->(void)
(	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
char	O
resize_undo_buffer	(*(*(struct(enum(int,int,int,int),*(struct`),*(struct`)))),*(int),int)->(char)
(	O
undo_t	struct(enum(int,int,int,int),*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)))
*	O
*	O
buf	*(*(char))
,	O
int	O
*	O
size	*(int)
,	O
int	O
min_size	int
)	O
{	O
if	O
(	O
*	O
size	*(int)
<	O
min_size	int
)	O
{	O
const	O
int	O
new_size	int
=	O
(	O
min_size	int
<	O
512	int
?	O
512	int
:	O
(	O
min_size	int
/	O
512	int
)	O
*	O
1024	int
)	O
;	O
void	O
*	O
new_buf	*(void)
=	O
0	int
;	O
disable_interrupts	()->(void)
(	O
)	O
;	O
if	O
(	O
*	O
buf	*(*(char))
)	O
new_buf	*(void)
=	O
realloc	(*(void),long)->(*(void))
(	O
*	O
buf	*(*(char))
,	O
new_size	int
)	O
;	O
else	O
new_buf	*(void)
=	O
malloc	(long)->(*(void))
(	O
new_size	int
)	O
;	O
if	O
(	O
!	O
new_buf	*(void)
)	O
{	O
show_strerror	(*(char),int)->(void)
(	O
0	int
,	O
errno	O
)	O
;	O
set_error_msg	(*(char))->(void)
(	O
"Memory exhausted"	*(char)
)	O
;	O
enable_interrupts	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
*	O
size	*(int)
=	O
new_size	int
;	O
*	O
buf	*(*(char))
=	O
(	O
undo_t	struct(enum(int,int,int,int),*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)))
*	O
)	O
new_buf	*(void)
;	O
enable_interrupts	()->(void)
(	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
const	O
char	O
*	O
strip_escapes	(*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
static	O
char	O
*	O
buf	*(*(char))
=	O
0	int
;	O
static	O
int	O
bufsz	int
=	O
0	int
;	O
const	O
int	O
len	int
=	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
;	O
int	O
i	*(int)
=	O
0	int
;	O
if	O
(	O
!	O
resize_buffer	(*(*(char)),*(int),int)->(char)
(	O
&	O
buf	*(*(char))
,	O
&	O
bufsz	int
,	O
len	int
+	O
1	int
)	O
)	O
return	O
0	int
;	O
while	O
(	O
(	O
buf	*(*(char))
[	O
i	*(int)
++	O
]	O
=	O
(	O
(	O
*	O
s	*(char)
==	O
'\\'	O
)	O
?	O
*	O
++	O
s	*(char)
:	O
*	O
s	*(char)
)	O
)	O
)	O
s	*(char)
++	O
;	O
return	O
buf	*(*(char))
;	O
}	O
