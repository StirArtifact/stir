int	O
mu_cfg_parser_verbose	int
;	O
static	O
mu_list_t	*(struct)
parse_node_list	*(struct)
;	O
size_t	long
mu_cfg_error_count	long
;	O
static	O
int	O
_mu_cfg_errcnt	int
;	O
int	O
mu_cfg_yylex	()->(int)
(	O
)	O
;	O
void	O
_mu_line_begin	()->(void)
(	O
void	O
)	O
;	O
void	O
_mu_line_add	(*(char),long)->(void)
(	O
char	O
*	O
text	*(char)
,	O
size_t	long
len	long
)	O
;	O
char	O
*	O
_mu_line_finish	()->(*(char))
(	O
void	O
)	O
;	O
static	O
int	O
mu_cfg_yyerror	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
mu_error	(*(char))->(int)
(	O
"%s"	*(char)
,	O
s	*(char)
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
return	O
0	int
;	O
}	O
static	O
mu_config_value_t	struct
*	O
config_value_dup	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))
(	O
mu_config_value_t	struct
*	O
src	*(char)
)	O
{	O
if	O
(	O
!	O
src	*(char)
)	O
return	O
NULL	O
;	O
else	O
{	O
mu_config_value_t	struct
*	O
val	array(int)
=	O
mu_alloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
val	array(int)
)	O
)	O
;	O
*	O
val	array(int)
=	O
*	O
src	*(char)
;	O
return	O
val	array(int)
;	O
}	O
}	O
static	O
int	O
_node_set_parent	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
mu_cfg_node	struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))))
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
item	*(void)
;	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
parent	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
data	*(void)
;	O
return	O
0	int
;	O
}	O
static	O
mu_cfg_node_t	struct
*	O
mu_cfg_alloc_node	(enum(int,int,int),*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))->(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
(	O
enum	O
mu_cfg_node_type	enum(int,int,int)
type	*(char)
,	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
const	O
char	O
*	O
tag	*(char)
,	O
mu_config_value_t	struct
*	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
,	O
mu_list_t	*(struct)
nodelist	*(struct)
)	O
{	O
char	O
*	O
p	*(char)
;	O
mu_cfg_node_t	struct
*	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
size_t	long
size	long
=	O
sizeof	O
*	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
+	O
strlen	(*(char))->(long)
(	O
tag	*(char)
)	O
+	O
1	int
;	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
mu_alloc	(long)->(*(void))
(	O
size	long
)	O
;	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
type	*(char)
=	O
type	*(char)
;	O
mu_locus_range_init	(*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
&	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
mu_locus_range_copy	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
&	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
p	*(char)
=	O
(	O
char	O
*	O
)	O
(	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
+	O
1	int
)	O
;	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
tag	*(char)
=	O
p	*(char)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(char)
,	O
tag	*(char)
)	O
;	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
=	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
;	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
nodes	*(struct)
=	O
nodelist	*(struct)
;	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
parent	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
return	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
void	O
mu_cfg_free_node	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))->(void)
(	O
mu_cfg_node_t	struct
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
free	(*(void))->(void)
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
;	O
free	(*(void))->(void)
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
}	O
static	O
void	O
debug_print_node	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))->(void)
(	O
mu_cfg_node_t	struct
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
if	O
(	O
mu_debug_level_p	(int,int)->(int)
(	O
MU_DEBCAT_CONFIG	int
,	O
MU_DEBUG_TRACE0	int
)	O
)	O
{	O
if	O
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
type	*(char)
==	O
mu_cfg_node_undefined	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"unknown statement type!"	*(char)
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
}	O
else	O
{	O
mu_error	(*(char))->(int)
(	O
"statement: %s, id: %s"	*(char)
,	O
node_type_str	O
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
type	*(char)
)	O
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
tag	*(char)
?	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
tag	*(char)
:	O
"(null)"	*(char)
)	O
;	O
}	O
}	O
}	O
static	O
void	O
free_node_item	(*(void))->(void)
(	O
void	O
*	O
item	*(void)
)	O
{	O
mu_cfg_node_t	struct
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
item	*(void)
;	O
switch	O
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
type	*(char)
)	O
{	O
case	O
mu_cfg_node_statement	int
:	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
nodes	*(struct)
)	O
;	O
break	O
;	O
case	O
mu_cfg_node_undefined	int
:	O
case	O
mu_cfg_node_param	int
:	O
break	O
;	O
}	O
mu_cfg_free_node	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))->(void)
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
}	O
int	O
mu_cfg_create_node_list	(*(*(struct)))->(int)
(	O
mu_list_t	*(struct)
*	O
plist	*(*(struct))
)	O
{	O
int	O
rc	int
;	O
mu_list_t	*(struct)
list	*(struct)
;	O
rc	int
=	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
list	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
mu_list_set_destroy_item	(*(struct),*((*(void))->(void)))->(*((*(void))->(void)))
(	O
list	*(struct)
,	O
free_node_item	(*(void))->(void)
)	O
;	O
*	O
plist	*(*(struct))
=	O
list	*(struct)
;	O
return	O
0	int
;	O
}	O
extern	O
int	O
mu_cfg_yydebug	int
;	O
enum	O
yytokentype	enum(int,int,int,int)
{	O
MU_TOK_IDENT	int
=	O
258	int
,	O
MU_TOK_STRING	int
=	O
259	int
,	O
MU_TOK_QSTRING	int
=	O
260	int
,	O
MU_TOK_MSTRING	int
=	O
261	int
}	O
;	O
typedef	O
union	O
YYSTYPE	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`))))),*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct))
{	O
mu_cfg_node_t	struct
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
mu_cfg_node_t	struct
*	O
pnode	*(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
;	O
mu_list_t	*(struct)
nodelist	*(struct)
;	O
char	O
*	O
string	*(*(char))
;	O
mu_config_value_t	struct
value	struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`)))))
,	O
*	O
pvalue	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
;	O
mu_list_t	*(struct)
list	*(struct)
;	O
}	O
YYSTYPE	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`))))),*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct))
;	O
extern	O
YYSTYPE	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`))))),*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct))
mu_cfg_yylval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
;	O
extern	O
YYLTYPE	O
mu_cfg_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
int	O
mu_cfg_yyparse	()->(int)
(	O
void	O
)	O
;	O
typedef	O
unsigned	O
char	O
yytype_uint8	char
;	O
typedef	O
signed	O
char	O
yytype_int8	char
;	O
typedef	O
unsigned	O
short	O
int	O
yytype_uint16	short
;	O
typedef	O
short	O
int	O
yytype_int16	short
;	O
union	O
mu_cfg_yyalloc	union(short,union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct)),struct(struct(*(char),int,int),struct(*(char),int,int)))
{	O
yytype_int16	short
yyss_alloc	short
;	O
YYSTYPE	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`))))),*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct))
yyvs_alloc	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
;	O
YYLTYPE	O
yyls_alloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
}	O
;	O
static	O
const	O
yytype_uint8	char
yytranslate	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
10	int
,	O
11	int
,	O
2	int
,	O
2	int
,	O
12	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
7	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
8	int
,	O
2	int
,	O
9	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yyprhs	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
3	int
,	O
5	int
,	O
7	int
,	O
10	int
,	O
12	int
,	O
14	int
,	O
18	int
,	O
24	int
,	O
31	int
,	O
33	int
,	O
34	int
,	O
36	int
,	O
38	int
,	O
40	int
,	O
43	int
,	O
45	int
,	O
47	int
,	O
49	int
,	O
51	int
,	O
53	int
,	O
55	int
,	O
57	int
,	O
59	int
,	O
62	int
,	O
66	int
,	O
71	int
,	O
73	int
,	O
77	int
,	O
78	int
}	O
;	O
static	O
const	O
yytype_int8	char
yyrhs	array(char)
[	O
]	O
=	O
{	O
14	int
,	O
0	int
,	O
-	O
1	int
,	O
15	int
,	O
-	O
1	int
,	O
16	int
,	O
-	O
1	int
,	O
15	int
,	O
16	int
,	O
-	O
1	int
,	O
17	int
,	O
-	O
1	int
,	O
18	int
,	O
-	O
1	int
,	O
19	int
,	O
21	int
,	O
7	int
,	O
-	O
1	int
,	O
19	int
,	O
20	int
,	O
8	int
,	O
9	int
,	O
29	int
,	O
-	O
1	int
,	O
19	int
,	O
20	int
,	O
8	int
,	O
15	int
,	O
9	int
,	O
29	int
,	O
-	O
1	int
,	O
3	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
21	int
,	O
-	O
1	int
,	O
22	int
,	O
-	O
1	int
,	O
23	int
,	O
-	O
1	int
,	O
22	int
,	O
23	int
,	O
-	O
1	int
,	O
24	int
,	O
-	O
1	int
,	O
27	int
,	O
-	O
1	int
,	O
6	int
,	O
-	O
1	int
,	O
4	int
,	O
-	O
1	int
,	O
3	int
,	O
-	O
1	int
,	O
25	int
,	O
-	O
1	int
,	O
26	int
,	O
-	O
1	int
,	O
5	int
,	O
-	O
1	int
,	O
26	int
,	O
5	int
,	O
-	O
1	int
,	O
10	int
,	O
28	int
,	O
11	int
,	O
-	O
1	int
,	O
10	int
,	O
28	int
,	O
12	int
,	O
11	int
,	O
-	O
1	int
,	O
23	int
,	O
-	O
1	int
,	O
28	int
,	O
12	int
,	O
23	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
7	int
,	O
-	O
1	int
}	O
;	O
static	O
const	O
yytype_uint16	short
yyrline	array(short)
[	O
]	O
=	O
{	O
0	int
,	O
196	int
,	O
196	int
,	O
202	int
,	O
207	int
,	O
215	int
,	O
216	int
,	O
219	int
,	O
228	int
,	O
235	int
,	O
245	int
,	O
249	int
,	O
252	int
,	O
255	int
,	O
290	int
,	O
300	int
,	O
306	int
,	O
311	int
,	O
316	int
,	O
323	int
,	O
324	int
,	O
325	int
,	O
328	int
,	O
347	int
,	O
352	int
,	O
359	int
,	O
363	int
,	O
369	int
,	O
374	int
,	O
381	int
,	O
382	int
}	O
;	O
static	O
const	O
char	O
*	O
const	O
yytname	array(*(char))
[	O
]	O
=	O
{	O
"$end"	*(char)
,	O
"error"	*(char)
,	O
"$undefined"	*(char)
,	O
"MU_TOK_IDENT"	*(char)
,	O
"MU_TOK_STRING"	*(char)
,	O
"MU_TOK_QSTRING"	*(char)
,	O
"MU_TOK_MSTRING"	*(char)
,	O
"';'"	*(char)
,	O
"'{'"	*(char)
,	O
"'}'"	*(char)
,	O
"'('"	*(char)
,	O
"')'"	*(char)
,	O
"','"	*(char)
,	O
"$accept"	*(char)
,	O
"input"	*(char)
,	O
"stmtlist"	*(char)
,	O
"stmt"	*(char)
,	O
"simple"	*(char)
,	O
"block"	*(char)
,	O
"ident"	*(char)
,	O
"tag"	*(char)
,	O
"vallist"	*(char)
,	O
"vlist"	*(char)
,	O
"value"	*(char)
,	O
"string"	*(char)
,	O
"slist"	*(char)
,	O
"slist0"	*(char)
,	O
"list"	*(char)
,	O
"values"	*(char)
,	O
"opt_sc"	*(char)
,	O
YY_NULL	int
}	O
;	O
static	O
const	O
yytype_uint8	char
mu_cfg_yyr1	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
15	int
,	O
16	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
22	int
,	O
23	int
,	O
23	int
,	O
23	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
26	int
,	O
27	int
,	O
27	int
,	O
28	int
,	O
28	int
,	O
29	int
,	O
29	int
}	O
;	O
static	O
const	O
yytype_uint8	char
mu_cfg_yyr2	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
5	int
,	O
6	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
1	int
,	O
3	int
,	O
0	int
,	O
1	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yydefact	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
10	int
,	O
0	int
,	O
2	int
,	O
3	int
,	O
5	int
,	O
6	int
,	O
11	int
,	O
1	int
,	O
4	int
,	O
20	int
,	O
19	int
,	O
23	int
,	O
18	int
,	O
0	int
,	O
0	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
16	int
,	O
21	int
,	O
22	int
,	O
17	int
,	O
27	int
,	O
0	int
,	O
0	int
,	O
7	int
,	O
15	int
,	O
24	int
,	O
25	int
,	O
0	int
,	O
29	int
,	O
0	int
,	O
26	int
,	O
28	int
,	O
30	int
,	O
8	int
,	O
29	int
,	O
9	int
}	O
;	O
static	O
const	O
yytype_int8	char
yydefgoto	array(char)
[	O
]	O
=	O
{	O
-	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
24	int
,	O
36	int
}	O
;	O
static	O
const	O
yytype_int8	char
mu_cfg_yypact	array(char)
[	O
]	O
=	O
{	O
-	O
1	int
,	O
-	O
14	int
,	O
11	int
,	O
-	O
1	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
15	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
15	int
,	O
14	int
,	O
16	int
,	O
15	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
19	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
3	int
,	O
0	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
2	int
,	O
20	int
,	O
7	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
20	int
,	O
-	O
14	int
}	O
;	O
static	O
const	O
yytype_int8	char
yypgoto	array(char)
[	O
]	O
=	O
{	O
-	O
14	int
,	O
-	O
14	int
,	O
1	int
,	O
-	O
3	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
13	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
9	int
}	O
;	O
static	O
const	O
yytype_uint8	char
mu_cfg_yytable	array(char)
[	O
]	O
=	O
{	O
9	int
,	O
23	int
,	O
1	int
,	O
1	int
,	O
27	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
31	int
,	O
1	int
,	O
8	int
,	O
14	int
,	O
33	int
,	O
29	int
,	O
30	int
,	O
37	int
,	O
34	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
25	int
,	O
26	int
,	O
28	int
,	O
14	int
,	O
32	int
,	O
35	int
,	O
38	int
,	O
9	int
}	O
;	O
static	O
const	O
yytype_uint8	char
mu_cfg_yycheck	array(char)
[	O
]	O
=	O
{	O
3	int
,	O
14	int
,	O
3	int
,	O
3	int
,	O
17	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
9	int
,	O
3	int
,	O
0	int
,	O
10	int
,	O
11	int
,	O
11	int
,	O
12	int
,	O
9	int
,	O
30	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
8	int
,	O
7	int
,	O
5	int
,	O
10	int
,	O
25	int
,	O
7	int
,	O
37	int
,	O
32	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yystos	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
3	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
0	int
,	O
16	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
10	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
23	int
,	O
28	int
,	O
8	int
,	O
7	int
,	O
23	int
,	O
5	int
,	O
11	int
,	O
12	int
,	O
9	int
,	O
15	int
,	O
11	int
,	O
23	int
,	O
7	int
,	O
29	int
,	O
9	int
,	O
29	int
}	O
;	O
static	O
void	O
yy_symbol_value_print	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(union(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(struct),*(char),struct(int,union(*`,*`,struct`)),*(struct(int,union`)),*(struct))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
FILE	struct
*	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
yytype	int
,	O
YYSTYPE	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`))))),*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct))
const	O
*	O
const	O
yyvaluep	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
,	O
YYLTYPE	O
const	O
*	O
const	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
FILE	struct
*	O
yyo	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
YYUSE	O
(	O
yyo	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
yyvaluep	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
)	O
return	O
;	O
YYUSE	O
(	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
YYUSE	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
switch	O
(	O
yytype	int
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
void	O
yy_symbol_print	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(union(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(struct),*(char),struct(int,union(*`,*`,struct`)),*(struct(int,union`)),*(struct))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
FILE	struct
*	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
yytype	int
,	O
YYSTYPE	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`))))),*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct))
const	O
*	O
const	O
yyvaluep	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
,	O
YYLTYPE	O
const	O
*	O
const	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
if	O
(	O
yytype	int
<	O
YYNTOKENS	int
)	O
YYFPRINTF	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"token %s ("	*(char)
,	O
yytname	array(*(char))
[	O
yytype	int
]	O
)	O
;	O
else	O
YYFPRINTF	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"nterm %s ("	*(char)
,	O
yytname	array(*(char))
[	O
yytype	int
]	O
)	O
;	O
YY_LOCATION_PRINT	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
*	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
YYFPRINTF	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
": "	*(char)
)	O
;	O
yy_symbol_value_print	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(union(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(struct),*(char),struct(int,union(*`,*`,struct`)),*(struct(int,union`)),*(struct))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
yytype	int
,	O
yyvaluep	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
,	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
YYFPRINTF	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
")"	*(char)
)	O
;	O
}	O
static	O
void	O
yy_stack_print	(*(short),*(short))->(void)
(	O
yytype_int16	short
*	O
yybottom	*(short)
,	O
yytype_int16	short
*	O
yytop	*(short)
)	O
{	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Stack now"	*(char)
)	O
;	O
for	O
(	O
;	O
yybottom	*(short)
<=	O
yytop	*(short)
;	O
yybottom	*(short)
++	O
)	O
{	O
int	O
yybot	int
=	O
*	O
yybottom	*(short)
;	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %d"	*(char)
,	O
yybot	int
)	O
;	O
}	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
static	O
void	O
yy_reduce_print	(*(union(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(struct),*(char),struct(int,union(*`,*`,struct`)),*(struct(int,union`)),*(struct))),*(struct(struct(*(char),int,int),struct(*(char),int,int))),int)->(void)
(	O
YYSTYPE	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`))))),*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct))
*	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
,	O
YYLTYPE	O
*	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
int	O
mu_cfg_yyrule	int
)	O
{	O
int	O
yynrhs	int
=	O
mu_cfg_yyr2	array(char)
[	O
mu_cfg_yyrule	int
]	O
;	O
int	O
yyi	int
;	O
unsigned	O
long	O
int	O
yylno	long
=	O
yyrline	array(short)
[	O
mu_cfg_yyrule	int
]	O
;	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Reducing stack by rule %d (line %lu):\n"	*(char)
,	O
mu_cfg_yyrule	int
-	O
1	int
,	O
yylno	long
)	O
;	O
for	O
(	O
yyi	int
=	O
0	int
;	O
yyi	int
<	O
yynrhs	int
;	O
yyi	int
++	O
)	O
{	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"   $%d = "	*(char)
,	O
yyi	int
+	O
1	int
)	O
;	O
yy_symbol_print	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(union(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(struct),*(char),struct(int,union(*`,*`,struct`)),*(struct(int,union`)),*(struct))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
yyrhs	array(char)
[	O
yyprhs	array(char)
[	O
mu_cfg_yyrule	int
]	O
+	O
yyi	int
]	O
,	O
&	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
yyi	int
+	O
1	int
)	O
-	O
(	O
yynrhs	int
)	O
]	O
)	O
,	O
&	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
yyi	int
+	O
1	int
)	O
-	O
(	O
yynrhs	int
)	O
]	O
)	O
)	O
;	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
}	O
int	O
mu_cfg_yydebug	int
;	O
static	O
void	O
yydestruct	(*(char),int,*(union(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(struct),*(char),struct(int,union(*`,*`,struct`)),*(struct(int,union`)),*(struct))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
const	O
char	O
*	O
yymsg	*(char)
,	O
int	O
yytype	int
,	O
YYSTYPE	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`))))),*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct))
*	O
yyvaluep	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
,	O
YYLTYPE	O
*	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
YYUSE	O
(	O
yyvaluep	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
)	O
;	O
YYUSE	O
(	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
if	O
(	O
!	O
yymsg	*(char)
)	O
yymsg	*(char)
=	O
"Deleting"	*(char)
;	O
YY_SYMBOL_PRINT	O
(	O
yymsg	*(char)
,	O
yytype	int
,	O
yyvaluep	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
,	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
switch	O
(	O
yytype	int
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
int	O
mu_cfg_yychar	int
;	O
YYSTYPE	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`))))),*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct))
mu_cfg_yylval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
YY_INITIAL_VALUE	O
(	O
yyval_default	O
)	O
;	O
YYLTYPE	O
mu_cfg_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
int	O
mu_cfg_yynerrs	int
;	O
int	O
mu_cfg_yyparse	()->(int)
(	O
void	O
)	O
{	O
int	O
mu_cfg_yystate	int
;	O
int	O
yyerrstatus	int
;	O
yytype_int16	short
yyssa	array(short)
[	O
YYINITDEPTH	int
]	O
;	O
yytype_int16	short
*	O
yyss	*(short)
;	O
yytype_int16	short
*	O
yyssp	*(short)
;	O
YYSTYPE	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`))))),*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct))
yyvsa	array(union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct)))
[	O
YYINITDEPTH	int
]	O
;	O
YYSTYPE	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`))))),*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct))
*	O
yyvs	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
;	O
YYSTYPE	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`))))),*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct))
*	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
;	O
YYLTYPE	O
yylsa	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
YYINITDEPTH	int
]	O
;	O
YYLTYPE	O
*	O
yyls	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
YYLTYPE	O
*	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
YYLTYPE	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
3	int
]	O
;	O
YYSIZE_T	O
yystacksize	long
;	O
int	O
yyn	int
;	O
int	O
yyresult	int
;	O
int	O
yytoken	int
=	O
0	int
;	O
YYSTYPE	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`))))),*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct))
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
;	O
YYLTYPE	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
int	O
mu_cfg_yylen	int
=	O
0	int
;	O
yyssp	*(short)
=	O
yyss	*(short)
=	O
yyssa	array(short)
;	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
=	O
yyvs	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
=	O
yyvsa	array(union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct)))
;	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
yyls	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
yylsa	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
yystacksize	long
=	O
YYINITDEPTH	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Starting parse\n"	*(char)
)	O
)	O
;	O
mu_cfg_yystate	int
=	O
0	int
;	O
yyerrstatus	int
=	O
0	int
;	O
mu_cfg_yynerrs	int
=	O
0	int
;	O
mu_cfg_yychar	int
=	O
YYEMPTY	O
;	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
0	int
]	O
=	O
mu_cfg_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
goto	O
yysetstate	O
;	O
yynewstate	O
:	O
yyssp	*(short)
++	O
;	O
yysetstate	O
:	O
*	O
yyssp	*(short)
=	O
mu_cfg_yystate	int
;	O
if	O
(	O
yyss	*(short)
+	O
yystacksize	long
-	O
1	int
<=	O
yyssp	*(short)
)	O
{	O
YYSIZE_T	O
yysize	long
=	O
yyssp	*(short)
-	O
yyss	*(short)
+	O
1	int
;	O
if	O
(	O
YYMAXDEPTH	int
<=	O
yystacksize	long
)	O
goto	O
yyexhaustedlab	O
;	O
yystacksize	long
*=	O
2	int
;	O
if	O
(	O
YYMAXDEPTH	int
<	O
yystacksize	long
)	O
yystacksize	long
=	O
YYMAXDEPTH	int
;	O
{	O
yytype_int16	short
*	O
yyss1	*(short)
=	O
yyss	*(short)
;	O
union	O
mu_cfg_yyalloc	union(short,union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct)),struct(struct(*(char),int,int),struct(*(char),int,int)))
*	O
yyptr	*(union(short,union(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(struct),*(char),struct(int,union(*`,*`,struct`)),*(struct(int,union`)),*(struct)),struct(struct(*(char),int,int),struct(*(char),int,int))))
=	O
(	O
union	O
mu_cfg_yyalloc	union(short,union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct)),struct(struct(*(char),int,int),struct(*(char),int,int)))
*	O
)	O
YYSTACK_ALLOC	O
(	O
YYSTACK_BYTES	O
(	O
yystacksize	long
)	O
)	O
;	O
if	O
(	O
!	O
yyptr	*(union(short,union(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(struct),*(char),struct(int,union(*`,*`,struct`)),*(struct(int,union`)),*(struct)),struct(struct(*(char),int,int),struct(*(char),int,int))))
)	O
goto	O
yyexhaustedlab	O
;	O
YYSTACK_RELOCATE	O
(	O
yyss_alloc	short
,	O
yyss	*(short)
)	O
;	O
YYSTACK_RELOCATE	O
(	O
yyvs_alloc	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
,	O
yyvs	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
)	O
;	O
YYSTACK_RELOCATE	O
(	O
yyls_alloc	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
yyls	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
if	O
(	O
yyss1	*(short)
!=	O
yyssa	array(short)
)	O
YYSTACK_FREE	O
(	O
yyss1	*(short)
)	O
;	O
}	O
yyssp	*(short)
=	O
yyss	*(short)
+	O
yysize	long
-	O
1	int
;	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
=	O
yyvs	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
+	O
yysize	long
-	O
1	int
;	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
yyls	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
+	O
yysize	long
-	O
1	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Stack size increased to %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
int	O
)	O
yystacksize	long
)	O
)	O
;	O
if	O
(	O
yyss	*(short)
+	O
yystacksize	long
-	O
1	int
<=	O
yyssp	*(short)
)	O
YYABORT	O
;	O
}	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Entering state %d\n"	*(char)
,	O
mu_cfg_yystate	int
)	O
)	O
;	O
if	O
(	O
mu_cfg_yystate	int
==	O
YYFINAL	int
)	O
YYACCEPT	O
;	O
goto	O
yybackup	O
;	O
yybackup	O
:	O
yyn	int
=	O
mu_cfg_yypact	array(char)
[	O
mu_cfg_yystate	int
]	O
;	O
if	O
(	O
yypact_value_is_default	O
(	O
yyn	int
)	O
)	O
goto	O
yydefault	O
;	O
if	O
(	O
mu_cfg_yychar	int
==	O
YYEMPTY	O
)	O
{	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Reading a token: "	*(char)
)	O
)	O
;	O
mu_cfg_yychar	int
=	O
YYLEX	O
;	O
}	O
if	O
(	O
mu_cfg_yychar	int
<=	O
YYEOF	int
)	O
{	O
mu_cfg_yychar	int
=	O
yytoken	int
=	O
YYEOF	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Now at end of input.\n"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
yytoken	int
=	O
YYTRANSLATE	O
(	O
mu_cfg_yychar	int
)	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Next token is"	*(char)
,	O
yytoken	int
,	O
&	O
mu_cfg_yylval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
,	O
&	O
mu_cfg_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
}	O
yyn	int
+=	O
yytoken	int
;	O
if	O
(	O
yyn	int
<	O
0	int
||	O
YYLAST	int
<	O
yyn	int
||	O
mu_cfg_yycheck	array(char)
[	O
yyn	int
]	O
!=	O
yytoken	int
)	O
goto	O
yydefault	O
;	O
yyn	int
=	O
mu_cfg_yytable	array(char)
[	O
yyn	int
]	O
;	O
if	O
(	O
yyn	int
<=	O
0	int
)	O
{	O
if	O
(	O
yytable_value_is_error	O
(	O
yyn	int
)	O
)	O
goto	O
yyerrlab	O
;	O
yyn	int
=	O
-	O
yyn	int
;	O
goto	O
yyreduce	O
;	O
}	O
if	O
(	O
yyerrstatus	int
)	O
yyerrstatus	int
--	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	*(char)
,	O
yytoken	int
,	O
&	O
mu_cfg_yylval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
,	O
&	O
mu_cfg_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
mu_cfg_yychar	int
=	O
YYEMPTY	O
;	O
mu_cfg_yystate	int
=	O
yyn	int
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	O
*	O
++	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
=	O
mu_cfg_yylval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_END	O
*	O
++	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
mu_cfg_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
goto	O
yynewstate	O
;	O
yydefault	O
:	O
yyn	int
=	O
yydefact	array(char)
[	O
mu_cfg_yystate	int
]	O
;	O
if	O
(	O
yyn	int
==	O
0	int
)	O
goto	O
yyerrlab	O
;	O
goto	O
yyreduce	O
;	O
yyreduce	O
:	O
mu_cfg_yylen	int
=	O
mu_cfg_yyr2	array(char)
[	O
yyn	int
]	O
;	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
=	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
1	int
-	O
mu_cfg_yylen	int
]	O
;	O
YYLLOC_DEFAULT	O
(	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
-	O
mu_cfg_yylen	int
)	O
,	O
mu_cfg_yylen	int
)	O
;	O
YY_REDUCE_PRINT	O
(	O
yyn	int
)	O
;	O
switch	O
(	O
yyn	int
)	O
{	O
case	O
2	int
:	O
{	O
parse_node_list	*(struct)
=	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
nodelist	*(struct)
)	O
;	O
}	O
break	O
;	O
case	O
3	int
:	O
{	O
mu_cfg_create_node_list	(*(*(struct)))->(int)
(	O
&	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
nodelist	*(struct)
)	O
)	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
nodelist	*(struct)
)	O
,	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
pnode	*(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
)	O
)	O
;	O
}	O
break	O
;	O
case	O
4	int
:	O
{	O
mu_list_append	(*(struct),*(void))->(int)
(	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
nodelist	*(struct)
)	O
,	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
pnode	*(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
)	O
)	O
;	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
nodelist	*(struct)
)	O
=	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
nodelist	*(struct)
)	O
;	O
debug_print_node	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))->(void)
(	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
pnode	*(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
)	O
)	O
;	O
}	O
break	O
;	O
case	O
7	int
:	O
{	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
beg	struct(*(char),int,int)
=	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
beg	struct(*(char),int,int)
;	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
end	struct(*(char),int,int)
=	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
end	struct(*(char),int,int)
;	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
pnode	*(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
)	O
=	O
mu_cfg_alloc_node	(enum(int,int,int),*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))->(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
(	O
mu_cfg_node_param	int
,	O
&	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
string	*(*(char))
)	O
,	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
pvalue	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
,	O
NULL	O
)	O
;	O
}	O
break	O
;	O
case	O
8	int
:	O
{	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
beg	struct(*(char),int,int)
=	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
1	int
)	O
-	O
(	O
5	int
)	O
]	O
)	O
.	O
beg	struct(*(char),int,int)
;	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
end	struct(*(char),int,int)
=	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
5	int
)	O
-	O
(	O
5	int
)	O
]	O
)	O
.	O
end	struct(*(char),int,int)
;	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
pnode	*(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
)	O
=	O
mu_cfg_alloc_node	(enum(int,int,int),*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))->(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
(	O
mu_cfg_node_statement	int
,	O
&	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
string	*(*(char))
)	O
,	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
pvalue	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
,	O
NULL	O
)	O
;	O
}	O
break	O
;	O
case	O
9	int
:	O
{	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
beg	struct(*(char),int,int)
=	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
1	int
)	O
-	O
(	O
6	int
)	O
]	O
)	O
.	O
beg	struct(*(char),int,int)
;	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
end	struct(*(char),int,int)
=	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
6	int
)	O
-	O
(	O
6	int
)	O
]	O
)	O
.	O
end	struct(*(char),int,int)
;	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
pnode	*(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
)	O
=	O
mu_cfg_alloc_node	(enum(int,int,int),*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))->(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
(	O
mu_cfg_node_statement	int
,	O
&	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
string	*(*(char))
)	O
,	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
2	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
pvalue	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
,	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
4	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
nodelist	*(struct)
)	O
)	O
;	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
4	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
nodelist	*(struct)
)	O
,	O
_node_set_parent	(*(void),*(void))->(int)
,	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
pnode	*(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
)	O
)	O
;	O
}	O
break	O
;	O
case	O
11	int
:	O
{	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
pvalue	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
13	int
:	O
{	O
size_t	long
n	long
=	O
0	int
;	O
mu_list_count	(*(struct),*(long))->(int)
(	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
list	*(struct)
)	O
,	O
&	O
n	long
)	O
;	O
if	O
(	O
n	long
==	O
1	int
)	O
{	O
mu_list_get	(*(struct),long,*(*(void)))->(int)
(	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
list	*(struct)
)	O
,	O
0	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
pvalue	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
)	O
;	O
}	O
else	O
{	O
size_t	long
i	long
;	O
mu_config_value_t	struct
val	array(int)
;	O
val	array(int)
.	O
type	*(char)
=	O
MU_CFG_ARRAY	int
;	O
val	array(int)
.	O
v	*(struct(int))
.	O
arg	*(char)
.	O
c	int
=	O
n	long
;	O
val	array(int)
.	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
=	O
mu_alloc	(long)->(*(void))
(	O
n	long
*	O
sizeof	O
(	O
val	array(int)
.	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
val	array(int)
.	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"not enough memory"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
mu_config_value_t	struct
*	O
v	*(struct(int))
;	O
mu_list_get	(*(struct),long,*(*(void)))->(int)
(	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
list	*(struct)
)	O
,	O
i	long
,	O
(	O
void	O
*	O
*	O
)	O
&	O
v	*(struct(int))
)	O
;	O
val	array(int)
.	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
[	O
i	long
]	O
=	O
*	O
v	*(struct(int))
;	O
}	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
pvalue	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
=	O
config_value_dup	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))
(	O
&	O
val	array(int)
)	O
;	O
}	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
list	*(struct)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
14	int
:	O
{	O
int	O
rc	int
=	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
list	*(struct)
)	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create list: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
mu_list_append	(*(struct),*(void))->(int)
(	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
list	*(struct)
)	O
,	O
config_value_dup	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))
(	O
&	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
value	struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`)))))
)	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
15	int
:	O
{	O
mu_list_append	(*(struct),*(void))->(int)
(	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
list	*(struct)
)	O
,	O
config_value_dup	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))
(	O
&	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
value	struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`)))))
)	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
16	int
:	O
{	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
value	struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`)))))
)	O
.	O
type	*(char)
=	O
MU_CFG_STRING	int
;	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
value	struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`)))))
)	O
.	O
v	*(struct(int))
.	O
string	*(*(char))
=	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	*(*(char))
)	O
;	O
}	O
break	O
;	O
case	O
17	int
:	O
{	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
value	struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`)))))
)	O
.	O
type	*(char)
=	O
MU_CFG_LIST	int
;	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
value	struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`)))))
)	O
.	O
v	*(struct(int))
.	O
list	*(struct)
=	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
list	*(struct)
)	O
;	O
}	O
break	O
;	O
case	O
18	int
:	O
{	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
value	struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`)))))
)	O
.	O
type	*(char)
=	O
MU_CFG_STRING	int
;	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
value	struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`)))))
)	O
.	O
v	*(struct(int))
.	O
string	*(*(char))
=	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	*(*(char))
)	O
;	O
}	O
break	O
;	O
case	O
22	int
:	O
{	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
list	*(struct)
)	O
,	O
&	O
itr	*(struct)
)	O
;	O
_mu_line_begin	()->(void)
(	O
)	O
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
char	O
*	O
p	*(char)
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
p	*(char)
)	O
;	O
_mu_line_add	(*(char),long)->(void)
(	O
p	*(char)
,	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
)	O
;	O
}	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
string	*(*(char))
)	O
=	O
_mu_line_finish	()->(*(char))
(	O
)	O
;	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
list	*(struct)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
23	int
:	O
{	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
list	*(struct)
)	O
)	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
list	*(struct)
)	O
,	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	*(*(char))
)	O
)	O
;	O
}	O
break	O
;	O
case	O
24	int
:	O
{	O
mu_list_append	(*(struct),*(void))->(int)
(	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
list	*(struct)
)	O
,	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
string	*(*(char))
)	O
)	O
;	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
list	*(struct)
)	O
=	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
list	*(struct)
)	O
;	O
}	O
break	O
;	O
case	O
25	int
:	O
{	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
list	*(struct)
)	O
=	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
list	*(struct)
)	O
;	O
}	O
break	O
;	O
case	O
26	int
:	O
{	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
list	*(struct)
)	O
=	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
2	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
list	*(struct)
)	O
;	O
}	O
break	O
;	O
case	O
27	int
:	O
{	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
list	*(struct)
)	O
)	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
list	*(struct)
)	O
,	O
config_value_dup	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))
(	O
&	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
value	struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`)))))
)	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
28	int
:	O
{	O
mu_list_append	(*(struct),*(void))->(int)
(	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
list	*(struct)
)	O
,	O
config_value_dup	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))
(	O
&	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
value	struct(int,union(*(struct),*(char),struct(long,*(struct(int,union`)))))
)	O
)	O
)	O
;	O
(	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
.	O
list	*(struct)
)	O
=	O
(	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
list	*(struct)
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
YY_SYMBOL_PRINT	O
(	O
"-> $$ ="	*(char)
,	O
mu_cfg_yyr1	array(char)
[	O
yyn	int
]	O
,	O
&	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
,	O
&	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
YYPOPSTACK	O
(	O
mu_cfg_yylen	int
)	O
;	O
mu_cfg_yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
*	O
++	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
=	O
mu_cfg_yyval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
;	O
*	O
++	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
yyn	int
=	O
mu_cfg_yyr1	array(char)
[	O
yyn	int
]	O
;	O
mu_cfg_yystate	int
=	O
yypgoto	array(char)
[	O
yyn	int
-	O
YYNTOKENS	int
]	O
+	O
*	O
yyssp	*(short)
;	O
if	O
(	O
0	int
<=	O
mu_cfg_yystate	int
&&	O
mu_cfg_yystate	int
<=	O
YYLAST	int
&&	O
mu_cfg_yycheck	array(char)
[	O
mu_cfg_yystate	int
]	O
==	O
*	O
yyssp	*(short)
)	O
mu_cfg_yystate	int
=	O
mu_cfg_yytable	array(char)
[	O
mu_cfg_yystate	int
]	O
;	O
else	O
mu_cfg_yystate	int
=	O
yydefgoto	array(char)
[	O
yyn	int
-	O
YYNTOKENS	int
]	O
;	O
goto	O
yynewstate	O
;	O
yyerrlab	O
:	O
yytoken	int
=	O
mu_cfg_yychar	int
==	O
YYEMPTY	O
?	O
YYEMPTY	O
:	O
YYTRANSLATE	O
(	O
mu_cfg_yychar	int
)	O
;	O
if	O
(	O
!	O
yyerrstatus	int
)	O
{	O
++	O
mu_cfg_yynerrs	int
;	O
mu_cfg_yyerror	(*(char))->(int)
(	O
YY_	O
(	O
"syntax error"	*(char)
)	O
)	O
;	O
}	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
1	int
]	O
=	O
mu_cfg_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
if	O
(	O
yyerrstatus	int
==	O
3	int
)	O
{	O
if	O
(	O
mu_cfg_yychar	int
<=	O
YYEOF	int
)	O
{	O
if	O
(	O
mu_cfg_yychar	int
==	O
YYEOF	int
)	O
YYABORT	O
;	O
}	O
else	O
{	O
yydestruct	(*(char),int,*(union(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(struct),*(char),struct(int,union(*`,*`,struct`)),*(struct(int,union`)),*(struct))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
"Error: discarding"	*(char)
,	O
yytoken	int
,	O
&	O
mu_cfg_yylval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
,	O
&	O
mu_cfg_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
mu_cfg_yychar	int
=	O
YYEMPTY	O
;	O
}	O
}	O
goto	O
yyerrlab1	O
;	O
yyerrorlab	O
:	O
if	O
(	O
0	int
)	O
goto	O
yyerrorlab	O
;	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
1	int
]	O
=	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
1	int
-	O
mu_cfg_yylen	int
]	O
;	O
YYPOPSTACK	O
(	O
mu_cfg_yylen	int
)	O
;	O
mu_cfg_yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
mu_cfg_yystate	int
=	O
*	O
yyssp	*(short)
;	O
goto	O
yyerrlab1	O
;	O
yyerrlab1	O
:	O
yyerrstatus	int
=	O
3	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
yyn	int
=	O
mu_cfg_yypact	array(char)
[	O
mu_cfg_yystate	int
]	O
;	O
if	O
(	O
!	O
yypact_value_is_default	O
(	O
yyn	int
)	O
)	O
{	O
yyn	int
+=	O
YYTERROR	int
;	O
if	O
(	O
0	int
<=	O
yyn	int
&&	O
yyn	int
<=	O
YYLAST	int
&&	O
mu_cfg_yycheck	array(char)
[	O
yyn	int
]	O
==	O
YYTERROR	int
)	O
{	O
yyn	int
=	O
mu_cfg_yytable	array(char)
[	O
yyn	int
]	O
;	O
if	O
(	O
0	int
<	O
yyn	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
yyssp	*(short)
==	O
yyss	*(short)
)	O
YYABORT	O
;	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
1	int
]	O
=	O
*	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
yydestruct	(*(char),int,*(union(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(struct),*(char),struct(int,union(*`,*`,struct`)),*(struct(int,union`)),*(struct))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
"Error: popping"	*(char)
,	O
yystos	array(char)
[	O
mu_cfg_yystate	int
]	O
,	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
,	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
mu_cfg_yystate	int
=	O
*	O
yyssp	*(short)
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
}	O
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	O
*	O
++	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
=	O
mu_cfg_yylval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_END	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
2	int
]	O
=	O
mu_cfg_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
YYLLOC_DEFAULT	O
(	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
2	int
)	O
;	O
*	O
++	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	*(char)
,	O
yystos	array(char)
[	O
yyn	int
]	O
,	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
,	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
mu_cfg_yystate	int
=	O
yyn	int
;	O
goto	O
yynewstate	O
;	O
yyacceptlab	O
:	O
yyresult	int
=	O
0	int
;	O
goto	O
yyreturn	O
;	O
yyabortlab	O
:	O
yyresult	int
=	O
1	int
;	O
goto	O
yyreturn	O
;	O
yyexhaustedlab	O
:	O
mu_cfg_yyerror	(*(char))->(int)
(	O
YY_	O
(	O
"memory exhausted"	*(char)
)	O
)	O
;	O
yyresult	int
=	O
2	int
;	O
yyreturn	O
:	O
if	O
(	O
mu_cfg_yychar	int
!=	O
YYEMPTY	O
)	O
{	O
yytoken	int
=	O
YYTRANSLATE	O
(	O
mu_cfg_yychar	int
)	O
;	O
yydestruct	(*(char),int,*(union(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(struct),*(char),struct(int,union(*`,*`,struct`)),*(struct(int,union`)),*(struct))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
"Cleanup: discarding lookahead"	*(char)
,	O
yytoken	int
,	O
&	O
mu_cfg_yylval	union(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(struct),*(char),struct(int,union(*(struct),*(char),struct(long,*(struct`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))
,	O
&	O
mu_cfg_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
}	O
YYPOPSTACK	O
(	O
mu_cfg_yylen	int
)	O
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
while	O
(	O
yyssp	*(short)
!=	O
yyss	*(short)
)	O
{	O
yydestruct	(*(char),int,*(union(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(struct),*(char),struct(int,union(*`,*`,struct`)),*(struct(int,union`)),*(struct))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
"Cleanup: popping"	*(char)
,	O
yystos	array(char)
[	O
*	O
yyssp	*(short)
]	O
,	O
yyvsp	*(union(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(struct),*(char),struct(int,union(*(struct`),*(char),struct(long,*`))),*(struct(int,union(*`,*`,struct`))),*(struct)))
,	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
yyss	*(short)
!=	O
yyssa	array(short)
)	O
YYSTACK_FREE	O
(	O
yyss	*(short)
)	O
;	O
return	O
YYID	O
(	O
yyresult	int
)	O
;	O
}	O
void	O
mu_cfg_set_debug	()->(void)
(	O
)	O
{	O
if	O
(	O
mu_debug_level_p	(int,int)->(int)
(	O
MU_DEBCAT_CONFIG	int
,	O
MU_DEBUG_TRACE7	int
)	O
)	O
mu_cfg_yydebug	int
=	O
1	int
;	O
}	O
int	O
mu_cfg_parse	(*(*(struct(*(struct`),*(struct`)))))->(int)
(	O
mu_cfg_tree_t	struct
*	O
*	O
ptree	*(*(struct(*(struct),*(struct))))
)	O
{	O
int	O
rc	int
;	O
mu_cfg_tree_t	struct
*	O
tree	*(struct(*(struct),*(struct)))
;	O
mu_opool_t	*(struct)
pool	*(struct)
;	O
int	O
save_mode	int
=	O
0	int
,	O
mode	int
;	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
save_locus	struct(struct(*(char),int,int),struct(*(char),int,int))
=	O
MU_LOCUS_RANGE_INITIALIZER	O
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_GET_MODE	int
,	O
&	O
save_mode	int
)	O
;	O
mode	int
=	O
save_mode	int
|	O
MU_LOGMODE_LOCUS	int
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_MODE	int
,	O
&	O
mode	int
)	O
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_GET_LOCUS_RANGE	int
,	O
&	O
save_locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
mu_cfg_set_debug	()->(void)
(	O
)	O
;	O
_mu_cfg_errcnt	int
=	O
0	int
;	O
rc	int
=	O
mu_cfg_yyparse	()->(int)
(	O
)	O
;	O
pool	*(struct)
=	O
mu_cfg_lexer_pool	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
&&	O
_mu_cfg_errcnt	int
)	O
{	O
mu_opool_destroy	(*(*(struct)))->(void)
(	O
&	O
pool	*(struct)
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
{	O
tree	*(struct(*(struct),*(struct)))
=	O
mu_alloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
tree	*(struct(*(struct),*(struct)))
)	O
)	O
;	O
tree	*(struct(*(struct),*(struct)))
->	O
nodes	*(struct)
=	O
parse_node_list	*(struct)
;	O
tree	*(struct(*(struct),*(struct)))
->	O
pool	*(struct)
=	O
pool	*(struct)
;	O
parse_node_list	*(struct)
=	O
NULL	O
;	O
*	O
ptree	*(*(struct(*(struct),*(struct))))
=	O
tree	*(struct(*(struct),*(struct)))
;	O
}	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_MODE	int
,	O
&	O
save_mode	int
)	O
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
&	O
save_locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
mu_locus_range_deinit	(*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
&	O
save_locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_cfg_tree_union	(*(*(struct(*(struct`),*(struct`)))),*(*(struct(*(struct`),*(struct`)))))->(int)
(	O
mu_cfg_tree_t	struct
*	O
*	O
pa	*(*(struct(*(struct),*(struct))))
,	O
mu_cfg_tree_t	struct
*	O
*	O
pb	*(*(struct(*(struct),*(struct))))
)	O
{	O
mu_cfg_tree_t	struct
*	O
a	*(struct(*(char),int,int))
,	O
*	O
b	*(struct(*(char),int,int))
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
pb	*(*(struct(*(struct),*(struct))))
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
*	O
pb	*(*(struct(*(struct),*(struct))))
)	O
return	O
0	int
;	O
b	*(struct(*(char),int,int))
=	O
*	O
pb	*(*(struct(*(struct),*(struct))))
;	O
if	O
(	O
!	O
pa	*(*(struct(*(struct),*(struct))))
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
*	O
pa	*(*(struct(*(struct),*(struct))))
)	O
{	O
*	O
pa	*(*(struct(*(struct),*(struct))))
=	O
b	*(struct(*(char),int,int))
;	O
*	O
pb	*(*(struct(*(struct),*(struct))))
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
else	O
a	*(struct(*(char),int,int))
=	O
*	O
pa	*(*(struct(*(struct),*(struct))))
;	O
rc	int
=	O
mu_opool_union	(*(*(struct)),*(*(struct)))->(int)
(	O
&	O
b	*(struct(*(char),int,int))
->	O
pool	*(struct)
,	O
&	O
a	*(struct(*(char),int,int))
->	O
pool	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
b	*(struct(*(char),int,int))
->	O
nodes	*(struct)
)	O
{	O
mu_list_append_list	(*(struct),*(struct))->(void)
(	O
a	*(struct(*(char),int,int))
->	O
nodes	*(struct)
,	O
b	*(struct(*(char),int,int))
->	O
nodes	*(struct)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
b	*(struct(*(char),int,int))
->	O
nodes	*(struct)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
b	*(struct(*(char),int,int))
)	O
;	O
*	O
pb	*(*(struct(*(struct),*(struct))))
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
mu_cfg_tree_t	struct
*	O
do_include	(*(char),*(struct(int,*(char),*(char),*(char))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(*(struct),*(struct))))
(	O
const	O
char	O
*	O
name	*(char)
,	O
struct	O
mu_cfg_parse_hints	struct(int,*(char),*(char),*(char))
*	O
hints	*(struct(*(char),*(char)))
,	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
char	O
*	O
tmpname	*(char)
=	O
NULL	O
;	O
mu_cfg_tree_t	struct
*	O
tree	*(struct(*(struct),*(struct)))
=	O
NULL	O
;	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
name	*(char)
=	O
tmpname	*(char)
=	O
mu_make_file_name	O
(	O
SYSCONFDIR	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
name	*(char)
)	O
{	O
mu_error	(*(char))->(int)
(	O
"%s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
name	*(char)
,	O
&	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
if	O
(	O
S_ISDIR	O
(	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
hints	*(struct(*(char),*(char)))
->	O
flags	int
&	O
MU_CFHINT_PROGRAM	int
)	O
{	O
char	O
*	O
file	*(char)
=	O
mu_make_file_name	O
(	O
name	*(char)
,	O
hints	*(struct(*(char),*(char)))
->	O
program	*(char)
)	O
;	O
rc	int
=	O
mu_cfg_parse_file	(*(*(struct(*(struct`),*(struct`)))),*(char),int)->(int)
(	O
&	O
tree	*(struct(*(struct),*(struct)))
,	O
file	*(char)
,	O
hints	*(struct(*(char),*(char)))
->	O
flags	int
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
)	O
;	O
}	O
else	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_WARNING	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
_	O
(	O
"ignoring `include': directory argument is allowed only from the top-level configuration file"	*(char)
)	O
)	O
;	O
}	O
}	O
else	O
rc	int
=	O
mu_cfg_parse_file	(*(*(struct(*(struct`),*(struct`)))),*(char),int)->(int)
(	O
&	O
tree	*(struct(*(struct),*(struct)))
,	O
name	*(char)
,	O
hints	*(struct(*(char),*(char)))
->	O
flags	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
&&	O
tree	*(struct(*(struct),*(struct)))
)	O
{	O
struct	O
mu_cfg_parse_hints	struct(int,*(char),*(char),*(char))
xhints	struct(int,*(char),*(char),*(char))
=	O
*	O
hints	*(struct(*(char),*(char)))
;	O
xhints	struct(int,*(char),*(char),*(char))
.	O
flags	int
&=	O
~	O
MU_CFHINT_PROGRAM	int
;	O
mu_cfg_tree_postprocess	(*(struct(*(struct),*(struct))),*(struct(int,*(char),*(char),*(char))))->(int)
(	O
tree	*(struct(*(struct),*(struct)))
,	O
&	O
xhints	struct(int,*(char),*(char),*(char))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
_	O
(	O
"include file or directory does not exist"	*(char)
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
}	O
else	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
_	O
(	O
"cannot stat include file or directory: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
}	O
free	(*(void))->(void)
(	O
tmpname	*(char)
)	O
;	O
return	O
tree	*(struct(*(struct),*(struct)))
;	O
}	O
int	O
mu_cfg_tree_postprocess	(*(struct(*(struct),*(struct))),*(struct(int,*(char),*(char),*(char))))->(int)
(	O
mu_cfg_tree_t	struct
*	O
tree	*(struct(*(struct),*(struct)))
,	O
struct	O
mu_cfg_parse_hints	struct(int,*(char),*(char),*(char))
*	O
hints	*(struct(*(char),*(char)))
)	O
{	O
int	O
rc	int
;	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
if	O
(	O
!	O
tree	*(struct(*(struct),*(struct)))
->	O
nodes	*(struct)
)	O
return	O
0	int
;	O
rc	int
=	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
tree	*(struct(*(struct),*(struct)))
->	O
nodes	*(struct)
,	O
&	O
itr	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
mu_cfg_node_t	struct
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
if	O
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
type	*(char)
==	O
mu_cfg_node_statement	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
tag	*(char)
,	O
"program"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
hints	*(struct(*(char),*(char)))
->	O
flags	int
&	O
MU_CFHINT_PROGRAM	int
)	O
{	O
if	O
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
->	O
type	*(char)
==	O
MU_CFG_STRING	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
->	O
v	*(struct(int))
.	O
string	*(*(char))
,	O
hints	*(struct(*(char),*(char)))
->	O
program	*(char)
)	O
==	O
0	int
)	O
{	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
nodes	*(struct)
,	O
_node_set_parent	(*(void),*(void))->(int)
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
parent	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_insert_list	int
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
nodes	*(struct)
)	O
;	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_delete	int
,	O
NULL	O
)	O
;	O
}	O
}	O
else	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
&	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"argument to `program' is not a string"	*(char)
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_delete	int
,	O
NULL	O
)	O
;	O
}	O
}	O
else	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_WARNING	int
,	O
&	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"ignoring `program' block: not located in top-level configuration file"	*(char)
)	O
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
type	*(char)
==	O
mu_cfg_node_param	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
tag	*(char)
,	O
"include"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
->	O
type	*(char)
==	O
MU_CFG_STRING	int
)	O
{	O
mu_cfg_tree_t	struct
*	O
t	*(struct(*(struct),*(struct)))
=	O
do_include	(*(char),*(struct(int,*(char),*(char),*(char))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(*(struct),*(struct))))
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
->	O
v	*(struct(int))
.	O
string	*(*(char))
,	O
hints	*(struct(*(char),*(char)))
,	O
&	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
if	O
(	O
t	*(struct(*(struct),*(struct)))
)	O
{	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_insert_list	int
,	O
t	*(struct(*(struct),*(struct)))
->	O
nodes	*(struct)
)	O
;	O
mu_opool_union	(*(*(struct)),*(*(struct)))->(int)
(	O
&	O
tree	*(struct(*(struct),*(struct)))
->	O
pool	*(struct)
,	O
&	O
t	*(struct(*(struct),*(struct)))
->	O
pool	*(struct)
)	O
;	O
mu_cfg_destroy_tree	(*(*(struct(*(struct`),*(struct`)))))->(void)
(	O
&	O
t	*(struct(*(struct),*(struct)))
)	O
;	O
}	O
}	O
else	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
&	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"argument to `include' is not a string"	*(char)
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
}	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_delete	int
,	O
NULL	O
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_mu_cfg_preorder_recursive	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
cbdata	*(void)
)	O
{	O
mu_cfg_node_t	struct
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
item	*(void)
;	O
struct	O
mu_cfg_iter_closure	struct(*((*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(void))->(int)),*((*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(void))->(int)),*(void))
*	O
clos	*(void)
=	O
cbdata	*(void)
;	O
int	O
rc	int
;	O
switch	O
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
type	*(char)
)	O
{	O
case	O
mu_cfg_node_undefined	int
:	O
abort	()->(void)
(	O
)	O
;	O
case	O
mu_cfg_node_statement	int
:	O
switch	O
(	O
clos	*(void)
->	O
beg	struct(*(char),int,int)
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
,	O
clos	*(void)
->	O
data	*(void)
)	O
)	O
{	O
case	O
MU_CFG_ITER_OK	int
:	O
rc	int
=	O
mu_cfg_preorder	(*(struct),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*(void))))->(int)
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
nodes	*(struct)
,	O
clos	*(void)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
clos	*(void)
->	O
end	struct(*(char),int,int)
&&	O
clos	*(void)
->	O
end	struct(*(char),int,int)
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
,	O
clos	*(void)
->	O
data	*(void)
)	O
==	O
MU_CFG_ITER_STOP	int
)	O
return	O
MU_ERR_USER0	O
;	O
break	O
;	O
case	O
MU_CFG_ITER_SKIP	int
:	O
break	O
;	O
case	O
MU_CFG_ITER_STOP	int
:	O
return	O
MU_ERR_USER0	O
;	O
}	O
break	O
;	O
case	O
mu_cfg_node_param	int
:	O
if	O
(	O
clos	*(void)
->	O
beg	struct(*(char),int,int)
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
,	O
clos	*(void)
->	O
data	*(void)
)	O
==	O
MU_CFG_ITER_STOP	int
)	O
return	O
MU_ERR_USER0	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mu_cfg_preorder	(*(struct),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*(void))))->(int)
(	O
mu_list_t	*(struct)
nodelist	*(struct)
,	O
struct	O
mu_cfg_iter_closure	struct(*((*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(void))->(int)),*((*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(void))->(int)),*(void))
*	O
clos	*(void)
)	O
{	O
if	O
(	O
!	O
nodelist	*(struct)
)	O
return	O
0	int
;	O
return	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
nodelist	*(struct)
,	O
_mu_cfg_preorder_recursive	(*(void),*(void))->(int)
,	O
clos	*(void)
)	O
;	O
}	O
void	O
mu_cfg_destroy_tree	(*(*(struct(*(struct`),*(struct`)))))->(void)
(	O
mu_cfg_tree_t	struct
*	O
*	O
ptree	*(*(struct(*(struct),*(struct))))
)	O
{	O
if	O
(	O
ptree	*(*(struct(*(struct),*(struct))))
&&	O
*	O
ptree	*(*(struct(*(struct),*(struct))))
)	O
{	O
mu_cfg_tree_t	struct
*	O
tree	*(struct(*(struct),*(struct)))
=	O
*	O
ptree	*(*(struct(*(struct),*(struct))))
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
tree	*(struct(*(struct),*(struct)))
->	O
nodes	*(struct)
)	O
;	O
mu_opool_destroy	(*(*(struct)))->(void)
(	O
&	O
tree	*(struct(*(struct),*(struct)))
->	O
pool	*(struct)
)	O
;	O
*	O
ptree	*(*(struct(*(struct),*(struct))))
=	O
NULL	O
;	O
}	O
}	O
struct	O
mu_cfg_section_list	struct(*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void))))),*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void))))
{	O
struct	O
mu_cfg_section_list	struct(*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void))))),*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void))))
*	O
next	*(struct(array(struct(array(long),int,struct(array(long)))),*(struct(array(struct(array(long),int,struct(array(long)))),*(struct`)))))
;	O
struct	O
mu_cfg_section	int
*	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
;	O
}	O
;	O
struct	O
scan_tree_data	struct(*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void))))),*(void),*(void),*(struct(*(struct),*(struct))),int)
{	O
struct	O
mu_cfg_section_list	struct(*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void))))),*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void))))
*	O
list	*(struct)
;	O
void	O
*	O
target	*(void)
;	O
void	O
*	O
call_data	*(void)
;	O
mu_cfg_tree_t	struct
*	O
tree	*(struct(*(struct),*(struct)))
;	O
int	O
error	int
;	O
}	O
;	O
static	O
struct	O
mu_cfg_cont	struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)),struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))))
*	O
find_container	(*(struct),enum(int,int),*(char),long)->(*(struct(enum(int,int),*(struct),union(*(char),struct(*`,*`,*`,*`,long,*`,*`,*`),struct(*`,int,*`,long,*`,*`,*`)))))
(	O
mu_list_t	*(struct)
list	*(struct)
,	O
enum	O
mu_cfg_cont_type	enum(int,int)
type	*(char)
,	O
const	O
char	O
*	O
ident	*(char)
,	O
size_t	long
len	long
)	O
{	O
mu_iterator_t	*(struct)
iter	*(struct)
;	O
struct	O
mu_cfg_cont	struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)),struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))))
*	O
ret	*(*(char))
=	O
NULL	O
;	O
if	O
(	O
len	long
==	O
0	int
)	O
len	long
=	O
strlen	(*(char))->(long)
(	O
ident	*(char)
)	O
;	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
list	*(struct)
,	O
&	O
iter	*(struct)
)	O
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
iter	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
iter	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
iter	*(struct)
)	O
)	O
{	O
struct	O
mu_cfg_cont	struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)),struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))))
*	O
cont	*(struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)),struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char)))))
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
iter	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cont	*(struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)),struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char)))))
)	O
;	O
if	O
(	O
cont	*(struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)),struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char)))))
->	O
type	*(char)
==	O
type	*(char)
&&	O
strlen	(*(char))->(long)
(	O
cont	*(struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)),struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char)))))
->	O
v	*(struct(int))
.	O
ident	*(char)
)	O
==	O
len	long
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
cont	*(struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)),struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char)))))
->	O
v	*(struct(int))
.	O
ident	*(char)
,	O
ident	*(char)
,	O
len	long
)	O
==	O
0	int
)	O
{	O
ret	*(*(char))
=	O
cont	*(struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)),struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char)))))
;	O
break	O
;	O
}	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
iter	*(struct)
)	O
;	O
return	O
ret	*(*(char))
;	O
}	O
static	O
struct	O
mu_cfg_section	int
*	O
find_subsection	(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))),*(char),long)->(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))))
(	O
struct	O
mu_cfg_section	int
*	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
,	O
const	O
char	O
*	O
ident	*(char)
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
)	O
{	O
if	O
(	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
children	*(struct)
)	O
{	O
struct	O
mu_cfg_cont	struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)),struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))))
*	O
cont	*(struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)),struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char)))))
=	O
find_container	(*(struct),enum(int,int),*(char),long)->(*(struct(enum(int,int),*(struct),union(*(char),struct(*`,*`,*`,*`,long,*`,*`,*`),struct(*`,int,*`,long,*`,*`,*`)))))
(	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
children	*(struct)
,	O
mu_cfg_cont_section	int
,	O
ident	*(char)
,	O
len	long
)	O
;	O
if	O
(	O
cont	*(struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)),struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char)))))
)	O
return	O
&	O
cont	*(struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)),struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char)))))
->	O
v	*(struct(int))
.	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
*	O
find_param	(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))),*(char),long)->(*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))))
(	O
struct	O
mu_cfg_section	int
*	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
,	O
const	O
char	O
*	O
ident	*(char)
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
)	O
{	O
if	O
(	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
children	*(struct)
)	O
{	O
struct	O
mu_cfg_cont	struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)),struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))))
*	O
cont	*(struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)),struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char)))))
=	O
find_container	(*(struct),enum(int,int),*(char),long)->(*(struct(enum(int,int),*(struct),union(*(char),struct(*`,*`,*`,*`,long,*`,*`,*`),struct(*`,int,*`,long,*`,*`,*`)))))
(	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
children	*(struct)
,	O
mu_cfg_cont_param	int
,	O
ident	*(char)
,	O
len	long
)	O
;	O
if	O
(	O
cont	*(struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)),struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char)))))
)	O
return	O
&	O
cont	*(struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)),struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char)))))
->	O
v	*(struct(int))
.	O
param	*(struct)
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
push_section	(*(struct(*(struct(*`,*`)),*(void),*(void),*(struct(*`,*`)),int)),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))))->(int)
(	O
struct	O
scan_tree_data	struct(*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void))))),*(void),*(void),*(struct(*(struct),*(struct))),int)
*	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
,	O
struct	O
mu_cfg_section	int
*	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
)	O
{	O
struct	O
mu_cfg_section_list	struct(*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void))))),*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void))))
*	O
p	*(char)
=	O
mu_alloc	(long)->(*(void))
(	O
sizeof	O
*	O
p	*(char)
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"not enough memory"	*(char)
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
return	O
1	int
;	O
}	O
p	*(char)
->	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
=	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
;	O
p	*(char)
->	O
next	*(struct(array(struct(array(long),int,struct(array(long)))),*(struct(array(struct(array(long),int,struct(array(long)))),*(struct`)))))
=	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
list	*(struct)
;	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
list	*(struct)
=	O
p	*(char)
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
mu_cfg_section	int
*	O
pop_section	(*(struct(*(struct(*`,*`)),*(void),*(void),*(struct(*`,*`)),int)))->(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))))
(	O
struct	O
scan_tree_data	struct(*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void))))),*(void),*(void),*(struct(*(struct),*(struct))),int)
*	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
)	O
{	O
struct	O
mu_cfg_section_list	struct(*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void))))),*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void))))
*	O
p	*(char)
=	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
list	*(struct)
;	O
struct	O
mu_cfg_section	int
*	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
=	O
p	*(char)
->	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
;	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
list	*(struct)
=	O
p	*(char)
->	O
next	*(struct(array(struct(array(long),int,struct(array(long)))),*(struct(array(struct(array(long),int,struct(array(long)))),*(struct`)))))
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
return	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
;	O
}	O
static	O
int	O
valcvt	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(void),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
const	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
void	O
*	O
tgt	*(void)
,	O
mu_c_type_t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
type	*(char)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
errmsg	*(*(char))
;	O
if	O
(	O
val	array(int)
->	O
type	*(char)
!=	O
MU_CFG_STRING	int
)	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"expected string value"	*(char)
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
mu_str_to_c	(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*(*(char)))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(*(char))
,	O
type	*(char)
,	O
tgt	*(void)
,	O
&	O
errmsg	*(*(char))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
"%s"	*(char)
,	O
errmsg	*(*(char))
?	O
errmsg	*(*(char))
:	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
errmsg	*(*(char))
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
struct	O
set_closure	struct(*(struct),int,*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))
{	O
mu_list_t	*(struct)
list	*(struct)
;	O
int	O
type	*(char)
;	O
struct	O
scan_tree_data	struct(*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void))))),*(void),*(void),*(struct(*(struct),*(struct))),int)
*	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
;	O
const	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
}	O
;	O
static	O
size_t	long
config_type_size	array(long)
[	O
]	O
=	O
{	O
[	O
mu_c_string	int
]	O
=	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
[	O
mu_c_short	int
]	O
=	O
sizeof	O
(	O
short	O
)	O
,	O
[	O
mu_c_ushort	int
]	O
=	O
sizeof	O
(	O
unsigned	O
short	O
)	O
,	O
[	O
mu_c_int	int
]	O
=	O
sizeof	O
(	O
int	O
)	O
,	O
[	O
mu_c_uint	int
]	O
=	O
sizeof	O
(	O
unsigned	O
)	O
,	O
[	O
mu_c_long	int
]	O
=	O
sizeof	O
(	O
long	O
)	O
,	O
[	O
mu_c_ulong	int
]	O
=	O
sizeof	O
(	O
unsigned	O
long	O
)	O
,	O
[	O
mu_c_size	int
]	O
=	O
sizeof	O
(	O
size_t	long
)	O
,	O
[	O
mu_c_time	int
]	O
=	O
sizeof	O
(	O
time_t	long
)	O
,	O
[	O
mu_c_bool	int
]	O
=	O
sizeof	O
(	O
int	O
)	O
,	O
[	O
mu_c_ipv4	int
]	O
=	O
sizeof	O
(	O
struct	O
in_addr	struct(int)
)	O
,	O
[	O
mu_c_cidr	int
]	O
=	O
sizeof	O
(	O
struct	O
mu_cidr	struct(int,int,array(char),array(char))
)	O
,	O
[	O
mu_c_host	int
]	O
=	O
sizeof	O
(	O
struct	O
in_addr	struct(int)
)	O
,	O
}	O
;	O
static	O
int	O
_set_fun	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
mu_config_value_t	struct
*	O
val	array(int)
=	O
item	*(void)
;	O
struct	O
set_closure	struct(*(struct),int,*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))
*	O
clos	*(void)
=	O
data	*(void)
;	O
void	O
*	O
tgt	*(void)
;	O
size_t	long
size	long
;	O
if	O
(	O
(	O
size_t	long
)	O
clos	*(void)
->	O
type	*(char)
>=	O
MU_ARRAY_SIZE	O
(	O
config_type_size	array(long)
)	O
||	O
(	O
size	long
=	O
config_type_size	array(long)
[	O
clos	*(void)
->	O
type	*(char)
]	O
)	O
==	O
0	int
)	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_EMERG	int
,	O
clos	*(void)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: unhandled data type %d"	*(char)
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
clos	*(void)
->	O
type	*(char)
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
return	O
1	int
;	O
}	O
tgt	*(void)
=	O
mu_alloc	(long)->(*(void))
(	O
size	long
)	O
;	O
if	O
(	O
!	O
tgt	*(void)
)	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
clos	*(void)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"not enough memory"	*(char)
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
valcvt	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(void),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
clos	*(void)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
&	O
tgt	*(void)
,	O
clos	*(void)
->	O
type	*(char)
,	O
val	array(int)
)	O
==	O
0	int
)	O
mu_list_append	(*(struct),*(void))->(int)
(	O
clos	*(void)
->	O
list	*(struct)
,	O
tgt	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_param	(*(struct(*(struct(*`,*`)),*(void),*(void),*(struct(*`,*`)),int)),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))->(int)
(	O
struct	O
scan_tree_data	struct(*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void))))),*(void),*(void),*(struct(*(struct),*(struct))),int)
*	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
,	O
const	O
mu_cfg_node_t	struct
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
void	O
*	O
tgt	*(void)
;	O
struct	O
set_closure	struct(*(struct),int,*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))
clos	*(void)
;	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
*	O
param	*(struct)
=	O
find_param	(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))),*(char),long)->(*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))))
(	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
list	*(struct)
->	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
tag	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
param	*(struct)
)	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
&	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"unknown keyword `%s'"	*(char)
)	O
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
tag	*(char)
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
param	*(struct)
->	O
data	*(void)
)	O
tgt	*(void)
=	O
param	*(struct)
->	O
data	*(void)
;	O
else	O
if	O
(	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
list	*(struct)
->	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
target	*(void)
)	O
tgt	*(void)
=	O
(	O
char	O
*	O
)	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
list	*(struct)
->	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
target	*(void)
+	O
param	*(struct)
->	O
offset	long
;	O
else	O
if	O
(	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
target	*(void)
)	O
tgt	*(void)
=	O
(	O
char	O
*	O
)	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
target	*(void)
+	O
param	*(struct)
->	O
offset	long
;	O
else	O
if	O
(	O
param	*(struct)
->	O
type	*(char)
==	O
mu_cfg_callback	int
)	O
tgt	*(void)
=	O
NULL	O
;	O
else	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_EMERG	int
,	O
&	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"INTERNAL ERROR: cannot determine target offset for "	*(char)
"%s"	*(char)
)	O
,	O
param	*(struct)
->	O
ident	*(char)
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
clos	*(void)
,	O
0	int
,	O
sizeof	O
clos	*(void)
)	O
;	O
clos	*(void)
.	O
type	*(char)
=	O
MU_CFG_TYPE	O
(	O
param	*(struct)
->	O
type	*(char)
)	O
;	O
if	O
(	O
MU_CFG_IS_LIST	O
(	O
param	*(struct)
->	O
type	*(char)
)	O
)	O
{	O
clos	*(void)
.	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
=	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
;	O
clos	*(void)
.	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
=	O
&	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
switch	O
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
->	O
type	*(char)
)	O
{	O
case	O
MU_CFG_LIST	int
:	O
break	O
;	O
case	O
MU_CFG_STRING	int
:	O
{	O
mu_list_t	*(struct)
list	*(struct)
;	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
list	*(struct)
)	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
list	*(struct)
,	O
config_value_dup	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
)	O
;	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
->	O
type	*(char)
=	O
MU_CFG_LIST	int
;	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
->	O
v	*(struct(int))
.	O
list	*(struct)
=	O
list	*(struct)
;	O
}	O
break	O
;	O
case	O
MU_CFG_ARRAY	int
:	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
&	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"expected list, but found array"	*(char)
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
return	O
1	int
;	O
}	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
clos	*(void)
.	O
list	*(struct)
)	O
;	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
->	O
v	*(struct(int))
.	O
list	*(struct)
,	O
_set_fun	(*(void),*(void))->(int)
,	O
&	O
clos	*(void)
)	O
;	O
*	O
(	O
mu_list_t	*(struct)
*	O
)	O
tgt	*(void)
=	O
clos	*(void)
.	O
list	*(struct)
;	O
}	O
else	O
if	O
(	O
clos	*(void)
.	O
type	*(char)
==	O
mu_cfg_callback	int
)	O
{	O
if	O
(	O
!	O
param	*(struct)
->	O
callback	*((*(void),*(struct(int,union(*`,*`,struct`))))->(int))
)	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_EMERG	int
,	O
&	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"INTERNAL ERROR: %s: callback not defined"	*(char)
)	O
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
tag	*(char)
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
(	O
void	O
*	O
)	O
&	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
if	O
(	O
param	*(struct)
->	O
callback	*((*(void),*(struct(int,union(*`,*`,struct`))))->(int))
(	O
tgt	*(void)
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
)	O
return	O
1	int
;	O
}	O
else	O
return	O
valcvt	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(void),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
&	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
tgt	*(void)
,	O
clos	*(void)
.	O
type	*(char)
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_scan_tree_helper	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(void))->(int)
(	O
const	O
mu_cfg_node_t	struct
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
scan_tree_data	struct(*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void))))),*(void),*(void),*(struct(*(struct),*(struct))),int)
*	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
=	O
data	*(void)
;	O
struct	O
mu_cfg_section	int
*	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
;	O
switch	O
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
type	*(char)
)	O
{	O
case	O
mu_cfg_node_undefined	int
:	O
abort	()->(void)
(	O
)	O
;	O
case	O
mu_cfg_node_statement	int
:	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
=	O
find_subsection	(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))),*(char),long)->(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))))
(	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
list	*(struct)
->	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
tag	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
)	O
{	O
if	O
(	O
mu_cfg_parser_verbose	int
)	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_WARNING	int
,	O
&	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"unknown section `%s'"	*(char)
)	O
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
tag	*(char)
)	O
;	O
}	O
return	O
MU_CFG_ITER_SKIP	int
;	O
}	O
if	O
(	O
!	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
children	*(struct)
)	O
return	O
MU_CFG_ITER_SKIP	int
;	O
if	O
(	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
data	*(void)
)	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
target	*(void)
=	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
data	*(void)
;	O
else	O
if	O
(	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
list	*(struct)
->	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
target	*(void)
)	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
target	*(void)
=	O
(	O
char	O
*	O
)	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
list	*(struct)
->	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
target	*(void)
+	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
offset	long
;	O
else	O
if	O
(	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
target	*(void)
)	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
target	*(void)
=	O
(	O
char	O
*	O
)	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
target	*(void)
+	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
offset	long
;	O
else	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
target	*(void)
=	O
NULL	O
;	O
if	O
(	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
parser	*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int))
)	O
{	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
(	O
void	O
*	O
)	O
&	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
if	O
(	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
parser	*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int))
(	O
mu_cfg_section_start	int
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
,	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
,	O
&	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
target	*(void)
,	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
call_data	*(void)
,	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
tree	*(struct(*(struct),*(struct)))
)	O
)	O
{	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
error	int
++	O
;	O
return	O
MU_CFG_ITER_SKIP	int
;	O
}	O
}	O
push_section	(*(struct(*(struct(*`,*`)),*(void),*(void),*(struct(*`,*`)),int)),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))))->(int)
(	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
,	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
)	O
;	O
break	O
;	O
case	O
mu_cfg_node_param	int
:	O
if	O
(	O
parse_param	(*(struct(*(struct(*`,*`)),*(void),*(void),*(struct(*`,*`)),int)),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))->(int)
(	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
)	O
{	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
error	int
++	O
;	O
return	O
MU_CFG_ITER_SKIP	int
;	O
}	O
break	O
;	O
}	O
return	O
MU_CFG_ITER_OK	int
;	O
}	O
static	O
int	O
_scan_tree_end_helper	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(void))->(int)
(	O
const	O
mu_cfg_node_t	struct
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
scan_tree_data	struct(*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void))))),*(void),*(void),*(struct(*(struct),*(struct))),int)
*	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
=	O
data	*(void)
;	O
struct	O
mu_cfg_section	int
*	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
;	O
switch	O
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
type	*(char)
)	O
{	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
case	O
mu_cfg_node_statement	int
:	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
=	O
pop_section	(*(struct(*(struct(*`,*`)),*(void),*(void),*(struct(*`,*`)),int)))->(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))))
(	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
)	O
;	O
if	O
(	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
&&	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
parser	*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int))
)	O
{	O
if	O
(	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
parser	*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int))
(	O
mu_cfg_section_end	int
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
,	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
,	O
&	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
->	O
target	*(void)
,	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
call_data	*(void)
,	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
tree	*(struct(*(struct),*(struct)))
)	O
)	O
{	O
sdata	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
->	O
error	int
++	O
;	O
return	O
MU_CFG_ITER_SKIP	int
;	O
}	O
}	O
}	O
return	O
MU_CFG_ITER_OK	int
;	O
}	O
int	O
mu_cfg_scan_tree	(*(struct(*(struct),*(struct))),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))),*(void),*(void))->(int)
(	O
mu_cfg_tree_t	struct
*	O
tree	*(struct(*(struct),*(struct)))
,	O
struct	O
mu_cfg_section	int
*	O
sections	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
,	O
void	O
*	O
target	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
scan_tree_data	struct(*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void))))),*(void),*(void),*(struct(*(struct),*(struct))),int)
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
;	O
struct	O
mu_cfg_iter_closure	struct(*((*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(void))->(int)),*((*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(void))->(int)),*(void))
clos	*(void)
;	O
int	O
save_mode	int
=	O
0	int
,	O
mode	int
;	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
save_locus	struct(struct(*(char),int,int),struct(*(char),int,int))
=	O
MU_LOCUS_RANGE_INITIALIZER	O
;	O
int	O
rc	int
;	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
.	O
tree	*(struct(*(struct),*(struct)))
=	O
tree	*(struct(*(struct),*(struct)))
;	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
.	O
list	*(struct)
=	O
NULL	O
;	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
.	O
error	int
=	O
0	int
;	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
.	O
call_data	*(void)
=	O
data	*(void)
;	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
.	O
target	*(void)
=	O
target	*(void)
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_GET_MODE	int
,	O
&	O
save_mode	int
)	O
;	O
mode	int
=	O
save_mode	int
|	O
MU_LOGMODE_LOCUS	int
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_MODE	int
,	O
&	O
mode	int
)	O
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_GET_LOCUS_RANGE	int
,	O
&	O
save_locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
if	O
(	O
push_section	(*(struct(*(struct(*`,*`)),*(void),*(void),*(struct(*`,*`)),int)),*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))))->(int)
(	O
&	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
,	O
sections	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
)	O
)	O
return	O
1	int
;	O
clos	*(void)
.	O
beg	struct(*(char),int,int)
=	O
_scan_tree_helper	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(void))->(int)
;	O
clos	*(void)
.	O
end	struct(*(char),int,int)
=	O
_scan_tree_end_helper	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(void))->(int)
;	O
clos	*(void)
.	O
data	*(void)
=	O
&	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
;	O
rc	int
=	O
mu_cfg_preorder	(*(struct),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*(void))))->(int)
(	O
tree	*(struct(*(struct),*(struct)))
->	O
nodes	*(struct)
,	O
&	O
clos	*(void)
)	O
;	O
pop_section	(*(struct(*(struct(*`,*`)),*(void),*(void),*(struct(*`,*`)),int)))->(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))))
(	O
&	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
)	O
;	O
if	O
(	O
rc	int
&&	O
rc	int
!=	O
MU_ERR_USER0	O
)	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
.	O
error	int
++	O
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_MODE	int
,	O
&	O
save_mode	int
)	O
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
&	O
save_locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
return	O
dat	*(struct(*(struct(*(struct`),*(struct`))),*(void),*(void),*(struct(*(struct`),*(struct`))),int))
.	O
error	int
;	O
}	O
int	O
mu_cfg_find_section	(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))),*(char),*(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)))))->(int)
(	O
struct	O
mu_cfg_section	int
*	O
root_sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
,	O
const	O
char	O
*	O
path	*(char)
,	O
struct	O
mu_cfg_section	int
*	O
*	O
retval	*(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))))
)	O
{	O
while	O
(	O
path	*(char)
[	O
0	int
]	O
)	O
{	O
struct	O
mu_cfg_section	int
*	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
;	O
size_t	long
len	long
;	O
const	O
char	O
*	O
p	*(char)
;	O
while	O
(	O
*	O
path	*(char)
==	O
MU_CFG_PATH_DELIM	char
)	O
path	*(char)
++	O
;	O
if	O
(	O
*	O
path	*(char)
==	O
0	int
)	O
return	O
MU_ERR_NOENT	O
;	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
path	*(char)
,	O
MU_CFG_PATH_DELIM	char
)	O
;	O
if	O
(	O
p	*(char)
)	O
len	long
=	O
p	*(char)
-	O
path	*(char)
;	O
else	O
len	long
=	O
strlen	(*(char))->(long)
(	O
path	*(char)
)	O
;	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
=	O
find_subsection	(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))),*(char),long)->(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))))
(	O
root_sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
,	O
path	*(char)
,	O
len	long
)	O
;	O
if	O
(	O
!	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
)	O
return	O
MU_ERR_NOENT	O
;	O
root_sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
=	O
sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
;	O
path	*(char)
+=	O
len	long
;	O
}	O
if	O
(	O
retval	*(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))))
)	O
*	O
retval	*(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))))
=	O
root_sec	*(struct(*(char),*(char),*((enum(int,int),*(struct`),*(char),*(*`),*(void),*(struct`))->(int)),*(void),long,*(struct),*(char),*(void)))
;	O
return	O
0	int
;	O
}	O
int	O
mu_cfg_tree_create	(*(*(struct(*(struct`),*(struct`)))))->(int)
(	O
struct	O
mu_cfg_tree	struct(*(struct),*(struct))
*	O
*	O
ptree	*(*(struct(*(struct),*(struct))))
)	O
{	O
struct	O
mu_cfg_tree	struct(*(struct),*(struct))
*	O
tree	*(struct(*(struct),*(struct)))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
*	O
tree	*(struct(*(struct),*(struct)))
)	O
;	O
if	O
(	O
!	O
tree	*(struct(*(struct),*(struct)))
)	O
return	O
errno	O
;	O
mu_opool_create	(*(*(struct)),int)->(int)
(	O
&	O
tree	*(struct(*(struct),*(struct)))
->	O
pool	*(struct)
,	O
MU_OPOOL_ENOMEMABRT	int
)	O
;	O
*	O
ptree	*(*(struct(*(struct),*(struct))))
=	O
tree	*(struct(*(struct),*(struct)))
;	O
return	O
0	int
;	O
}	O
mu_cfg_node_t	struct
*	O
mu_cfg_tree_create_node	(*(struct(*(struct),*(struct))),enum(int,int,int),*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char),*(char),*(struct))->(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
(	O
struct	O
mu_cfg_tree	struct(*(struct),*(struct))
*	O
tree	*(struct(*(struct),*(struct)))
,	O
enum	O
mu_cfg_node_type	enum(int,int,int)
type	*(char)
,	O
const	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
const	O
char	O
*	O
tag	*(char)
,	O
const	O
char	O
*	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
,	O
mu_list_t	*(struct)
nodelist	*(struct)
)	O
{	O
char	O
*	O
p	*(char)
;	O
mu_cfg_node_t	struct
*	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
size_t	long
size	long
=	O
sizeof	O
*	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
+	O
strlen	(*(char))->(long)
(	O
tag	*(char)
)	O
+	O
1	int
;	O
mu_config_value_t	struct
val	array(int)
;	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
mu_alloc	(long)->(*(void))
(	O
size	long
)	O
;	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
type	*(char)
=	O
type	*(char)
;	O
mu_locus_range_init	(*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
&	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
if	O
(	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
mu_locus_range_copy	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
&	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
p	*(char)
=	O
(	O
char	O
*	O
)	O
(	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
+	O
1	int
)	O
;	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
tag	*(char)
=	O
p	*(char)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(char)
,	O
tag	*(char)
)	O
;	O
p	*(char)
+=	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
+	O
1	int
;	O
val	array(int)
.	O
type	*(char)
=	O
MU_CFG_STRING	int
;	O
if	O
(	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
{	O
mu_opool_clear	(*(struct))->(void)
(	O
tree	*(struct(*(struct),*(struct)))
->	O
pool	*(struct)
)	O
;	O
mu_opool_appendz	(*(struct),*(char))->(int)
(	O
tree	*(struct(*(struct),*(struct)))
->	O
pool	*(struct)
,	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
;	O
mu_opool_append_char	(*(struct),char)->(int)
(	O
tree	*(struct(*(struct),*(struct)))
->	O
pool	*(struct)
,	O
0	int
)	O
;	O
val	array(int)
.	O
v	*(struct(int))
.	O
string	*(*(char))
=	O
mu_opool_finish	(*(struct),*(long))->(*(void))
(	O
tree	*(struct(*(struct),*(struct)))
->	O
pool	*(struct)
,	O
NULL	O
)	O
;	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
=	O
config_value_dup	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))
(	O
&	O
val	array(int)
)	O
;	O
}	O
else	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
=	O
NULL	O
;	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
nodes	*(struct)
=	O
nodelist	*(struct)
;	O
return	O
np	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
void	O
mu_cfg_tree_add_node	(*(struct(*(struct),*(struct))),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))->(void)
(	O
mu_cfg_tree_t	struct
*	O
tree	*(struct(*(struct),*(struct)))
,	O
mu_cfg_node_t	struct
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
if	O
(	O
!	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
return	O
;	O
if	O
(	O
!	O
tree	*(struct(*(struct),*(struct)))
->	O
nodes	*(struct)
)	O
mu_cfg_create_node_list	(*(*(struct)))->(int)
(	O
&	O
tree	*(struct(*(struct),*(struct)))
->	O
nodes	*(struct)
)	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
tree	*(struct(*(struct),*(struct)))
->	O
nodes	*(struct)
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
}	O
void	O
mu_cfg_tree_add_nodelist	(*(struct(*(struct),*(struct))),*(struct))->(void)
(	O
mu_cfg_tree_t	struct
*	O
tree	*(struct(*(struct),*(struct)))
,	O
mu_list_t	*(struct)
nodelist	*(struct)
)	O
{	O
if	O
(	O
!	O
nodelist	*(struct)
)	O
return	O
;	O
if	O
(	O
!	O
tree	*(struct(*(struct),*(struct)))
->	O
nodes	*(struct)
)	O
mu_cfg_create_node_list	(*(*(struct)))->(int)
(	O
&	O
tree	*(struct(*(struct),*(struct)))
->	O
nodes	*(struct)
)	O
;	O
mu_list_append_list	(*(struct),*(struct))->(void)
(	O
tree	*(struct(*(struct),*(struct)))
->	O
nodes	*(struct)
,	O
nodelist	*(struct)
)	O
;	O
}	O
int	O
mu_cfg_value_eq	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
mu_config_value_t	struct
*	O
a	*(struct(*(char),int,int))
,	O
mu_config_value_t	struct
*	O
b	*(struct(*(char),int,int))
)	O
{	O
if	O
(	O
a	*(struct(*(char),int,int))
->	O
type	*(char)
!=	O
b	*(struct(*(char),int,int))
->	O
type	*(char)
)	O
return	O
0	int
;	O
switch	O
(	O
a	*(struct(*(char),int,int))
->	O
type	*(char)
)	O
{	O
case	O
MU_CFG_STRING	int
:	O
if	O
(	O
a	*(struct(*(char),int,int))
->	O
v	*(struct(int))
.	O
string	*(*(char))
==	O
NULL	O
)	O
return	O
b	*(struct(*(char),int,int))
->	O
v	*(struct(int))
.	O
string	*(*(char))
==	O
NULL	O
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
a	*(struct(*(char),int,int))
->	O
v	*(struct(int))
.	O
string	*(*(char))
,	O
b	*(struct(*(char),int,int))
->	O
v	*(struct(int))
.	O
string	*(*(char))
)	O
==	O
0	int
;	O
case	O
MU_CFG_LIST	int
:	O
{	O
int	O
ret	*(*(char))
=	O
1	int
;	O
size_t	long
cnt	long
;	O
size_t	long
i	long
;	O
mu_iterator_t	*(struct)
aitr	*(struct)
,	O
bitr	*(struct)
;	O
mu_list_count	(*(struct),*(long))->(int)
(	O
a	*(struct(*(char),int,int))
->	O
v	*(struct(int))
.	O
list	*(struct)
,	O
&	O
cnt	long
)	O
;	O
mu_list_count	(*(struct),*(long))->(int)
(	O
b	*(struct(*(char),int,int))
->	O
v	*(struct(int))
.	O
list	*(struct)
,	O
&	O
i	long
)	O
;	O
if	O
(	O
i	long
!=	O
cnt	long
)	O
return	O
1	int
;	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
a	*(struct(*(char),int,int))
->	O
v	*(struct(int))
.	O
list	*(struct)
,	O
&	O
aitr	*(struct)
)	O
;	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
b	*(struct(*(char),int,int))
->	O
v	*(struct(int))
.	O
list	*(struct)
,	O
&	O
bitr	*(struct)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
,	O
mu_iterator_first	(*(struct))->(int)
(	O
aitr	*(struct)
)	O
,	O
mu_iterator_first	(*(struct))->(int)
(	O
bitr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
aitr	*(struct)
)	O
&&	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
bitr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
aitr	*(struct)
)	O
,	O
mu_iterator_next	(*(struct))->(int)
(	O
bitr	*(struct)
)	O
,	O
i	long
++	O
)	O
{	O
mu_config_value_t	struct
*	O
ap	array(struct(int,int,*(void),*(void)))
,	O
*	O
bp	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
aitr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
bitr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
bp	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
;	O
ret	*(*(char))
=	O
mu_cfg_value_eq	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
bp	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
;	O
if	O
(	O
!	O
ret	*(*(char))
)	O
break	O
;	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
aitr	*(struct)
)	O
;	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
bitr	*(struct)
)	O
;	O
return	O
ret	*(*(char))
&&	O
i	long
==	O
cnt	long
;	O
}	O
case	O
MU_CFG_ARRAY	int
:	O
if	O
(	O
a	*(struct(*(char),int,int))
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
c	int
==	O
b	*(struct(*(char),int,int))
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
c	int
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
a	*(struct(*(char),int,int))
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
c	int
;	O
i	long
++	O
)	O
if	O
(	O
!	O
mu_cfg_value_eq	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
&	O
a	*(struct(*(char),int,int))
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
[	O
i	long
]	O
,	O
&	O
b	*(struct(*(char),int,int))
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
[	O
i	long
]	O
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
split_cfg_path	(*(char),*(int),*(*(*(char))))->(int)
(	O
const	O
char	O
*	O
path	*(char)
,	O
int	O
*	O
pargc	*(int)
,	O
char	O
*	O
*	O
*	O
pargv	*(*(*(char)))
)	O
{	O
int	O
argc	long
;	O
char	O
*	O
*	O
argv	*(*(char))
;	O
char	O
*	O
delim	*(char)
=	O
MU_CFG_PATH_DELIM_STR	*(char)
;	O
char	O
static_delim	array(char)
[	O
2	int
]	O
=	O
{	O
0	int
,	O
0	int
}	O
;	O
if	O
(	O
path	*(char)
[	O
0	int
]	O
==	O
'\\'	O
)	O
{	O
argv	*(*(char))
=	O
calloc	(long,long)->(*(void))
(	O
2	int
,	O
sizeof	O
(	O
*	O
argv	*(*(char))
)	O
)	O
;	O
if	O
(	O
!	O
argv	*(*(char))
)	O
return	O
ENOMEM	int
;	O
argv	*(*(char))
[	O
0	int
]	O
=	O
strdup	(*(char))->(*(char))
(	O
path	*(char)
+	O
1	int
)	O
;	O
if	O
(	O
!	O
argv	*(*(char))
[	O
0	int
]	O
)	O
{	O
free	(*(void))->(void)
(	O
argv	*(*(char))
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
argv	*(*(char))
[	O
1	int
]	O
=	O
NULL	O
;	O
argc	long
=	O
1	int
;	O
}	O
else	O
{	O
struct	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
if	O
(	O
mu_ispunct	O
(	O
path	*(char)
[	O
0	int
]	O
)	O
)	O
{	O
delim	*(char)
=	O
static_delim	array(char)
;	O
delim	*(char)
[	O
0	int
]	O
=	O
path	*(char)
[	O
0	int
]	O
;	O
path	*(char)
++	O
;	O
}	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_delim	*(char)
=	O
delim	*(char)
;	O
if	O
(	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
path	*(char)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
MU_WRDSF_DEFFLAGS	O
|	O
MU_WRDSF_DELIM	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot split line `%s': %s"	*(char)
)	O
,	O
path	*(char)
,	O
mu_wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
;	O
return	O
errno	O
;	O
}	O
argc	long
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
;	O
argv	*(*(char))
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
=	O
0	int
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
=	O
NULL	O
;	O
mu_wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
}	O
*	O
pargc	*(int)
=	O
argc	long
;	O
*	O
pargv	*(*(*(char)))
=	O
argv	*(*(char))
;	O
return	O
0	int
;	O
}	O
struct	O
find_data	struct(int,*(*(char)),int,*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))))
{	O
int	O
argc	long
;	O
char	O
*	O
*	O
argv	*(*(char))
;	O
int	O
tag	*(char)
;	O
mu_config_value_t	struct
*	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
;	O
const	O
mu_cfg_node_t	struct
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
;	O
static	O
void	O
free_value_mem	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(void)
(	O
mu_config_value_t	struct
*	O
p	*(char)
)	O
{	O
switch	O
(	O
p	*(char)
->	O
type	*(char)
)	O
{	O
case	O
MU_CFG_STRING	int
:	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
p	*(char)
->	O
v	*(struct(int))
.	O
string	*(*(char))
)	O
;	O
break	O
;	O
case	O
MU_CFG_LIST	int
:	O
break	O
;	O
case	O
MU_CFG_ARRAY	int
:	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
p	*(char)
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
c	int
;	O
i	long
++	O
)	O
free_value_mem	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(void)
(	O
&	O
p	*(char)
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
[	O
i	long
]	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
destroy_value	(*(void))->(void)
(	O
void	O
*	O
p	*(char)
)	O
{	O
mu_config_value_t	struct
*	O
val	array(int)
=	O
p	*(char)
;	O
if	O
(	O
val	array(int)
)	O
{	O
free_value_mem	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(void)
(	O
val	array(int)
)	O
;	O
free	(*(void))->(void)
(	O
val	array(int)
)	O
;	O
}	O
}	O
static	O
mu_config_value_t	struct
*	O
parse_label	(*(char))->(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
mu_config_value_t	struct
*	O
val	array(int)
=	O
NULL	O
;	O
size_t	long
i	long
;	O
struct	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
;	O
if	O
(	O
len	long
>	O
1	int
&&	O
str	*(char)
[	O
0	int
]	O
==	O
'('	O
&&	O
str	*(char)
[	O
len	long
-	O
1	int
]	O
==	O
')'	O
)	O
{	O
mu_list_t	*(struct)
lst	*(struct)
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_delim	*(char)
=	O
","	*(char)
;	O
if	O
(	O
mu_wordsplit_len	(*(char),long,*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)),int)->(int)
(	O
str	*(char)
+	O
1	int
,	O
len	long
-	O
2	int
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
MU_WRDSF_DEFFLAGS	O
|	O
MU_WRDSF_DELIM	O
|	O
MU_WRDSF_WS	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot split line `%s': %s"	*(char)
)	O
,	O
str	*(char)
,	O
mu_wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
lst	*(struct)
)	O
;	O
mu_list_set_destroy_item	(*(struct),*((*(void))->(void)))->(*((*(void))->(void)))
(	O
lst	*(struct)
,	O
destroy_value	(*(void))->(void)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
;	O
i	long
++	O
)	O
{	O
mu_config_value_t	struct
*	O
p	*(char)
=	O
mu_alloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
p	*(char)
)	O
)	O
;	O
p	*(char)
->	O
type	*(char)
=	O
MU_CFG_STRING	int
;	O
p	*(char)
->	O
v	*(struct(int))
.	O
string	*(*(char))
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	long
]	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
lst	*(struct)
,	O
p	*(char)
)	O
;	O
}	O
val	array(int)
=	O
mu_alloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
val	array(int)
)	O
)	O
;	O
val	array(int)
->	O
type	*(char)
=	O
MU_CFG_LIST	int
;	O
val	array(int)
->	O
v	*(struct(int))
.	O
list	*(struct)
=	O
lst	*(struct)
;	O
}	O
else	O
{	O
if	O
(	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
str	*(char)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
MU_WRDSF_DEFFLAGS	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot split line `%s': %s"	*(char)
)	O
,	O
str	*(char)
,	O
mu_wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
val	array(int)
=	O
mu_alloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
val	array(int)
)	O
)	O
;	O
if	O
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
==	O
1	int
)	O
{	O
val	array(int)
->	O
type	*(char)
=	O
MU_CFG_STRING	int
;	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(*(char))
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
;	O
}	O
else	O
{	O
val	array(int)
->	O
type	*(char)
=	O
MU_CFG_ARRAY	int
;	O
val	array(int)
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
c	int
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
;	O
val	array(int)
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
=	O
mu_alloc	(long)->(*(void))
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
*	O
sizeof	O
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
;	O
i	long
++	O
)	O
{	O
val	array(int)
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
[	O
i	long
]	O
.	O
type	*(char)
=	O
MU_CFG_STRING	int
;	O
val	array(int)
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
[	O
i	long
]	O
.	O
v	*(struct(int))
.	O
string	*(*(char))
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	long
]	O
;	O
}	O
}	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
=	O
0	int
;	O
mu_wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
}	O
return	O
val	array(int)
;	O
}	O
static	O
void	O
parse_tag	(*(struct(int,*(*(char)),int,*(struct(int,union`)),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))->(void)
(	O
struct	O
find_data	struct(int,*(*(char)),int,*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))))
*	O
fptr	*(int)
)	O
{	O
char	O
*	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
fptr	*(int)
->	O
argv	*(*(char))
[	O
fptr	*(int)
->	O
tag	*(char)
]	O
,	O
'='	O
)	O
;	O
if	O
(	O
p	*(char)
)	O
{	O
*	O
p	*(char)
++	O
=	O
0	int
;	O
fptr	*(int)
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
=	O
parse_label	(*(char))->(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))
(	O
p	*(char)
)	O
;	O
}	O
else	O
fptr	*(int)
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
=	O
NULL	O
;	O
}	O
static	O
int	O
node_finder	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(void))->(int)
(	O
const	O
mu_cfg_node_t	struct
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
find_data	struct(int,*(*(char)),int,*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))))
*	O
fdptr	*(struct(int,*(*(char)),int,*(struct(int,union(*`,*`,struct`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
data	*(void)
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
fdptr	*(struct(int,*(*(char)),int,*(struct(int,union(*`,*`,struct`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
argv	*(*(char))
[	O
fdptr	*(struct(int,*(*(char)),int,*(struct(int,union(*`,*`,struct`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
tag	*(char)
]	O
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
tag	*(char)
)	O
==	O
0	int
&&	O
(	O
!	O
fdptr	*(struct(int,*(*(char)),int,*(struct(int,union(*`,*`,struct`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
||	O
mu_cfg_value_eq	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
fdptr	*(struct(int,*(*(char)),int,*(struct(int,union(*`,*`,struct`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
)	O
)	O
{	O
fdptr	*(struct(int,*(*(char)),int,*(struct(int,union(*`,*`,struct`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
tag	*(char)
++	O
;	O
if	O
(	O
fdptr	*(struct(int,*(*(char)),int,*(struct(int,union(*`,*`,struct`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
tag	*(char)
==	O
fdptr	*(struct(int,*(*(char)),int,*(struct(int,union(*`,*`,struct`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
argc	long
)	O
{	O
fdptr	*(struct(int,*(*(char)),int,*(struct(int,union(*`,*`,struct`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
return	O
MU_CFG_ITER_STOP	int
;	O
}	O
parse_tag	(*(struct(int,*(*(char)),int,*(struct(int,union`)),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))->(void)
(	O
fdptr	*(struct(int,*(*(char)),int,*(struct(int,union(*`,*`,struct`))),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
return	O
MU_CFG_ITER_OK	int
;	O
}	O
return	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
type	*(char)
==	O
mu_cfg_node_statement	int
?	O
MU_CFG_ITER_SKIP	int
:	O
MU_CFG_ITER_OK	int
;	O
}	O
int	O
mu_cfg_find_node	(*(struct(*(struct),*(struct))),*(char),*(*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))->(int)
(	O
mu_cfg_tree_t	struct
*	O
tree	*(struct(*(struct),*(struct)))
,	O
const	O
char	O
*	O
path	*(char)
,	O
mu_cfg_node_t	struct
*	O
*	O
pval	*(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
)	O
{	O
int	O
rc	int
;	O
struct	O
find_data	struct(int,*(*(char)),int,*(struct(int,union(*(struct),*(char),struct(long,*(struct`))))),*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))))))
data	*(void)
;	O
rc	int
=	O
split_cfg_path	(*(char),*(int),*(*(*(char))))->(int)
(	O
path	*(char)
,	O
&	O
data	*(void)
.	O
argc	long
,	O
&	O
data	*(void)
.	O
argv	*(*(char))
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
data	*(void)
.	O
tag	*(char)
=	O
0	int
;	O
if	O
(	O
data	*(void)
.	O
argc	long
)	O
{	O
struct	O
mu_cfg_iter_closure	struct(*((*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(void))->(int)),*((*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(void))->(int)),*(void))
clos	*(void)
;	O
parse_tag	(*(struct(int,*(*(char)),int,*(struct(int,union`)),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))->(void)
(	O
&	O
data	*(void)
)	O
;	O
clos	*(void)
.	O
beg	struct(*(char),int,int)
=	O
node_finder	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(void))->(int)
;	O
clos	*(void)
.	O
end	struct(*(char),int,int)
=	O
NULL	O
;	O
clos	*(void)
.	O
data	*(void)
=	O
&	O
data	*(void)
;	O
rc	int
=	O
mu_cfg_preorder	(*(struct),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*(void))))->(int)
(	O
tree	*(struct(*(struct),*(struct)))
->	O
nodes	*(struct)
,	O
&	O
clos	*(void)
)	O
;	O
destroy_value	(*(void))->(void)
(	O
data	*(void)
.	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
)	O
;	O
if	O
(	O
rc	int
==	O
MU_ERR_USER0	O
)	O
{	O
*	O
pval	*(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
=	O
(	O
mu_cfg_node_t	struct
*	O
)	O
data	*(void)
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
rc	int
!=	O
0	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERR	O
,	O
"mu_cfg_preorder"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
}	O
return	O
MU_ERR_NOENT	O
;	O
}	O
int	O
mu_cfg_create_subtree	(*(char),*(*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))->(int)
(	O
const	O
char	O
*	O
path	*(char)
,	O
mu_cfg_node_t	struct
*	O
*	O
pnode	*(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
)	O
{	O
int	O
rc	int
;	O
int	O
argc	long
,	O
i	long
;	O
char	O
*	O
*	O
argv	*(*(char))
;	O
enum	O
mu_cfg_node_type	enum(int,int,int)
type	*(char)
;	O
mu_cfg_node_t	struct
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
=	O
MU_LOCUS_RANGE_INITIALIZER	O
;	O
rc	int
=	O
split_cfg_path	(*(char),*(int),*(*(*(char))))->(int)
(	O
path	*(char)
,	O
&	O
argc	long
,	O
&	O
argv	*(*(char))
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
for	O
(	O
i	long
=	O
argc	long
-	O
1	int
;	O
i	long
>=	O
0	int
;	O
i	long
--	O
)	O
{	O
mu_list_t	*(struct)
nodelist	*(struct)
=	O
NULL	O
;	O
mu_config_value_t	struct
*	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
=	O
NULL	O
;	O
char	O
*	O
q	*(char)
=	O
argv	*(*(char))
[	O
i	long
]	O
,	O
*	O
p	*(char)
;	O
mu_cfg_node_t	struct
*	O
parent	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
type	*(char)
=	O
mu_cfg_node_statement	int
;	O
do	O
{	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
q	*(char)
,	O
'='	O
)	O
;	O
if	O
(	O
p	*(char)
&&	O
p	*(char)
>	O
argv	*(*(char))
[	O
i	long
]	O
&&	O
p	*(char)
[	O
-	O
1	int
]	O
!=	O
'\\'	O
)	O
{	O
*	O
p	*(char)
++	O
=	O
0	int
;	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
=	O
parse_label	(*(char))->(*(struct(int,union(*(struct`),*(char),struct(long,*`)))))
(	O
p	*(char)
)	O
;	O
if	O
(	O
i	long
==	O
argc	long
-	O
1	int
)	O
type	*(char)
=	O
mu_cfg_node_param	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
p	*(char)
)	O
q	*(char)
=	O
p	*(char)
+	O
1	int
;	O
else	O
break	O
;	O
}	O
while	O
(	O
*	O
q	*(char)
)	O
;	O
if	O
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
mu_cfg_create_node_list	(*(*(struct)))->(int)
(	O
&	O
nodelist	*(struct)
)	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
nodelist	*(struct)
,	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
}	O
parent	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
mu_cfg_alloc_node	(enum(int,int,int),*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char),*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*(struct))->(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
(	O
type	*(char)
,	O
&	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
argv	*(*(char))
[	O
i	long
]	O
,	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
,	O
nodelist	*(struct)
)	O
;	O
if	O
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
parent	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
parent	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
parent	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
mu_argcv_free	(long,*(*(char)))->(void)
(	O
argc	long
,	O
argv	*(*(char))
)	O
;	O
*	O
pnode	*(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))))
=	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
return	O
0	int
;	O
}	O
int	O
mu_cfg_parse_config	(*(*(struct(*(struct`),*(struct`)))),*(struct(int,*(char),*(char),*(char))))->(int)
(	O
mu_cfg_tree_t	struct
*	O
*	O
ptree	*(*(struct(*(struct),*(struct))))
,	O
struct	O
mu_cfg_parse_hints	struct(int,*(char),*(char),*(char))
*	O
hints	*(struct(*(char),*(char)))
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
mu_cfg_tree_t	struct
*	O
tree	*(struct(*(struct),*(struct)))
=	O
NULL	O
,	O
*	O
tmp	*(struct(*(struct),*(struct)))
;	O
struct	O
mu_cfg_parse_hints	struct(int,*(char),*(char),*(char))
xhints	struct(int,*(char),*(char),*(char))
;	O
if	O
(	O
(	O
hints	*(struct(*(char),*(char)))
->	O
flags	int
&	O
MU_CFHINT_SITE_FILE	int
)	O
&&	O
hints	*(struct(*(char),*(char)))
->	O
site_file	*(char)
)	O
{	O
rc	int
=	O
mu_cfg_parse_file	(*(*(struct(*(struct`),*(struct`)))),*(char),int)->(int)
(	O
&	O
tmp	*(struct(*(struct),*(struct)))
,	O
hints	*(struct(*(char),*(char)))
->	O
site_file	*(char)
,	O
hints	*(struct(*(char),*(char)))
->	O
flags	int
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
mu_cfg_tree_postprocess	(*(struct(*(struct),*(struct))),*(struct(int,*(char),*(char),*(char))))->(int)
(	O
tmp	*(struct(*(struct),*(struct)))
,	O
hints	*(struct(*(char),*(char)))
)	O
;	O
mu_cfg_tree_union	(*(*(struct(*(struct`),*(struct`)))),*(*(struct(*(struct`),*(struct`)))))->(int)
(	O
&	O
tree	*(struct(*(struct),*(struct)))
,	O
&	O
tmp	*(struct(*(struct),*(struct)))
)	O
;	O
case	O
ENOENT	int
:	O
rc	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
mu_error	(*(char))->(int)
(	O
"%s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
}	O
xhints	struct(int,*(char),*(char),*(char))
=	O
*	O
hints	*(struct(*(char),*(char)))
;	O
xhints	struct(int,*(char),*(char),*(char))
.	O
flags	int
&=	O
~	O
MU_CFHINT_PROGRAM	int
;	O
if	O
(	O
(	O
hints	*(struct(*(char),*(char)))
->	O
flags	int
&	O
MU_CFHINT_PER_USER_FILE	int
)	O
&&	O
(	O
hints	*(struct(*(char),*(char)))
->	O
flags	int
&	O
MU_CFHINT_PROGRAM	int
)	O
)	O
{	O
size_t	long
size	long
=	O
3	int
+	O
strlen	(*(char))->(long)
(	O
hints	*(struct(*(char),*(char)))
->	O
program	*(char)
)	O
+	O
1	int
;	O
char	O
*	O
file_name	*(char)
=	O
malloc	(long)->(*(void))
(	O
size	long
)	O
;	O
if	O
(	O
file_name	*(char)
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
file_name	*(char)
,	O
"~/."	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
file_name	*(char)
,	O
hints	*(struct(*(char),*(char)))
->	O
program	*(char)
)	O
;	O
rc	int
=	O
mu_cfg_parse_file	(*(*(struct(*(struct`),*(struct`)))),*(char),int)->(int)
(	O
&	O
tmp	*(struct(*(struct),*(struct)))
,	O
file_name	*(char)
,	O
xhints	struct(int,*(char),*(char),*(char))
.	O
flags	int
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
mu_cfg_tree_postprocess	(*(struct(*(struct),*(struct))),*(struct(int,*(char),*(char),*(char))))->(int)
(	O
tmp	*(struct(*(struct),*(struct)))
,	O
&	O
xhints	struct(int,*(char),*(char),*(char))
)	O
;	O
mu_cfg_tree_union	(*(*(struct(*(struct`),*(struct`)))),*(*(struct(*(struct`),*(struct`)))))->(int)
(	O
&	O
tree	*(struct(*(struct),*(struct)))
,	O
&	O
tmp	*(struct(*(struct),*(struct)))
)	O
;	O
break	O
;	O
case	O
ENOENT	int
:	O
rc	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
mu_error	(*(char))->(int)
(	O
"%s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_cfg_destroy_tree	(*(*(struct(*(struct`),*(struct`)))))->(void)
(	O
&	O
tree	*(struct(*(struct),*(struct)))
)	O
;	O
return	O
rc	int
;	O
}	O
free	(*(void))->(void)
(	O
file_name	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
(	O
hints	*(struct(*(char),*(char)))
->	O
flags	int
&	O
MU_CFHINT_CUSTOM_FILE	int
)	O
&&	O
hints	*(struct(*(char),*(char)))
->	O
custom_file	*(char)
)	O
{	O
rc	int
=	O
mu_cfg_parse_file	(*(*(struct(*(struct`),*(struct`)))),*(char),int)->(int)
(	O
&	O
tmp	*(struct(*(struct),*(struct)))
,	O
hints	*(struct(*(char),*(char)))
->	O
custom_file	*(char)
,	O
xhints	struct(int,*(char),*(char),*(char))
.	O
flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"errors parsing file %s: %s"	*(char)
)	O
,	O
hints	*(struct(*(char),*(char)))
->	O
custom_file	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_cfg_destroy_tree	(*(*(struct(*(struct`),*(struct`)))))->(void)
(	O
&	O
tree	*(struct(*(struct),*(struct)))
)	O
;	O
return	O
rc	int
;	O
}	O
else	O
{	O
mu_cfg_tree_postprocess	(*(struct(*(struct),*(struct))),*(struct(int,*(char),*(char),*(char))))->(int)
(	O
tmp	*(struct(*(struct),*(struct)))
,	O
&	O
xhints	struct(int,*(char),*(char),*(char))
)	O
;	O
mu_cfg_tree_union	(*(*(struct(*(struct`),*(struct`)))),*(*(struct(*(struct`),*(struct`)))))->(int)
(	O
&	O
tree	*(struct(*(struct),*(struct)))
,	O
&	O
tmp	*(struct(*(struct),*(struct)))
)	O
;	O
}	O
}	O
*	O
ptree	*(*(struct(*(struct),*(struct))))
=	O
tree	*(struct(*(struct),*(struct)))
;	O
return	O
rc	int
;	O
}	O
