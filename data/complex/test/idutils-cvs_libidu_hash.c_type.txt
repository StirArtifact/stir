static	O
void	O
hash_rehash	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))))->(void)
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
)	O
;	O
static	O
unsigned	O
long	O
round_up_2	(long)->(long)
(	O
unsigned	O
long	O
rough	long
)	O
;	O
void	O
*	O
hash_deleted_item	*(void)
=	O
&	O
hash_deleted_item	*(void)
;	O
void	O
hash_init	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),long,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))->(void)
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
unsigned	O
long	O
size	long
,	O
hash_func_t	*((*(void))->(long))
hash_1	*((*(void))->(long))
,	O
hash_func_t	*((*(void))->(long))
hash_2	*((*(void))->(long))
,	O
hash_cmp_func_t	*((*(void),*(void))->(int))
hash_cmp	*((*(void),*(void))->(int))
)	O
{	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
=	O
round_up_2	(long)->(long)
(	O
size	long
)	O
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_empty_slots	long
=	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_vec	*(*(void))
=	O
(	O
void	O
*	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
,	O
sizeof	O
(	O
struct	O
token	O
*	O
)	O
)	O
;	O
if	O
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_vec	*(*(void))
==	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
0	int
,	O
_	O
(	O
"can't allocate %ld bytes for hash table: memory exhausted"	*(char)
)	O
,	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
*	O
sizeof	O
(	O
struct	O
token	O
*	O
)	O
)	O
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_capacity	long
=	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
*	O
15	int
/	O
16	int
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_fill	long
=	O
0	int
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_collisions	long
=	O
0	int
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_lookups	long
=	O
0	int
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_rehashes	int
=	O
0	int
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_hash_1	*((*(void))->(long))
=	O
hash_1	*((*(void))->(long))
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_hash_2	*((*(void))->(long))
=	O
hash_2	*((*(void))->(long))
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_compare	*((*(void),*(void))->(int))
=	O
hash_cmp	*((*(void),*(void))->(int))
;	O
}	O
void	O
hash_load	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void),long,long)->(void)
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
void	O
*	O
item_table	*(void)
,	O
unsigned	O
long	O
cardinality	long
,	O
unsigned	O
long	O
size	long
)	O
{	O
char	O
*	O
items	*(char)
=	O
(	O
char	O
*	O
)	O
item_table	*(void)
;	O
while	O
(	O
cardinality	long
--	O
)	O
{	O
hash_insert	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(void))
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
items	*(char)
)	O
;	O
items	*(char)
+=	O
size	long
;	O
}	O
}	O
void	O
*	O
*	O
hash_find_slot	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(*(void)))
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
void	O
const	O
*	O
key	*(void)
)	O
{	O
void	O
*	O
*	O
slot	*(void)
;	O
void	O
*	O
*	O
deleted_slot	*(*(void))
=	O
0	int
;	O
unsigned	O
int	O
hash_2	*((*(void))->(long))
=	O
0	int
;	O
unsigned	O
int	O
hash_1	*((*(void))->(long))
=	O
(	O
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_hash_1	*((*(void))->(long))
)	O
(	O
key	*(void)
)	O
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_lookups	long
++	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
hash_1	*((*(void))->(long))
%=	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
;	O
slot	*(void)
=	O
&	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_vec	*(*(void))
[	O
hash_1	*((*(void))->(long))
]	O
;	O
if	O
(	O
*	O
slot	*(void)
==	O
0	int
)	O
return	O
(	O
deleted_slot	*(*(void))
?	O
deleted_slot	*(*(void))
:	O
slot	*(void)
)	O
;	O
if	O
(	O
*	O
slot	*(void)
==	O
hash_deleted_item	*(void)
)	O
{	O
if	O
(	O
deleted_slot	*(*(void))
==	O
0	int
)	O
deleted_slot	*(*(void))
=	O
slot	*(void)
;	O
}	O
else	O
{	O
if	O
(	O
key	*(void)
==	O
*	O
slot	*(void)
)	O
return	O
slot	*(void)
;	O
if	O
(	O
(	O
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_compare	*((*(void),*(void))->(int))
)	O
(	O
key	*(void)
,	O
*	O
slot	*(void)
)	O
==	O
0	int
)	O
return	O
slot	*(void)
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_collisions	long
++	O
;	O
}	O
if	O
(	O
!	O
hash_2	*((*(void))->(long))
)	O
hash_2	*((*(void))->(long))
=	O
(	O
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_hash_2	*((*(void))->(long))
)	O
(	O
key	*(void)
)	O
|	O
1	int
;	O
hash_1	*((*(void))->(long))
+=	O
hash_2	*((*(void))->(long))
;	O
}	O
}	O
void	O
*	O
hash_find_item	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(void))
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
void	O
const	O
*	O
key	*(void)
)	O
{	O
void	O
*	O
*	O
slot	*(void)
=	O
hash_find_slot	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(*(void)))
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
key	*(void)
)	O
;	O
return	O
(	O
(	O
HASH_VACANT	O
(	O
*	O
slot	*(void)
)	O
)	O
?	O
0	int
:	O
*	O
slot	*(void)
)	O
;	O
}	O
void	O
*	O
hash_insert	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(void))
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
void	O
*	O
item	*(void)
)	O
{	O
void	O
*	O
*	O
slot	*(void)
=	O
hash_find_slot	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(*(void)))
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
item	*(void)
)	O
;	O
void	O
*	O
old_item	*(void)
=	O
slot	*(void)
?	O
*	O
slot	*(void)
:	O
0	int
;	O
hash_insert_at	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void),*(void))->(*(void))
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
item	*(void)
,	O
slot	*(void)
)	O
;	O
return	O
(	O
(	O
HASH_VACANT	O
(	O
old_item	*(void)
)	O
)	O
?	O
0	int
:	O
old_item	*(void)
)	O
;	O
}	O
void	O
*	O
hash_insert_at	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void),*(void))->(*(void))
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
void	O
*	O
item	*(void)
,	O
void	O
const	O
*	O
slot	*(void)
)	O
{	O
void	O
*	O
old_item	*(void)
=	O
*	O
(	O
void	O
*	O
*	O
)	O
slot	*(void)
;	O
if	O
(	O
HASH_VACANT	O
(	O
old_item	*(void)
)	O
)	O
{	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_fill	long
++	O
;	O
if	O
(	O
old_item	*(void)
==	O
0	int
)	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_empty_slots	long
--	O
;	O
old_item	*(void)
=	O
item	*(void)
;	O
}	O
*	O
(	O
void	O
const	O
*	O
*	O
)	O
slot	*(void)
=	O
item	*(void)
;	O
if	O
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_empty_slots	long
<	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
-	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_capacity	long
)	O
{	O
hash_rehash	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))))->(void)
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
)	O
;	O
return	O
(	O
void	O
*	O
)	O
hash_find_slot	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(*(void)))
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
item	*(void)
)	O
;	O
}	O
else	O
return	O
(	O
void	O
*	O
)	O
slot	*(void)
;	O
}	O
void	O
*	O
hash_delete	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(void))
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
void	O
const	O
*	O
item	*(void)
)	O
{	O
void	O
*	O
*	O
slot	*(void)
=	O
hash_find_slot	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(*(void)))
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
item	*(void)
)	O
;	O
return	O
hash_delete_at	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(void))
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
slot	*(void)
)	O
;	O
}	O
void	O
*	O
hash_delete_at	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(void))
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
void	O
const	O
*	O
slot	*(void)
)	O
{	O
void	O
*	O
item	*(void)
=	O
*	O
(	O
void	O
*	O
*	O
)	O
slot	*(void)
;	O
if	O
(	O
!	O
HASH_VACANT	O
(	O
item	*(void)
)	O
)	O
{	O
*	O
(	O
void	O
const	O
*	O
*	O
)	O
slot	*(void)
=	O
hash_deleted_item	*(void)
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_fill	long
--	O
;	O
return	O
item	*(void)
;	O
}	O
else	O
return	O
0	int
;	O
}	O
void	O
hash_free_items	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))))->(void)
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
)	O
{	O
void	O
*	O
*	O
vec	*(*(void))
=	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_vec	*(*(void))
;	O
void	O
*	O
*	O
end	*(*(void))
=	O
&	O
vec	*(*(void))
[	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
]	O
;	O
for	O
(	O
;	O
vec	*(*(void))
<	O
end	*(*(void))
;	O
vec	*(*(void))
++	O
)	O
{	O
void	O
*	O
item	*(void)
=	O
*	O
vec	*(*(void))
;	O
if	O
(	O
!	O
HASH_VACANT	O
(	O
item	*(void)
)	O
)	O
free	(*(void))->(void)
(	O
item	*(void)
)	O
;	O
*	O
vec	*(*(void))
=	O
0	int
;	O
}	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_fill	long
=	O
0	int
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_empty_slots	long
=	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
;	O
}	O
void	O
hash_delete_items	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))))->(void)
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
)	O
{	O
void	O
*	O
*	O
vec	*(*(void))
=	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_vec	*(*(void))
;	O
void	O
*	O
*	O
end	*(*(void))
=	O
&	O
vec	*(*(void))
[	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
]	O
;	O
for	O
(	O
;	O
vec	*(*(void))
<	O
end	*(*(void))
;	O
vec	*(*(void))
++	O
)	O
*	O
vec	*(*(void))
=	O
0	int
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_fill	long
=	O
0	int
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_collisions	long
=	O
0	int
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_lookups	long
=	O
0	int
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_rehashes	int
=	O
0	int
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_empty_slots	long
=	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
;	O
}	O
void	O
hash_free	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),int)->(void)
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
int	O
free_items	int
)	O
{	O
if	O
(	O
free_items	int
)	O
hash_free_items	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))))->(void)
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
)	O
;	O
else	O
{	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_fill	long
=	O
0	int
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_empty_slots	long
=	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
;	O
}	O
free	(*(void))->(void)
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_vec	*(*(void))
)	O
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_vec	*(*(void))
=	O
0	int
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_capacity	long
=	O
0	int
;	O
}	O
void	O
hash_map	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*((*(void))->(void)))->(void)
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
hash_map_func_t	*((*(void))->(void))
map	*((*(void))->(void))
)	O
{	O
void	O
*	O
*	O
slot	*(void)
;	O
void	O
*	O
*	O
end	*(*(void))
=	O
&	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_vec	*(*(void))
[	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
]	O
;	O
for	O
(	O
slot	*(void)
=	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_vec	*(*(void))
;	O
slot	*(void)
<	O
end	*(*(void))
;	O
slot	*(void)
++	O
)	O
{	O
if	O
(	O
!	O
HASH_VACANT	O
(	O
*	O
slot	*(void)
)	O
)	O
(	O
*	O
map	*((*(void))->(void))
)	O
(	O
*	O
slot	*(void)
)	O
;	O
}	O
}	O
static	O
void	O
hash_rehash	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))))->(void)
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
)	O
{	O
unsigned	O
long	O
old_ht_size	long
=	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
;	O
void	O
*	O
*	O
old_vec	*(*(void))
=	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_vec	*(*(void))
;	O
void	O
*	O
*	O
ovp	*(*(void))
;	O
if	O
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_fill	long
>=	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_capacity	long
)	O
{	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
*=	O
2	int
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_capacity	long
=	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
-	O
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
>>	O
4	int
)	O
;	O
}	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_rehashes	int
++	O
;	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_vec	*(*(void))
=	O
(	O
void	O
*	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
,	O
sizeof	O
(	O
struct	O
token	O
*	O
)	O
)	O
;	O
for	O
(	O
ovp	*(*(void))
=	O
old_vec	*(*(void))
;	O
ovp	*(*(void))
<	O
&	O
old_vec	*(*(void))
[	O
old_ht_size	long
]	O
;	O
ovp	*(*(void))
++	O
)	O
{	O
if	O
(	O
!	O
HASH_VACANT	O
(	O
*	O
ovp	*(*(void))
)	O
)	O
{	O
void	O
*	O
*	O
slot	*(void)
=	O
hash_find_slot	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(*(void)))
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
*	O
ovp	*(*(void))
)	O
;	O
*	O
slot	*(void)
=	O
*	O
ovp	*(*(void))
;	O
}	O
}	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_empty_slots	long
=	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
-	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_fill	long
;	O
free	(*(void))->(void)
(	O
old_vec	*(*(void))
)	O
;	O
}	O
void	O
hash_print_stats	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
FILE	struct
*	O
out_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
out_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Load=%ld/%ld=%.0f%%, "	*(char)
)	O
,	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_fill	long
,	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
,	O
100.0	int
*	O
(	O
double	O
)	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_fill	long
/	O
(	O
double	O
)	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
out_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Rehash=%d, "	*(char)
)	O
,	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_rehashes	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
out_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Collisions=%ld/%ld=%.0f%%"	*(char)
)	O
,	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_collisions	long
,	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_lookups	long
,	O
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_lookups	long
?	O
(	O
100.0	int
*	O
(	O
double	O
)	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_collisions	long
/	O
(	O
double	O
)	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_lookups	long
)	O
:	O
0	int
)	O
)	O
;	O
}	O
void	O
*	O
*	O
hash_dump	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(*(void)),*((*(void),*(void))->(int)))->(*(*(void)))
(	O
struct	O
hash_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
*	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
,	O
void	O
*	O
*	O
vector_0	*(*(void))
,	O
qsort_cmp_t	*((*(void),*(void))->(int))
compare	*((*(void),*(void))->(int))
)	O
{	O
void	O
*	O
*	O
vector	*(*(void))
;	O
void	O
*	O
*	O
slot	*(void)
;	O
void	O
*	O
*	O
end	*(*(void))
=	O
&	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_vec	*(*(void))
[	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_size	long
]	O
;	O
if	O
(	O
vector_0	*(*(void))
==	O
0	int
)	O
vector_0	*(*(void))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
void	O
*	O
)	O
*	O
(	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_fill	long
+	O
1	int
)	O
)	O
;	O
vector	*(*(void))
=	O
vector_0	*(*(void))
;	O
for	O
(	O
slot	*(void)
=	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_vec	*(*(void))
;	O
slot	*(void)
<	O
end	*(*(void))
;	O
slot	*(void)
++	O
)	O
if	O
(	O
!	O
HASH_VACANT	O
(	O
*	O
slot	*(void)
)	O
)	O
*	O
vector	*(*(void))
++	O
=	O
*	O
slot	*(void)
;	O
*	O
vector	*(*(void))
=	O
0	int
;	O
if	O
(	O
compare	*((*(void),*(void))->(int))
)	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
vector_0	*(*(void))
,	O
ht	*(struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))))
->	O
ht_fill	long
,	O
sizeof	O
(	O
void	O
*	O
)	O
,	O
compare	*((*(void),*(void))->(int))
)	O
;	O
return	O
vector_0	*(*(void))
;	O
}	O
static	O
unsigned	O
long	O
round_up_2	(long)->(long)
(	O
unsigned	O
long	O
rough	long
)	O
{	O
int	O
round	int
;	O
round	int
=	O
1	int
;	O
while	O
(	O
rough	long
)	O
{	O
round	int
<<=	O
1	int
;	O
rough	long
>>=	O
1	int
;	O
}	O
return	O
round	int
;	O
}	O
