static	O
const	O
char	O
*	O
current_folder	*(char)
=	O
NULL	O
;	O
int	O
rcpt_mask	int
=	O
RCPT_DEFAULT	O
;	O
int	O
mh_auto_install	int
=	O
1	int
;	O
mu_property_t	*(struct)
mh_read_property_file	(*(char),int)->(*(struct))
(	O
char	O
*	O
name	*(char)
,	O
int	O
ro	int
)	O
{	O
mu_property_t	*(struct)
prop	*(struct)
;	O
struct	O
mu_mh_prop	struct(*(char),int)
*	O
mhprop	*(struct(*(char),int))
;	O
int	O
rc	int
;	O
mhprop	*(struct(*(char),int))
=	O
mu_zalloc	(long)->(*(void))
(	O
sizeof	O
(	O
mhprop	*(struct(*(char),int))
[	O
0	int
]	O
)	O
)	O
;	O
mhprop	*(struct(*(char),int))
->	O
filename	*(char)
=	O
name	*(char)
;	O
mhprop	*(struct(*(char),int))
->	O
ro	int
=	O
ro	int
;	O
rc	int
=	O
mu_property_create_init	(*(*(struct)),*((*(struct))->(int)),*(void))->(int)
(	O
&	O
prop	*(struct)
,	O
mu_mh_property_init	(*(struct))->(int)
,	O
mhprop	*(struct(*(char),int))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_property_create_init"	*(char)
,	O
name	*(char)
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
return	O
prop	*(struct)
;	O
}	O
static	O
int	O
prop_merger	(*(char),*(char),*(void))->(int)
(	O
const	O
char	O
*	O
field	*(char)
,	O
const	O
char	O
*	O
value	*(char)
,	O
void	O
*	O
data	*(void)
)	O
{	O
mu_property_t	*(struct)
dst	*(char)
=	O
data	*(void)
;	O
return	O
mu_property_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
dst	*(char)
,	O
field	*(char)
,	O
value	*(char)
,	O
1	int
)	O
;	O
}	O
void	O
mh_property_merge	(*(struct),*(struct))->(void)
(	O
mu_property_t	*(struct)
dst	*(char)
,	O
mu_property_t	*(struct)
src	*(char)
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
!	O
src	*(char)
)	O
return	O
;	O
rc	int
=	O
mu_mhprop_iterate	(*(struct),*((*(char),*(char),*(void))->(int)),*(void))->(int)
(	O
src	*(char)
,	O
prop_merger	(*(char),*(char),*(void))->(int)
,	O
dst	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_mhprop_iterate"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
void	O
_mh_init_global_context	()->(void)
(	O
)	O
{	O
char	O
*	O
p	*(char)
,	O
*	O
ctx_name	*(char)
;	O
if	O
(	O
mu_mh_context	*(struct)
)	O
return	O
;	O
p	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"CONTEXT"	*(char)
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
p	*(char)
=	O
MH_CONTEXT_FILE	*(char)
;	O
ctx_name	*(char)
=	O
mh_expand_name	(*(char),*(char),int)->(*(char))
(	O
NULL	O
,	O
p	*(char)
,	O
NAME_ANY	int
)	O
;	O
mu_mh_context	*(struct)
=	O
mh_read_property_file	(*(char),int)->(*(struct))
(	O
ctx_name	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
current_folder	*(char)
)	O
current_folder	*(char)
=	O
mh_global_context_get	O
(	O
"Current-Folder"	*(char)
,	O
mh_global_profile_get	O
(	O
"Inbox"	*(char)
,	O
"inbox"	*(char)
)	O
)	O
;	O
}	O
void	O
mh_read_profile	()->(void)
(	O
)	O
{	O
char	O
*	O
p	*(char)
;	O
const	O
char	O
*	O
fallback	*(char)
;	O
p	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"MH"	*(char)
)	O
;	O
if	O
(	O
p	*(char)
)	O
p	*(char)
=	O
mu_tilde_expansion	(*(char),int,*(char))->(*(char))
(	O
p	*(char)
,	O
MU_HIERARCHY_DELIMITER	char
,	O
NULL	O
)	O
;	O
else	O
{	O
char	O
*	O
home	*(char)
=	O
mu_get_homedir	()->(*(char))
(	O
)	O
;	O
if	O
(	O
!	O
home	*(char)
)	O
abort	()->(void)
(	O
)	O
;	O
p	*(char)
=	O
mh_safe_make_file_name	(*(char),*(char))->(*(char))
(	O
home	*(char)
,	O
MH_USER_PROFILE	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
home	*(char)
)	O
;	O
}	O
if	O
(	O
mh_auto_install	int
&&	O
access	(*(char),int)->(int)
(	O
p	*(char)
,	O
R_OK	int
)	O
)	O
mh_install	(*(char),int)->(void)
(	O
p	*(char)
,	O
1	int
)	O
;	O
mu_mh_profile	*(struct)
=	O
mh_read_property_file	(*(char),int)->(*(struct))
(	O
p	*(char)
,	O
0	int
)	O
;	O
mu_set_folder_directory	(*(char))->(int)
(	O
mh_get_dir	()->(*(char))
(	O
)	O
)	O
;	O
mh_set_reply_regex	(*(char))->(void)
(	O
mh_global_profile_get	O
(	O
"Reply-Regex"	*(char)
,	O
NULL	O
)	O
)	O
;	O
fallback	*(char)
=	O
mh_global_profile_get	O
(	O
"Decode-Fallback"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
fallback	*(char)
&&	O
mu_set_default_fallback	(*(char))->(int)
(	O
fallback	*(char)
)	O
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Incorrect value for decode-fallback"	*(char)
)	O
)	O
;	O
_mh_init_global_context	()->(void)
(	O
)	O
;	O
}	O
const	O
char	O
*	O
mh_current_folder	()->(*(char))
(	O
)	O
{	O
return	O
mh_global_context_get	O
(	O
"Current-Folder"	*(char)
,	O
mh_global_profile_get	O
(	O
"Inbox"	*(char)
,	O
"inbox"	*(char)
)	O
)	O
;	O
}	O
const	O
char	O
*	O
mh_set_current_folder	(*(char))->(*(char))
(	O
const	O
char	O
*	O
val	array(int)
)	O
{	O
int	O
rc	int
=	O
mh_global_context_set	O
(	O
"Current-Folder"	*(char)
,	O
val	array(int)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mh_global_context_set"	*(char)
,	O
"Current-Folder"	*(char)
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
current_folder	*(char)
=	O
mh_current_folder	()->(*(char))
(	O
)	O
;	O
return	O
current_folder	*(char)
;	O
}	O
mu_property_t	*(struct)
mh_mailbox_get_property	(*(struct))->(*(struct))
(	O
mu_mailbox_t	*(struct)
mbox	*(struct)
)	O
{	O
mu_property_t	*(struct)
prop	*(struct)
;	O
int	O
rc	int
=	O
mu_mailbox_get_property	(*(struct),*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
&	O
prop	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_mailbox_get_property"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
return	O
prop	*(struct)
;	O
}	O
void	O
mh_global_sequences_drop	(*(struct))->(void)
(	O
mu_mailbox_t	*(struct)
mbox	*(struct)
)	O
{	O
mu_property_t	*(struct)
prop	*(struct)
=	O
mh_mailbox_get_property	(*(struct))->(*(struct))
(	O
mbox	*(struct)
)	O
;	O
int	O
rc	int
=	O
mu_property_clear	(*(struct))->(int)
(	O
prop	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_property_clear"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
const	O
char	O
*	O
mh_global_sequences_get	(*(struct),*(char),*(char))->(*(char))
(	O
mu_mailbox_t	*(struct)
mbox	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
defval	int
)	O
{	O
mu_property_t	*(struct)
prop	*(struct)
=	O
mh_mailbox_get_property	(*(struct))->(*(struct))
(	O
mbox	*(struct)
)	O
;	O
const	O
char	O
*	O
s	*(char)
;	O
int	O
rc	int
=	O
mu_property_sget_value	(*(struct),*(char),*(*(char)))->(int)
(	O
prop	*(struct)
,	O
name	*(char)
,	O
&	O
s	*(char)
)	O
;	O
if	O
(	O
rc	int
==	O
MU_ERR_NOENT	O
)	O
s	*(char)
=	O
defval	int
;	O
else	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_property_sget_value"	*(char)
,	O
name	*(char)
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
return	O
s	*(char)
;	O
}	O
void	O
mh_global_sequences_set	(*(struct),*(char),*(char))->(void)
(	O
mu_mailbox_t	*(struct)
mbox	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
value	*(char)
)	O
{	O
mu_property_t	*(struct)
prop	*(struct)
=	O
mh_mailbox_get_property	(*(struct))->(*(struct))
(	O
mbox	*(struct)
)	O
;	O
int	O
rc	int
=	O
mu_property_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
prop	*(struct)
,	O
name	*(char)
,	O
value	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
rc	int
&&	O
!	O
(	O
!	O
value	*(char)
&&	O
rc	int
==	O
MU_ERR_NOENT	O
)	O
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_property_set_value"	*(char)
,	O
name	*(char)
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
void	O
mh_global_sequences_iterate	(*(struct),*((*(char),*(char),*(void))->(int)),*(void))->(void)
(	O
mu_mailbox_t	*(struct)
mbox	*(struct)
,	O
mu_mhprop_iterator_t	*((*(char),*(char),*(void))->(int))
fp	*((*(char),*(char),*(void))->(int))
,	O
void	O
*	O
data	*(void)
)	O
{	O
int	O
rc	int
;	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
mu_property_t	*(struct)
prop	*(struct)
=	O
mh_mailbox_get_property	(*(struct))->(*(struct))
(	O
mbox	*(struct)
)	O
;	O
rc	int
=	O
mu_property_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
prop	*(struct)
,	O
&	O
itr	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_property_get_iterator"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
mu_mhprop_iterate	(*(struct),*((*(char),*(char),*(void))->(int)),*(void))->(int)
(	O
prop	*(struct)
,	O
fp	*((*(char),*(char),*(void))->(int))
,	O
data	*(void)
)	O
;	O
}	O
void	O
mh_global_save_state	()->(void)
(	O
)	O
{	O
int	O
rc	int
;	O
mh_global_context_set	O
(	O
"Current-Folder"	*(char)
,	O
current_folder	*(char)
)	O
;	O
rc	int
=	O
mu_property_save	(*(struct))->(int)
(	O
mu_mh_context	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_property_save"	*(char)
,	O
"context"	*(char)
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
