static	O
int	O
errors	O
;	O
int	O
re_flags	O
=	O
REG_EXTENDED	O
;	O
static	O
struct	O
rush_rule	O
*	O
current_rule	O
;	O
struct	O
asgn	O
{	O
struct	O
asgn	O
*	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
;	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
value	O
;	O
}	O
;	O
static	O
void	O
add_asgn_list	O
(	O
struct	O
asgn	O
*	O
head	O
,	O
enum	O
envar_type	O
type	enum(int,int,int,int)
)	O
;	O
static	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
new_set_node	O
(	O
enum	O
transform_node_type	enum(int,int,int,int)
type	enum(int,int,int,int)
,	O
char	O
*	O
varname	O
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
;	O
extern	O
int	O
yydebug	O
;	O
enum	O
yytokentype	O
{	O
STRING	O
=	O
258	int
,	O
IDENT	O
=	O
259	int
,	O
NUMBER	O
=	O
260	int
,	O
RUSH	O
=	O
261	int
,	O
T_VERSION	O
=	O
262	int
,	O
RULE	O
=	O
263	int
,	O
GLOBAL	O
=	O
264	int
,	O
EOL	O
=	O
265	int
,	O
SET	O
=	O
266	int
,	O
INSERT	O
=	O
267	int
,	O
REMOPT	O
=	O
268	int
,	O
MAP	O
=	O
269	int
,	O
UNSET	O
=	O
270	int
,	O
MATCH	O
=	O
271	int
,	O
FALLTHROUGH	O
=	O
272	int
,	O
INCLUDE	O
=	O
273	int
,	O
LIMITS	O
=	O
274	int
,	O
CLRENV	O
=	O
275	int
,	O
SETENV	O
=	O
276	int
,	O
UNSETENV	O
=	O
277	int
,	O
KEEPENV	O
=	O
278	int
,	O
EVALENV	O
=	O
279	int
,	O
DELETE	O
=	O
280	int
,	O
EXIT	O
=	O
281	int
,	O
ATTRIB	O
=	O
282	int
,	O
GLATTRIB	O
=	O
283	int
,	O
BOGUS	O
=	O
284	int
,	O
OR	O
=	O
285	int
,	O
AND	O
=	O
286	int
,	O
NOT	O
=	O
287	int
,	O
EQ	O
=	O
288	int
,	O
NE	O
=	O
289	int
,	O
LT	O
=	O
290	int
,	O
LE	O
=	O
291	int
,	O
GT	O
=	O
292	int
,	O
GE	O
=	O
293	int
,	O
XF	O
=	O
294	int
,	O
NM	O
=	O
295	int
,	O
IN	O
=	O
296	int
,	O
GROUP	O
=	O
297	int
}	O
;	O
typedef	O
union	O
YYSTYPE	O
{	O
char	O
*	O
str	*(char)
;	O
struct	O
cfnumber	O
num	long
;	O
int	O
intval	O
;	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
regex	O
;	O
struct	O
rush_rule	O
rule	*(char)
;	O
struct	O
test_node	O
*	O
node	O
;	O
struct	O
strlist	O
{	O
char	O
*	O
*	O
argv	*(*(char))
;	O
size_t	long
argc	int
;	O
}	O
strlist	O
;	O
struct	O
{	O
int	O
start	*(long)
;	O
int	O
end	*(long)
;	O
}	O
range	O
;	O
struct	O
asgn	O
*	O
asgn	O
;	O
struct	O
{	O
struct	O
asgn	O
*	O
head	O
;	O
struct	O
asgn	O
*	O
tail	O
;	O
}	O
asgn_list	O
;	O
struct	O
limits_rec	O
*	O
lrec	O
;	O
rule_attrib_setter_t	O
attrib	O
;	O
struct	O
global_attrib	O
*	O
global_attrib	O
;	O
struct	O
argval	O
*	O
arg	struct(int,int)
;	O
struct	O
{	O
int	O
argc	int
;	O
struct	O
argval	O
*	O
head	O
;	O
struct	O
argval	O
*	O
tail	O
;	O
}	O
arglist	O
;	O
struct	O
{	O
unsigned	O
major	O
,	O
minor	O
;	O
}	O
version	(*(char))->(void)
;	O
}	O
YYSTYPE	O
;	O
extern	O
YYSTYPE	O
yylval	O
;	O
extern	O
YYLTYPE	O
yylloc	O
;	O
int	O
yyparse	O
(	O
void	O
)	O
;	O
typedef	O
unsigned	O
char	O
yytype_uint8	O
;	O
typedef	O
signed	O
char	O
yytype_int8	O
;	O
typedef	O
unsigned	O
short	O
int	O
yytype_uint16	O
;	O
typedef	O
short	O
int	O
yytype_int16	O
;	O
union	O
yyalloc	O
{	O
yytype_int16	O
yyss_alloc	O
;	O
YYSTYPE	O
yyvs_alloc	O
;	O
YYLTYPE	O
yyls_alloc	O
;	O
}	O
;	O
static	O
const	O
yytype_uint8	O
yytranslate	O
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
44	int
,	O
45	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
46	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
47	int
,	O
2	int
,	O
48	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
43	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
}	O
;	O
static	O
const	O
yytype_uint16	O
yyprhs	O
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
3	int
,	O
6	int
,	O
10	int
,	O
12	int
,	O
16	int
,	O
17	int
,	O
19	int
,	O
21	int
,	O
24	int
,	O
25	int
,	O
27	int
,	O
29	int
,	O
32	int
,	O
35	int
,	O
38	int
,	O
41	int
,	O
43	int
,	O
46	int
,	O
50	int
,	O
52	int
,	O
55	int
,	O
57	int
,	O
59	int
,	O
63	int
,	O
64	int
,	O
66	int
,	O
68	int
,	O
71	int
,	O
74	int
,	O
77	int
,	O
80	int
,	O
83	int
,	O
86	int
,	O
89	int
,	O
92	int
,	O
95	int
,	O
98	int
,	O
101	int
,	O
103	int
,	O
106	int
,	O
108	int
,	O
112	int
,	O
116	int
,	O
118	int
,	O
121	int
,	O
125	int
,	O
129	int
,	O
133	int
,	O
137	int
,	O
141	int
,	O
145	int
,	O
149	int
,	O
153	int
,	O
157	int
,	O
161	int
,	O
165	int
,	O
169	int
,	O
172	int
,	O
175	int
,	O
177	int
,	O
179	int
,	O
181	int
,	O
183	int
,	O
185	int
,	O
187	int
,	O
192	int
,	O
197	int
,	O
202	int
,	O
209	int
,	O
216	int
,	O
221	int
,	O
226	int
,	O
233	int
,	O
236	int
,	O
239	int
,	O
248	int
,	O
257	int
,	O
258	int
,	O
260	int
,	O
264	int
,	O
266	int
,	O
268	int
,	O
272	int
,	O
276	int
,	O
277	int
,	O
279	int
,	O
282	int
,	O
284	int
,	O
287	int
,	O
291	int
,	O
294	int
,	O
296	int
,	O
299	int
,	O
303	int
,	O
304	int
,	O
306	int
,	O
308	int
,	O
313	int
,	O
316	int
,	O
319	int
,	O
322	int
,	O
324	int
,	O
327	int
,	O
329	int
,	O
333	int
,	O
336	int
,	O
337	int
}	O
;	O
static	O
const	O
yytype_int8	O
yyrhs	O
[	O
]	O
=	O
{	O
50	int
,	O
0	int
,	O
-	O
1	int
,	O
53	int
,	O
51	int
,	O
-	O
1	int
,	O
52	int
,	O
53	int
,	O
55	int
,	O
-	O
1	int
,	O
29	int
,	O
-	O
1	int
,	O
6	int
,	O
7	int
,	O
10	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
54	int
,	O
-	O
1	int
,	O
10	int
,	O
-	O
1	int
,	O
54	int
,	O
10	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
56	int
,	O
-	O
1	int
,	O
57	int
,	O
-	O
1	int
,	O
56	int
,	O
57	int
,	O
-	O
1	int
,	O
63	int
,	O
65	int
,	O
-	O
1	int
,	O
58	int
,	O
59	int
,	O
-	O
1	int
,	O
9	int
,	O
54	int
,	O
-	O
1	int
,	O
60	int
,	O
-	O
1	int
,	O
59	int
,	O
60	int
,	O
-	O
1	int
,	O
28	int
,	O
61	int
,	O
54	int
,	O
-	O
1	int
,	O
62	int
,	O
-	O
1	int
,	O
61	int
,	O
62	int
,	O
-	O
1	int
,	O
71	int
,	O
-	O
1	int
,	O
5	int
,	O
-	O
1	int
,	O
8	int
,	O
64	int
,	O
54	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
72	int
,	O
-	O
1	int
,	O
66	int
,	O
-	O
1	int
,	O
65	int
,	O
66	int
,	O
-	O
1	int
,	O
67	int
,	O
54	int
,	O
-	O
1	int
,	O
74	int
,	O
54	int
,	O
-	O
1	int
,	O
75	int
,	O
54	int
,	O
-	O
1	int
,	O
81	int
,	O
54	int
,	O
-	O
1	int
,	O
84	int
,	O
54	int
,	O
-	O
1	int
,	O
88	int
,	O
54	int
,	O
-	O
1	int
,	O
79	int
,	O
54	int
,	O
-	O
1	int
,	O
91	int
,	O
54	int
,	O
-	O
1	int
,	O
86	int
,	O
54	int
,	O
-	O
1	int
,	O
83	int
,	O
53	int
,	O
-	O
1	int
,	O
1	int
,	O
-	O
1	int
,	O
16	int
,	O
68	int
,	O
-	O
1	int
,	O
69	int
,	O
-	O
1	int
,	O
68	int
,	O
31	int
,	O
69	int
,	O
-	O
1	int
,	O
68	int
,	O
30	int
,	O
69	int
,	O
-	O
1	int
,	O
70	int
,	O
-	O
1	int
,	O
32	int
,	O
69	int
,	O
-	O
1	int
,	O
44	int
,	O
68	int
,	O
45	int
,	O
-	O
1	int
,	O
72	int
,	O
43	int
,	O
73	int
,	O
-	O
1	int
,	O
72	int
,	O
40	int
,	O
73	int
,	O
-	O
1	int
,	O
72	int
,	O
33	int
,	O
71	int
,	O
-	O
1	int
,	O
72	int
,	O
34	int
,	O
71	int
,	O
-	O
1	int
,	O
72	int
,	O
33	int
,	O
5	int
,	O
-	O
1	int
,	O
72	int
,	O
34	int
,	O
5	int
,	O
-	O
1	int
,	O
72	int
,	O
35	int
,	O
5	int
,	O
-	O
1	int
,	O
72	int
,	O
36	int
,	O
5	int
,	O
-	O
1	int
,	O
72	int
,	O
37	int
,	O
5	int
,	O
-	O
1	int
,	O
72	int
,	O
38	int
,	O
5	int
,	O
-	O
1	int
,	O
72	int
,	O
41	int
,	O
92	int
,	O
-	O
1	int
,	O
42	int
,	O
72	int
,	O
-	O
1	int
,	O
42	int
,	O
92	int
,	O
-	O
1	int
,	O
4	int
,	O
-	O
1	int
,	O
3	int
,	O
-	O
1	int
,	O
4	int
,	O
-	O
1	int
,	O
3	int
,	O
-	O
1	int
,	O
5	int
,	O
-	O
1	int
,	O
72	int
,	O
-	O
1	int
,	O
11	int
,	O
77	int
,	O
46	int
,	O
78	int
,	O
-	O
1	int
,	O
12	int
,	O
77	int
,	O
46	int
,	O
78	int
,	O
-	O
1	int
,	O
11	int
,	O
77	int
,	O
39	int
,	O
78	int
,	O
-	O
1	int
,	O
11	int
,	O
77	int
,	O
46	int
,	O
72	int
,	O
43	int
,	O
78	int
,	O
-	O
1	int
,	O
12	int
,	O
77	int
,	O
46	int
,	O
72	int
,	O
43	int
,	O
78	int
,	O
-	O
1	int
,	O
11	int
,	O
4	int
,	O
46	int
,	O
78	int
,	O
-	O
1	int
,	O
11	int
,	O
4	int
,	O
39	int
,	O
78	int
,	O
-	O
1	int
,	O
11	int
,	O
4	int
,	O
46	int
,	O
72	int
,	O
43	int
,	O
78	int
,	O
-	O
1	int
,	O
15	int
,	O
4	int
,	O
-	O
1	int
,	O
15	int
,	O
77	int
,	O
-	O
1	int
,	O
14	int
,	O
77	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
5	int
,	O
5	int
,	O
76	int
,	O
-	O
1	int
,	O
14	int
,	O
4	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
5	int
,	O
5	int
,	O
76	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
72	int
,	O
-	O
1	int
,	O
47	int
,	O
5	int
,	O
48	int
,	O
-	O
1	int
,	O
72	int
,	O
-	O
1	int
,	O
17	int
,	O
-	O
1	int
,	O
26	int
,	O
80	int
,	O
3	int
,	O
-	O
1	int
,	O
26	int
,	O
80	int
,	O
4	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
5	int
,	O
-	O
1	int
,	O
25	int
,	O
82	int
,	O
-	O
1	int
,	O
5	int
,	O
-	O
1	int
,	O
5	int
,	O
5	int
,	O
-	O
1	int
,	O
18	int
,	O
72	int
,	O
10	int
,	O
-	O
1	int
,	O
19	int
,	O
85	int
,	O
-	O
1	int
,	O
4	int
,	O
-	O
1	int
,	O
85	int
,	O
4	int
,	O
-	O
1	int
,	O
13	int
,	O
72	int
,	O
87	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
72	int
,	O
-	O
1	int
,	O
20	int
,	O
-	O
1	int
,	O
21	int
,	O
4	int
,	O
46	int
,	O
72	int
,	O
-	O
1	int
,	O
24	int
,	O
72	int
,	O
-	O
1	int
,	O
22	int
,	O
89	int
,	O
-	O
1	int
,	O
23	int
,	O
89	int
,	O
-	O
1	int
,	O
90	int
,	O
-	O
1	int
,	O
89	int
,	O
90	int
,	O
-	O
1	int
,	O
71	int
,	O
-	O
1	int
,	O
4	int
,	O
46	int
,	O
78	int
,	O
-	O
1	int
,	O
27	int
,	O
72	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
44	int
,	O
93	int
,	O
61	int
,	O
45	int
,	O
-	O
1	int
}	O
;	O
static	O
const	O
yytype_uint16	O
yyrline	O
[	O
]	O
=	O
{	O
0	int
,	O
130	int
,	O
130	int
,	O
133	int
,	O
138	int
,	O
145	int
,	O
156	int
,	O
157	int
,	O
160	int
,	O
161	int
,	O
164	int
,	O
165	int
,	O
168	int
,	O
169	int
,	O
172	int
,	O
173	int
,	O
176	int
,	O
179	int
,	O
180	int
,	O
183	int
,	O
193	int
,	O
198	int
,	O
206	int
,	O
214	int
,	O
225	int
,	O
235	int
,	O
238	int
,	O
241	int
,	O
242	int
,	O
245	int
,	O
246	int
,	O
247	int
,	O
248	int
,	O
249	int
,	O
250	int
,	O
251	int
,	O
252	int
,	O
253	int
,	O
254	int
,	O
255	int
,	O
268	int
,	O
280	int
,	O
281	int
,	O
287	int
,	O
295	int
,	O
296	int
,	O
301	int
,	O
307	int
,	O
314	int
,	O
324	int
,	O
331	int
,	O
338	int
,	O
345	int
,	O
352	int
,	O
359	int
,	O
366	int
,	O
373	int
,	O
380	int
,	O
387	int
,	O
394	int
,	O
401	int
,	O
402	int
,	O
405	int
,	O
406	int
,	O
407	int
,	O
413	int
,	O
428	int
,	O
439	int
,	O
450	int
,	O
462	int
,	O
474	int
,	O
486	int
,	O
495	int
,	O
506	int
,	O
517	int
,	O
525	int
,	O
542	int
,	O
560	int
,	O
579	int
,	O
582	int
,	O
585	int
,	O
592	int
,	O
598	int
,	O
602	int
,	O
607	int
,	O
620	int
,	O
623	int
,	O
633	int
,	O
650	int
,	O
655	int
,	O
670	int
,	O
681	int
,	O
687	int
,	O
707	int
,	O
732	int
,	O
770	int
,	O
773	int
,	O
779	int
,	O
783	int
,	O
792	int
,	O
800	int
,	O
804	int
,	O
810	int
,	O
814	int
,	O
821	int
,	O
828	int
,	O
840	int
,	O
847	int
,	O
847	int
}	O
;	O
static	O
const	O
char	O
*	O
const	O
yytname	O
[	O
]	O
=	O
{	O
"$end"	*(char)
,	O
"error"	*(char)
,	O
"$undefined"	*(char)
,	O
"\"string\""	*(char)
,	O
"\"identifier\""	*(char)
,	O
"\"number\""	*(char)
,	O
"\"rush\""	*(char)
,	O
"T_VERSION"	*(char)
,	O
"\"rule\""	*(char)
,	O
"\"global\""	*(char)
,	O
"\"end of line\""	*(char)
,	O
"\"set\""	*(char)
,	O
"\"insert\""	*(char)
,	O
"\"remopt\""	*(char)
,	O
"\"map\""	*(char)
,	O
"\"unset\""	*(char)
,	O
"\"match\""	*(char)
,	O
"\"fallthrough\""	*(char)
,	O
"\"include\""	*(char)
,	O
"\"limits\""	*(char)
,	O
"\"clrenv\""	*(char)
,	O
"\"setenv\""	*(char)
,	O
"\"unsetenv\""	*(char)
,	O
"\"keepenv\""	*(char)
,	O
"\"evalenv\""	*(char)
,	O
"\"delete\""	*(char)
,	O
"\"exit\""	*(char)
,	O
"\"rule attribute\""	*(char)
,	O
"\"global attribute\""	*(char)
,	O
"\"erroneous token\""	*(char)
,	O
"\"||\""	*(char)
,	O
"\"&&\""	*(char)
,	O
"\"!\""	*(char)
,	O
"\"==\""	*(char)
,	O
"\"!=\""	*(char)
,	O
"\"<\""	*(char)
,	O
"\"<=\""	*(char)
,	O
"\">\""	*(char)
,	O
"\">=\""	*(char)
,	O
"\"=~\""	*(char)
,	O
"\"!~\""	*(char)
,	O
"\"in\""	*(char)
,	O
"\"group\""	*(char)
,	O
"'~'"	*(char)
,	O
"'('"	*(char)
,	O
"')'"	*(char)
,	O
"'='"	*(char)
,	O
"'['"	*(char)
,	O
"']'"	*(char)
,	O
"$accept"	*(char)
,	O
"rcfile"	*(char)
,	O
"select"	*(char)
,	O
"preface"	*(char)
,	O
"skipeol"	*(char)
,	O
"eol"	*(char)
,	O
"content"	*(char)
,	O
"rulelist"	*(char)
,	O
"rule"	*(char)
,	O
"globhdr"	*(char)
,	O
"globbody"	*(char)
,	O
"glob_stmt"	*(char)
,	O
"arglist"	*(char)
,	O
"arg"	*(char)
,	O
"rulehdr"	*(char)
,	O
"ruleid"	*(char)
,	O
"rulebody"	*(char)
,	O
"stmt"	*(char)
,	O
"match_stmt"	*(char)
,	O
"compound_cond"	*(char)
,	O
"simple_cond"	*(char)
,	O
"expr"	*(char)
,	O
"literal"	*(char)
,	O
"string"	*(char)
,	O
"regex"	*(char)
,	O
"set_stmt"	*(char)
,	O
"map_stmt"	*(char)
,	O
"defval"	*(char)
,	O
"index"	*(char)
,	O
"value"	*(char)
,	O
"flowctl_stmt"	*(char)
,	O
"fdescr"	*(char)
,	O
"delete_stmt"	*(char)
,	O
"range"	*(char)
,	O
"include_stmt"	*(char)
,	O
"limits_stmt"	*(char)
,	O
"resource_limits"	*(char)
,	O
"remopt_stmt"	*(char)
,	O
"optstring"	*(char)
,	O
"environ_stmt"	*(char)
,	O
"asgn_list"	*(char)
,	O
"asgn"	*(char)
,	O
"attrib_stmt"	*(char)
,	O
"strlist"	*(char)
,	O
"$@1"	*(char)
,	O
YY_NULL	O
}	O
;	O
static	O
const	O
yytype_uint8	O
yyr1	O
[	O
]	O
=	O
{	O
0	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
53	int
,	O
54	int
,	O
54	int
,	O
55	int
,	O
55	int
,	O
56	int
,	O
56	int
,	O
57	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
59	int
,	O
60	int
,	O
61	int
,	O
61	int
,	O
62	int
,	O
62	int
,	O
63	int
,	O
64	int
,	O
64	int
,	O
65	int
,	O
65	int
,	O
66	int
,	O
66	int
,	O
66	int
,	O
66	int
,	O
66	int
,	O
66	int
,	O
66	int
,	O
66	int
,	O
66	int
,	O
66	int
,	O
66	int
,	O
67	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
69	int
,	O
69	int
,	O
69	int
,	O
70	int
,	O
70	int
,	O
70	int
,	O
70	int
,	O
70	int
,	O
70	int
,	O
70	int
,	O
70	int
,	O
70	int
,	O
70	int
,	O
70	int
,	O
70	int
,	O
70	int
,	O
71	int
,	O
71	int
,	O
72	int
,	O
72	int
,	O
72	int
,	O
73	int
,	O
74	int
,	O
74	int
,	O
74	int
,	O
74	int
,	O
74	int
,	O
74	int
,	O
74	int
,	O
74	int
,	O
74	int
,	O
74	int
,	O
75	int
,	O
75	int
,	O
76	int
,	O
76	int
,	O
77	int
,	O
78	int
,	O
79	int
,	O
79	int
,	O
79	int
,	O
80	int
,	O
80	int
,	O
81	int
,	O
82	int
,	O
82	int
,	O
83	int
,	O
84	int
,	O
85	int
,	O
85	int
,	O
86	int
,	O
87	int
,	O
87	int
,	O
88	int
,	O
88	int
,	O
88	int
,	O
88	int
,	O
88	int
,	O
89	int
,	O
89	int
,	O
90	int
,	O
90	int
,	O
91	int
,	O
93	int
,	O
92	int
}	O
;	O
static	O
const	O
yytype_uint8	O
yyr2	O
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
2	int
,	O
3	int
,	O
1	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
3	int
,	O
3	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
6	int
,	O
6	int
,	O
4	int
,	O
4	int
,	O
6	int
,	O
2	int
,	O
2	int
,	O
8	int
,	O
8	int
,	O
0	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
4	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
3	int
,	O
2	int
,	O
0	int
,	O
4	int
}	O
;	O
static	O
const	O
yytype_uint8	O
yydefact	O
[	O
]	O
=	O
{	O
6	int
,	O
8	int
,	O
0	int
,	O
0	int
,	O
7	int
,	O
1	int
,	O
0	int
,	O
4	int
,	O
2	int
,	O
6	int
,	O
9	int
,	O
0	int
,	O
10	int
,	O
5	int
,	O
25	int
,	O
0	int
,	O
3	int
,	O
11	int
,	O
12	int
,	O
0	int
,	O
0	int
,	O
63	int
,	O
62	int
,	O
64	int
,	O
0	int
,	O
26	int
,	O
16	int
,	O
13	int
,	O
0	int
,	O
15	int
,	O
17	int
,	O
39	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
82	int
,	O
0	int
,	O
0	int
,	O
97	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
85	int
,	O
0	int
,	O
0	int
,	O
27	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
6	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
24	int
,	O
61	int
,	O
60	int
,	O
23	int
,	O
0	int
,	O
20	int
,	O
22	int
,	O
18	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
95	int
,	O
0	int
,	O
0	int
,	O
74	int
,	O
75	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
40	int
,	O
41	int
,	O
44	int
,	O
0	int
,	O
0	int
,	O
92	int
,	O
91	int
,	O
0	int
,	O
60	int
,	O
104	int
,	O
100	int
,	O
102	int
,	O
101	int
,	O
99	int
,	O
88	int
,	O
87	int
,	O
86	int
,	O
0	int
,	O
106	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
35	int
,	O
32	int
,	O
38	int
,	O
33	int
,	O
37	int
,	O
34	int
,	O
36	int
,	O
19	int
,	O
21	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
96	int
,	O
94	int
,	O
81	int
,	O
0	int
,	O
0	int
,	O
45	int
,	O
107	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
90	int
,	O
93	int
,	O
0	int
,	O
0	int
,	O
103	int
,	O
89	int
,	O
83	int
,	O
84	int
,	O
72	int
,	O
81	int
,	O
71	int
,	O
80	int
,	O
68	int
,	O
81	int
,	O
66	int
,	O
81	int
,	O
67	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
46	int
,	O
43	int
,	O
42	int
,	O
51	int
,	O
49	int
,	O
52	int
,	O
50	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
65	int
,	O
48	int
,	O
57	int
,	O
47	int
,	O
98	int
,	O
105	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
73	int
,	O
69	int
,	O
70	int
,	O
0	int
,	O
0	int
,	O
108	int
,	O
78	int
,	O
78	int
,	O
79	int
,	O
77	int
,	O
76	int
}	O
;	O
static	O
const	O
yytype_int16	O
yydefgoto	O
[	O
]	O
=	O
{	O
-	O
1	int
,	O
2	int
,	O
8	int
,	O
9	int
,	O
3	int
,	O
4	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
29	int
,	O
30	int
,	O
65	int
,	O
66	int
,	O
20	int
,	O
24	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
81	int
,	O
82	int
,	O
83	int
,	O
67	int
,	O
121	int
,	O
172	int
,	O
52	int
,	O
53	int
,	O
192	int
,	O
71	int
,	O
122	int
,	O
54	int
,	O
98	int
,	O
55	int
,	O
96	int
,	O
56	int
,	O
57	int
,	O
87	int
,	O
58	int
,	O
120	int
,	O
59	int
,	O
91	int
,	O
92	int
,	O
60	int
,	O
127	int
,	O
159	int
}	O
;	O
static	O
const	O
yytype_int16	O
yypact	O
[	O
]	O
=	O
{	O
1	int
,	O
-	O
73	int
,	O
27	int
,	O
10	int
,	O
22	int
,	O
-	O
73	int
,	O
17	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
1	int
,	O
-	O
73	int
,	O
30	int
,	O
64	int
,	O
-	O
73	int
,	O
105	int
,	O
1	int
,	O
-	O
73	int
,	O
64	int
,	O
-	O
73	int
,	O
15	int
,	O
166	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
1	int
,	O
-	O
73	int
,	O
22	int
,	O
-	O
73	int
,	O
108	int
,	O
15	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
6	int
,	O
21	int
,	O
105	int
,	O
8	int
,	O
9	int
,	O
25	int
,	O
-	O
73	int
,	O
105	int
,	O
58	int
,	O
-	O
73	int
,	O
75	int
,	O
11	int
,	O
11	int
,	O
105	int
,	O
79	int
,	O
82	int
,	O
105	int
,	O
121	int
,	O
-	O
73	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
22	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
86	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
13	int
,	O
89	int
,	O
24	int
,	O
53	int
,	O
105	int
,	O
105	int
,	O
105	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
25	int
,	O
14	int
,	O
25	int
,	O
71	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
116	int
,	O
104	int
,	O
-	O
73	int
,	O
113	int
,	O
73	int
,	O
74	int
,	O
-	O
73	int
,	O
11	int
,	O
-	O
73	int
,	O
11	int
,	O
-	O
73	int
,	O
119	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
123	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
22	int
,	O
22	int
,	O
22	int
,	O
22	int
,	O
22	int
,	O
-	O
73	int
,	O
22	int
,	O
22	int
,	O
22	int
,	O
22	int
,	O
22	int
,	O
-	O
73	int
,	O
105	int
,	O
105	int
,	O
83	int
,	O
105	int
,	O
105	int
,	O
105	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
105	int
,	O
105	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
9	int
,	O
25	int
,	O
25	int
,	O
157	int
,	O
160	int
,	O
150	int
,	O
153	int
,	O
161	int
,	O
163	int
,	O
105	int
,	O
125	int
,	O
105	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
105	int
,	O
105	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
127	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
128	int
,	O
-	O
73	int
,	O
129	int
,	O
-	O
73	int
,	O
105	int
,	O
105	int
,	O
108	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
105	int
,	O
105	int
,	O
105	int
,	O
168	int
,	O
169	int
,	O
3	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
189	int
,	O
190	int
,	O
-	O
73	int
,	O
105	int
,	O
105	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
}	O
;	O
static	O
const	O
yytype_int16	O
yypgoto	O
[	O
]	O
=	O
{	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
7	int
,	O
23	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
179	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
170	int
,	O
38	int
,	O
-	O
64	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
149	int
,	O
-	O
73	int
,	O
120	int
,	O
-	O
69	int
,	O
-	O
73	int
,	O
-	O
39	int
,	O
-	O
14	int
,	O
63	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
13	int
,	O
62	int
,	O
-	O
72	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
-	O
73	int
,	O
162	int
,	O
-	O
56	int
,	O
-	O
73	int
,	O
66	int
,	O
-	O
73	int
}	O
;	O
static	O
const	O
yytype_int16	O
yytable	O
[	O
]	O
=	O
{	O
25	int
,	O
112	int
,	O
12	int
,	O
123	int
,	O
90	int
,	O
90	int
,	O
62	int
,	O
63	int
,	O
64	int
,	O
124	int
,	O
69	int
,	O
1	int
,	O
74	int
,	O
76	int
,	O
62	int
,	O
89	int
,	O
6	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
73	int
,	O
129	int
,	O
130	int
,	O
84	int
,	O
11	int
,	O
85	int
,	O
113	int
,	O
5	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
94	int
,	O
10	int
,	O
114	int
,	O
99	int
,	O
144	int
,	O
160	int
,	O
144	int
,	O
26	int
,	O
7	int
,	O
13	int
,	O
148	int
,	O
150	int
,	O
28	int
,	O
152	int
,	O
154	int
,	O
156	int
,	O
61	int
,	O
188	int
,	O
106	int
,	O
157	int
,	O
158	int
,	O
90	int
,	O
70	int
,	O
90	int
,	O
70	int
,	O
70	int
,	O
78	int
,	O
125	int
,	O
119	int
,	O
161	int
,	O
162	int
,	O
86	int
,	O
116	int
,	O
84	int
,	O
126	int
,	O
84	int
,	O
79	int
,	O
70	int
,	O
80	int
,	O
117	int
,	O
176	int
,	O
14	int
,	O
15	int
,	O
101	int
,	O
102	int
,	O
103	int
,	O
104	int
,	O
105	int
,	O
88	int
,	O
107	int
,	O
108	int
,	O
109	int
,	O
110	int
,	O
95	int
,	O
180	int
,	O
181	int
,	O
97	int
,	O
111	int
,	O
62	int
,	O
63	int
,	O
64	int
,	O
164	int
,	O
166	int
,	O
115	int
,	O
72	int
,	O
1	int
,	O
75	int
,	O
77	int
,	O
118	int
,	O
149	int
,	O
129	int
,	O
130	int
,	O
153	int
,	O
155	int
,	O
183	int
,	O
184	int
,	O
185	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
62	int
,	O
63	int
,	O
64	int
,	O
140	int
,	O
84	int
,	O
84	int
,	O
141	int
,	O
112	int
,	O
142	int
,	O
143	int
,	O
-	O
14	int
,	O
31	int
,	O
171	int
,	O
145	int
,	O
171	int
,	O
146	int
,	O
147	int
,	O
175	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
151	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
131	int
,	O
132	int
,	O
133	int
,	O
134	int
,	O
135	int
,	O
136	int
,	O
167	int
,	O
137	int
,	O
138	int
,	O
168	int
,	O
139	int
,	O
62	int
,	O
63	int
,	O
163	int
,	O
62	int
,	O
63	int
,	O
165	int
,	O
169	int
,	O
31	int
,	O
170	int
,	O
125	int
,	O
177	int
,	O
178	int
,	O
179	int
,	O
186	int
,	O
187	int
,	O
191	int
,	O
191	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
189	int
,	O
190	int
,	O
27	int
,	O
182	int
,	O
100	int
,	O
68	int
,	O
128	int
,	O
0	int
,	O
174	int
,	O
193	int
,	O
173	int
,	O
0	int
,	O
93	int
}	O
;	O
static	O
const	O
yytype_int16	O
yycheck	O
[	O
]	O
=	O
{	O
14	int
,	O
65	int
,	O
9	int
,	O
75	int
,	O
43	int
,	O
44	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
78	int
,	O
4	int
,	O
10	int
,	O
4	int
,	O
4	int
,	O
3	int
,	O
4	int
,	O
6	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
34	int
,	O
30	int
,	O
31	int
,	O
37	int
,	O
7	int
,	O
39	int
,	O
39	int
,	O
0	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
45	int
,	O
10	int
,	O
46	int
,	O
48	int
,	O
91	int
,	O
45	int
,	O
93	int
,	O
15	int
,	O
29	int
,	O
10	int
,	O
113	int
,	O
114	int
,	O
28	int
,	O
116	int
,	O
117	int
,	O
118	int
,	O
24	int
,	O
45	int
,	O
56	int
,	O
122	int
,	O
123	int
,	O
91	int
,	O
47	int
,	O
93	int
,	O
47	int
,	O
47	int
,	O
32	int
,	O
44	int
,	O
73	int
,	O
129	int
,	O
130	int
,	O
4	int
,	O
39	int
,	O
78	int
,	O
79	int
,	O
80	int
,	O
42	int
,	O
47	int
,	O
44	int
,	O
46	int
,	O
143	int
,	O
8	int
,	O
9	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
4	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
60	int
,	O
5	int
,	O
157	int
,	O
158	int
,	O
5	int
,	O
65	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
131	int
,	O
132	int
,	O
5	int
,	O
33	int
,	O
10	int
,	O
35	int
,	O
36	int
,	O
46	int
,	O
114	int
,	O
30	int
,	O
31	int
,	O
117	int
,	O
118	int
,	O
177	int
,	O
178	int
,	O
179	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
10	int
,	O
129	int
,	O
130	int
,	O
4	int
,	O
182	int
,	O
46	int
,	O
46	int
,	O
0	int
,	O
1	int
,	O
137	int
,	O
5	int
,	O
139	int
,	O
3	int
,	O
4	int
,	O
142	int
,	O
8	int
,	O
9	int
,	O
48	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
5	int
,	O
40	int
,	O
41	int
,	O
5	int
,	O
43	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
5	int
,	O
1	int
,	O
5	int
,	O
44	int
,	O
43	int
,	O
43	int
,	O
43	int
,	O
5	int
,	O
5	int
,	O
189	int
,	O
190	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
5	int
,	O
5	int
,	O
17	int
,	O
159	int
,	O
49	int
,	O
29	int
,	O
80	int
,	O
-	O
1	int
,	O
139	int
,	O
190	int
,	O
138	int
,	O
-	O
1	int
,	O
44	int
}	O
;	O
static	O
const	O
yytype_uint8	O
yystos	O
[	O
]	O
=	O
{	O
0	int
,	O
10	int
,	O
50	int
,	O
53	int
,	O
54	int
,	O
0	int
,	O
6	int
,	O
29	int
,	O
51	int
,	O
52	int
,	O
10	int
,	O
7	int
,	O
53	int
,	O
10	int
,	O
8	int
,	O
9	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
63	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
64	int
,	O
72	int
,	O
54	int
,	O
57	int
,	O
28	int
,	O
59	int
,	O
60	int
,	O
1	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
65	int
,	O
66	int
,	O
67	int
,	O
74	int
,	O
75	int
,	O
79	int
,	O
81	int
,	O
83	int
,	O
84	int
,	O
86	int
,	O
88	int
,	O
91	int
,	O
54	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
61	int
,	O
62	int
,	O
71	int
,	O
60	int
,	O
4	int
,	O
47	int
,	O
77	int
,	O
77	int
,	O
72	int
,	O
4	int
,	O
77	int
,	O
4	int
,	O
77	int
,	O
32	int
,	O
42	int
,	O
44	int
,	O
68	int
,	O
69	int
,	O
70	int
,	O
72	int
,	O
72	int
,	O
4	int
,	O
85	int
,	O
4	int
,	O
4	int
,	O
71	int
,	O
89	int
,	O
90	int
,	O
89	int
,	O
72	int
,	O
5	int
,	O
82	int
,	O
5	int
,	O
80	int
,	O
72	int
,	O
66	int
,	O
54	int
,	O
54	int
,	O
54	int
,	O
54	int
,	O
54	int
,	O
53	int
,	O
54	int
,	O
54	int
,	O
54	int
,	O
54	int
,	O
54	int
,	O
62	int
,	O
39	int
,	O
46	int
,	O
5	int
,	O
39	int
,	O
46	int
,	O
46	int
,	O
72	int
,	O
87	int
,	O
72	int
,	O
78	int
,	O
78	int
,	O
69	int
,	O
44	int
,	O
72	int
,	O
92	int
,	O
68	int
,	O
30	int
,	O
31	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
40	int
,	O
41	int
,	O
43	int
,	O
10	int
,	O
4	int
,	O
46	int
,	O
46	int
,	O
90	int
,	O
5	int
,	O
3	int
,	O
4	int
,	O
78	int
,	O
72	int
,	O
78	int
,	O
48	int
,	O
78	int
,	O
72	int
,	O
78	int
,	O
72	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
93	int
,	O
45	int
,	O
69	int
,	O
69	int
,	O
5	int
,	O
71	int
,	O
5	int
,	O
71	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
72	int
,	O
73	int
,	O
92	int
,	O
73	int
,	O
72	int
,	O
78	int
,	O
43	int
,	O
43	int
,	O
43	int
,	O
78	int
,	O
78	int
,	O
61	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
5	int
,	O
5	int
,	O
45	int
,	O
5	int
,	O
5	int
,	O
72	int
,	O
76	int
,	O
76	int
}	O
;	O
static	O
void	O
yy_symbol_value_print	O
(	O
FILE	struct
*	O
yyoutput	O
,	O
int	O
yytype	O
,	O
YYSTYPE	O
const	O
*	O
const	O
yyvaluep	O
,	O
YYLTYPE	O
const	O
*	O
const	O
yylocationp	O
)	O
{	O
FILE	struct
*	O
yyo	O
=	O
yyoutput	O
;	O
YYUSE	O
(	O
yyo	O
)	O
;	O
if	O
(	O
!	O
yyvaluep	O
)	O
return	O
;	O
YYUSE	O
(	O
yylocationp	O
)	O
;	O
YYUSE	O
(	O
yyoutput	O
)	O
;	O
switch	O
(	O
yytype	O
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
void	O
yy_symbol_print	O
(	O
FILE	struct
*	O
yyoutput	O
,	O
int	O
yytype	O
,	O
YYSTYPE	O
const	O
*	O
const	O
yyvaluep	O
,	O
YYLTYPE	O
const	O
*	O
const	O
yylocationp	O
)	O
{	O
if	O
(	O
yytype	O
<	O
YYNTOKENS	O
)	O
YYFPRINTF	O
(	O
yyoutput	O
,	O
"token %s ("	*(char)
,	O
yytname	O
[	O
yytype	O
]	O
)	O
;	O
else	O
YYFPRINTF	O
(	O
yyoutput	O
,	O
"nterm %s ("	*(char)
,	O
yytname	O
[	O
yytype	O
]	O
)	O
;	O
YY_LOCATION_PRINT	O
(	O
yyoutput	O
,	O
*	O
yylocationp	O
)	O
;	O
YYFPRINTF	O
(	O
yyoutput	O
,	O
": "	*(char)
)	O
;	O
yy_symbol_value_print	O
(	O
yyoutput	O
,	O
yytype	O
,	O
yyvaluep	O
,	O
yylocationp	O
)	O
;	O
YYFPRINTF	O
(	O
yyoutput	O
,	O
")"	*(char)
)	O
;	O
}	O
static	O
void	O
yy_stack_print	O
(	O
yytype_int16	O
*	O
yybottom	O
,	O
yytype_int16	O
*	O
yytop	O
)	O
{	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Stack now"	*(char)
)	O
;	O
for	O
(	O
;	O
yybottom	O
<=	O
yytop	O
;	O
yybottom	O
++	O
)	O
{	O
int	O
yybot	O
=	O
*	O
yybottom	O
;	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %d"	*(char)
,	O
yybot	O
)	O
;	O
}	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
static	O
void	O
yy_reduce_print	O
(	O
YYSTYPE	O
*	O
yyvsp	O
,	O
YYLTYPE	O
*	O
yylsp	O
,	O
int	O
yyrule	O
)	O
{	O
int	O
yynrhs	O
=	O
yyr2	O
[	O
yyrule	O
]	O
;	O
int	O
yyi	O
;	O
unsigned	O
long	O
int	O
yylno	O
=	O
yyrline	O
[	O
yyrule	O
]	O
;	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Reducing stack by rule %d (line %lu):\n"	*(char)
,	O
yyrule	O
-	O
1	int
,	O
yylno	O
)	O
;	O
for	O
(	O
yyi	O
=	O
0	int
;	O
yyi	O
<	O
yynrhs	O
;	O
yyi	O
++	O
)	O
{	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"   $%d = "	*(char)
,	O
yyi	O
+	O
1	int
)	O
;	O
yy_symbol_print	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
yyrhs	O
[	O
yyprhs	O
[	O
yyrule	O
]	O
+	O
yyi	O
]	O
,	O
&	O
(	O
yyvsp	O
[	O
(	O
yyi	O
+	O
1	int
)	O
-	O
(	O
yynrhs	O
)	O
]	O
)	O
,	O
&	O
(	O
yylsp	O
[	O
(	O
yyi	O
+	O
1	int
)	O
-	O
(	O
yynrhs	O
)	O
]	O
)	O
)	O
;	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
}	O
int	O
yydebug	O
;	O
static	O
YYSIZE_T	O
yytnamerr	O
(	O
char	O
*	O
yyres	O
,	O
const	O
char	O
*	O
yystr	O
)	O
{	O
if	O
(	O
*	O
yystr	O
==	O
'"'	O
)	O
{	O
YYSIZE_T	O
yyn	O
=	O
0	int
;	O
char	O
const	O
*	O
yyp	O
=	O
yystr	O
;	O
for	O
(	O
;	O
;	O
)	O
switch	O
(	O
*	O
++	O
yyp	O
)	O
{	O
case	O
'\''	O
:	O
case	O
','	O
:	O
goto	O
do_not_strip_quotes	O
;	O
case	O
'\\'	O
:	O
if	O
(	O
*	O
++	O
yyp	O
!=	O
'\\'	O
)	O
goto	O
do_not_strip_quotes	O
;	O
default	O
:	O
if	O
(	O
yyres	O
)	O
yyres	O
[	O
yyn	O
]	O
=	O
*	O
yyp	O
;	O
yyn	O
++	O
;	O
break	O
;	O
case	O
'"'	O
:	O
if	O
(	O
yyres	O
)	O
yyres	O
[	O
yyn	O
]	O
=	O
'\0'	O
;	O
return	O
yyn	O
;	O
}	O
do_not_strip_quotes	O
:	O
;	O
}	O
if	O
(	O
!	O
yyres	O
)	O
return	O
yystrlen	O
(	O
yystr	O
)	O
;	O
return	O
yystpcpy	O
(	O
yyres	O
,	O
yystr	O
)	O
-	O
yyres	O
;	O
}	O
static	O
int	O
yysyntax_error	O
(	O
YYSIZE_T	O
*	O
yymsg_alloc	O
,	O
char	O
*	O
*	O
yymsg	O
,	O
yytype_int16	O
*	O
yyssp	O
,	O
int	O
yytoken	O
)	O
{	O
YYSIZE_T	O
yysize0	O
=	O
yytnamerr	O
(	O
YY_NULL	O
,	O
yytname	O
[	O
yytoken	O
]	O
)	O
;	O
YYSIZE_T	O
yysize	O
=	O
yysize0	O
;	O
enum	O
{	O
YYERROR_VERBOSE_ARGS_MAXIMUM	O
=	O
5	int
}	O
;	O
const	O
char	O
*	O
yyformat	O
=	O
YY_NULL	O
;	O
char	O
const	O
*	O
yyarg	O
[	O
YYERROR_VERBOSE_ARGS_MAXIMUM	O
]	O
;	O
int	O
yycount	O
=	O
0	int
;	O
if	O
(	O
yytoken	O
!=	O
YYEMPTY	O
)	O
{	O
int	O
yyn	O
=	O
yypact	O
[	O
*	O
yyssp	O
]	O
;	O
yyarg	O
[	O
yycount	O
++	O
]	O
=	O
yytname	O
[	O
yytoken	O
]	O
;	O
if	O
(	O
!	O
yypact_value_is_default	O
(	O
yyn	O
)	O
)	O
{	O
int	O
yyxbegin	O
=	O
yyn	O
<	O
0	int
?	O
-	O
yyn	O
:	O
0	int
;	O
int	O
yychecklim	O
=	O
YYLAST	O
-	O
yyn	O
+	O
1	int
;	O
int	O
yyxend	O
=	O
yychecklim	O
<	O
YYNTOKENS	O
?	O
yychecklim	O
:	O
YYNTOKENS	O
;	O
int	O
yyx	O
;	O
for	O
(	O
yyx	O
=	O
yyxbegin	O
;	O
yyx	O
<	O
yyxend	O
;	O
++	O
yyx	O
)	O
if	O
(	O
yycheck	O
[	O
yyx	O
+	O
yyn	O
]	O
==	O
yyx	O
&&	O
yyx	O
!=	O
YYTERROR	O
&&	O
!	O
yytable_value_is_error	O
(	O
yytable	O
[	O
yyx	O
+	O
yyn	O
]	O
)	O
)	O
{	O
if	O
(	O
yycount	O
==	O
YYERROR_VERBOSE_ARGS_MAXIMUM	O
)	O
{	O
yycount	O
=	O
1	int
;	O
yysize	O
=	O
yysize0	O
;	O
break	O
;	O
}	O
yyarg	O
[	O
yycount	O
++	O
]	O
=	O
yytname	O
[	O
yyx	O
]	O
;	O
{	O
YYSIZE_T	O
yysize1	O
=	O
yysize	O
+	O
yytnamerr	O
(	O
YY_NULL	O
,	O
yytname	O
[	O
yyx	O
]	O
)	O
;	O
if	O
(	O
!	O
(	O
yysize	O
<=	O
yysize1	O
&&	O
yysize1	O
<=	O
YYSTACK_ALLOC_MAXIMUM	O
)	O
)	O
return	O
2	int
;	O
yysize	O
=	O
yysize1	O
;	O
}	O
}	O
}	O
}	O
switch	O
(	O
yycount	O
)	O
{	O
YYCASE_	O
(	O
0	int
,	O
YY_	O
(	O
"syntax error"	*(char)
)	O
)	O
;	O
YYCASE_	O
(	O
1	int
,	O
YY_	O
(	O
"syntax error, unexpected %s"	*(char)
)	O
)	O
;	O
YYCASE_	O
(	O
2	int
,	O
YY_	O
(	O
"syntax error, unexpected %s, expecting %s"	*(char)
)	O
)	O
;	O
YYCASE_	O
(	O
3	int
,	O
YY_	O
(	O
"syntax error, unexpected %s, expecting %s or %s"	*(char)
)	O
)	O
;	O
YYCASE_	O
(	O
4	int
,	O
YY_	O
(	O
"syntax error, unexpected %s, expecting %s or %s or %s"	*(char)
)	O
)	O
;	O
YYCASE_	O
(	O
5	int
,	O
YY_	O
(	O
"syntax error, unexpected %s, expecting %s or %s or %s or %s"	*(char)
)	O
)	O
;	O
}	O
{	O
YYSIZE_T	O
yysize1	O
=	O
yysize	O
+	O
yystrlen	O
(	O
yyformat	O
)	O
;	O
if	O
(	O
!	O
(	O
yysize	O
<=	O
yysize1	O
&&	O
yysize1	O
<=	O
YYSTACK_ALLOC_MAXIMUM	O
)	O
)	O
return	O
2	int
;	O
yysize	O
=	O
yysize1	O
;	O
}	O
if	O
(	O
*	O
yymsg_alloc	O
<	O
yysize	O
)	O
{	O
*	O
yymsg_alloc	O
=	O
2	int
*	O
yysize	O
;	O
if	O
(	O
!	O
(	O
yysize	O
<=	O
*	O
yymsg_alloc	O
&&	O
*	O
yymsg_alloc	O
<=	O
YYSTACK_ALLOC_MAXIMUM	O
)	O
)	O
*	O
yymsg_alloc	O
=	O
YYSTACK_ALLOC_MAXIMUM	O
;	O
return	O
1	int
;	O
}	O
{	O
char	O
*	O
yyp	O
=	O
*	O
yymsg	O
;	O
int	O
yyi	O
=	O
0	int
;	O
while	O
(	O
(	O
*	O
yyp	O
=	O
*	O
yyformat	O
)	O
!=	O
'\0'	O
)	O
if	O
(	O
*	O
yyp	O
==	O
'%'	O
&&	O
yyformat	O
[	O
1	int
]	O
==	O
's'	O
&&	O
yyi	O
<	O
yycount	O
)	O
{	O
yyp	O
+=	O
yytnamerr	O
(	O
yyp	O
,	O
yyarg	O
[	O
yyi	O
++	O
]	O
)	O
;	O
yyformat	O
+=	O
2	int
;	O
}	O
else	O
{	O
yyp	O
++	O
;	O
yyformat	O
++	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
yydestruct	O
(	O
const	O
char	O
*	O
yymsg	O
,	O
int	O
yytype	O
,	O
YYSTYPE	O
*	O
yyvaluep	O
,	O
YYLTYPE	O
*	O
yylocationp	O
)	O
{	O
YYUSE	O
(	O
yyvaluep	O
)	O
;	O
YYUSE	O
(	O
yylocationp	O
)	O
;	O
if	O
(	O
!	O
yymsg	O
)	O
yymsg	O
=	O
"Deleting"	*(char)
;	O
YY_SYMBOL_PRINT	O
(	O
yymsg	O
,	O
yytype	O
,	O
yyvaluep	O
,	O
yylocationp	O
)	O
;	O
switch	O
(	O
yytype	O
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
int	O
yychar	O
;	O
YYSTYPE	O
yylval	O
YY_INITIAL_VALUE	O
(	O
yyval_default	O
)	O
;	O
YYLTYPE	O
yylloc	O
;	O
int	O
yynerrs	O
;	O
int	O
yyparse	O
(	O
void	O
)	O
{	O
int	O
yystate	O
;	O
int	O
yyerrstatus	O
;	O
yytype_int16	O
yyssa	O
[	O
YYINITDEPTH	O
]	O
;	O
yytype_int16	O
*	O
yyss	O
;	O
yytype_int16	O
*	O
yyssp	O
;	O
YYSTYPE	O
yyvsa	O
[	O
YYINITDEPTH	O
]	O
;	O
YYSTYPE	O
*	O
yyvs	O
;	O
YYSTYPE	O
*	O
yyvsp	O
;	O
YYLTYPE	O
yylsa	O
[	O
YYINITDEPTH	O
]	O
;	O
YYLTYPE	O
*	O
yyls	O
;	O
YYLTYPE	O
*	O
yylsp	O
;	O
YYLTYPE	O
yyerror_range	O
[	O
3	int
]	O
;	O
YYSIZE_T	O
yystacksize	O
;	O
int	O
yyn	O
;	O
int	O
yyresult	O
;	O
int	O
yytoken	O
=	O
0	int
;	O
YYSTYPE	O
yyval	O
;	O
YYLTYPE	O
yyloc	O
;	O
char	O
yymsgbuf	O
[	O
128	int
]	O
;	O
char	O
*	O
yymsg	O
=	O
yymsgbuf	O
;	O
YYSIZE_T	O
yymsg_alloc	O
=	O
sizeof	O
yymsgbuf	O
;	O
int	O
yylen	O
=	O
0	int
;	O
yyssp	O
=	O
yyss	O
=	O
yyssa	O
;	O
yyvsp	O
=	O
yyvs	O
=	O
yyvsa	O
;	O
yylsp	O
=	O
yyls	O
=	O
yylsa	O
;	O
yystacksize	O
=	O
YYINITDEPTH	O
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Starting parse\n"	*(char)
)	O
)	O
;	O
yystate	O
=	O
0	int
;	O
yyerrstatus	O
=	O
0	int
;	O
yynerrs	O
=	O
0	int
;	O
yychar	O
=	O
YYEMPTY	O
;	O
yylsp	O
[	O
0	int
]	O
=	O
yylloc	O
;	O
goto	O
yysetstate	O
;	O
yynewstate	O
:	O
yyssp	O
++	O
;	O
yysetstate	O
:	O
*	O
yyssp	O
=	O
yystate	O
;	O
if	O
(	O
yyss	O
+	O
yystacksize	O
-	O
1	int
<=	O
yyssp	O
)	O
{	O
YYSIZE_T	O
yysize	O
=	O
yyssp	O
-	O
yyss	O
+	O
1	int
;	O
if	O
(	O
YYMAXDEPTH	O
<=	O
yystacksize	O
)	O
goto	O
yyexhaustedlab	O
;	O
yystacksize	O
*=	O
2	int
;	O
if	O
(	O
YYMAXDEPTH	O
<	O
yystacksize	O
)	O
yystacksize	O
=	O
YYMAXDEPTH	O
;	O
{	O
yytype_int16	O
*	O
yyss1	O
=	O
yyss	O
;	O
union	O
yyalloc	O
*	O
yyptr	O
=	O
(	O
union	O
yyalloc	O
*	O
)	O
YYSTACK_ALLOC	O
(	O
YYSTACK_BYTES	O
(	O
yystacksize	O
)	O
)	O
;	O
if	O
(	O
!	O
yyptr	O
)	O
goto	O
yyexhaustedlab	O
;	O
YYSTACK_RELOCATE	O
(	O
yyss_alloc	O
,	O
yyss	O
)	O
;	O
YYSTACK_RELOCATE	O
(	O
yyvs_alloc	O
,	O
yyvs	O
)	O
;	O
YYSTACK_RELOCATE	O
(	O
yyls_alloc	O
,	O
yyls	O
)	O
;	O
if	O
(	O
yyss1	O
!=	O
yyssa	O
)	O
YYSTACK_FREE	O
(	O
yyss1	O
)	O
;	O
}	O
yyssp	O
=	O
yyss	O
+	O
yysize	O
-	O
1	int
;	O
yyvsp	O
=	O
yyvs	O
+	O
yysize	O
-	O
1	int
;	O
yylsp	O
=	O
yyls	O
+	O
yysize	O
-	O
1	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Stack size increased to %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
int	O
)	O
yystacksize	O
)	O
)	O
;	O
if	O
(	O
yyss	O
+	O
yystacksize	O
-	O
1	int
<=	O
yyssp	O
)	O
YYABORT	O
;	O
}	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Entering state %d\n"	*(char)
,	O
yystate	O
)	O
)	O
;	O
if	O
(	O
yystate	O
==	O
YYFINAL	O
)	O
YYACCEPT	O
;	O
goto	O
yybackup	O
;	O
yybackup	O
:	O
yyn	O
=	O
yypact	O
[	O
yystate	O
]	O
;	O
if	O
(	O
yypact_value_is_default	O
(	O
yyn	O
)	O
)	O
goto	O
yydefault	O
;	O
if	O
(	O
yychar	O
==	O
YYEMPTY	O
)	O
{	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Reading a token: "	*(char)
)	O
)	O
;	O
yychar	O
=	O
YYLEX	O
;	O
}	O
if	O
(	O
yychar	O
<=	O
YYEOF	O
)	O
{	O
yychar	O
=	O
yytoken	O
=	O
YYEOF	O
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Now at end of input.\n"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
yytoken	O
=	O
YYTRANSLATE	O
(	O
yychar	O
)	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Next token is"	*(char)
,	O
yytoken	O
,	O
&	O
yylval	O
,	O
&	O
yylloc	O
)	O
;	O
}	O
yyn	O
+=	O
yytoken	O
;	O
if	O
(	O
yyn	O
<	O
0	int
||	O
YYLAST	O
<	O
yyn	O
||	O
yycheck	O
[	O
yyn	O
]	O
!=	O
yytoken	O
)	O
goto	O
yydefault	O
;	O
yyn	O
=	O
yytable	O
[	O
yyn	O
]	O
;	O
if	O
(	O
yyn	O
<=	O
0	int
)	O
{	O
if	O
(	O
yytable_value_is_error	O
(	O
yyn	O
)	O
)	O
goto	O
yyerrlab	O
;	O
yyn	O
=	O
-	O
yyn	O
;	O
goto	O
yyreduce	O
;	O
}	O
if	O
(	O
yyerrstatus	O
)	O
yyerrstatus	O
--	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	*(char)
,	O
yytoken	O
,	O
&	O
yylval	O
,	O
&	O
yylloc	O
)	O
;	O
yychar	O
=	O
YYEMPTY	O
;	O
yystate	O
=	O
yyn	O
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	O
*	O
++	O
yyvsp	O
=	O
yylval	O
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_END	O
*	O
++	O
yylsp	O
=	O
yylloc	O
;	O
goto	O
yynewstate	O
;	O
yydefault	O
:	O
yyn	O
=	O
yydefact	O
[	O
yystate	O
]	O
;	O
if	O
(	O
yyn	O
==	O
0	int
)	O
goto	O
yyerrlab	O
;	O
goto	O
yyreduce	O
;	O
yyreduce	O
:	O
yylen	O
=	O
yyr2	O
[	O
yyn	O
]	O
;	O
yyval	O
=	O
yyvsp	O
[	O
1	int
-	O
yylen	O
]	O
;	O
YYLLOC_DEFAULT	O
(	O
yyloc	O
,	O
(	O
yylsp	O
-	O
yylen	O
)	O
,	O
yylen	O
)	O
;	O
YY_REDUCE_PRINT	O
(	O
yyn	O
)	O
;	O
switch	O
(	O
yyn	O
)	O
{	O
case	O
3	int
:	O
{	O
if	O
(	O
errors	O
)	O
YYERROR	O
;	O
}	O
break	O
;	O
case	O
4	int
:	O
{	O
if	O
(	O
parse_old_rc	O
(	O
)	O
)	O
YYERROR	O
;	O
}	O
break	O
;	O
case	O
5	int
:	O
{	O
if	O
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
version	(*(char))->(void)
)	O
.	O
major	O
==	O
2	int
&&	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
version	(*(char))->(void)
)	O
.	O
minor	O
==	O
0	int
)	O
{	O
cflex_normal	O
(	O
)	O
;	O
}	O
else	O
{	O
cferror	O
(	O
&	O
(	O
yylsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
,	O
_	O
(	O
"unsupported configuration file version"	*(char)
)	O
)	O
;	O
YYERROR	O
;	O
}	O
}	O
break	O
;	O
case	O
19	int
:	O
{	O
struct	O
cfloc	O
loc	O
;	O
loc	O
.	O
beg	O
=	O
(	O
yylsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
beg	O
;	O
loc	O
.	O
end	*(long)
=	O
(	O
yylsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
end	*(long)
;	O
global_attrib_set	O
(	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
global_attrib	O
)	O
,	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
arglist	O
)	O
.	O
argc	int
,	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
arglist	O
)	O
.	O
head	O
,	O
&	O
loc	O
)	O
;	O
arglist_free	O
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
arglist	O
)	O
.	O
head	O
)	O
;	O
}	O
break	O
;	O
case	O
20	int
:	O
{	O
(	O
yyval	O
.	O
arglist	O
)	O
.	O
head	O
=	O
(	O
yyval	O
.	O
arglist	O
)	O
.	O
tail	O
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
arg	struct(int,int)
)	O
;	O
(	O
yyval	O
.	O
arglist	O
)	O
.	O
argc	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
21	int
:	O
{	O
LIST_APPEND	O
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
arg	struct(int,int)
)	O
,	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
arglist	O
)	O
.	O
head	O
,	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
arglist	O
)	O
.	O
tail	O
)	O
;	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
arglist	O
)	O
.	O
argc	int
++	O
;	O
(	O
yyval	O
.	O
arglist	O
)	O
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
arglist	O
)	O
;	O
}	O
break	O
;	O
case	O
22	int
:	O
{	O
(	O
yyval	O
.	O
arg	struct(int,int)
)	O
=	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
(	O
yyval	O
.	O
arg	struct(int,int)
)	O
)	O
)	O
;	O
(	O
yyval	O
.	O
arg	struct(int,int)
)	O
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
=	O
NULL	O
;	O
(	O
yyval	O
.	O
arg	struct(int,int)
)	O
->	O
loc	O
=	O
(	O
yylsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
)	O
;	O
(	O
yyval	O
.	O
arg	struct(int,int)
)	O
->	O
isnum	O
=	O
0	int
;	O
(	O
yyval	O
.	O
arg	struct(int,int)
)	O
->	O
strval	O
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
23	int
:	O
{	O
(	O
yyval	O
.	O
arg	struct(int,int)
)	O
=	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
(	O
yyval	O
.	O
arg	struct(int,int)
)	O
)	O
)	O
;	O
(	O
yyval	O
.	O
arg	struct(int,int)
)	O
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
=	O
NULL	O
;	O
(	O
yyval	O
.	O
arg	struct(int,int)
)	O
->	O
loc	O
=	O
(	O
yylsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
)	O
;	O
(	O
yyval	O
.	O
arg	struct(int,int)
)	O
->	O
isnum	O
=	O
1	int
;	O
(	O
yyval	O
.	O
arg	struct(int,int)
)	O
->	O
strval	O
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
num	long
)	O
.	O
strval	O
;	O
(	O
yyval	O
.	O
arg	struct(int,int)
)	O
->	O
intval	O
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
}	O
break	O
;	O
case	O
24	int
:	O
{	O
current_rule	O
=	O
new_rush_rule	O
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
;	O
current_rule	O
->	O
file	*(char)
=	O
(	O
yylsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
beg	O
.	O
filename	O
;	O
current_rule	O
->	O
line	O
=	O
(	O
yylsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
beg	O
.	O
line	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
25	int
:	O
{	O
(	O
yyval	O
.	O
str	*(char)
)	O
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
39	int
:	O
{	O
skiptoeol	O
(	O
)	O
;	O
restorenormal	O
(	O
)	O
;	O
yyerrok	O
;	O
yyclearin	O
;	O
errors	O
=	O
1	int
;	O
}	O
break	O
;	O
case	O
40	int
:	O
{	O
if	O
(	O
current_rule	O
->	O
test_node	O
)	O
{	O
struct	O
test_node	O
*	O
np	O
=	O
new_test_node	O
(	O
test_and	int
)	O
;	O
np	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
0	int
]	O
=	O
current_rule	O
->	O
test_node	O
;	O
np	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
1	int
]	O
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
node	O
)	O
;	O
current_rule	O
->	O
test_node	O
=	O
np	O
;	O
}	O
else	O
current_rule	O
->	O
test_node	O
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
node	O
)	O
;	O
}	O
break	O
;	O
case	O
42	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_and	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
0	int
]	O
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
node	O
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
1	int
]	O
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
node	O
)	O
;	O
}	O
break	O
;	O
case	O
43	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_or	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
0	int
]	O
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
node	O
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
1	int
]	O
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
node	O
)	O
;	O
}	O
break	O
;	O
case	O
45	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_not	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
0	int
]	O
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
node	O
)	O
;	O
}	O
break	O
;	O
case	O
46	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
node	O
)	O
;	O
}	O
break	O
;	O
case	O
47	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_cmps	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_match	int
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
rx	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
regex	O
)	O
;	O
}	O
break	O
;	O
case	O
48	int
:	O
{	O
struct	O
test_node	O
*	O
np	O
=	O
new_test_node	O
(	O
test_cmps	int
)	O
;	O
np	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_match	int
;	O
np	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
np	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
rx	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
regex	O
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_not	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
0	int
]	O
=	O
np	O
;	O
}	O
break	O
;	O
case	O
49	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_cmps	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_eq	int
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
str	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
50	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_cmps	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_ne	int
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
str	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
51	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_cmpn	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_eq	int
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
num	long
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
}	O
break	O
;	O
case	O
52	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_cmpn	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_ne	int
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
num	long
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
}	O
break	O
;	O
case	O
53	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_cmpn	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_lt	int
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
num	long
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
}	O
break	O
;	O
case	O
54	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_cmpn	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_le	int
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
num	long
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
}	O
break	O
;	O
case	O
55	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_cmpn	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_gt	int
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
num	long
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
}	O
break	O
;	O
case	O
56	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_cmpn	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_ge	int
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
num	long
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
}	O
break	O
;	O
case	O
57	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_in	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_in	int
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
strv	*(*(char))
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
strlist	O
)	O
.	O
argv	*(*(char))
;	O
}	O
break	O
;	O
case	O
58	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_group	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
groups	*(*(char))
=	O
xcalloc	(long,long)->(*(void))
(	O
2	int
,	O
sizeof	O
(	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
groups	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
groups	*(*(char))
[	O
0	int
]	O
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
groups	*(*(char))
[	O
1	int
]	O
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
59	int
:	O
{	O
(	O
yyval	O
.	O
node	O
)	O
=	O
new_test_node	O
(	O
test_group	int
)	O
;	O
(	O
yyval	O
.	O
node	O
)	O
->	O
v	union(*(char),struct(int,int))
.	O
groups	*(*(char))
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
strlist	O
)	O
.	O
argv	*(*(char))
;	O
}	O
break	O
;	O
case	O
64	int
:	O
{	O
(	O
yyval	O
.	O
str	*(char)
)	O
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
num	long
)	O
.	O
strval	O
;	O
}	O
break	O
;	O
case	O
65	int
:	O
{	O
int	O
rc	O
=	O
regcomp	O
(	O
&	O
(	O
yyval	O
.	O
regex	O
)	O
,	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
re_flags	O
)	O
;	O
if	O
(	O
rc	O
)	O
{	O
char	O
errbuf	O
[	O
512	int
]	O
;	O
regerror	O
(	O
rc	O
,	O
&	O
(	O
yyval	O
.	O
regex	O
)	O
,	O
errbuf	O
,	O
sizeof	O
(	O
errbuf	O
)	O
)	O
;	O
cferror	O
(	O
&	O
(	O
yylsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
)	O
,	O
_	O
(	O
"invalid regexp: %s"	*(char)
)	O
,	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
;	O
YYERROR	O
;	O
}	O
}	O
break	O
;	O
case	O
66	int
:	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
;	O
node	O
=	O
new_transform_node	O
(	O
current_rule	O
,	O
transform_set	int
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_arg	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
ins	int
=	O
0	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
idx	int
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
intval	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
pattern	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
trans	*(struct)
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
67	int
:	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
;	O
node	O
=	O
new_transform_node	O
(	O
current_rule	O
,	O
transform_set	int
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_arg	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
ins	int
=	O
1	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
idx	int
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
intval	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
pattern	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
trans	*(struct)
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
68	int
:	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
;	O
node	O
=	O
new_transform_node	O
(	O
current_rule	O
,	O
transform_set	int
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_arg	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
ins	int
=	O
0	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
idx	int
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
intval	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
pattern	*(char)
=	O
NULL	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
trans	*(struct)
=	O
compile_transform_expr	O
(	O
(	O
yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
re_flags	O
,	O
&	O
(	O
yylsp	O
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
69	int
:	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
;	O
node	O
=	O
new_transform_node	O
(	O
current_rule	O
,	O
transform_set	int
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_arg	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
ins	int
=	O
0	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
idx	int
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
intval	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
pattern	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
trans	*(struct)
=	O
compile_transform_expr	O
(	O
(	O
yyvsp	O
[	O
(	O
6	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
re_flags	O
,	O
&	O
(	O
yylsp	O
[	O
(	O
6	int
)	O
-	O
(	O
6	int
)	O
]	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
70	int
:	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
;	O
node	O
=	O
new_transform_node	O
(	O
current_rule	O
,	O
transform_set	int
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_arg	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
ins	int
=	O
1	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
idx	int
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
intval	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
pattern	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
trans	*(struct)
=	O
compile_transform_expr	O
(	O
(	O
yyvsp	O
[	O
(	O
6	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
re_flags	O
,	O
&	O
(	O
yylsp	O
[	O
(	O
6	int
)	O
-	O
(	O
6	int
)	O
]	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
71	int
:	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
=	O
new_set_node	O
(	O
transform_set	int
,	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
&	O
(	O
yylsp	O
[	O
(	O
2	int
)	O
-	O
(	O
4	int
)	O
]	O
)	O
)	O
;	O
if	O
(	O
node	O
)	O
{	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
pattern	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
trans	*(struct)
=	O
NULL	O
;	O
}	O
}	O
break	O
;	O
case	O
72	int
:	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
=	O
new_set_node	O
(	O
transform_set	int
,	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
&	O
(	O
yylsp	O
[	O
(	O
2	int
)	O
-	O
(	O
4	int
)	O
]	O
)	O
)	O
;	O
if	O
(	O
node	O
)	O
{	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
pattern	*(char)
=	O
NULL	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
trans	*(struct)
=	O
compile_transform_expr	O
(	O
(	O
yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
re_flags	O
,	O
&	O
(	O
yylsp	O
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
)	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
73	int
:	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
=	O
new_set_node	O
(	O
transform_set	int
,	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
&	O
(	O
yylsp	O
[	O
(	O
2	int
)	O
-	O
(	O
6	int
)	O
]	O
)	O
)	O
;	O
if	O
(	O
node	O
)	O
{	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
pattern	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
trans	*(struct)
=	O
compile_transform_expr	O
(	O
(	O
yyvsp	O
[	O
(	O
6	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
re_flags	O
,	O
&	O
(	O
yylsp	O
[	O
(	O
6	int
)	O
-	O
(	O
6	int
)	O
]	O
)	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
74	int
:	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
=	O
new_set_node	O
(	O
transform_delete	int
,	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
&	O
(	O
yylsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
)	O
)	O
;	O
if	O
(	O
node	O
)	O
{	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
name	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
}	O
}	O
break	O
;	O
case	O
75	int
:	O
{	O
if	O
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
intval	O
)	O
==	O
0	int
)	O
{	O
cferror	O
(	O
&	O
(	O
yylsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
)	O
,	O
_	O
(	O
"$0 cannot be unset"	*(char)
)	O
)	O
;	O
errors	O
++	O
;	O
}	O
else	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
=	O
new_transform_node	O
(	O
current_rule	O
,	O
transform_delete	int
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_arg	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
ins	int
=	O
0	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
idx	int
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
intval	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
arg_end	int
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
intval	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
76	int
:	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
;	O
node	O
=	O
new_transform_node	O
(	O
current_rule	O
,	O
transform_map	int
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_arg	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
ins	int
=	O
0	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
idx	int
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
intval	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
file	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
delim	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
key	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
5	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
key_field	int
=	O
(	O
yyvsp	O
[	O
(	O
6	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
val_field	int
=	O
(	O
yyvsp	O
[	O
(	O
7	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
defval	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
8	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
6	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
num	long
)	O
.	O
strval	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
7	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
num	long
)	O
.	O
strval	O
)	O
;	O
}	O
break	O
;	O
case	O
77	int
:	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
;	O
node	O
=	O
new_set_node	O
(	O
transform_map	int
,	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
&	O
(	O
yylsp	O
[	O
(	O
2	int
)	O
-	O
(	O
8	int
)	O
]	O
)	O
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
name	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
file	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
delim	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
key	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
5	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
key_field	int
=	O
(	O
yyvsp	O
[	O
(	O
6	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
val_field	int
=	O
(	O
yyvsp	O
[	O
(	O
7	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
defval	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
8	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
6	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
num	long
)	O
.	O
strval	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
7	int
)	O
-	O
(	O
8	int
)	O
]	O
.	O
num	long
)	O
.	O
strval	O
)	O
;	O
}	O
break	O
;	O
case	O
78	int
:	O
{	O
(	O
yyval	O
.	O
str	*(char)
)	O
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
80	int
:	O
{	O
(	O
yyval	O
.	O
intval	O
)	O
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
num	long
)	O
.	O
strval	O
)	O
;	O
}	O
break	O
;	O
case	O
82	int
:	O
{	O
current_rule	O
->	O
fall_through	O
=	O
1	int
;	O
}	O
break	O
;	O
case	O
83	int
:	O
{	O
current_rule	O
->	O
error	O
=	O
new_error	O
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
intval	O
)	O
,	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
0	int
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
84	int
:	O
{	O
int	O
n	long
=	O
string_to_error_index	O
(	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
;	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
{	O
cferror	O
(	O
&	O
(	O
yylsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
,	O
_	O
(	O
"Unknown message reference"	*(char)
)	O
)	O
;	O
YYERROR	O
;	O
}	O
else	O
current_rule	O
->	O
error	O
=	O
new_standard_error	O
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
intval	O
)	O
,	O
n	long
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
85	int
:	O
{	O
(	O
yyval	O
.	O
intval	O
)	O
=	O
2	int
;	O
}	O
break	O
;	O
case	O
86	int
:	O
{	O
(	O
yyval	O
.	O
intval	O
)	O
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
num	long
)	O
.	O
strval	O
)	O
;	O
}	O
break	O
;	O
case	O
87	int
:	O
{	O
if	O
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
range	O
)	O
.	O
start	*(long)
==	O
0	int
||	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
range	O
)	O
.	O
end	*(long)
==	O
0	int
)	O
{	O
cferror	O
(	O
&	O
(	O
yylsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
)	O
,	O
_	O
(	O
"$0 cannot be deleted"	*(char)
)	O
)	O
;	O
errors	O
++	O
;	O
}	O
else	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
=	O
new_transform_node	O
(	O
current_rule	O
,	O
transform_delete	int
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_arg	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
ins	int
=	O
0	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
idx	int
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
range	O
)	O
.	O
start	*(long)
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
arg_end	int
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
range	O
)	O
.	O
end	*(long)
;	O
}	O
}	O
break	O
;	O
case	O
88	int
:	O
{	O
(	O
yyval	O
.	O
range	O
)	O
.	O
start	*(long)
=	O
(	O
yyval	O
.	O
range	O
)	O
.	O
end	*(long)
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
num	long
)	O
.	O
strval	O
)	O
;	O
}	O
break	O
;	O
case	O
89	int
:	O
{	O
(	O
yyval	O
.	O
range	O
)	O
.	O
start	*(long)
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
(	O
yyval	O
.	O
range	O
)	O
.	O
end	*(long)
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
num	long
)	O
.	O
intval	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
num	long
)	O
.	O
strval	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
num	long
)	O
.	O
strval	O
)	O
;	O
}	O
break	O
;	O
case	O
90	int
:	O
{	O
if	O
(	O
cflex_include	O
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
&	O
(	O
yylsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
)	O
)	O
YYERROR	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
91	int
:	O
{	O
current_rule	O
->	O
limits	O
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
lrec	O
)	O
;	O
}	O
break	O
;	O
case	O
92	int
:	O
{	O
char	O
*	O
p	*(void)
;	O
(	O
yyval	O
.	O
lrec	O
)	O
=	O
limits_record_create	O
(	O
)	O
;	O
switch	O
(	O
limits_record_add	O
(	O
(	O
yyval	O
.	O
lrec	O
)	O
,	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
&	O
p	*(void)
)	O
)	O
{	O
case	O
lrec_ok	O
:	O
break	O
;	O
case	O
lrec_error	O
:	O
cferror	O
(	O
&	O
(	O
yylsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
)	O
,	O
_	O
(	O
"unrecognized resource limit: %s"	*(char)
)	O
,	O
p	*(void)
)	O
;	O
break	O
;	O
case	O
lrec_badval	O
:	O
cferror	O
(	O
&	O
(	O
yylsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
)	O
,	O
_	O
(	O
"bad value: %s"	*(char)
)	O
,	O
p	*(void)
)	O
;	O
break	O
;	O
}	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
93	int
:	O
{	O
char	O
*	O
p	*(void)
;	O
switch	O
(	O
limits_record_add	O
(	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
lrec	O
)	O
,	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
&	O
p	*(void)
)	O
)	O
{	O
case	O
lrec_ok	O
:	O
break	O
;	O
case	O
lrec_error	O
:	O
cferror	O
(	O
&	O
(	O
yylsp	O
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
)	O
,	O
_	O
(	O
"unrecognized resource limit: %s"	*(char)
)	O
,	O
p	*(void)
)	O
;	O
break	O
;	O
case	O
lrec_badval	O
:	O
cferror	O
(	O
&	O
(	O
yylsp	O
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
)	O
,	O
_	O
(	O
"bad value: %s"	*(char)
)	O
,	O
p	*(void)
)	O
;	O
break	O
;	O
}	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
;	O
(	O
yyval	O
.	O
lrec	O
)	O
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
lrec	O
)	O
;	O
}	O
break	O
;	O
case	O
94	int
:	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
;	O
size_t	long
n	long
;	O
n	long
=	O
strspn	(*(char),*(char))->(long)
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
+	O
1	int
,	O
":"	*(char)
)	O
;	O
if	O
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
[	O
n	long
+	O
1	int
]	O
)	O
{	O
struct	O
cfloc	O
loc	O
;	O
loc	O
.	O
beg	O
=	O
(	O
yylsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
beg	O
;	O
loc	O
.	O
beg	O
.	O
column	O
+=	O
n	long
+	O
1	int
;	O
loc	O
.	O
end	*(long)
=	O
loc	O
.	O
beg	O
;	O
cferror	O
(	O
&	O
loc	O
,	O
_	O
(	O
"invalid character in short option designator"	*(char)
)	O
)	O
;	O
cferror	O
(	O
&	O
loc	O
,	O
_	O
(	O
"short option letter can be followed only by zero to two colons"	*(char)
)	O
)	O
;	O
errors	O
++	O
;	O
}	O
else	O
{	O
if	O
(	O
n	long
>	O
2	int
)	O
{	O
struct	O
cfloc	O
loc	O
;	O
loc	O
.	O
beg	O
=	O
(	O
yylsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
beg	O
;	O
loc	O
.	O
beg	O
.	O
column	O
+=	O
n	long
;	O
loc	O
.	O
end	*(long)
=	O
loc	O
.	O
beg	O
;	O
cferror	O
(	O
&	O
loc	O
,	O
_	O
(	O
"ignoring extra character in short option designator"	*(char)
)	O
)	O
;	O
cferror	O
(	O
&	O
loc	O
,	O
_	O
(	O
"short option letter can be followed only by zero to two colons"	*(char)
)	O
)	O
;	O
}	O
node	O
=	O
new_transform_node	O
(	O
current_rule	O
,	O
transform_remopt	int
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_command	int
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
remopt	struct(*(char),*(char))
.	O
s_opt	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
remopt	struct(*(char),*(char))
.	O
l_opt	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
}	O
}	O
break	O
;	O
case	O
95	int
:	O
{	O
(	O
yyval	O
.	O
str	*(char)
)	O
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
97	int
:	O
{	O
current_rule	O
->	O
clrenv	O
=	O
1	int
;	O
}	O
break	O
;	O
case	O
98	int
:	O
{	O
new_envar	O
(	O
current_rule	O
,	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
strlen	(*(char))->(long)
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
,	O
(	O
yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
strlen	(*(char))->(long)
(	O
(	O
yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
,	O
envar_set	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
99	int
:	O
{	O
new_envar	O
(	O
current_rule	O
,	O
""	*(char)
,	O
0	int
,	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
strlen	(*(char))->(long)
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
,	O
envar_eval	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
100	int
:	O
{	O
add_asgn_list	O
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
asgn_list	O
)	O
.	O
head	O
,	O
envar_unset	O
)	O
;	O
}	O
break	O
;	O
case	O
101	int
:	O
{	O
add_asgn_list	O
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
asgn_list	O
)	O
.	O
head	O
,	O
envar_keep	O
)	O
;	O
}	O
break	O
;	O
case	O
102	int
:	O
{	O
(	O
yyval	O
.	O
asgn_list	O
)	O
.	O
head	O
=	O
(	O
yyval	O
.	O
asgn_list	O
)	O
.	O
tail	O
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
asgn	O
)	O
;	O
}	O
break	O
;	O
case	O
103	int
:	O
{	O
LIST_APPEND	O
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
asgn	O
)	O
,	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
asgn_list	O
)	O
.	O
head	O
,	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
asgn_list	O
)	O
.	O
tail	O
)	O
;	O
(	O
yyval	O
.	O
asgn_list	O
)	O
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
asgn_list	O
)	O
;	O
}	O
break	O
;	O
case	O
104	int
:	O
{	O
(	O
yyval	O
.	O
asgn	O
)	O
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
(	O
yyval	O
.	O
asgn	O
)	O
)	O
)	O
;	O
(	O
yyval	O
.	O
asgn	O
)	O
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
=	O
NULL	O
;	O
(	O
yyval	O
.	O
asgn	O
)	O
->	O
name	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
(	O
yyval	O
.	O
asgn	O
)	O
->	O
value	O
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
105	int
:	O
{	O
(	O
yyval	O
.	O
asgn	O
)	O
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
(	O
yyval	O
.	O
asgn	O
)	O
)	O
)	O
;	O
(	O
yyval	O
.	O
asgn	O
)	O
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
=	O
NULL	O
;	O
(	O
yyval	O
.	O
asgn	O
)	O
->	O
name	*(char)
=	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
(	O
yyval	O
.	O
asgn	O
)	O
->	O
value	O
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
str	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
106	int
:	O
{	O
(	O
yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
attrib	O
)	O
(	O
current_rule	O
,	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
str	*(char)
)	O
,	O
&	O
(	O
yylsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
str	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
107	int
:	O
{	O
cflex_pushargs	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
108	int
:	O
{	O
int	O
i	O
;	O
struct	O
argval	O
*	O
arg	struct(int,int)
;	O
cflex_popargs	O
(	O
)	O
;	O
(	O
yyval	O
.	O
strlist	O
)	O
.	O
argc	int
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
arglist	O
)	O
.	O
argc	int
;	O
(	O
yyval	O
.	O
strlist	O
)	O
.	O
argv	*(*(char))
=	O
xcalloc	(long,long)->(*(void))
(	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
arglist	O
)	O
.	O
argc	int
+	O
1	int
,	O
sizeof	O
(	O
(	O
yyval	O
.	O
strlist	O
)	O
.	O
argv	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
,	O
arg	struct(int,int)
=	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
arglist	O
)	O
.	O
head	O
;	O
i	O
<	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
arglist	O
)	O
.	O
argc	int
;	O
i	O
++	O
,	O
arg	struct(int,int)
=	O
arg	struct(int,int)
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
)	O
{	O
(	O
yyval	O
.	O
strlist	O
)	O
.	O
argv	*(*(char))
[	O
i	O
]	O
=	O
arg	struct(int,int)
->	O
strval	O
;	O
arg	struct(int,int)
->	O
strval	O
=	O
NULL	O
;	O
}	O
arglist_free	O
(	O
(	O
yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
arglist	O
)	O
.	O
head	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
YY_SYMBOL_PRINT	O
(	O
"-> $$ ="	*(char)
,	O
yyr1	O
[	O
yyn	O
]	O
,	O
&	O
yyval	O
,	O
&	O
yyloc	O
)	O
;	O
YYPOPSTACK	O
(	O
yylen	O
)	O
;	O
yylen	O
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	O
,	O
yyssp	O
)	O
;	O
*	O
++	O
yyvsp	O
=	O
yyval	O
;	O
*	O
++	O
yylsp	O
=	O
yyloc	O
;	O
yyn	O
=	O
yyr1	O
[	O
yyn	O
]	O
;	O
yystate	O
=	O
yypgoto	O
[	O
yyn	O
-	O
YYNTOKENS	O
]	O
+	O
*	O
yyssp	O
;	O
if	O
(	O
0	int
<=	O
yystate	O
&&	O
yystate	O
<=	O
YYLAST	O
&&	O
yycheck	O
[	O
yystate	O
]	O
==	O
*	O
yyssp	O
)	O
yystate	O
=	O
yytable	O
[	O
yystate	O
]	O
;	O
else	O
yystate	O
=	O
yydefgoto	O
[	O
yyn	O
-	O
YYNTOKENS	O
]	O
;	O
goto	O
yynewstate	O
;	O
yyerrlab	O
:	O
yytoken	O
=	O
yychar	O
==	O
YYEMPTY	O
?	O
YYEMPTY	O
:	O
YYTRANSLATE	O
(	O
yychar	O
)	O
;	O
if	O
(	O
!	O
yyerrstatus	O
)	O
{	O
++	O
yynerrs	O
;	O
{	O
char	O
const	O
*	O
yymsgp	O
=	O
YY_	O
(	O
"syntax error"	*(char)
)	O
;	O
int	O
yysyntax_error_status	O
;	O
yysyntax_error_status	O
=	O
YYSYNTAX_ERROR	O
;	O
if	O
(	O
yysyntax_error_status	O
==	O
0	int
)	O
yymsgp	O
=	O
yymsg	O
;	O
else	O
if	O
(	O
yysyntax_error_status	O
==	O
1	int
)	O
{	O
if	O
(	O
yymsg	O
!=	O
yymsgbuf	O
)	O
YYSTACK_FREE	O
(	O
yymsg	O
)	O
;	O
yymsg	O
=	O
(	O
char	O
*	O
)	O
YYSTACK_ALLOC	O
(	O
yymsg_alloc	O
)	O
;	O
if	O
(	O
!	O
yymsg	O
)	O
{	O
yymsg	O
=	O
yymsgbuf	O
;	O
yymsg_alloc	O
=	O
sizeof	O
yymsgbuf	O
;	O
yysyntax_error_status	O
=	O
2	int
;	O
}	O
else	O
{	O
yysyntax_error_status	O
=	O
YYSYNTAX_ERROR	O
;	O
yymsgp	O
=	O
yymsg	O
;	O
}	O
}	O
yyerror	O
(	O
yymsgp	O
)	O
;	O
if	O
(	O
yysyntax_error_status	O
==	O
2	int
)	O
goto	O
yyexhaustedlab	O
;	O
}	O
}	O
yyerror_range	O
[	O
1	int
]	O
=	O
yylloc	O
;	O
if	O
(	O
yyerrstatus	O
==	O
3	int
)	O
{	O
if	O
(	O
yychar	O
<=	O
YYEOF	O
)	O
{	O
if	O
(	O
yychar	O
==	O
YYEOF	O
)	O
YYABORT	O
;	O
}	O
else	O
{	O
yydestruct	O
(	O
"Error: discarding"	*(char)
,	O
yytoken	O
,	O
&	O
yylval	O
,	O
&	O
yylloc	O
)	O
;	O
yychar	O
=	O
YYEMPTY	O
;	O
}	O
}	O
goto	O
yyerrlab1	O
;	O
yyerrorlab	O
:	O
if	O
(	O
0	int
)	O
goto	O
yyerrorlab	O
;	O
yyerror_range	O
[	O
1	int
]	O
=	O
yylsp	O
[	O
1	int
-	O
yylen	O
]	O
;	O
YYPOPSTACK	O
(	O
yylen	O
)	O
;	O
yylen	O
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	O
,	O
yyssp	O
)	O
;	O
yystate	O
=	O
*	O
yyssp	O
;	O
goto	O
yyerrlab1	O
;	O
yyerrlab1	O
:	O
yyerrstatus	O
=	O
3	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
yyn	O
=	O
yypact	O
[	O
yystate	O
]	O
;	O
if	O
(	O
!	O
yypact_value_is_default	O
(	O
yyn	O
)	O
)	O
{	O
yyn	O
+=	O
YYTERROR	O
;	O
if	O
(	O
0	int
<=	O
yyn	O
&&	O
yyn	O
<=	O
YYLAST	O
&&	O
yycheck	O
[	O
yyn	O
]	O
==	O
YYTERROR	O
)	O
{	O
yyn	O
=	O
yytable	O
[	O
yyn	O
]	O
;	O
if	O
(	O
0	int
<	O
yyn	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
yyssp	O
==	O
yyss	O
)	O
YYABORT	O
;	O
yyerror_range	O
[	O
1	int
]	O
=	O
*	O
yylsp	O
;	O
yydestruct	O
(	O
"Error: popping"	*(char)
,	O
yystos	O
[	O
yystate	O
]	O
,	O
yyvsp	O
,	O
yylsp	O
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
yystate	O
=	O
*	O
yyssp	O
;	O
YY_STACK_PRINT	O
(	O
yyss	O
,	O
yyssp	O
)	O
;	O
}	O
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	O
*	O
++	O
yyvsp	O
=	O
yylval	O
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_END	O
yyerror_range	O
[	O
2	int
]	O
=	O
yylloc	O
;	O
YYLLOC_DEFAULT	O
(	O
yyloc	O
,	O
yyerror_range	O
,	O
2	int
)	O
;	O
*	O
++	O
yylsp	O
=	O
yyloc	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	*(char)
,	O
yystos	O
[	O
yyn	O
]	O
,	O
yyvsp	O
,	O
yylsp	O
)	O
;	O
yystate	O
=	O
yyn	O
;	O
goto	O
yynewstate	O
;	O
yyacceptlab	O
:	O
yyresult	O
=	O
0	int
;	O
goto	O
yyreturn	O
;	O
yyabortlab	O
:	O
yyresult	O
=	O
1	int
;	O
goto	O
yyreturn	O
;	O
yyexhaustedlab	O
:	O
yyerror	O
(	O
YY_	O
(	O
"memory exhausted"	*(char)
)	O
)	O
;	O
yyresult	O
=	O
2	int
;	O
yyreturn	O
:	O
if	O
(	O
yychar	O
!=	O
YYEMPTY	O
)	O
{	O
yytoken	O
=	O
YYTRANSLATE	O
(	O
yychar	O
)	O
;	O
yydestruct	O
(	O
"Cleanup: discarding lookahead"	*(char)
,	O
yytoken	O
,	O
&	O
yylval	O
,	O
&	O
yylloc	O
)	O
;	O
}	O
YYPOPSTACK	O
(	O
yylen	O
)	O
;	O
YY_STACK_PRINT	O
(	O
yyss	O
,	O
yyssp	O
)	O
;	O
while	O
(	O
yyssp	O
!=	O
yyss	O
)	O
{	O
yydestruct	O
(	O
"Cleanup: popping"	*(char)
,	O
yystos	O
[	O
*	O
yyssp	O
]	O
,	O
yyvsp	O
,	O
yylsp	O
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
yyss	O
!=	O
yyssa	O
)	O
YYSTACK_FREE	O
(	O
yyss	O
)	O
;	O
if	O
(	O
yymsg	O
!=	O
yymsgbuf	O
)	O
YYSTACK_FREE	O
(	O
yymsg	O
)	O
;	O
return	O
YYID	O
(	O
yyresult	O
)	O
;	O
}	O
void	O
yyerror	O
(	O
char	O
const	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	O
;	O
va_start	O
(	O
ap	O
,	O
fmt	*(char)
)	O
;	O
vcferror	O
(	O
&	O
curloc	O
,	O
fmt	*(char)
,	O
ap	O
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
errors	O
=	O
1	int
;	O
}	O
void	O
cfgram_debug	O
(	O
int	O
v	union(*(char),struct(int,int))
)	O
{	O
yydebug	O
=	O
v	union(*(char),struct(int,int))
;	O
}	O
struct	O
rush_rule	O
*	O
new_rush_rule	O
(	O
char	O
const	O
*	O
tag	O
)	O
{	O
struct	O
rush_rule	O
*	O
p	*(void)
=	O
xzalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
p	*(void)
)	O
)	O
;	O
LIST_APPEND	O
(	O
p	*(void)
,	O
rule_head	O
,	O
rule_tail	O
)	O
;	O
static	O
unsigned	O
rule_num	O
=	O
0	int
;	O
rule_num	O
++	O
;	O
if	O
(	O
tag	O
&&	O
tag	O
[	O
0	int
]	O
)	O
p	*(void)
->	O
tag	O
=	O
xstrdup	(*(char))->(*(char))
(	O
tag	O
)	O
;	O
else	O
{	O
char	O
buf	O
[	O
INT_BUFSIZE_BOUND	O
(	O
unsigned	O
)	O
]	O
;	O
char	O
*	O
s	long
=	O
uinttostr	(int,*(char))->(*(char))
(	O
rule_num	O
,	O
buf	O
)	O
;	O
p	*(void)
->	O
tag	O
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
s	long
)	O
+	O
2	int
)	O
;	O
p	*(void)
->	O
tag	O
[	O
0	int
]	O
=	O
'#'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
->	O
tag	O
+	O
1	int
,	O
s	long
)	O
;	O
}	O
p	*(void)
->	O
mask	O
=	O
NO_UMASK	O
;	O
p	*(void)
->	O
gid	int
=	O
NO_GID	O
;	O
p	*(void)
->	O
fork	()->(int)
=	O
rush_undefined	O
;	O
p	*(void)
->	O
acct	(*(char))->(int)
=	O
rush_undefined	O
;	O
return	O
p	*(void)
;	O
}	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
new_transform_node	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
enum	O
transform_node_type	enum(int,int,int,int)
type	enum(int,int,int,int)
)	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
p	*(void)
=	O
xzalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
p	*(void)
)	O
)	O
;	O
LIST_APPEND	O
(	O
p	*(void)
,	O
rule	*(char)
->	O
transform_head	O
,	O
rule	*(char)
->	O
transform_tail	O
)	O
;	O
p	*(void)
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
return	O
p	*(void)
;	O
}	O
struct	O
test_node	O
*	O
new_test_node	O
(	O
enum	O
test_type	enum(int,int,int,int,int,int,int)
type	enum(int,int,int,int)
)	O
{	O
struct	O
test_node	O
*	O
p	*(void)
=	O
xzalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
p	*(void)
)	O
)	O
;	O
p	*(void)
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
return	O
p	*(void)
;	O
}	O
struct	O
envar	O
*	O
new_envar	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
char	O
const	O
*	O
name	*(char)
,	O
size_t	long
nlen	O
,	O
char	O
const	O
*	O
value	O
,	O
size_t	long
vlen	O
,	O
enum	O
envar_type	O
type	enum(int,int,int,int)
)	O
{	O
struct	O
envar	O
*	O
p	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
p	*(void)
)	O
+	O
nlen	O
+	O
1	int
+	O
(	O
value	O
?	O
vlen	O
+	O
1	int
:	O
0	int
)	O
)	O
;	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
=	O
NULL	O
;	O
p	*(void)
->	O
name	*(char)
=	O
(	O
char	O
*	O
)	O
(	O
p	*(void)
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
->	O
name	*(char)
,	O
name	*(char)
,	O
nlen	O
)	O
;	O
p	*(void)
->	O
name	*(char)
[	O
nlen	O
]	O
=	O
0	int
;	O
if	O
(	O
value	O
)	O
{	O
p	*(void)
->	O
value	O
=	O
p	*(void)
->	O
name	*(char)
+	O
nlen	O
+	O
1	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
->	O
value	O
,	O
value	O
,	O
vlen	O
)	O
;	O
p	*(void)
->	O
value	O
[	O
vlen	O
]	O
=	O
0	int
;	O
}	O
else	O
{	O
p	*(void)
->	O
value	O
=	O
NULL	O
;	O
}	O
p	*(void)
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
LIST_APPEND	O
(	O
p	*(void)
,	O
rule	*(char)
->	O
envar_head	O
,	O
rule	*(char)
->	O
envar_tail	O
)	O
;	O
return	O
p	*(void)
;	O
}	O
static	O
void	O
add_asgn_list	O
(	O
struct	O
asgn	O
*	O
head	O
,	O
enum	O
envar_type	O
type	enum(int,int,int,int)
)	O
{	O
for	O
(	O
;	O
head	O
;	O
head	O
=	O
head	O
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
)	O
{	O
new_envar	O
(	O
current_rule	O
,	O
head	O
->	O
name	*(char)
,	O
strlen	(*(char))->(long)
(	O
head	O
->	O
name	*(char)
)	O
,	O
head	O
->	O
value	O
,	O
head	O
->	O
value	O
?	O
strlen	(*(char))->(long)
(	O
head	O
->	O
value	O
)	O
:	O
0	int
,	O
type	enum(int,int,int,int)
)	O
;	O
free	(*(void))->(void)
(	O
head	O
->	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
head	O
->	O
value	O
)	O
;	O
}	O
}	O
static	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
new_set_node	O
(	O
enum	O
transform_node_type	enum(int,int,int,int)
type	enum(int,int,int,int)
,	O
char	O
*	O
varname	O
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
;	O
enum	O
transform_target_type	enum(int,int,int,int,int,int)
tgt	O
;	O
tgt	O
=	O
rush_variable_target	O
(	O
varname	O
)	O
;	O
if	O
(	O
tgt	O
==	O
target_readonly	int
)	O
{	O
cferror	O
(	O
loc	O
,	O
_	O
(	O
"attempt to modify a read-only variable"	*(char)
)	O
)	O
;	O
errors	O
++	O
;	O
return	O
NULL	O
;	O
}	O
node	O
=	O
new_transform_node	O
(	O
current_rule	O
,	O
type	enum(int,int,int,int)
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
tgt	O
;	O
switch	O
(	O
tgt	O
)	O
{	O
case	O
target_command	int
:	O
case	O
target_program	int
:	O
free	(*(void))->(void)
(	O
varname	O
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
transform_delete	int
)	O
{	O
cferror	O
(	O
loc	O
,	O
_	O
(	O
"attempt to unset a read-only variable"	*(char)
)	O
)	O
;	O
errors	O
++	O
;	O
return	O
NULL	O
;	O
}	O
break	O
;	O
case	O
target_var	int
:	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
name	*(char)
=	O
varname	O
;	O
break	O
;	O
default	O
:	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: invalid target type %d"	*(char)
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
tgt	O
)	O
;	O
}	O
return	O
node	O
;	O
}	O
