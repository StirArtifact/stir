static	O
const	O
char	O
copyright	array(char)
[	O
]	O
=	O
"@(#) Copyright (c) 1980, 1993\n"	*(char)
"The Regents of the University of California.  All rights reserved.\n"	*(char)
"@(#) Copyright (c) 1998\n"	*(char)
"Free Software Foundation, Inc.  All rights reserved.\n"	*(char)
;	O
static	O
const	O
char	O
filever	array(char)
[	O
]	O
=	O
"$Id: sccs.c,v 1.44 2007/12/19 00:21:14 jay Exp $"	*(char)
;	O
typedef	O
char	O
bool	char
;	O
struct	O
sccsprog	struct(*(char),short,short,*(char),int)
{	O
const	O
char	O
*	O
sccsname	*(char)
;	O
short	O
sccsoper	short
;	O
short	O
sccsflags	short
;	O
const	O
char	O
*	O
sccspath	*(char)
;	O
int	O
clean_mode	int
;	O
}	O
;	O
const	O
struct	O
sccsprog	struct(*(char),short,short,*(char),int)
SccsProg	array(struct(*(char),short,short,*(char),int))
[	O
]	O
=	O
{	O
{	O
"admin"	*(char)
,	O
PROG	int
,	O
REALUSER	int
,	O
_PATH_SCCSADMIN	O
,	O
0	int
}	O
,	O
{	O
"cdc"	*(char)
,	O
PROG	int
,	O
0	int
,	O
_PATH_SCCSCDC	O
,	O
0	int
}	O
,	O
{	O
"comb"	*(char)
,	O
PROG	int
,	O
WARN_MISSING	int
,	O
_PATH_SCCSCOMB	O
,	O
0	int
}	O
,	O
{	O
"delta"	*(char)
,	O
PROG	int
,	O
0	int
,	O
_PATH_SCCSDELTA	O
,	O
0	int
}	O
,	O
{	O
"get"	*(char)
,	O
PROG	int
,	O
0	int
,	O
_PATH_SCCSGET	O
,	O
0	int
}	O
,	O
{	O
"unget"	*(char)
,	O
PROG	int
,	O
0	int
,	O
_PATH_SCCSUNGET	O
,	O
0	int
}	O
,	O
{	O
"help"	*(char)
,	O
PROG	int
,	O
NO_HELP_HERE	int
|	O
NO_SDOT	int
,	O
_PATH_SCCSHELP	O
,	O
0	int
}	O
,	O
{	O
"prs"	*(char)
,	O
PROG	int
,	O
0	int
,	O
_PATH_SCCSPRS	O
,	O
0	int
}	O
,	O
{	O
"prt"	*(char)
,	O
PROG	int
,	O
0	int
,	O
_PATH_SCCSPRT	O
,	O
0	int
}	O
,	O
{	O
"rmdel"	*(char)
,	O
PROG	int
,	O
REALUSER	int
,	O
_PATH_SCCSRMDEL	O
,	O
0	int
}	O
,	O
{	O
"val"	*(char)
,	O
PROG	int
,	O
0	int
,	O
_PATH_SCCSVAL	O
,	O
0	int
}	O
,	O
{	O
"what"	*(char)
,	O
PROG	int
,	O
NO_SDOT	int
,	O
_PATH_SCCSWHAT	O
,	O
0	int
}	O
,	O
{	O
"sccsdiff"	*(char)
,	O
PROG	int
,	O
REALUSER	int
,	O
_PATH_SCCSDIFF	O
,	O
0	int
}	O
,	O
{	O
"edit"	*(char)
,	O
CMACRO	int
,	O
NO_SDOT	int
,	O
"get -e"	*(char)
,	O
0	int
}	O
,	O
{	O
"delget"	*(char)
,	O
CMACRO	int
,	O
NO_SDOT	int
,	O
"delta:mysrp/get:ixbeskcl -t"	*(char)
,	O
0	int
}	O
,	O
{	O
"deledit"	*(char)
,	O
CMACRO	int
,	O
NO_SDOT	int
,	O
"delta:mysrp -n/get:ixbskcl -e -t -g"	*(char)
,	O
0	int
}	O
,	O
{	O
"fix"	*(char)
,	O
FIX	int
,	O
NO_SDOT	int
,	O
NULL	O
,	O
0	int
}	O
,	O
{	O
"clean"	*(char)
,	O
CLEAN	int
,	O
REALUSER	int
|	O
NO_SDOT	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
CLEANC	int
}	O
,	O
{	O
"info"	*(char)
,	O
CLEAN	int
,	O
REALUSER	int
|	O
NO_SDOT	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
INFOC	int
}	O
,	O
{	O
"check"	*(char)
,	O
CLEAN	int
,	O
REALUSER	int
|	O
NO_SDOT	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
CHECKC	int
}	O
,	O
{	O
"tell"	*(char)
,	O
CLEAN	int
,	O
REALUSER	int
|	O
NO_SDOT	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
TELLC	int
}	O
,	O
{	O
"unedit"	*(char)
,	O
UNEDIT	int
,	O
NO_SDOT	int
,	O
NULL	O
,	O
0	int
}	O
,	O
{	O
"diffs"	*(char)
,	O
DIFFS	int
,	O
NO_SDOT	int
|	O
REALUSER	int
,	O
NULL	O
,	O
0	int
}	O
,	O
{	O
"-diff"	*(char)
,	O
DODIFF	int
,	O
NO_SDOT	int
|	O
REALUSER	int
,	O
_PATH_SCCSBDIFF	O
,	O
0	int
}	O
,	O
{	O
"print"	*(char)
,	O
CMACRO	int
,	O
NO_SDOT	int
,	O
"prs -e/get -p -m -s"	*(char)
,	O
0	int
}	O
,	O
{	O
"branch"	*(char)
,	O
CMACRO	int
,	O
NO_SDOT	int
,	O
"get:ixrc -e -b/delta: -s -n -ybranch-place-holder/get:pl -e -t -g"	*(char)
,	O
0	int
}	O
,	O
{	O
"enter"	*(char)
,	O
ENTER	int
,	O
NO_SDOT	int
,	O
NULL	O
,	O
0	int
}	O
,	O
{	O
"create"	*(char)
,	O
CMACRO	int
,	O
NO_SDOT	int
,	O
"enter/get:ixeskcl -t"	*(char)
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
-	O
1	int
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
,	O
}	O
;	O
struct	O
pfile	struct(*(char),*(char),*(char),*(char),*(char),*(char))
{	O
char	O
*	O
p_osid	*(char)
;	O
char	O
*	O
p_nsid	*(char)
;	O
char	O
*	O
p_user	*(char)
;	O
char	O
*	O
p_date	*(char)
;	O
char	O
*	O
p_time	*(char)
;	O
char	O
*	O
p_aux	*(char)
;	O
}	O
;	O
const	O
char	O
*	O
SccsPath	*(char)
=	O
SCCSPATH	*(char)
;	O
const	O
char	O
*	O
SccsDir	*(char)
=	O
""	*(char)
;	O
char	O
*	O
subprogram_exec_prefix	*(char)
=	O
NULL	O
;	O
int	O
OutFile	int
=	O
-	O
1	int
;	O
bool	char
RealUser	char
;	O
bool	char
Debug	char
=	O
0	int
;	O
static	O
bool	char
TrustEnvironment	char
=	O
0	int
;	O
void	O
syserr	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
;	O
void	O
usrerr	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
;	O
int	O
command	(array(*(char)),char,*(char))->(int)
(	O
char	O
*	O
argv	array(*(char))
[	O
]	O
,	O
bool	char
forkflag	char
,	O
const	O
char	O
*	O
arg0	*(char)
)	O
;	O
int	O
callprog	(*(char),short,array(*(char)),char)->(int)
(	O
const	O
char	O
*	O
progpath	*(char)
,	O
short	O
flags	short
,	O
char	O
*	O
const	O
argv	array(*(char))
[	O
]	O
,	O
bool	char
forkflag	char
)	O
;	O
int	O
clean	(int,array(*(char)))->(int)
(	O
int	O
mode	int
,	O
char	O
*	O
const	O
argv	array(*(char))
[	O
]	O
)	O
;	O
int	O
dodiff	(array(*(char)),*(char))->(int)
(	O
char	O
*	O
getv	array(*(char))
[	O
]	O
,	O
const	O
char	O
*	O
gfile	*(char)
)	O
;	O
int	O
isbranch	(*(char))->(int)
(	O
const	O
char	O
*	O
sid	*(char)
)	O
;	O
void	O
putpfent	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
register	O
const	O
struct	O
pfile	struct(*(char),*(char),*(char),*(char),*(char),*(char))
*	O
pf	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
,	O
register	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
bool	char
safepath	(*(char))->(char)
(	O
register	O
const	O
char	O
*	O
p	*(char)
)	O
;	O
bool	char
isdir	(*(char))->(char)
(	O
const	O
char	O
*	O
name	*(char)
)	O
;	O
const	O
struct	O
sccsprog	struct(*(char),short,short,*(char),int)
*	O
lookup	(*(char))->(*(struct(*(char),short,short,*(char),int)))
(	O
const	O
char	O
*	O
name	*(char)
)	O
;	O
bool	char
unedit	(*(char))->(char)
(	O
const	O
char	O
*	O
fn	*(char)
)	O
;	O
char	O
*	O
makefile	(*(char))->(*(char))
(	O
const	O
char	O
*	O
name	*(char)
)	O
;	O
const	O
char	O
*	O
tail	(*(char))->(*(char))
(	O
register	O
const	O
char	O
*	O
fn	*(char)
)	O
;	O
char	O
*	O
tail_nc	(*(char))->(*(char))
(	O
register	O
char	O
*	O
fn	*(char)
)	O
;	O
const	O
struct	O
pfile	struct(*(char),*(char),*(char),*(char),*(char),*(char))
*	O
getpfent	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(*(char),*(char),*(char),*(char),*(char),*(char))))
(	O
FILE	struct
*	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
const	O
char	O
*	O
username	()->(*(char))
(	O
void	O
)	O
;	O
char	O
*	O
nextfield	(*(char))->(*(char))
(	O
register	O
char	O
*	O
p	*(char)
)	O
;	O
char	O
*	O
my_rindex	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
int	O
ch	int
)	O
;	O
char	O
*	O
my_index	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
int	O
ch	int
)	O
;	O
static	O
char	O
*	O
gstrcat	(*(char),*(char),long)->(*(char))
(	O
char	O
*	O
to	*(char)
,	O
const	O
char	O
*	O
from	*(char)
,	O
size_t	long
length	long
)	O
;	O
static	O
char	O
*	O
gstrncat	(*(char),*(char),long,long)->(*(char))
(	O
char	O
*	O
to	*(char)
,	O
const	O
char	O
*	O
from	*(char)
,	O
size_t	long
n	long
,	O
size_t	long
length	long
)	O
;	O
static	O
char	O
*	O
gstrcpy	(*(char),*(char),long)->(*(char))
(	O
char	O
*	O
to	*(char)
,	O
const	O
char	O
*	O
from	*(char)
,	O
size_t	long
length	long
)	O
;	O
static	O
void	O
gstrbotch	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
str1	*(char)
,	O
const	O
char	O
*	O
str2	*(char)
)	O
;	O
static	O
void	O
gstrbotchn	(int,*(char),int,*(char),int)->(void)
(	O
int	O
avail	int
,	O
const	O
char	O
*	O
,	O
int	O
,	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
static	O
int	O
absolute_pathname	(*(char))->(int)
(	O
const	O
char	O
*	O
)	O
;	O
static	O
char	O
*	O
str_dup	(*(char))->(*(char))
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
childwait	(int,*(int),int)->(void)
(	O
int	O
pid	int
,	O
int	O
*	O
status_ptr	*(int)
,	O
int	O
ignoreintr	int
)	O
;	O
static	O
void	O
show_version	()->(void)
(	O
void	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s from GNU CSSC %s\n%s\n"	*(char)
,	O
program_name	*(char)
,	O
(	O
VERSION	*(char)
)	O
,	O
filever	array(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"SccsPath = '%s'\nSccsDir = '%s'\n"	*(char)
,	O
SccsPath	*(char)
,	O
SccsDir	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Default prefix for SCCS subcommands is '%s'\n"	*(char)
,	O
(	O
PREFIX	O
)	O
)	O
;	O
}	O
static	O
void	O
oom	()->(void)
(	O
void	O
)	O
{	O
perror	(*(char))->(void)
(	O
"malloc failed"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_TEMPFAIL	int
)	O
;	O
}	O
static	O
void	O
set_prefix	(*(char))->(void)
(	O
const	O
char	O
*	O
pfx	*(char)
)	O
{	O
if	O
(	O
TrustEnvironment	char
)	O
{	O
char	O
*	O
p	*(char)
=	O
malloc	(long)->(*(void))
(	O
1	int
+	O
strlen	(*(char))->(long)
(	O
pfx	*(char)
)	O
)	O
;	O
if	O
(	O
Debug	char
)	O
printf	(*(char))->(int)
(	O
"set_prefix: setting execution prefix to '%s'\n"	*(char)
,	O
pfx	*(char)
)	O
;	O
if	O
(	O
p	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
subprogram_exec_prefix	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(char)
,	O
pfx	*(char)
)	O
;	O
subprogram_exec_prefix	*(char)
=	O
p	*(char)
;	O
}	O
else	O
{	O
oom	()->(void)
(	O
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
"Option --prefix is incompatible with setuid "	*(char)
"execution.  Sorry.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
}	O
static	O
void	O
setuid_warn	()->(void)
(	O
void	O
)	O
{	O
const	O
char	O
*	O
str	*(char)
=	O
"If you want to install this program set-user-id or set-group-id, you\n"	*(char)
"must compile it with the SCCSDIR macro defined, in order to\n"	*(char)
"prevent abuse.  Even so, abuse is probably not impossible.  This\n"	*(char)
"is not a recommended mode of operation for this program.\n"	*(char)
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
str	*(char)
)	O
;	O
}	O
static	O
void	O
drop_privs	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
0	int
!=	O
setgroups	(long,*(int))->(int)
(	O
0	int
,	O
NULL	O
)	O
&&	O
errno	O
!=	O
EPERM	int
)	O
{	O
perror	(*(char))->(void)
(	O
"setgroups"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_NOPERM	int
)	O
;	O
}	O
if	O
(	O
0	int
!=	O
setgid	(int)->(int)
(	O
getgid	()->(int)
(	O
)	O
)	O
)	O
{	O
perror	(*(char))->(void)
(	O
"setgid"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_NOPERM	int
)	O
;	O
}	O
if	O
(	O
0	int
!=	O
setuid	(int)->(int)
(	O
getuid	()->(int)
(	O
)	O
)	O
)	O
{	O
perror	(*(char))->(void)
(	O
"setuid"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_NOPERM	int
)	O
;	O
}	O
RealUser	char
++	O
;	O
}	O
static	O
void	O
check_data_integrity	()->(void)
(	O
)	O
{	O
}	O
static	O
void	O
cleanup_environment	()->(void)
(	O
void	O
)	O
{	O
const	O
char	O
*	O
binary_support	*(char)
=	O
"CSSC_BINARY_SUPPORT"	*(char)
;	O
const	O
char	O
*	O
max_line_len	*(char)
=	O
"CSSC_MAX_LINE_LENGTH"	*(char)
;	O
unsetenv	(*(char))->(int)
(	O
binary_support	*(char)
)	O
;	O
unsetenv	(*(char))->(int)
(	O
max_line_len	*(char)
)	O
;	O
}	O
static	O
void	O
usage	()->(void)
(	O
void	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Usage: %s [flags] command [flags]\n"	*(char)
,	O
program_name	*(char)
)	O
;	O
}	O
char	O
*	O
my_rindex	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
p	*(char)
,	O
int	O
ch	int
)	O
{	O
return	O
strrchr	(*(char),int)->(*(char))
(	O
p	*(char)
,	O
ch	int
)	O
;	O
}	O
char	O
*	O
my_index	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
p	*(char)
,	O
int	O
ch	int
)	O
{	O
return	O
strchr	(*(char),int)->(*(char))
(	O
p	*(char)
,	O
ch	int
)	O
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	array(*(char))
)	O
{	O
register	O
char	O
*	O
p	*(char)
;	O
register	O
int	O
i	int
;	O
int	O
hadver	int
=	O
0	int
;	O
(	O
void	O
)	O
&	O
copyright	array(char)
;	O
set_program_name	(*(char))->(void)
(	O
argv	array(*(char))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
absolute_pathname	(*(char))->(int)
(	O
PREFIX	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Compiled-in program name prefix %s is not absolute.\n"	*(char)
"Please recompile this program using an absolute path.\n"	*(char)
,	O
PREFIX	O
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_CONFIG	int
)	O
;	O
}	O
if	O
(	O
(	O
getuid	()->(int)
(	O
)	O
!=	O
geteuid	()->(int)
(	O
)	O
)	O
||	O
(	O
getgid	()->(int)
(	O
)	O
!=	O
getegid	()->(int)
(	O
)	O
)	O
)	O
{	O
TrustEnvironment	char
=	O
0	int
;	O
setuid_warn	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_NOPERM	int
)	O
;	O
cleanup_environment	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
TrustEnvironment	char
=	O
1	int
;	O
}	O
if	O
(	O
TrustEnvironment	char
)	O
{	O
if	O
(	O
NULL	O
==	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
)	O
{	O
perror	(*(char))->(void)
(	O
"Error setting locale"	*(char)
)	O
;	O
}	O
}	O
check_data_integrity	()->(void)
(	O
)	O
;	O
p	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"PROJECTDIR"	*(char)
)	O
;	O
if	O
(	O
p	*(char)
!=	O
NULL	O
&&	O
p	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
register	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
extern	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
)	O
;	O
char	O
buf	array(char)
[	O
FBUFSIZ	O
]	O
;	O
if	O
(	O
p	*(char)
[	O
0	int
]	O
==	O
'/'	O
)	O
SccsDir	*(char)
=	O
p	*(char)
;	O
else	O
{	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
p	*(char)
)	O
;	O
if	O
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
==	O
NULL	O
)	O
{	O
usrerr	(*(char))->(void)
(	O
"user %s does not exist"	*(char)
,	O
p	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
gstrcpy	(*(char),*(char),long)->(*(char))
(	O
buf	array(char)
,	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_dir	*(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
)	O
;	O
gstrcat	(*(char),*(char),long)->(*(char))
(	O
buf	array(char)
,	O
"/src"	*(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
)	O
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
buf	array(char)
,	O
0	int
)	O
<	O
0	int
)	O
{	O
gstrcpy	(*(char),*(char),long)->(*(char))
(	O
buf	array(char)
,	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_dir	*(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
)	O
;	O
gstrcat	(*(char),*(char),long)->(*(char))
(	O
buf	array(char)
,	O
"/source"	*(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
)	O
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
buf	array(char)
,	O
0	int
)	O
<	O
0	int
)	O
{	O
usrerr	(*(char))->(void)
(	O
"project %s has no source!"	*(char)
,	O
p	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
}	O
SccsDir	*(char)
=	O
buf	array(char)
;	O
}	O
}	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
usage	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
argv	array(*(char))
[	O
argc	int
]	O
=	O
NULL	O
;	O
if	O
(	O
lookup	(*(char))->(*(struct(*(char),short,short,*(char),int)))
(	O
argv	array(*(char))
[	O
0	int
]	O
)	O
==	O
NULL	O
)	O
{	O
while	O
(	O
(	O
p	*(char)
=	O
*	O
++	O
argv	array(*(char))
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
*	O
p	*(char)
!=	O
'-'	O
)	O
break	O
;	O
switch	O
(	O
*	O
++	O
p	*(char)
)	O
{	O
case	O
'-'	O
:	O
++	O
p	*(char)
;	O
if	O
(	O
0	int
==	O
*	O
p	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
"End-of-arguments option \"--\" not "	*(char)
"supported, sorry.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
else	O
if	O
(	O
0	int
==	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(char)
,	O
"prefix="	*(char)
,	O
7	int
)	O
)	O
{	O
set_prefix	(*(char))->(void)
(	O
p	*(char)
+	O
7	int
)	O
;	O
}	O
else	O
if	O
(	O
0	int
==	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(char)
,	O
"cssc"	*(char)
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
"yes"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_OK	int
)	O
;	O
}	O
else	O
if	O
(	O
0	int
==	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(char)
,	O
"version"	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
hadver	int
)	O
show_version	()->(void)
(	O
)	O
;	O
hadver	int
=	O
1	int
;	O
if	O
(	O
2	int
==	O
argc	int
)	O
return	O
0	int
;	O
}	O
else	O
{	O
usrerr	(*(char))->(void)
(	O
"unknown option --%s"	*(char)
,	O
p	*(char)
)	O
;	O
usage	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
break	O
;	O
case	O
'V'	O
:	O
if	O
(	O
!	O
hadver	int
)	O
show_version	()->(void)
(	O
)	O
;	O
hadver	int
=	O
1	int
;	O
if	O
(	O
2	int
==	O
argc	int
)	O
return	O
0	int
;	O
break	O
;	O
case	O
'r'	O
:	O
drop_privs	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
SccsPath	*(char)
=	O
++	O
p	*(char)
;	O
if	O
(	O
SccsPath	*(char)
[	O
0	int
]	O
==	O
'\0'	O
&&	O
argv	array(*(char))
[	O
1	int
]	O
!=	O
NULL	O
)	O
SccsPath	*(char)
=	O
*	O
++	O
argv	array(*(char))
;	O
break	O
;	O
case	O
'd'	O
:	O
SccsDir	*(char)
=	O
++	O
p	*(char)
;	O
if	O
(	O
SccsDir	*(char)
[	O
0	int
]	O
==	O
'\0'	O
&&	O
argv	array(*(char))
[	O
1	int
]	O
!=	O
NULL	O
)	O
SccsDir	*(char)
=	O
*	O
++	O
argv	array(*(char))
;	O
break	O
;	O
case	O
'T'	O
:	O
Debug	char
++	O
;	O
break	O
;	O
default	O
:	O
usrerr	(*(char))->(void)
(	O
"unknown option -%s"	*(char)
,	O
p	*(char)
)	O
;	O
usage	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
}	O
if	O
(	O
SccsPath	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
SccsPath	*(char)
=	O
"."	*(char)
;	O
}	O
if	O
(	O
NULL	O
==	O
argv	array(*(char))
[	O
0	int
]	O
)	O
{	O
if	O
(	O
!	O
hadver	int
)	O
{	O
usage	()->(void)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
i	int
=	O
command	(array(*(char)),char,*(char))->(int)
(	O
argv	array(*(char))
,	O
FALSE	int
,	O
""	*(char)
)	O
;	O
return	O
i	int
;	O
}	O
}	O
char	O
*	O
*	O
do_enter	(array(*(char)),*(*(char)),*(*(char)),*(int))->(*(*(char)))
(	O
char	O
*	O
argv	array(*(char))
[	O
]	O
,	O
char	O
*	O
*	O
np	*(*(char))
,	O
char	O
*	O
*	O
ap	*(*(char))
,	O
int	O
*	O
rval	*(int)
)	O
{	O
char	O
buf2	array(char)
[	O
FBUFSIZ	O
]	O
;	O
char	O
*	O
argv_tmp	*(char)
;	O
for	O
(	O
np	*(*(char))
=	O
&	O
ap	*(*(char))
[	O
1	int
]	O
;	O
*	O
np	*(*(char))
!=	O
NULL	O
&&	O
*	O
*	O
np	*(*(char))
==	O
'-'	O
;	O
np	*(*(char))
++	O
)	O
continue	O
;	O
argv	array(*(char))
=	O
np	*(*(char))
;	O
argv_tmp	*(char)
=	O
argv	array(*(char))
[	O
1	int
]	O
;	O
while	O
(	O
np	*(*(char))
[	O
0	int
]	O
!=	O
NULL	O
)	O
{	O
printf	(*(char))->(int)
(	O
"\n%s:\n"	*(char)
,	O
*	O
np	*(*(char))
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf2	array(char)
,	O
"-i"	*(char)
)	O
;	O
gstrcat	(*(char),*(char),long)->(*(char))
(	O
buf2	array(char)
,	O
np	*(*(char))
[	O
0	int
]	O
,	O
sizeof	O
(	O
buf2	array(char)
)	O
)	O
;	O
ap	*(*(char))
[	O
0	int
]	O
=	O
buf2	array(char)
;	O
argv	array(*(char))
[	O
0	int
]	O
=	O
tail_nc	(*(char))->(*(char))
(	O
np	*(*(char))
[	O
0	int
]	O
)	O
;	O
argv	array(*(char))
[	O
1	int
]	O
=	O
NULL	O
;	O
*	O
rval	*(int)
=	O
command	(array(*(char)),char,*(char))->(int)
(	O
ap	*(*(char))
,	O
TRUE	int
,	O
"admin"	*(char)
)	O
;	O
argv	array(*(char))
[	O
1	int
]	O
=	O
argv_tmp	*(char)
;	O
if	O
(	O
*	O
rval	*(int)
==	O
0	int
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf2	array(char)
,	O
","	*(char)
)	O
;	O
gstrcat	(*(char),*(char),long)->(*(char))
(	O
buf2	array(char)
,	O
tail	(*(char))->(*(char))
(	O
np	*(*(char))
[	O
0	int
]	O
)	O
,	O
sizeof	O
(	O
buf2	array(char)
)	O
)	O
;	O
if	O
(	O
link	(*(char),*(char))->(int)
(	O
np	*(*(char))
[	O
0	int
]	O
,	O
buf2	array(char)
)	O
>=	O
0	int
)	O
unlink	(*(char))->(int)
(	O
np	*(*(char))
[	O
0	int
]	O
)	O
;	O
}	O
np	*(*(char))
++	O
;	O
}	O
return	O
np	*(*(char))
;	O
}	O
static	O
int	O
absolute_pathname	(*(char))->(int)
(	O
const	O
char	O
*	O
p	*(char)
)	O
{	O
return	O
'/'	O
==	O
p	*(char)
[	O
0	int
]	O
;	O
}	O
static	O
void	O
try_to_exec	(*(char),array(*(char)))->(void)
(	O
const	O
char	O
*	O
prog	*(char)
,	O
char	O
*	O
const	O
argv	array(*(char))
[	O
]	O
)	O
{	O
char	O
*	O
newprog	*(char)
;	O
const	O
char	O
*	O
prefix	*(char)
;	O
size_t	long
len	long
;	O
if	O
(	O
Debug	char
)	O
printf	(*(char))->(int)
(	O
"try_to_exec: %s\n"	*(char)
,	O
prog	*(char)
)	O
;	O
if	O
(	O
subprogram_exec_prefix	*(char)
)	O
{	O
prefix	*(char)
=	O
subprogram_exec_prefix	*(char)
;	O
if	O
(	O
Debug	char
)	O
printf	(*(char))->(int)
(	O
"try_to_exec: Using user prefix '%s'\n"	*(char)
,	O
prefix	*(char)
)	O
;	O
}	O
else	O
{	O
prefix	*(char)
=	O
(	O
PREFIX	O
)	O
;	O
if	O
(	O
Debug	char
)	O
printf	(*(char))->(int)
(	O
"try_to_exec: Using default prefix '%s'\n"	*(char)
,	O
prefix	*(char)
)	O
;	O
if	O
(	O
TrustEnvironment	char
||	O
RealUser	char
)	O
execvp	(*(char),array(*(char)))->(int)
(	O
prog	*(char)
,	O
argv	array(*(char))
)	O
;	O
}	O
if	O
(	O
absolute_pathname	(*(char))->(int)
(	O
prog	*(char)
)	O
)	O
{	O
execv	(*(char),array(*(char)))->(int)
(	O
prog	*(char)
,	O
argv	array(*(char))
)	O
;	O
perror	(*(char))->(void)
(	O
prog	*(char)
)	O
;	O
}	O
else	O
{	O
len	long
=	O
strlen	(*(char))->(long)
(	O
prefix	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
prog	*(char)
)	O
;	O
newprog	*(char)
=	O
malloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
NULL	O
==	O
newprog	*(char)
)	O
{	O
oom	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_TEMPFAIL	int
)	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
newprog	*(char)
,	O
"%s%s"	*(char)
,	O
prefix	*(char)
,	O
prog	*(char)
)	O
;	O
prog	*(char)
=	O
newprog	*(char)
;	O
if	O
(	O
Debug	char
)	O
printf	(*(char))->(int)
(	O
"try_to_exec: %s\n"	*(char)
,	O
prog	*(char)
)	O
;	O
execv	(*(char),array(*(char)))->(int)
(	O
prog	*(char)
,	O
argv	array(*(char))
)	O
;	O
perror	(*(char))->(void)
(	O
prog	*(char)
)	O
;	O
}	O
if	O
(	O
Debug	char
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"try_to_exec: exec failed.\n"	*(char)
)	O
;	O
}	O
}	O
int	O
command	(array(*(char)),char,*(char))->(int)
(	O
char	O
*	O
argv	array(*(char))
[	O
]	O
,	O
bool	char
forkflag	char
,	O
const	O
char	O
*	O
arg0	*(char)
)	O
{	O
const	O
struct	O
sccsprog	struct(*(char),short,short,*(char),int)
*	O
cmd	*(struct(*(char),short,short,*(char),int))
;	O
char	O
buf	array(char)
[	O
FBUFSIZ	O
]	O
;	O
char	O
*	O
nav	array(*(char))
[	O
1000	int
]	O
;	O
char	O
*	O
*	O
np	*(*(char))
;	O
char	O
*	O
*	O
ap	*(*(char))
;	O
int	O
rval	*(int)
=	O
0	int
;	O
if	O
(	O
Debug	char
)	O
{	O
int	O
i	int
;	O
printf	(*(char))->(int)
(	O
"command:\n\t\"%s\"\n"	*(char)
,	O
arg0	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
argv	array(*(char))
[	O
i	int
]	O
!=	O
NULL	O
;	O
++	O
i	int
)	O
printf	(*(char))->(int)
(	O
"\t\"%s\"\n"	*(char)
,	O
argv	array(*(char))
[	O
i	int
]	O
)	O
;	O
}	O
np	*(*(char))
=	O
ap	*(*(char))
=	O
&	O
nav	array(*(char))
[	O
1	int
]	O
;	O
if	O
(	O
1	int
)	O
{	O
char	O
*	O
editchs	*(char)
;	O
editchs	*(char)
=	O
NULL	O
;	O
if	O
(	O
1	int
)	O
{	O
char	O
*	O
q	*(char)
;	O
const	O
char	O
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
arg0	*(char)
,	O
q	*(char)
=	O
buf	array(char)
;	O
*	O
p	*(char)
!=	O
'\0'	O
&&	O
*	O
p	*(char)
!=	O
'/'	O
;	O
)	O
{	O
*	O
np	*(*(char))
++	O
=	O
q	*(char)
;	O
while	O
(	O
*	O
p	*(char)
==	O
' '	O
)	O
p	*(char)
++	O
;	O
while	O
(	O
*	O
p	*(char)
!=	O
' '	O
&&	O
*	O
p	*(char)
!=	O
'\0'	O
&&	O
*	O
p	*(char)
!=	O
'/'	O
&&	O
*	O
p	*(char)
!=	O
':'	O
)	O
*	O
q	*(char)
++	O
=	O
*	O
p	*(char)
++	O
;	O
*	O
q	*(char)
++	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
':'	O
)	O
{	O
editchs	*(char)
=	O
q	*(char)
;	O
while	O
(	O
*	O
++	O
p	*(char)
!=	O
'\0'	O
&&	O
*	O
p	*(char)
!=	O
'/'	O
&&	O
*	O
p	*(char)
!=	O
' '	O
)	O
*	O
q	*(char)
++	O
=	O
*	O
p	*(char)
;	O
*	O
q	*(char)
++	O
=	O
'\0'	O
;	O
}	O
}	O
}	O
*	O
np	*(*(char))
=	O
NULL	O
;	O
if	O
(	O
*	O
ap	*(*(char))
==	O
NULL	O
)	O
*	O
np	*(*(char))
++	O
=	O
*	O
argv	array(*(char))
++	O
;	O
cmd	*(struct(*(char),short,short,*(char),int))
=	O
lookup	(*(char))->(*(struct(*(char),short,short,*(char),int)))
(	O
*	O
ap	*(*(char))
)	O
;	O
if	O
(	O
cmd	*(struct(*(char),short,short,*(char),int))
==	O
NULL	O
)	O
{	O
usrerr	(*(char))->(void)
(	O
"Unknown command \"%s\""	*(char)
,	O
*	O
ap	*(*(char))
)	O
;	O
usage	()->(void)
(	O
)	O
;	O
return	O
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
cmd	*(struct(*(char),short,short,*(char),int))
->	O
sccsflags	short
&	O
WARN_MISSING	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Warning: the \"%s\" command is not yet implemented.\n"	*(char)
,	O
*	O
ap	*(*(char))
)	O
;	O
}	O
if	O
(	O
cmd	*(struct(*(char),short,short,*(char),int))
->	O
sccsflags	short
&	O
NO_HELP_HERE	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"GNU CSSC does not provide the \"%s\" command;\n"	*(char)
"please see the relevant entry in the GNU CSSC manual\n"	*(char)
"and the \"Missing Features and other Problems\" chapter\n"	*(char)
"in particular.\n\n"	*(char)
,	O
*	O
ap	*(*(char))
)	O
;	O
}	O
}	O
for	O
(	O
;	O
*	O
argv	array(*(char))
!=	O
NULL	O
;	O
argv	array(*(char))
++	O
)	O
{	O
char	O
*	O
p	*(char)
;	O
p	*(char)
=	O
*	O
argv	array(*(char))
;	O
if	O
(	O
*	O
p	*(char)
==	O
'-'	O
)	O
{	O
if	O
(	O
p	*(char)
[	O
1	int
]	O
==	O
'\0'	O
||	O
editchs	*(char)
==	O
NULL	O
||	O
my_index	(*(char),int)->(*(char))
(	O
editchs	*(char)
,	O
p	*(char)
[	O
1	int
]	O
)	O
!=	O
NULL	O
)	O
*	O
np	*(*(char))
++	O
=	O
p	*(char)
;	O
}	O
else	O
{	O
if	O
(	O
!	O
bitset	O
(	O
NO_SDOT	int
,	O
cmd	*(struct(*(char),short,short,*(char),int))
->	O
sccsflags	short
)	O
)	O
p	*(char)
=	O
makefile	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
if	O
(	O
p	*(char)
!=	O
NULL	O
)	O
*	O
np	*(*(char))
++	O
=	O
p	*(char)
;	O
}	O
}	O
*	O
np	*(*(char))
=	O
NULL	O
;	O
}	O
switch	O
(	O
cmd	*(struct(*(char),short,short,*(char),int))
->	O
sccsoper	short
)	O
{	O
case	O
PROG	int
:	O
{	O
rval	*(int)
=	O
callprog	(*(char),short,array(*(char)),char)->(int)
(	O
cmd	*(struct(*(char),short,short,*(char),int))
->	O
sccspath	*(char)
,	O
cmd	*(struct(*(char),short,short,*(char),int))
->	O
sccsflags	short
,	O
ap	*(*(char))
,	O
forkflag	char
)	O
;	O
}	O
break	O
;	O
case	O
CMACRO	int
:	O
{	O
const	O
char	O
*	O
s	*(char)
;	O
for	O
(	O
s	*(char)
=	O
cmd	*(struct(*(char),short,short,*(char),int))
->	O
sccspath	*(char)
;	O
*	O
s	*(char)
!=	O
'\0'	O
;	O
s	*(char)
++	O
)	O
{	O
const	O
char	O
*	O
qq	*(char)
=	O
s	*(char)
;	O
while	O
(	O
*	O
s	*(char)
!=	O
'\0'	O
&&	O
*	O
s	*(char)
!=	O
'/'	O
)	O
s	*(char)
++	O
;	O
rval	*(int)
=	O
command	(array(*(char)),char,*(char))->(int)
(	O
&	O
ap	*(*(char))
[	O
1	int
]	O
,	O
*	O
s	*(char)
!=	O
'\0'	O
,	O
qq	*(char)
)	O
;	O
if	O
(	O
rval	*(int)
!=	O
0	int
)	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
FIX	int
:	O
{	O
if	O
(	O
ap	*(*(char))
[	O
1	int
]	O
==	O
0	int
||	O
strncmp	(*(char),*(char),long)->(int)
(	O
ap	*(*(char))
[	O
1	int
]	O
,	O
"-r"	*(char)
,	O
2	int
)	O
!=	O
0	int
)	O
{	O
usrerr	(*(char))->(void)
(	O
"-r flag needed for fix command"	*(char)
)	O
;	O
rval	*(int)
=	O
CSSC_EX_USAGE	int
;	O
break	O
;	O
}	O
rval	*(int)
=	O
command	(array(*(char)),char,*(char))->(int)
(	O
&	O
ap	*(*(char))
[	O
1	int
]	O
,	O
TRUE	int
,	O
"get -k"	*(char)
)	O
;	O
if	O
(	O
rval	*(int)
==	O
0	int
)	O
rval	*(int)
=	O
command	(array(*(char)),char,*(char))->(int)
(	O
&	O
ap	*(*(char))
[	O
1	int
]	O
,	O
TRUE	int
,	O
"rmdel:r"	*(char)
)	O
;	O
if	O
(	O
rval	*(int)
==	O
0	int
)	O
rval	*(int)
=	O
command	(array(*(char)),char,*(char))->(int)
(	O
&	O
ap	*(*(char))
[	O
2	int
]	O
,	O
FALSE	int
,	O
"get -e -g"	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
CLEAN	int
:	O
{	O
rval	*(int)
=	O
clean	(int,array(*(char)))->(int)
(	O
cmd	*(struct(*(char),short,short,*(char),int))
->	O
clean_mode	int
,	O
ap	*(*(char))
)	O
;	O
}	O
break	O
;	O
case	O
UNEDIT	int
:	O
{	O
for	O
(	O
argv	array(*(char))
=	O
np	*(*(char))
=	O
&	O
ap	*(*(char))
[	O
1	int
]	O
;	O
*	O
argv	array(*(char))
!=	O
NULL	O
;	O
argv	array(*(char))
++	O
)	O
{	O
if	O
(	O
unedit	(*(char))->(char)
(	O
*	O
argv	array(*(char))
)	O
)	O
*	O
np	*(*(char))
++	O
=	O
*	O
argv	array(*(char))
;	O
}	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
*	O
np	*(*(char))
=	O
NULL	O
;	O
if	O
(	O
np	*(*(char))
>	O
&	O
ap	*(*(char))
[	O
1	int
]	O
)	O
rval	*(int)
=	O
command	(array(*(char)),char,*(char))->(int)
(	O
&	O
ap	*(*(char))
[	O
1	int
]	O
,	O
TRUE	int
,	O
"get"	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
DIFFS	int
:	O
{	O
char	O
*	O
s	*(char)
;	O
for	O
(	O
np	*(*(char))
=	O
&	O
ap	*(*(char))
[	O
1	int
]	O
;	O
*	O
np	*(*(char))
!=	O
NULL	O
&&	O
*	O
*	O
np	*(*(char))
==	O
'-'	O
;	O
np	*(*(char))
++	O
)	O
continue	O
;	O
argv	array(*(char))
=	O
np	*(*(char))
;	O
s	*(char)
=	O
argv	array(*(char))
[	O
1	int
]	O
;	O
while	O
(	O
*	O
np	*(*(char))
!=	O
NULL	O
)	O
{	O
int	O
this_ret	int
;	O
*	O
argv	array(*(char))
=	O
*	O
np	*(*(char))
++	O
;	O
argv	array(*(char))
[	O
1	int
]	O
=	O
NULL	O
;	O
this_ret	int
=	O
dodiff	(array(*(char)),*(char))->(int)
(	O
ap	*(*(char))
,	O
tail	(*(char))->(*(char))
(	O
*	O
argv	array(*(char))
)	O
)	O
;	O
if	O
(	O
rval	*(int)
==	O
0	int
)	O
rval	*(int)
=	O
this_ret	int
;	O
argv	array(*(char))
[	O
1	int
]	O
=	O
s	*(char)
;	O
}	O
}	O
break	O
;	O
case	O
DODIFF	int
:	O
{	O
drop_privs	()->(void)
(	O
)	O
;	O
for	O
(	O
np	*(*(char))
=	O
ap	*(*(char))
;	O
*	O
np	*(*(char))
!=	O
NULL	O
;	O
np	*(*(char))
++	O
)	O
{	O
if	O
(	O
(	O
*	O
np	*(*(char))
)	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
(	O
*	O
np	*(*(char))
)	O
[	O
1	int
]	O
==	O
'C'	O
)	O
(	O
*	O
np	*(*(char))
)	O
[	O
1	int
]	O
=	O
'c'	O
;	O
}	O
np	*(*(char))
[	O
1	int
]	O
=	O
NULL	O
;	O
np	*(*(char))
[	O
0	int
]	O
=	O
np	*(*(char))
[	O
-	O
1	int
]	O
;	O
np	*(*(char))
[	O
-	O
1	int
]	O
=	O
"-"	*(char)
;	O
if	O
(	O
TrustEnvironment	char
)	O
execvp	(*(char),array(*(char)))->(int)
(	O
"diff"	*(char)
,	O
ap	*(*(char))
)	O
;	O
try_to_exec	(*(char),array(*(char)))->(void)
(	O
cmd	*(struct(*(char),short,short,*(char),int))
->	O
sccspath	*(char)
,	O
argv	array(*(char))
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
break	O
;	O
case	O
ENTER	int
:	O
np	*(*(char))
=	O
do_enter	(array(*(char)),*(*(char)),*(*(char)),*(int))->(*(*(char)))
(	O
argv	array(*(char))
,	O
np	*(*(char))
,	O
ap	*(*(char))
,	O
&	O
rval	*(int)
)	O
;	O
break	O
;	O
default	O
:	O
{	O
syserr	(*(char))->(void)
(	O
"Unexpected oper %d"	*(char)
,	O
cmd	*(struct(*(char),short,short,*(char),int))
->	O
sccsoper	short
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_SOFTWARE	int
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
Debug	char
)	O
printf	(*(char))->(int)
(	O
"command: rval=%d\n"	*(char)
,	O
rval	*(int)
)	O
;	O
return	O
rval	*(int)
;	O
}	O
const	O
struct	O
sccsprog	struct(*(char),short,short,*(char),int)
*	O
lookup	(*(char))->(*(struct(*(char),short,short,*(char),int)))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
register	O
const	O
struct	O
sccsprog	struct(*(char),short,short,*(char),int)
*	O
cmd	*(struct(*(char),short,short,*(char),int))
;	O
for	O
(	O
cmd	*(struct(*(char),short,short,*(char),int))
=	O
SccsProg	array(struct(*(char),short,short,*(char),int))
;	O
cmd	*(struct(*(char),short,short,*(char),int))
->	O
sccsname	*(char)
!=	O
NULL	O
;	O
cmd	*(struct(*(char),short,short,*(char),int))
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(struct(*(char),short,short,*(char),int))
->	O
sccsname	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
cmd	*(struct(*(char),short,short,*(char),int))
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
childwait	(int,*(int),int)->(void)
(	O
int	O
pid	int
,	O
int	O
*	O
status_ptr	*(int)
,	O
int	O
ignoreintr	int
)	O
{	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
sa	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
osa	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
int	O
ret	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
sa	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
0	int
,	O
sizeof	O
(	O
sa	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
)	O
;	O
if	O
(	O
ignoreintr	int
)	O
{	O
sa	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
=	O
SIG_IGN	O
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
sa	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
sa	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
0	int
;	O
ret	int
=	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGINT	int
,	O
&	O
sa	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
&	O
osa	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
}	O
while	O
(	O
-	O
1	int
==	O
waitpid	(int,*(int),int)->(int)
(	O
pid	int
,	O
status_ptr	*(int)
,	O
0	int
)	O
&&	O
EINTR	int
==	O
errno	O
)	O
errno	O
=	O
0	int
;	O
if	O
(	O
ignoreintr	int
&&	O
0	int
==	O
ret	int
)	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGINT	int
,	O
&	O
osa	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
NULL	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
get_sig_name	(int,array(char))->(*(char))
(	O
unsigned	O
int	O
sig	int
,	O
char	O
sigmsgbuf	array(char)
[	O
11	int
]	O
)	O
{	O
if	O
(	O
sig	int
>	O
999	int
)	O
sig	int
=	O
999	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
sigmsgbuf	array(char)
,	O
"Signal %u"	*(char)
,	O
sig	int
)	O
;	O
return	O
sigmsgbuf	array(char)
;	O
}	O
static	O
pid_t	int
do_fork	()->(int)
(	O
void	O
)	O
{	O
return	O
fork	()->(int)
(	O
)	O
;	O
}	O
int	O
callprog	(*(char),short,array(*(char)),char)->(int)
(	O
const	O
char	O
*	O
progpath	*(char)
,	O
short	O
flags	short
,	O
char	O
*	O
const	O
argv	array(*(char))
[	O
]	O
,	O
bool	char
forkflag	char
)	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
Debug	char
)	O
{	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
"callprog:"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
argv	array(*(char))
[	O
i	int
]	O
!=	O
NULL	O
;	O
i	int
++	O
)	O
printf	(*(char))->(int)
(	O
"\t\"%s\"\n"	*(char)
,	O
argv	array(*(char))
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
*	O
argv	array(*(char))
==	O
NULL	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
if	O
(	O
forkflag	char
)	O
{	O
if	O
(	O
Debug	char
)	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
"Forking\n"	*(char)
)	O
;	O
i	int
=	O
do_fork	()->(int)
(	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
syserr	(*(char))->(void)
(	O
"cannot fork"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
else	O
if	O
(	O
i	int
>	O
0	int
)	O
{	O
int	O
st	int
;	O
childwait	(int,*(int),int)->(void)
(	O
i	int
,	O
&	O
st	int
,	O
0	int
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
st	int
)	O
)	O
{	O
st	int
=	O
WEXITSTATUS	O
(	O
st	int
)	O
;	O
}	O
else	O
{	O
int	O
sigcode	int
=	O
WTERMSIG	O
(	O
st	int
)	O
;	O
if	O
(	O
sigcode	int
!=	O
SIGINT	int
&&	O
sigcode	int
!=	O
SIGPIPE	int
)	O
{	O
char	O
sigmsgbuf	array(char)
[	O
11	int
]	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s: %s%s\n"	*(char)
,	O
program_name	*(char)
,	O
argv	array(*(char))
[	O
0	int
]	O
,	O
get_sig_name	(int,array(char))->(*(char))
(	O
sigcode	int
,	O
sigmsgbuf	array(char)
)	O
,	O
(	O
WCOREDUMP	O
(	O
st	int
)	O
?	O
" (core dumped)"	*(char)
:	O
""	*(char)
)	O
)	O
;	O
}	O
st	int
=	O
CSSC_EX_SOFTWARE	int
;	O
}	O
if	O
(	O
OutFile	int
>=	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
OutFile	int
)	O
;	O
OutFile	int
=	O
-	O
1	int
;	O
}	O
return	O
(	O
st	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
OutFile	int
>=	O
0	int
)	O
{	O
syserr	(*(char))->(void)
(	O
"callprog: setting stdout without forking"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_SOFTWARE	int
)	O
;	O
}	O
if	O
(	O
bitset	O
(	O
REALUSER	int
,	O
flags	short
)	O
)	O
{	O
drop_privs	()->(void)
(	O
)	O
;	O
RealUser	char
=	O
1	int
;	O
if	O
(	O
Debug	char
)	O
printf	(*(char))->(int)
(	O
"callprog: gave up privileges.\n"	*(char)
)	O
;	O
}	O
if	O
(	O
OutFile	int
>=	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
1	int
)	O
;	O
dup	(int)->(int)
(	O
OutFile	int
)	O
;	O
close	*((*(void))->(int))
(	O
OutFile	int
)	O
;	O
}	O
try_to_exec	(*(char),array(*(char)))->(void)
(	O
progpath	*(char)
,	O
argv	array(*(char))
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_UNAVAILABLE	int
)	O
;	O
}	O
static	O
char	O
*	O
str_dup	(*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
char	O
*	O
p	*(char)
;	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
+	O
1u	int
;	O
p	*(char)
=	O
malloc	(long)->(*(void))
(	O
len	long
)	O
;	O
if	O
(	O
p	*(char)
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(char)
,	O
s	*(char)
,	O
len	long
)	O
;	O
}	O
else	O
{	O
perror	(*(char))->(void)
(	O
"Sccs: no mem"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_TEMPFAIL	int
)	O
;	O
}	O
return	O
p	*(char)
;	O
}	O
char	O
*	O
makefile	(*(char))->(*(char))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
register	O
const	O
char	O
*	O
p	*(char)
;	O
char	O
buf	array(char)
[	O
3	int
*	O
FBUFSIZ	O
]	O
;	O
register	O
char	O
*	O
q	*(char)
;	O
size_t	long
left	long
;	O
p	*(char)
=	O
my_rindex	(*(char),int)->(*(char))
(	O
name	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
p	*(char)
==	O
NULL	O
)	O
p	*(char)
=	O
name	*(char)
;	O
else	O
p	*(char)
++	O
;	O
if	O
(	O
SccsDir	*(char)
[	O
0	int
]	O
==	O
'/'	O
&&	O
!	O
safepath	(*(char))->(char)
(	O
name	*(char)
)	O
)	O
return	O
(	O
NULL	O
)	O
;	O
if	O
(	O
SccsDir	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
name	*(char)
[	O
0	int
]	O
!=	O
'/'	O
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"./"	*(char)
,	O
2	int
)	O
!=	O
0	int
)	O
{	O
gstrcpy	(*(char),*(char),long)->(*(char))
(	O
buf	array(char)
,	O
SccsDir	*(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
)	O
;	O
gstrcat	(*(char),*(char),long)->(*(char))
(	O
buf	array(char)
,	O
"/"	*(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
)	O
;	O
}	O
else	O
{	O
gstrcpy	(*(char),*(char),long)->(*(char))
(	O
buf	array(char)
,	O
""	*(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
)	O
;	O
}	O
gstrncat	(*(char),*(char),long,long)->(*(char))
(	O
buf	array(char)
,	O
name	*(char)
,	O
p	*(char)
-	O
name	*(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
)	O
;	O
q	*(char)
=	O
&	O
buf	array(char)
[	O
strlen	(*(char))->(long)
(	O
buf	array(char)
)	O
]	O
;	O
left	long
=	O
sizeof	O
(	O
buf	array(char)
)	O
-	O
strlen	(*(char))->(long)
(	O
buf	array(char)
)	O
;	O
gstrcpy	(*(char),*(char),long)->(*(char))
(	O
q	*(char)
,	O
p	*(char)
,	O
left	long
)	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(char)
,	O
"s."	*(char)
,	O
2	int
)	O
!=	O
0	int
&&	O
!	O
isdir	(*(char))->(char)
(	O
buf	array(char)
)	O
)	O
{	O
gstrcpy	(*(char),*(char),long)->(*(char))
(	O
q	*(char)
,	O
SccsPath	*(char)
,	O
left	long
)	O
;	O
gstrcat	(*(char),*(char),long)->(*(char))
(	O
buf	array(char)
,	O
"/s."	*(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
)	O
;	O
gstrcat	(*(char),*(char),long)->(*(char))
(	O
buf	array(char)
,	O
p	*(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
)	O
;	O
}	O
return	O
str_dup	(*(char))->(*(char))
(	O
buf	array(char)
)	O
;	O
}	O
bool	char
isdir	(*(char))->(char)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
return	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
name	*(char)
,	O
&	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
>=	O
0	int
)	O
&&	O
S_ISDIR	O
(	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
;	O
}	O
bool	char
safepath	(*(char))->(char)
(	O
register	O
const	O
char	O
*	O
p	*(char)
)	O
{	O
const	O
char	O
*	O
arg	*(char)
=	O
p	*(char)
;	O
if	O
(	O
*	O
p	*(char)
!=	O
'/'	O
)	O
{	O
while	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(char)
,	O
"../"	*(char)
,	O
3	int
)	O
!=	O
0	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(char)
,	O
".."	*(char)
)	O
!=	O
0	int
)	O
{	O
p	*(char)
=	O
my_index	(*(char),int)->(*(char))
(	O
p	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
p	*(char)
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
p	*(char)
++	O
;	O
}	O
}	O
printf	(*(char))->(int)
(	O
"You may not use full pathnames or \"..\" but you specifed '%s'\n"	*(char)
,	O
arg	*(char)
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
void	O
form_gname	(*(char),long,*(struct(long,long,short,char,array(char))))->(void)
(	O
char	O
*	O
buf	array(char)
,	O
size_t	long
bufsize	long
,	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dir	*(struct(long,long,short,char,array(char)))
)	O
{	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
dir	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
;	O
size_t	long
gname_len	long
=	O
len	long
-	O
2u	int
;	O
if	O
(	O
gname_len	long
>=	O
bufsize	long
)	O
{	O
gstrbotchn	(int,*(char),int,*(char),int)->(void)
(	O
bufsize	long
,	O
dir	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
,	O
len	long
,	O
(	O
char	O
*	O
)	O
0	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	array(char)
,	O
dir	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
+	O
2	int
,	O
gname_len	long
)	O
;	O
buf	array(char)
[	O
gname_len	long
]	O
=	O
0	int
;	O
}	O
}	O
int	O
do_clean	(int,*(*(char)),array(char))->(int)
(	O
int	O
mode	int
,	O
char	O
*	O
const	O
*	O
argv	array(*(char))
,	O
char	O
buf	array(char)
[	O
FBUFSIZ	O
]	O
)	O
{	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dir	*(struct(long,long,short,char,array(char)))
;	O
register	O
DIR	struct
*	O
dirp	*(struct)
;	O
char	O
*	O
bufend	*(char)
;	O
register	O
char	O
*	O
basefile	*(char)
;	O
bool	char
gotedit	char
;	O
bool	char
gotpfent	char
;	O
FILE	struct
*	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
bool	char
nobranch	char
=	O
FALSE	int
;	O
register	O
const	O
struct	O
pfile	struct(*(char),*(char),*(char),*(char),*(char),*(char))
*	O
pf	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
;	O
register	O
char	O
*	O
const	O
*	O
ap	*(*(char))
;	O
const	O
char	O
*	O
usernm	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
subdir	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
cmdname	*(char)
;	O
cmdname	*(char)
=	O
*	O
argv	array(*(char))
;	O
for	O
(	O
ap	*(*(char))
=	O
argv	array(*(char))
;	O
*	O
++	O
ap	*(*(char))
!=	O
NULL	O
;	O
)	O
{	O
if	O
(	O
*	O
*	O
ap	*(*(char))
==	O
'-'	O
)	O
{	O
switch	O
(	O
(	O
*	O
ap	*(*(char))
)	O
[	O
1	int
]	O
)	O
{	O
case	O
'b'	O
:	O
nobranch	char
=	O
TRUE	int
;	O
break	O
;	O
case	O
'u'	O
:	O
if	O
(	O
(	O
*	O
ap	*(*(char))
)	O
[	O
2	int
]	O
!=	O
'\0'	O
)	O
usernm	*(char)
=	O
&	O
(	O
*	O
ap	*(*(char))
)	O
[	O
2	int
]	O
;	O
else	O
if	O
(	O
ap	*(*(char))
[	O
1	int
]	O
!=	O
NULL	O
&&	O
ap	*(*(char))
[	O
1	int
]	O
[	O
0	int
]	O
!=	O
'-'	O
)	O
usernm	*(char)
=	O
*	O
++	O
ap	*(*(char))
;	O
else	O
usernm	*(char)
=	O
username	()->(*(char))
(	O
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
subdir	*(char)
!=	O
NULL	O
)	O
usrerr	(*(char))->(void)
(	O
"too many args"	*(char)
)	O
;	O
else	O
subdir	*(char)
=	O
*	O
ap	*(*(char))
;	O
}	O
}	O
gstrcpy	(*(char),*(char),long)->(*(char))
(	O
buf	array(char)
,	O
SccsDir	*(char)
,	O
FBUFSIZ	O
)	O
;	O
if	O
(	O
buf	array(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
gstrcat	(*(char),*(char),long)->(*(char))
(	O
buf	array(char)
,	O
"/"	*(char)
,	O
FBUFSIZ	O
)	O
;	O
if	O
(	O
subdir	*(char)
!=	O
NULL	O
)	O
{	O
gstrcat	(*(char),*(char),long)->(*(char))
(	O
buf	array(char)
,	O
subdir	*(char)
,	O
FBUFSIZ	O
)	O
;	O
gstrcat	(*(char),*(char),long)->(*(char))
(	O
buf	array(char)
,	O
"/"	*(char)
,	O
FBUFSIZ	O
)	O
;	O
}	O
gstrcat	(*(char),*(char),long)->(*(char))
(	O
buf	array(char)
,	O
SccsPath	*(char)
,	O
FBUFSIZ	O
)	O
;	O
bufend	*(char)
=	O
&	O
buf	array(char)
[	O
strlen	(*(char))->(long)
(	O
buf	array(char)
)	O
]	O
;	O
dirp	*(struct)
=	O
opendir	(*(char))->(*(struct))
(	O
buf	array(char)
)	O
;	O
if	O
(	O
dirp	*(struct)
==	O
NULL	O
)	O
{	O
usrerr	(*(char))->(void)
(	O
"cannot open %s"	*(char)
,	O
buf	array(char)
)	O
;	O
return	O
(	O
CSSC_EX_NOINPUT	int
)	O
;	O
}	O
gotedit	char
=	O
FALSE	int
;	O
while	O
(	O
NULL	O
!=	O
(	O
dir	*(struct(long,long,short,char,array(char)))
=	O
readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
dirp	*(struct)
)	O
)	O
)	O
{	O
if	O
(	O
's'	O
!=	O
dir	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
0	int
]	O
||	O
'.'	O
!=	O
dir	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
1	int
]	O
||	O
0	int
==	O
dir	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
2	int
]	O
)	O
continue	O
;	O
gstrcat	(*(char),*(char),long)->(*(char))
(	O
buf	array(char)
,	O
"/p."	*(char)
,	O
FBUFSIZ	O
)	O
;	O
basefile	*(char)
=	O
bufend	*(char)
+	O
3	int
;	O
form_gname	(*(char),long,*(struct(long,long,short,char,array(char))))->(void)
(	O
basefile	*(char)
,	O
FBUFSIZ	O
-	O
strlen	(*(char))->(long)
(	O
buf	array(char)
)	O
,	O
dir	*(struct(long,long,short,char,array(char)))
)	O
;	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
buf	array(char)
,	O
"r"	*(char)
)	O
;	O
gotpfent	char
=	O
FALSE	int
;	O
if	O
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
while	O
(	O
(	O
pf	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
=	O
getpfent	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(*(char),*(char),*(char),*(char),*(char),*(char))))
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
nobranch	char
&&	O
isbranch	(*(char))->(int)
(	O
pf	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
p_nsid	*(char)
)	O
)	O
continue	O
;	O
if	O
(	O
usernm	*(char)
!=	O
NULL	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
usernm	*(char)
,	O
pf	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
p_user	*(char)
)	O
!=	O
0	int
&&	O
mode	int
!=	O
CLEANC	int
)	O
continue	O
;	O
gotedit	char
=	O
TRUE	int
;	O
gotpfent	char
=	O
TRUE	int
;	O
if	O
(	O
mode	int
==	O
TELLC	int
)	O
{	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
basefile	*(char)
)	O
;	O
break	O
;	O
}	O
printf	(*(char))->(int)
(	O
"%12s: being edited: "	*(char)
,	O
basefile	*(char)
)	O
;	O
putpfent	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
pf	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
mode	int
==	O
CLEANC	int
&&	O
!	O
gotpfent	char
)	O
{	O
char	O
unlinkbuf	array(char)
[	O
FBUFSIZ	O
]	O
;	O
form_gname	(*(char),long,*(struct(long,long,short,char,array(char))))->(void)
(	O
unlinkbuf	array(char)
,	O
FBUFSIZ	O
,	O
dir	*(struct(long,long,short,char,array(char)))
)	O
;	O
unlink	(*(char))->(int)
(	O
unlinkbuf	array(char)
)	O
;	O
}	O
}	O
closedir	(*(struct))->(int)
(	O
dirp	*(struct)
)	O
;	O
if	O
(	O
!	O
gotedit	char
&&	O
mode	int
==	O
INFOC	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Nothing being edited"	*(char)
)	O
;	O
if	O
(	O
nobranch	char
)	O
printf	(*(char))->(int)
(	O
" (on trunk)"	*(char)
)	O
;	O
if	O
(	O
usernm	*(char)
==	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
" by %s\n"	*(char)
,	O
usernm	*(char)
)	O
;	O
}	O
if	O
(	O
mode	int
==	O
CHECKC	int
)	O
exit	(int)->(void)
(	O
gotedit	char
)	O
;	O
return	O
(	O
CSSC_EX_OK	int
)	O
;	O
}	O
int	O
clean	(int,array(*(char)))->(int)
(	O
int	O
mode	int
,	O
char	O
*	O
const	O
*	O
argv	array(*(char))
)	O
{	O
int	O
retval	int
=	O
CSSC_EX_OK	int
;	O
char	O
*	O
buf	array(char)
=	O
malloc	(long)->(*(void))
(	O
FBUFSIZ	O
)	O
;	O
if	O
(	O
NULL	O
==	O
buf	array(char)
)	O
{	O
oom	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
retval	int
=	O
do_clean	(int,*(*(char)),array(char))->(int)
(	O
mode	int
,	O
argv	array(*(char))
,	O
buf	array(char)
)	O
;	O
free	(*(void))->(void)
(	O
buf	array(char)
)	O
;	O
}	O
return	O
retval	int
;	O
}	O
int	O
isbranch	(*(char))->(int)
(	O
const	O
char	O
*	O
sid	*(char)
)	O
{	O
register	O
const	O
char	O
*	O
p	*(char)
;	O
int	O
dots	int
;	O
dots	int
=	O
0	int
;	O
for	O
(	O
p	*(char)
=	O
sid	*(char)
;	O
*	O
p	*(char)
!=	O
'\0'	O
;	O
p	*(char)
++	O
)	O
{	O
if	O
(	O
*	O
p	*(char)
==	O
'.'	O
)	O
dots	int
++	O
;	O
if	O
(	O
dots	int
>	O
1	int
)	O
return	O
TRUE	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
bool	char
unedit	(*(char))->(char)
(	O
const	O
char	O
*	O
fn	*(char)
)	O
{	O
register	O
FILE	struct
*	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
const	O
char	O
*	O
cp	*(char)
;	O
char	O
*	O
pfn	*(char)
;	O
FILE	struct
*	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
register	O
char	O
*	O
q	*(char)
;	O
bool	char
delete	char
=	O
FALSE	int
;	O
bool	char
others	char
=	O
FALSE	int
;	O
const	O
char	O
*	O
myname	*(char)
;	O
const	O
struct	O
pfile	struct(*(char),*(char),*(char),*(char),*(char),*(char))
*	O
pent	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
;	O
char	O
buf	array(char)
[	O
PFILELG	int
]	O
;	O
pfn	*(char)
=	O
makefile	(*(char))->(*(char))
(	O
fn	*(char)
)	O
;	O
if	O
(	O
pfn	*(char)
==	O
NULL	O
)	O
return	O
(	O
FALSE	int
)	O
;	O
q	*(char)
=	O
my_rindex	(*(char),int)->(*(char))
(	O
pfn	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
q	*(char)
==	O
NULL	O
)	O
q	*(char)
=	O
&	O
pfn	*(char)
[	O
-	O
1	int
]	O
;	O
if	O
(	O
q	*(char)
[	O
1	int
]	O
!=	O
's'	O
||	O
q	*(char)
[	O
2	int
]	O
!=	O
'.'	O
)	O
{	O
usrerr	(*(char))->(void)
(	O
"bad file name \"%s\""	*(char)
,	O
fn	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
pfn	*(char)
)	O
;	O
return	O
(	O
FALSE	int
)	O
;	O
}	O
*	O
++	O
q	*(char)
=	O
'p'	O
;	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
pfn	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%12s: not being edited\n"	*(char)
,	O
fn	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
pfn	*(char)
)	O
;	O
return	O
(	O
FALSE	int
)	O
;	O
}	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
tmpfile	()->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
)	O
;	O
if	O
(	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
usrerr	(*(char))->(void)
(	O
"cannot create temporary file"	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
pfn	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
myname	*(char)
=	O
username	()->(*(char))
(	O
)	O
;	O
while	O
(	O
(	O
pent	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
=	O
getpfent	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(*(char),*(char),*(char),*(char),*(char),*(char))))
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
pent	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
p_user	*(char)
,	O
myname	*(char)
)	O
==	O
0	int
)	O
{	O
delete	char
=	O
TRUE	int
;	O
}	O
else	O
{	O
putpfent	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
pent	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
,	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
others	char
++	O
;	O
}	O
}	O
if	O
(	O
delete	char
)	O
{	O
extern	O
int	O
errno	O
;	O
cp	*(char)
=	O
tail	(*(char))->(*(char))
(	O
pfn	*(char)
)	O
;	O
if	O
(	O
'p'	O
==	O
cp	*(char)
[	O
0	int
]	O
&&	O
'.'	O
==	O
cp	*(char)
[	O
1	int
]	O
)	O
{	O
cp	*(char)
+=	O
2	int
;	O
}	O
errno	O
=	O
0	int
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
cp	*(char)
,	O
0	int
)	O
<	O
0	int
&&	O
errno	O
!=	O
ENOENT	int
)	O
goto	O
bad	O
;	O
if	O
(	O
errno	O
==	O
0	int
)	O
if	O
(	O
access	(*(char),int)->(int)
(	O
"."	*(char)
,	O
2	int
)	O
<	O
0	int
)	O
{	O
bad	O
:	O
printf	(*(char))->(int)
(	O
"%12s: can't remove\n"	*(char)
,	O
cp	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
pfn	*(char)
)	O
;	O
return	O
(	O
FALSE	int
)	O
;	O
}	O
}	O
if	O
(	O
others	char
)	O
{	O
rewind	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
freopen	(*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
pfn	*(char)
,	O
"w"	*(char)
,	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
NULL	O
)	O
{	O
usrerr	(*(char))->(void)
(	O
"cannot create \"%s\""	*(char)
,	O
pfn	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
pfn	*(char)
)	O
;	O
return	O
(	O
FALSE	int
)	O
;	O
}	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	array(char)
,	O
sizeof	O
buf	array(char)
,	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
NULL	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
buf	array(char)
,	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
{	O
unlink	(*(char))->(int)
(	O
pfn	*(char)
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
delete	char
)	O
{	O
if	O
(	O
unlink	(*(char))->(int)
(	O
cp	*(char)
)	O
>=	O
0	int
)	O
printf	(*(char))->(int)
(	O
"%12s: removed\n"	*(char)
,	O
cp	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
pfn	*(char)
)	O
;	O
return	O
(	O
TRUE	int
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"%12s: not being edited by you\n"	*(char)
,	O
fn	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
pfn	*(char)
)	O
;	O
return	O
(	O
FALSE	int
)	O
;	O
}	O
}	O
int	O
dodiff	(array(*(char)),*(char))->(int)
(	O
char	O
*	O
getv	array(*(char))
[	O
]	O
,	O
const	O
char	O
*	O
gfile	*(char)
)	O
{	O
int	O
pipev	array(int)
[	O
2	int
]	O
;	O
int	O
rval	*(int)
;	O
register	O
int	O
pid	int
;	O
auto	O
int	O
st	int
;	O
extern	O
int	O
errno	O
;	O
printf	(*(char))->(int)
(	O
"\n------- %s -------\n"	*(char)
,	O
gfile	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
pipe	(array(int))->(int)
(	O
pipev	array(int)
)	O
<	O
0	int
)	O
{	O
syserr	(*(char))->(void)
(	O
"dodiff: pipe failed"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
if	O
(	O
(	O
pid	int
=	O
do_fork	()->(int)
(	O
)	O
)	O
<	O
0	int
)	O
{	O
syserr	(*(char))->(void)
(	O
"dodiff: fork failed"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
else	O
if	O
(	O
pid	int
>	O
0	int
)	O
{	O
OutFile	int
=	O
pipev	array(int)
[	O
1	int
]	O
;	O
close	*((*(void))->(int))
(	O
pipev	array(int)
[	O
0	int
]	O
)	O
;	O
rval	*(int)
=	O
command	(array(*(char)),char,*(char))->(int)
(	O
&	O
getv	array(*(char))
[	O
1	int
]	O
,	O
TRUE	int
,	O
"get:rcixt -s -k -p"	*(char)
)	O
;	O
childwait	(int,*(int),int)->(void)
(	O
pid	int
,	O
&	O
st	int
,	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
close	*((*(void))->(int))
(	O
pipev	array(int)
[	O
1	int
]	O
)	O
<	O
0	int
||	O
close	*((*(void))->(int))
(	O
0	int
)	O
<	O
0	int
||	O
dup	(int)->(int)
(	O
pipev	array(int)
[	O
0	int
]	O
)	O
!=	O
0	int
||	O
close	*((*(void))->(int))
(	O
pipev	array(int)
[	O
0	int
]	O
)	O
<	O
0	int
)	O
{	O
syserr	(*(char))->(void)
(	O
"dodiff: failed to set up the 'diff' end of the pipe"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
command	(array(*(char)),char,*(char))->(int)
(	O
&	O
getv	array(*(char))
[	O
1	int
]	O
,	O
FALSE	int
,	O
"-diff:elsfhbCunaBdHpqsvwyD"	*(char)
)	O
;	O
}	O
return	O
rval	*(int)
;	O
}	O
const	O
char	O
*	O
tail	(*(char))->(*(char))
(	O
register	O
const	O
char	O
*	O
fn	*(char)
)	O
{	O
register	O
const	O
char	O
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
fn	*(char)
;	O
*	O
p	*(char)
!=	O
0	int
;	O
p	*(char)
++	O
)	O
if	O
(	O
*	O
p	*(char)
==	O
'/'	O
&&	O
p	*(char)
[	O
1	int
]	O
!=	O
'\0'	O
&&	O
p	*(char)
[	O
1	int
]	O
!=	O
'/'	O
)	O
fn	*(char)
=	O
&	O
p	*(char)
[	O
1	int
]	O
;	O
return	O
fn	*(char)
;	O
}	O
char	O
*	O
tail_nc	(*(char))->(*(char))
(	O
register	O
char	O
*	O
fn	*(char)
)	O
{	O
register	O
char	O
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
fn	*(char)
;	O
*	O
p	*(char)
!=	O
0	int
;	O
p	*(char)
++	O
)	O
if	O
(	O
*	O
p	*(char)
==	O
'/'	O
&&	O
p	*(char)
[	O
1	int
]	O
!=	O
'\0'	O
&&	O
p	*(char)
[	O
1	int
]	O
!=	O
'/'	O
)	O
fn	*(char)
=	O
&	O
p	*(char)
[	O
1	int
]	O
;	O
return	O
fn	*(char)
;	O
}	O
const	O
struct	O
pfile	struct(*(char),*(char),*(char),*(char),*(char),*(char))
*	O
getpfent	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(*(char),*(char),*(char),*(char),*(char),*(char))))
(	O
FILE	struct
*	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
static	O
struct	O
pfile	struct(*(char),*(char),*(char),*(char),*(char),*(char))
ent	struct(*(char),*(char),*(char),*(char),*(char),*(char))
;	O
static	O
char	O
buf	array(char)
[	O
PFILELG	int
]	O
;	O
register	O
char	O
*	O
p	*(char)
;	O
if	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	array(char)
,	O
sizeof	O
buf	array(char)
,	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
ent	struct(*(char),*(char),*(char),*(char),*(char),*(char))
.	O
p_osid	*(char)
=	O
p	*(char)
=	O
buf	array(char)
;	O
ent	struct(*(char),*(char),*(char),*(char),*(char),*(char))
.	O
p_nsid	*(char)
=	O
p	*(char)
=	O
nextfield	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
ent	struct(*(char),*(char),*(char),*(char),*(char),*(char))
.	O
p_user	*(char)
=	O
p	*(char)
=	O
nextfield	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
ent	struct(*(char),*(char),*(char),*(char),*(char),*(char))
.	O
p_date	*(char)
=	O
p	*(char)
=	O
nextfield	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
ent	struct(*(char),*(char),*(char),*(char),*(char),*(char))
.	O
p_time	*(char)
=	O
p	*(char)
=	O
nextfield	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
ent	struct(*(char),*(char),*(char),*(char),*(char),*(char))
.	O
p_aux	*(char)
=	O
p	*(char)
=	O
nextfield	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
return	O
&	O
ent	struct(*(char),*(char),*(char),*(char),*(char),*(char))
;	O
}	O
char	O
*	O
nextfield	(*(char))->(*(char))
(	O
register	O
char	O
*	O
p	*(char)
)	O
{	O
if	O
(	O
p	*(char)
==	O
NULL	O
||	O
*	O
p	*(char)
==	O
'\0'	O
)	O
return	O
NULL	O
;	O
while	O
(	O
*	O
p	*(char)
!=	O
' '	O
&&	O
*	O
p	*(char)
!=	O
'\n'	O
&&	O
*	O
p	*(char)
!=	O
'\0'	O
)	O
p	*(char)
++	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
'\n'	O
||	O
*	O
p	*(char)
==	O
'\0'	O
)	O
{	O
*	O
p	*(char)
=	O
'\0'	O
;	O
return	O
NULL	O
;	O
}	O
*	O
p	*(char)
++	O
=	O
'\0'	O
;	O
return	O
p	*(char)
;	O
}	O
void	O
putpfent	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
register	O
const	O
struct	O
pfile	struct(*(char),*(char),*(char),*(char),*(char),*(char))
*	O
pf	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
,	O
register	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s %s %s %s %s"	*(char)
,	O
pf	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
p_osid	*(char)
,	O
pf	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
p_nsid	*(char)
,	O
pf	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
p_user	*(char)
,	O
pf	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
p_date	*(char)
,	O
pf	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
p_time	*(char)
)	O
;	O
if	O
(	O
pf	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
p_aux	*(char)
!=	O
NULL	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %s"	*(char)
,	O
pf	*(struct(*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
p_aux	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
void	O
usrerr	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	*(*(char))
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n%s: "	*(char)
,	O
program_name	*(char)
)	O
;	O
va_start	O
(	O
ap	*(*(char))
,	O
fmt	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	*(*(char))
)	O
;	O
va_end	O
(	O
ap	*(*(char))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
void	O
syserr	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
extern	O
int	O
errno	O
;	O
va_list	array(struct(int,int,*(void),*(void)))
ap	*(*(char))
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n%s SYSERR: "	*(char)
,	O
program_name	*(char)
)	O
;	O
va_start	O
(	O
ap	*(*(char))
,	O
fmt	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	*(*(char))
)	O
;	O
va_end	O
(	O
ap	*(*(char))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
if	O
(	O
errno	O
==	O
0	int
)	O
{	O
exit	(int)->(void)
(	O
CSSC_EX_SOFTWARE	int
)	O
;	O
}	O
else	O
{	O
perror	(*(char))->(void)
(	O
NULL	O
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
}	O
const	O
char	O
*	O
username	()->(*(char))
(	O
void	O
)	O
{	O
const	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwuid	(int)->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
getuid	()->(int)
(	O
)	O
)	O
;	O
if	O
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
==	O
NULL	O
)	O
{	O
syserr	(*(char))->(void)
(	O
"Who are you?\n"	*(char)
"You don't seem to have an entry in the user database "	*(char)
"(/etc/passwd) (uid=%d)"	*(char)
,	O
(	O
int	O
)	O
getuid	()->(int)
(	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
return	O
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_name	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
gstrcat	(*(char),*(char),long)->(*(char))
(	O
char	O
*	O
to	*(char)
,	O
const	O
char	O
*	O
from	*(char)
,	O
size_t	long
length	long
)	O
{	O
if	O
(	O
strlen	(*(char))->(long)
(	O
from	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
to	*(char)
)	O
>=	O
length	long
)	O
{	O
gstrbotch	(*(char),*(char))->(void)
(	O
to	*(char)
,	O
from	*(char)
)	O
;	O
}	O
return	O
(	O
strcat	(*(char),*(char))->(*(char))
(	O
to	*(char)
,	O
from	*(char)
)	O
)	O
;	O
}	O
static	O
char	O
*	O
gstrncat	(*(char),*(char),long,long)->(*(char))
(	O
char	O
*	O
to	*(char)
,	O
const	O
char	O
*	O
from	*(char)
,	O
size_t	long
n	long
,	O
size_t	long
length	long
)	O
{	O
if	O
(	O
n	long
+	O
strlen	(*(char))->(long)
(	O
to	*(char)
)	O
>=	O
length	long
)	O
{	O
gstrbotch	(*(char),*(char))->(void)
(	O
to	*(char)
,	O
from	*(char)
)	O
;	O
}	O
return	O
strncat	(*(char),*(char),long)->(*(char))
(	O
to	*(char)
,	O
from	*(char)
,	O
n	long
)	O
;	O
}	O
static	O
char	O
*	O
gstrcpy	(*(char),*(char),long)->(*(char))
(	O
char	O
*	O
to	*(char)
,	O
const	O
char	O
*	O
from	*(char)
,	O
size_t	long
length	long
)	O
{	O
if	O
(	O
strlen	(*(char))->(long)
(	O
from	*(char)
)	O
>=	O
length	long
)	O
{	O
gstrbotch	(*(char),*(char))->(void)
(	O
from	*(char)
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
return	O
strcpy	(*(char),*(char))->(*(char))
(	O
to	*(char)
,	O
from	*(char)
)	O
;	O
}	O
static	O
void	O
gstrbotch	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
str1	*(char)
,	O
const	O
char	O
*	O
str2	*(char)
)	O
{	O
usrerr	(*(char))->(void)
(	O
"Filename(s) too long: %s %s"	*(char)
,	O
(	O
str1	*(char)
?	O
str1	*(char)
:	O
""	*(char)
)	O
,	O
(	O
str2	*(char)
?	O
str2	*(char)
:	O
""	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_SOFTWARE	int
)	O
;	O
}	O
static	O
void	O
gstrbotchn	(int,*(char),int,*(char),int)->(void)
(	O
int	O
navail	int
,	O
const	O
char	O
*	O
str1	*(char)
,	O
int	O
len1	int
,	O
const	O
char	O
*	O
str2	*(char)
,	O
int	O
len2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Filename%s too long: "	*(char)
,	O
(	O
str1	*(char)
&&	O
str2	*(char)
)	O
?	O
"s"	*(char)
:	O
""	*(char)
)	O
;	O
if	O
(	O
str1	*(char)
)	O
{	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
str1	*(char)
,	O
len1	int
,	O
1	int
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
str2	*(char)
)	O
{	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
str2	*(char)
,	O
len2	int
,	O
1	int
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Only %d characters available.\n"	*(char)
,	O
navail	int
)	O
;	O
exit	(int)->(void)
(	O
CSSC_EX_SOFTWARE	int
)	O
;	O
}	O
