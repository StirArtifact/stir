object	O
imag_unit	int
,	O
minus_imag_unit	O
,	O
imag_two	O
;	O
int	O
fixnum_expt	(int,int)->(int)
(	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
int	O
z	int
;	O
z	int
=	O
1	int
;	O
while	O
(	O
y	int
>	O
0	int
)	O
if	O
(	O
y	int
%	O
2	int
==	O
0	int
)	O
{	O
x	int
*=	O
x	int
;	O
y	int
/=	O
2	int
;	O
}	O
else	O
{	O
z	int
*=	O
x	int
;	O
--	O
y	int
;	O
}	O
return	O
(	O
z	int
)	O
;	O
}	O
static	O
object	O
number_sin	()->(int)
(	O
object	O
)	O
;	O
static	O
object	O
number_cos	()->(int)
(	O
object	O
)	O
;	O
static	O
object	O
number_exp	()->(int)
(	O
object	O
)	O
;	O
static	O
object	O
number_nlog	()->(int)
(	O
object	O
)	O
;	O
static	O
object	O
number_atan2	()->(int)
(	O
object	O
,	O
object	O
)	O
;	O
static	O
object	O
number_exp	()->(int)
(	O
object	O
x	int
)	O
{	O
double	O
exp	(double)->(double)
(	O
double	O
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
return	O
(	O
make_longfloat	()->(int)
(	O
(	O
longfloat	O
)	O
exp	(double)->(double)
(	O
number_to_double	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
;	O
case	O
t_shortfloat	O
:	O
return	O
(	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
exp	(double)->(double)
(	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
)	O
;	O
case	O
t_longfloat	O
:	O
return	O
(	O
make_longfloat	()->(int)
(	O
exp	(double)->(double)
(	O
lf	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
;	O
case	O
t_complex	O
:	O
{	O
object	O
y	int
,	O
y1	O
;	O
vs_mark	O
;	O
y	int
=	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
;	O
x	int
=	O
x	int
->	O
cmp	O
.	O
cmp_real	O
;	O
x	int
=	O
number_exp	()->(int)
(	O
x	int
)	O
;	O
vs_push	()->(int)
(	O
x	int
)	O
;	O
y1	O
=	O
number_cos	()->(int)
(	O
y	int
)	O
;	O
vs_push	()->(int)
(	O
y1	O
)	O
;	O
y	int
=	O
number_sin	()->(int)
(	O
y	int
)	O
;	O
vs_push	()->(int)
(	O
y	int
)	O
;	O
y	int
=	O
make_complex	()->(int)
(	O
y1	O
,	O
y	int
)	O
;	O
vs_push	()->(int)
(	O
y	int
)	O
;	O
x	int
=	O
number_times	()->(int)
(	O
x	int
,	O
y	int
)	O
;	O
vs_reset	O
;	O
return	O
(	O
x	int
)	O
;	O
}	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
inline	O
object	O
number_fix_iexpt	(int,int,int,int)->(int)
(	O
object	O
x	int
,	O
fixnum	O
y	int
,	O
fixnum	O
ly	int
,	O
fixnum	O
j	int
)	O
{	O
object	O
z	int
;	O
if	O
(	O
j	int
+	O
1	int
==	O
ly	int
)	O
return	O
x	int
;	O
z	int
=	O
number_fix_iexpt	(int,int,int,int)->(int)
(	O
number_times	()->(int)
(	O
x	int
,	O
x	int
)	O
,	O
y	int
,	O
ly	int
,	O
j	int
+	O
1	int
)	O
;	O
return	O
fixnum_bitp	()->(int)
(	O
j	int
,	O
y	int
)	O
?	O
number_times	()->(int)
(	O
x	int
,	O
z	int
)	O
:	O
z	int
;	O
}	O
inline	O
object	O
number_big_iexpt	(int,int,int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
,	O
fixnum	O
ly	int
,	O
fixnum	O
j	int
)	O
{	O
object	O
z	int
;	O
if	O
(	O
j	int
+	O
1	int
==	O
ly	int
)	O
return	O
x	int
;	O
z	int
=	O
number_big_iexpt	(int,int,int,int)->(int)
(	O
number_times	()->(int)
(	O
x	int
,	O
x	int
)	O
,	O
y	int
,	O
ly	int
,	O
j	int
+	O
1	int
)	O
;	O
return	O
mpz_tstbit	()->(int)
(	O
MP	()->(int)
(	O
y	int
)	O
,	O
j	int
)	O
?	O
number_times	()->(int)
(	O
x	int
,	O
z	int
)	O
:	O
z	int
;	O
}	O
inline	O
object	O
number_zero_expt	(int,int)->(int)
(	O
object	O
x	int
,	O
bool	O
promote_short_p	int
)	O
{	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
return	O
make_fixnum	()->(int)
(	O
1	int
)	O
;	O
case	O
t_shortfloat	O
:	O
return	O
promote_short_p	int
?	O
make_longfloat	()->(int)
(	O
1.0	int
)	O
:	O
make_shortfloat	()->(int)
(	O
1.0	int
)	O
;	O
case	O
t_longfloat	O
:	O
return	O
make_longfloat	()->(int)
(	O
1.0	int
)	O
;	O
case	O
t_complex	O
:	O
return	O
make_complex	()->(int)
(	O
number_zero_expt	(int,int)->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
,	O
promote_short_p	int
)	O
,	O
small_fixnum	()->(int)
(	O
0	int
)	O
)	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
Cnil	O
;	O
}	O
}	O
inline	O
object	O
number_ui_expt	(int,int)->(int)
(	O
object	O
x	int
,	O
fixnum	O
fy	int
)	O
{	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
{	O
fixnum	O
fx	O
=	O
fix	()->(int)
(	O
x	int
)	O
;	O
object	O
z	int
;	O
MPOP	()->(int)
(	O
z	int
=	O
,	O
mpz_ui_pow_ui	O
,	O
labs	O
(	O
fx	O
)	O
,	O
fy	int
)	O
;	O
if	O
(	O
fx	O
<	O
0	int
&&	O
(	O
fy	int
&	O
0x1	int
)	O
)	O
return	O
number_negate	()->(int)
(	O
z	int
)	O
;	O
else	O
return	O
z	int
;	O
}	O
case	O
t_bignum	O
:	O
MPOP	()->(int)
(	O
return	O
,	O
mpz_pow_ui	O
,	O
MP	()->(int)
(	O
x	int
)	O
,	O
fy	int
)	O
;	O
case	O
t_ratio	O
:	O
{	O
object	O
n	O
=	O
number_ui_expt	(int,int)->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
,	O
fy	int
)	O
,	O
d	double
=	O
number_ui_expt	(int,int)->(int)
(	O
x	int
->	O
rat	O
.	O
rat_den	O
,	O
fy	int
)	O
,	O
z	int
=	O
alloc_object	O
(	O
t_ratio	O
)	O
;	O
z	int
->	O
rat	O
.	O
rat_num	O
=	O
n	O
;	O
z	int
->	O
rat	O
.	O
rat_den	O
=	O
d	double
;	O
return	O
z	int
;	O
}	O
case	O
t_shortfloat	O
:	O
case	O
t_longfloat	O
:	O
case	O
t_complex	O
:	O
{	O
fixnum	O
ly	int
=	O
fixnum_length	O
(	O
fy	int
)	O
;	O
return	O
ly	int
?	O
number_fix_iexpt	(int,int,int,int)->(int)
(	O
x	int
,	O
fy	int
,	O
ly	int
,	O
0	int
)	O
:	O
number_zero_expt	(int,int)->(int)
(	O
x	int
,	O
0	int
)	O
;	O
}	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
Cnil	O
;	O
}	O
}	O
inline	O
object	O
number_ump_expt	(int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
return	O
number_big_iexpt	(int,int,int,int)->(int)
(	O
x	int
,	O
y	int
,	O
fix	()->(int)
(	O
integer_length	()->(int)
(	O
y	int
)	O
)	O
,	O
0	int
)	O
;	O
}	O
inline	O
object	O
number_log_expt	(int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
return	O
number_zerop	()->(int)
(	O
y	int
)	O
?	O
number_zero_expt	(int,int)->(int)
(	O
y	int
,	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_longfloat	O
)	O
:	O
number_exp	()->(int)
(	O
number_times	()->(int)
(	O
number_nlog	()->(int)
(	O
x	int
)	O
,	O
y	int
)	O
)	O
;	O
}	O
inline	O
object	O
number_invert	(int,int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
,	O
object	O
z	int
)	O
{	O
switch	O
(	O
type_of	()->(int)
(	O
z	int
)	O
)	O
{	O
case	O
t_shortfloat	O
:	O
if	O
(	O
!	O
ISNORMAL	O
(	O
sf	()->(int)
(	O
z	int
)	O
)	O
)	O
return	O
number_log_expt	(int,int)->(int)
(	O
x	int
,	O
y	int
)	O
;	O
break	O
;	O
case	O
t_longfloat	O
:	O
if	O
(	O
!	O
ISNORMAL	O
(	O
lf	()->(int)
(	O
z	int
)	O
)	O
)	O
return	O
number_log_expt	(int,int)->(int)
(	O
x	int
,	O
y	int
)	O
;	O
break	O
;	O
}	O
return	O
number_divide	()->(int)
(	O
small_fixnum	()->(int)
(	O
1	int
)	O
,	O
z	int
)	O
;	O
}	O
inline	O
object	O
number_si_expt	(int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
{	O
fixnum	O
fy	int
=	O
fix	()->(int)
(	O
y	int
)	O
;	O
if	O
(	O
fy	int
>=	O
0	int
)	O
return	O
number_ui_expt	(int,int)->(int)
(	O
x	int
,	O
fy	int
)	O
;	O
if	O
(	O
fy	int
==	O
MOST_NEGATIVE_FIX	O
)	O
return	O
number_invert	(int,int,int)->(int)
(	O
x	int
,	O
y	int
,	O
number_ump_expt	(int,int)->(int)
(	O
x	int
,	O
number_negate	()->(int)
(	O
y	int
)	O
)	O
)	O
;	O
return	O
number_invert	(int,int,int)->(int)
(	O
x	int
,	O
y	int
,	O
number_ui_expt	(int,int)->(int)
(	O
x	int
,	O
-	O
fy	int
)	O
)	O
;	O
}	O
case	O
t_bignum	O
:	O
return	O
big_sign	()->(int)
(	O
y	int
)	O
<	O
0	int
?	O
number_invert	(int,int,int)->(int)
(	O
x	int
,	O
y	int
,	O
number_ump_expt	(int,int)->(int)
(	O
x	int
,	O
number_negate	()->(int)
(	O
y	int
)	O
)	O
)	O
:	O
number_ump_expt	(int,int)->(int)
(	O
x	int
,	O
y	int
)	O
;	O
case	O
t_ratio	O
:	O
case	O
t_shortfloat	O
:	O
case	O
t_longfloat	O
:	O
case	O
t_complex	O
:	O
return	O
number_log_expt	(int,int)->(int)
(	O
x	int
,	O
y	int
)	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
y	int
)	O
;	O
return	O
Cnil	O
;	O
}	O
}	O
object	O
number_expt	(int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
if	O
(	O
number_zerop	()->(int)
(	O
x	int
)	O
&&	O
y	int
!=	O
small_fixnum	()->(int)
(	O
0	int
)	O
)	O
{	O
if	O
(	O
!	O
number_plusp	()->(int)
(	O
type_of	()->(int)
(	O
y	int
)	O
==	O
t_complex	O
?	O
y	int
->	O
cmp	O
.	O
cmp_real	O
:	O
y	int
)	O
)	O
FEerror	()->(int)
(	O
"Cannot raise zero to the power ~S."	*(char)
,	O
1	int
,	O
y	int
)	O
;	O
return	O
(	O
number_times	()->(int)
(	O
x	int
,	O
y	int
)	O
)	O
;	O
}	O
return	O
number_si_expt	(int,int)->(int)
(	O
x	int
,	O
y	int
)	O
;	O
}	O
static	O
object	O
number_nlog	()->(int)
(	O
object	O
x	int
)	O
{	O
double	O
log	(double)->(double)
(	O
double	O
)	O
;	O
object	O
r	O
=	O
Cnil	O
,	O
i	O
=	O
Cnil	O
,	O
a	O
,	O
p	O
;	O
vs_mark	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_complex	O
)	O
{	O
r	O
=	O
x	int
->	O
cmp	O
.	O
cmp_real	O
;	O
i	O
=	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
;	O
goto	O
COMPLEX	O
;	O
}	O
if	O
(	O
number_zerop	()->(int)
(	O
x	int
)	O
)	O
FEerror	()->(int)
(	O
"Zero is the logarithmic singularity."	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
number_minusp	()->(int)
(	O
x	int
)	O
)	O
{	O
r	O
=	O
x	int
;	O
i	O
=	O
small_fixnum	()->(int)
(	O
0	int
)	O
;	O
goto	O
COMPLEX	O
;	O
}	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
return	O
(	O
make_longfloat	()->(int)
(	O
log	(double)->(double)
(	O
number_to_double	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
;	O
case	O
t_shortfloat	O
:	O
return	O
(	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
log	(double)->(double)
(	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
)	O
;	O
case	O
t_longfloat	O
:	O
return	O
(	O
make_longfloat	()->(int)
(	O
log	(double)->(double)
(	O
lf	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
}	O
COMPLEX	O
:	O
a	O
=	O
number_times	()->(int)
(	O
r	O
,	O
r	O
)	O
;	O
vs_push	()->(int)
(	O
a	O
)	O
;	O
p	O
=	O
number_times	()->(int)
(	O
i	O
,	O
i	O
)	O
;	O
vs_push	()->(int)
(	O
p	O
)	O
;	O
a	O
=	O
number_plus	()->(int)
(	O
a	O
,	O
p	O
)	O
;	O
vs_push	()->(int)
(	O
a	O
)	O
;	O
a	O
=	O
number_nlog	()->(int)
(	O
a	O
)	O
;	O
vs_push	()->(int)
(	O
a	O
)	O
;	O
a	O
=	O
number_divide	()->(int)
(	O
a	O
,	O
small_fixnum	()->(int)
(	O
2	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
a	O
)	O
;	O
p	O
=	O
number_atan2	()->(int)
(	O
i	O
,	O
r	O
)	O
;	O
vs_push	()->(int)
(	O
p	O
)	O
;	O
x	int
=	O
make_complex	()->(int)
(	O
a	O
,	O
p	O
)	O
;	O
vs_reset	O
;	O
return	O
(	O
x	int
)	O
;	O
}	O
static	O
object	O
number_log	(int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
object	O
z	int
;	O
vs_mark	O
;	O
if	O
(	O
number_zerop	()->(int)
(	O
y	int
)	O
)	O
FEerror	()->(int)
(	O
"Zero is the logarithmic singularity."	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
number_zerop	()->(int)
(	O
x	int
)	O
)	O
return	O
(	O
number_times	()->(int)
(	O
x	int
,	O
y	int
)	O
)	O
;	O
x	int
=	O
number_nlog	()->(int)
(	O
x	int
)	O
;	O
vs_push	()->(int)
(	O
x	int
)	O
;	O
y	int
=	O
number_nlog	()->(int)
(	O
y	int
)	O
;	O
vs_push	()->(int)
(	O
y	int
)	O
;	O
z	int
=	O
number_divide	()->(int)
(	O
y	int
,	O
x	int
)	O
;	O
vs_reset	O
;	O
return	O
(	O
z	int
)	O
;	O
}	O
static	O
object	O
number_sqrt	(int)->(int)
(	O
object	O
x	int
)	O
{	O
object	O
z	int
;	O
double	O
sqrt	(double)->(double)
(	O
double	O
)	O
;	O
vs_mark	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_complex	O
)	O
goto	O
COMPLEX	O
;	O
if	O
(	O
number_minusp	()->(int)
(	O
x	int
)	O
)	O
goto	O
COMPLEX	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
return	O
(	O
make_longfloat	()->(int)
(	O
(	O
longfloat	O
)	O
sqrt	(double)->(double)
(	O
number_to_double	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
;	O
case	O
t_shortfloat	O
:	O
return	O
(	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
sqrt	(double)->(double)
(	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
)	O
;	O
case	O
t_longfloat	O
:	O
return	O
(	O
make_longfloat	()->(int)
(	O
sqrt	(double)->(double)
(	O
lf	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
}	O
COMPLEX	O
:	O
z	int
=	O
make_ratio	()->(int)
(	O
small_fixnum	()->(int)
(	O
1	int
)	O
,	O
small_fixnum	()->(int)
(	O
2	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
z	int
)	O
;	O
z	int
=	O
number_expt	(int,int)->(int)
(	O
x	int
,	O
z	int
)	O
;	O
vs_reset	O
;	O
return	O
(	O
z	int
)	O
;	O
}	O
object	O
number_abs	(int)->(int)
(	O
object	O
x	int
)	O
{	O
object	O
r	O
,	O
i	O
,	O
z	int
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_complex	O
:	O
if	O
(	O
number_zerop	()->(int)
(	O
x	int
)	O
)	O
return	O
x	int
->	O
cmp	O
.	O
cmp_real	O
;	O
r	O
=	O
number_abs	(int)->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
)	O
;	O
i	O
=	O
number_abs	(int)->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
;	O
if	O
(	O
number_compare	()->(int)
(	O
r	O
,	O
i	O
)	O
<	O
0	int
)	O
{	O
object	O
z	int
=	O
i	O
;	O
i	O
=	O
r	O
;	O
r	O
=	O
z	int
;	O
}	O
z	int
=	O
number_divide	()->(int)
(	O
i	O
,	O
r	O
)	O
;	O
return	O
number_times	()->(int)
(	O
r	O
,	O
number_sqrt	(int)->(int)
(	O
one_plus	()->(int)
(	O
number_times	()->(int)
(	O
z	int
,	O
z	int
)	O
)	O
)	O
)	O
;	O
case	O
t_fixnum	O
:	O
{	O
fixnum	O
fx	O
=	O
fix	()->(int)
(	O
x	int
)	O
;	O
return	O
fx	O
==	O
MOST_NEGATIVE_FIX	O
?	O
fixnum_add	()->(int)
(	O
1	int
,	O
MOST_POSITIVE_FIX	O
)	O
:	O
(	O
fx	O
<	O
0	int
?	O
make_fixnum	()->(int)
(	O
-	O
fx	O
)	O
:	O
x	int
)	O
;	O
}	O
case	O
t_bignum	O
:	O
return	O
big_sign	()->(int)
(	O
x	int
)	O
<	O
0	int
?	O
big_minus	()->(int)
(	O
x	int
)	O
:	O
x	int
;	O
case	O
t_ratio	O
:	O
{	O
object	O
n	O
=	O
number_abs	(int)->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
)	O
;	O
return	O
n	O
==	O
x	int
?	O
x	int
:	O
make_ratio	()->(int)
(	O
n	O
,	O
x	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
}	O
case	O
t_shortfloat	O
:	O
return	O
sf	()->(int)
(	O
x	int
)	O
<	O
0.0	int
?	O
make_shortfloat	()->(int)
(	O
-	O
sf	()->(int)
(	O
x	int
)	O
)	O
:	O
x	int
;	O
case	O
t_longfloat	O
:	O
return	O
lf	()->(int)
(	O
x	int
)	O
<	O
0.0	int
?	O
make_longfloat	()->(int)
(	O
-	O
lf	()->(int)
(	O
x	int
)	O
)	O
:	O
x	int
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
object	O
number_signum	(int)->(int)
(	O
object	O
x	int
)	O
{	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
{	O
fixnum	O
fx	O
=	O
fix	()->(int)
(	O
x	int
)	O
;	O
return	O
make_fixnum	()->(int)
(	O
fx	O
<	O
0	int
?	O
-	O
1	int
:	O
(	O
fx	O
==	O
0	int
?	O
0	int
:	O
1	int
)	O
)	O
;	O
}	O
case	O
t_bignum	O
:	O
return	O
make_fixnum	()->(int)
(	O
big_sign	()->(int)
(	O
x	int
)	O
<	O
0	int
?	O
-	O
1	int
:	O
1	int
)	O
;	O
case	O
t_ratio	O
:	O
return	O
number_signum	(int)->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
)	O
;	O
case	O
t_shortfloat	O
:	O
return	O
make_shortfloat	()->(int)
(	O
sf	()->(int)
(	O
x	int
)	O
<	O
0.0	int
?	O
-	O
1.0	int
:	O
(	O
sf	()->(int)
(	O
x	int
)	O
==	O
0.0	int
?	O
0.0	int
:	O
1.0	int
)	O
)	O
;	O
case	O
t_longfloat	O
:	O
return	O
make_longfloat	()->(int)
(	O
lf	()->(int)
(	O
x	int
)	O
<	O
0.0	int
?	O
-	O
1.0	int
:	O
(	O
lf	()->(int)
(	O
x	int
)	O
==	O
0.0	int
?	O
0.0	int
:	O
1.0	int
)	O
)	O
;	O
case	O
t_complex	O
:	O
return	O
number_zerop	()->(int)
(	O
x	int
)	O
?	O
x	int
:	O
number_divide	()->(int)
(	O
x	int
,	O
number_abs	(int)->(int)
(	O
x	int
)	O
)	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
static	O
object	O
number_atan2	()->(int)
(	O
object	O
y	int
,	O
object	O
x	int
)	O
{	O
object	O
z	int
;	O
double	O
atan	(double)->(double)
(	O
double	O
)	O
,	O
dy	double
,	O
dx	double
,	O
dz	double
=	O
0.0	int
;	O
dy	double
=	O
number_to_double	()->(int)
(	O
y	int
)	O
;	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
if	O
(	O
dx	double
>	O
0.0	int
)	O
if	O
(	O
dy	double
>	O
0.0	int
)	O
dz	double
=	O
atan	(double)->(double)
(	O
dy	double
/	O
dx	double
)	O
;	O
else	O
if	O
(	O
dy	double
==	O
0.0	int
)	O
dz	double
=	O
0.0	int
;	O
else	O
dz	double
=	O
-	O
atan	(double)->(double)
(	O
-	O
dy	double
/	O
dx	double
)	O
;	O
else	O
if	O
(	O
dx	double
==	O
0.0	int
)	O
if	O
(	O
dy	double
>	O
0.0	int
)	O
dz	double
=	O
PI	O
/	O
2.0	int
;	O
else	O
if	O
(	O
dy	double
==	O
0.0	int
)	O
FEerror	()->(int)
(	O
"Logarithmic singularity."	*(char)
,	O
0	int
)	O
;	O
else	O
dz	double
=	O
-	O
PI	O
/	O
2.0	int
;	O
else	O
if	O
(	O
dy	double
>	O
0.0	int
)	O
dz	double
=	O
PI	O
-	O
atan	(double)->(double)
(	O
dy	double
/	O
-	O
dx	double
)	O
;	O
else	O
if	O
(	O
dy	double
==	O
0.0	int
)	O
dz	double
=	O
PI	O
;	O
else	O
dz	double
=	O
-	O
PI	O
+	O
atan	(double)->(double)
(	O
-	O
dy	double
/	O
-	O
dx	double
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_shortfloat	O
)	O
z	int
=	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
dz	double
)	O
;	O
else	O
z	int
=	O
make_longfloat	()->(int)
(	O
dz	double
)	O
;	O
return	O
(	O
z	int
)	O
;	O
}	O
static	O
object	O
number_atan	(int)->(int)
(	O
object	O
y	int
)	O
{	O
object	O
z	int
,	O
z1	O
;	O
vs_mark	O
;	O
if	O
(	O
type_of	()->(int)
(	O
y	int
)	O
==	O
t_complex	O
)	O
{	O
z	int
=	O
number_times	()->(int)
(	O
imag_unit	int
,	O
y	int
)	O
;	O
vs_push	()->(int)
(	O
z	int
)	O
;	O
z	int
=	O
one_plus	()->(int)
(	O
z	int
)	O
;	O
vs_push	()->(int)
(	O
z	int
)	O
;	O
z1	O
=	O
number_times	()->(int)
(	O
y	int
,	O
y	int
)	O
;	O
vs_push	()->(int)
(	O
z1	O
)	O
;	O
z1	O
=	O
one_plus	()->(int)
(	O
z1	O
)	O
;	O
vs_push	()->(int)
(	O
z1	O
)	O
;	O
z1	O
=	O
number_sqrt	(int)->(int)
(	O
z1	O
)	O
;	O
vs_push	()->(int)
(	O
z1	O
)	O
;	O
z	int
=	O
number_divide	()->(int)
(	O
z	int
,	O
z1	O
)	O
;	O
vs_push	()->(int)
(	O
z	int
)	O
;	O
z	int
=	O
number_nlog	()->(int)
(	O
z	int
)	O
;	O
vs_push	()->(int)
(	O
z	int
)	O
;	O
z	int
=	O
number_times	()->(int)
(	O
minus_imag_unit	O
,	O
z	int
)	O
;	O
vs_reset	O
;	O
return	O
(	O
z	int
)	O
;	O
}	O
return	O
(	O
number_atan2	()->(int)
(	O
y	int
,	O
small_fixnum	()->(int)
(	O
1	int
)	O
)	O
)	O
;	O
}	O
static	O
object	O
number_sin	()->(int)
(	O
object	O
x	int
)	O
{	O
double	O
sin	(double)->(double)
(	O
double	O
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
return	O
(	O
make_longfloat	()->(int)
(	O
(	O
longfloat	O
)	O
sin	(double)->(double)
(	O
number_to_double	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
;	O
case	O
t_shortfloat	O
:	O
return	O
(	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
sin	(double)->(double)
(	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
)	O
;	O
case	O
t_longfloat	O
:	O
return	O
(	O
make_longfloat	()->(int)
(	O
sin	(double)->(double)
(	O
lf	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
;	O
case	O
t_complex	O
:	O
{	O
object	O
r	O
;	O
object	O
x0	O
,	O
x1	O
,	O
x2	O
;	O
vs_mark	O
;	O
x0	O
=	O
number_times	()->(int)
(	O
imag_unit	int
,	O
x	int
)	O
;	O
vs_push	()->(int)
(	O
x0	O
)	O
;	O
x0	O
=	O
number_exp	()->(int)
(	O
x0	O
)	O
;	O
vs_push	()->(int)
(	O
x0	O
)	O
;	O
x1	O
=	O
number_times	()->(int)
(	O
minus_imag_unit	O
,	O
x	int
)	O
;	O
vs_push	()->(int)
(	O
x1	O
)	O
;	O
x1	O
=	O
number_exp	()->(int)
(	O
x1	O
)	O
;	O
vs_push	()->(int)
(	O
x1	O
)	O
;	O
x2	O
=	O
number_minus	()->(int)
(	O
x0	O
,	O
x1	O
)	O
;	O
vs_push	()->(int)
(	O
x2	O
)	O
;	O
r	O
=	O
number_divide	()->(int)
(	O
x2	O
,	O
imag_two	O
)	O
;	O
vs_reset	O
;	O
return	O
(	O
r	O
)	O
;	O
}	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
static	O
object	O
number_cos	()->(int)
(	O
object	O
x	int
)	O
{	O
double	O
cos	(double)->(double)
(	O
double	O
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
return	O
(	O
make_longfloat	()->(int)
(	O
(	O
longfloat	O
)	O
cos	(double)->(double)
(	O
number_to_double	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
;	O
case	O
t_shortfloat	O
:	O
return	O
(	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
cos	(double)->(double)
(	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
)	O
;	O
case	O
t_longfloat	O
:	O
return	O
(	O
make_longfloat	()->(int)
(	O
cos	(double)->(double)
(	O
lf	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
;	O
case	O
t_complex	O
:	O
{	O
object	O
r	O
;	O
object	O
x0	O
,	O
x1	O
,	O
x2	O
;	O
vs_mark	O
;	O
x0	O
=	O
number_times	()->(int)
(	O
imag_unit	int
,	O
x	int
)	O
;	O
vs_push	()->(int)
(	O
x0	O
)	O
;	O
x0	O
=	O
number_exp	()->(int)
(	O
x0	O
)	O
;	O
vs_push	()->(int)
(	O
x0	O
)	O
;	O
x1	O
=	O
number_times	()->(int)
(	O
minus_imag_unit	O
,	O
x	int
)	O
;	O
vs_push	()->(int)
(	O
x1	O
)	O
;	O
x1	O
=	O
number_exp	()->(int)
(	O
x1	O
)	O
;	O
vs_push	()->(int)
(	O
x1	O
)	O
;	O
x2	O
=	O
number_plus	()->(int)
(	O
x0	O
,	O
x1	O
)	O
;	O
vs_push	()->(int)
(	O
x2	O
)	O
;	O
r	O
=	O
number_divide	()->(int)
(	O
x2	O
,	O
small_fixnum	()->(int)
(	O
2	int
)	O
)	O
;	O
vs_reset	O
;	O
return	O
(	O
r	O
)	O
;	O
}	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
static	O
object	O
number_tan1	(int)->(int)
(	O
object	O
x	int
)	O
{	O
double	O
cos	(double)->(double)
(	O
double	O
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
return	O
(	O
make_longfloat	()->(int)
(	O
(	O
longfloat	O
)	O
tan	O
(	O
number_to_double	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
;	O
case	O
t_shortfloat	O
:	O
return	O
(	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
tan	O
(	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
)	O
;	O
case	O
t_longfloat	O
:	O
return	O
(	O
make_longfloat	()->(int)
(	O
tan	O
(	O
lf	()->(int)
(	O
x	int
)	O
)	O
)	O
)	O
;	O
case	O
t_complex	O
:	O
{	O
object	O
r	O
;	O
object	O
x0	O
,	O
x1	O
,	O
x2	O
;	O
vs_mark	O
;	O
x0	O
=	O
number_times	()->(int)
(	O
imag_two	O
,	O
x	int
)	O
;	O
vs_push	()->(int)
(	O
x0	O
)	O
;	O
x0	O
=	O
number_exp	()->(int)
(	O
x0	O
)	O
;	O
vs_push	()->(int)
(	O
x0	O
)	O
;	O
x1	O
=	O
number_minus	()->(int)
(	O
x0	O
,	O
small_fixnum	()->(int)
(	O
1	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
x1	O
)	O
;	O
x2	O
=	O
number_plus	()->(int)
(	O
x0	O
,	O
small_fixnum	()->(int)
(	O
1	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
x2	O
)	O
;	O
x2	O
=	O
number_times	()->(int)
(	O
x2	O
,	O
imag_unit	int
)	O
;	O
vs_push	()->(int)
(	O
x2	O
)	O
;	O
r	O
=	O
number_divide	()->(int)
(	O
x1	O
,	O
x2	O
)	O
;	O
vs_reset	O
;	O
return	O
(	O
r	O
)	O
;	O
}	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
static	O
object	O
number_tan	(int)->(int)
(	O
object	O
x	int
)	O
{	O
object	O
r	O
,	O
c	O
;	O
vs_mark	O
;	O
c	O
=	O
number_cos	()->(int)
(	O
x	int
)	O
;	O
vs_push	()->(int)
(	O
c	O
)	O
;	O
if	O
(	O
number_zerop	()->(int)
(	O
c	O
)	O
==	O
TRUE	O
)	O
FEerror	()->(int)
(	O
"Cannot compute the tangent of ~S."	*(char)
,	O
1	int
,	O
x	int
)	O
;	O
r	O
=	O
number_tan1	(int)->(int)
(	O
x	int
)	O
;	O
vs_reset	O
;	O
return	O
(	O
r	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lexp	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
number_exp	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lexpt	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
2	int
)	O
;	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
number_expt	(int,int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
,	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
vs_popp	O
;	O
}	O
LFD	(int)->(int)
(	O
Llog	int
)	O
(	O
void	O
)	O
{	O
int	O
narg	int
;	O
narg	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
narg	int
<	O
1	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
else	O
if	O
(	O
narg	int
==	O
1	int
)	O
{	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
number_nlog	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
narg	int
==	O
2	int
)	O
{	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
number_log	(int,int)->(int)
(	O
vs_base	O
[	O
1	int
]	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_popp	O
;	O
}	O
else	O
too_many_arguments	()->(int)
(	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lsqrt	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
number_sqrt	(int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lsin	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
number_sin	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lcos	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
number_cos	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Ltan	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
number_tan	(int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Latan	int
)	O
(	O
void	O
)	O
{	O
int	O
narg	int
;	O
narg	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
narg	int
<	O
1	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
if	O
(	O
narg	int
==	O
1	int
)	O
{	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
number_atan	(int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
narg	int
==	O
2	int
)	O
{	O
check_type_or_rational_float	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
check_type_or_rational_float	()->(int)
(	O
&	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
number_atan2	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
,	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
vs_popp	O
;	O
}	O
else	O
too_many_arguments	()->(int)
(	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
siLmodf	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
;	O
double	O
d	double
,	O
ip	double
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_float	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_base	O
=	O
vs_top	O
;	O
d	double
=	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_longfloat	O
?	O
lf	()->(int)
(	O
x	int
)	O
:	O
(	O
double	O
)	O
sf	()->(int)
(	O
x	int
)	O
;	O
d	double
=	O
modf	O
(	O
d	double
,	O
&	O
ip	double
)	O
;	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
(	O
int	O
)	O
ip	double
)	O
)	O
;	O
vs_push	()->(int)
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_longfloat	O
?	O
make_longfloat	()->(int)
(	O
d	double
)	O
:	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
d	double
)	O
)	O
;	O
}	O
void	O
gcl_init_num_sfun	()->(void)
(	O
void	O
)	O
{	O
imag_unit	int
=	O
make_complex	()->(int)
(	O
make_longfloat	()->(int)
(	O
(	O
longfloat	O
)	O
0.0	int
)	O
,	O
make_longfloat	()->(int)
(	O
(	O
longfloat	O
)	O
1.0	int
)	O
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
imag_unit	int
)	O
;	O
minus_imag_unit	O
=	O
make_complex	()->(int)
(	O
make_longfloat	()->(int)
(	O
(	O
longfloat	O
)	O
0.0	int
)	O
,	O
make_longfloat	()->(int)
(	O
(	O
longfloat	O
)	O
-	O
1.0	int
)	O
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
minus_imag_unit	O
)	O
;	O
imag_two	O
=	O
make_complex	()->(int)
(	O
make_longfloat	()->(int)
(	O
(	O
longfloat	O
)	O
0.0	int
)	O
,	O
make_longfloat	()->(int)
(	O
(	O
longfloat	O
)	O
2.0	int
)	O
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
imag_two	O
)	O
;	O
make_constant	()->(int)
(	O
"PI"	*(char)
,	O
make_longfloat	()->(int)
(	O
PI	O
)	O
)	O
;	O
make_function	()->(int)
(	O
"EXP"	*(char)
,	O
Lexp	int
)	O
;	O
make_function	()->(int)
(	O
"EXPT"	*(char)
,	O
Lexpt	int
)	O
;	O
make_function	()->(int)
(	O
"LOG"	*(char)
,	O
Llog	int
)	O
;	O
make_function	()->(int)
(	O
"SQRT"	*(char)
,	O
Lsqrt	int
)	O
;	O
make_function	()->(int)
(	O
"SIN"	*(char)
,	O
Lsin	int
)	O
;	O
make_function	()->(int)
(	O
"COS"	*(char)
,	O
Lcos	int
)	O
;	O
make_function	()->(int)
(	O
"TAN"	*(char)
,	O
Ltan	int
)	O
;	O
make_function	()->(int)
(	O
"ATAN"	*(char)
,	O
Latan	int
)	O
;	O
make_si_function	()->(int)
(	O
"MODF"	*(char)
,	O
siLmodf	int
)	O
;	O
}	O
