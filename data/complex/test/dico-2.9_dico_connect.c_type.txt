const	O
char	O
*	O
xscript_prefix	array(*(char))
[	O
]	O
=	O
{	O
"S:"	*(char)
,	O
"C:"	*(char)
}	O
;	O
static	O
int	O
parse_initial_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
struct	O
dict_connection	struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))))
*	O
conn	*(struct)
)	O
{	O
char	O
*	O
p	*(void)
;	O
size_t	long
n	long
=	O
0	int
;	O
size_t	long
len	long
;	O
if	O
(	O
!	O
dict_status_p	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char))->(int)
(	O
conn	*(struct)
,	O
"220"	*(char)
)	O
)	O
return	O
1	int
;	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
conn	*(struct)
->	O
buf	*(void)
,	O
'<'	O
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
return	O
1	int
;	O
p	*(void)
++	O
;	O
while	O
(	O
(	O
len	long
=	O
strcspn	(*(char),*(char))->(long)
(	O
p	*(void)
,	O
".>"	*(char)
)	O
)	O
)	O
{	O
char	O
*	O
s	long
;	O
if	O
(	O
conn	*(struct)
->	O
capac	int
==	O
n	long
)	O
{	O
if	O
(	O
n	long
==	O
0	int
)	O
n	long
=	O
2	int
;	O
conn	*(struct)
->	O
capav	*(*(char))
=	O
x2nrealloc	(*(void),*(long),long)->(*(void))
(	O
conn	*(struct)
->	O
capav	*(*(char))
,	O
&	O
n	long
,	O
sizeof	O
(	O
conn	*(struct)
->	O
capav	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
}	O
s	long
=	O
xmalloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
s	long
,	O
p	*(void)
,	O
len	long
)	O
;	O
s	long
[	O
len	long
]	O
=	O
0	int
;	O
conn	*(struct)
->	O
capav	*(*(char))
[	O
conn	*(struct)
->	O
capac	int
++	O
]	O
=	O
s	long
;	O
p	*(void)
+=	O
len	long
+	O
1	int
;	O
if	O
(	O
p	*(void)
[	O
-	O
1	int
]	O
==	O
'>'	O
)	O
break	O
;	O
}	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
'<'	O
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
return	O
1	int
;	O
len	long
=	O
strcspn	(*(char),*(char))->(long)
(	O
p	*(void)
,	O
">"	*(char)
)	O
;	O
if	O
(	O
p	*(void)
[	O
len	long
]	O
!=	O
'>'	O
)	O
return	O
1	int
;	O
len	long
++	O
;	O
conn	*(struct)
->	O
msgid	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
conn	*(struct)
->	O
msgid	*(char)
,	O
p	*(void)
,	O
len	long
)	O
;	O
conn	*(struct)
->	O
msgid	*(char)
[	O
len	long
]	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
apop_auth	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))))->(int)
(	O
struct	O
dict_connection	struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))))
*	O
conn	*(struct)
,	O
struct	O
auth_cred	struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))
*	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
)	O
{	O
int	O
i	long
;	O
struct	O
md5_ctx	struct(int,int,int,int,array(int),int,array(int))
md5context	struct(int,int,int,int,array(int),int,array(int))
;	O
unsigned	O
char	O
md5digest	array(char)
[	O
16	int
]	O
;	O
char	O
buf	*(void)
[	O
sizeof	O
(	O
md5digest	array(char)
)	O
*	O
2	int
+	O
1	int
]	O
;	O
char	O
*	O
p	*(void)
;	O
md5_init_ctx	(*(struct(int,int,int,int,array(int),int,array(int))))->(void)
(	O
&	O
md5context	struct(int,int,int,int,array(int),int,array(int))
)	O
;	O
md5_process_bytes	(*(void),long,*(struct(int,int,int,int,array(int),int,array(int))))->(void)
(	O
conn	*(struct)
->	O
msgid	*(char)
,	O
strlen	(*(char))->(long)
(	O
conn	*(struct)
->	O
msgid	*(char)
)	O
,	O
&	O
md5context	struct(int,int,int,int,array(int),int,array(int))
)	O
;	O
md5_process_bytes	(*(void),long,*(struct(int,int,int,int,array(int),int,array(int))))->(void)
(	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
pass	*(char)
,	O
strlen	(*(char))->(long)
(	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
pass	*(char)
)	O
,	O
&	O
md5context	struct(int,int,int,int,array(int),int,array(int))
)	O
;	O
md5_finish_ctx	(*(struct(int,int,int,int,array(int),int,array(int))),*(void))->(*(void))
(	O
&	O
md5context	struct(int,int,int,int,array(int),int,array(int))
,	O
md5digest	array(char)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
,	O
p	*(void)
=	O
buf	*(void)
;	O
i	long
<	O
16	int
;	O
i	long
++	O
,	O
p	*(void)
+=	O
2	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"%02x"	*(char)
,	O
md5digest	array(char)
[	O
i	long
]	O
)	O
;	O
*	O
p	*(void)
=	O
0	int
;	O
stream_printf	(*(struct),*(char))->(int)
(	O
conn	*(struct)
->	O
str	*(char)
,	O
"AUTH %s %s\r\n"	*(char)
,	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
user	*(char)
,	O
buf	*(void)
)	O
;	O
if	O
(	O
dict_read_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"No reply from server"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
dict_status_p	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char))->(int)
(	O
conn	*(struct)
,	O
"230"	*(char)
)	O
==	O
0	int
;	O
}	O
static	O
int	O
dict_auth	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))))->(int)
(	O
struct	O
dict_connection	struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))))
*	O
conn	*(struct)
,	O
dico_url_t	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
)	O
{	O
int	O
rc	int
=	O
saslauth	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))))->(int)
(	O
conn	*(struct)
,	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
AUTH_OK	int
:	O
return	O
0	int
;	O
case	O
AUTH_CONT	int
:	O
if	O
(	O
dict_capa	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char))->(int)
(	O
conn	*(struct)
,	O
"auth"	*(char)
)	O
)	O
{	O
struct	O
auth_cred	struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
;	O
switch	O
(	O
auth_cred_get	(*(char),*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))))->(int)
(	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
host	*(char)
,	O
&	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
)	O
)	O
{	O
case	O
GETCRED_OK	int
:	O
XDICO_DEBUG	O
(	O
1	int
,	O
_	O
(	O
"Attempting APOP authentication\n"	*(char)
)	O
)	O
;	O
rc	int
=	O
apop_auth	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))))->(int)
(	O
conn	*(struct)
,	O
&	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
)	O
;	O
auth_cred_free	(*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))))->(void)
(	O
&	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
)	O
;	O
return	O
rc	int
;	O
case	O
GETCRED_FAIL	int
:	O
dico_log	(int,int,*(char))->(void)
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"Not enough credentials for authentication"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
GETCRED_NOAUTH	int
:	O
XDICO_DEBUG	O
(	O
1	int
,	O
_	O
(	O
"Skipping authentication\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
}	O
return	O
0	int
;	O
case	O
AUTH_FAIL	int
:	O
break	O
;	O
}	O
return	O
1	int
;	O
}	O
char	O
*	O
get_homedir	()->(*(char))
(	O
void	O
)	O
{	O
char	O
*	O
homedir	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
;	O
if	O
(	O
!	O
homedir	*(char)
)	O
{	O
struct	O
passwd	*(char)
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwuid	(int)->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
geteuid	()->(int)
(	O
)	O
)	O
;	O
homedir	*(char)
=	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_dir	*(char)
;	O
}	O
return	O
homedir	*(char)
;	O
}	O
int	O
ds_tilde_expand	(*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
str	*(char)
,	O
char	O
*	O
*	O
output	*(*(char))
)	O
{	O
char	O
*	O
dir	*(char)
;	O
if	O
(	O
str	*(char)
[	O
0	int
]	O
!=	O
'~'	O
)	O
return	O
0	int
;	O
if	O
(	O
str	*(char)
[	O
1	int
]	O
==	O
'/'	O
)	O
{	O
dir	*(char)
=	O
get_homedir	()->(*(char))
(	O
)	O
;	O
str	*(char)
+=	O
2	int
;	O
}	O
else	O
{	O
char	O
*	O
p	*(void)
;	O
size_t	long
len	long
;	O
char	O
*	O
name	*(char)
;	O
struct	O
passwd	*(char)
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
str	*(char)
++	O
;	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
str	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
return	O
0	int
;	O
len	long
=	O
p	*(void)
-	O
str	*(char)
;	O
name	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
name	*(char)
,	O
str	*(char)
,	O
len	long
)	O
;	O
name	*(char)
[	O
len	long
]	O
=	O
0	int
;	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
if	O
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
)	O
{	O
dir	*(char)
=	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_dir	*(char)
;	O
str	*(char)
=	O
p	*(void)
+	O
1	int
;	O
}	O
}	O
*	O
output	*(*(char))
=	O
dico_full_file_name	(*(char),*(char))->(*(char))
(	O
dir	*(char)
,	O
str	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
auth_cred_dup	(*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))),*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))))->(void)
(	O
struct	O
auth_cred	struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))
*	O
dst	*(char)
,	O
const	O
struct	O
auth_cred	struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))
*	O
src	*(char)
)	O
{	O
dst	*(char)
->	O
user	*(char)
=	O
src	*(char)
->	O
user	*(char)
?	O
xstrdup	(*(char))->(*(char))
(	O
src	*(char)
->	O
user	*(char)
)	O
:	O
NULL	O
;	O
dst	*(char)
->	O
pass	*(char)
=	O
src	*(char)
->	O
pass	*(char)
?	O
xstrdup	(*(char))->(*(char))
(	O
src	*(char)
->	O
pass	*(char)
)	O
:	O
NULL	O
;	O
}	O
void	O
auth_cred_free	(*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))))->(void)
(	O
struct	O
auth_cred	struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))
*	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
)	O
{	O
free	(*(void))->(void)
(	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
user	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
pass	*(char)
)	O
;	O
dico_list_destroy	(*(*(struct)))->(void)
(	O
&	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
mech	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
service	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
realm	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
hostname	*(char)
)	O
;	O
}	O
int	O
auth_cred_get	(*(char),*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))))->(int)
(	O
char	O
*	O
host	*(char)
,	O
struct	O
auth_cred	struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))
*	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
,	O
0	int
,	O
sizeof	O
(	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
[	O
0	int
]	O
)	O
)	O
;	O
auth_cred_dup	(*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))),*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))))->(void)
(	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
,	O
&	O
default_cred	struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))
)	O
;	O
if	O
(	O
default_cred	struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))
.	O
user	*(char)
&&	O
default_cred	struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))
.	O
pass	*(char)
)	O
{	O
XDICO_DEBUG	O
(	O
1	int
,	O
_	O
(	O
"Obtained authentication credentials from the command line\n"	*(char)
)	O
)	O
;	O
return	O
GETCRED_OK	int
;	O
}	O
else	O
{	O
int	O
flags	int
=	O
0	int
;	O
if	O
(	O
autologin_file	*(char)
)	O
{	O
if	O
(	O
access	(*(char),int)->(int)
(	O
autologin_file	*(char)
,	O
F_OK	int
)	O
)	O
dico_log	(int,int,*(char))->(void)
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"File %s does not exist"	*(char)
)	O
,	O
autologin_file	*(char)
)	O
;	O
else	O
parse_autologin	(*(char),*(char),*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))),*(int))->(int)
(	O
autologin_file	*(char)
,	O
host	*(char)
,	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
,	O
&	O
flags	int
)	O
;	O
}	O
if	O
(	O
!	O
flags	int
&&	O
DEFAULT_AUTOLOGIN_FILE	*(char)
)	O
{	O
char	O
*	O
home	*(char)
=	O
get_homedir	()->(*(char))
(	O
)	O
;	O
char	O
*	O
filename	*(char)
=	O
dico_full_file_name	(*(char),*(char))->(*(char))
(	O
home	*(char)
,	O
DEFAULT_AUTOLOGIN_FILE	*(char)
)	O
;	O
parse_autologin	(*(char),*(char),*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))),*(int))->(int)
(	O
filename	*(char)
,	O
host	*(char)
,	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
,	O
&	O
flags	int
)	O
;	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
}	O
if	O
(	O
flags	int
&	O
AUTOLOGIN_NOAUTH	int
)	O
return	O
GETCRED_NOAUTH	int
;	O
}	O
if	O
(	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
user	*(char)
&&	O
!	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
pass	*(char)
)	O
{	O
char	O
*	O
p	*(void)
=	O
getpass	(*(char))->(*(char))
(	O
_	O
(	O
"Password:"	*(char)
)	O
)	O
;	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
pass	*(char)
=	O
p	*(void)
?	O
xstrdup	(*(char))->(*(char))
(	O
p	*(void)
)	O
:	O
NULL	O
;	O
}	O
return	O
(	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
user	*(char)
&&	O
cred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
pass	*(char)
)	O
?	O
GETCRED_OK	int
:	O
GETCRED_FAIL	int
;	O
}	O
void	O
dict_transcript	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),int)->(void)
(	O
struct	O
dict_connection	struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))))
*	O
conn	*(struct)
,	O
int	O
state	*(int)
)	O
{	O
if	O
(	O
state	*(int)
==	O
conn	*(struct)
->	O
transcript	int
)	O
return	O
;	O
if	O
(	O
state	*(int)
==	O
0	int
)	O
{	O
dico_stream_t	*(struct)
transport	*(struct)
;	O
if	O
(	O
dico_stream_ioctl	(*(struct),int,*(void))->(int)
(	O
conn	*(struct)
->	O
str	*(char)
,	O
DICO_IOCTL_GET_TRANSPORT	int
,	O
&	O
transport	*(struct)
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_CRIT	int
,	O
errno	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: cannot get stream transport"	*(char)
)	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
dico_stream_ioctl	(*(struct),int,*(void))->(int)
(	O
conn	*(struct)
->	O
str	*(char)
,	O
DICO_IOCTL_SET_TRANSPORT	int
,	O
NULL	O
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_CRIT	int
,	O
errno	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: cannot set stream transport"	*(char)
)	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
return	O
;	O
}	O
dico_stream_close	(*(struct))->(int)
(	O
conn	*(struct)
->	O
str	*(char)
)	O
;	O
dico_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
conn	*(struct)
->	O
str	*(char)
)	O
;	O
conn	*(struct)
->	O
str	*(char)
=	O
transport	*(struct)
;	O
conn	*(struct)
->	O
transcript	int
=	O
state	*(int)
;	O
}	O
else	O
{	O
dico_stream_t	*(struct)
logstr	*(struct)
=	O
dico_log_stream_create	(int)->(*(struct))
(	O
L_DEBUG	int
)	O
;	O
if	O
(	O
!	O
logstr	*(struct)
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
conn	*(struct)
->	O
str	*(char)
=	O
xdico_transcript_stream_create	(*(struct),*(struct),array(*(char)))->(*(struct))
(	O
conn	*(struct)
->	O
str	*(char)
,	O
logstr	*(struct)
,	O
xscript_prefix	array(*(char))
)	O
;	O
conn	*(struct)
->	O
transcript	int
=	O
state	*(int)
;	O
}	O
}	O
static	O
char	O
const	O
*	O
urlstr	*(char)
(	O
dico_url_t	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
)	O
{	O
if	O
(	O
!	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
string	*(*(char))
)	O
{	O
if	O
(	O
!	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
proto	*(char)
)	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
proto	*(char)
,	O
"dict"	*(char)
)	O
;	O
if	O
(	O
!	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
port	*(char)
)	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
port	*(char)
,	O
DICO_DICT_PORT_STR	*(char)
)	O
;	O
if	O
(	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
host	*(char)
)	O
{	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
string	*(*(char))
,	O
"%s://%s:%s"	*(char)
,	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
proto	*(char)
,	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
host	*(char)
,	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
port	*(char)
)	O
;	O
}	O
else	O
{	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
string	*(*(char))
,	O
"%s:///%s"	*(char)
,	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
proto	*(char)
,	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
path	*(char)
)	O
;	O
}	O
}	O
return	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
string	*(*(char))
;	O
}	O
int	O
dict_connect	(*(*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))))->(int)
(	O
struct	O
dict_connection	struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))))
*	O
*	O
pconn	*(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))
,	O
dico_url_t	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
)	O
{	O
int	O
fd	int
,	O
rc	int
,	O
family	int
;	O
struct	O
addrinfo	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`))))))
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
*	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
,	O
*	O
rp	*(struct)
;	O
dico_stream_t	*(struct)
str	*(char)
;	O
struct	O
dict_connection	struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))))
*	O
conn	*(struct)
;	O
char	O
const	O
*	O
port	*(char)
=	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
port	*(char)
?	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
port	*(char)
:	O
DICO_DICT_PORT_STR	*(char)
;	O
XDICO_DEBUG_F1	O
(	O
1	int
,	O
_	O
(	O
"Connecting to %s\n"	*(char)
)	O
,	O
urlstr	*(char)
(	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
)	O
)	O
;	O
if	O
(	O
source_addr	*(char)
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
0	int
,	O
sizeof	O
(	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
)	O
)	O
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_socktype	int
=	O
SOCK_STREAM	int
;	O
rc	int
=	O
getaddrinfo	(*(char),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))),*(*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))->(int)
(	O
source_addr	*(char)
,	O
NULL	O
,	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
&	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"bad source address: %s"	*(char)
)	O
,	O
gai_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
rp	*(struct)
=	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
;	O
rp	*(struct)
;	O
rp	*(struct)
=	O
rp	*(struct)
->	O
ai_next	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
{	O
fd	int
=	O
socket	(int,int,int)->(int)
(	O
rp	*(struct)
->	O
ai_family	int
,	O
rp	*(struct)
->	O
ai_socktype	int
,	O
rp	*(struct)
->	O
ai_protocol	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
continue	O
;	O
if	O
(	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
fd	int
,	O
rp	*(struct)
->	O
ai_addr	*(struct(short,array(char)))
,	O
rp	*(struct)
->	O
ai_addrlen	int
)	O
==	O
0	int
)	O
break	O
;	O
close	(int)->(int)
(	O
fd	int
)	O
;	O
}	O
if	O
(	O
!	O
rp	*(struct)
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"can't bind to the source address"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
fd	int
=	O
-	O
1	int
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
0	int
,	O
sizeof	O
(	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
)	O
)	O
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_socktype	int
=	O
SOCK_STREAM	int
;	O
if	O
(	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
host	*(char)
)	O
{	O
rc	int
=	O
getaddrinfo	(*(char),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))),*(*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))->(int)
(	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
host	*(char)
,	O
port	*(char)
,	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
&	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: can't get address: %s"	*(char)
)	O
,	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
host	*(char)
,	O
gai_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
struct	O
sockaddr_un	struct(short,array(char))
*	O
s	long
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
path	*(char)
)	O
>=	O
sizeof	O
s	long
->	O
sun_path	array(char)
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: UNIX socket name too long"	*(char)
)	O
,	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
path	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_family	int
=	O
AF_UNIX	O
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_addrlen	int
=	O
sizeof	O
(	O
struct	O
sockaddr_un	struct(short,array(char))
)	O
;	O
s	long
=	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_addrlen	int
)	O
;	O
s	long
->	O
sun_family	short
=	O
AF_UNIX	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
s	long
->	O
sun_path	array(char)
,	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
path	*(char)
)	O
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_addr	*(struct(short,array(char)))
=	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
s	long
;	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
=	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
;	O
}	O
for	O
(	O
rp	*(struct)
=	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
;	O
rp	*(struct)
;	O
rp	*(struct)
=	O
rp	*(struct)
->	O
ai_next	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
{	O
if	O
(	O
fd	int
!=	O
-	O
1	int
&&	O
family	int
!=	O
rp	*(struct)
->	O
ai_family	int
)	O
{	O
close	(int)->(int)
(	O
fd	int
)	O
;	O
fd	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
family	int
=	O
rp	*(struct)
->	O
ai_family	int
;	O
fd	int
=	O
socket	(int,int,int)->(int)
(	O
family	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"cannot create dict socket"	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
connect	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
fd	int
,	O
rp	*(struct)
->	O
ai_addr	*(struct(short,array(char)))
,	O
rp	*(struct)
->	O
ai_addrlen	int
)	O
!=	O
-	O
1	int
)	O
break	O
;	O
}	O
if	O
(	O
!	O
rp	*(struct)
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: cannot connect"	*(char)
)	O
,	O
urlstr	*(char)
(	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
==	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
)	O
free	(*(void))->(void)
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
ai_addr	*(struct(short,array(char)))
)	O
;	O
else	O
freeaddrinfo	(*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
;	O
if	O
(	O
(	O
str	*(char)
=	O
dico_fd_io_stream_create	(int,int)->(*(struct))
(	O
fd	int
,	O
fd	int
)	O
)	O
==	O
NULL	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"cannot create dict stream: %s"	*(char)
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
conn	*(struct)
=	O
xzalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
conn	*(struct)
)	O
)	O
;	O
conn	*(struct)
->	O
str	*(char)
=	O
str	*(char)
;	O
conn	*(struct)
->	O
fd	int
=	O
fd	int
;	O
dict_transcript	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),int)->(void)
(	O
conn	*(struct)
,	O
transcript	int
)	O
;	O
if	O
(	O
dict_read_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"No reply from server"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
parse_initial_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"Invalid reply from server"	*(char)
)	O
)	O
;	O
dict_conn_close	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(void)
(	O
conn	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
XDICO_DEBUG	O
(	O
1	int
,	O
_	O
(	O
"Sending client information\n"	*(char)
)	O
)	O
;	O
stream_printf	(*(struct),*(char))->(int)
(	O
conn	*(struct)
->	O
str	*(char)
,	O
"CLIENT \"%s\"\r\n"	*(char)
,	O
client	*(char)
)	O
;	O
dict_read_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
;	O
if	O
(	O
!	O
dict_status_p	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char))->(int)
(	O
conn	*(struct)
,	O
"250"	*(char)
)	O
)	O
dico_log	(int,int,*(char))->(void)
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"Unexpected reply to CLIENT command: `%s'"	*(char)
)	O
,	O
conn	*(struct)
->	O
buf	*(void)
)	O
;	O
obstack_init	O
(	O
&	O
conn	*(struct)
->	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
)	O
;	O
if	O
(	O
!	O
noauth_option	int
&&	O
dict_auth	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))))->(int)
(	O
conn	*(struct)
,	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"Authentication failed"	*(char)
)	O
)	O
;	O
dict_conn_close	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(void)
(	O
conn	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
*	O
pconn	*(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))
=	O
conn	*(struct)
;	O
return	O
0	int
;	O
}	O
int	O
dict_read_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
struct	O
dict_connection	struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))))
*	O
conn	*(struct)
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
conn	*(struct)
->	O
buf	*(void)
)	O
conn	*(struct)
->	O
buf	*(void)
[	O
0	int
]	O
=	O
0	int
;	O
rc	int
=	O
dico_stream_getline	(*(struct),*(*(char)),*(long),*(long))->(int)
(	O
conn	*(struct)
->	O
str	*(char)
,	O
&	O
conn	*(struct)
->	O
buf	*(void)
,	O
&	O
conn	*(struct)
->	O
size	long
,	O
&	O
conn	*(struct)
->	O
level	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
conn	*(struct)
->	O
level	int
=	O
dico_trim_nl	(*(char))->(long)
(	O
conn	*(struct)
->	O
buf	*(void)
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
dict_status_p	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char))->(int)
(	O
struct	O
dict_connection	struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))))
*	O
conn	*(struct)
,	O
const	O
char	O
*	O
status	int
)	O
{	O
return	O
conn	*(struct)
->	O
level	int
>	O
3	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
conn	*(struct)
->	O
buf	*(void)
,	O
status	int
,	O
3	int
)	O
==	O
0	int
&&	O
(	O
isspace	(int)->(int)
(	O
conn	*(struct)
->	O
buf	*(void)
[	O
3	int
]	O
)	O
||	O
(	O
conn	*(struct)
->	O
level	int
==	O
5	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
conn	*(struct)
->	O
buf	*(void)
+	O
3	int
,	O
"\r\n"	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
)	O
;	O
}	O
int	O
dict_capa	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char))->(int)
(	O
struct	O
dict_connection	struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))))
*	O
conn	*(struct)
,	O
char	O
*	O
capa	*(char)
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
conn	*(struct)
->	O
capac	int
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
conn	*(struct)
->	O
capav	*(*(char))
[	O
i	long
]	O
,	O
capa	*(char)
)	O
==	O
0	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
dict_multiline_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
struct	O
dict_connection	struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))))
*	O
conn	*(struct)
)	O
{	O
int	O
rc	int
;	O
size_t	long
nlines	long
=	O
0	int
;	O
while	O
(	O
(	O
rc	int
=	O
dict_read_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
)	O
==	O
0	int
)	O
{	O
char	O
*	O
ptr	*(void)
=	O
conn	*(struct)
->	O
buf	*(void)
;	O
size_t	long
len	long
=	O
conn	*(struct)
->	O
level	int
;	O
if	O
(	O
*	O
ptr	*(void)
==	O
'.'	O
)	O
{	O
if	O
(	O
ptr	*(void)
[	O
1	int
]	O
==	O
0	int
)	O
break	O
;	O
else	O
if	O
(	O
ptr	*(void)
[	O
1	int
]	O
==	O
'.'	O
)	O
{	O
ptr	*(void)
++	O
;	O
len	long
--	O
;	O
}	O
}	O
obstack_grow	O
(	O
&	O
conn	*(struct)
->	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
ptr	*(void)
,	O
len	long
)	O
;	O
obstack_1grow	O
(	O
&	O
conn	*(struct)
->	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
'\n'	O
)	O
;	O
nlines	long
++	O
;	O
}	O
obstack_1grow	O
(	O
&	O
conn	*(struct)
->	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
0	int
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
dict_define	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char),*(char))->(int)
(	O
struct	O
dict_connection	struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))))
*	O
conn	*(struct)
,	O
char	O
*	O
database	*(char)
,	O
char	O
*	O
word	*(char)
)	O
{	O
int	O
rc	int
;	O
XDICO_DEBUG_F2	O
(	O
1	int
,	O
_	O
(	O
"Sending query for word \"%s\" in database \"%s\"\n"	*(char)
)	O
,	O
word	*(char)
,	O
database	*(char)
)	O
;	O
stream_printf	(*(struct),*(char))->(int)
(	O
conn	*(struct)
->	O
str	*(char)
,	O
"DEFINE \"%s\" \"%s\"\r\n"	*(char)
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
0	int
,	O
database	*(char)
)	O
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
1	int
,	O
word	*(char)
)	O
)	O
;	O
dict_read_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
;	O
if	O
(	O
dict_status_p	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char))->(int)
(	O
conn	*(struct)
,	O
"150"	*(char)
)	O
)	O
{	O
unsigned	O
long	O
i	long
,	O
count	long
;	O
char	O
*	O
p	*(void)
;	O
count	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
conn	*(struct)
->	O
buf	*(void)
+	O
3	int
,	O
&	O
p	*(void)
,	O
10	int
)	O
;	O
XDICO_DEBUG_F1	O
(	O
1	int
,	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"Reading %lu definition\n"	*(char)
,	O
"Reading %lu definitions\n"	*(char)
,	O
count	long
)	O
,	O
count	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
count	long
;	O
i	long
++	O
)	O
{	O
dict_read_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
;	O
if	O
(	O
!	O
dict_status_p	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char))->(int)
(	O
conn	*(struct)
,	O
"151"	*(char)
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"Unexpected reply in place of definition %lu"	*(char)
)	O
,	O
i	long
)	O
;	O
break	O
;	O
}	O
obstack_grow	O
(	O
&	O
conn	*(struct)
->	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
conn	*(struct)
->	O
buf	*(void)
,	O
conn	*(struct)
->	O
level	int
)	O
;	O
obstack_1grow	O
(	O
&	O
conn	*(struct)
->	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
0	int
)	O
;	O
dict_multiline_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
;	O
}	O
dict_read_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
;	O
dict_result_create	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),enum(int,int,int),long,*(char))->(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))
(	O
conn	*(struct)
,	O
dict_result_define	int
,	O
count	long
,	O
obstack_finish	O
(	O
&	O
conn	*(struct)
->	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
)	O
)	O
;	O
rc	int
=	O
0	int
;	O
}	O
else	O
rc	int
=	O
1	int
;	O
return	O
rc	int
;	O
}	O
int	O
dict_match	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char),*(char),*(char))->(int)
(	O
struct	O
dict_connection	struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))))
*	O
conn	*(struct)
,	O
char	O
*	O
database	*(char)
,	O
char	O
*	O
strategy	*(char)
,	O
char	O
*	O
word	*(char)
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
levenshtein_threshold	int
&&	O
conn	*(struct)
->	O
levdist	long
!=	O
levenshtein_threshold	int
&&	O
dict_capa	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char))->(int)
(	O
conn	*(struct)
,	O
"xlev"	*(char)
)	O
)	O
{	O
XDICO_DEBUG	O
(	O
1	int
,	O
_	O
(	O
"Setting Levenshtein threshold\n"	*(char)
)	O
)	O
;	O
stream_printf	(*(struct),*(char))->(int)
(	O
conn	*(struct)
->	O
str	*(char)
,	O
"XLEV %u\n"	*(char)
,	O
levenshtein_threshold	int
)	O
;	O
dict_read_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
;	O
if	O
(	O
dict_status_p	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char))->(int)
(	O
conn	*(struct)
,	O
"250"	*(char)
)	O
)	O
conn	*(struct)
->	O
levdist	long
=	O
levenshtein_threshold	int
;	O
else	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"Server rejected XLEV command"	*(char)
)	O
)	O
;	O
dico_log	(int,int,*(char))->(void)
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"Server reply: %s"	*(char)
)	O
,	O
conn	*(struct)
->	O
buf	*(void)
)	O
;	O
}	O
}	O
XDICO_DEBUG_F3	O
(	O
1	int
,	O
_	O
(	O
"Sending query to match word \"%s\" in "	*(char)
"database \"%s\", "	*(char)
"using \"%s\"\n"	*(char)
)	O
,	O
word	*(char)
,	O
database	*(char)
,	O
strategy	*(char)
)	O
;	O
stream_printf	(*(struct),*(char))->(int)
(	O
conn	*(struct)
->	O
str	*(char)
,	O
"MATCH \"%s\" \"%s\" \"%s\"\r\n"	*(char)
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
0	int
,	O
database	*(char)
)	O
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
1	int
,	O
strategy	*(char)
)	O
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
2	int
,	O
word	*(char)
)	O
)	O
;	O
dict_read_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
;	O
if	O
(	O
dict_status_p	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char))->(int)
(	O
conn	*(struct)
,	O
"152"	*(char)
)	O
)	O
{	O
unsigned	O
long	O
count	long
;	O
char	O
*	O
p	*(void)
;	O
count	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
conn	*(struct)
->	O
buf	*(void)
+	O
3	int
,	O
&	O
p	*(void)
,	O
10	int
)	O
;	O
XDICO_DEBUG_F1	O
(	O
1	int
,	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"Reading %lu match\n"	*(char)
,	O
"Reading %lu matches\n"	*(char)
,	O
count	long
)	O
,	O
count	long
)	O
;	O
dict_multiline_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
;	O
dict_result_create	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),enum(int,int,int),long,*(char))->(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))
(	O
conn	*(struct)
,	O
dict_result_match	int
,	O
count	long
,	O
obstack_finish	O
(	O
&	O
conn	*(struct)
->	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
)	O
)	O
;	O
dict_read_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
;	O
rc	int
=	O
0	int
;	O
}	O
else	O
rc	int
=	O
1	int
;	O
return	O
rc	int
;	O
}	O
static	O
size_t	long
count_lines	(*(char))->(long)
(	O
char	O
*	O
p	*(void)
)	O
{	O
size_t	long
count	long
=	O
0	int
;	O
while	O
(	O
(	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
'\n'	O
)	O
)	O
)	O
{	O
count	long
++	O
;	O
p	*(void)
++	O
;	O
}	O
return	O
count	long
;	O
}	O
static	O
void	O
_result_parse_def	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))->(void)
(	O
struct	O
dict_result	struct(*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char)))))
*	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
{	O
char	O
*	O
p	*(void)
;	O
size_t	long
i	long
;	O
struct	O
define_result	struct(*(char),*(char),*(char),*(char),long)
*	O
def	*(struct(*(char),*(char),*(char),*(char),long))
=	O
xcalloc	(long,long)->(*(void))
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
count	long
,	O
sizeof	O
(	O
*	O
def	*(struct(*(char),*(char),*(char),*(char),long))
)	O
)	O
;	O
struct	O
dico_tokbuf	struct(*(char),long,long,*(*(char)),int,int)
tb	*(struct(*(char),long,long,*(*(char)),int,int))
;	O
dico_tokenize_begin	(*(struct(*(char),long,long,*(*(char)),int,int)))->(void)
(	O
&	O
tb	*(struct(*(char),long,long,*(*(char)),int,int))
)	O
;	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
set	union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char))))
.	O
def	*(struct(*(char),*(char),*(char),*(char),long))
=	O
def	*(struct(*(char),*(char),*(char),*(char),long))
;	O
p	*(void)
=	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
base	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
count	long
;	O
i	long
++	O
,	O
def	*(struct(*(char),*(char),*(char),*(char),long))
++	O
)	O
{	O
xdico_tokenize_string	(*(struct(*(char),long,long,*(*(char)),int,int)),*(char))->(void)
(	O
&	O
tb	*(struct(*(char),long,long,*(*(char)),int,int))
,	O
p	*(void)
)	O
;	O
def	*(struct(*(char),*(char),*(char),*(char),long))
->	O
word	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
tb	*(struct(*(char),long,long,*(*(char)),int,int))
.	O
tb_tokv	*(*(char))
[	O
1	int
]	O
)	O
;	O
def	*(struct(*(char),*(char),*(char),*(char),long))
->	O
database	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
tb	*(struct(*(char),long,long,*(*(char)),int,int))
.	O
tb_tokv	*(*(char))
[	O
2	int
]	O
)	O
;	O
def	*(struct(*(char),*(char),*(char),*(char),long))
->	O
descr	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
tb	*(struct(*(char),long,long,*(*(char)),int,int))
.	O
tb_tokv	*(*(char))
[	O
3	int
]	O
)	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
+	O
1	int
;	O
def	*(struct(*(char),*(char),*(char),*(char),long))
->	O
defn	*(char)
=	O
p	*(void)
;	O
def	*(struct(*(char),*(char),*(char),*(char),long))
->	O
nlines	long
=	O
count_lines	(*(char))->(long)
(	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
+	O
1	int
;	O
}	O
dico_tokenize_end	(*(struct(*(char),long,long,*(*(char)),int,int)))->(void)
(	O
&	O
tb	*(struct(*(char),long,long,*(*(char)),int,int))
)	O
;	O
}	O
static	O
void	O
_result_free_def	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))->(void)
(	O
struct	O
dict_result	struct(*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char)))))
*	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
{	O
size_t	long
i	long
;	O
struct	O
define_result	struct(*(char),*(char),*(char),*(char),long)
*	O
def	*(struct(*(char),*(char),*(char),*(char),long))
=	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
set	union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char))))
.	O
def	*(struct(*(char),*(char),*(char),*(char),long))
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
count	long
;	O
i	long
++	O
,	O
def	*(struct(*(char),*(char),*(char),*(char),long))
++	O
)	O
{	O
free	(*(void))->(void)
(	O
def	*(struct(*(char),*(char),*(char),*(char),long))
->	O
word	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
def	*(struct(*(char),*(char),*(char),*(char),long))
->	O
database	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
def	*(struct(*(char),*(char),*(char),*(char),long))
->	O
descr	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
set	union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char))))
.	O
def	*(struct(*(char),*(char),*(char),*(char),long))
)	O
;	O
}	O
static	O
void	O
_result_parse_mat	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))->(void)
(	O
struct	O
dict_result	struct(*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char)))))
*	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
{	O
char	O
*	O
p	*(void)
;	O
size_t	long
i	long
;	O
struct	O
match_result	struct(*(char),*(char))
*	O
mat	*(struct(*(char),*(char)))
=	O
xcalloc	(long,long)->(*(void))
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
count	long
,	O
sizeof	O
(	O
*	O
mat	*(struct(*(char),*(char)))
)	O
)	O
;	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
set	union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char))))
.	O
mat	*(struct(*(char),*(char)))
=	O
mat	*(struct(*(char),*(char)))
;	O
for	O
(	O
i	long
=	O
0	int
,	O
p	*(void)
=	O
strtok	(*(char),*(char))->(*(char))
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
base	int
,	O
"\n"	*(char)
)	O
;	O
i	long
<	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
count	long
;	O
p	*(void)
=	O
strtok	(*(char),*(char))->(*(char))
(	O
NULL	O
,	O
"\n"	*(char)
)	O
,	O
i	long
++	O
,	O
mat	*(struct(*(char),*(char)))
++	O
)	O
{	O
size_t	long
len	long
;	O
if	O
(	O
!	O
p	*(void)
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_NOTICE	int
,	O
0	int
,	O
_	O
(	O
"Not enough data in the result"	*(char)
)	O
)	O
;	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
count	long
=	O
i	long
;	O
break	O
;	O
}	O
mat	*(struct(*(char),*(char)))
->	O
database	*(char)
=	O
p	*(void)
;	O
len	long
=	O
strcspn	(*(char),*(char))->(long)
(	O
p	*(void)
,	O
" \t"	*(char)
)	O
;	O
p	*(void)
[	O
len	long
]	O
=	O
0	int
;	O
p	*(void)
+=	O
len	long
+	O
1	int
;	O
p	*(void)
+=	O
strspn	(*(char),*(char))->(long)
(	O
p	*(void)
,	O
" \t"	*(char)
)	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
;	O
if	O
(	O
p	*(void)
[	O
0	int
]	O
==	O
'"'	O
&&	O
p	*(void)
[	O
len	long
-	O
1	int
]	O
==	O
'"'	O
)	O
{	O
p	*(void)
[	O
len	long
-	O
1	int
]	O
=	O
0	int
;	O
p	*(void)
++	O
;	O
}	O
mat	*(struct(*(char),*(char)))
->	O
word	*(char)
=	O
p	*(void)
;	O
}	O
}	O
static	O
void	O
_result_free_mat	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))->(void)
(	O
struct	O
dict_result	struct(*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char)))))
*	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
{	O
free	(*(void))->(void)
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
set	union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char))))
.	O
mat	*(struct(*(char),*(char)))
)	O
;	O
}	O
struct	O
dict_result	struct(*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char)))))
*	O
dict_result_create	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),enum(int,int,int),long,*(char))->(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))
(	O
struct	O
dict_connection	struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))))
*	O
conn	*(struct)
,	O
enum	O
dict_result_type	enum(int,int,int)
type	enum(int,int,int)
,	O
size_t	long
count	long
,	O
char	O
*	O
base	int
)	O
{	O
struct	O
dict_result	struct(*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char)))))
*	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
)	O
;	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
conn	*(struct)
=	O
conn	*(struct)
;	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
conn	*(struct)
->	O
last_result	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
;	O
conn	*(struct)
->	O
last_result	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
=	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
;	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
type	enum(int,int,int)
=	O
type	enum(int,int,int)
;	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
count	long
=	O
count	long
;	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
base	int
=	O
base	int
;	O
switch	O
(	O
type	enum(int,int,int)
)	O
{	O
case	O
dict_result_define	int
:	O
_result_parse_def	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))->(void)
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
;	O
break	O
;	O
case	O
dict_result_match	int
:	O
_result_parse_mat	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))->(void)
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
;	O
break	O
;	O
case	O
dict_result_text	int
:	O
break	O
;	O
}	O
return	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
;	O
}	O
void	O
dict_result_free	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))->(void)
(	O
struct	O
dict_result	struct(*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char)))))
*	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
{	O
if	O
(	O
!	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
return	O
;	O
if	O
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
==	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
conn	*(struct)
->	O
last_result	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
{	O
obstack_free	O
(	O
&	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
conn	*(struct)
->	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
base	int
)	O
;	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
conn	*(struct)
->	O
last_result	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
=	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
}	O
else	O
{	O
struct	O
dict_result	struct(*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char)))))
*	O
p	*(void)
;	O
for	O
(	O
p	*(void)
=	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
conn	*(struct)
->	O
last_result	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
;	O
p	*(void)
&&	O
p	*(void)
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
!=	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
;	O
p	*(void)
=	O
p	*(void)
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_CRIT	int
,	O
0	int
,	O
_	O
(	O
"Freeing unlinked result"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
p	*(void)
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
}	O
switch	O
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
type	enum(int,int,int)
)	O
{	O
case	O
dict_result_define	int
:	O
_result_free_def	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))->(void)
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
;	O
break	O
;	O
case	O
dict_result_match	int
:	O
_result_free_mat	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))->(void)
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
;	O
break	O
;	O
case	O
dict_result_text	int
:	O
break	O
;	O
}	O
free	(*(void))->(void)
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
;	O
}	O
void	O
dict_conn_close	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(void)
(	O
struct	O
dict_connection	struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))))
*	O
conn	*(struct)
)	O
{	O
struct	O
dict_result	struct(*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char)))))
*	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
;	O
dico_stream_close	(*(struct))->(int)
(	O
conn	*(struct)
->	O
str	*(char)
)	O
;	O
dico_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
conn	*(struct)
->	O
str	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
conn	*(struct)
->	O
msgid	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
conn	*(struct)
->	O
buf	*(void)
)	O
;	O
dico_argcv_free	(int,*(*(char)))->(void)
(	O
conn	*(struct)
->	O
capac	int
,	O
conn	*(struct)
->	O
capav	*(*(char))
)	O
;	O
for	O
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
=	O
conn	*(struct)
->	O
last_result	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
;	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
;	O
)	O
{	O
struct	O
dict_result	struct(*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char)))))
*	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
dict_result_free	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))->(void)
(	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
;	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
=	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
}	O
obstack_free	O
(	O
&	O
conn	*(struct)
->	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
conn	*(struct)
)	O
;	O
}	O
