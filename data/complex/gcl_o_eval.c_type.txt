static	O
void	O
call_applyhook	()->(void)
(	O
object	O
)	O
;	O
struct	O
nil3	struct(array(int))
{	O
object	O
nil3_self	array(int)
[	O
3	int
]	O
;	O
}	O
three_nils	struct(array(int))
;	O
object	O
sSAbreak_pointsA	int
;	O
object	O
sSAbreak_stepA	int
;	O
static	O
void	O
quick_call_sfun	(int)->(void)
(	O
object	O
fun	int
)	O
{	O
DEBUG_AVMA	O
int	O
i	int
=	O
fun	int
->	O
sfn	O
.	O
sfn_argd	O
,	O
n	int
=	O
SFUN_NARGS	()->(int)
(	O
i	int
)	O
;	O
enum	O
ftype	O
restype	enum
;	O
object	O
*	O
x	enum
,	O
res	O
,	O
*	O
base	*(int)
;	O
object	O
*	O
temp_ar	O
=	O
alloca	O
(	O
n	int
*	O
sizeof	O
(	O
object	O
)	O
)	O
;	O
base	*(int)
=	O
vs_base	O
;	O
if	O
(	O
n	int
!=	O
vs_top	O
-	O
base	*(int)
)	O
{	O
check_arg_failed	()->(int)
(	O
n	int
)	O
;	O
}	O
restype	enum
=	O
SFUN_RETURN_TYPE	()->(int)
(	O
i	int
)	O
;	O
SFUN_START_ARG_TYPES	()->(int)
(	O
i	int
)	O
;	O
if	O
(	O
i	int
==	O
0	int
)	O
x	enum
=	O
vs_base	O
;	O
else	O
{	O
int	O
j	int
;	O
x	enum
=	O
temp_ar	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
n	int
;	O
j	int
++	O
)	O
{	O
enum	O
ftype	O
typ	enum
=	O
SFUN_NEXT_TYPE	()->(int)
(	O
i	int
)	O
;	O
x	enum
[	O
j	int
]	O
=	O
COERCE_ARG	O
(	O
vs_base	O
[	O
j	int
]	O
,	O
typ	enum
)	O
;	O
}	O
}	O
res	O
=	O
c_apply_n_fun	()->(int)
(	O
fun	int
,	O
n	int
,	O
x	enum
)	O
;	O
base	*(int)
[	O
0	int
]	O
=	O
(	O
restype	enum
==	O
f_object	O
?	O
res	O
:	O
restype	enum
==	O
f_fixnum	O
?	O
make_fixnum	()->(int)
(	O
(	O
long	O
)	O
res	O
)	O
:	O
(	O
object	O
)	O
(	O
FEerror	()->(int)
(	O
"Bad result type"	*(char)
,	O
0	int
)	O
,	O
Cnil	O
)	O
)	O
;	O
vs_base	O
=	O
base	*(int)
;	O
vs_top	O
=	O
base	*(int)
+	O
1	int
;	O
CHECK_AVMA	O
;	O
return	O
;	O
}	O
static	O
void	O
call_sfun_no_check	(int)->(void)
(	O
object	O
fun	int
)	O
{	O
DEBUG_AVMA	O
int	O
n	int
;	O
object	O
*	O
base	*(int)
=	O
vs_base	O
;	O
n	int
=	O
vs_top	O
-	O
base	*(int)
;	O
base	*(int)
[	O
0	int
]	O
=	O
c_apply_n_fun	()->(int)
(	O
fun	int
,	O
n	int
,	O
base	*(int)
)	O
;	O
vs_top	O
=	O
(	O
vs_base	O
=	O
base	*(int)
)	O
+	O
1	int
;	O
CHECK_AVMA	O
;	O
return	O
;	O
}	O
static	O
void	O
call_vfun	(int)->(void)
(	O
object	O
fun	int
)	O
{	O
DEBUG_AVMA	O
int	O
n	int
;	O
object	O
*	O
base	*(int)
=	O
vs_base	O
;	O
n	int
=	O
vs_top	O
-	O
base	*(int)
;	O
if	O
(	O
n	int
<	O
fun	int
->	O
vfn	O
.	O
vfn_minargs	O
)	O
{	O
FEtoo_few_arguments	()->(int)
(	O
base	*(int)
,	O
vs_top	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
n	int
>	O
fun	int
->	O
vfn	O
.	O
vfn_maxargs	O
)	O
{	O
FEtoo_many_arguments	()->(int)
(	O
base	*(int)
,	O
vs_top	O
)	O
;	O
return	O
;	O
}	O
VFUN_NARGS	O
=	O
n	int
;	O
base	*(int)
[	O
0	int
]	O
=	O
c_apply_n_fun	()->(int)
(	O
fun	int
,	O
n	int
,	O
base	*(int)
)	O
;	O
vs_top	O
=	O
(	O
vs_base	O
=	O
base	*(int)
)	O
+	O
1	int
;	O
CHECK_AVMA	O
;	O
return	O
;	O
}	O
void	O
funcall	(int)->(void)
(	O
object	O
fun	int
)	O
{	O
object	O
temporary	O
;	O
object	O
x	enum
;	O
object	O
*	O
VOL	O
top	O
;	O
object	O
*	O
lex	O
;	O
bds_ptr	O
old_bds_top	O
;	O
VOL	O
bool	O
b	O
;	O
bool	O
c	O
;	O
DEBUG_AVMA	O
TOP	O
:	O
if	O
(	O
fun	int
==	O
OBJNULL	O
)	O
FEerror	()->(int)
(	O
"Undefined function."	*(char)
,	O
0	int
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
)	O
{	O
case	O
t_cfun	O
:	O
MMcall	()->(int)
(	O
fun	int
)	O
;	O
CHECK_AVMA	O
;	O
return	O
;	O
case	O
t_gfun	O
:	O
case	O
t_sfun	O
:	O
{	O
extern	O
int	O
Rset	int
;	O
int	O
rset	int
=	O
Rset	int
;	O
if	O
(	O
!	O
rset	int
)	O
{	O
ihs_check	O
;	O
ihs_push	()->(int)
(	O
fun	int
)	O
;	O
}	O
quick_call_sfun	(int)->(void)
(	O
fun	int
)	O
;	O
if	O
(	O
!	O
rset	int
)	O
ihs_pop	()->(int)
(	O
)	O
;	O
}	O
return	O
;	O
case	O
t_vfun	O
:	O
{	O
extern	O
int	O
Rset	int
;	O
int	O
rset	int
=	O
Rset	int
;	O
if	O
(	O
!	O
rset	int
)	O
{	O
ihs_check	O
;	O
ihs_push	()->(int)
(	O
fun	int
)	O
;	O
}	O
call_vfun	(int)->(void)
(	O
fun	int
)	O
;	O
if	O
(	O
!	O
rset	int
)	O
ihs_pop	()->(int)
(	O
)	O
;	O
}	O
return	O
;	O
case	O
t_afun	O
:	O
case	O
t_closure	O
:	O
{	O
object	O
res	O
,	O
*	O
b	O
=	O
vs_base	O
;	O
int	O
n	int
=	O
vs_top	O
-	O
b	O
;	O
res	O
=	O
(	O
object	O
)	O
IapplyVector	()->(int)
(	O
fun	int
,	O
n	int
,	O
b	O
)	O
;	O
n	int
=	O
fcall	O
.	O
nvalues	O
;	O
vs_base	O
=	O
b	O
;	O
vs_top	O
=	O
b	O
+	O
n	int
;	O
while	O
(	O
--	O
n	int
>	O
0	int
)	O
b	O
[	O
n	int
]	O
=	O
fcall	O
.	O
values	O
[	O
n	int
]	O
;	O
b	O
[	O
0	int
]	O
=	O
res	O
;	O
return	O
;	O
}	O
case	O
t_cclosure	O
:	O
MMccall	()->(int)
(	O
fun	int
)	O
;	O
CHECK_AVMA	O
;	O
return	O
;	O
case	O
t_symbol	O
:	O
{	O
object	O
x	enum
=	O
fun	int
->	O
s	O
.	O
s_gfdef	O
;	O
if	O
(	O
x	enum
)	O
{	O
fun	int
=	O
x	enum
;	O
goto	O
TOP	O
;	O
}	O
else	O
FEundefined_function	()->(int)
(	O
fun	int
)	O
;	O
}	O
case	O
t_cons	O
:	O
break	O
;	O
default	O
:	O
FEinvalid_function	()->(int)
(	O
fun	int
)	O
;	O
}	O
{	O
VOL	O
int	O
not_pushed	O
=	O
0	int
;	O
if	O
(	O
vs_base	O
!=	O
ihs_top	O
->	O
ihs_base	O
)	O
{	O
ihs_check	O
;	O
ihs_push	()->(int)
(	O
fun	int
)	O
;	O
}	O
else	O
not_pushed	O
=	O
1	int
;	O
ihs_top	O
->	O
ihs_base	O
=	O
lex_env	O
;	O
x	enum
=	O
MMcar	()->(int)
(	O
fun	int
)	O
;	O
top	O
=	O
vs_top	O
;	O
lex	O
=	O
lex_env	O
;	O
old_bds_top	O
=	O
bds_top	O
;	O
if	O
(	O
x	enum
==	O
sSlambda_block_expanded	O
)	O
{	O
b	O
=	O
TRUE	O
;	O
c	O
=	O
FALSE	O
;	O
fun	int
=	O
fun	int
->	O
c	O
.	O
c_cdr	O
;	O
}	O
else	O
if	O
(	O
x	enum
==	O
sLlambda_block	O
)	O
{	O
b	O
=	O
TRUE	O
;	O
c	O
=	O
FALSE	O
;	O
if	O
(	O
sSlambda_block_expanded	O
->	O
s	O
.	O
s_dbind	O
!=	O
OBJNULL	O
)	O
fun	int
=	O
ifuncall1	()->(int)
(	O
sSlambda_block_expanded	O
->	O
s	O
.	O
s_dbind	O
,	O
fun	int
)	O
;	O
fun	int
=	O
fun	int
->	O
c	O
.	O
c_cdr	O
;	O
}	O
else	O
if	O
(	O
x	enum
==	O
sLlambda_closure	O
)	O
{	O
b	O
=	O
FALSE	O
;	O
c	O
=	O
TRUE	O
;	O
fun	int
=	O
fun	int
->	O
c	O
.	O
c_cdr	O
;	O
}	O
else	O
if	O
(	O
x	enum
==	O
sLlambda	O
)	O
{	O
b	O
=	O
c	O
=	O
FALSE	O
;	O
fun	int
=	O
fun	int
->	O
c	O
.	O
c_cdr	O
;	O
}	O
else	O
if	O
(	O
x	enum
==	O
sLlambda_block_closure	O
)	O
{	O
b	O
=	O
c	O
=	O
TRUE	O
;	O
fun	int
=	O
fun	int
->	O
c	O
.	O
c_cdr	O
;	O
}	O
else	O
b	O
=	O
c	O
=	O
TRUE	O
;	O
if	O
(	O
c	O
)	O
{	O
vs_push	()->(int)
(	O
kar	()->(int)
(	O
fun	int
)	O
)	O
;	O
fun	int
=	O
fun	int
->	O
c	O
.	O
c_cdr	O
;	O
vs_push	()->(int)
(	O
kar	()->(int)
(	O
fun	int
)	O
)	O
;	O
fun	int
=	O
fun	int
->	O
c	O
.	O
c_cdr	O
;	O
vs_push	()->(int)
(	O
kar	()->(int)
(	O
fun	int
)	O
)	O
;	O
fun	int
=	O
fun	int
->	O
c	O
.	O
c_cdr	O
;	O
}	O
else	O
{	O
*	O
(	O
struct	O
nil3	struct(array(int))
*	O
)	O
vs_top	O
=	O
three_nils	struct(array(int))
;	O
vs_top	O
+=	O
3	int
;	O
}	O
if	O
(	O
b	O
)	O
{	O
x	enum
=	O
kar	()->(int)
(	O
fun	int
)	O
;	O
fun	int
=	O
fun	int
->	O
c	O
.	O
c_cdr	O
;	O
}	O
lex_env	O
=	O
top	O
;	O
vs_push	()->(int)
(	O
fun	int
)	O
;	O
lambda_bind	()->(int)
(	O
top	O
)	O
;	O
ihs_top	O
->	O
ihs_base	O
=	O
lex_env	O
;	O
if	O
(	O
b	O
)	O
{	O
fun	int
=	O
temporary	O
=	O
alloc_frame_id	()->(int)
(	O
)	O
;	O
temporary	O
=	O
MMcons	()->(int)
(	O
temporary	O
,	O
Cnil	O
)	O
;	O
temporary	O
=	O
MMcons	()->(int)
(	O
sLblock	O
,	O
temporary	O
)	O
;	O
temporary	O
=	O
MMcons	()->(int)
(	O
x	enum
,	O
temporary	O
)	O
;	O
lex_env	O
[	O
2	int
]	O
=	O
MMcons	()->(int)
(	O
temporary	O
,	O
lex_env	O
[	O
2	int
]	O
)	O
;	O
frs_push	()->(int)
(	O
FRS_CATCH	O
,	O
fun	int
)	O
;	O
if	O
(	O
nlj_active	O
)	O
{	O
nlj_active	O
=	O
FALSE	O
;	O
goto	O
END	O
;	O
}	O
}	O
x	enum
=	O
top	O
[	O
3	int
]	O
;	O
if	O
(	O
endp	()->(int)
(	O
x	enum
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
}	O
else	O
{	O
top	O
=	O
vs_top	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
x	enum
)	O
)	O
;	O
x	enum
=	O
MMcdr	()->(int)
(	O
x	enum
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
x	enum
)	O
)	O
break	O
;	O
vs_top	O
=	O
top	O
;	O
}	O
}	O
END	O
:	O
if	O
(	O
b	O
)	O
frs_pop	()->(int)
(	O
)	O
;	O
bds_unwind	()->(int)
(	O
old_bds_top	O
)	O
;	O
lex_env	O
=	O
lex	O
;	O
if	O
(	O
not_pushed	O
==	O
0	int
)	O
{	O
ihs_pop	()->(int)
(	O
)	O
;	O
}	O
CHECK_AVMA	O
;	O
}	O
}	O
void	O
funcall_no_event	(int)->(void)
(	O
object	O
fun	int
)	O
{	O
DEBUG_AVMA	O
if	O
(	O
fun	int
==	O
OBJNULL	O
)	O
FEerror	()->(int)
(	O
"Undefined function."	*(char)
,	O
0	int
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
)	O
{	O
case	O
t_cfun	O
:	O
(	O
*	O
fun	int
->	O
cf	O
.	O
cf_self	O
)	O
(	O
)	O
;	O
break	O
;	O
case	O
t_cclosure	O
:	O
(	O
*	O
fun	int
->	O
cc	O
.	O
cc_self	O
)	O
(	O
fun	int
)	O
;	O
break	O
;	O
case	O
t_sfun	O
:	O
case	O
t_gfun	O
:	O
quick_call_sfun	(int)->(void)
(	O
fun	int
)	O
;	O
return	O
;	O
case	O
t_vfun	O
:	O
call_vfun	(int)->(void)
(	O
fun	int
)	O
;	O
return	O
;	O
default	O
:	O
funcall	(int)->(void)
(	O
fun	int
)	O
;	O
}	O
}	O
void	O
lispcall	(*(int),int)->(void)
(	O
object	O
*	O
funp	*(int)
,	O
int	O
narg	int
)	O
{	O
DEBUG_AVMA	O
object	O
fun	int
=	O
*	O
funp	*(int)
;	O
vs_base	O
=	O
funp	*(int)
+	O
1	int
;	O
vs_top	O
=	O
vs_base	O
+	O
narg	int
;	O
if	O
(	O
fun	int
==	O
OBJNULL	O
)	O
FEerror	()->(int)
(	O
"Undefined function."	*(char)
,	O
0	int
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
)	O
{	O
case	O
t_cfun	O
:	O
MMcall	()->(int)
(	O
fun	int
)	O
;	O
break	O
;	O
case	O
t_cclosure	O
:	O
MMccall	()->(int)
(	O
fun	int
)	O
;	O
break	O
;	O
default	O
:	O
funcall	(int)->(void)
(	O
fun	int
)	O
;	O
}	O
CHECK_AVMA	O
;	O
}	O
void	O
lispcall_no_event	(*(int),int)->(void)
(	O
object	O
*	O
funp	*(int)
,	O
int	O
narg	int
)	O
{	O
DEBUG_AVMA	O
object	O
fun	int
=	O
*	O
funp	*(int)
;	O
vs_base	O
=	O
funp	*(int)
+	O
1	int
;	O
vs_top	O
=	O
vs_base	O
+	O
narg	int
;	O
if	O
(	O
fun	int
==	O
OBJNULL	O
)	O
FEerror	()->(int)
(	O
"Undefined function."	*(char)
,	O
0	int
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
)	O
{	O
case	O
t_cfun	O
:	O
(	O
*	O
fun	int
->	O
cf	O
.	O
cf_self	O
)	O
(	O
)	O
;	O
break	O
;	O
case	O
t_cclosure	O
:	O
(	O
*	O
fun	int
->	O
cc	O
.	O
cc_self	O
)	O
(	O
fun	int
)	O
;	O
break	O
;	O
default	O
:	O
funcall	(int)->(void)
(	O
fun	int
)	O
;	O
}	O
CHECK_AVMA	O
;	O
}	O
void	O
symlispcall	(int,*(int),int)->(void)
(	O
object	O
sym	int
,	O
object	O
*	O
base	*(int)
,	O
int	O
narg	int
)	O
{	O
DEBUG_AVMA	O
object	O
fun	int
=	O
symbol_function	O
(	O
sym	int
)	O
;	O
vs_base	O
=	O
base	*(int)
;	O
vs_top	O
=	O
vs_base	O
+	O
narg	int
;	O
if	O
(	O
fun	int
==	O
OBJNULL	O
)	O
FEerror	()->(int)
(	O
"Undefined function."	*(char)
,	O
0	int
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
)	O
{	O
case	O
t_cfun	O
:	O
MMcall	()->(int)
(	O
fun	int
)	O
;	O
break	O
;	O
case	O
t_cclosure	O
:	O
MMccall	()->(int)
(	O
fun	int
)	O
;	O
break	O
;	O
default	O
:	O
funcall	(int)->(void)
(	O
fun	int
)	O
;	O
}	O
CHECK_AVMA	O
;	O
}	O
void	O
symlispcall_no_event	(int,*(int),int)->(void)
(	O
object	O
sym	int
,	O
object	O
*	O
base	*(int)
,	O
int	O
narg	int
)	O
{	O
DEBUG_AVMA	O
object	O
fun	int
=	O
symbol_function	O
(	O
sym	int
)	O
;	O
vs_base	O
=	O
base	*(int)
;	O
vs_top	O
=	O
vs_base	O
+	O
narg	int
;	O
if	O
(	O
fun	int
==	O
OBJNULL	O
)	O
FEerror	()->(int)
(	O
"Undefined function."	*(char)
,	O
0	int
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
)	O
{	O
case	O
t_cfun	O
:	O
(	O
*	O
fun	int
->	O
cf	O
.	O
cf_self	O
)	O
(	O
)	O
;	O
break	O
;	O
case	O
t_cclosure	O
:	O
(	O
*	O
fun	int
->	O
cc	O
.	O
cc_self	O
)	O
(	O
fun	int
)	O
;	O
break	O
;	O
default	O
:	O
funcall	(int)->(void)
(	O
fun	int
)	O
;	O
}	O
CHECK_AVMA	O
;	O
}	O
object	O
simple_lispcall	(*(int),int)->(int)
(	O
object	O
*	O
funp	*(int)
,	O
int	O
narg	int
)	O
{	O
DEBUG_AVMA	O
object	O
fun	int
=	O
*	O
funp	*(int)
;	O
object	O
*	O
sup	O
=	O
vs_top	O
;	O
vs_base	O
=	O
funp	*(int)
+	O
1	int
;	O
vs_top	O
=	O
vs_base	O
+	O
narg	int
;	O
if	O
(	O
fun	int
==	O
OBJNULL	O
)	O
FEerror	()->(int)
(	O
"Undefined function."	*(char)
,	O
0	int
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
)	O
{	O
case	O
t_cfun	O
:	O
MMcall	()->(int)
(	O
fun	int
)	O
;	O
break	O
;	O
case	O
t_cclosure	O
:	O
MMccall	()->(int)
(	O
fun	int
)	O
;	O
break	O
;	O
default	O
:	O
funcall	(int)->(void)
(	O
fun	int
)	O
;	O
}	O
vs_top	O
=	O
sup	O
;	O
CHECK_AVMA	O
;	O
return	O
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
object	O
simple_symlispcall	(int,*(int),int)->(int)
(	O
object	O
sym	int
,	O
object	O
*	O
base	*(int)
,	O
int	O
narg	int
)	O
{	O
DEBUG_AVMA	O
object	O
fun	int
=	O
symbol_function	O
(	O
sym	int
)	O
;	O
object	O
*	O
sup	O
=	O
vs_top	O
;	O
vs_base	O
=	O
base	*(int)
;	O
vs_top	O
=	O
vs_base	O
+	O
narg	int
;	O
if	O
(	O
fun	int
==	O
OBJNULL	O
)	O
FEerror	()->(int)
(	O
"Undefined function."	*(char)
,	O
0	int
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
)	O
{	O
case	O
t_cfun	O
:	O
MMcall	()->(int)
(	O
fun	int
)	O
;	O
break	O
;	O
case	O
t_cclosure	O
:	O
MMccall	()->(int)
(	O
fun	int
)	O
;	O
break	O
;	O
default	O
:	O
funcall	(int)->(void)
(	O
fun	int
)	O
;	O
}	O
vs_top	O
=	O
sup	O
;	O
CHECK_AVMA	O
;	O
return	O
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
void	O
super_funcall	(int)->(void)
(	O
object	O
fun	int
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
==	O
t_symbol	O
)	O
{	O
if	O
(	O
fun	int
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
||	O
fun	int
->	O
s	O
.	O
s_mflag	O
)	O
FEinvalid_function	()->(int)
(	O
fun	int
)	O
;	O
if	O
(	O
fun	int
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
)	O
FEundefined_function	()->(int)
(	O
fun	int
)	O
;	O
fun	int
=	O
fun	int
->	O
s	O
.	O
s_gfdef	O
;	O
}	O
funcall	(int)->(void)
(	O
fun	int
)	O
;	O
}	O
void	O
super_funcall_no_event	(int)->(void)
(	O
object	O
fun	int
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
==	O
t_cfun	O
)	O
{	O
(	O
*	O
fun	int
->	O
cf	O
.	O
cf_self	O
)	O
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
==	O
t_sfun	O
)	O
{	O
call_sfun_no_check	(int)->(void)
(	O
fun	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
==	O
t_gfun	O
)	O
{	O
quick_call_sfun	(int)->(void)
(	O
fun	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
==	O
t_vfun	O
)	O
{	O
call_vfun	(int)->(void)
(	O
fun	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
==	O
t_symbol	O
)	O
{	O
if	O
(	O
fun	int
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
||	O
fun	int
->	O
s	O
.	O
s_mflag	O
)	O
FEinvalid_function	()->(int)
(	O
fun	int
)	O
;	O
if	O
(	O
fun	int
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
)	O
FEundefined_function	()->(int)
(	O
fun	int
)	O
;	O
fun	int
=	O
fun	int
->	O
s	O
.	O
s_gfdef	O
;	O
if	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
==	O
t_cfun	O
)	O
{	O
(	O
*	O
fun	int
->	O
cf	O
.	O
cf_self	O
)	O
(	O
)	O
;	O
return	O
;	O
}	O
}	O
funcall_no_event	(int)->(void)
(	O
fun	int
)	O
;	O
}	O
object	O
Ieval	(int)->(int)
(	O
object	O
form	int
)	O
{	O
eval	()->(int)
(	O
form	int
)	O
;	O
return	O
Ivs_values	()->(int)
(	O
)	O
;	O
}	O
void	O
eval	()->(int)
(	O
object	O
form	int
)	O
{	O
object	O
temporary	O
;	O
DEBUG_AVMA	O
object	O
fun	int
,	O
x	enum
;	O
object	O
*	O
top	O
;	O
object	O
*	O
base	*(int)
;	O
cs_check	()->(int)
(	O
form	int
)	O
;	O
EVAL	O
:	O
vs_check	O
;	O
if	O
(	O
Vevalhook	O
->	O
s	O
.	O
s_dbind	O
!=	O
Cnil	O
&&	O
eval1	O
==	O
0	int
)	O
{	O
bds_ptr	O
old_bds_top	O
=	O
bds_top	O
;	O
object	O
hookfun	O
=	O
symbol_value	()->(int)
(	O
Vevalhook	O
)	O
;	O
bds_bind	()->(int)
(	O
Vevalhook	O
,	O
Cnil	O
)	O
;	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
form	int
)	O
;	O
vs_push	()->(int)
(	O
lex_env	O
[	O
0	int
]	O
)	O
;	O
vs_push	()->(int)
(	O
lex_env	O
[	O
1	int
]	O
)	O
;	O
vs_push	()->(int)
(	O
lex_env	O
[	O
2	int
]	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
super_funcall	(int)->(void)
(	O
hookfun	O
)	O
;	O
bds_unwind	()->(int)
(	O
old_bds_top	O
)	O
;	O
return	O
;	O
}	O
else	O
eval1	O
=	O
0	int
;	O
if	O
(	O
type_of	()->(int)
(	O
form	int
)	O
==	O
t_cons	O
)	O
goto	O
APPLICATION	O
;	O
if	O
(	O
type_of	()->(int)
(	O
form	int
)	O
!=	O
t_symbol	O
)	O
{	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
form	int
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
form	int
->	O
s	O
.	O
s_stype	O
)	O
{	O
case	O
stp_constant	O
:	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
form	int
->	O
s	O
.	O
s_dbind	O
)	O
;	O
return	O
;	O
case	O
stp_special	O
:	O
if	O
(	O
form	int
->	O
s	O
.	O
s_dbind	O
==	O
OBJNULL	O
)	O
FEunbound_variable	()->(int)
(	O
form	int
)	O
;	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
form	int
->	O
s	O
.	O
s_dbind	O
)	O
;	O
return	O
;	O
default	O
:	O
for	O
(	O
x	enum
=	O
lex_env	O
[	O
0	int
]	O
;	O
type_of	()->(int)
(	O
x	enum
)	O
==	O
t_cons	O
;	O
x	enum
=	O
x	enum
->	O
c	O
.	O
c_cdr	O
)	O
if	O
(	O
x	enum
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_car	O
==	O
form	int
)	O
{	O
x	enum
=	O
x	enum
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
endp	()->(int)
(	O
x	enum
)	O
)	O
break	O
;	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
x	enum
->	O
c	O
.	O
c_car	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
form	int
->	O
s	O
.	O
s_dbind	O
==	O
OBJNULL	O
)	O
FEunbound_variable	()->(int)
(	O
form	int
)	O
;	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
form	int
->	O
s	O
.	O
s_dbind	O
)	O
;	O
return	O
;	O
}	O
APPLICATION	O
:	O
if	O
(	O
sSAbreak_pointsA	int
->	O
s	O
.	O
s_dbind	O
!=	O
Cnil	O
)	O
{	O
if	O
(	O
sSAbreak_stepA	int
->	O
s	O
.	O
s_dbind	O
==	O
Cnil	O
||	O
ifuncall2	()->(int)
(	O
sSAbreak_stepA	int
->	O
s	O
.	O
s_dbind	O
,	O
form	int
,	O
list	()->(int)
(	O
3	int
,	O
lex_env	O
[	O
0	int
]	O
,	O
lex_env	O
[	O
1	int
]	O
,	O
lex_env	O
[	O
2	int
]	O
)	O
)	O
==	O
Cnil	O
)	O
{	O
object	O
*	O
bpts	O
=	O
sSAbreak_pointsA	int
->	O
s	O
.	O
s_dbind	O
->	O
v	O
.	O
v_self	O
;	O
int	O
i	int
=	O
sSAbreak_pointsA	int
->	O
s	O
.	O
s_dbind	O
->	O
v	O
.	O
v_fillp	O
;	O
while	O
(	O
--	O
i	int
>=	O
0	int
)	O
{	O
if	O
(	O
(	O
*	O
bpts	O
)	O
->	O
c	O
.	O
c_car	O
==	O
form	int
)	O
{	O
ifuncall2	()->(int)
(	O
sSAbreak_pointsA	int
->	O
s	O
.	O
s_gfdef	O
,	O
form	int
,	O
list	()->(int)
(	O
3	int
,	O
lex_env	O
[	O
0	int
]	O
,	O
lex_env	O
[	O
1	int
]	O
,	O
lex_env	O
[	O
2	int
]	O
)	O
)	O
;	O
break	O
;	O
}	O
bpts	O
++	O
;	O
}	O
}	O
}	O
fun	int
=	O
MMcar	()->(int)
(	O
form	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
!=	O
t_symbol	O
)	O
goto	O
LAMBDA	O
;	O
if	O
(	O
fun	int
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
)	O
{	O
ihs_check	O
;	O
ihs_push	()->(int)
(	O
form	int
)	O
;	O
ihs_top	O
->	O
ihs_base	O
=	O
lex_env	O
;	O
(	O
*	O
fun	int
->	O
s	O
.	O
s_sfdef	O
)	O
(	O
MMcdr	()->(int)
(	O
form	int
)	O
)	O
;	O
CHECK_AVMA	O
;	O
ihs_pop	()->(int)
(	O
)	O
;	O
return	O
;	O
}	O
for	O
(	O
x	enum
=	O
lex_env	O
[	O
1	int
]	O
;	O
type_of	()->(int)
(	O
x	enum
)	O
==	O
t_cons	O
;	O
x	enum
=	O
x	enum
->	O
c	O
.	O
c_cdr	O
)	O
if	O
(	O
x	enum
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_car	O
==	O
fun	int
)	O
{	O
x	enum
=	O
x	enum
->	O
c	O
.	O
c_car	O
;	O
if	O
(	O
MMcadr	()->(int)
(	O
x	enum
)	O
==	O
sLmacro	O
)	O
{	O
x	enum
=	O
MMcaddr	()->(int)
(	O
x	enum
)	O
;	O
goto	O
EVAL_MACRO	O
;	O
}	O
x	enum
=	O
MMcaddr	()->(int)
(	O
x	enum
)	O
;	O
goto	O
EVAL_ARGS	O
;	O
}	O
if	O
(	O
(	O
x	enum
=	O
fun	int
->	O
s	O
.	O
s_gfdef	O
)	O
==	O
OBJNULL	O
)	O
FEundefined_function	()->(int)
(	O
fun	int
)	O
;	O
if	O
(	O
fun	int
->	O
s	O
.	O
s_mflag	O
)	O
{	O
EVAL_MACRO	O
:	O
top	O
=	O
vs_top	O
;	O
form	int
=	O
Imacro_expand1	()->(int)
(	O
x	enum
,	O
form	int
)	O
;	O
vs_top	O
=	O
top	O
;	O
vs_push	()->(int)
(	O
form	int
)	O
;	O
goto	O
EVAL	O
;	O
}	O
EVAL_ARGS	O
:	O
vs_push	()->(int)
(	O
x	enum
)	O
;	O
ihs_check	O
;	O
ihs_push	()->(int)
(	O
form	int
)	O
;	O
ihs_top	O
->	O
ihs_base	O
=	O
lex_env	O
;	O
form	int
=	O
form	int
->	O
c	O
.	O
c_cdr	O
;	O
base	*(int)
=	O
vs_top	O
;	O
top	O
=	O
vs_top	O
;	O
while	O
(	O
!	O
endp	()->(int)
(	O
form	int
)	O
)	O
{	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
form	int
)	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_top	O
=	O
++	O
top	O
;	O
form	int
=	O
MMcdr	()->(int)
(	O
form	int
)	O
;	O
}	O
vs_base	O
=	O
base	*(int)
;	O
if	O
(	O
Vapplyhook	O
->	O
s	O
.	O
s_dbind	O
!=	O
Cnil	O
)	O
{	O
call_applyhook	()->(void)
(	O
fun	int
)	O
;	O
return	O
;	O
}	O
ihs_top	O
->	O
ihs_function	O
=	O
x	enum
;	O
ihs_top	O
->	O
ihs_base	O
=	O
vs_base	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	enum
)	O
==	O
t_cfun	O
)	O
(	O
*	O
(	O
x	enum
)	O
->	O
cf	O
.	O
cf_self	O
)	O
(	O
)	O
;	O
else	O
funcall_no_event	(int)->(void)
(	O
x	enum
)	O
;	O
CHECK_AVMA	O
;	O
ihs_pop	()->(int)
(	O
)	O
;	O
return	O
;	O
LAMBDA	O
:	O
if	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
==	O
t_cons	O
&&	O
MMcar	()->(int)
(	O
fun	int
)	O
==	O
sLlambda	O
)	O
{	O
temporary	O
=	O
make_cons	()->(int)
(	O
lex_env	O
[	O
2	int
]	O
,	O
fun	int
->	O
c	O
.	O
c_cdr	O
)	O
;	O
temporary	O
=	O
make_cons	()->(int)
(	O
lex_env	O
[	O
1	int
]	O
,	O
temporary	O
)	O
;	O
temporary	O
=	O
make_cons	()->(int)
(	O
lex_env	O
[	O
0	int
]	O
,	O
temporary	O
)	O
;	O
x	enum
=	O
make_cons	()->(int)
(	O
sLlambda_closure	O
,	O
temporary	O
)	O
;	O
vs_push	()->(int)
(	O
x	enum
)	O
;	O
goto	O
EVAL_ARGS	O
;	O
}	O
FEinvalid_function	()->(int)
(	O
fun	int
)	O
;	O
}	O
static	O
void	O
call_applyhook	()->(void)
(	O
object	O
fun	int
)	O
{	O
object	O
ah	O
;	O
object	O
*	O
v	O
;	O
ah	O
=	O
symbol_value	()->(int)
(	O
Vapplyhook	O
)	O
;	O
v	O
=	O
vs_base	O
+	O
1	int
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
while	O
(	O
vs_top	O
>	O
v	O
)	O
stack_cons	()->(int)
(	O
)	O
;	O
vs_push	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
fun	int
;	O
vs_push	()->(int)
(	O
lex_env	O
[	O
0	int
]	O
)	O
;	O
vs_push	()->(int)
(	O
lex_env	O
[	O
1	int
]	O
)	O
;	O
vs_push	()->(int)
(	O
lex_env	O
[	O
2	int
]	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
stack_cons	()->(int)
(	O
)	O
;	O
super_funcall	(int)->(void)
(	O
ah	O
)	O
;	O
}	O
DEFUNOM_NEW	()->(int)
(	O
"FUNCALL"	*(char)
,	O
object	O
,	O
fLfuncall	O
,	O
LISP	O
,	O
1	int
,	O
MAX_ARGS	O
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lfuncall	O
,	O
(	O
object	O
fun	int
,	O
...	O
)	O
,	O
""	*(char)
)	O
{	O
va_list	O
ap	int
;	O
object	O
*	O
new	O
;	O
int	O
n	int
=	O
VFUN_NARGS	O
;	O
va_start	O
(	O
ap	int
,	O
fun	int
)	O
;	O
{	O
COERCE_VA_LIST	()->(int)
(	O
new	O
,	O
ap	int
,	O
n	int
)	O
;	O
return	O
IapplyVector	()->(int)
(	O
fun	int
,	O
n	int
-	O
1	int
,	O
new	O
)	O
;	O
va_end	O
(	O
ap	int
)	O
;	O
}	O
}	O
DEFUNOM_NEW	()->(int)
(	O
"APPLY"	*(char)
,	O
object	O
,	O
fLapply	O
,	O
LISP	O
,	O
2	int
,	O
MAX_ARGS	O
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lapply	O
,	O
(	O
object	O
fun	int
,	O
...	O
)	O
,	O
""	*(char)
)	O
{	O
int	O
m	int
,	O
n	int
=	O
VFUN_NARGS	O
;	O
object	O
l	O
;	O
object	O
buf	O
[	O
MAX_ARGS	O
]	O
;	O
object	O
*	O
base	*(int)
=	O
buf	O
;	O
va_list	O
ap	int
;	O
va_start	O
(	O
ap	int
,	O
fun	int
)	O
;	O
m	int
=	O
n	int
-	O
1	int
;	O
while	O
(	O
--	O
m	int
>	O
0	int
)	O
{	O
*	O
base	*(int)
++	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
}	O
m	int
=	O
n	int
-	O
2	int
;	O
l	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
va_end	O
(	O
ap	int
)	O
;	O
while	O
(	O
!	O
endp	()->(int)
(	O
l	O
)	O
)	O
{	O
if	O
(	O
m	int
>=	O
MAX_ARGS	O
)	O
FEerror	()->(int)
(	O
" Lisps arglist maximum surpassed"	*(char)
,	O
0	int
)	O
;	O
*	O
base	*(int)
++	O
=	O
Mcar	()->(int)
(	O
l	O
)	O
;	O
l	O
=	O
Mcdr	()->(int)
(	O
l	O
)	O
;	O
m	int
++	O
;	O
}	O
return	O
IapplyVector	()->(int)
(	O
fun	int
,	O
m	int
,	O
buf	O
)	O
;	O
}	O
DEFUNOM_NEW	()->(int)
(	O
"EVAL"	*(char)
,	O
object	O
,	O
fLeval	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Leval	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	*(char)
)	O
{	O
object	O
*	O
lex	O
=	O
lex_env	O
;	O
lex_new	()->(int)
(	O
)	O
;	O
eval	()->(int)
(	O
x0	O
)	O
;	O
lex_env	O
=	O
lex	O
;	O
return	O
Ivs_values	()->(int)
(	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Levalhook	int
)	O
(	O
void	O
)	O
{	O
object	O
env	O
;	O
bds_ptr	O
old_bds_top	O
=	O
bds_top	O
;	O
object	O
*	O
lex	O
=	O
lex_env	O
;	O
int	O
n	int
=	O
vs_top	O
-	O
vs_base	O
;	O
lex_env	O
=	O
vs_top	O
;	O
if	O
(	O
n	int
<	O
3	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
else	O
if	O
(	O
n	int
==	O
3	int
)	O
{	O
*	O
(	O
struct	O
nil3	struct(array(int))
*	O
)	O
vs_top	O
=	O
three_nils	struct(array(int))
;	O
vs_top	O
+=	O
3	int
;	O
}	O
else	O
if	O
(	O
n	int
==	O
4	int
)	O
{	O
env	O
=	O
vs_base	O
[	O
3	int
]	O
;	O
vs_push	()->(int)
(	O
car	()->(int)
(	O
env	O
)	O
)	O
;	O
env	O
=	O
cdr	()->(int)
(	O
env	O
)	O
;	O
vs_push	()->(int)
(	O
car	()->(int)
(	O
env	O
)	O
)	O
;	O
env	O
=	O
cdr	()->(int)
(	O
env	O
)	O
;	O
vs_push	()->(int)
(	O
car	()->(int)
(	O
env	O
)	O
)	O
;	O
}	O
else	O
too_many_arguments	()->(int)
(	O
)	O
;	O
bds_bind	()->(int)
(	O
Vevalhook	O
,	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
bds_bind	()->(int)
(	O
Vapplyhook	O
,	O
vs_base	O
[	O
2	int
]	O
)	O
;	O
eval1	O
=	O
1	int
;	O
eval	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
lex_env	O
=	O
lex	O
;	O
bds_unwind	()->(int)
(	O
old_bds_top	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lapplyhook	int
)	O
(	O
void	O
)	O
{	O
object	O
env	O
;	O
bds_ptr	O
old_bds_top	O
=	O
bds_top	O
;	O
object	O
*	O
lex	O
=	O
lex_env	O
;	O
int	O
n	int
=	O
vs_top	O
-	O
vs_base	O
;	O
object	O
l	O
,	O
*	O
z	O
;	O
lex_env	O
=	O
vs_top	O
;	O
if	O
(	O
n	int
<	O
4	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
else	O
if	O
(	O
n	int
==	O
4	int
)	O
{	O
*	O
(	O
struct	O
nil3	struct(array(int))
*	O
)	O
vs_top	O
=	O
three_nils	struct(array(int))
;	O
vs_top	O
+=	O
3	int
;	O
}	O
else	O
if	O
(	O
n	int
==	O
5	int
)	O
{	O
env	O
=	O
vs_base	O
[	O
4	int
]	O
;	O
vs_push	()->(int)
(	O
car	()->(int)
(	O
env	O
)	O
)	O
;	O
env	O
=	O
cdr	()->(int)
(	O
env	O
)	O
;	O
vs_push	()->(int)
(	O
car	()->(int)
(	O
env	O
)	O
)	O
;	O
env	O
=	O
cdr	()->(int)
(	O
env	O
)	O
;	O
vs_push	()->(int)
(	O
car	()->(int)
(	O
env	O
)	O
)	O
;	O
}	O
else	O
too_many_arguments	()->(int)
(	O
)	O
;	O
bds_bind	()->(int)
(	O
Vevalhook	O
,	O
vs_base	O
[	O
2	int
]	O
)	O
;	O
bds_bind	()->(int)
(	O
Vapplyhook	O
,	O
vs_base	O
[	O
3	int
]	O
)	O
;	O
z	O
=	O
vs_top	O
;	O
for	O
(	O
l	O
=	O
vs_base	O
[	O
1	int
]	O
;	O
!	O
endp	()->(int)
(	O
l	O
)	O
;	O
l	O
=	O
l	O
->	O
c	O
.	O
c_cdr	O
)	O
vs_push	()->(int)
(	O
l	O
->	O
c	O
.	O
c_car	O
)	O
;	O
l	O
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_base	O
=	O
z	O
;	O
super_funcall	(int)->(void)
(	O
l	O
)	O
;	O
lex_env	O
=	O
lex	O
;	O
bds_unwind	()->(int)
(	O
old_bds_top	O
)	O
;	O
}	O
DEFUNO_NEW	()->(int)
(	O
"CONSTANTP"	*(char)
,	O
object	O
,	O
fLconstantp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lconstantp	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	*(char)
)	O
{	O
enum	O
type	O
x	enum
;	O
x	enum
=	O
type_of	()->(int)
(	O
x0	O
)	O
;	O
if	O
(	O
x	enum
==	O
t_cons	O
)	O
if	O
(	O
x0	O
->	O
c	O
.	O
c_car	O
==	O
sLquote	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
else	O
if	O
(	O
x	enum
==	O
t_symbol	O
)	O
if	O
(	O
(	O
enum	O
stype	O
)	O
x0	O
->	O
s	O
.	O
s_stype	O
==	O
stp_constant	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
else	O
x0	O
=	O
Ct	O
;	O
RETURN1	()->(int)
(	O
x0	O
)	O
;	O
}	O
object	O
ieval	(int)->(int)
(	O
object	O
x	enum
)	O
{	O
object	O
*	O
old_vs_base	O
;	O
object	O
*	O
old_vs_top	O
;	O
old_vs_base	O
=	O
vs_base	O
;	O
old_vs_top	O
=	O
vs_top	O
;	O
eval	()->(int)
(	O
x	enum
)	O
;	O
x	enum
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_base	O
=	O
old_vs_base	O
;	O
vs_top	O
=	O
old_vs_top	O
;	O
return	O
(	O
x	enum
)	O
;	O
}	O
object	O
ifuncall1	()->(int)
(	O
object	O
fun	int
,	O
object	O
arg1	int
)	O
{	O
object	O
*	O
old_vs_base	O
;	O
object	O
*	O
old_vs_top	O
;	O
object	O
x	enum
;	O
old_vs_base	O
=	O
vs_base	O
;	O
old_vs_top	O
=	O
vs_top	O
;	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
arg1	int
)	O
;	O
super_funcall	(int)->(void)
(	O
fun	int
)	O
;	O
x	enum
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_top	O
=	O
old_vs_top	O
;	O
vs_base	O
=	O
old_vs_base	O
;	O
return	O
(	O
x	enum
)	O
;	O
}	O
object	O
ifuncall2	()->(int)
(	O
object	O
fun	int
,	O
object	O
arg1	int
,	O
object	O
arg2	int
)	O
{	O
object	O
*	O
old_vs_base	O
;	O
object	O
*	O
old_vs_top	O
;	O
object	O
x	enum
;	O
old_vs_base	O
=	O
vs_base	O
;	O
old_vs_top	O
=	O
vs_top	O
;	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
arg1	int
)	O
;	O
vs_push	()->(int)
(	O
arg2	int
)	O
;	O
super_funcall	(int)->(void)
(	O
fun	int
)	O
;	O
x	enum
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_top	O
=	O
old_vs_top	O
;	O
vs_base	O
=	O
old_vs_base	O
;	O
return	O
(	O
x	enum
)	O
;	O
}	O
object	O
ifuncall3	(int,int,int,int)->(int)
(	O
object	O
fun	int
,	O
object	O
arg1	int
,	O
object	O
arg2	int
,	O
object	O
arg3	int
)	O
{	O
object	O
*	O
old_vs_base	O
;	O
object	O
*	O
old_vs_top	O
;	O
object	O
x	enum
;	O
old_vs_base	O
=	O
vs_base	O
;	O
old_vs_top	O
=	O
vs_top	O
;	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
arg1	int
)	O
;	O
vs_push	()->(int)
(	O
arg2	int
)	O
;	O
vs_push	()->(int)
(	O
arg3	int
)	O
;	O
super_funcall	(int)->(void)
(	O
fun	int
)	O
;	O
x	enum
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_top	O
=	O
old_vs_top	O
;	O
vs_base	O
=	O
old_vs_base	O
;	O
return	O
(	O
x	enum
)	O
;	O
}	O
void	O
funcall_with_catcher	(int,int)->(void)
(	O
object	O
fname	int
,	O
object	O
fun	int
)	O
{	O
int	O
n	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
n	int
>	O
64	int
)	O
n	int
=	O
64	int
;	O
frs_push	()->(int)
(	O
FRS_CATCH	O
,	O
make_cons	()->(int)
(	O
fname	int
,	O
make_fixnum	()->(int)
(	O
n	int
)	O
)	O
)	O
;	O
if	O
(	O
nlj_active	O
)	O
nlj_active	O
=	O
FALSE	O
;	O
else	O
funcall	(int)->(void)
(	O
fun	int
)	O
;	O
frs_pop	()->(int)
(	O
)	O
;	O
}	O
static	O
object	O
fcalln_cclosure	(int,int)->(int)
(	O
object	O
first	int
,	O
va_list	O
ap	int
)	O
{	O
int	O
i	int
=	O
fcall	O
.	O
argd	O
;	O
{	O
object	O
*	O
base	*(int)
=	O
vs_top	O
,	O
*	O
old_base	O
=	O
base	*(int)
;	O
DEBUG_AVMA	O
vs_base	O
=	O
base	*(int)
;	O
if	O
(	O
i	int
)	O
{	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
first	int
;	O
i	int
--	O
;	O
}	O
switch	O
(	O
i	int
)	O
{	O
case	O
10	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
9	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
8	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
7	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
6	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
5	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
4	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
3	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
2	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
1	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
FEerror	()->(int)
(	O
"bad args"	*(char)
,	O
0	int
)	O
;	O
}	O
vs_top	O
=	O
base	*(int)
;	O
base	*(int)
=	O
old_base	O
;	O
do	O
{	O
object	O
fun	int
=	O
fcall	O
.	O
fun	int
;	O
object	O
*	O
top	O
,	O
*	O
base	*(int)
,	O
l	O
;	O
massert	()->(int)
(	O
fun	int
->	O
cc	O
.	O
cc_turbo	O
)	O
;	O
if	O
(	O
fun	int
->	O
cc	O
.	O
cc_turbo	O
!=	O
NULL	O
)	O
{	O
(	O
*	O
fun	int
->	O
cc	O
.	O
cc_self	O
)	O
(	O
fun	int
)	O
;	O
break	O
;	O
}	O
top	O
=	O
vs_top	O
;	O
base	*(int)
=	O
vs_base	O
;	O
for	O
(	O
l	O
=	O
fun	int
->	O
cc	O
.	O
cc_env	O
;	O
!	O
endp	()->(int)
(	O
l	O
)	O
;	O
l	O
=	O
l	O
->	O
c	O
.	O
c_cdr	O
)	O
vs_push	()->(int)
(	O
l	O
)	O
;	O
vs_base	O
=	O
vs_top	O
;	O
while	O
(	O
base	*(int)
<	O
top	O
)	O
vs_push	()->(int)
(	O
*	O
base	*(int)
++	O
)	O
;	O
(	O
*	O
fcall	O
.	O
fun	int
->	O
cc	O
.	O
cc_self	O
)	O
(	O
top	O
)	O
;	O
break	O
;	O
}	O
while	O
(	O
0	int
)	O
;	O
vs_top	O
=	O
base	*(int)
;	O
CHECK_AVMA	O
;	O
return	O
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
}	O
static	O
object	O
fcalln_general	(int,int)->(int)
(	O
object	O
first	int
,	O
va_list	O
ap	int
)	O
{	O
int	O
i	int
=	O
fcall	O
.	O
argd	O
;	O
{	O
int	O
n	int
=	O
SFUN_NARGS	()->(int)
(	O
i	int
)	O
;	O
object	O
*	O
old_vs_top	O
=	O
vs_top	O
;	O
object	O
x	enum
;	O
enum	O
ftype	O
typ	enum
,	O
restype	enum
=	O
SFUN_RETURN_TYPE	()->(int)
(	O
i	int
)	O
;	O
vs_top	O
=	O
vs_base	O
=	O
old_vs_top	O
;	O
SFUN_START_ARG_TYPES	()->(int)
(	O
i	int
)	O
;	O
if	O
(	O
i	int
==	O
0	int
)	O
{	O
int	O
jj	int
=	O
0	int
;	O
while	O
(	O
n	int
--	O
>	O
0	int
)	O
{	O
typ	enum
=	O
SFUN_NEXT_TYPE	()->(int)
(	O
i	int
)	O
;	O
x	enum
=	O
(	O
typ	enum
==	O
f_object	O
?	O
(	O
jj	int
?	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
:	O
first	int
)	O
:	O
typ	enum
==	O
f_fixnum	O
?	O
make_fixnum	()->(int)
(	O
(	O
jj	int
?	O
va_arg	()->(int)
(	O
ap	int
,	O
fixnum	O
)	O
:	O
(	O
fixnum	O
)	O
first	int
)	O
)	O
:	O
(	O
object	O
)	O
(	O
FEerror	()->(int)
(	O
"bad type"	*(char)
,	O
0	int
)	O
,	O
Cnil	O
)	O
)	O
;	O
*	O
(	O
vs_top	O
++	O
)	O
=	O
x	enum
;	O
jj	int
++	O
;	O
}	O
}	O
else	O
{	O
object	O
*	O
base	*(int)
=	O
vs_top	O
;	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
first	int
;	O
n	int
--	O
;	O
while	O
(	O
n	int
--	O
>	O
0	int
)	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
vs_top	O
=	O
base	*(int)
;	O
}	O
funcall	(int)->(void)
(	O
fcall	O
.	O
fun	int
)	O
;	O
x	enum
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_top	O
=	O
old_vs_top	O
;	O
return	O
(	O
restype	enum
==	O
f_object	O
?	O
x	enum
:	O
restype	enum
==	O
f_fixnum	O
?	O
(	O
object	O
)	O
(	O
fix	()->(int)
(	O
x	enum
)	O
)	O
:	O
(	O
object	O
)	O
(	O
FEerror	()->(int)
(	O
"bad type"	*(char)
,	O
0	int
)	O
,	O
Cnil	O
)	O
)	O
;	O
}	O
}	O
static	O
object	O
fcalln_vfun	(int,int)->(int)
(	O
object	O
first	int
,	O
va_list	O
vl	int
)	O
{	O
object	O
*	O
new	O
,	O
res	O
;	O
DEBUG_AVMA	O
COERCE_VA_LIST_NEW	()->(int)
(	O
new	O
,	O
first	int
,	O
vl	int
,	O
fcall	O
.	O
argd	O
)	O
;	O
res	O
=	O
c_apply_n_fun	()->(int)
(	O
fcall	O
.	O
fun	int
,	O
fcall	O
.	O
argd	O
,	O
new	O
)	O
;	O
CHECK_AVMA	O
;	O
return	O
res	O
;	O
}	O
object	O
fcalln1	(int)->(int)
(	O
object	O
first	int
,	O
...	O
)	O
{	O
va_list	O
ap	int
;	O
object	O
fun	int
=	O
fcall	O
.	O
fun	int
;	O
DEBUG_AVMA	O
va_start	O
(	O
ap	int
,	O
first	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
==	O
t_cfun	O
)	O
{	O
object	O
*	O
base	*(int)
=	O
vs_top	O
,	O
*	O
old_base	O
=	O
base	*(int)
;	O
int	O
i	int
=	O
fcall	O
.	O
argd	O
;	O
vs_base	O
=	O
base	*(int)
;	O
if	O
(	O
i	int
)	O
{	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
first	int
;	O
i	int
--	O
;	O
}	O
switch	O
(	O
i	int
)	O
{	O
case	O
10	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
9	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
8	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
7	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
6	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
5	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
4	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
3	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
2	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
1	int
:	O
*	O
(	O
base	*(int)
++	O
)	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
FEerror	()->(int)
(	O
"bad args"	*(char)
,	O
0	int
)	O
;	O
}	O
vs_top	O
=	O
base	*(int)
;	O
base	*(int)
=	O
old_base	O
;	O
(	O
*	O
fcall	O
.	O
fun	int
->	O
cf	O
.	O
cf_self	O
)	O
(	O
)	O
;	O
vs_top	O
=	O
base	*(int)
;	O
CHECK_AVMA	O
;	O
return	O
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
==	O
t_cclosure	O
)	O
return	O
(	O
fcalln_cclosure	(int,int)->(int)
(	O
first	int
,	O
ap	int
)	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
==	O
t_vfun	O
)	O
return	O
(	O
fcalln_vfun	(int,int)->(int)
(	O
first	int
,	O
ap	int
)	O
)	O
;	O
return	O
(	O
fcalln_general	(int,int)->(int)
(	O
first	int
,	O
ap	int
)	O
)	O
;	O
va_end	O
(	O
ap	int
)	O
;	O
}	O
object	O
funcall_cfun	(int,int)->(int)
(	O
funcvoid	O
fn	int
,	O
int	O
n	int
,	O
...	O
)	O
{	O
object	O
*	O
old_top	O
=	O
vs_top	O
;	O
object	O
*	O
old_base	O
=	O
vs_base	O
;	O
object	O
result	O
;	O
va_list	O
ap	int
;	O
DEBUG_AVMA	O
vs_base	O
=	O
vs_top	O
;	O
va_start	O
(	O
ap	int
,	O
n	int
)	O
;	O
while	O
(	O
n	int
--	O
>	O
0	int
)	O
vs_push	()->(int)
(	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
)	O
;	O
va_end	O
(	O
ap	int
)	O
;	O
(	O
*	O
fn	int
)	O
(	O
)	O
;	O
if	O
(	O
vs_top	O
>	O
vs_base	O
)	O
result	O
=	O
vs_base	O
[	O
0	int
]	O
;	O
else	O
result	O
=	O
Cnil	O
;	O
vs_top	O
=	O
old_top	O
;	O
vs_base	O
=	O
old_base	O
;	O
CHECK_AVMA	O
;	O
return	O
result	O
;	O
}	O
DEF_ORDINARY	()->(int)
(	O
"LAMBDA-BLOCK-EXPANDED"	*(char)
,	O
sSlambda_block_expanded	O
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEFVAR	()->(int)
(	O
"*BREAK-POINTS*"	*(char)
,	O
sSAbreak_pointsA	int
,	O
SI	O
,	O
Cnil	O
,	O
""	*(char)
)	O
;	O
DEFVAR	()->(int)
(	O
"*BREAK-STEP*"	*(char)
,	O
sSAbreak_stepA	int
,	O
SI	O
,	O
Cnil	O
,	O
""	*(char)
)	O
;	O
void	O
gcl_init_eval	()->(void)
(	O
void	O
)	O
{	O
make_constant	()->(int)
(	O
"CALL-ARGUMENTS-LIMIT"	*(char)
,	O
make_fixnum	()->(int)
(	O
64	int
)	O
)	O
;	O
Vevalhook	O
=	O
make_special	()->(int)
(	O
"*EVALHOOK*"	*(char)
,	O
Cnil	O
)	O
;	O
Vapplyhook	O
=	O
make_special	()->(int)
(	O
"*APPLYHOOK*"	*(char)
,	O
Cnil	O
)	O
;	O
three_nils	struct(array(int))
.	O
nil3_self	array(int)
[	O
0	int
]	O
=	O
Cnil	O
;	O
three_nils	struct(array(int))
.	O
nil3_self	array(int)
[	O
1	int
]	O
=	O
Cnil	O
;	O
three_nils	struct(array(int))
.	O
nil3_self	array(int)
[	O
2	int
]	O
=	O
Cnil	O
;	O
make_function	()->(int)
(	O
"EVALHOOK"	*(char)
,	O
Levalhook	int
)	O
;	O
make_function	()->(int)
(	O
"APPLYHOOK"	*(char)
,	O
Lapplyhook	int
)	O
;	O
}	O
