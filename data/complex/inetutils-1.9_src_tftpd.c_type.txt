void	O
usage	()->(void)
(	O
void	O
)	O
;	O
static	O
int	O
peer	int
;	O
static	O
int	O
rexmtval	int
=	O
TIMEOUT	int
;	O
static	O
int	O
maxtimeout	int
=	O
5	int
*	O
TIMEOUT	int
;	O
static	O
char	O
buf	array(char)
[	O
PKTSIZE	O
]	O
;	O
static	O
char	O
ackbuf	array(char)
[	O
PKTSIZE	O
]	O
;	O
static	O
struct	O
sockaddr_storage	struct(short,array(char),long)
from	struct(short,array(char),long)
;	O
static	O
socklen_t	int
fromlen	int
;	O
void	O
tftp	(*(struct(short,union(array(char),struct(union`,array(char)),array(char)))),int)->(void)
(	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
,	O
int	O
)	O
;	O
static	O
struct	O
dirlist	struct(*(char),int)
{	O
char	O
*	O
name	*(char)
;	O
int	O
len	int
;	O
}	O
dirs	array(struct(*(char),int))
[	O
MAXDIRS	int
+	O
1	int
]	O
;	O
static	O
int	O
suppress_naks	int
;	O
static	O
int	O
logging	int
;	O
static	O
const	O
char	O
*	O
errtomsg	(int)->(*(char))
(	O
int	O
)	O
;	O
static	O
void	O
nak	(int)->(void)
(	O
int	O
)	O
;	O
static	O
const	O
char	O
*	O
verifyhost	(*(struct(short,array(char),long)),int)->(*(char))
(	O
struct	O
sockaddr_storage	struct(short,array(char),long)
*	O
,	O
socklen_t	int
)	O
;	O
static	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
options	*(struct(*(char),int,*(char),int,*(char),int))
[	O
]	O
=	O
{	O
{	O
"logging"	*(char)
,	O
'l'	O
,	O
NULL	O
,	O
0	int
,	O
"enable logging"	*(char)
}	O
,	O
{	O
"nonexistent"	*(char)
,	O
'n'	O
,	O
NULL	O
,	O
0	int
,	O
"supress negative acknowledgement of requests for "	*(char)
"nonexistent relative filenames"	*(char)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
error_t	int
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(int)
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'l'	O
:	O
logging	int
=	O
1	int
;	O
break	O
;	O
case	O
'n'	O
:	O
suppress_naks	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
{	O
options	*(struct(*(char),int,*(char),int,*(char),int))
,	O
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
,	O
"directory..."	*(char)
,	O
"Trivial File Transfer Protocol server"	*(char)
}	O
;	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
int	O
index	(*(char),int)->(*(char))
;	O
register	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
;	O
int	O
on	int
,	O
n	int
;	O
struct	O
sockaddr_storage	struct(short,array(char),long)
sin	struct(short,array(char),long)
;	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
iu_argp_init	O
(	O
"tftpd"	*(char)
,	O
default_program_authors	array(*(char))
)	O
;	O
argp_parse	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,*(int),*(void))->(int)
(	O
&	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
&	O
index	(*(char),int)->(*(char))
,	O
NULL	O
)	O
;	O
openlog	(*(char),int,int)->(void)
(	O
"tftpd"	*(char)
,	O
LOG_PID	int
,	O
LOG_FTP	O
)	O
;	O
if	O
(	O
index	(*(char),int)->(*(char))
<	O
argc	int
)	O
{	O
struct	O
dirlist	struct(*(char),int)
*	O
dirp	*(struct(*(char),int))
;	O
for	O
(	O
dirp	*(struct(*(char),int))
=	O
dirs	array(struct(*(char),int))
;	O
index	(*(char),int)->(*(char))
<	O
argc	int
&&	O
dirp	*(struct(*(char),int))
<	O
&	O
dirs	array(struct(*(char),int))
[	O
MAXDIRS	int
]	O
;	O
index	(*(char),int)->(*(char))
++	O
)	O
{	O
if	O
(	O
argv	*(*(char))
[	O
index	(*(char),int)->(*(char))
]	O
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
dirp	*(struct(*(char),int))
->	O
name	*(char)
=	O
argv	*(*(char))
[	O
index	(*(char),int)->(*(char))
]	O
;	O
dirp	*(struct(*(char),int))
->	O
len	int
=	O
strlen	(*(char))->(long)
(	O
dirp	*(struct(*(char),int))
->	O
name	*(char)
)	O
;	O
dirp	*(struct(*(char),int))
++	O
;	O
}	O
}	O
}	O
on	int
=	O
1	int
;	O
if	O
(	O
ioctl	(int,long)->(int)
(	O
0	int
,	O
FIONBIO	int
,	O
&	O
on	int
)	O
<	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"ioctl(FIONBIO): %m\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
fromlen	int
=	O
sizeof	O
(	O
from	struct(short,array(char),long)
)	O
;	O
n	int
=	O
recvfrom	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(long)
(	O
0	int
,	O
buf	array(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
from	struct(short,array(char),long)
,	O
&	O
fromlen	int
)	O
;	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"recvfrom: %m\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
{	O
int	O
pid	int
;	O
int	O
i	int
;	O
socklen_t	int
j	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
20	int
;	O
i	int
++	O
)	O
{	O
pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
sleep	(int)->(int)
(	O
i	int
)	O
;	O
j	int
=	O
sizeof	O
from	struct(short,array(char),long)
;	O
i	int
=	O
recvfrom	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(long)
(	O
0	int
,	O
buf	array(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
from	struct(short,array(char),long)
,	O
&	O
j	int
)	O
;	O
if	O
(	O
i	int
>	O
0	int
)	O
{	O
n	int
=	O
i	int
;	O
fromlen	int
=	O
j	int
;	O
}	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"fork: %m\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
if	O
(	O
pid	int
!=	O
0	int
)	O
{	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
}	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
close	*((*(void))->(int))
(	O
0	int
)	O
;	O
close	*((*(void))->(int))
(	O
1	int
)	O
;	O
peer	int
=	O
socket	(int,int,int)->(int)
(	O
from	struct(short,array(char),long)
.	O
ss_family	short
,	O
SOCK_DGRAM	int
,	O
0	int
)	O
;	O
if	O
(	O
peer	int
<	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"socket: %m\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
sin	struct(short,array(char),long)
,	O
0	int
,	O
sizeof	O
(	O
sin	struct(short,array(char),long)
)	O
)	O
;	O
sin	struct(short,array(char),long)
.	O
ss_family	short
=	O
from	struct(short,array(char),long)
.	O
ss_family	short
;	O
if	O
(	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
peer	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
sin	struct(short,array(char),long)
,	O
fromlen	int
)	O
<	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"bind: %m\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
=	O
(	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
)	O
buf	array(char)
;	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
=	O
ntohs	(short)->(short)
(	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
)	O
;	O
if	O
(	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
==	O
RRQ	int
||	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
==	O
WRQ	int
)	O
tftp	(*(struct(short,union(array(char),struct(union`,array(char)),array(char)))),int)->(void)
(	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
n	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
struct	O
formats	struct(*(char),*((*(*(char)),int)->(int)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),int)
;	O
int	O
validate_access	(*(*(char)),int)->(int)
(	O
char	O
*	O
*	O
,	O
int	O
)	O
;	O
void	O
send_file	(*(struct))->(void)
(	O
struct	O
formats	struct(*(char),*((*(*(char)),int)->(int)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),int)
*	O
)	O
;	O
void	O
recvfile	(*(struct))->(void)
(	O
struct	O
formats	struct(*(char),*((*(*(char)),int)->(int)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),int)
*	O
)	O
;	O
struct	O
formats	struct(*(char),*((*(*(char)),int)->(int)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),int)
{	O
char	O
*	O
f_mode	*(char)
;	O
int	O
(	O
*	O
f_validate	*((*(*(char)),int)->(int))
)	O
(	O
char	O
*	O
*	O
,	O
int	O
)	O
;	O
void	O
(	O
*	O
f_send	*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void))
)	O
(	O
struct	O
formats	struct(*(char),*((*(*(char)),int)->(int)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),int)
*	O
)	O
;	O
void	O
(	O
*	O
f_recv	*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void))
)	O
(	O
struct	O
formats	struct(*(char),*((*(*(char)),int)->(int)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),int)
*	O
)	O
;	O
int	O
f_convert	int
;	O
}	O
formats	struct(*(char),*((*(*(char)),int)->(int)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),int)
[	O
]	O
=	O
{	O
{	O
"netascii"	*(char)
,	O
validate_access	(*(*(char)),int)->(int)
,	O
send_file	(*(struct))->(void)
,	O
recvfile	(*(struct))->(void)
,	O
1	int
}	O
,	O
{	O
"octet"	*(char)
,	O
validate_access	(*(*(char)),int)->(int)
,	O
send_file	(*(struct))->(void)
,	O
recvfile	(*(struct))->(void)
,	O
0	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
void	O
tftp	(*(struct(short,union(array(char),struct(union`,array(char)),array(char)))),int)->(void)
(	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
int	O
size	int
)	O
{	O
register	O
char	O
*	O
cp	*(char)
;	O
int	O
first	int
=	O
1	int
,	O
ecode	int
;	O
register	O
struct	O
formats	struct(*(char),*((*(*(char)),int)->(int)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),int)
*	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
;	O
char	O
*	O
filename	*(char)
,	O
*	O
mode	*(char)
;	O
filename	*(char)
=	O
cp	*(char)
=	O
(	O
char	O
*	O
)	O
&	O
(	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_stuff	O
)	O
;	O
again	O
:	O
while	O
(	O
cp	*(char)
<	O
buf	array(char)
+	O
size	int
)	O
{	O
if	O
(	O
*	O
cp	*(char)
==	O
'\0'	O
)	O
break	O
;	O
cp	*(char)
++	O
;	O
}	O
if	O
(	O
*	O
cp	*(char)
!=	O
'\0'	O
)	O
{	O
nak	(int)->(void)
(	O
EBADOP	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
first	int
)	O
{	O
mode	*(char)
=	O
++	O
cp	*(char)
;	O
first	int
=	O
0	int
;	O
goto	O
again	O
;	O
}	O
for	O
(	O
cp	*(char)
=	O
mode	*(char)
;	O
*	O
cp	*(char)
;	O
cp	*(char)
++	O
)	O
if	O
(	O
isupper	(int)->(int)
(	O
*	O
cp	*(char)
)	O
)	O
*	O
cp	*(char)
=	O
tolower	(int)->(int)
(	O
*	O
cp	*(char)
)	O
;	O
for	O
(	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
=	O
formats	struct(*(char),*((*(*(char)),int)->(int)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),int)
;	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
->	O
f_mode	*(char)
;	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
->	O
f_mode	*(char)
,	O
mode	*(char)
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
->	O
f_mode	*(char)
==	O
0	int
)	O
{	O
nak	(int)->(void)
(	O
EBADOP	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
ecode	int
=	O
(	O
*	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
->	O
f_validate	*((*(*(char)),int)->(int))
)	O
(	O
&	O
filename	*(char)
,	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
)	O
;	O
if	O
(	O
logging	int
)	O
{	O
char	O
*	O
family	*(char)
;	O
switch	O
(	O
from	struct(short,array(char),long)
.	O
ss_family	short
)	O
{	O
case	O
AF_INET	O
:	O
family	*(char)
=	O
"IPv4"	*(char)
;	O
break	O
;	O
case	O
AF_INET6	O
:	O
family	*(char)
=	O
"IPv6"	*(char)
;	O
break	O
;	O
default	O
:	O
family	*(char)
=	O
"?"	*(char)
;	O
}	O
syslog	(int,*(char))->(void)
(	O
LOG_INFO	int
,	O
"%s (%s): %s request for %s: %s"	*(char)
,	O
verifyhost	(*(struct(short,array(char),long)),int)->(*(char))
(	O
&	O
from	struct(short,array(char),long)
,	O
fromlen	int
)	O
,	O
family	*(char)
,	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
==	O
WRQ	int
?	O
"write"	*(char)
:	O
"read"	*(char)
,	O
filename	*(char)
,	O
errtomsg	(int)->(*(char))
(	O
ecode	int
)	O
)	O
;	O
}	O
if	O
(	O
ecode	int
)	O
{	O
if	O
(	O
suppress_naks	int
&&	O
*	O
filename	*(char)
!=	O
'/'	O
&&	O
ecode	int
==	O
ENOTFOUND	int
)	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
nak	(int)->(void)
(	O
ecode	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
==	O
WRQ	int
)	O
(	O
*	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
->	O
f_recv	*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void))
)	O
(	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
)	O
;	O
else	O
(	O
*	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
->	O
f_send	*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void))
)	O
(	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
FILE	struct
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
validate_access	(*(*(char)),int)->(int)
(	O
char	O
*	O
*	O
filep	*(*(char))
,	O
int	O
mode	*(char)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
fd	int
;	O
struct	O
dirlist	struct(*(char),int)
*	O
dirp	*(struct(*(char),int))
;	O
static	O
char	O
*	O
pathname	*(char)
=	O
0	int
;	O
char	O
*	O
filename	*(char)
=	O
*	O
filep	*(*(char))
;	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
filename	*(char)
,	O
"/../"	*(char)
)	O
)	O
return	O
(	O
EACCESS	int
)	O
;	O
if	O
(	O
*	O
filename	*(char)
==	O
'/'	O
)	O
{	O
for	O
(	O
dirp	*(struct(*(char),int))
=	O
dirs	array(struct(*(char),int))
;	O
dirp	*(struct(*(char),int))
->	O
name	*(char)
!=	O
NULL	O
;	O
dirp	*(struct(*(char),int))
++	O
)	O
{	O
if	O
(	O
dirp	*(struct(*(char),int))
->	O
len	int
==	O
1	int
||	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
filename	*(char)
,	O
dirp	*(struct(*(char),int))
->	O
name	*(char)
,	O
dirp	*(struct(*(char),int))
->	O
len	int
)	O
&&	O
filename	*(char)
[	O
dirp	*(struct(*(char),int))
->	O
len	int
]	O
==	O
'/'	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
dirp	*(struct(*(char),int))
->	O
name	*(char)
==	O
NULL	O
&&	O
dirp	*(struct(*(char),int))
!=	O
dirs	array(struct(*(char),int))
)	O
return	O
(	O
EACCESS	int
)	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
filename	*(char)
,	O
&	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
return	O
(	O
errno	O
==	O
ENOENT	int
?	O
ENOTFOUND	int
:	O
EACCESS	int
)	O
;	O
if	O
(	O
(	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
S_IFMT	O
)	O
!=	O
S_IFREG	O
)	O
return	O
(	O
ENOTFOUND	int
)	O
;	O
if	O
(	O
mode	*(char)
==	O
RRQ	int
)	O
{	O
if	O
(	O
(	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
S_IROTH	O
)	O
==	O
0	int
)	O
return	O
(	O
EACCESS	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
S_IWOTH	O
)	O
==	O
0	int
)	O
return	O
(	O
EACCESS	int
)	O
;	O
}	O
}	O
else	O
{	O
int	O
err	long
;	O
if	O
(	O
mode	*(char)
!=	O
RRQ	int
||	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
filename	*(char)
,	O
"../"	*(char)
,	O
3	int
)	O
)	O
return	O
(	O
EACCESS	int
)	O
;	O
err	long
=	O
ENOTFOUND	int
;	O
for	O
(	O
dirp	*(struct(*(char),int))
=	O
dirs	array(struct(*(char),int))
;	O
dirp	*(struct(*(char),int))
->	O
name	*(char)
!=	O
NULL	O
;	O
dirp	*(struct(*(char),int))
++	O
)	O
{	O
free	(*(void))->(void)
(	O
pathname	*(char)
)	O
;	O
pathname	*(char)
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
dirp	*(struct(*(char),int))
->	O
name	*(char)
)	O
+	O
1	int
+	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
pathname	*(char)
)	O
return	O
ENOMEM	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
pathname	*(char)
,	O
"%s/%s"	*(char)
,	O
dirp	*(struct(*(char),int))
->	O
name	*(char)
,	O
filename	*(char)
)	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
pathname	*(char)
,	O
&	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
&&	O
(	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
S_IFMT	O
)	O
==	O
S_IFREG	O
)	O
{	O
if	O
(	O
(	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
S_IROTH	O
)	O
!=	O
0	int
)	O
{	O
break	O
;	O
}	O
err	long
=	O
EACCESS	int
;	O
}	O
}	O
if	O
(	O
dirp	*(struct(*(char),int))
->	O
name	*(char)
==	O
NULL	O
)	O
return	O
(	O
err	long
)	O
;	O
*	O
filep	*(*(char))
=	O
filename	*(char)
=	O
pathname	*(char)
;	O
}	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
filename	*(char)
,	O
mode	*(char)
==	O
RRQ	int
?	O
O_RDONLY	int
:	O
(	O
O_WRONLY	int
|	O
O_TRUNC	int
)	O
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
(	O
errno	O
+	O
100	int
)	O
;	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fd	int
,	O
(	O
mode	*(char)
==	O
RRQ	int
)	O
?	O
"r"	*(char)
:	O
"w"	*(char)
)	O
;	O
if	O
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
return	O
errno	O
+	O
100	int
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
timeout	int
;	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
timeoutbuf	array(struct(array(long),int,struct(array(long))))
;	O
void	O
timer	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
timeout	int
+=	O
rexmtval	int
;	O
if	O
(	O
timeout	int
>=	O
maxtimeout	int
)	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
siglongjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
timeoutbuf	array(struct(array(long),int,struct(array(long))))
,	O
1	int
)	O
;	O
}	O
void	O
send_file	(*(struct))->(void)
(	O
struct	O
formats	struct(*(char),*((*(*(char)),int)->(int)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),int)
*	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
)	O
{	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
*	O
r_init	()->(*(struct(short,union(array(char),struct(union`,array(char)),array(char)))))
(	O
void	O
)	O
;	O
register	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
;	O
register	O
int	O
size	int
,	O
n	int
;	O
volatile	O
int	O
block	int
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGALRM	int
,	O
timer	(int)->(void)
)	O
;	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
=	O
r_init	()->(*(struct(short,union(array(char),struct(union`,array(char)),array(char)))))
(	O
)	O
;	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
=	O
(	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
)	O
ackbuf	array(char)
;	O
block	int
=	O
1	int
;	O
do	O
{	O
size	int
=	O
readit	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(struct(short,union(array(char),struct`,array(char))))),int)->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
->	O
f_convert	int
)	O
;	O
if	O
(	O
size	int
<	O
0	int
)	O
{	O
nak	(int)->(void)
(	O
errno	O
+	O
100	int
)	O
;	O
goto	O
abort	()->(void)
;	O
}	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
DATA	int
)	O
;	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
block	int
)	O
;	O
timeout	int
=	O
0	int
;	O
sigsetjmp	O
(	O
timeoutbuf	array(struct(array(long),int,struct(array(long))))
,	O
SIGALRM	int
)	O
;	O
send_data	O
:	O
if	O
(	O
sendto	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(long)
(	O
peer	int
,	O
(	O
const	O
char	O
*	O
)	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
size	int
+	O
4	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
from	struct(short,array(char),long)
,	O
fromlen	int
)	O
!=	O
size	int
+	O
4	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"tftpd: write: %m\n"	*(char)
)	O
;	O
goto	O
abort	()->(void)
;	O
}	O
read_ahead	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
->	O
f_convert	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
alarm	(int)->(int)
(	O
rexmtval	int
)	O
;	O
n	int
=	O
recv	(int,*(void),long,int)->(long)
(	O
peer	int
,	O
ackbuf	array(char)
,	O
sizeof	O
(	O
ackbuf	array(char)
)	O
,	O
0	int
)	O
;	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"tftpd: read: %m\n"	*(char)
)	O
;	O
goto	O
abort	()->(void)
;	O
}	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
=	O
ntohs	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
)	O
;	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
=	O
ntohs	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
)	O
;	O
if	O
(	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
==	O
ERROR	int
)	O
goto	O
abort	()->(void)
;	O
if	O
(	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
==	O
ACK	int
)	O
{	O
if	O
(	O
(	O
unsigned	O
short	O
)	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
==	O
(	O
unsigned	O
short	O
)	O
block	int
)	O
break	O
;	O
synchnet	(int)->(int)
(	O
peer	int
)	O
;	O
if	O
(	O
(	O
unsigned	O
short	O
)	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
==	O
(	O
unsigned	O
short	O
)	O
(	O
block	int
-	O
1	int
)	O
)	O
goto	O
send_data	O
;	O
}	O
}	O
block	int
++	O
;	O
}	O
while	O
(	O
size	int
==	O
SEGSIZE	int
)	O
;	O
abort	()->(void)
:	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
void	O
justquit	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
void	O
recvfile	(*(struct))->(void)
(	O
struct	O
formats	struct(*(char),*((*(*(char)),int)->(int)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),*((*(struct(*(char),*((*`,int)->(int)),*((*`)->(void)),*((*`)->(void)),int)))->(void)),int)
*	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
)	O
{	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
*	O
w_init	()->(*(struct(short,union(array(char),struct(union`,array(char)),array(char)))))
(	O
void	O
)	O
;	O
register	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
;	O
register	O
int	O
n	int
,	O
size	int
;	O
volatile	O
int	O
block	int
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGALRM	int
,	O
timer	(int)->(void)
)	O
;	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
=	O
w_init	()->(*(struct(short,union(array(char),struct(union`,array(char)),array(char)))))
(	O
)	O
;	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
=	O
(	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
)	O
ackbuf	array(char)
;	O
block	int
=	O
0	int
;	O
do	O
{	O
timeout	int
=	O
0	int
;	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
ACK	int
)	O
;	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
block	int
)	O
;	O
block	int
++	O
;	O
sigsetjmp	O
(	O
timeoutbuf	array(struct(array(long),int,struct(array(long))))
,	O
SIGALRM	int
)	O
;	O
send_ack	O
:	O
if	O
(	O
sendto	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(long)
(	O
peer	int
,	O
ackbuf	array(char)
,	O
4	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
from	struct(short,array(char),long)
,	O
fromlen	int
)	O
!=	O
4	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"tftpd: write: %m\n"	*(char)
)	O
;	O
goto	O
abort	()->(void)
;	O
}	O
write_behind	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
->	O
f_convert	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
alarm	(int)->(int)
(	O
rexmtval	int
)	O
;	O
n	int
=	O
recv	(int,*(void),long,int)->(long)
(	O
peer	int
,	O
(	O
char	O
*	O
)	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
PKTSIZE	O
,	O
0	int
)	O
;	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"tftpd: read: %m\n"	*(char)
)	O
;	O
goto	O
abort	()->(void)
;	O
}	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
=	O
ntohs	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
)	O
;	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
=	O
ntohs	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
)	O
;	O
if	O
(	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
==	O
ERROR	int
)	O
goto	O
abort	()->(void)
;	O
if	O
(	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
==	O
DATA	int
)	O
{	O
if	O
(	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
==	O
block	int
)	O
{	O
break	O
;	O
}	O
synchnet	(int)->(int)
(	O
peer	int
)	O
;	O
if	O
(	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
==	O
(	O
block	int
-	O
1	int
)	O
)	O
goto	O
send_ack	O
;	O
}	O
}	O
size	int
=	O
writeit	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(struct(short,union(array(char),struct`,array(char))))),int,int)->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
n	int
-	O
4	int
,	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
->	O
f_convert	int
)	O
;	O
if	O
(	O
size	int
!=	O
(	O
n	int
-	O
4	int
)	O
)	O
{	O
if	O
(	O
size	int
<	O
0	int
)	O
nak	(int)->(void)
(	O
errno	O
+	O
100	int
)	O
;	O
else	O
nak	(int)->(void)
(	O
ENOSPACE	int
)	O
;	O
goto	O
abort	()->(void)
;	O
}	O
}	O
while	O
(	O
size	int
==	O
SEGSIZE	int
)	O
;	O
write_behind	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
pf	*(struct(*(char),*((*(*`),int)->(int)),*((*(struct`))->(void)),*((*(struct`))->(void)),int))
->	O
f_convert	int
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
ACK	int
)	O
;	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
(	O
block	int
)	O
)	O
;	O
sendto	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(long)
(	O
peer	int
,	O
ackbuf	array(char)
,	O
4	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
from	struct(short,array(char),long)
,	O
fromlen	int
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGALRM	int
,	O
justquit	(int)->(void)
)	O
;	O
alarm	(int)->(int)
(	O
rexmtval	int
)	O
;	O
n	int
=	O
recv	(int,*(void),long,int)->(long)
(	O
peer	int
,	O
buf	array(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
,	O
0	int
)	O
;	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
if	O
(	O
n	int
>=	O
4	int
&&	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
==	O
DATA	int
&&	O
block	int
==	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
)	O
{	O
sendto	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(long)
(	O
peer	int
,	O
ackbuf	array(char)
,	O
4	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
from	struct(short,array(char),long)
,	O
fromlen	int
)	O
;	O
}	O
abort	()->(void)
:	O
return	O
;	O
}	O
struct	O
errmsg	struct(int,*(char))
{	O
int	O
e_code	int
;	O
const	O
char	O
*	O
e_msg	*(char)
;	O
}	O
errmsgs	array(struct(int,*(char)))
[	O
]	O
=	O
{	O
{	O
EUNDEF	int
,	O
"Undefined error code"	*(char)
}	O
,	O
{	O
ENOTFOUND	int
,	O
"File not found"	*(char)
}	O
,	O
{	O
EACCESS	int
,	O
"Access violation"	*(char)
}	O
,	O
{	O
ENOSPACE	int
,	O
"Disk full or allocation exceeded"	*(char)
}	O
,	O
{	O
EBADOP	int
,	O
"Illegal TFTP operation"	*(char)
}	O
,	O
{	O
EBADID	int
,	O
"Unknown transfer ID"	*(char)
}	O
,	O
{	O
EEXISTS	int
,	O
"File already exists"	*(char)
}	O
,	O
{	O
ENOUSER	int
,	O
"No such user"	*(char)
}	O
,	O
{	O
-	O
1	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
char	O
*	O
errtomsg	(int)->(*(char))
(	O
int	O
error	int
)	O
{	O
static	O
char	O
buf	array(char)
[	O
20	int
]	O
;	O
register	O
struct	O
errmsg	struct(int,*(char))
*	O
pe	*(struct(int,*(char)))
;	O
if	O
(	O
error	int
==	O
0	int
)	O
return	O
"success"	*(char)
;	O
for	O
(	O
pe	*(struct(int,*(char)))
=	O
errmsgs	array(struct(int,*(char)))
;	O
pe	*(struct(int,*(char)))
->	O
e_code	int
>=	O
0	int
;	O
pe	*(struct(int,*(char)))
++	O
)	O
if	O
(	O
pe	*(struct(int,*(char)))
->	O
e_code	int
==	O
error	int
)	O
return	O
pe	*(struct(int,*(char)))
->	O
e_msg	*(char)
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
"error %d"	*(char)
,	O
error	int
)	O
;	O
return	O
buf	array(char)
;	O
}	O
static	O
void	O
nak	(int)->(void)
(	O
int	O
error	int
)	O
{	O
register	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
;	O
int	O
length	int
;	O
register	O
struct	O
errmsg	struct(int,*(char))
*	O
pe	*(struct(int,*(char)))
;	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
=	O
(	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
)	O
buf	array(char)
;	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
ERROR	int
)	O
;	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_code	O
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
error	int
)	O
;	O
for	O
(	O
pe	*(struct(int,*(char)))
=	O
errmsgs	array(struct(int,*(char)))
;	O
pe	*(struct(int,*(char)))
->	O
e_code	int
>=	O
0	int
;	O
pe	*(struct(int,*(char)))
++	O
)	O
if	O
(	O
pe	*(struct(int,*(char)))
->	O
e_code	int
==	O
error	int
)	O
break	O
;	O
if	O
(	O
pe	*(struct(int,*(char)))
->	O
e_code	int
<	O
0	int
)	O
{	O
pe	*(struct(int,*(char)))
->	O
e_msg	*(char)
=	O
strerror	(int)->(*(char))
(	O
error	int
-	O
100	int
)	O
;	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_code	O
=	O
EUNDEF	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_msg	O
,	O
pe	*(struct(int,*(char)))
->	O
e_msg	*(char)
)	O
;	O
length	int
=	O
strlen	(*(char))->(long)
(	O
pe	*(struct(int,*(char)))
->	O
e_msg	*(char)
)	O
;	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_msg	O
[	O
length	int
]	O
=	O
'\0'	O
;	O
length	int
+=	O
5	int
;	O
if	O
(	O
sendto	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(long)
(	O
peer	int
,	O
buf	array(char)
,	O
length	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
from	struct(short,array(char),long)
,	O
fromlen	int
)	O
!=	O
length	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"nak: %m\n"	*(char)
)	O
;	O
}	O
static	O
const	O
char	O
*	O
verifyhost	(*(struct(short,array(char),long)),int)->(*(char))
(	O
struct	O
sockaddr_storage	struct(short,array(char),long)
*	O
fromp	*(struct(short,array(char),long))
,	O
socklen_t	int
frlen	int
)	O
{	O
int	O
rc	int
;	O
static	O
char	O
host	*(char)
[	O
NI_MAXHOST	int
]	O
;	O
rc	int
=	O
getnameinfo	(*(struct(short,array(char))),int,*(char),int,*(char),int,int)->(int)
(	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
fromp	*(struct(short,array(char),long))
,	O
frlen	int
,	O
host	*(char)
,	O
sizeof	O
(	O
host	*(char)
)	O
,	O
NULL	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
return	O
host	*(char)
;	O
else	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"getnameinfo: %s\n"	*(char)
,	O
gai_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
"0.0.0.0"	*(char)
;	O
}	O
}	O
static	O
const	O
char	O
usage_str	array(char)
[	O
]	O
=	O
"Usage: tftpd [OPTIONS...]\n"	*(char)
"\n"	*(char)
"Options are:\n"	*(char)
"   -l                      Enable logging\n"	*(char)
"   -n                      Supress negative acknowledgement of\n"	*(char)
"                           requests for nonexistent relative filenames\n"	*(char)
"       --help              Display usage instructions\n"	*(char)
"       --version           Display program version\n"	*(char)
;	O
void	O
usage	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
"Send bug reports to <%s>\n"	*(char)
,	O
usage_str	array(char)
,	O
PACKAGE_BUGREPORT	*(char)
)	O
;	O
}	O
