static	O
void	O
echo_off	(*(struct(int,int,int,int,char,array(char),int,int)))->(void)
(	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
*	O
stored_settings	*(struct(int,int,int,int,char,array(char),int,int))
)	O
{	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
new_settings	struct(int,int,int,int,char,array(char),int,int)
;	O
tcgetattr	(int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
0	int
,	O
stored_settings	*(struct(int,int,int,int,char,array(char),int,int))
)	O
;	O
new_settings	struct(int,int,int,int,char,array(char),int,int)
=	O
*	O
stored_settings	*(struct(int,int,int,int,char,array(char),int,int))
;	O
new_settings	struct(int,int,int,int,char,array(char),int,int)
.	O
c_lflag	int
&=	O
(	O
~	O
ECHO	int
)	O
;	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
0	int
,	O
TCSANOW	int
,	O
&	O
new_settings	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
}	O
static	O
void	O
echo_on	(*(struct(int,int,int,int,char,array(char),int,int)))->(void)
(	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
*	O
stored_settings	*(struct(int,int,int,int,char,array(char),int,int))
)	O
{	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
0	int
,	O
TCSANOW	int
,	O
stored_settings	*(struct(int,int,int,int,char,array(char),int,int))
)	O
;	O
}	O
int	O
mu_ticket_create	(*(*(struct)),*(void))->(int)
(	O
mu_ticket_t	*(struct)
*	O
pticket	*(*(struct))
,	O
void	O
*	O
owner	*(void)
)	O
{	O
mu_ticket_t	*(struct)
ticket	*(struct)
;	O
if	O
(	O
pticket	*(*(struct))
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
ticket	*(struct)
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
ticket	*(struct)
)	O
)	O
;	O
if	O
(	O
ticket	*(struct)
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
ticket	*(struct)
->	O
owner	*(void)
=	O
owner	*(void)
;	O
mu_ticket_ref	(*(struct))->(int)
(	O
ticket	*(struct)
)	O
;	O
*	O
pticket	*(*(struct))
=	O
ticket	*(struct)
;	O
return	O
0	int
;	O
}	O
int	O
mu_ticket_ref	(*(struct))->(int)
(	O
mu_ticket_t	*(struct)
ticket	*(struct)
)	O
{	O
if	O
(	O
!	O
ticket	*(struct)
)	O
return	O
EINVAL	int
;	O
ticket	*(struct)
->	O
refcnt	int
++	O
;	O
return	O
0	int
;	O
}	O
int	O
mu_ticket_unref	(*(struct))->(int)
(	O
mu_ticket_t	*(struct)
ticket	*(struct)
)	O
{	O
if	O
(	O
!	O
ticket	*(struct)
)	O
return	O
EINVAL	int
;	O
if	O
(	O
ticket	*(struct)
->	O
refcnt	int
)	O
ticket	*(struct)
->	O
refcnt	int
--	O
;	O
if	O
(	O
ticket	*(struct)
->	O
refcnt	int
==	O
0	int
)	O
{	O
if	O
(	O
ticket	*(struct)
->	O
plain	*(char)
)	O
free	(*(void))->(void)
(	O
ticket	*(struct)
->	O
plain	*(char)
)	O
;	O
if	O
(	O
ticket	*(struct)
->	O
secret	*(struct)
)	O
mu_secret_destroy	(*(*(struct)))->(void)
(	O
&	O
ticket	*(struct)
->	O
secret	*(struct)
)	O
;	O
if	O
(	O
ticket	*(struct)
->	O
_destroy	*((*(struct))->(void))
)	O
ticket	*(struct)
->	O
_destroy	*((*(struct))->(void))
(	O
ticket	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
ticket	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
return	O
MU_ERR_EXISTS	O
;	O
}	O
void	O
mu_ticket_destroy	(*(*(struct)))->(void)
(	O
mu_ticket_t	*(struct)
*	O
pticket	*(*(struct))
)	O
{	O
if	O
(	O
pticket	*(*(struct))
&&	O
*	O
pticket	*(*(struct))
&&	O
mu_ticket_unref	(*(struct))->(int)
(	O
*	O
pticket	*(*(struct))
)	O
==	O
0	int
)	O
*	O
pticket	*(*(struct))
=	O
NULL	O
;	O
}	O
int	O
mu_ticket_set_destroy	(*(struct),*((*(struct))->(void)),*(void))->(int)
(	O
mu_ticket_t	*(struct)
ticket	*(struct)
,	O
void	O
(	O
*	O
_destroy	*((*(struct))->(void))
)	O
(	O
mu_ticket_t	*(struct)
)	O
,	O
void	O
*	O
owner	*(void)
)	O
{	O
if	O
(	O
ticket	*(struct)
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
ticket	*(struct)
->	O
owner	*(void)
!=	O
owner	*(void)
)	O
return	O
EACCES	int
;	O
ticket	*(struct)
->	O
_destroy	*((*(struct))->(void))
=	O
_destroy	*((*(struct))->(void))
;	O
return	O
0	int
;	O
}	O
void	O
*	O
mu_ticket_get_owner	(*(struct))->(*(void))
(	O
mu_ticket_t	*(struct)
ticket	*(struct)
)	O
{	O
return	O
(	O
ticket	*(struct)
)	O
?	O
ticket	*(struct)
->	O
owner	*(void)
:	O
NULL	O
;	O
}	O
int	O
mu_ticket_set_get_cred	(*(struct),*((*(struct),*(struct),*(char),*(*(char)),*(*(struct`)))->(int)),*(void))->(int)
(	O
mu_ticket_t	*(struct)
ticket	*(struct)
,	O
int	O
(	O
*	O
_get_cred	*((*(struct(*(void),int,*(char),*(struct`),*((*`)->(void)),*((*`,*`,*`,*`,*`)->(int)),*(void))),*(struct),*(char),*(*(char)),*(*(struct)))->(int))
)	O
(	O
mu_ticket_t	*(struct)
,	O
mu_url_t	*(struct)
,	O
const	O
char	O
*	O
,	O
char	O
*	O
*	O
,	O
mu_secret_t	*(struct)
*	O
)	O
,	O
void	O
*	O
owner	*(void)
)	O
{	O
if	O
(	O
ticket	*(struct)
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
ticket	*(struct)
->	O
owner	*(void)
!=	O
owner	*(void)
)	O
return	O
EACCES	int
;	O
ticket	*(struct)
->	O
_get_cred	*((*(struct(*(void),int,*(char),*(struct`),*((*`)->(void)),*((*`,*`,*`,*`,*`)->(int)),*(void))),*(struct),*(char),*(*(char)),*(*(struct)))->(int))
=	O
_get_cred	*((*(struct(*(void),int,*(char),*(struct`),*((*`)->(void)),*((*`,*`,*`,*`,*`)->(int)),*(void))),*(struct),*(char),*(*(char)),*(*(struct)))->(int))
;	O
return	O
0	int
;	O
}	O
int	O
mu_ticket_set_secret	(*(struct),*(struct))->(int)
(	O
mu_ticket_t	*(struct)
ticket	*(struct)
,	O
mu_secret_t	*(struct)
secret	*(struct)
)	O
{	O
if	O
(	O
ticket	*(struct)
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
ticket	*(struct)
->	O
secret	*(struct)
)	O
mu_secret_unref	(*(struct))->(int)
(	O
ticket	*(struct)
->	O
secret	*(struct)
)	O
;	O
mu_secret_ref	(*(struct))->(void)
(	O
secret	*(struct)
)	O
;	O
ticket	*(struct)
->	O
secret	*(struct)
=	O
secret	*(struct)
;	O
return	O
0	int
;	O
}	O
int	O
mu_ticket_set_plain	(*(struct),*(char))->(int)
(	O
mu_ticket_t	*(struct)
ticket	*(struct)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
if	O
(	O
ticket	*(struct)
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
ticket	*(struct)
->	O
plain	*(char)
)	O
free	(*(void))->(void)
(	O
ticket	*(struct)
->	O
plain	*(char)
)	O
;	O
ticket	*(struct)
->	O
plain	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
text	*(char)
)	O
;	O
if	O
(	O
!	O
ticket	*(struct)
->	O
plain	*(char)
)	O
return	O
ENOMEM	int
;	O
return	O
0	int
;	O
}	O
int	O
mu_ticket_get_cred	(*(struct),*(struct),*(char),*(*(char)),*(*(struct)))->(int)
(	O
mu_ticket_t	*(struct)
ticket	*(struct)
,	O
mu_url_t	*(struct)
url	*(struct)
,	O
const	O
char	O
*	O
challenge	*(char)
,	O
char	O
*	O
*	O
pplain	*(*(char))
,	O
mu_secret_t	*(struct)
*	O
psec	*(*(struct))
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
char	O
arg	array(char)
[	O
256	int
]	O
;	O
if	O
(	O
ticket	*(struct)
==	O
NULL	O
||	O
(	O
pplain	*(*(char))
&&	O
psec	*(*(struct))
)	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
pplain	*(*(char))
==	O
NULL	O
&&	O
psec	*(*(struct))
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
if	O
(	O
ticket	*(struct)
->	O
_get_cred	*((*(struct(*(void),int,*(char),*(struct`),*((*`)->(void)),*((*`,*`,*`,*`,*`)->(int)),*(void))),*(struct),*(char),*(*(char)),*(*(struct)))->(int))
)	O
{	O
int	O
res	*(int)
=	O
ticket	*(struct)
->	O
_get_cred	*((*(struct(*(void),int,*(char),*(struct`),*((*`)->(void)),*((*`,*`,*`,*`,*`)->(int)),*(void))),*(struct),*(char),*(*(char)),*(*(struct)))->(int))
(	O
ticket	*(struct)
,	O
url	*(struct)
,	O
challenge	*(char)
,	O
pplain	*(*(char))
,	O
psec	*(*(struct))
)	O
;	O
if	O
(	O
res	*(int)
==	O
0	int
)	O
return	O
res	*(int)
;	O
}	O
if	O
(	O
pplain	*(*(char))
&&	O
ticket	*(struct)
->	O
plain	*(char)
)	O
{	O
*	O
pplain	*(*(char))
=	O
strdup	(*(char))->(*(char))
(	O
ticket	*(struct)
->	O
plain	*(char)
)	O
;	O
if	O
(	O
!	O
*	O
pplain	*(*(char))
)	O
return	O
ENOMEM	int
;	O
}	O
if	O
(	O
psec	*(*(struct))
&&	O
ticket	*(struct)
->	O
secret	*(struct)
)	O
{	O
mu_secret_ref	(*(struct))->(void)
(	O
ticket	*(struct)
->	O
secret	*(struct)
)	O
;	O
*	O
psec	*(*(struct))
=	O
ticket	*(struct)
->	O
secret	*(struct)
;	O
return	O
0	int
;	O
}	O
if	O
(	O
isatty	(int)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
{	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
stored_settings	*(struct(int,int,int,int,char,array(char),int,int))
;	O
int	O
echo	int
=	O
pplain	*(*(char))
!=	O
NULL	O
;	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
challenge	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
echo	int
)	O
echo_off	(*(struct(int,int,int,int,char,array(char),int,int)))->(void)
(	O
&	O
stored_settings	*(struct(int,int,int,int,char,array(char),int,int))
)	O
;	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
arg	array(char)
,	O
sizeof	O
(	O
arg	array(char)
)	O
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
echo	int
)	O
{	O
echo_on	(*(struct(int,int,int,int,char,array(char),int,int)))->(void)
(	O
&	O
stored_settings	*(struct(int,int,int,int,char,array(char),int,int))
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
arg	array(char)
[	O
strlen	(*(char))->(long)
(	O
arg	array(char)
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
return	O
MU_ERR_FAILURE	O
;	O
if	O
(	O
pplain	*(*(char))
)	O
{	O
*	O
pplain	*(*(char))
=	O
strdup	(*(char))->(*(char))
(	O
arg	array(char)
)	O
;	O
if	O
(	O
!	O
*	O
pplain	*(*(char))
)	O
return	O
ENOMEM	int
;	O
}	O
else	O
rc	int
=	O
mu_secret_create	(*(*(struct)),*(char),long)->(int)
(	O
psec	*(*(struct))
,	O
arg	array(char)
,	O
strlen	(*(char))->(long)
(	O
arg	array(char)
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
void	O
*	O
mu_ticket_get_data	(*(struct))->(*(void))
(	O
mu_ticket_t	*(struct)
ticket	*(struct)
)	O
{	O
if	O
(	O
!	O
ticket	*(struct)
)	O
return	O
NULL	O
;	O
return	O
ticket	*(struct)
->	O
data	*(void)
;	O
}	O
int	O
mu_ticket_set_data	(*(struct),*(void),*(void))->(int)
(	O
mu_ticket_t	*(struct)
ticket	*(struct)
,	O
void	O
*	O
data	*(void)
,	O
void	O
*	O
owner	*(void)
)	O
{	O
if	O
(	O
ticket	*(struct)
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
ticket	*(struct)
->	O
owner	*(void)
!=	O
owner	*(void)
)	O
return	O
EACCES	int
;	O
ticket	*(struct)
->	O
data	*(void)
=	O
data	*(void)
;	O
return	O
0	int
;	O
}	O
