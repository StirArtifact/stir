OBJID	long
EDMAPROC	O
_edma_clone_simple_obj	(long,long)->(long)
(	O
OBJID	long
IdObj	long
,	O
ESint32	long
copy	long
)	O
{	O
OBJID	long
id	long
;	O
CLASSID	long
idc	long
;	O
EChar	char
ClassNam1	array(char)
[	O
EDMA_CLASS_NAME_LEN	int
]	O
;	O
ESint32	long
i	long
,	O
n	long
,	O
offset	long
;	O
EDMAT_BUFFER	struct(long,long,*(void))
*	O
src_pbuf	*(struct(long,long,*(void)))
,	O
*	O
dest_pbuf	*(struct(long,long,*(void)))
;	O
EPByte	*(char)
src_ptr	*(char)
,	O
dest_ptr	*(char)
;	O
idc	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
ClassNam1	array(char)
,	O
gClass	O
[	O
idc	long
]	O
->	O
ClassName	array(char)
)	O
;	O
if	O
(	O
(	O
id	long
=	O
_edma_newobj_basic_stage	(long,long,*(void))->(long)
(	O
idc	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdSIU	long
,	O
NULL	O
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_shallow_clone] Basic Stage Failed."	*(char)
"Can't create object of class '%s'"	*(char)
,	O
ClassNam1	array(char)
)	O
;	O
if	O
(	O
(	O
_edma_newobj_vm_stage	(long)->(long)
(	O
id	long
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_new_obj] Virtual Method Stage "	*(char)
"Failed. "	*(char)
"Can't create object of class '%s'"	*(char)
,	O
ClassNam1	array(char)
)	O
;	O
if	O
(	O
(	O
_edma_newobj_final_stage	(long,*(char),*(void))->(long)
(	O
id	long
,	O
NULL	O
,	O
NULL	O
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_new_obj] Final Stage Failed. "	*(char)
"can't create object of class '%s'"	*(char)
,	O
ClassNam1	array(char)
)	O
;	O
memcpy	(*(void),*(void),int)->(*(void))
(	O
gObj	O
[	O
id	long
]	O
->	O
Data	*(void)
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	*(void)
,	O
gClass	O
[	O
idc	long
]	O
->	O
TamDatos	long
)	O
;	O
if	O
(	O
copy	long
)	O
{	O
n	long
=	O
gClass	O
[	O
idc	long
]	O
->	O
nProp	short
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
idc	long
]	O
->	O
nProp	short
;	O
i	long
++	O
)	O
{	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
idc	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
i	long
]	O
.	O
nElem	long
>	O
0	int
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"[DEBUG] CloneObj. Located ARRAY type... "	*(char)
"Still Not implemented"	*(char)
)	O
;	O
}	O
offset	long
=	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
idc	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
i	long
]	O
.	O
Off	short
;	O
src_ptr	*(char)
=	O
(	O
EPByte	*(char)
)	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	*(void)
)	O
+	O
offset	long
;	O
dest_ptr	*(char)
=	O
(	O
EPByte	*(char)
)	O
(	O
gObj	O
[	O
id	long
]	O
->	O
Data	*(void)
)	O
+	O
offset	long
;	O
switch	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
idc	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
i	long
]	O
.	O
Tipo	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
src_pbuf	*(struct(long,long,*(void)))
=	O
(	O
EDMAT_BUFFER	struct(long,long,*(void))
*	O
)	O
src_ptr	*(char)
;	O
dest_pbuf	*(struct(long,long,*(void)))
=	O
(	O
EDMAT_BUFFER	struct(long,long,*(void))
*	O
)	O
dest_ptr	*(char)
;	O
if	O
(	O
(	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(long)
(	O
dest_pbuf	*(struct(long,long,*(void)))
,	O
src_pbuf	*(struct(long,long,*(void)))
->	O
Size	long
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[%s] Can't allocate buffer for "	*(char)
"cloned object"	*(char)
,	O
__FUNCTION__	O
)	O
;	O
}	O
memcpy	(*(void),*(void),int)->(*(void))
(	O
dest_pbuf	*(struct(long,long,*(void)))
->	O
dat	*(void)
,	O
src_pbuf	*(struct(long,long,*(void)))
->	O
dat	*(void)
,	O
src_pbuf	*(struct(long,long,*(void)))
->	O
Size	long
)	O
;	O
break	O
;	O
case	O
DT_EZSTRING	int
:	O
edma_log	(*(char))->(long)
(	O
"[%s] Clonning string '%s'"	*(char)
,	O
__FUNCTION__	O
,	O
*	O
(	O
EPChar	*(char)
*	O
)	O
src_ptr	*(char)
)	O
;	O
if	O
(	O
(	O
*	O
(	O
EPChar	*(char)
*	O
)	O
src_ptr	*(char)
)	O
)	O
*	O
(	O
EPChar	*(char)
*	O
)	O
dest_ptr	*(char)
=	O
(	O
EPChar	*(char)
)	O
strdup	(*(char))->(*(char))
(	O
*	O
(	O
EPChar	*(char)
*	O
)	O
src_ptr	*(char)
)	O
;	O
else	O
*	O
(	O
EPChar	*(char)
*	O
)	O
dest_ptr	*(char)
=	O
(	O
EPChar	*(char)
)	O
NULL	O
;	O
break	O
;	O
}	O
}	O
}	O
return	O
id	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_clone_subobjects	(long,long)->(long)
(	O
OBJID	long
IdObj	long
,	O
OBJID	long
id_from	long
)	O
{	O
OBJID	long
id_subobj	long
,	O
aux	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
ESint32	long
i	long
,	O
n	long
,	O
i1	long
,	O
n1	long
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
n	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
nUpTable	long
;	O
if	O
(	O
n	long
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
aux	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
;	O
id_subobj	long
=	O
_edma_clone_simple_obj	(long,long)->(long)
(	O
aux	long
,	O
1	int
)	O
;	O
if	O
(	O
id_subobj	long
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[%s] Can't clone subobject...."	*(char)
,	O
__FUNCTION__	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
aux	long
]	O
;	O
edma_add_superobject	(long,long,*(char))->(long)
(	O
id_from	long
,	O
id_subobj	long
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	*(char)
)	O
;	O
n1	long
=	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
;	O
if	O
(	O
n1	long
)	O
{	O
for	O
(	O
i1	long
=	O
0	int
;	O
i1	long
<	O
n1	long
;	O
i1	long
++	O
)	O
if	O
(	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i1	long
]	O
.	O
Obj	long
==	O
IdObj	long
)	O
break	O
;	O
edma_add_subobject	(long,long,*(char))->(long)
(	O
id_subobj	long
,	O
id_from	long
,	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i1	long
]	O
.	O
Id	*(char)
)	O
;	O
}	O
else	O
{	O
edma_log	(*(char))->(long)
(	O
"[%s] WARNNING... subobject has no uplink"	*(char)
,	O
__FUNCTION__	O
)	O
;	O
}	O
_edma_clone_subobjects	(long,long)->(long)
(	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdObj	long
,	O
id_subobj	long
)	O
;	O
}	O
return	O
0	int
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_clone_superobjects	(long,long)->(long)
(	O
OBJID	long
IdObj	long
,	O
OBJID	long
id_from	long
)	O
{	O
OBJID	long
id_subobj	long
,	O
aux	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
ESint32	long
i	long
,	O
n	long
,	O
i1	long
,	O
n1	long
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
n	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
nDownTable	long
;	O
if	O
(	O
n	long
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
aux	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
;	O
id_subobj	long
=	O
_edma_clone_simple_obj	(long,long)->(long)
(	O
aux	long
,	O
1	int
)	O
;	O
if	O
(	O
id_subobj	long
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[%s] Can't clone subobject...."	*(char)
,	O
__FUNCTION__	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
aux	long
]	O
;	O
edma_add_subobject	(long,long,*(char))->(long)
(	O
id_from	long
,	O
id_subobj	long
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	*(char)
)	O
;	O
n1	long
=	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nUpTable	long
;	O
if	O
(	O
n1	long
)	O
{	O
for	O
(	O
i1	long
=	O
0	int
;	O
i1	long
<	O
n1	long
;	O
i1	long
++	O
)	O
if	O
(	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i1	long
]	O
.	O
Obj	long
==	O
IdObj	long
)	O
break	O
;	O
edma_add_superobject	(long,long,*(char))->(long)
(	O
id_subobj	long
,	O
id_from	long
,	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i1	long
]	O
.	O
Id	*(char)
)	O
;	O
}	O
else	O
{	O
edma_log	(*(char))->(long)
(	O
"[%s] WARNNING... subobject has no uplink"	*(char)
,	O
__FUNCTION__	O
)	O
;	O
}	O
_edma_clone_superobjects	(long,long)->(long)
(	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdObj	long
,	O
id_subobj	long
)	O
;	O
}	O
return	O
0	int
;	O
}	O
OBJID	long
EDMAPROC	O
edma_clone_obj	(long)->(long)
(	O
OBJID	long
IdObj	long
)	O
{	O
OBJID	long
id_clone	long
;	O
if	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_clone_obj"	*(char)
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
id_clone	long
=	O
_edma_clone_simple_obj	(long,long)->(long)
(	O
IdObj	long
,	O
1	int
)	O
;	O
_edma_clone_superobjects	(long,long)->(long)
(	O
IdObj	long
,	O
id_clone	long
)	O
;	O
_edma_clone_subobjects	(long,long)->(long)
(	O
IdObj	long
,	O
id_clone	long
)	O
;	O
return	O
id_clone	long
;	O
}	O
OBJID	long
EDMAPROC	O
edma_shallow_clone_obj	(long)->(long)
(	O
OBJID	long
IdObj	long
)	O
{	O
OBJID	long
id	long
;	O
EChar	char
aux	long
[	O
EDMA_GENERAL_ID_LEN	int
]	O
;	O
ESint32	long
i	long
,	O
n	long
;	O
if	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_shallow_clone_obj"	*(char)
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
id	long
=	O
_edma_clone_simple_obj	(long,long)->(long)
(	O
IdObj	long
,	O
1	int
)	O
;	O
n	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
nUpTable	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
aux	long
,	O
"child-%ld-%ld"	*(char)
,	O
id	long
,	O
i	long
)	O
;	O
edma_add_superobject	(long,long,*(char))->(long)
(	O
id	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	*(char)
)	O
;	O
edma_add_subobject	(long,long,*(char))->(long)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
,	O
id	long
,	O
aux	long
)	O
;	O
}	O
return	O
id	long
;	O
}	O
