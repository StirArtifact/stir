static	O
char	O
my_name	array(char)
[	O
]	O
=	O
"(default pager):"	*(char)
;	O
static	O
void	O
__attribute__	O
(	O
(	O
format	O
(	O
printf	O
,	O
1	int
,	O
2	int
)	O
,	O
unused	O
)	O
)	O
synchronized_printf	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
static	O
pthread_mutex_t	O
printf_lock	int
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
va_list	O
ap	O
;	O
va_start	O
(	O
ap	O
,	O
fmt	*(char)
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
printf_lock	int
)	O
;	O
vprintf	O
(	O
fmt	*(char)
,	O
ap	O
)	O
;	O
fflush	()->(int)
(	O
stdout	O
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
printf_lock	int
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
}	O
partition_t	O
partition_of	(int)->(int)
(	O
x	int
)	O
int	O
x	int
;	O
{	O
if	O
(	O
x	int
>=	O
all_partitions	O
.	O
n_partitions	O
||	O
x	int
<	O
0	int
)	O
panic	()->(int)
(	O
"partition_of x%x"	*(char)
,	O
x	int
)	O
;	O
return	O
all_partitions	O
.	O
partition_list	O
[	O
x	int
]	O
;	O
}	O
void	O
set_partition_of	()->(int)
(	O
x	int
,	O
p	int
)	O
int	O
x	int
;	O
partition_t	O
p	int
;	O
{	O
if	O
(	O
x	int
>=	O
all_partitions	O
.	O
n_partitions	O
||	O
x	int
<	O
0	int
)	O
panic	()->(int)
(	O
"set_partition_of x%x"	*(char)
,	O
x	int
)	O
;	O
all_partitions	O
.	O
partition_list	O
[	O
x	int
]	O
=	O
p	int
;	O
}	O
unsigned	O
int	O
part_id	(*(char))->(int)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
unsigned	O
int	O
id	int
,	O
xorid	int
;	O
size_t	O
len	int
;	O
len	int
=	O
strlen	O
(	O
name	*(char)
)	O
;	O
id	int
=	O
xorid	int
=	O
0	int
;	O
while	O
(	O
len	int
--	O
)	O
{	O
xorid	int
^=	O
*	O
name	*(char)
;	O
id	int
+=	O
*	O
name	*(char)
++	O
;	O
}	O
return	O
(	O
id	int
<<	O
8	int
)	O
|	O
xorid	int
;	O
}	O
void	O
partition_init	()->(void)
(	O
)	O
{	O
pthread_mutex_init	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
,	O
NULL	O
)	O
;	O
all_partitions	O
.	O
n_partitions	O
=	O
0	int
;	O
}	O
static	O
partition_t	O
new_partition	(*(char),*(struct),int)->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
struct	O
file_direct	O
*	O
fdp	*(struct)
,	O
int	O
check_linux_signature	int
)	O
{	O
partition_t	O
part	int
;	O
vm_size_t	O
size	int
,	O
bmsize	O
;	O
vm_offset_t	O
raddr	O
;	O
mach_msg_type_number_t	O
rsize	O
;	O
int	O
rc	int
;	O
unsigned	O
int	O
id	int
=	O
part_id	(*(char))->(int)
(	O
name	*(char)
)	O
;	O
unsigned	O
int	O
n	int
=	O
strlen	O
(	O
name	*(char)
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
{	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
all_partitions	O
.	O
n_partitions	O
;	O
i	int
++	O
)	O
{	O
part	int
=	O
partition_of	(int)->(int)
(	O
i	int
)	O
;	O
if	O
(	O
part	int
&&	O
part	int
->	O
id	int
==	O
id	int
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
size	int
=	O
atop	O
(	O
fdp	*(struct)
->	O
fd_size	O
*	O
fdp	*(struct)
->	O
fd_bsize	O
)	O
;	O
bmsize	O
=	O
howmany	()->(int)
(	O
size	int
,	O
NB_BM	O
)	O
*	O
sizeof	O
(	O
bm_entry_t	O
)	O
;	O
part	int
=	O
(	O
partition_t	O
)	O
kalloc	()->(int)
(	O
sizeof	O
(	O
struct	O
part	int
)	O
)	O
;	O
pthread_mutex_init	()->(int)
(	O
&	O
part	int
->	O
p_lock	O
,	O
NULL	O
)	O
;	O
part	int
->	O
name	*(char)
=	O
(	O
char	O
*	O
)	O
kalloc	()->(int)
(	O
n	int
+	O
1	int
)	O
;	O
strcpy	O
(	O
part	int
->	O
name	*(char)
,	O
name	*(char)
)	O
;	O
part	int
->	O
total_size	O
=	O
size	int
;	O
part	int
->	O
free	*(int)
=	O
size	int
;	O
part	int
->	O
id	int
=	O
id	int
;	O
part	int
->	O
bitmap	O
=	O
(	O
bm_entry_t	O
*	O
)	O
kalloc	()->(int)
(	O
bmsize	O
)	O
;	O
part	int
->	O
going_away	O
=	O
FALSE	O
;	O
part	int
->	O
file	O
=	O
fdp	*(struct)
;	O
memset	O
(	O
(	O
char	O
*	O
)	O
part	int
->	O
bitmap	O
,	O
0	int
,	O
bmsize	O
)	O
;	O
if	O
(	O
check_linux_signature	int
<	O
0	int
)	O
{	O
if	O
(	O
check_linux_signature	int
!=	O
-	O
3	int
)	O
printf	O
(	O
"(default pager): "	*(char)
"Paging to raw partition %s (%uk paging space)\n"	*(char)
,	O
name	*(char)
,	O
part	int
->	O
total_size	O
*	O
(	O
vm_page_size	O
/	O
1024	int
)	O
)	O
;	O
return	O
part	int
;	O
}	O
rc	int
=	O
page_read_file_direct	()->(int)
(	O
part	int
->	O
file	O
,	O
0	int
,	O
LINUX_PAGE_SIZE	int
,	O
&	O
raddr	O
,	O
&	O
rsize	O
)	O
;	O
if	O
(	O
rc	int
)	O
panic	()->(int)
(	O
"(default pager): cannot read first page of %s! rc=%#x\n"	*(char)
,	O
name	*(char)
,	O
rc	int
)	O
;	O
while	O
(	O
rsize	O
<	O
LINUX_PAGE_SIZE	int
)	O
{	O
vm_address_t	O
baddr	O
;	O
vm_size_t	O
bsize	O
;	O
rc	int
=	O
page_read_file_direct	()->(int)
(	O
part	int
->	O
file	O
,	O
rsize	O
,	O
LINUX_PAGE_SIZE	int
-	O
rsize	O
,	O
&	O
baddr	O
,	O
&	O
bsize	O
)	O
;	O
if	O
(	O
rc	int
)	O
panic	()->(int)
(	O
"(default pager): "	*(char)
"cannot read first page of %s! rc=%#x at %#x\n"	*(char)
,	O
name	*(char)
,	O
rc	int
,	O
rsize	O
)	O
;	O
memcpy	O
(	O
(	O
char	O
*	O
)	O
raddr	O
+	O
rsize	O
,	O
(	O
void	O
*	O
)	O
baddr	O
,	O
bsize	O
)	O
;	O
rsize	O
+=	O
bsize	O
;	O
vm_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
baddr	O
,	O
bsize	O
)	O
;	O
}	O
if	O
(	O
!	O
memcmp	O
(	O
"SWAP-SPACE"	*(char)
,	O
(	O
char	O
*	O
)	O
raddr	O
+	O
LINUX_PAGE_SIZE	int
-	O
10	int
,	O
10	int
)	O
)	O
{	O
unsigned	O
int	O
i	int
,	O
j	int
,	O
bad	int
,	O
max	int
;	O
int	O
waste	int
;	O
printf	O
(	O
"(default pager): Found Linux 2.0 swap signature in %s\n"	*(char)
,	O
name	*(char)
)	O
;	O
*	O
(	O
u_int32_t	O
*	O
)	O
raddr	O
&=	O
~	O
(	O
u_int32_t	O
)	O
1	int
;	O
memset	O
(	O
(	O
char	O
*	O
)	O
raddr	O
+	O
LINUX_PAGE_SIZE	int
-	O
10	int
,	O
0	int
,	O
10	int
)	O
;	O
max	int
=	O
LINUX_PAGE_SIZE	int
/	O
sizeof	O
(	O
u_int32_t	O
)	O
;	O
if	O
(	O
max	int
>	O
(	O
part	int
->	O
total_size	O
+	O
31	int
)	O
/	O
32	int
)	O
max	int
=	O
(	O
part	int
->	O
total_size	O
+	O
31	int
)	O
/	O
32	int
;	O
bad	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
max	int
;	O
++	O
i	int
)	O
{	O
u_int32_t	O
bm	O
=	O
(	O
(	O
u_int32_t	O
*	O
)	O
raddr	O
)	O
[	O
i	int
]	O
;	O
if	O
(	O
bm	O
==	O
~	O
(	O
u_int32_t	O
)	O
0	int
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
32	int
;	O
++	O
j	int
)	O
if	O
(	O
(	O
bm	O
&	O
(	O
1	int
<<	O
j	int
)	O
)	O
==	O
0	int
)	O
{	O
unsigned	O
int	O
p	int
=	O
i	int
*	O
32	int
+	O
j	int
;	O
if	O
(	O
p	int
>=	O
part	int
->	O
total_size	O
)	O
break	O
;	O
++	O
bad	int
;	O
part	int
->	O
bitmap	O
[	O
p	int
/	O
NB_BM	O
]	O
|=	O
1	int
<<	O
(	O
p	int
%	O
NB_BM	O
)	O
;	O
}	O
}	O
part	int
->	O
free	*(int)
-=	O
bad	int
;	O
--	O
bad	int
;	O
waste	int
=	O
part	int
->	O
total_size	O
-	O
(	O
8	int
*	O
(	O
LINUX_PAGE_SIZE	int
-	O
10	int
)	O
)	O
;	O
if	O
(	O
waste	int
>	O
0	int
)	O
{	O
bad	int
-=	O
waste	int
;	O
if	O
(	O
bad	int
>	O
0	int
)	O
printf	O
(	O
"(default pager): Paging to %s, %dk swap-space (%dk bad, %dk wasted at end)\n"	*(char)
,	O
name	*(char)
,	O
part	int
->	O
free	*(int)
*	O
(	O
LINUX_PAGE_SIZE	int
/	O
1024	int
)	O
,	O
bad	int
*	O
(	O
LINUX_PAGE_SIZE	int
/	O
1024	int
)	O
,	O
waste	int
*	O
(	O
LINUX_PAGE_SIZE	int
/	O
1024	int
)	O
)	O
;	O
else	O
printf	O
(	O
"(default pager): Paging to %s, %dk swap-space (%dk wasted at end)\n"	*(char)
,	O
name	*(char)
,	O
part	int
->	O
free	*(int)
*	O
(	O
LINUX_PAGE_SIZE	int
/	O
1024	int
)	O
,	O
waste	int
*	O
(	O
LINUX_PAGE_SIZE	int
/	O
1024	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
bad	int
>	O
0	int
)	O
printf	O
(	O
"(default pager): Paging to %s, %dk swap-space (excludes %dk marked bad)\n"	*(char)
,	O
name	*(char)
,	O
part	int
->	O
free	*(int)
*	O
(	O
LINUX_PAGE_SIZE	int
/	O
1024	int
)	O
,	O
bad	int
*	O
(	O
LINUX_PAGE_SIZE	int
/	O
1024	int
)	O
)	O
;	O
else	O
printf	O
(	O
"(default pager): Paging to %s, %dk swap-space\n"	*(char)
,	O
name	*(char)
,	O
part	int
->	O
free	*(int)
*	O
(	O
LINUX_PAGE_SIZE	int
/	O
1024	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
memcmp	O
(	O
"SWAPSPACE2"	*(char)
,	O
(	O
char	O
*	O
)	O
raddr	O
+	O
LINUX_PAGE_SIZE	int
-	O
10	int
,	O
10	int
)	O
)	O
{	O
struct	O
{	O
u_int8_t	O
bootbits	array(int)
[	O
1024	int
]	O
;	O
u_int32_t	O
version	int
;	O
u_int32_t	O
last_page	int
;	O
u_int32_t	O
nr_badpages	int
;	O
u_int32_t	O
padding	array(int)
[	O
125	int
]	O
;	O
u_int32_t	O
badpages	array(int)
[	O
1	int
]	O
;	O
}	O
*	O
hdr	*(struct(array(int),int,int,int,array(int),array(int)))
=	O
(	O
void	O
*	O
)	O
raddr	O
;	O
printf	O
(	O
"(default pager): Found Linux 2.2 swap signature (v%u) in %s..."	*(char)
,	O
hdr	*(struct(array(int),int,int,int,array(int),array(int)))
->	O
version	int
,	O
name	*(char)
)	O
;	O
part	int
->	O
bitmap	O
[	O
0	int
]	O
|=	O
1	int
;	O
part	int
->	O
free	*(int)
--	O
;	O
switch	O
(	O
hdr	*(struct(array(int),int,int,int,array(int),array(int)))
->	O
version	int
)	O
{	O
default	O
:	O
if	O
(	O
check_linux_signature	int
)	O
{	O
printf	O
(	O
"version %u unknown!  SKIPPING %s!\n"	*(char)
,	O
hdr	*(struct(array(int),int,int,int,array(int),array(int)))
->	O
version	int
,	O
name	*(char)
)	O
;	O
vm_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
raddr	O
,	O
rsize	O
)	O
;	O
kfree	()->(int)
(	O
part	int
->	O
bitmap	O
,	O
bmsize	O
)	O
;	O
kfree	()->(int)
(	O
part	int
->	O
name	*(char)
,	O
strlen	O
(	O
part	int
->	O
name	*(char)
)	O
+	O
1	int
)	O
;	O
kfree	()->(int)
(	O
part	int
,	O
sizeof	O
*	O
part	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
printf	O
(	O
"version %u unknown! IGNORING SIGNATURE PAGE!"	*(char)
" %dk swap-space\n"	*(char)
,	O
hdr	*(struct(array(int),int,int,int,array(int),array(int)))
->	O
version	int
,	O
part	int
->	O
free	*(int)
*	O
(	O
LINUX_PAGE_SIZE	int
/	O
1024	int
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
{	O
unsigned	O
int	O
waste	int
,	O
i	int
;	O
if	O
(	O
hdr	*(struct(array(int),int,int,int,array(int),array(int)))
->	O
last_page	int
>	O
part	int
->	O
total_size	O
)	O
{	O
printf	O
(	O
"signature says %uk, partition has only %uk! "	*(char)
,	O
hdr	*(struct(array(int),int,int,int,array(int),array(int)))
->	O
last_page	int
*	O
(	O
LINUX_PAGE_SIZE	int
/	O
1024	int
)	O
,	O
part	int
->	O
total_size	O
*	O
(	O
LINUX_PAGE_SIZE	int
/	O
1024	int
)	O
)	O
;	O
waste	int
=	O
0	int
;	O
}	O
else	O
{	O
waste	int
=	O
part	int
->	O
total_size	O
-	O
hdr	*(struct(array(int),int,int,int,array(int),array(int)))
->	O
last_page	int
;	O
part	int
->	O
total_size	O
=	O
hdr	*(struct(array(int),int,int,int,array(int),array(int)))
->	O
last_page	int
;	O
part	int
->	O
free	*(int)
=	O
part	int
->	O
total_size	O
-	O
1	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
hdr	*(struct(array(int),int,int,int,array(int),array(int)))
->	O
nr_badpages	int
;	O
++	O
i	int
)	O
{	O
const	O
u_int32_t	O
bad	int
=	O
hdr	*(struct(array(int),int,int,int,array(int),array(int)))
->	O
badpages	array(int)
[	O
i	int
]	O
;	O
part	int
->	O
bitmap	O
[	O
bad	int
/	O
NB_BM	O
]	O
|=	O
1	int
<<	O
(	O
bad	int
%	O
NB_BM	O
)	O
;	O
part	int
->	O
free	*(int)
--	O
;	O
}	O
printf	O
(	O
"%uk swap-space"	*(char)
,	O
part	int
->	O
free	*(int)
*	O
(	O
LINUX_PAGE_SIZE	int
/	O
1024	int
)	O
)	O
;	O
if	O
(	O
hdr	*(struct(array(int),int,int,int,array(int),array(int)))
->	O
nr_badpages	int
!=	O
0	int
)	O
printf	O
(	O
" (excludes %uk marked bad)"	*(char)
,	O
hdr	*(struct(array(int),int,int,int,array(int),array(int)))
->	O
nr_badpages	int
*	O
(	O
LINUX_PAGE_SIZE	int
/	O
1024	int
)	O
)	O
;	O
if	O
(	O
waste	int
!=	O
0	int
)	O
printf	O
(	O
" (excludes %uk at end of partition)"	*(char)
,	O
waste	int
*	O
(	O
LINUX_PAGE_SIZE	int
/	O
1024	int
)	O
)	O
;	O
printf	O
(	O
"\n"	*(char)
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
check_linux_signature	int
)	O
{	O
printf	O
(	O
"(default pager): "	*(char)
"Cannot find Linux swap signature page!  "	*(char)
"SKIPPING %s (%uk partition)!"	*(char)
,	O
name	*(char)
,	O
part	int
->	O
total_size	O
*	O
(	O
vm_page_size	O
/	O
1024	int
)	O
)	O
;	O
kfree	()->(int)
(	O
part	int
->	O
bitmap	O
,	O
bmsize	O
)	O
;	O
kfree	()->(int)
(	O
part	int
->	O
name	*(char)
,	O
strlen	O
(	O
part	int
->	O
name	*(char)
)	O
+	O
1	int
)	O
;	O
kfree	()->(int)
(	O
part	int
,	O
sizeof	O
*	O
part	int
)	O
;	O
part	int
=	O
0	int
;	O
}	O
else	O
printf	O
(	O
"(default pager): "	*(char)
"Paging to raw partition %s (%uk paging space)\n"	*(char)
,	O
name	*(char)
,	O
part	int
->	O
total_size	O
*	O
(	O
vm_page_size	O
/	O
1024	int
)	O
)	O
;	O
vm_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
raddr	O
,	O
rsize	O
)	O
;	O
return	O
part	int
;	O
}	O
void	O
create_paging_partition	(*(char),*(struct),int,int)->(void)
(	O
const	O
char	O
*	O
name	*(char)
,	O
struct	O
file_direct	O
*	O
fdp	*(struct)
,	O
int	O
isa_file	int
,	O
int	O
linux_signature	int
)	O
{	O
partition_t	O
part	int
;	O
part	int
=	O
new_partition	(*(char),*(struct),int)->(int)
(	O
name	*(char)
,	O
fdp	*(struct)
,	O
linux_signature	int
)	O
;	O
if	O
(	O
!	O
part	int
)	O
return	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
all_partitions	O
.	O
n_partitions	O
;	O
i	int
++	O
)	O
if	O
(	O
partition_of	(int)->(int)
(	O
i	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	int
==	O
all_partitions	O
.	O
n_partitions	O
)	O
{	O
partition_t	O
*	O
new_list	O
,	O
*	O
old_list	O
;	O
int	O
n	int
;	O
n	int
=	O
i	int
?	O
(	O
i	int
<<	O
1	int
)	O
:	O
2	int
;	O
new_list	O
=	O
(	O
partition_t	O
*	O
)	O
kalloc	()->(int)
(	O
n	int
*	O
sizeof	O
(	O
partition_t	O
)	O
)	O
;	O
if	O
(	O
new_list	O
==	O
0	int
)	O
no_paging_space	()->(int)
(	O
TRUE	O
)	O
;	O
memset	O
(	O
new_list	O
,	O
0	int
,	O
n	int
*	O
sizeof	O
(	O
partition_t	O
)	O
)	O
;	O
if	O
(	O
i	int
)	O
{	O
old_list	O
=	O
all_partitions	O
.	O
partition_list	O
;	O
memcpy	O
(	O
new_list	O
,	O
old_list	O
,	O
i	int
*	O
sizeof	O
(	O
partition_t	O
)	O
)	O
;	O
}	O
all_partitions	O
.	O
partition_list	O
=	O
new_list	O
;	O
all_partitions	O
.	O
n_partitions	O
=	O
n	int
;	O
if	O
(	O
i	int
)	O
kfree	()->(int)
(	O
old_list	O
,	O
i	int
*	O
sizeof	O
(	O
partition_t	O
)	O
)	O
;	O
}	O
set_partition_of	()->(int)
(	O
i	int
,	O
part	int
)	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
overcommitted	()->(int)
(	O
TRUE	O
,	O
part	int
->	O
free	*(int)
)	O
;	O
}	O
p_index_t	O
choose_partition	()->(int)
(	O
size	int
,	O
cur_part	int
)	O
unsigned	O
int	O
size	int
;	O
p_index_t	O
cur_part	int
;	O
{	O
partition_t	O
part	int
;	O
boolean_t	O
found	O
=	O
FALSE	O
;	O
int	O
i	int
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
all_partitions	O
.	O
n_partitions	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
cur_part	int
)	O
continue	O
;	O
ddprintf	O
(	O
"choose_partition(%x,%d,%d)\n"	*(char)
,	O
size	int
,	O
cur_part	int
,	O
i	int
)	O
;	O
if	O
(	O
(	O
part	int
=	O
partition_of	(int)->(int)
(	O
i	int
)	O
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
part	int
->	O
going_away	O
)	O
continue	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
part	int
->	O
p_lock	O
)	O
;	O
if	O
(	O
ptoa	O
(	O
part	int
->	O
free	*(int)
)	O
>=	O
size	int
)	O
{	O
if	O
(	O
cur_part	int
!=	O
P_INDEX_INVALID	O
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
return	O
(	O
p_index_t	O
)	O
i	int
;	O
}	O
else	O
found	O
=	O
TRUE	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
part	int
->	O
p_lock	O
)	O
;	O
if	O
(	O
found	O
)	O
break	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
return	O
(	O
found	O
)	O
?	O
(	O
p_index_t	O
)	O
i	int
:	O
P_INDEX_INVALID	O
;	O
}	O
vm_offset_t	O
pager_alloc_page	()->(int)
(	O
pindex	int
,	O
lock_it	int
)	O
p_index_t	O
pindex	int
;	O
boolean_t	O
lock_it	int
;	O
{	O
int	O
bm_e	O
;	O
int	O
bit	O
;	O
int	O
limit	int
;	O
bm_entry_t	O
*	O
bm	O
;	O
partition_t	O
part	int
;	O
static	O
char	O
here	array(char)
[	O
]	O
=	O
"%spager_alloc_page"	*(char)
;	O
if	O
(	O
no_partition	()->(int)
(	O
pindex	int
)	O
)	O
return	O
(	O
NO_BLOCK	O
)	O
;	O
ddprintf	O
(	O
"pager_alloc_page(%d,%d)\n"	*(char)
,	O
pindex	int
,	O
lock_it	int
)	O
;	O
part	int
=	O
partition_of	(int)->(int)
(	O
pindex	int
)	O
;	O
if	O
(	O
!	O
part	int
||	O
part	int
->	O
going_away	O
)	O
return	O
(	O
NO_BLOCK	O
)	O
;	O
if	O
(	O
lock_it	int
)	O
pthread_mutex_lock	()->(int)
(	O
&	O
part	int
->	O
p_lock	O
)	O
;	O
if	O
(	O
part	int
->	O
free	*(int)
==	O
0	int
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
part	int
->	O
p_lock	O
)	O
;	O
return	O
(	O
NO_BLOCK	O
)	O
;	O
}	O
limit	int
=	O
howmany	()->(int)
(	O
part	int
->	O
total_size	O
,	O
NB_BM	O
)	O
;	O
bm	O
=	O
part	int
->	O
bitmap	O
;	O
for	O
(	O
bm_e	O
=	O
0	int
;	O
bm_e	O
<	O
limit	int
;	O
bm_e	O
++	O
,	O
bm	O
++	O
)	O
if	O
(	O
*	O
bm	O
!=	O
BM_MASK	O
)	O
break	O
;	O
if	O
(	O
bm_e	O
==	O
limit	int
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
{	O
bm_entry_t	O
b	O
=	O
*	O
bm	O
;	O
for	O
(	O
bit	O
=	O
0	int
;	O
bit	O
<	O
NB_BM	O
;	O
bit	O
++	O
)	O
if	O
(	O
(	O
b	O
&	O
(	O
1	int
<<	O
bit	O
)	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
bit	O
==	O
NB_BM	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
*	O
bm	O
=	O
b	O
|	O
(	O
1	int
<<	O
bit	O
)	O
;	O
part	int
->	O
free	*(int)
--	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
part	int
->	O
p_lock	O
)	O
;	O
return	O
(	O
bm_e	O
*	O
NB_BM	O
+	O
bit	O
)	O
;	O
}	O
void	O
pager_dealloc_page	()->(int)
(	O
pindex	int
,	O
page	int
,	O
lock_it	int
)	O
p_index_t	O
pindex	int
;	O
vm_offset_t	O
page	int
;	O
boolean_t	O
lock_it	int
;	O
{	O
partition_t	O
part	int
;	O
int	O
bit	O
,	O
bm_e	O
;	O
if	O
(	O
no_partition	()->(int)
(	O
pindex	int
)	O
)	O
panic	()->(int)
(	O
"%sdealloc_page"	*(char)
,	O
my_name	array(char)
)	O
;	O
ddprintf	O
(	O
"pager_dealloc_page(%d,%lx,%d)\n"	*(char)
,	O
pindex	int
,	O
page	int
,	O
lock_it	int
)	O
;	O
part	int
=	O
partition_of	(int)->(int)
(	O
pindex	int
)	O
;	O
if	O
(	O
page	int
>=	O
part	int
->	O
total_size	O
)	O
panic	()->(int)
(	O
"%sdealloc_page"	*(char)
,	O
my_name	array(char)
)	O
;	O
bm_e	O
=	O
page	int
/	O
NB_BM	O
;	O
bit	O
=	O
page	int
%	O
NB_BM	O
;	O
if	O
(	O
lock_it	int
)	O
pthread_mutex_lock	()->(int)
(	O
&	O
part	int
->	O
p_lock	O
)	O
;	O
part	int
->	O
bitmap	O
[	O
bm_e	O
]	O
&=	O
~	O
(	O
1	int
<<	O
bit	O
)	O
;	O
part	int
->	O
free	*(int)
++	O
;	O
if	O
(	O
lock_it	int
)	O
pthread_mutex_unlock	()->(int)
(	O
&	O
part	int
->	O
p_lock	O
)	O
;	O
}	O
vm_size_t	O
max_doubled_size	int
=	O
4	int
*	O
1024	int
*	O
1024	int
;	O
dp_map_t	O
pager_get_direct_map	O
(	O
pager	int
)	O
dpager_t	O
pager	int
;	O
{	O
dp_map_t	O
mapptr	int
,	O
emapptr	O
;	O
vm_size_t	O
size	int
=	O
pager	int
->	O
size	int
;	O
if	O
(	O
pager	int
->	O
map	O
)	O
return	O
pager	int
->	O
map	O
;	O
{	O
vm_size_t	O
alloc_size	O
;	O
dp_map_t	O
init_value	O
;	O
if	O
(	O
INDIRECT_PAGEMAP	()->(int)
(	O
size	int
)	O
)	O
{	O
alloc_size	O
=	O
INDIRECT_PAGEMAP_SIZE	()->(int)
(	O
size	int
)	O
;	O
init_value	O
=	O
(	O
dp_map_t	O
)	O
0	int
;	O
}	O
else	O
{	O
alloc_size	O
=	O
PAGEMAP_SIZE	()->(int)
(	O
size	int
)	O
;	O
init_value	O
=	O
(	O
dp_map_t	O
)	O
NO_BLOCK	O
;	O
}	O
mapptr	int
=	O
(	O
dp_map_t	O
)	O
kalloc	()->(int)
(	O
alloc_size	O
)	O
;	O
for	O
(	O
emapptr	O
=	O
&	O
mapptr	int
[	O
(	O
alloc_size	O
-	O
1	int
)	O
/	O
sizeof	O
(	O
vm_offset_t	O
)	O
]	O
;	O
emapptr	O
>=	O
mapptr	int
;	O
emapptr	O
--	O
)	O
emapptr	O
->	O
indirect	O
=	O
init_value	O
;	O
}	O
pager	int
->	O
map	O
=	O
mapptr	int
;	O
return	O
mapptr	int
;	O
}	O
void	O
pager_alloc	O
(	O
pager	int
,	O
part	int
,	O
size	int
)	O
dpager_t	O
pager	int
;	O
p_index_t	O
part	int
;	O
vm_size_t	O
size	int
;	O
{	O
int	O
i	int
;	O
pthread_mutex_init	()->(int)
(	O
&	O
pager	int
->	O
lock	O
,	O
NULL	O
)	O
;	O
pager	int
->	O
cur_partition	O
=	O
part	int
;	O
size	int
=	O
atop	O
(	O
size	int
)	O
;	O
if	O
(	O
size	int
<=	O
atop	O
(	O
max_doubled_size	int
)	O
)	O
{	O
i	int
=	O
1	int
;	O
while	O
(	O
i	int
<	O
size	int
)	O
i	int
<<=	O
1	int
;	O
size	int
=	O
i	int
;	O
}	O
else	O
size	int
=	O
ROUNDUP_TO_PAGEMAP	O
(	O
size	int
)	O
;	O
pager	int
->	O
map	O
=	O
NULL	O
;	O
pager	int
->	O
size	int
=	O
size	int
;	O
pager	int
->	O
limit	int
=	O
(	O
vm_size_t	O
)	O
-	O
1	int
;	O
}	O
vm_size_t	O
pager_allocated	O
(	O
pager	int
)	O
dpager_t	O
pager	int
;	O
{	O
vm_size_t	O
size	int
;	O
dp_map_t	O
map	O
,	O
emap	O
;	O
vm_size_t	O
asize	O
;	O
size	int
=	O
pager	int
->	O
size	int
;	O
asize	O
=	O
0	int
;	O
map	O
=	O
pager_get_direct_map	O
(	O
pager	int
)	O
;	O
if	O
(	O
INDIRECT_PAGEMAP	()->(int)
(	O
size	int
)	O
)	O
{	O
for	O
(	O
emap	O
=	O
&	O
map	O
[	O
INDIRECT_PAGEMAP_ENTRIES	()->(int)
(	O
size	int
)	O
]	O
;	O
map	O
<	O
emap	O
;	O
map	O
++	O
)	O
{	O
dp_map_t	O
map2	O
,	O
emap2	O
;	O
if	O
(	O
(	O
map2	O
=	O
map	O
->	O
indirect	O
)	O
==	O
0	int
)	O
continue	O
;	O
for	O
(	O
emap2	O
=	O
&	O
map2	O
[	O
PAGEMAP_ENTRIES	O
]	O
;	O
map2	O
<	O
emap2	O
;	O
map2	O
++	O
)	O
if	O
(	O
!	O
no_block	()->(int)
(	O
*	O
map2	O
)	O
)	O
asize	O
++	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
emap	O
=	O
&	O
map	O
[	O
size	int
]	O
;	O
map	O
<	O
emap	O
;	O
map	O
++	O
)	O
if	O
(	O
!	O
no_block	()->(int)
(	O
*	O
map	O
)	O
)	O
asize	O
++	O
;	O
}	O
return	O
ptoa	O
(	O
asize	O
)	O
;	O
}	O
unsigned	O
int	O
pager_pages	()->(int)
(	O
pager	int
,	O
pages	*(int)
,	O
numpages	int
)	O
dpager_t	O
pager	int
;	O
default_pager_page_t	O
*	O
pages	*(int)
;	O
unsigned	O
int	O
numpages	int
;	O
{	O
vm_size_t	O
size	int
;	O
dp_map_t	O
map	O
,	O
emap	O
;	O
unsigned	O
int	O
actual	int
;	O
vm_offset_t	O
offset	int
;	O
size	int
=	O
pager	int
->	O
size	int
;	O
map	O
=	O
pager_get_direct_map	O
(	O
pager	int
)	O
;	O
actual	int
=	O
0	int
;	O
offset	int
=	O
0	int
;	O
if	O
(	O
INDIRECT_PAGEMAP	()->(int)
(	O
size	int
)	O
)	O
{	O
for	O
(	O
emap	O
=	O
&	O
map	O
[	O
INDIRECT_PAGEMAP_ENTRIES	()->(int)
(	O
size	int
)	O
]	O
;	O
map	O
<	O
emap	O
;	O
map	O
++	O
)	O
{	O
dp_map_t	O
map2	O
,	O
emap2	O
;	O
if	O
(	O
(	O
map2	O
=	O
map	O
->	O
indirect	O
)	O
==	O
0	int
)	O
{	O
offset	int
+=	O
vm_page_size	O
*	O
PAGEMAP_ENTRIES	O
;	O
continue	O
;	O
}	O
for	O
(	O
emap2	O
=	O
&	O
map2	O
[	O
PAGEMAP_ENTRIES	O
]	O
;	O
map2	O
<	O
emap2	O
;	O
map2	O
++	O
)	O
if	O
(	O
!	O
no_block	()->(int)
(	O
*	O
map2	O
)	O
)	O
{	O
if	O
(	O
actual	int
++	O
<	O
numpages	int
)	O
pages	*(int)
++	O
->	O
dpp_offset	O
=	O
offset	int
;	O
}	O
offset	int
+=	O
vm_page_size	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
emap	O
=	O
&	O
map	O
[	O
size	int
]	O
;	O
map	O
<	O
emap	O
;	O
map	O
++	O
)	O
{	O
if	O
(	O
!	O
no_block	()->(int)
(	O
*	O
map	O
)	O
)	O
{	O
if	O
(	O
actual	int
++	O
<	O
numpages	int
)	O
pages	*(int)
++	O
->	O
dpp_offset	O
=	O
offset	int
;	O
}	O
offset	int
+=	O
vm_page_size	O
;	O
}	O
}	O
return	O
actual	int
;	O
}	O
void	O
pager_extend	O
(	O
pager	int
,	O
new_size	int
)	O
dpager_t	O
pager	int
;	O
vm_size_t	O
new_size	int
;	O
{	O
dp_map_t	O
new_mapptr	O
;	O
dp_map_t	O
old_mapptr	int
;	O
int	O
i	int
;	O
vm_size_t	O
old_size	int
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
pager	int
->	O
lock	O
)	O
;	O
old_size	int
=	O
pager	int
->	O
size	int
;	O
if	O
(	O
new_size	int
<=	O
atop	O
(	O
max_doubled_size	int
)	O
)	O
{	O
i	int
=	O
old_size	int
?	O
old_size	int
:	O
1	int
;	O
while	O
(	O
i	int
<	O
new_size	int
)	O
i	int
<<=	O
1	int
;	O
new_size	int
=	O
i	int
;	O
}	O
else	O
new_size	int
=	O
ROUNDUP_TO_PAGEMAP	O
(	O
new_size	int
)	O
;	O
if	O
(	O
INDIRECT_PAGEMAP	()->(int)
(	O
old_size	int
)	O
)	O
{	O
new_mapptr	O
=	O
(	O
dp_map_t	O
)	O
kalloc	()->(int)
(	O
INDIRECT_PAGEMAP_SIZE	()->(int)
(	O
new_size	int
)	O
)	O
;	O
old_mapptr	int
=	O
pager_get_direct_map	O
(	O
pager	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
INDIRECT_PAGEMAP_ENTRIES	()->(int)
(	O
old_size	int
)	O
;	O
i	int
++	O
)	O
new_mapptr	O
[	O
i	int
]	O
=	O
old_mapptr	int
[	O
i	int
]	O
;	O
for	O
(	O
;	O
i	int
<	O
INDIRECT_PAGEMAP_ENTRIES	()->(int)
(	O
new_size	int
)	O
;	O
i	int
++	O
)	O
new_mapptr	O
[	O
i	int
]	O
.	O
indirect	O
=	O
(	O
dp_map_t	O
)	O
0	int
;	O
kfree	()->(int)
(	O
(	O
char	O
*	O
)	O
old_mapptr	int
,	O
INDIRECT_PAGEMAP_SIZE	()->(int)
(	O
old_size	int
)	O
)	O
;	O
pager	int
->	O
map	O
=	O
new_mapptr	O
;	O
pager	int
->	O
size	int
=	O
new_size	int
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
pager	int
->	O
lock	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
INDIRECT_PAGEMAP	()->(int)
(	O
new_size	int
)	O
)	O
{	O
new_mapptr	O
=	O
(	O
dp_map_t	O
)	O
kalloc	()->(int)
(	O
PAGEMAP_SIZE	()->(int)
(	O
PAGEMAP_ENTRIES	O
)	O
)	O
;	O
old_mapptr	int
=	O
pager_get_direct_map	O
(	O
pager	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
old_size	int
;	O
i	int
++	O
)	O
new_mapptr	O
[	O
i	int
]	O
=	O
old_mapptr	int
[	O
i	int
]	O
;	O
for	O
(	O
;	O
i	int
<	O
PAGEMAP_ENTRIES	O
;	O
i	int
++	O
)	O
invalidate_block	()->(int)
(	O
new_mapptr	O
[	O
i	int
]	O
)	O
;	O
kfree	()->(int)
(	O
(	O
char	O
*	O
)	O
old_mapptr	int
,	O
PAGEMAP_SIZE	()->(int)
(	O
old_size	int
)	O
)	O
;	O
old_mapptr	int
=	O
new_mapptr	O
;	O
new_mapptr	O
=	O
(	O
dp_map_t	O
)	O
kalloc	()->(int)
(	O
INDIRECT_PAGEMAP_SIZE	()->(int)
(	O
new_size	int
)	O
)	O
;	O
new_mapptr	O
[	O
0	int
]	O
.	O
indirect	O
=	O
old_mapptr	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
INDIRECT_PAGEMAP_ENTRIES	()->(int)
(	O
new_size	int
)	O
;	O
i	int
++	O
)	O
new_mapptr	O
[	O
i	int
]	O
.	O
indirect	O
=	O
0	int
;	O
pager	int
->	O
map	O
=	O
new_mapptr	O
;	O
pager	int
->	O
size	int
=	O
new_size	int
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
pager	int
->	O
lock	O
)	O
;	O
return	O
;	O
}	O
new_mapptr	O
=	O
(	O
dp_map_t	O
)	O
kalloc	()->(int)
(	O
PAGEMAP_SIZE	()->(int)
(	O
new_size	int
)	O
)	O
;	O
old_mapptr	int
=	O
pager_get_direct_map	O
(	O
pager	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
old_size	int
;	O
i	int
++	O
)	O
new_mapptr	O
[	O
i	int
]	O
=	O
old_mapptr	int
[	O
i	int
]	O
;	O
for	O
(	O
;	O
i	int
<	O
new_size	int
;	O
i	int
++	O
)	O
invalidate_block	()->(int)
(	O
new_mapptr	O
[	O
i	int
]	O
)	O
;	O
kfree	()->(int)
(	O
(	O
char	O
*	O
)	O
old_mapptr	int
,	O
PAGEMAP_SIZE	()->(int)
(	O
old_size	int
)	O
)	O
;	O
pager	int
->	O
map	O
=	O
new_mapptr	O
;	O
pager	int
->	O
size	int
=	O
new_size	int
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
pager	int
->	O
lock	O
)	O
;	O
}	O
static	O
void	O
dealloc_direct	(int,int,int)->(void)
(	O
dp_map_t	O
mapptr	int
,	O
vm_size_t	O
old_size	int
,	O
vm_size_t	O
new_size	int
)	O
{	O
vm_size_t	O
i	int
;	O
if	O
(	O
!	O
mapptr	int
)	O
return	O
;	O
for	O
(	O
i	int
=	O
new_size	int
;	O
i	int
<	O
old_size	int
;	O
++	O
i	int
)	O
{	O
const	O
union	O
dp_map	O
entry	union
=	O
mapptr	int
[	O
i	int
]	O
;	O
if	O
(	O
!	O
no_block	()->(int)
(	O
entry	union
)	O
)	O
{	O
pager_dealloc_page	()->(int)
(	O
entry	union
.	O
block	union
.	O
p_index	O
,	O
entry	union
.	O
block	union
.	O
p_offset	O
,	O
TRUE	O
)	O
;	O
invalidate_block	()->(int)
(	O
mapptr	int
[	O
i	int
]	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
pager_truncate	(int,int)->(void)
(	O
dpager_t	O
pager	int
,	O
vm_size_t	O
new_size	int
)	O
{	O
int	O
i	int
;	O
vm_size_t	O
old_size	int
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
pager	int
->	O
lock	O
)	O
;	O
if	O
(	O
!	O
pager	int
->	O
map	O
)	O
goto	O
done	O
;	O
old_size	int
=	O
pager	int
->	O
size	int
;	O
if	O
(	O
INDIRECT_PAGEMAP	()->(int)
(	O
old_size	int
)	O
)	O
{	O
for	O
(	O
i	int
=	O
INDIRECT_PAGEMAP_ENTRIES	()->(int)
(	O
new_size	int
)	O
;	O
i	int
<	O
INDIRECT_PAGEMAP_ENTRIES	()->(int)
(	O
old_size	int
)	O
;	O
++	O
i	int
)	O
{	O
const	O
dp_map_t	O
mapptr	int
=	O
pager	int
->	O
map	O
[	O
i	int
]	O
.	O
indirect	O
;	O
pager	int
->	O
map	O
[	O
i	int
]	O
.	O
indirect	O
=	O
(	O
dp_map_t	O
)	O
0	int
;	O
dealloc_direct	(int,int,int)->(void)
(	O
mapptr	int
,	O
PAGEMAP_ENTRIES	O
,	O
0	int
)	O
;	O
kfree	()->(int)
(	O
(	O
char	O
*	O
)	O
mapptr	int
,	O
PAGEMAP_SIZE	()->(int)
(	O
PAGEMAP_ENTRIES	O
)	O
)	O
;	O
}	O
dealloc_direct	(int,int,int)->(void)
(	O
pager	int
->	O
map	O
[	O
(	O
new_size	int
-	O
1	int
)	O
/	O
PAGEMAP_ENTRIES	O
]	O
.	O
indirect	O
,	O
old_size	int
&	O
(	O
PAGEMAP_ENTRIES	O
-	O
1	int
)	O
,	O
new_size	int
&	O
(	O
PAGEMAP_ENTRIES	O
-	O
1	int
)	O
)	O
;	O
if	O
(	O
INDIRECT_PAGEMAP	()->(int)
(	O
new_size	int
)	O
)	O
{	O
const	O
dp_map_t	O
old_mapptr	int
=	O
pager	int
->	O
map	O
;	O
pager	int
->	O
map	O
=	O
(	O
dp_map_t	O
)	O
kalloc	()->(int)
(	O
INDIRECT_PAGEMAP_SIZE	()->(int)
(	O
new_size	int
)	O
)	O
;	O
memcpy	O
(	O
pager	int
->	O
map	O
,	O
old_mapptr	int
,	O
INDIRECT_PAGEMAP_SIZE	()->(int)
(	O
new_size	int
)	O
)	O
;	O
kfree	()->(int)
(	O
(	O
char	O
*	O
)	O
old_mapptr	int
,	O
INDIRECT_PAGEMAP_SIZE	()->(int)
(	O
old_size	int
)	O
)	O
;	O
}	O
else	O
{	O
const	O
dp_map_t	O
mapptr	int
=	O
pager	int
->	O
map	O
[	O
0	int
]	O
.	O
indirect	O
;	O
kfree	()->(int)
(	O
(	O
char	O
*	O
)	O
pager	int
->	O
map	O
,	O
INDIRECT_PAGEMAP_SIZE	()->(int)
(	O
old_size	int
)	O
)	O
;	O
pager	int
->	O
map	O
=	O
mapptr	int
;	O
}	O
}	O
if	O
(	O
!	O
INDIRECT_PAGEMAP	()->(int)
(	O
old_size	int
)	O
)	O
{	O
dealloc_direct	(int,int,int)->(void)
(	O
pager	int
->	O
map	O
,	O
old_size	int
,	O
new_size	int
)	O
;	O
if	O
(	O
PAGEMAP_SIZE	()->(int)
(	O
new_size	int
)	O
<=	O
PAGEMAP_SIZE	()->(int)
(	O
old_size	int
)	O
/	O
2	int
)	O
{	O
const	O
dp_map_t	O
old_mapptr	int
=	O
pager	int
->	O
map	O
;	O
pager	int
->	O
map	O
=	O
(	O
dp_map_t	O
)	O
kalloc	()->(int)
(	O
PAGEMAP_SIZE	()->(int)
(	O
new_size	int
)	O
)	O
;	O
memcpy	O
(	O
pager	int
->	O
map	O
,	O
old_mapptr	int
,	O
PAGEMAP_SIZE	()->(int)
(	O
new_size	int
)	O
)	O
;	O
kfree	()->(int)
(	O
(	O
char	O
*	O
)	O
old_mapptr	int
,	O
PAGEMAP_SIZE	()->(int)
(	O
old_size	int
)	O
)	O
;	O
}	O
}	O
done	O
:	O
pager	int
->	O
size	int
=	O
new_size	int
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
pager	int
->	O
lock	O
)	O
;	O
}	O
union	O
dp_map	O
pager_read_offset	O
(	O
pager	int
,	O
offset	int
)	O
dpager_t	O
pager	int
;	O
vm_offset_t	O
offset	int
;	O
{	O
vm_offset_t	O
f_page	O
;	O
union	O
dp_map	O
pager_offset	O
;	O
f_page	O
=	O
atop	O
(	O
offset	int
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
pager	int
->	O
lock	O
)	O
;	O
if	O
(	O
f_page	O
>=	O
pager	int
->	O
size	int
)	O
{	O
ddprintf	O
(	O
"%spager_read_offset pager %p: bad page %ld >= size %d"	*(char)
,	O
my_name	array(char)
,	O
pager	int
,	O
f_page	O
,	O
pager	int
->	O
size	int
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
pager	int
->	O
lock	O
)	O
;	O
return	O
(	O
union	O
dp_map	O
)	O
(	O
union	O
dp_map	O
*	O
)	O
NO_BLOCK	O
;	O
}	O
invalidate_block	()->(int)
(	O
pager_offset	O
)	O
;	O
if	O
(	O
INDIRECT_PAGEMAP	()->(int)
(	O
pager	int
->	O
size	int
)	O
)	O
{	O
dp_map_t	O
mapptr	int
;	O
if	O
(	O
pager	int
->	O
map	O
)	O
{	O
mapptr	int
=	O
pager	int
->	O
map	O
[	O
f_page	O
/	O
PAGEMAP_ENTRIES	O
]	O
.	O
indirect	O
;	O
if	O
(	O
mapptr	int
)	O
pager_offset	O
=	O
mapptr	int
[	O
f_page	O
%	O
PAGEMAP_ENTRIES	O
]	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
pager	int
->	O
map	O
)	O
pager_offset	O
=	O
pager	int
->	O
map	O
[	O
f_page	O
]	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
pager	int
->	O
lock	O
)	O
;	O
return	O
(	O
pager_offset	O
)	O
;	O
}	O
void	O
pager_release_offset	O
(	O
pager	int
,	O
offset	int
)	O
dpager_t	O
pager	int
;	O
vm_offset_t	O
offset	int
;	O
{	O
union	O
dp_map	O
entry	union
;	O
offset	int
=	O
atop	O
(	O
offset	int
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
pager	int
->	O
lock	O
)	O
;	O
assert	O
(	O
pager	int
->	O
map	O
)	O
;	O
if	O
(	O
INDIRECT_PAGEMAP	()->(int)
(	O
pager	int
->	O
size	int
)	O
)	O
{	O
dp_map_t	O
mapptr	int
;	O
mapptr	int
=	O
pager	int
->	O
map	O
[	O
offset	int
/	O
PAGEMAP_ENTRIES	O
]	O
.	O
indirect	O
;	O
entry	union
=	O
mapptr	int
[	O
offset	int
%	O
PAGEMAP_ENTRIES	O
]	O
;	O
invalidate_block	()->(int)
(	O
mapptr	int
[	O
offset	int
%	O
PAGEMAP_ENTRIES	O
]	O
)	O
;	O
}	O
else	O
{	O
entry	union
=	O
pager	int
->	O
map	O
[	O
offset	int
]	O
;	O
invalidate_block	()->(int)
(	O
pager	int
->	O
map	O
[	O
offset	int
]	O
)	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
pager	int
->	O
lock	O
)	O
;	O
pager_dealloc_page	()->(int)
(	O
entry	union
.	O
block	union
.	O
p_index	O
,	O
entry	union
.	O
block	union
.	O
p_offset	O
,	O
TRUE	O
)	O
;	O
}	O
union	O
dp_map	O
pager_move_page	(union)->(union)
(	O
block	union
)	O
union	O
dp_map	O
block	union
;	O
{	O
partition_t	O
old_part	O
,	O
new_part	O
;	O
p_index_t	O
old_pindex	O
,	O
new_pindex	O
;	O
union	O
dp_map	O
ret	union
;	O
vm_size_t	O
size	int
;	O
vm_offset_t	O
raddr	O
,	O
offset	int
,	O
new_offset	O
;	O
kern_return_t	O
rc	int
;	O
static	O
char	O
here	array(char)
[	O
]	O
=	O
"%spager_move_page"	*(char)
;	O
old_pindex	O
=	O
block	union
.	O
block	union
.	O
p_index	O
;	O
invalidate_block	()->(int)
(	O
ret	union
)	O
;	O
new_pindex	O
=	O
choose_partition	()->(int)
(	O
ptoa	O
(	O
1	int
)	O
,	O
old_pindex	O
)	O
;	O
if	O
(	O
no_partition	()->(int)
(	O
new_pindex	O
)	O
)	O
return	O
ret	union
;	O
new_offset	O
=	O
pager_alloc_page	()->(int)
(	O
new_pindex	O
,	O
FALSE	O
)	O
;	O
if	O
(	O
new_offset	O
==	O
NO_BLOCK	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
ddprintf	O
(	O
"pager_move_page(%x,%d,%d)\n"	*(char)
,	O
block	union
.	O
block	union
.	O
p_offset	O
,	O
old_pindex	O
,	O
new_pindex	O
)	O
;	O
old_part	O
=	O
partition_of	(int)->(int)
(	O
old_pindex	O
)	O
;	O
offset	int
=	O
ptoa	O
(	O
block	union
.	O
block	union
.	O
p_offset	O
)	O
;	O
rc	int
=	O
page_read_file_direct	()->(int)
(	O
old_part	O
->	O
file	O
,	O
offset	int
,	O
vm_page_size	O
,	O
&	O
raddr	O
,	O
&	O
size	int
)	O
;	O
if	O
(	O
rc	int
!=	O
0	int
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
pager_dealloc_page	()->(int)
(	O
old_pindex	O
,	O
block	union
.	O
block	union
.	O
p_offset	O
,	O
FALSE	O
)	O
;	O
new_part	O
=	O
partition_of	(int)->(int)
(	O
new_pindex	O
)	O
;	O
offset	int
=	O
ptoa	O
(	O
new_offset	O
)	O
;	O
rc	int
=	O
page_write_file_direct	()->(int)
(	O
new_part	O
->	O
file	O
,	O
offset	int
,	O
raddr	O
,	O
size	int
,	O
&	O
size	int
)	O
;	O
if	O
(	O
rc	int
!=	O
0	int
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
(	O
void	O
)	O
vm_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
raddr	O
,	O
size	int
)	O
;	O
ret	union
.	O
block	union
.	O
p_offset	O
=	O
new_offset	O
;	O
ret	union
.	O
block	union
.	O
p_index	O
=	O
new_pindex	O
;	O
return	O
ret	union
;	O
}	O
union	O
dp_map	O
pager_write_offset	O
(	O
pager	int
,	O
offset	int
)	O
dpager_t	O
pager	int
;	O
vm_offset_t	O
offset	int
;	O
{	O
vm_offset_t	O
f_page	O
;	O
dp_map_t	O
mapptr	int
;	O
union	O
dp_map	O
block	union
;	O
invalidate_block	()->(int)
(	O
block	union
)	O
;	O
f_page	O
=	O
atop	O
(	O
offset	int
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
pager	int
->	O
lock	O
)	O
;	O
if	O
(	O
no_partition	()->(int)
(	O
pager	int
->	O
cur_partition	O
)	O
)	O
{	O
p_index_t	O
new_part	O
;	O
vm_size_t	O
size	int
;	O
size	int
=	O
(	O
f_page	O
>	O
pager	int
->	O
size	int
)	O
?	O
f_page	O
:	O
pager	int
->	O
size	int
;	O
new_part	O
=	O
choose_partition	()->(int)
(	O
ptoa	O
(	O
size	int
)	O
,	O
P_INDEX_INVALID	O
)	O
;	O
if	O
(	O
no_partition	()->(int)
(	O
new_part	O
)	O
)	O
new_part	O
=	O
choose_partition	()->(int)
(	O
ptoa	O
(	O
1	int
)	O
,	O
P_INDEX_INVALID	O
)	O
;	O
if	O
(	O
no_partition	()->(int)
(	O
new_part	O
)	O
)	O
goto	O
out	*(int)
;	O
else	O
pager	int
->	O
cur_partition	O
=	O
new_part	O
;	O
}	O
while	O
(	O
f_page	O
>=	O
pager	int
->	O
size	int
)	O
{	O
ddprintf	O
(	O
"pager_write_offset: extending: %lx %x\n"	*(char)
,	O
f_page	O
,	O
pager	int
->	O
size	int
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
pager	int
->	O
lock	O
)	O
;	O
pager_extend	O
(	O
pager	int
,	O
f_page	O
+	O
1	int
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
pager	int
->	O
lock	O
)	O
;	O
ddprintf	O
(	O
"pager_write_offset: done extending: %lx %x\n"	*(char)
,	O
f_page	O
,	O
pager	int
->	O
size	int
)	O
;	O
}	O
if	O
(	O
INDIRECT_PAGEMAP	()->(int)
(	O
pager	int
->	O
size	int
)	O
)	O
{	O
ddprintf	O
(	O
"pager_write_offset: indirect\n"	*(char)
)	O
;	O
mapptr	int
=	O
pager_get_direct_map	O
(	O
pager	int
)	O
;	O
mapptr	int
=	O
mapptr	int
[	O
f_page	O
/	O
PAGEMAP_ENTRIES	O
]	O
.	O
indirect	O
;	O
if	O
(	O
mapptr	int
==	O
0	int
)	O
{	O
int	O
i	int
;	O
ddprintf	O
(	O
"pager_write_offset: allocating indirect\n"	*(char)
)	O
;	O
mapptr	int
=	O
(	O
dp_map_t	O
)	O
kalloc	()->(int)
(	O
PAGEMAP_SIZE	()->(int)
(	O
PAGEMAP_ENTRIES	O
)	O
)	O
;	O
if	O
(	O
mapptr	int
==	O
0	int
)	O
{	O
no_paging_space	()->(int)
(	O
TRUE	O
)	O
;	O
goto	O
out	*(int)
;	O
}	O
pager	int
->	O
map	O
[	O
f_page	O
/	O
PAGEMAP_ENTRIES	O
]	O
.	O
indirect	O
=	O
mapptr	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
PAGEMAP_ENTRIES	O
;	O
i	int
++	O
)	O
invalidate_block	()->(int)
(	O
mapptr	int
[	O
i	int
]	O
)	O
;	O
}	O
f_page	O
%=	O
PAGEMAP_ENTRIES	O
;	O
}	O
else	O
{	O
mapptr	int
=	O
pager_get_direct_map	O
(	O
pager	int
)	O
;	O
}	O
block	union
=	O
mapptr	int
[	O
f_page	O
]	O
;	O
ddprintf	O
(	O
"pager_write_offset: block starts as %p[%lx] %p\n"	*(char)
,	O
mapptr	int
,	O
f_page	O
,	O
block	union
.	O
indirect	O
)	O
;	O
if	O
(	O
no_block	()->(int)
(	O
block	union
)	O
)	O
{	O
vm_offset_t	O
off	O
;	O
off	O
=	O
pager_alloc_page	()->(int)
(	O
pager	int
->	O
cur_partition	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
off	O
==	O
NO_BLOCK	O
)	O
{	O
p_index_t	O
new_part	O
;	O
ddprintf	O
(	O
"pager_write_offset: could not allocate block\n"	*(char)
)	O
;	O
new_part	O
=	O
choose_partition	()->(int)
(	O
ptoa	O
(	O
1	int
)	O
,	O
pager	int
->	O
cur_partition	O
)	O
;	O
if	O
(	O
!	O
no_partition	()->(int)
(	O
new_part	O
)	O
)	O
{	O
pager	int
->	O
cur_partition	O
=	O
new_part	O
;	O
off	O
=	O
pager_alloc_page	()->(int)
(	O
pager	int
->	O
cur_partition	O
,	O
FALSE	O
)	O
;	O
}	O
if	O
(	O
off	O
==	O
NO_BLOCK	O
)	O
{	O
overcommitted	()->(int)
(	O
FALSE	O
,	O
1	int
)	O
;	O
goto	O
out	*(int)
;	O
}	O
ddprintf	O
(	O
"pager_write_offset: decided to allocate block\n"	*(char)
)	O
;	O
}	O
block	union
.	O
block	union
.	O
p_offset	O
=	O
off	O
;	O
block	union
.	O
block	union
.	O
p_index	O
=	O
pager	int
->	O
cur_partition	O
;	O
mapptr	int
[	O
f_page	O
]	O
=	O
block	union
;	O
}	O
out	*(int)
:	O
pthread_mutex_unlock	()->(int)
(	O
&	O
pager	int
->	O
lock	O
)	O
;	O
return	O
(	O
block	union
)	O
;	O
}	O
void	O
pager_dealloc	O
(	O
pager	int
)	O
dpager_t	O
pager	int
;	O
{	O
int	O
i	int
,	O
j	int
;	O
dp_map_t	O
mapptr	int
;	O
union	O
dp_map	O
block	union
;	O
if	O
(	O
!	O
pager	int
->	O
map	O
)	O
return	O
;	O
if	O
(	O
INDIRECT_PAGEMAP	()->(int)
(	O
pager	int
->	O
size	int
)	O
)	O
{	O
for	O
(	O
i	int
=	O
INDIRECT_PAGEMAP_ENTRIES	()->(int)
(	O
pager	int
->	O
size	int
)	O
;	O
--	O
i	int
>=	O
0	int
;	O
)	O
{	O
mapptr	int
=	O
pager	int
->	O
map	O
[	O
i	int
]	O
.	O
indirect	O
;	O
if	O
(	O
mapptr	int
!=	O
0	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
PAGEMAP_ENTRIES	O
;	O
j	int
++	O
)	O
{	O
block	union
=	O
mapptr	int
[	O
j	int
]	O
;	O
if	O
(	O
!	O
no_block	()->(int)
(	O
block	union
)	O
)	O
pager_dealloc_page	()->(int)
(	O
block	union
.	O
block	union
.	O
p_index	O
,	O
block	union
.	O
block	union
.	O
p_offset	O
,	O
TRUE	O
)	O
;	O
}	O
kfree	()->(int)
(	O
(	O
char	O
*	O
)	O
mapptr	int
,	O
PAGEMAP_SIZE	()->(int)
(	O
PAGEMAP_ENTRIES	O
)	O
)	O
;	O
pager	int
->	O
map	O
[	O
i	int
]	O
.	O
indirect	O
=	O
(	O
dp_map_t	O
)	O
0	int
;	O
}	O
}	O
kfree	()->(int)
(	O
(	O
char	O
*	O
)	O
pager	int
->	O
map	O
,	O
INDIRECT_PAGEMAP_SIZE	()->(int)
(	O
pager	int
->	O
size	int
)	O
)	O
;	O
pager	int
->	O
map	O
=	O
(	O
dp_map_t	O
)	O
0	int
;	O
}	O
else	O
{	O
mapptr	int
=	O
pager	int
->	O
map	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pager	int
->	O
size	int
;	O
i	int
++	O
)	O
{	O
block	union
=	O
mapptr	int
[	O
i	int
]	O
;	O
if	O
(	O
!	O
no_block	()->(int)
(	O
block	union
)	O
)	O
pager_dealloc_page	()->(int)
(	O
block	union
.	O
block	union
.	O
p_index	O
,	O
block	union
.	O
block	union
.	O
p_offset	O
,	O
TRUE	O
)	O
;	O
}	O
kfree	()->(int)
(	O
(	O
char	O
*	O
)	O
pager	int
->	O
map	O
,	O
PAGEMAP_SIZE	()->(int)
(	O
pager	int
->	O
size	int
)	O
)	O
;	O
pager	int
->	O
map	O
=	O
(	O
dp_map_t	O
)	O
0	int
;	O
}	O
}	O
boolean_t	O
pager_realloc	O
(	O
pager	int
,	O
pindex	int
)	O
dpager_t	O
pager	int
;	O
p_index_t	O
pindex	int
;	O
{	O
dp_map_t	O
map	O
,	O
emap	O
;	O
vm_size_t	O
size	int
;	O
union	O
dp_map	O
block	union
;	O
if	O
(	O
!	O
pager	int
->	O
map	O
)	O
return	O
TRUE	O
;	O
size	int
=	O
pager	int
->	O
size	int
;	O
map	O
=	O
pager	int
->	O
map	O
;	O
if	O
(	O
INDIRECT_PAGEMAP	()->(int)
(	O
size	int
)	O
)	O
{	O
for	O
(	O
emap	O
=	O
&	O
map	O
[	O
INDIRECT_PAGEMAP_ENTRIES	()->(int)
(	O
size	int
)	O
]	O
;	O
map	O
<	O
emap	O
;	O
map	O
++	O
)	O
{	O
dp_map_t	O
map2	O
,	O
emap2	O
;	O
if	O
(	O
(	O
map2	O
=	O
map	O
->	O
indirect	O
)	O
==	O
0	int
)	O
continue	O
;	O
for	O
(	O
emap2	O
=	O
&	O
map2	O
[	O
PAGEMAP_ENTRIES	O
]	O
;	O
map2	O
<	O
emap2	O
;	O
map2	O
++	O
)	O
if	O
(	O
map2	O
->	O
block	union
.	O
p_index	O
==	O
pindex	int
)	O
{	O
block	union
=	O
pager_move_page	(union)->(union)
(	O
*	O
map2	O
)	O
;	O
if	O
(	O
!	O
no_block	()->(int)
(	O
block	union
)	O
)	O
*	O
map2	O
=	O
block	union
;	O
else	O
return	O
FALSE	O
;	O
}	O
}	O
goto	O
ok	O
;	O
}	O
for	O
(	O
emap	O
=	O
&	O
map	O
[	O
size	int
]	O
;	O
map	O
<	O
emap	O
;	O
map	O
++	O
)	O
if	O
(	O
map	O
->	O
block	union
.	O
p_index	O
==	O
pindex	int
)	O
{	O
block	union
=	O
pager_move_page	(union)->(union)
(	O
*	O
map	O
)	O
;	O
if	O
(	O
!	O
no_block	()->(int)
(	O
block	union
)	O
)	O
*	O
map	O
=	O
block	union
;	O
else	O
return	O
FALSE	O
;	O
}	O
ok	O
:	O
pager	int
->	O
cur_partition	O
=	O
choose_partition	()->(int)
(	O
0	int
,	O
P_INDEX_INVALID	O
)	O
;	O
return	O
TRUE	O
;	O
}	O
int	O
default_read	O
(	O
ds	int
,	O
addr	int
,	O
size	int
,	O
offset	int
,	O
out_addr	*(int)
,	O
deallocate	int
,	O
external	int
)	O
dpager_t	O
ds	int
;	O
vm_offset_t	O
addr	int
;	O
vm_size_t	O
size	int
;	O
vm_offset_t	O
offset	int
;	O
vm_offset_t	O
*	O
out_addr	*(int)
;	O
boolean_t	O
deallocate	int
;	O
boolean_t	O
external	int
;	O
{	O
union	O
dp_map	O
block	union
;	O
vm_offset_t	O
raddr	O
;	O
vm_size_t	O
rsize	O
;	O
int	O
rc	int
;	O
boolean_t	O
first_time	O
;	O
partition_t	O
part	int
;	O
vm_offset_t	O
original_offset	O
=	O
offset	int
;	O
block	union
=	O
pager_read_offset	O
(	O
ds	int
,	O
offset	int
)	O
;	O
if	O
(	O
no_block	()->(int)
(	O
block	union
)	O
)	O
{	O
if	O
(	O
external	int
)	O
{	O
memset	O
(	O
(	O
char	O
*	O
)	O
addr	int
,	O
0	int
,	O
vm_page_size	O
)	O
;	O
*	O
out_addr	*(int)
=	O
addr	int
;	O
return	O
(	O
PAGER_SUCCESS	int
)	O
;	O
}	O
return	O
(	O
PAGER_ABSENT	int
)	O
;	O
}	O
offset	int
=	O
ptoa	O
(	O
block	union
.	O
block	union
.	O
p_offset	O
)	O
;	O
ddprintf	O
(	O
"default_read(%lx,%x,%lx,%d)\n"	*(char)
,	O
addr	int
,	O
size	int
,	O
offset	int
,	O
block	union
.	O
block	union
.	O
p_index	O
)	O
;	O
part	int
=	O
partition_of	(int)->(int)
(	O
block	union
.	O
block	union
.	O
p_index	O
)	O
;	O
first_time	O
=	O
TRUE	O
;	O
*	O
out_addr	*(int)
=	O
addr	int
;	O
do	O
{	O
rc	int
=	O
page_read_file_direct	()->(int)
(	O
part	int
->	O
file	O
,	O
offset	int
,	O
size	int
,	O
&	O
raddr	O
,	O
&	O
rsize	O
)	O
;	O
if	O
(	O
rc	int
!=	O
0	int
)	O
return	O
(	O
PAGER_ERROR	int
)	O
;	O
if	O
(	O
first_time	O
&&	O
rsize	O
==	O
size	int
)	O
{	O
*	O
out_addr	*(int)
=	O
raddr	O
;	O
break	O
;	O
}	O
first_time	O
=	O
FALSE	O
;	O
memcpy	O
(	O
(	O
char	O
*	O
)	O
addr	int
,	O
(	O
char	O
*	O
)	O
raddr	O
,	O
rsize	O
)	O
;	O
addr	int
+=	O
rsize	O
;	O
offset	int
+=	O
rsize	O
;	O
size	int
-=	O
rsize	O
;	O
}	O
while	O
(	O
size	int
!=	O
0	int
)	O
;	O
if	O
(	O
deallocate	int
)	O
pager_release_offset	O
(	O
ds	int
,	O
original_offset	O
)	O
;	O
return	O
(	O
PAGER_SUCCESS	int
)	O
;	O
}	O
int	O
default_write	O
(	O
ds	int
,	O
addr	int
,	O
size	int
,	O
offset	int
)	O
dpager_t	O
ds	int
;	O
vm_offset_t	O
addr	int
;	O
vm_size_t	O
size	int
;	O
vm_offset_t	O
offset	int
;	O
{	O
union	O
dp_map	O
block	union
;	O
partition_t	O
part	int
;	O
vm_size_t	O
wsize	O
;	O
int	O
rc	int
;	O
ddprintf	O
(	O
"default_write: pager offset %lx\n"	*(char)
,	O
offset	int
)	O
;	O
block	union
=	O
pager_write_offset	O
(	O
ds	int
,	O
offset	int
)	O
;	O
if	O
(	O
no_block	()->(int)
(	O
block	union
)	O
)	O
return	O
(	O
PAGER_ERROR	int
)	O
;	O
offset	int
=	O
ptoa	O
(	O
block	union
.	O
block	union
.	O
p_offset	O
)	O
;	O
ddprintf	O
(	O
"default_write(%lx,%x,%lx,%d)\n"	*(char)
,	O
addr	int
,	O
size	int
,	O
offset	int
,	O
block	union
.	O
block	union
.	O
p_index	O
)	O
;	O
part	int
=	O
partition_of	(int)->(int)
(	O
block	union
.	O
block	union
.	O
p_index	O
)	O
;	O
do	O
{	O
rc	int
=	O
page_write_file_direct	()->(int)
(	O
part	int
->	O
file	O
,	O
offset	int
,	O
addr	int
,	O
size	int
,	O
&	O
wsize	O
)	O
;	O
if	O
(	O
rc	int
!=	O
0	int
)	O
{	O
dprintf	O
(	O
"*** PAGER ERROR: default_write: "	*(char)
)	O
;	O
dprintf	O
(	O
"ds=0x%p addr=0x%lx size=0x%x offset=0x%lx resid=0x%x\n"	*(char)
,	O
ds	int
,	O
addr	int
,	O
size	int
,	O
offset	int
,	O
wsize	O
)	O
;	O
return	O
(	O
PAGER_ERROR	int
)	O
;	O
}	O
addr	int
+=	O
wsize	O
;	O
offset	int
+=	O
wsize	O
;	O
size	int
-=	O
wsize	O
;	O
}	O
while	O
(	O
size	int
!=	O
0	int
)	O
;	O
return	O
(	O
PAGER_SUCCESS	int
)	O
;	O
}	O
boolean_t	O
default_has_page	O
(	O
ds	int
,	O
offset	int
)	O
dpager_t	O
ds	int
;	O
vm_offset_t	O
offset	int
;	O
{	O
return	O
(	O
!	O
no_block	()->(int)
(	O
pager_read_offset	O
(	O
ds	int
,	O
offset	int
)	O
)	O
)	O
;	O
}	O
struct	O
pager_port	O
all_pagers	struct
;	O
void	O
pager_port_list_insert	()->(int)
(	O
port	O
,	O
ds	int
)	O
mach_port_t	O
port	O
;	O
default_pager_t	O
ds	int
;	O
{	O
pthread_mutex_lock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
hurd_ihash_add	O
(	O
&	O
all_pagers	struct
.	O
htable	O
,	O
(	O
hurd_ihash_key_t	O
)	O
port	O
,	O
(	O
hurd_ihash_value_t	O
)	O
ds	int
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
mach_port_set_protected_payload	O
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
port	O
,	O
(	O
unsigned	O
long	O
)	O
ds	int
)	O
;	O
}	O
void	O
pager_port_list_delete	O
(	O
ds	int
)	O
default_pager_t	O
ds	int
;	O
{	O
pthread_mutex_lock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
hurd_ihash_locp_remove	O
(	O
&	O
all_pagers	struct
.	O
htable	O
,	O
ds	int
->	O
htable_locp	O
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
mach_port_clear_protected_payload	O
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
ds	int
->	O
pager	int
)	O
;	O
}	O
kern_return_t	O
destroy_paging_partition	(*(char),*(*(void)))->(int)
(	O
name	*(char)
,	O
pp_private	*(*(void))
)	O
char	O
*	O
name	*(char)
;	O
void	O
*	O
*	O
pp_private	*(*(void))
;	O
{	O
unsigned	O
int	O
id	int
=	O
part_id	(*(char))->(int)
(	O
name	*(char)
)	O
;	O
partition_t	O
part	int
=	O
NULL	O
;	O
boolean_t	O
all_ok	O
=	O
TRUE	O
;	O
default_pager_t	O
entry	union
;	O
int	O
pindex	int
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
for	O
(	O
pindex	int
=	O
0	int
;	O
pindex	int
<	O
all_partitions	O
.	O
n_partitions	O
;	O
pindex	int
++	O
)	O
{	O
part	int
=	O
partition_of	(int)->(int)
(	O
pindex	int
)	O
;	O
if	O
(	O
part	int
&&	O
(	O
part	int
->	O
id	int
==	O
id	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
part	int
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
return	O
KERN_INVALID_ARGUMENT	O
;	O
}	O
part	int
->	O
going_away	O
=	O
TRUE	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
all_over_again	O
:	O
all_ok	O
=	O
TRUE	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
part	int
->	O
p_lock	O
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
HURD_IHASH_ITERATE	()->(int)
(	O
&	O
all_pagers	struct
.	O
htable	O
,	O
val	O
)	O
{	O
entry	union
=	O
(	O
default_pager_t	O
)	O
val	O
;	O
dstruct_lock	O
(	O
entry	union
)	O
;	O
if	O
(	O
pthread_mutex_trylock	()->(int)
(	O
&	O
entry	union
->	O
dpager	O
.	O
lock	O
)	O
)	O
{	O
dstruct_unlock	O
(	O
entry	union
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
part	int
->	O
p_lock	O
)	O
;	O
(	O
void	O
)	O
thread_switch	()->(int)
(	O
MACH_PORT_NULL	O
,	O
SWITCH_OPTION_NONE	O
,	O
0	int
)	O
;	O
goto	O
all_over_again	O
;	O
}	O
all_ok	O
=	O
pager_realloc	O
(	O
&	O
entry	union
->	O
dpager	O
,	O
pindex	int
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
entry	union
->	O
dpager	O
.	O
lock	O
)	O
;	O
dstruct_unlock	O
(	O
entry	union
)	O
;	O
if	O
(	O
!	O
all_ok	O
)	O
break	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
if	O
(	O
all_ok	O
)	O
{	O
set_partition_of	()->(int)
(	O
pindex	int
,	O
0	int
)	O
;	O
*	O
pp_private	*(*(void))
=	O
part	int
->	O
file	O
;	O
kfree	()->(int)
(	O
part	int
->	O
bitmap	O
,	O
howmany	()->(int)
(	O
part	int
->	O
total_size	O
,	O
NB_BM	O
)	O
*	O
sizeof	O
(	O
bm_entry_t	O
)	O
)	O
;	O
kfree	()->(int)
(	O
part	int
->	O
name	*(char)
,	O
strlen	O
(	O
part	int
->	O
name	*(char)
)	O
+	O
1	int
)	O
;	O
kfree	()->(int)
(	O
part	int
,	O
sizeof	O
(	O
struct	O
part	int
)	O
)	O
;	O
dprintf	O
(	O
"%s Removed paging partition %s\n"	*(char)
,	O
my_name	array(char)
,	O
name	*(char)
)	O
;	O
return	O
KERN_SUCCESS	O
;	O
}	O
part	int
->	O
going_away	O
=	O
FALSE	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
part	int
->	O
p_lock	O
)	O
;	O
return	O
KERN_FAILURE	O
;	O
}	O
unsigned	O
int	O
default_pager_total	int
=	O
0	int
;	O
unsigned	O
int	O
default_pager_wait_seqno	int
=	O
0	int
;	O
unsigned	O
int	O
default_pager_wait_read	int
=	O
0	int
;	O
unsigned	O
int	O
default_pager_wait_write	int
=	O
0	int
;	O
unsigned	O
int	O
default_pager_wait_refs	int
=	O
0	int
;	O
void	O
pager_port_lock	()->(int)
(	O
ds	int
,	O
seqno	int
)	O
default_pager_t	O
ds	int
;	O
mach_port_seqno_t	O
seqno	int
;	O
{	O
default_pager_total	int
++	O
;	O
dstruct_lock	O
(	O
ds	int
)	O
;	O
while	O
(	O
ds	int
->	O
seqno	int
!=	O
seqno	int
)	O
{	O
default_pager_wait_seqno	int
++	O
;	O
pthread_cond_wait	O
(	O
&	O
ds	int
->	O
waiting_seqno	O
,	O
&	O
ds	int
->	O
lock	O
)	O
;	O
}	O
}	O
void	O
pager_port_unlock	()->(int)
(	O
ds	int
)	O
default_pager_t	O
ds	int
;	O
{	O
ds	int
->	O
seqno	int
++	O
;	O
dstruct_unlock	O
(	O
ds	int
)	O
;	O
pthread_cond_broadcast	O
(	O
&	O
ds	int
->	O
waiting_seqno	O
)	O
;	O
}	O
void	O
pager_port_start_read	O
(	O
ds	int
)	O
default_pager_t	O
ds	int
;	O
{	O
ds	int
->	O
readers	O
++	O
;	O
}	O
void	O
pager_port_wait_for_readers	()->(int)
(	O
ds	int
)	O
default_pager_t	O
ds	int
;	O
{	O
while	O
(	O
ds	int
->	O
readers	O
!=	O
0	int
)	O
{	O
default_pager_wait_read	int
++	O
;	O
pthread_cond_wait	O
(	O
&	O
ds	int
->	O
waiting_read	O
,	O
&	O
ds	int
->	O
lock	O
)	O
;	O
}	O
}	O
void	O
pager_port_finish_read	O
(	O
ds	int
)	O
default_pager_t	O
ds	int
;	O
{	O
dstruct_lock	O
(	O
ds	int
)	O
;	O
if	O
(	O
--	O
ds	int
->	O
readers	O
==	O
0	int
)	O
{	O
dstruct_unlock	O
(	O
ds	int
)	O
;	O
pthread_cond_broadcast	O
(	O
&	O
ds	int
->	O
waiting_read	O
)	O
;	O
}	O
else	O
{	O
dstruct_unlock	O
(	O
ds	int
)	O
;	O
}	O
}	O
void	O
pager_port_start_write	O
(	O
ds	int
)	O
default_pager_t	O
ds	int
;	O
{	O
ds	int
->	O
writers	O
++	O
;	O
}	O
void	O
pager_port_wait_for_writers	()->(int)
(	O
ds	int
)	O
default_pager_t	O
ds	int
;	O
{	O
while	O
(	O
ds	int
->	O
writers	O
!=	O
0	int
)	O
{	O
default_pager_wait_write	int
++	O
;	O
pthread_cond_wait	O
(	O
&	O
ds	int
->	O
waiting_write	O
,	O
&	O
ds	int
->	O
lock	O
)	O
;	O
}	O
}	O
void	O
pager_port_finish_write	O
(	O
ds	int
)	O
default_pager_t	O
ds	int
;	O
{	O
dstruct_lock	O
(	O
ds	int
)	O
;	O
if	O
(	O
--	O
ds	int
->	O
writers	O
==	O
0	int
)	O
{	O
dstruct_unlock	O
(	O
ds	int
)	O
;	O
pthread_cond_broadcast	O
(	O
&	O
ds	int
->	O
waiting_write	O
)	O
;	O
}	O
else	O
{	O
dstruct_unlock	O
(	O
ds	int
)	O
;	O
}	O
}	O
void	O
pager_port_wait_for_refs	O
(	O
ds	int
)	O
default_pager_t	O
ds	int
;	O
{	O
while	O
(	O
ds	int
->	O
name_refs	O
==	O
0	int
)	O
{	O
default_pager_wait_refs	int
++	O
;	O
pthread_cond_wait	O
(	O
&	O
ds	int
->	O
waiting_refs	O
,	O
&	O
ds	int
->	O
lock	O
)	O
;	O
}	O
}	O
void	O
pager_port_finish_refs	O
(	O
ds	int
)	O
default_pager_t	O
ds	int
;	O
{	O
pthread_cond_broadcast	O
(	O
&	O
ds	int
->	O
waiting_refs	O
)	O
;	O
}	O
task_t	O
default_pager_self	int
;	O
mach_port_t	O
default_pager_default_port	int
;	O
mach_port_t	O
default_pager_exception_port	int
;	O
mach_port_t	O
default_pager_internal_set	int
;	O
mach_port_t	O
default_pager_external_set	int
;	O
mach_port_t	O
default_pager_default_set	int
;	O
typedef	O
struct	O
default_pager_thread	struct(int,int,int)
{	O
pthread_t	O
dpt_thread	int
;	O
vm_offset_t	O
dpt_buffer	int
;	O
boolean_t	O
dpt_internal	int
;	O
}	O
default_pager_thread_t	struct(int,int,int)
;	O
unsigned	O
int	O
default_pager_internal_count	int
=	O
DEFAULT_PAGER_INTERNAL_COUNT	O
;	O
unsigned	O
int	O
default_pager_external_count	int
=	O
DEFAULT_PAGER_EXTERNAL_COUNT	O
;	O
default_pager_t	O
pager_port_alloc	()->(int)
(	O
size	int
)	O
vm_size_t	O
size	int
;	O
{	O
default_pager_t	O
ds	int
;	O
p_index_t	O
part	int
;	O
ds	int
=	O
(	O
default_pager_t	O
)	O
kalloc	()->(int)
(	O
sizeof	O
*	O
ds	int
)	O
;	O
if	O
(	O
ds	int
==	O
DEFAULT_PAGER_NULL	O
)	O
panic	()->(int)
(	O
"%spager_port_alloc"	*(char)
,	O
my_name	array(char)
)	O
;	O
memset	O
(	O
(	O
char	O
*	O
)	O
ds	int
,	O
0	int
,	O
sizeof	O
*	O
ds	int
)	O
;	O
dstruct_lock_init	O
(	O
ds	int
)	O
;	O
part	int
=	O
choose_partition	()->(int)
(	O
size	int
,	O
P_INDEX_INVALID	O
)	O
;	O
if	O
(	O
no_partition	()->(int)
(	O
part	int
)	O
)	O
{	O
overcommitted	()->(int)
(	O
FALSE	O
,	O
atop	O
(	O
size	int
)	O
)	O
;	O
part	int
=	O
choose_partition	()->(int)
(	O
0	int
,	O
P_INDEX_INVALID	O
)	O
;	O
}	O
pager_alloc	O
(	O
&	O
ds	int
->	O
dpager	O
,	O
part	int
,	O
size	int
)	O
;	O
return	O
ds	int
;	O
}	O
mach_port_urefs_t	O
default_pager_max_urefs	int
=	O
10000	int
;	O
void	O
pager_port_check_request	O
(	O
ds	int
,	O
pager_request	int
)	O
default_pager_t	O
ds	int
;	O
mach_port_t	O
pager_request	int
;	O
{	O
mach_port_delta_t	O
delta	O
;	O
kern_return_t	O
kr	O
;	O
assert	O
(	O
ds	int
->	O
pager_request	int
==	O
pager_request	int
)	O
;	O
if	O
(	O
++	O
ds	int
->	O
request_refs	O
>	O
default_pager_max_urefs	int
)	O
{	O
delta	O
=	O
1	int
-	O
ds	int
->	O
request_refs	O
;	O
ds	int
->	O
request_refs	O
=	O
1	int
;	O
dstruct_unlock	O
(	O
ds	int
)	O
;	O
kr	O
=	O
mach_port_mod_refs	O
(	O
default_pager_self	int
,	O
pager_request	int
,	O
MACH_PORT_RIGHT_SEND	O
,	O
delta	O
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
"%spager_port_check_request"	*(char)
,	O
my_name	array(char)
)	O
;	O
dstruct_lock	O
(	O
ds	int
)	O
;	O
}	O
}	O
void	O
default_pager_add	()->(int)
(	O
ds	int
,	O
internal	int
)	O
default_pager_t	O
ds	int
;	O
boolean_t	O
internal	int
;	O
{	O
mach_port_t	O
pager	int
=	O
ds	int
->	O
pager	int
;	O
mach_port_t	O
pset	O
;	O
mach_port_mscount_t	O
sync	O
;	O
mach_port_t	O
previous	O
;	O
kern_return_t	O
kr	O
;	O
static	O
char	O
here	array(char)
[	O
]	O
=	O
"%sdefault_pager_add"	*(char)
;	O
if	O
(	O
internal	int
)	O
{	O
sync	O
=	O
0	int
;	O
pset	O
=	O
default_pager_internal_set	int
;	O
ds	int
->	O
external	int
=	O
FALSE	O
;	O
}	O
else	O
{	O
sync	O
=	O
1	int
;	O
pset	O
=	O
default_pager_external_set	int
;	O
ds	int
->	O
external	int
=	O
TRUE	O
;	O
}	O
kr	O
=	O
mach_port_request_notification	O
(	O
default_pager_self	int
,	O
pager	int
,	O
MACH_NOTIFY_NO_SENDERS	O
,	O
sync	O
,	O
pager	int
,	O
MACH_MSG_TYPE_MAKE_SEND_ONCE	O
,	O
&	O
previous	O
)	O
;	O
if	O
(	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
||	O
(	O
previous	O
!=	O
MACH_PORT_NULL	O
)	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
kr	O
=	O
mach_port_move_member	()->(int)
(	O
default_pager_self	int
,	O
pager	int
,	O
pset	O
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
}	O
kern_return_t	O
seqnos_memory_object_create	O
(	O
old_pager	O
,	O
seqno	int
,	O
new_pager	int
,	O
new_size	int
,	O
new_pager_request	int
,	O
new_pager_name	int
,	O
new_page_size	int
)	O
mach_port_t	O
old_pager	O
;	O
mach_port_seqno_t	O
seqno	int
;	O
mach_port_t	O
new_pager	int
;	O
vm_size_t	O
new_size	int
;	O
mach_port_t	O
new_pager_request	int
;	O
mach_port_t	O
new_pager_name	int
;	O
vm_size_t	O
new_page_size	int
;	O
{	O
default_pager_t	O
ds	int
;	O
assert	O
(	O
old_pager	O
==	O
default_pager_default_port	int
)	O
;	O
assert	O
(	O
MACH_PORT_VALID	O
(	O
new_pager_request	int
)	O
)	O
;	O
assert	O
(	O
MACH_PORT_VALID	O
(	O
new_pager_name	int
)	O
)	O
;	O
assert	O
(	O
new_page_size	int
==	O
vm_page_size	O
)	O
;	O
ds	int
=	O
pager_port_alloc	()->(int)
(	O
new_size	int
)	O
;	O
ds	int
->	O
pager	int
=	O
new_pager	int
;	O
ds	int
->	O
pager_request	int
=	O
new_pager_request	int
;	O
ds	int
->	O
request_refs	O
=	O
1	int
;	O
ds	int
->	O
pager_name	int
=	O
new_pager_name	int
;	O
ds	int
->	O
name_refs	O
=	O
1	int
;	O
pager_port_list_insert	()->(int)
(	O
new_pager	int
,	O
ds	int
)	O
;	O
default_pager_add	()->(int)
(	O
ds	int
,	O
TRUE	O
)	O
;	O
return	O
(	O
KERN_SUCCESS	O
)	O
;	O
}	O
memory_object_copy_strategy_t	O
default_pager_copy_strategy	int
=	O
MEMORY_OBJECT_COPY_DELAY	O
;	O
kern_return_t	O
seqnos_memory_object_init	O
(	O
ds	int
,	O
seqno	int
,	O
pager_request	int
,	O
pager_name	int
,	O
pager_page_size	int
)	O
default_pager_t	O
ds	int
;	O
mach_port_seqno_t	O
seqno	int
;	O
mach_port_t	O
pager_request	int
;	O
mach_port_t	O
pager_name	int
;	O
vm_size_t	O
pager_page_size	int
;	O
{	O
kern_return_t	O
kr	O
;	O
static	O
char	O
here	array(char)
[	O
]	O
=	O
"%sinit"	*(char)
;	O
assert	O
(	O
MACH_PORT_VALID	O
(	O
pager_request	int
)	O
)	O
;	O
assert	O
(	O
MACH_PORT_VALID	O
(	O
pager_name	int
)	O
)	O
;	O
assert	O
(	O
pager_page_size	int
==	O
vm_page_size	O
)	O
;	O
if	O
(	O
ds	int
==	O
DEFAULT_PAGER_NULL	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
pager_port_lock	()->(int)
(	O
ds	int
,	O
seqno	int
)	O
;	O
if	O
(	O
ds	int
->	O
pager_request	int
!=	O
MACH_PORT_NULL	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
ds	int
->	O
pager_request	int
=	O
pager_request	int
;	O
ds	int
->	O
request_refs	O
=	O
1	int
;	O
ds	int
->	O
pager_name	int
=	O
pager_name	int
;	O
ds	int
->	O
name_refs	O
=	O
1	int
;	O
kr	O
=	O
memory_object_ready	O
(	O
pager_request	int
,	O
FALSE	O
,	O
default_pager_copy_strategy	int
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
pager_port_unlock	()->(int)
(	O
ds	int
)	O
;	O
return	O
(	O
KERN_SUCCESS	O
)	O
;	O
}	O
kern_return_t	O
seqnos_memory_object_terminate	O
(	O
ds	int
,	O
seqno	int
,	O
pager_request	int
,	O
pager_name	int
)	O
default_pager_t	O
ds	int
;	O
mach_port_seqno_t	O
seqno	int
;	O
mach_port_t	O
pager_request	int
;	O
mach_port_t	O
pager_name	int
;	O
{	O
static	O
char	O
here	array(char)
[	O
]	O
=	O
"%sterminate"	*(char)
;	O
if	O
(	O
ds	int
==	O
DEFAULT_PAGER_NULL	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
ddprintf	O
(	O
"seqnos_memory_object_terminate <%p>: pager_port_lock: <%p>[s:%d,r:%d,w:%d,l:%d], %d\n"	*(char)
,	O
&	O
ds	int
,	O
ds	int
,	O
ds	int
->	O
seqno	int
,	O
ds	int
->	O
readers	O
,	O
ds	int
->	O
writers	O
,	O
ds	int
->	O
lock	O
.	O
__held	O
,	O
seqno	int
)	O
;	O
pager_port_lock	()->(int)
(	O
ds	int
,	O
seqno	int
)	O
;	O
pager_port_wait_for_readers	()->(int)
(	O
ds	int
)	O
;	O
pager_port_wait_for_writers	()->(int)
(	O
ds	int
)	O
;	O
pager_port_wait_for_refs	O
(	O
ds	int
)	O
;	O
if	O
(	O
ds	int
->	O
external	int
)	O
pager_request	int
=	O
ds	int
->	O
pager_request	int
;	O
ds	int
->	O
pager_request	int
=	O
MACH_PORT_NULL	O
;	O
ds	int
->	O
request_refs	O
=	O
0	int
;	O
assert	O
(	O
ds	int
->	O
pager_name	int
==	O
pager_name	int
)	O
;	O
ds	int
->	O
pager_name	int
=	O
MACH_PORT_NULL	O
;	O
ds	int
->	O
name_refs	O
=	O
0	int
;	O
ddprintf	O
(	O
"seqnos_memory_object_terminate <%p>: pager_port_unlock: <%p>[s:%d,r:%d,w:%d,l:%d]\n"	*(char)
,	O
&	O
ds	int
,	O
ds	int
,	O
ds	int
->	O
seqno	int
,	O
ds	int
->	O
readers	O
,	O
ds	int
->	O
writers	O
,	O
ds	int
->	O
lock	O
.	O
__held	O
)	O
;	O
pager_port_unlock	()->(int)
(	O
ds	int
)	O
;	O
mach_port_destroy	O
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
pager_request	int
)	O
;	O
mach_port_destroy	O
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
pager_name	int
)	O
;	O
return	O
(	O
KERN_SUCCESS	O
)	O
;	O
}	O
void	O
default_pager_no_senders	O
(	O
pager	int
,	O
seqno	int
,	O
mscount	int
)	O
memory_object_t	O
pager	int
;	O
mach_port_seqno_t	O
seqno	int
;	O
mach_port_mscount_t	O
mscount	int
;	O
{	O
default_pager_t	O
ds	int
;	O
kern_return_t	O
kr	O
;	O
static	O
char	O
here	array(char)
[	O
]	O
=	O
"%sno_senders"	*(char)
;	O
ds	int
=	O
begin_using_default_pager	O
(	O
pager	int
)	O
;	O
if	O
(	O
ds	int
==	O
DEFAULT_PAGER_NULL	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
pager_port_lock	()->(int)
(	O
ds	int
,	O
seqno	int
)	O
;	O
if	O
(	O
ds	int
->	O
pager_request	int
!=	O
MACH_PORT_NULL	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
dstruct_unlock	O
(	O
ds	int
)	O
;	O
pager_port_list_delete	O
(	O
ds	int
)	O
;	O
pager_dealloc	O
(	O
&	O
ds	int
->	O
dpager	O
)	O
;	O
kr	O
=	O
mach_port_mod_refs	O
(	O
default_pager_self	int
,	O
pager	int
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
-	O
1	int
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
kfree	()->(int)
(	O
(	O
char	O
*	O
)	O
ds	int
,	O
sizeof	O
(	O
*	O
ds	int
)	O
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
while	O
(	O
!	O
queue_empty	O
(	O
&	O
all_pagers	struct
.	O
leak_queue	O
)	O
)	O
{	O
ds	int
=	O
(	O
default_pager_t	O
)	O
queue_first	O
(	O
&	O
all_pagers	struct
.	O
leak_queue	O
)	O
;	O
queue_remove_first	O
(	O
&	O
all_pagers	struct
.	O
leak_queue	O
,	O
ds	int
,	O
default_pager_t	O
,	O
links	O
)	O
;	O
kfree	()->(int)
(	O
(	O
char	O
*	O
)	O
ds	int
,	O
sizeof	O
(	O
*	O
ds	int
)	O
)	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
}	O
int	O
default_pager_pagein_count	int
=	O
0	int
;	O
int	O
default_pager_pageout_count	int
=	O
0	int
;	O
static	O
__thread	O
default_pager_thread_t	struct(int,int,int)
*	O
dpt	*(struct(int,int,int))
;	O
kern_return_t	O
seqnos_memory_object_data_request	O
(	O
ds	int
,	O
seqno	int
,	O
reply_to	int
,	O
offset	int
,	O
length	int
,	O
protection_required	int
)	O
default_pager_t	O
ds	int
;	O
mach_port_seqno_t	O
seqno	int
;	O
mach_port_t	O
reply_to	int
;	O
vm_offset_t	O
offset	int
;	O
vm_size_t	O
length	int
;	O
vm_prot_t	O
protection_required	int
;	O
{	O
vm_offset_t	O
addr	int
;	O
unsigned	O
int	O
errors	O
;	O
kern_return_t	O
rc	int
;	O
static	O
char	O
here	array(char)
[	O
]	O
=	O
"%sdata_request"	*(char)
;	O
if	O
(	O
length	int
!=	O
vm_page_size	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
if	O
(	O
ds	int
==	O
DEFAULT_PAGER_NULL	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
ddprintf	O
(	O
"seqnos_memory_object_data_request <%p>: pager_port_lock: <%p>[s:%d,r:%d,w:%d,l:%d], %d\n"	*(char)
,	O
&	O
ds	int
,	O
ds	int
,	O
ds	int
->	O
seqno	int
,	O
ds	int
->	O
readers	O
,	O
ds	int
->	O
writers	O
,	O
ds	int
->	O
lock	O
.	O
__held	O
,	O
seqno	int
)	O
;	O
pager_port_lock	()->(int)
(	O
ds	int
,	O
seqno	int
)	O
;	O
pager_port_check_request	O
(	O
ds	int
,	O
reply_to	int
)	O
;	O
pager_port_wait_for_writers	()->(int)
(	O
ds	int
)	O
;	O
pager_port_start_read	O
(	O
ds	int
)	O
;	O
errors	O
=	O
ds	int
->	O
errors	O
;	O
ddprintf	O
(	O
"seqnos_memory_object_data_request <%p>: pager_port_unlock: <%p>[s:%d,r:%d,w:%d,l:%d]\n"	*(char)
,	O
&	O
ds	int
,	O
ds	int
,	O
ds	int
->	O
seqno	int
,	O
ds	int
->	O
readers	O
,	O
ds	int
->	O
writers	O
,	O
ds	int
->	O
lock	O
.	O
__held	O
)	O
;	O
pager_port_unlock	()->(int)
(	O
ds	int
)	O
;	O
if	O
(	O
errors	O
)	O
{	O
dprintf	O
(	O
"%s %s\n"	*(char)
,	O
my_name	array(char)
,	O
"dropping data_request because of previous paging errors"	*(char)
)	O
;	O
(	O
void	O
)	O
memory_object_data_error	O
(	O
reply_to	int
,	O
offset	int
,	O
vm_page_size	O
,	O
KERN_FAILURE	O
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
offset	int
>=	O
ds	int
->	O
dpager	O
.	O
limit	int
)	O
rc	int
=	O
PAGER_ERROR	int
;	O
else	O
rc	int
=	O
default_read	O
(	O
&	O
ds	int
->	O
dpager	O
,	O
dpt	*(struct(int,int,int))
->	O
dpt_buffer	int
,	O
vm_page_size	O
,	O
offset	int
,	O
&	O
addr	int
,	O
protection_required	int
&	O
VM_PROT_WRITE	O
,	O
ds	int
->	O
external	int
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
PAGER_SUCCESS	int
:	O
if	O
(	O
addr	int
!=	O
dpt	*(struct(int,int,int))
->	O
dpt_buffer	int
)	O
{	O
(	O
void	O
)	O
memory_object_data_supply	O
(	O
reply_to	int
,	O
offset	int
,	O
addr	int
,	O
vm_page_size	O
,	O
TRUE	O
,	O
VM_PROT_NONE	O
,	O
FALSE	O
,	O
MACH_PORT_NULL	O
)	O
;	O
}	O
else	O
{	O
(	O
void	O
)	O
memory_object_data_supply	O
(	O
reply_to	int
,	O
offset	int
,	O
addr	int
,	O
vm_page_size	O
,	O
FALSE	O
,	O
VM_PROT_NONE	O
,	O
FALSE	O
,	O
MACH_PORT_NULL	O
)	O
;	O
}	O
break	O
;	O
case	O
PAGER_ABSENT	int
:	O
(	O
void	O
)	O
memory_object_data_unavailable	O
(	O
reply_to	int
,	O
offset	int
,	O
vm_page_size	O
)	O
;	O
break	O
;	O
case	O
PAGER_ERROR	int
:	O
(	O
void	O
)	O
memory_object_data_error	O
(	O
reply_to	int
,	O
offset	int
,	O
vm_page_size	O
,	O
KERN_FAILURE	O
)	O
;	O
break	O
;	O
}	O
default_pager_pagein_count	int
++	O
;	O
done	O
:	O
pager_port_finish_read	O
(	O
ds	int
)	O
;	O
return	O
(	O
KERN_SUCCESS	O
)	O
;	O
}	O
kern_return_t	O
seqnos_memory_object_data_initialize	O
(	O
ds	int
,	O
seqno	int
,	O
pager_request	int
,	O
offset	int
,	O
addr	int
,	O
data_cnt	int
)	O
default_pager_t	O
ds	int
;	O
mach_port_seqno_t	O
seqno	int
;	O
mach_port_t	O
pager_request	int
;	O
register	O
vm_offset_t	O
offset	int
;	O
register	O
pointer_t	O
addr	int
;	O
vm_size_t	O
data_cnt	int
;	O
{	O
vm_offset_t	O
amount_sent	O
;	O
static	O
char	O
here	array(char)
[	O
]	O
=	O
"%sdata_initialize"	*(char)
;	O
if	O
(	O
ds	int
==	O
DEFAULT_PAGER_NULL	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
ddprintf	O
(	O
"seqnos_memory_object_data_initialize <%p>: pager_port_lock: <%p>[s:%d,r:%d,w:%d,l:%d], %d\n"	*(char)
,	O
&	O
ds	int
,	O
ds	int
,	O
ds	int
->	O
seqno	int
,	O
ds	int
->	O
readers	O
,	O
ds	int
->	O
writers	O
,	O
ds	int
->	O
lock	O
.	O
__held	O
,	O
seqno	int
)	O
;	O
pager_port_lock	()->(int)
(	O
ds	int
,	O
seqno	int
)	O
;	O
pager_port_check_request	O
(	O
ds	int
,	O
pager_request	int
)	O
;	O
pager_port_start_write	O
(	O
ds	int
)	O
;	O
ddprintf	O
(	O
"seqnos_memory_object_data_initialize <%p>: pager_port_unlock: <%p>[s:%d,r:%d,w:%d,l:%d]\n"	*(char)
,	O
&	O
ds	int
,	O
ds	int
,	O
ds	int
->	O
seqno	int
,	O
ds	int
->	O
readers	O
,	O
ds	int
->	O
writers	O
,	O
ds	int
->	O
lock	O
.	O
__held	O
)	O
;	O
pager_port_unlock	()->(int)
(	O
ds	int
)	O
;	O
for	O
(	O
amount_sent	O
=	O
0	int
;	O
amount_sent	O
<	O
data_cnt	int
;	O
amount_sent	O
+=	O
vm_page_size	O
)	O
{	O
if	O
(	O
!	O
default_has_page	O
(	O
&	O
ds	int
->	O
dpager	O
,	O
offset	int
+	O
amount_sent	O
)	O
)	O
{	O
if	O
(	O
default_write	O
(	O
&	O
ds	int
->	O
dpager	O
,	O
addr	int
+	O
amount_sent	O
,	O
vm_page_size	O
,	O
offset	int
+	O
amount_sent	O
)	O
!=	O
PAGER_SUCCESS	int
)	O
{	O
dprintf	O
(	O
"%s%s write error\n"	*(char)
,	O
my_name	array(char)
,	O
here	array(char)
)	O
;	O
dstruct_lock	O
(	O
ds	int
)	O
;	O
ds	int
->	O
errors	O
++	O
;	O
dstruct_unlock	O
(	O
ds	int
)	O
;	O
}	O
}	O
}	O
pager_port_finish_write	O
(	O
ds	int
)	O
;	O
if	O
(	O
vm_deallocate	()->(int)
(	O
default_pager_self	int
,	O
addr	int
,	O
data_cnt	int
)	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
return	O
(	O
KERN_SUCCESS	O
)	O
;	O
}	O
kern_return_t	O
seqnos_memory_object_data_return	O
(	O
ds	int
,	O
seqno	int
,	O
pager_request	int
,	O
offset	int
,	O
addr	int
,	O
data_cnt	int
,	O
dirty	int
,	O
kernel_copy	int
)	O
default_pager_t	O
ds	int
;	O
mach_port_seqno_t	O
seqno	int
;	O
mach_port_t	O
pager_request	int
;	O
vm_offset_t	O
offset	int
;	O
pointer_t	O
addr	int
;	O
vm_size_t	O
data_cnt	int
;	O
boolean_t	O
dirty	int
;	O
boolean_t	O
kernel_copy	int
;	O
{	O
register	O
vm_size_t	O
amount_sent	O
;	O
static	O
char	O
here	array(char)
[	O
]	O
=	O
"%sdata_return"	*(char)
;	O
int	O
err	O
;	O
(	O
void	O
)	O
dirty	int
;	O
(	O
void	O
)	O
kernel_copy	int
;	O
if	O
(	O
(	O
data_cnt	int
%	O
vm_page_size	O
)	O
!=	O
0	int
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
if	O
(	O
ds	int
==	O
DEFAULT_PAGER_NULL	O
)	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
pager_port_lock	()->(int)
(	O
ds	int
,	O
seqno	int
)	O
;	O
pager_port_start_write	O
(	O
ds	int
)	O
;	O
vm_size_t	O
limit	int
=	O
ds	int
->	O
dpager	O
.	O
byte_limit	O
;	O
pager_port_unlock	()->(int)
(	O
ds	int
)	O
;	O
if	O
(	O
(	O
limit	int
!=	O
round_page	()->(int)
(	O
limit	int
)	O
)	O
&&	O
(	O
trunc_page	O
(	O
limit	int
)	O
==	O
offset	int
)	O
)	O
{	O
assert	O
(	O
trunc_page	O
(	O
limit	int
)	O
==	O
offset	int
)	O
;	O
assert	O
(	O
data_cnt	int
==	O
vm_page_size	O
)	O
;	O
vm_offset_t	O
tail	O
=	O
addr	int
+	O
limit	int
-	O
trunc_page	O
(	O
limit	int
)	O
;	O
vm_size_t	O
tail_size	O
=	O
round_page	()->(int)
(	O
limit	int
)	O
-	O
limit	int
;	O
memset	O
(	O
(	O
void	O
*	O
)	O
tail	O
,	O
0	int
,	O
tail_size	O
)	O
;	O
memory_object_data_supply	O
(	O
pager_request	int
,	O
trunc_page	O
(	O
limit	int
)	O
,	O
addr	int
,	O
vm_page_size	O
,	O
TRUE	O
,	O
VM_PROT_NONE	O
,	O
TRUE	O
,	O
MACH_PORT_NULL	O
)	O
;	O
dstruct_lock	O
(	O
ds	int
)	O
;	O
ds	int
->	O
dpager	O
.	O
byte_limit	O
=	O
round_page	()->(int)
(	O
limit	int
)	O
;	O
dstruct_unlock	O
(	O
ds	int
)	O
;	O
pager_port_finish_write	O
(	O
ds	int
)	O
;	O
return	O
(	O
KERN_SUCCESS	O
)	O
;	O
}	O
for	O
(	O
amount_sent	O
=	O
0	int
;	O
amount_sent	O
<	O
data_cnt	int
;	O
amount_sent	O
+=	O
vm_page_size	O
)	O
{	O
int	O
result	int
;	O
result	int
=	O
default_write	O
(	O
&	O
ds	int
->	O
dpager	O
,	O
addr	int
+	O
amount_sent	O
,	O
vm_page_size	O
,	O
offset	int
+	O
amount_sent	O
)	O
;	O
if	O
(	O
result	int
!=	O
KERN_SUCCESS	O
)	O
{	O
dstruct_lock	O
(	O
ds	int
)	O
;	O
ds	int
->	O
errors	O
++	O
;	O
dstruct_unlock	O
(	O
ds	int
)	O
;	O
}	O
default_pager_pageout_count	int
++	O
;	O
}	O
pager_port_finish_write	O
(	O
ds	int
)	O
;	O
err	O
=	O
vm_deallocate	()->(int)
(	O
default_pager_self	int
,	O
addr	int
,	O
data_cnt	int
)	O
;	O
if	O
(	O
err	O
!=	O
KERN_SUCCESS	O
)	O
{	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
}	O
return	O
(	O
KERN_SUCCESS	O
)	O
;	O
}	O
kern_return_t	O
seqnos_memory_object_copy	O
(	O
old_memory_object	O
,	O
seqno	int
,	O
old_memory_control	int
,	O
offset	int
,	O
length	int
,	O
new_memory_object	int
)	O
default_pager_t	O
old_memory_object	O
;	O
mach_port_seqno_t	O
seqno	int
;	O
memory_object_control_t	O
old_memory_control	int
;	O
vm_offset_t	O
offset	int
;	O
vm_size_t	O
length	int
;	O
memory_object_t	O
new_memory_object	int
;	O
{	O
panic	()->(int)
(	O
"%scopy"	*(char)
,	O
my_name	array(char)
)	O
;	O
return	O
KERN_FAILURE	O
;	O
}	O
kern_return_t	O
seqnos_memory_object_lock_completed	(int,int,int,int,int)->(int)
(	O
default_pager_t	O
ds	int
,	O
mach_port_seqno_t	O
seqno	int
,	O
mach_port_t	O
pager_request	int
,	O
vm_offset_t	O
offset	int
,	O
vm_size_t	O
length	int
)	O
{	O
panic	()->(int)
(	O
"%slock_completed"	*(char)
,	O
my_name	array(char)
)	O
;	O
return	O
KERN_FAILURE	O
;	O
}	O
kern_return_t	O
seqnos_memory_object_data_unlock	O
(	O
pager	int
,	O
seqno	int
,	O
pager_request	int
,	O
offset	int
,	O
length	int
,	O
protection_required	int
)	O
default_pager_t	O
pager	int
;	O
mach_port_seqno_t	O
seqno	int
;	O
mach_port_t	O
pager_request	int
;	O
vm_offset_t	O
offset	int
;	O
vm_size_t	O
length	int
;	O
vm_prot_t	O
protection_required	int
;	O
{	O
panic	()->(int)
(	O
"%sdata_unlock"	*(char)
,	O
my_name	array(char)
)	O
;	O
return	O
(	O
KERN_FAILURE	O
)	O
;	O
}	O
kern_return_t	O
seqnos_memory_object_supply_completed	O
(	O
ds	int
,	O
seqno	int
,	O
pager_request	int
,	O
offset	int
,	O
length	int
,	O
result	int
,	O
error_offset	int
)	O
default_pager_t	O
ds	int
;	O
mach_port_seqno_t	O
seqno	int
;	O
mach_port_t	O
pager_request	int
;	O
vm_offset_t	O
offset	int
;	O
vm_size_t	O
length	int
;	O
kern_return_t	O
result	int
;	O
vm_offset_t	O
error_offset	int
;	O
{	O
panic	()->(int)
(	O
"%ssupply_completed"	*(char)
,	O
my_name	array(char)
)	O
;	O
return	O
(	O
KERN_FAILURE	O
)	O
;	O
}	O
kern_return_t	O
seqnos_memory_object_change_completed	O
(	O
ds	int
,	O
seqno	int
,	O
may_cache	int
,	O
copy_strategy	int
)	O
default_pager_t	O
ds	int
;	O
mach_port_seqno_t	O
seqno	int
;	O
boolean_t	O
may_cache	int
;	O
memory_object_copy_strategy_t	O
copy_strategy	int
;	O
{	O
panic	()->(int)
(	O
"%schange_completed"	*(char)
,	O
my_name	array(char)
)	O
;	O
return	O
(	O
KERN_FAILURE	O
)	O
;	O
}	O
boolean_t	O
default_pager_notify_server	O
(	O
in	*(int)
,	O
out	*(int)
)	O
mach_msg_header_t	O
*	O
in	*(int)
,	O
*	O
out	*(int)
;	O
{	O
mach_no_senders_notification_t	O
*	O
n	int
=	O
(	O
mach_no_senders_notification_t	O
*	O
)	O
in	*(int)
;	O
if	O
(	O
(	O
n	int
->	O
not_header	O
.	O
msgh_bits	O
!=	O
MACH_MSGH_BITS	()->(int)
(	O
0	int
,	O
MACH_MSG_TYPE_PORT_SEND_ONCE	O
)	O
)	O
||	O
(	O
n	int
->	O
not_header	O
.	O
msgh_id	O
!=	O
MACH_NOTIFY_NO_SENDERS	O
)	O
)	O
return	O
FALSE	O
;	O
assert	O
(	O
n	int
->	O
not_header	O
.	O
msgh_size	O
==	O
sizeof	O
*	O
n	int
)	O
;	O
assert	O
(	O
n	int
->	O
not_header	O
.	O
msgh_remote_port	O
==	O
MACH_PORT_NULL	O
)	O
;	O
assert	O
(	O
n	int
->	O
not_type	O
.	O
msgt_name	O
==	O
MACH_MSG_TYPE_INTEGER_32	O
)	O
;	O
assert	O
(	O
n	int
->	O
not_type	O
.	O
msgt_size	O
==	O
32	int
)	O
;	O
assert	O
(	O
n	int
->	O
not_type	O
.	O
msgt_number	O
==	O
1	int
)	O
;	O
assert	O
(	O
n	int
->	O
not_type	O
.	O
msgt_inline	O
)	O
;	O
assert	O
(	O
!	O
n	int
->	O
not_type	O
.	O
msgt_longform	O
)	O
;	O
default_pager_no_senders	O
(	O
n	int
->	O
not_header	O
.	O
msgh_local_port	O
,	O
n	int
->	O
not_header	O
.	O
msgh_seqno	O
,	O
n	int
->	O
not_count	O
)	O
;	O
out	*(int)
->	O
msgh_remote_port	O
=	O
MACH_PORT_NULL	O
;	O
return	O
TRUE	O
;	O
}	O
extern	O
boolean_t	O
seqnos_memory_object_default_server	()->(int)
(	O
)	O
;	O
extern	O
boolean_t	O
default_pager_server	()->(int)
(	O
)	O
;	O
extern	O
boolean_t	O
exc_server	()->(int)
(	O
)	O
;	O
extern	O
boolean_t	O
bootstrap_server	()->(int)
(	O
)	O
;	O
extern	O
void	O
bootstrap_compat	()->(void)
(	O
)	O
;	O
mach_msg_size_t	O
default_pager_msg_size_object	int
=	O
128	int
;	O
static	O
void	O
mig_reply_setup	(*(int),*(int))->(void)
(	O
const	O
mach_msg_header_t	O
*	O
in	*(int)
,	O
mach_msg_header_t	O
*	O
out	*(int)
)	O
{	O
static	O
const	O
mach_msg_type_t	O
RetCodeType	int
=	O
{	O
MACH_MSG_TYPE_INTEGER_32	O
,	O
32	int
,	O
1	int
,	O
TRUE	O
,	O
FALSE	O
,	O
FALSE	O
,	O
0	int
}	O
;	O
OutP	O
->	O
Head	O
.	O
msgh_bits	O
=	O
MACH_MSGH_BITS	()->(int)
(	O
MACH_MSGH_BITS_REMOTE	()->(int)
(	O
InP	O
->	O
msgh_bits	O
)	O
,	O
0	int
)	O
;	O
OutP	O
->	O
Head	O
.	O
msgh_size	O
=	O
sizeof	O
*	O
OutP	O
;	O
OutP	O
->	O
Head	O
.	O
msgh_remote_port	O
=	O
InP	O
->	O
msgh_remote_port	O
;	O
OutP	O
->	O
Head	O
.	O
msgh_local_port	O
=	O
MACH_PORT_NULL	O
;	O
OutP	O
->	O
Head	O
.	O
msgh_seqno	O
=	O
0	int
;	O
OutP	O
->	O
Head	O
.	O
msgh_id	O
=	O
InP	O
->	O
msgh_id	O
+	O
100	int
;	O
OutP	O
->	O
RetCodeType	int
=	O
RetCodeType	int
;	O
OutP	O
->	O
RetCode	O
=	O
MIG_BAD_ID	O
;	O
}	O
boolean_t	O
default_pager_demux_object	O
(	O
in	*(int)
,	O
out	*(int)
)	O
mach_msg_header_t	O
*	O
in	*(int)
;	O
mach_msg_header_t	O
*	O
out	*(int)
;	O
{	O
int	O
rval	O
=	O
FALSE	O
;	O
ddprintf	O
(	O
"DPAGER DEMUX OBJECT <%p>: %d\n"	*(char)
,	O
in	*(int)
,	O
in	*(int)
->	O
msgh_id	O
)	O
;	O
mig_reply_setup	(*(int),*(int))->(void)
(	O
in	*(int)
,	O
out	*(int)
)	O
;	O
mig_routine_t	O
routine	O
;	O
if	O
(	O
(	O
routine	O
=	O
seqnos_memory_object_server_routine	O
(	O
in	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
seqnos_memory_object_default_server_routine	O
(	O
in	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
NULL	O
,	O
default_pager_notify_server	O
(	O
in	*(int)
,	O
out	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
default_pager_server_routine	O
(	O
in	*(int)
)	O
)	O
)	O
{	O
if	O
(	O
routine	O
)	O
(	O
*	O
routine	O
)	O
(	O
in	*(int)
,	O
out	*(int)
)	O
;	O
rval	O
=	O
TRUE	O
;	O
}	O
ddprintf	O
(	O
"DPAGER DEMUX OBJECT DONE <%p>: %d\n"	*(char)
,	O
in	*(int)
,	O
in	*(int)
->	O
msgh_id	O
)	O
;	O
return	O
rval	O
;	O
}	O
mach_msg_size_t	O
default_pager_msg_size_default	int
=	O
8	int
*	O
1024	int
;	O
boolean_t	O
default_pager_demux_default	O
(	O
in	*(int)
,	O
out	*(int)
)	O
mach_msg_header_t	O
*	O
in	*(int)
;	O
mach_msg_header_t	O
*	O
out	*(int)
;	O
{	O
if	O
(	O
in	*(int)
->	O
msgh_local_port	O
==	O
default_pager_default_port	int
)	O
{	O
int	O
rval	O
;	O
ddprintf	O
(	O
"DPAGER DEMUX DEFAULT <%p>: %d\n"	*(char)
,	O
in	*(int)
,	O
in	*(int)
->	O
msgh_id	O
)	O
;	O
rval	O
=	O
(	O
seqnos_memory_object_default_server	()->(int)
(	O
in	*(int)
,	O
out	*(int)
)	O
||	O
default_pager_server	()->(int)
(	O
in	*(int)
,	O
out	*(int)
)	O
)	O
;	O
ddprintf	O
(	O
"DPAGER DEMUX DEFAULT DONE <%p>: %d\n"	*(char)
,	O
in	*(int)
,	O
in	*(int)
->	O
msgh_id	O
)	O
;	O
return	O
rval	O
;	O
}	O
else	O
if	O
(	O
in	*(int)
->	O
msgh_local_port	O
==	O
default_pager_exception_port	int
)	O
{	O
return	O
exc_server	()->(int)
(	O
in	*(int)
,	O
out	*(int)
)	O
;	O
}	O
else	O
{	O
panic	()->(int)
(	O
my_name	array(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
void	O
default_pager_thread_privileges	()->(void)
(	O
)	O
{	O
wire_thread	()->(int)
(	O
)	O
;	O
}	O
void	O
*	O
default_pager_default_thread	(*(void))->(*(void))
(	O
void	O
*	O
arg	*(void)
)	O
{	O
kern_return_t	O
kr	O
;	O
default_pager_thread_privileges	()->(void)
(	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
kr	O
=	O
mach_msg_server	()->(int)
(	O
default_pager_demux_default	O
,	O
default_pager_msg_size_default	int
,	O
default_pager_default_set	int
)	O
;	O
panic	()->(int)
(	O
my_name	array(char)
,	O
kr	O
)	O
;	O
}	O
}	O
void	O
*	O
default_pager_thread	struct(int,int,int)
(	O
void	O
*	O
arg	*(void)
)	O
{	O
mach_port_t	O
pset	O
;	O
kern_return_t	O
kr	O
;	O
dpt	*(struct(int,int,int))
=	O
(	O
default_pager_thread_t	struct(int,int,int)
*	O
)	O
arg	*(void)
;	O
if	O
(	O
dpt	*(struct(int,int,int))
->	O
dpt_internal	int
)	O
{	O
default_pager_thread_privileges	()->(void)
(	O
)	O
;	O
pset	O
=	O
default_pager_internal_set	int
;	O
}	O
else	O
{	O
pset	O
=	O
default_pager_external_set	int
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
kr	O
=	O
mach_msg_server	()->(int)
(	O
default_pager_demux_object	O
,	O
default_pager_msg_size_object	int
,	O
pset	O
)	O
;	O
panic	()->(int)
(	O
"%s%s"	*(char)
,	O
my_name	array(char)
,	O
strerror	O
(	O
kr	O
)	O
)	O
;	O
}	O
}	O
void	O
start_default_pager_thread	()->(int)
(	O
internal	int
)	O
boolean_t	O
internal	int
;	O
{	O
default_pager_thread_t	struct(int,int,int)
*	O
ndpt	O
;	O
kern_return_t	O
kr	O
;	O
error_t	O
err	O
;	O
ndpt	O
=	O
(	O
default_pager_thread_t	struct(int,int,int)
*	O
)	O
kalloc	()->(int)
(	O
sizeof	O
*	O
ndpt	O
)	O
;	O
if	O
(	O
ndpt	O
==	O
0	int
)	O
panic	()->(int)
(	O
my_name	array(char)
)	O
;	O
ndpt	O
->	O
dpt_internal	int
=	O
internal	int
;	O
kr	O
=	O
vm_allocate	()->(int)
(	O
default_pager_self	int
,	O
&	O
ndpt	O
->	O
dpt_buffer	int
,	O
vm_page_size	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
my_name	array(char)
)	O
;	O
wire_memory	O
(	O
ndpt	O
->	O
dpt_buffer	int
,	O
vm_page_size	O
,	O
VM_PROT_READ	O
|	O
VM_PROT_WRITE	O
)	O
;	O
err	O
=	O
pthread_create	O
(	O
&	O
ndpt	O
->	O
dpt_thread	int
,	O
NULL	O
,	O
default_pager_thread	struct(int,int,int)
,	O
ndpt	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
pthread_detach	O
(	O
ndpt	O
->	O
dpt_thread	int
)	O
;	O
else	O
{	O
errno	O
=	O
err	O
;	O
perror	O
(	O
"pthread_create"	*(char)
)	O
;	O
}	O
}	O
void	O
default_pager_initialize	O
(	O
host_port	O
)	O
mach_port_t	O
host_port	O
;	O
{	O
memory_object_t	O
DMM	O
;	O
kern_return_t	O
kr	O
;	O
default_pager_self	int
=	O
mach_task_self	()->(int)
(	O
)	O
;	O
kr	O
=	O
mach_port_allocate	()->(int)
(	O
default_pager_self	int
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
&	O
default_pager_default_port	int
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
my_name	array(char)
)	O
;	O
DMM	O
=	O
default_pager_default_port	int
;	O
kr	O
=	O
vm_set_default_memory_manager	O
(	O
host_port	O
,	O
&	O
DMM	O
)	O
;	O
if	O
(	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
||	O
MACH_PORT_VALID	O
(	O
DMM	O
)	O
)	O
panic	()->(int)
(	O
my_name	array(char)
)	O
;	O
kr	O
=	O
mach_port_allocate	()->(int)
(	O
default_pager_self	int
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
&	O
default_pager_exception_port	int
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
my_name	array(char)
)	O
;	O
wire_setup	O
(	O
host_port	O
)	O
;	O
if	O
(	O
default_pager_internal_count	int
==	O
0	int
)	O
{	O
host_basic_info_data_t	O
h_info	O
;	O
natural_t	O
h_info_count	O
;	O
h_info_count	O
=	O
HOST_BASIC_INFO_COUNT	O
;	O
(	O
void	O
)	O
host_info	O
(	O
host_port	O
,	O
HOST_BASIC_INFO	O
,	O
(	O
host_info_t	O
)	O
&	O
h_info	O
,	O
&	O
h_info_count	O
)	O
;	O
default_pager_internal_count	int
=	O
(	O
h_info	O
.	O
avail_cpus	O
>	O
32	int
?	O
32	int
:	O
h_info	O
.	O
avail_cpus	O
)	O
/	O
4	int
+	O
3	int
;	O
}	O
}	O
void	O
default_pager	()->(void)
(	O
)	O
{	O
kern_return_t	O
kr	O
;	O
int	O
i	int
;	O
default_pager_thread_privileges	()->(void)
(	O
)	O
;	O
wire_all_memory	()->(int)
(	O
)	O
;	O
pager_port_list_init	O
(	O
)	O
;	O
kr	O
=	O
mach_port_allocate	()->(int)
(	O
default_pager_self	int
,	O
MACH_PORT_RIGHT_PORT_SET	O
,	O
&	O
default_pager_internal_set	int
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
my_name	array(char)
)	O
;	O
kr	O
=	O
mach_port_allocate	()->(int)
(	O
default_pager_self	int
,	O
MACH_PORT_RIGHT_PORT_SET	O
,	O
&	O
default_pager_external_set	int
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
my_name	array(char)
)	O
;	O
kr	O
=	O
mach_port_allocate	()->(int)
(	O
default_pager_self	int
,	O
MACH_PORT_RIGHT_PORT_SET	O
,	O
&	O
default_pager_default_set	int
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
my_name	array(char)
)	O
;	O
kr	O
=	O
mach_port_move_member	()->(int)
(	O
default_pager_self	int
,	O
default_pager_default_port	int
,	O
default_pager_default_set	int
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
my_name	array(char)
)	O
;	O
kr	O
=	O
mach_port_move_member	()->(int)
(	O
default_pager_self	int
,	O
default_pager_exception_port	int
,	O
default_pager_default_set	int
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
my_name	array(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
default_pager_internal_count	int
;	O
i	int
++	O
)	O
start_default_pager_thread	()->(int)
(	O
TRUE	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
default_pager_external_count	int
;	O
i	int
++	O
)	O
start_default_pager_thread	()->(int)
(	O
FALSE	O
)	O
;	O
default_pager_default_thread	(*(void))->(*(void))
(	O
0	int
)	O
;	O
}	O
kern_return_t	O
S_default_pager_object_create	(int,*(int),*(int),int)->(int)
(	O
mach_port_t	O
pager	int
,	O
mach_port_t	O
*	O
mem_obj	*(int)
,	O
mach_msg_type_name_t	O
*	O
mem_obj_type	*(int)
,	O
vm_size_t	O
size	int
)	O
{	O
default_pager_t	O
ds	int
;	O
mach_port_t	O
port	O
;	O
kern_return_t	O
result	int
;	O
if	O
(	O
pager	int
!=	O
default_pager_default_port	int
)	O
return	O
KERN_INVALID_ARGUMENT	O
;	O
ds	int
=	O
pager_port_alloc	()->(int)
(	O
size	int
)	O
;	O
result	int
=	O
mach_port_allocate	()->(int)
(	O
default_pager_self	int
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
&	O
port	O
)	O
;	O
if	O
(	O
result	int
!=	O
KERN_SUCCESS	O
)	O
{	O
kfree	()->(int)
(	O
(	O
char	O
*	O
)	O
ds	int
,	O
sizeof	O
*	O
ds	int
)	O
;	O
return	O
result	int
;	O
}	O
ds	int
->	O
pager	int
=	O
port	O
;	O
ds	int
->	O
dpager	O
.	O
limit	int
=	O
size	int
;	O
pager_port_list_insert	()->(int)
(	O
port	O
,	O
ds	int
)	O
;	O
default_pager_add	()->(int)
(	O
ds	int
,	O
FALSE	O
)	O
;	O
*	O
mem_obj	*(int)
=	O
port	O
;	O
*	O
mem_obj_type	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
return	O
(	O
KERN_SUCCESS	O
)	O
;	O
}	O
kern_return_t	O
S_default_pager_info	(int,*(int))->(int)
(	O
mach_port_t	O
pager	int
,	O
default_pager_info_t	O
*	O
infop	*(int)
)	O
{	O
vm_size_t	O
total	O
,	O
free	*(int)
;	O
if	O
(	O
pager	int
!=	O
default_pager_default_port	int
)	O
return	O
KERN_INVALID_ARGUMENT	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
paging_space_info	()->(int)
(	O
&	O
total	O
,	O
&	O
free	*(int)
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
infop	*(int)
->	O
dpi_total_space	O
=	O
ptoa	O
(	O
total	O
)	O
;	O
infop	*(int)
->	O
dpi_free_space	O
=	O
ptoa	O
(	O
free	*(int)
)	O
;	O
infop	*(int)
->	O
dpi_page_size	O
=	O
vm_page_size	O
;	O
return	O
KERN_SUCCESS	O
;	O
}	O
kern_return_t	O
S_default_pager_storage_info	(int,*(int),*(int),*(int),*(int),*(int),*(int))->(int)
(	O
mach_port_t	O
pager	int
,	O
vm_size_array_t	O
*	O
size	int
,	O
mach_msg_type_number_t	O
*	O
sizeCnt	*(int)
,	O
vm_size_array_t	O
*	O
free	*(int)
,	O
mach_msg_type_number_t	O
*	O
freeCnt	*(int)
,	O
data_t	O
*	O
name	*(char)
,	O
mach_msg_type_number_t	O
*	O
nameCnt	*(int)
)	O
{	O
int	O
i	int
,	O
n	int
,	O
m	int
;	O
int	O
len	int
=	O
0	int
;	O
char	O
*	O
names	*(char)
;	O
kern_return_t	O
kr	O
;	O
vm_offset_t	O
addr	int
;	O
vm_size_array_t	O
osize	O
=	O
*	O
size	int
;	O
vm_size_array_t	O
ofree	O
=	O
*	O
free	*(int)
;	O
data_t	O
oname	O
=	O
*	O
name	*(char)
;	O
if	O
(	O
pager	int
!=	O
default_pager_default_port	int
)	O
return	O
KERN_INVALID_ARGUMENT	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
n	int
=	O
all_partitions	O
.	O
n_partitions	O
;	O
len	int
=	O
0	int
;	O
m	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
partition_t	O
part	int
=	O
partition_of	(int)->(int)
(	O
i	int
)	O
;	O
if	O
(	O
part	int
==	O
0	int
)	O
continue	O
;	O
m	int
++	O
;	O
len	int
+=	O
strlen	O
(	O
part	int
->	O
name	*(char)
)	O
+	O
1	int
;	O
}	O
if	O
(	O
*	O
sizeCnt	*(int)
<	O
m	int
)	O
{	O
kr	O
=	O
vm_allocate	()->(int)
(	O
default_pager_self	int
,	O
&	O
addr	int
,	O
round_page	()->(int)
(	O
m	int
*	O
sizeof	O
(	O
*	O
size	int
)	O
)	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
goto	O
nomemory	O
;	O
*	O
size	int
=	O
(	O
vm_size_array_t	O
)	O
addr	int
;	O
}	O
*	O
sizeCnt	*(int)
=	O
m	int
;	O
if	O
(	O
*	O
freeCnt	*(int)
<	O
m	int
)	O
{	O
kr	O
=	O
vm_allocate	()->(int)
(	O
default_pager_self	int
,	O
&	O
addr	int
,	O
round_page	()->(int)
(	O
m	int
*	O
sizeof	O
(	O
*	O
free	*(int)
)	O
)	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
goto	O
nomemory	O
;	O
*	O
free	*(int)
=	O
(	O
vm_size_array_t	O
)	O
addr	int
;	O
}	O
*	O
freeCnt	*(int)
=	O
m	int
;	O
if	O
(	O
*	O
nameCnt	*(int)
<	O
len	int
)	O
{	O
kr	O
=	O
vm_allocate	()->(int)
(	O
default_pager_self	int
,	O
&	O
addr	int
,	O
round_page	()->(int)
(	O
len	int
)	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
goto	O
nomemory	O
;	O
*	O
name	*(char)
=	O
(	O
data_t	O
)	O
addr	int
;	O
}	O
*	O
nameCnt	*(int)
=	O
len	int
;	O
names	*(char)
=	O
*	O
name	*(char)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
partition_t	O
part	int
=	O
partition_of	(int)->(int)
(	O
i	int
)	O
;	O
if	O
(	O
part	int
==	O
0	int
)	O
continue	O
;	O
(	O
*	O
size	int
)	O
[	O
i	int
]	O
=	O
ptoa	O
(	O
part	int
->	O
total_size	O
)	O
;	O
(	O
*	O
free	*(int)
)	O
[	O
i	int
]	O
=	O
ptoa	O
(	O
part	int
->	O
free	*(int)
)	O
;	O
names	*(char)
=	O
stpcpy	O
(	O
names	*(char)
,	O
part	int
->	O
name	*(char)
)	O
+	O
1	int
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
return	O
KERN_SUCCESS	O
;	O
nomemory	O
:	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_partitions	O
.	O
lock	O
)	O
;	O
if	O
(	O
*	O
size	int
!=	O
osize	O
)	O
(	O
void	O
)	O
vm_deallocate	()->(int)
(	O
default_pager_self	int
,	O
(	O
vm_offset_t	O
)	O
*	O
size	int
,	O
round_page	()->(int)
(	O
m	int
*	O
sizeof	O
(	O
*	O
size	int
)	O
)	O
)	O
;	O
if	O
(	O
*	O
free	*(int)
!=	O
ofree	O
)	O
(	O
void	O
)	O
vm_deallocate	()->(int)
(	O
default_pager_self	int
,	O
(	O
vm_offset_t	O
)	O
*	O
free	*(int)
,	O
round_page	()->(int)
(	O
m	int
*	O
sizeof	O
(	O
*	O
free	*(int)
)	O
)	O
)	O
;	O
if	O
(	O
*	O
name	*(char)
!=	O
oname	O
)	O
(	O
void	O
)	O
vm_deallocate	()->(int)
(	O
default_pager_self	int
,	O
(	O
vm_offset_t	O
)	O
*	O
name	*(char)
,	O
len	int
)	O
;	O
return	O
KERN_RESOURCE_SHORTAGE	O
;	O
}	O
kern_return_t	O
S_default_pager_objects	(int,*(int),*(int),*(int),*(int))->(int)
(	O
mach_port_t	O
pager	int
,	O
default_pager_object_array_t	O
*	O
objectsp	*(int)
,	O
natural_t	O
*	O
ocountp	*(int)
,	O
mach_port_array_t	O
*	O
portsp	*(int)
,	O
natural_t	O
*	O
pcountp	*(int)
)	O
{	O
vm_offset_t	O
oaddr	O
=	O
0	int
;	O
vm_size_t	O
osize	O
=	O
0	int
;	O
default_pager_object_t	O
*	O
objects	O
;	O
natural_t	O
opotential	O
;	O
vm_offset_t	O
paddr	O
=	O
0	int
;	O
vm_size_t	O
psize	O
=	O
0	int
;	O
mach_port_t	O
*	O
ports	O
;	O
natural_t	O
ppotential	O
;	O
unsigned	O
int	O
actual	int
;	O
unsigned	O
int	O
num_pagers	int
;	O
kern_return_t	O
kr	O
;	O
default_pager_t	O
entry	union
;	O
if	O
(	O
pager	int
!=	O
default_pager_default_port	int
)	O
return	O
KERN_INVALID_ARGUMENT	O
;	O
num_pagers	int
=	O
0	int
;	O
objects	O
=	O
*	O
objectsp	*(int)
;	O
opotential	O
=	O
*	O
ocountp	*(int)
;	O
ports	O
=	O
*	O
portsp	*(int)
;	O
ppotential	O
=	O
*	O
pcountp	*(int)
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
actual	int
=	O
all_pagers	struct
.	O
htable	O
.	O
nr_items	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
if	O
(	O
opotential	O
<	O
actual	int
)	O
{	O
vm_offset_t	O
newaddr	O
;	O
vm_size_t	O
newsize	O
;	O
newsize	O
=	O
2	int
*	O
round_page	()->(int)
(	O
actual	int
*	O
sizeof	O
*	O
objects	O
)	O
;	O
kr	O
=	O
vm_allocate	()->(int)
(	O
default_pager_self	int
,	O
&	O
newaddr	O
,	O
newsize	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
goto	O
nomemory	O
;	O
oaddr	O
=	O
newaddr	O
;	O
osize	O
=	O
newsize	O
;	O
opotential	O
=	O
osize	O
/	O
sizeof	O
*	O
objects	O
;	O
objects	O
=	O
(	O
default_pager_object_t	O
*	O
)	O
oaddr	O
;	O
}	O
if	O
(	O
ppotential	O
<	O
actual	int
)	O
{	O
vm_offset_t	O
newaddr	O
;	O
vm_size_t	O
newsize	O
;	O
newsize	O
=	O
2	int
*	O
round_page	()->(int)
(	O
actual	int
*	O
sizeof	O
*	O
ports	O
)	O
;	O
kr	O
=	O
vm_allocate	()->(int)
(	O
default_pager_self	int
,	O
&	O
newaddr	O
,	O
newsize	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
goto	O
nomemory	O
;	O
paddr	O
=	O
newaddr	O
;	O
psize	O
=	O
newsize	O
;	O
ppotential	O
=	O
psize	O
/	O
sizeof	O
*	O
ports	O
;	O
ports	O
=	O
(	O
mach_port_t	O
*	O
)	O
paddr	O
;	O
}	O
pthread_mutex_lock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
num_pagers	int
=	O
0	int
;	O
HURD_IHASH_ITERATE	()->(int)
(	O
&	O
all_pagers	struct
.	O
htable	O
,	O
val	O
)	O
{	O
entry	union
=	O
(	O
default_pager_t	O
)	O
val	O
;	O
mach_port_t	O
port	O
;	O
vm_size_t	O
size	int
;	O
if	O
(	O
(	O
num_pagers	int
>=	O
opotential	O
)	O
||	O
(	O
num_pagers	int
>=	O
ppotential	O
)	O
)	O
{	O
break	O
;	O
}	O
if	O
(	O
pthread_mutex_trylock	()->(int)
(	O
&	O
entry	union
->	O
dpager	O
.	O
lock	O
)	O
)	O
goto	O
not_this_one	O
;	O
size	int
=	O
pager_allocated	O
(	O
&	O
entry	union
->	O
dpager	O
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
entry	union
->	O
dpager	O
.	O
lock	O
)	O
;	O
dstruct_lock	O
(	O
entry	union
)	O
;	O
port	O
=	O
entry	union
->	O
pager_name	int
;	O
if	O
(	O
port	O
==	O
MACH_PORT_NULL	O
)	O
{	O
dstruct_unlock	O
(	O
entry	union
)	O
;	O
goto	O
not_this_one	O
;	O
}	O
if	O
(	O
--	O
entry	union
->	O
name_refs	O
==	O
0	int
)	O
{	O
dstruct_unlock	O
(	O
entry	union
)	O
;	O
kr	O
=	O
mach_port_mod_refs	O
(	O
default_pager_self	int
,	O
port	O
,	O
MACH_PORT_RIGHT_SEND	O
,	O
default_pager_max_urefs	int
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
"%sdefault_pager_objects"	*(char)
,	O
my_name	array(char)
)	O
;	O
dstruct_lock	O
(	O
entry	union
)	O
;	O
entry	union
->	O
name_refs	O
+=	O
default_pager_max_urefs	int
;	O
pager_port_finish_refs	O
(	O
entry	union
)	O
;	O
}	O
dstruct_unlock	O
(	O
entry	union
)	O
;	O
objects	O
[	O
num_pagers	int
]	O
.	O
dpo_object	O
=	O
(	O
vm_offset_t	O
)	O
entry	union
;	O
objects	O
[	O
num_pagers	int
]	O
.	O
dpo_size	O
=	O
size	int
;	O
ports	O
[	O
num_pagers	int
++	O
]	O
=	O
port	O
;	O
continue	O
;	O
not_this_one	O
:	O
objects	O
[	O
num_pagers	int
]	O
.	O
dpo_object	O
=	O
(	O
vm_offset_t	O
)	O
0	int
;	O
objects	O
[	O
num_pagers	int
]	O
.	O
dpo_size	O
=	O
0	int
;	O
ports	O
[	O
num_pagers	int
++	O
]	O
=	O
MACH_PORT_NULL	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
if	O
(	O
objects	O
==	O
*	O
objectsp	*(int)
)	O
{	O
*	O
ocountp	*(int)
=	O
num_pagers	int
;	O
}	O
else	O
if	O
(	O
actual	int
==	O
0	int
)	O
{	O
(	O
void	O
)	O
vm_deallocate	()->(int)
(	O
default_pager_self	int
,	O
oaddr	O
,	O
osize	O
)	O
;	O
*	O
ocountp	*(int)
=	O
0	int
;	O
}	O
else	O
{	O
vm_offset_t	O
used	O
;	O
used	O
=	O
round_page	()->(int)
(	O
actual	int
*	O
sizeof	O
*	O
objects	O
)	O
;	O
if	O
(	O
used	O
!=	O
osize	O
)	O
(	O
void	O
)	O
vm_deallocate	()->(int)
(	O
default_pager_self	int
,	O
oaddr	O
+	O
used	O
,	O
osize	O
-	O
used	O
)	O
;	O
*	O
objectsp	*(int)
=	O
objects	O
;	O
*	O
ocountp	*(int)
=	O
num_pagers	int
;	O
}	O
if	O
(	O
ports	O
==	O
*	O
portsp	*(int)
)	O
{	O
*	O
pcountp	*(int)
=	O
num_pagers	int
;	O
}	O
else	O
if	O
(	O
actual	int
==	O
0	int
)	O
{	O
(	O
void	O
)	O
vm_deallocate	()->(int)
(	O
default_pager_self	int
,	O
paddr	O
,	O
psize	O
)	O
;	O
*	O
pcountp	*(int)
=	O
0	int
;	O
}	O
else	O
{	O
vm_offset_t	O
used	O
;	O
used	O
=	O
round_page	()->(int)
(	O
actual	int
*	O
sizeof	O
*	O
ports	O
)	O
;	O
if	O
(	O
used	O
!=	O
psize	O
)	O
(	O
void	O
)	O
vm_deallocate	()->(int)
(	O
default_pager_self	int
,	O
paddr	O
+	O
used	O
,	O
psize	O
-	O
used	O
)	O
;	O
*	O
portsp	*(int)
=	O
ports	O
;	O
*	O
pcountp	*(int)
=	O
num_pagers	int
;	O
}	O
return	O
KERN_SUCCESS	O
;	O
nomemory	O
:	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_pagers	int
;	O
i	int
++	O
)	O
(	O
void	O
)	O
mach_port_deallocate	()->(int)
(	O
default_pager_self	int
,	O
ports	O
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
objects	O
!=	O
*	O
objectsp	*(int)
)	O
(	O
void	O
)	O
vm_deallocate	()->(int)
(	O
default_pager_self	int
,	O
oaddr	O
,	O
osize	O
)	O
;	O
if	O
(	O
ports	O
!=	O
*	O
portsp	*(int)
)	O
(	O
void	O
)	O
vm_deallocate	()->(int)
(	O
default_pager_self	int
,	O
paddr	O
,	O
psize	O
)	O
;	O
return	O
KERN_RESOURCE_SHORTAGE	O
;	O
}	O
kern_return_t	O
S_default_pager_object_pages	(int,int,*(int),*(int))->(int)
(	O
mach_port_t	O
pager	int
,	O
mach_port_t	O
object	int
,	O
default_pager_page_array_t	O
*	O
pagesp	*(int)
,	O
natural_t	O
*	O
countp	*(int)
)	O
{	O
vm_offset_t	O
addr	int
=	O
0	int
;	O
vm_size_t	O
size	int
=	O
0	int
;	O
default_pager_page_t	O
*	O
pages	*(int)
;	O
natural_t	O
potential	O
,	O
actual	int
;	O
kern_return_t	O
kr	O
;	O
if	O
(	O
pager	int
!=	O
default_pager_default_port	int
)	O
return	O
KERN_INVALID_ARGUMENT	O
;	O
pages	*(int)
=	O
*	O
pagesp	*(int)
;	O
potential	O
=	O
*	O
countp	*(int)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
default_pager_t	O
entry	union
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
HURD_IHASH_ITERATE	()->(int)
(	O
&	O
all_pagers	struct
.	O
htable	O
,	O
val	O
)	O
{	O
entry	union
=	O
(	O
default_pager_t	O
)	O
val	O
;	O
dstruct_lock	O
(	O
entry	union
)	O
;	O
if	O
(	O
entry	union
->	O
pager_name	int
==	O
object	int
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
goto	O
found_object	O
;	O
}	O
dstruct_unlock	O
(	O
entry	union
)	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
all_pagers	struct
.	O
lock	O
)	O
;	O
if	O
(	O
pages	*(int)
!=	O
*	O
pagesp	*(int)
)	O
(	O
void	O
)	O
vm_deallocate	()->(int)
(	O
default_pager_self	int
,	O
addr	int
,	O
size	int
)	O
;	O
return	O
KERN_INVALID_ARGUMENT	O
;	O
found_object	O
:	O
if	O
(	O
pthread_mutex_trylock	()->(int)
(	O
&	O
entry	union
->	O
dpager	O
.	O
lock	O
)	O
)	O
{	O
dstruct_unlock	O
(	O
entry	union
)	O
;	O
(	O
void	O
)	O
thread_switch	()->(int)
(	O
MACH_PORT_NULL	O
,	O
SWITCH_OPTION_NONE	O
,	O
0	int
)	O
;	O
continue	O
;	O
}	O
actual	int
=	O
pager_pages	()->(int)
(	O
&	O
entry	union
->	O
dpager	O
,	O
pages	*(int)
,	O
potential	O
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
entry	union
->	O
dpager	O
.	O
lock	O
)	O
;	O
dstruct_unlock	O
(	O
entry	union
)	O
;	O
if	O
(	O
actual	int
<=	O
potential	O
)	O
break	O
;	O
if	O
(	O
pages	*(int)
!=	O
*	O
pagesp	*(int)
)	O
(	O
void	O
)	O
vm_deallocate	()->(int)
(	O
default_pager_self	int
,	O
addr	int
,	O
size	int
)	O
;	O
size	int
=	O
round_page	()->(int)
(	O
actual	int
*	O
sizeof	O
*	O
pages	*(int)
)	O
;	O
kr	O
=	O
vm_allocate	()->(int)
(	O
default_pager_self	int
,	O
&	O
addr	int
,	O
size	int
,	O
TRUE	O
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
return	O
kr	O
;	O
pages	*(int)
=	O
(	O
default_pager_page_t	O
*	O
)	O
addr	int
;	O
potential	O
=	O
size	int
/	O
sizeof	O
*	O
pages	*(int)
;	O
}	O
if	O
(	O
pages	*(int)
==	O
*	O
pagesp	*(int)
)	O
{	O
*	O
countp	*(int)
=	O
actual	int
;	O
}	O
else	O
if	O
(	O
actual	int
==	O
0	int
)	O
{	O
(	O
void	O
)	O
vm_deallocate	()->(int)
(	O
default_pager_self	int
,	O
addr	int
,	O
size	int
)	O
;	O
*	O
countp	*(int)
=	O
0	int
;	O
}	O
else	O
{	O
vm_offset_t	O
used	O
;	O
used	O
=	O
round_page	()->(int)
(	O
actual	int
*	O
sizeof	O
*	O
pages	*(int)
)	O
;	O
if	O
(	O
used	O
!=	O
size	int
)	O
(	O
void	O
)	O
vm_deallocate	()->(int)
(	O
default_pager_self	int
,	O
addr	int
+	O
used	O
,	O
size	int
-	O
used	O
)	O
;	O
*	O
pagesp	*(int)
=	O
pages	*(int)
;	O
*	O
countp	*(int)
=	O
actual	int
;	O
}	O
return	O
KERN_SUCCESS	O
;	O
}	O
kern_return_t	O
S_default_pager_object_set_size	(int,int,int)->(int)
(	O
default_pager_t	O
ds	int
,	O
mach_port_seqno_t	O
seqno	int
,	O
vm_size_t	O
limit	int
)	O
{	O
kern_return_t	O
kr	O
=	O
KERN_SUCCESS	O
;	O
if	O
(	O
ds	int
==	O
DEFAULT_PAGER_NULL	O
)	O
return	O
KERN_INVALID_ARGUMENT	O
;	O
pager_port_lock	()->(int)
(	O
ds	int
,	O
seqno	int
)	O
;	O
pager_port_wait_for_readers	()->(int)
(	O
ds	int
)	O
;	O
pager_port_wait_for_writers	()->(int)
(	O
ds	int
)	O
;	O
vm_size_t	O
rounded_limit	O
=	O
round_page	()->(int)
(	O
limit	int
)	O
;	O
vm_size_t	O
trunc_limit	O
=	O
trunc_page	O
(	O
limit	int
)	O
;	O
if	O
(	O
ds	int
->	O
dpager	O
.	O
limit	int
<	O
rounded_limit	O
)	O
{	O
ds	int
->	O
dpager	O
.	O
limit	int
=	O
rounded_limit	O
;	O
ds	int
->	O
dpager	O
.	O
byte_limit	O
=	O
rounded_limit	O
;	O
kr	O
=	O
memory_object_lock_request	()->(int)
(	O
ds	int
->	O
pager_request	int
,	O
0	int
,	O
rounded_limit	O
,	O
MEMORY_OBJECT_RETURN_NONE	O
,	O
FALSE	O
,	O
VM_PROT_NONE	O
,	O
MACH_PORT_NULL	O
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
"memory_object_lock_request: %d"	*(char)
,	O
kr	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ds	int
->	O
dpager	O
.	O
limit	int
!=	O
rounded_limit	O
)	O
{	O
kr	O
=	O
memory_object_lock_request	()->(int)
(	O
ds	int
->	O
pager_request	int
,	O
rounded_limit	O
,	O
ds	int
->	O
dpager	O
.	O
limit	int
-	O
rounded_limit	O
,	O
MEMORY_OBJECT_RETURN_NONE	O
,	O
TRUE	O
,	O
VM_PROT_ALL	O
,	O
MACH_PORT_NULL	O
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
"memory_object_lock_request: %d"	*(char)
,	O
kr	O
)	O
;	O
ds	int
->	O
dpager	O
.	O
limit	int
=	O
rounded_limit	O
;	O
}	O
if	O
(	O
ds	int
->	O
dpager	O
.	O
size	int
>	O
ds	int
->	O
dpager	O
.	O
limit	int
/	O
vm_page_size	O
)	O
pager_truncate	(int,int)->(void)
(	O
&	O
ds	int
->	O
dpager	O
,	O
ds	int
->	O
dpager	O
.	O
limit	int
/	O
vm_page_size	O
)	O
;	O
if	O
(	O
(	O
limit	int
!=	O
rounded_limit	O
)	O
&&	O
(	O
ds	int
->	O
dpager	O
.	O
limit	int
>	O
limit	int
)	O
)	O
{	O
ds	int
->	O
dpager	O
.	O
byte_limit	O
=	O
limit	int
;	O
kr	O
=	O
memory_object_lock_request	()->(int)
(	O
ds	int
->	O
pager_request	int
,	O
trunc_limit	O
,	O
vm_page_size	O
,	O
MEMORY_OBJECT_RETURN_ALL	O
,	O
TRUE	O
,	O
VM_PROT_NONE	O
,	O
MACH_PORT_NULL	O
)	O
;	O
}	O
}	O
pager_port_unlock	()->(int)
(	O
ds	int
)	O
;	O
return	O
kr	O
;	O
}	O
extern	O
mach_port_t	O
bootstrap_master_device_port	int
;	O
extern	O
mach_port_t	O
bootstrap_master_host_port	int
;	O
kern_return_t	O
S_default_pager_paging_file	O
(	O
pager	int
,	O
mdport	int
,	O
file_name	int
,	O
add	int
)	O
mach_port_t	O
pager	int
;	O
mach_port_t	O
mdport	int
;	O
default_pager_filename_t	O
file_name	int
;	O
boolean_t	O
add	int
;	O
{	O
kern_return_t	O
kr	O
;	O
if	O
(	O
pager	int
!=	O
default_pager_default_port	int
)	O
return	O
KERN_INVALID_ARGUMENT	O
;	O
if	O
(	O
add	int
)	O
{	O
kr	O
=	O
add_paging_file	O
(	O
bootstrap_master_device_port	int
,	O
file_name	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
kr	O
=	O
remove_paging_file	O
(	O
file_name	int
)	O
;	O
}	O
if	O
(	O
mdport	int
!=	O
bootstrap_master_device_port	int
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
mdport	int
)	O
;	O
return	O
kr	O
;	O
}	O
kern_return_t	O
default_pager_register_fileserver	O
(	O
pager	int
,	O
fileserver	int
)	O
mach_port_t	O
pager	int
;	O
mach_port_t	O
fileserver	int
;	O
{	O
if	O
(	O
pager	int
!=	O
default_pager_default_port	int
)	O
return	O
KERN_INVALID_ARGUMENT	O
;	O
return	O
KERN_SUCCESS	O
;	O
}	O
void	O
no_paging_space	()->(int)
(	O
out_of_memory	O
)	O
boolean_t	O
out_of_memory	O
;	O
{	O
static	O
char	O
here	array(char)
[	O
]	O
=	O
"%s *** NOT ENOUGH PAGING SPACE ***"	*(char)
;	O
if	O
(	O
out_of_memory	O
)	O
dprintf	O
(	O
"*** OUT OF MEMORY *** "	*(char)
)	O
;	O
panic	()->(int)
(	O
here	array(char)
,	O
my_name	array(char)
)	O
;	O
}	O
void	O
overcommitted	()->(int)
(	O
got_more_space	O
,	O
space	int
)	O
boolean_t	O
got_more_space	O
;	O
vm_size_t	O
space	int
;	O
{	O
vm_size_t	O
pages_free	O
,	O
pages_total	O
;	O
static	O
boolean_t	O
user_warned	O
=	O
FALSE	O
;	O
static	O
vm_size_t	O
pages_shortage	O
=	O
0	int
;	O
paging_space_info	()->(int)
(	O
&	O
pages_total	O
,	O
&	O
pages_free	O
)	O
;	O
if	O
(	O
got_more_space	O
)	O
{	O
pages_free	O
-=	O
pages_shortage	O
;	O
if	O
(	O
pages_free	O
>	O
0	int
)	O
{	O
pages_shortage	O
=	O
0	int
;	O
if	O
(	O
user_warned	O
)	O
dprintf	O
(	O
"%s paging space ok now.\n"	*(char)
,	O
my_name	array(char)
)	O
;	O
}	O
else	O
pages_shortage	O
=	O
pages_free	O
;	O
user_warned	O
=	O
FALSE	O
;	O
return	O
;	O
}	O
pages_free	O
-=	O
space	int
;	O
pages_shortage	O
=	O
(	O
pages_free	O
>	O
0	int
)	O
?	O
0	int
:	O
-	O
pages_free	O
;	O
if	O
(	O
!	O
user_warned	O
&&	O
pages_shortage	O
)	O
{	O
user_warned	O
=	O
TRUE	O
;	O
dprintf	O
(	O
"%s paging space over-committed.\n"	*(char)
,	O
my_name	array(char)
)	O
;	O
}	O
}	O
void	O
paging_space_info	()->(int)
(	O
totp	O
,	O
freep	O
)	O
vm_size_t	O
*	O
totp	O
,	O
*	O
freep	O
;	O
{	O
vm_size_t	O
total	O
,	O
free	*(int)
;	O
partition_t	O
part	int
;	O
int	O
i	int
;	O
total	O
=	O
free	*(int)
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
all_partitions	O
.	O
n_partitions	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
part	int
=	O
partition_of	(int)->(int)
(	O
i	int
)	O
)	O
==	O
0	int
)	O
continue	O
;	O
total	O
+=	O
part	int
->	O
total_size	O
;	O
free	*(int)
+=	O
part	int
->	O
free	*(int)
;	O
}	O
*	O
totp	O
=	O
total	O
;	O
*	O
freep	O
=	O
free	*(int)
;	O
}	O
kern_return_t	O
catch_exception_raise	O
(	O
exception_port	O
,	O
thread	int
,	O
task	O
,	O
exception	int
,	O
code	int
,	O
subcode	int
)	O
mach_port_t	O
exception_port	O
;	O
mach_port_t	O
thread	int
,	O
task	O
;	O
int	O
exception	int
,	O
code	int
,	O
subcode	int
;	O
{	O
ddprintf	O
(	O
"(default_pager)catch_exception_raise(%d,%d,%d)\n"	*(char)
,	O
exception	int
,	O
code	int
,	O
subcode	int
)	O
;	O
panic	()->(int)
(	O
my_name	array(char)
)	O
;	O
return	O
KERN_FAILURE	O
;	O
}	O
