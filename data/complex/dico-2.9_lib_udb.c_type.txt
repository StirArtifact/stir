struct	O
dico_udb	struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))),*(char),*(char),*(char),*((*(*(void)),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*(char)))->(int)),*((*(void),*(char),*(char),*(*(struct)))->(int)))
{	O
void	O
*	O
handle	*(void)
;	O
dico_url_t	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
;	O
const	O
char	O
*	O
qpw	*(char)
;	O
const	O
char	O
*	O
qgrp	*(char)
;	O
const	O
char	O
*	O
options	*(char)
;	O
int	O
(	O
*	O
_db_open	*((*(*(void)),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char))->(int))
)	O
(	O
void	O
*	O
*	O
,	O
dico_url_t	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
,	O
const	O
char	O
*	O
)	O
;	O
int	O
(	O
*	O
_db_close	*((*(void))->(int))
)	O
(	O
void	O
*	O
)	O
;	O
int	O
(	O
*	O
_db_check_password	*((*(void),*(char),*(char),*(char))->(int))
)	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
int	O
(	O
*	O
_db_get_password	*((*(void),*(char),*(char),*(*(char)))->(int))
)	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
,	O
char	O
*	O
*	O
)	O
;	O
int	O
(	O
*	O
_db_get_groups	*((*(void),*(char),*(char),*(*(struct)))->(int))
)	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
,	O
dico_list_t	*(struct)
*	O
)	O
;	O
}	O
;	O
int	O
dico_udb_open	(*(struct))->(int)
(	O
dico_udb_t	*(struct)
db	*(char)
)	O
{	O
if	O
(	O
!	O
db	*(char)
)	O
return	O
1	int
;	O
if	O
(	O
!	O
db	*(char)
->	O
_db_open	*((*(*(void)),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char))->(int))
)	O
return	O
0	int
;	O
return	O
db	*(char)
->	O
_db_open	*((*(*(void)),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char))->(int))
(	O
&	O
db	*(char)
->	O
handle	*(void)
,	O
db	*(char)
->	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
,	O
db	*(char)
->	O
options	*(char)
)	O
;	O
}	O
int	O
dico_udb_close	(*(struct))->(int)
(	O
dico_udb_t	*(struct)
db	*(char)
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
!	O
db	*(char)
->	O
_db_close	*((*(void))->(int))
)	O
rc	int
=	O
0	int
;	O
else	O
rc	int
=	O
db	*(char)
->	O
_db_close	*((*(void))->(int))
(	O
db	*(char)
->	O
handle	*(void)
)	O
;	O
db	*(char)
->	O
handle	*(void)
=	O
NULL	O
;	O
return	O
rc	int
;	O
}	O
int	O
dico_udb_check_password	(*(struct),*(char),*(char))->(int)
(	O
dico_udb_t	*(struct)
db	*(char)
,	O
const	O
char	O
*	O
key	*(char)
,	O
const	O
char	O
*	O
pass	*(char)
)	O
{	O
if	O
(	O
!	O
db	*(char)
->	O
_db_check_password	*((*(void),*(char),*(char),*(char))->(int))
)	O
return	O
ENOSYS	int
;	O
return	O
db	*(char)
->	O
_db_check_password	*((*(void),*(char),*(char),*(char))->(int))
(	O
db	*(char)
->	O
handle	*(void)
,	O
db	*(char)
->	O
qpw	*(char)
,	O
key	*(char)
,	O
pass	*(char)
)	O
;	O
}	O
int	O
dico_udb_get_password	(*(struct),*(char),*(*(char)))->(int)
(	O
dico_udb_t	*(struct)
db	*(char)
,	O
const	O
char	O
*	O
key	*(char)
,	O
char	O
*	O
*	O
pass	*(char)
)	O
{	O
return	O
db	*(char)
->	O
_db_get_password	*((*(void),*(char),*(char),*(*(char)))->(int))
(	O
db	*(char)
->	O
handle	*(void)
,	O
db	*(char)
->	O
qpw	*(char)
,	O
key	*(char)
,	O
pass	*(char)
)	O
;	O
}	O
int	O
dico_udb_get_groups	(*(struct),*(char),*(*(struct)))->(int)
(	O
dico_udb_t	*(struct)
db	*(char)
,	O
const	O
char	O
*	O
key	*(char)
,	O
dico_list_t	*(struct)
*	O
groups	*(*(struct))
)	O
{	O
return	O
db	*(char)
->	O
_db_get_groups	*((*(void),*(char),*(char),*(*(struct)))->(int))
(	O
db	*(char)
->	O
handle	*(void)
,	O
db	*(char)
->	O
qgrp	*(char)
,	O
key	*(char)
,	O
groups	*(*(struct))
)	O
;	O
}	O
dico_list_t	*(struct)
dico_udb_def_list	*(struct)
;	O
static	O
int	O
udb_def_cmp	(*(void),*(void),*(void))->(int)
(	O
const	O
void	O
*	O
item	*(void)
,	O
const	O
void	O
*	O
data	*(void)
,	O
void	O
*	O
ignore	*(void)
)	O
{	O
const	O
struct	O
dico_udb_def	struct(*(char),*((*(*(void)),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*(char)))->(int)),*((*(void),*(char),*(char),*(*(struct)))->(int)),*((*(void),*(char),*(char),*(char))->(int)))
*	O
def	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
=	O
item	*(void)
;	O
const	O
char	O
*	O
proto	*(char)
=	O
data	*(void)
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
def	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
->	O
proto	*(char)
,	O
proto	*(char)
)	O
;	O
}	O
int	O
dico_udb_define	(*(struct(*(char),*((*`,*`,*`)->(int)),*((*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,*`,*`)->(int)))))->(int)
(	O
struct	O
dico_udb_def	struct(*(char),*((*(*(void)),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*(char)))->(int)),*((*(void),*(char),*(char),*(*(struct)))->(int)),*((*(void),*(char),*(char),*(char))->(int)))
*	O
dptr	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
)	O
{	O
if	O
(	O
!	O
dico_udb_def_list	*(struct)
)	O
{	O
dico_udb_def_list	*(struct)
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
dico_udb_def_list	*(struct)
)	O
{	O
errno	O
=	O
ENOMEM	int
;	O
return	O
1	int
;	O
}	O
dico_list_set_comparator	(*(struct),*((*(void),*(void),*(void))->(int)),*(void))->(int)
(	O
dico_udb_def_list	*(struct)
,	O
udb_def_cmp	(*(void),*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
}	O
return	O
dico_list_append	(*(struct),*(void))->(int)
(	O
dico_udb_def_list	*(struct)
,	O
dptr	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
)	O
;	O
}	O
int	O
dico_udb_create	(*(*(struct)),*(char),*(char),*(char),*(char))->(int)
(	O
dico_udb_t	*(struct)
*	O
pdb	*(*(struct))
,	O
const	O
char	O
*	O
urlstr	*(char)
,	O
const	O
char	O
*	O
qpw	*(char)
,	O
const	O
char	O
*	O
qgrp	*(char)
,	O
const	O
char	O
*	O
options	*(char)
)	O
{	O
dico_url_t	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
;	O
int	O
rc	int
;	O
struct	O
dico_udb_def	struct(*(char),*((*(*(void)),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*(char)))->(int)),*((*(void),*(char),*(char),*(*(struct)))->(int)),*((*(void),*(char),*(char),*(char))->(int)))
*	O
def	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
;	O
struct	O
dico_udb	struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))),*(char),*(char),*(char),*((*(*(void)),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*(char)))->(int)),*((*(void),*(char),*(char),*(*(struct)))->(int)))
*	O
uptr	*(struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char),*(char),*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int))))
;	O
rc	int
=	O
dico_url_parse	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long)))),*(char))->(int)
(	O
&	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
,	O
urlstr	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
errno	O
=	O
EINVAL	int
;	O
return	O
1	int
;	O
}	O
def	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
=	O
dico_list_locate	(*(struct),*(void))->(*(void))
(	O
dico_udb_def_list	*(struct)
,	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
proto	*(char)
)	O
;	O
if	O
(	O
!	O
def	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
)	O
{	O
errno	O
=	O
EINVAL	int
;	O
dico_url_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long)))))->(void)
(	O
&	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
)	O
;	O
return	O
1	int
;	O
}	O
uptr	*(struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char),*(char),*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int))))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
uptr	*(struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char),*(char),*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int))))
)	O
)	O
;	O
if	O
(	O
!	O
uptr	*(struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char),*(char),*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int))))
)	O
return	O
1	int
;	O
uptr	*(struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char),*(char),*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int))))
->	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
=	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
;	O
uptr	*(struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char),*(char),*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int))))
->	O
qpw	*(char)
=	O
qpw	*(char)
;	O
uptr	*(struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char),*(char),*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int))))
->	O
qgrp	*(char)
=	O
qgrp	*(char)
;	O
uptr	*(struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char),*(char),*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int))))
->	O
options	*(char)
=	O
options	*(char)
;	O
uptr	*(struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char),*(char),*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int))))
->	O
_db_open	*((*(*(void)),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char))->(int))
=	O
def	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
->	O
_db_open	*((*(*(void)),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char))->(int))
;	O
uptr	*(struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char),*(char),*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int))))
->	O
_db_close	*((*(void))->(int))
=	O
def	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
->	O
_db_close	*((*(void))->(int))
;	O
uptr	*(struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char),*(char),*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int))))
->	O
_db_check_password	*((*(void),*(char),*(char),*(char))->(int))
=	O
def	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
->	O
_db_check_password	*((*(void),*(char),*(char),*(char))->(int))
;	O
uptr	*(struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char),*(char),*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int))))
->	O
_db_get_password	*((*(void),*(char),*(char),*(*(char)))->(int))
=	O
def	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
->	O
_db_get_password	*((*(void),*(char),*(char),*(*(char)))->(int))
;	O
uptr	*(struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char),*(char),*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int))))
->	O
_db_get_groups	*((*(void),*(char),*(char),*(*(struct)))->(int))
=	O
def	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
->	O
_db_get_groups	*((*(void),*(char),*(char),*(*(struct)))->(int))
;	O
*	O
pdb	*(*(struct))
=	O
uptr	*(struct(*(void),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char),*(char),*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(char))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int))))
;	O
return	O
0	int
;	O
}	O
