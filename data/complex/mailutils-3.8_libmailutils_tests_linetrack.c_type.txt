static	O
int	O
getnum	(*(char),*(int))->(int)
(	O
char	O
const	O
*	O
arg	*(char)
,	O
unsigned	O
*	O
ret	*(*(struct))
)	O
{	O
char	O
*	O
end	struct(*(char),int,int)
;	O
unsigned	O
long	O
x	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
,	O
&	O
end	struct(*(char),int,int)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
end	struct(*(char),int,int)
)	O
{	O
mu_error	(*(char))->(int)
(	O
"bad number: %s"	*(char)
,	O
arg	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
*	O
ret	*(*(struct))
=	O
x	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_retreat	(int,*(*(char)),*(struct),*(void))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
mu_assoc_t	*(struct)
options	*(struct)
,	O
void	O
*	O
env	*(struct)
)	O
{	O
mu_linetrack_t	*(struct)
trk	*(struct)
=	O
env	*(struct)
;	O
unsigned	O
x	long
;	O
if	O
(	O
getnum	(*(char),*(int))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
x	long
)	O
==	O
0	int
)	O
{	O
int	O
rc	int
=	O
mu_linetrack_retreat	(*(struct),long)->(int)
(	O
trk	*(struct)
,	O
x	long
)	O
;	O
if	O
(	O
rc	int
==	O
ERANGE	int
)	O
mu_error	(*(char))->(int)
(	O
"retreat count too big"	*(char)
)	O
;	O
else	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_linetrack_retreat"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
rc	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
com_origin	(int,*(*(char)),*(struct),*(void))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
mu_assoc_t	*(struct)
options	*(struct)
,	O
void	O
*	O
env	*(struct)
)	O
{	O
mu_linetrack_t	*(struct)
trk	*(struct)
=	O
env	*(struct)
;	O
int	O
rc	int
;	O
struct	O
mu_locus_point	struct(*(char),int,int)
pt	*(struct(*(char),int,int))
;	O
pt	*(struct(*(char),int,int))
.	O
mu_file	*(char)
=	O
argv	*(*(char))
[	O
1	int
]	O
;	O
if	O
(	O
getnum	(*(char),*(int))->(int)
(	O
argv	*(*(char))
[	O
2	int
]	O
,	O
&	O
pt	*(struct(*(char),int,int))
.	O
mu_line	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
getnum	(*(char),*(int))->(int)
(	O
argv	*(*(char))
[	O
3	int
]	O
,	O
&	O
pt	*(struct(*(char),int,int))
.	O
mu_col	int
)	O
)	O
return	O
0	int
;	O
rc	int
=	O
mu_linetrack_origin	(*(struct),*(struct(*(char),int,int)))->(int)
(	O
trk	*(struct)
,	O
&	O
pt	*(struct(*(char),int,int))
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_linetrack_origin"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_line	(int,*(*(char)),*(struct),*(void))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
mu_assoc_t	*(struct)
options	*(struct)
,	O
void	O
*	O
env	*(struct)
)	O
{	O
mu_linetrack_t	*(struct)
trk	*(struct)
=	O
env	*(struct)
;	O
int	O
rc	int
;	O
struct	O
mu_locus_point	struct(*(char),int,int)
pt	*(struct(*(char),int,int))
=	O
MU_LOCUS_POINT_INITIALIZER	O
;	O
if	O
(	O
getnum	(*(char),*(int))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
pt	*(struct(*(char),int,int))
.	O
mu_line	int
)	O
)	O
return	O
0	int
;	O
rc	int
=	O
mu_linetrack_origin	(*(struct),*(struct(*(char),int,int)))->(int)
(	O
trk	*(struct)
,	O
&	O
pt	*(struct(*(char),int,int))
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_linetrack_origin"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_rebase	(int,*(*(char)),*(struct),*(void))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
mu_assoc_t	*(struct)
options	*(struct)
,	O
void	O
*	O
env	*(struct)
)	O
{	O
mu_linetrack_t	*(struct)
trk	*(struct)
=	O
env	*(struct)
;	O
int	O
rc	int
;	O
struct	O
mu_locus_point	struct(*(char),int,int)
pt	*(struct(*(char),int,int))
;	O
pt	*(struct(*(char),int,int))
.	O
mu_file	*(char)
=	O
argv	*(*(char))
[	O
1	int
]	O
;	O
if	O
(	O
getnum	(*(char),*(int))->(int)
(	O
argv	*(*(char))
[	O
2	int
]	O
,	O
&	O
pt	*(struct(*(char),int,int))
.	O
mu_line	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
getnum	(*(char),*(int))->(int)
(	O
argv	*(*(char))
[	O
3	int
]	O
,	O
&	O
pt	*(struct(*(char),int,int))
.	O
mu_col	int
)	O
)	O
return	O
0	int
;	O
rc	int
=	O
mu_linetrack_rebase	(*(struct),*(struct(*(char),int,int)))->(int)
(	O
trk	*(struct)
,	O
&	O
pt	*(struct(*(char),int,int))
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_linetrack_rebase"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_point	(int,*(*(char)),*(struct),*(void))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
mu_assoc_t	*(struct)
options	*(struct)
,	O
void	O
*	O
env	*(struct)
)	O
{	O
mu_linetrack_t	*(struct)
trk	*(struct)
=	O
env	*(struct)
;	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
MU_LOCUS_RANGE_INITIALIZER	O
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_linetrack_locus	(*(struct),*(struct(*(char),int,int)))->(int)
(	O
trk	*(struct)
,	O
&	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
beg	struct(*(char),int,int)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_linetrack_locus"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
else	O
{	O
mu_stream_lprintf	(*(struct),*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
mu_strout	*(struct)
,	O
&	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
"%s\n"	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
mu_locus_range_deinit	(*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
&	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
com_bol_p	(int,*(*(char)),*(struct),*(void))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
mu_assoc_t	*(struct)
options	*(struct)
,	O
void	O
*	O
env	*(struct)
)	O
{	O
mu_linetrack_t	*(struct)
trk	*(struct)
=	O
env	*(struct)
;	O
mu_printf	(*(char))->(int)
(	O
"%d\n"	*(char)
,	O
mu_linetrack_at_bol	(*(struct))->(int)
(	O
trk	*(struct)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_stat	(int,*(*(char)),*(struct),*(void))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
mu_assoc_t	*(struct)
options	*(struct)
,	O
void	O
*	O
env	*(struct)
)	O
{	O
mu_linetrack_t	*(struct)
trk	*(struct)
=	O
env	*(struct)
;	O
int	O
rc	int
;	O
struct	O
mu_linetrack_stat	struct(long,long,long)
st	*(struct(long,long,long))
;	O
rc	int
=	O
mu_linetrack_stat	struct(long,long,long)
(	O
trk	*(struct)
,	O
&	O
st	*(struct(long,long,long))
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_linetrack_stat"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
else	O
{	O
mu_printf	(*(char))->(int)
(	O
"n_files=%zu\n"	*(char)
,	O
st	*(struct(long,long,long))
.	O
n_files	long
)	O
;	O
mu_printf	(*(char))->(int)
(	O
"n_lines=%zu\n"	*(char)
,	O
st	*(struct(long,long,long))
.	O
n_lines	long
)	O
;	O
mu_printf	(*(char))->(int)
(	O
"n_chars=%zu\n"	*(char)
,	O
st	*(struct(long,long,long))
.	O
n_chars	long
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
lineproc	(int,*(*(char)),*(struct),*(void))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
mu_assoc_t	*(struct)
options	*(struct)
,	O
void	O
*	O
env	*(struct)
)	O
{	O
char	O
*	O
buf	*(char)
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
mu_linetrack_t	*(struct)
trk	*(struct)
=	O
env	*(struct)
;	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
MU_LOCUS_RANGE_INITIALIZER	O
;	O
char	O
*	O
tok	int
;	O
if	O
(	O
buf	*(char)
[	O
0	int
]	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
buf	*(char)
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
buf	*(char)
,	O
buf	*(char)
+	O
1	int
,	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
)	O
;	O
return	O
MU_ERR_USER0	O
;	O
}	O
mu_c_str_unescape	(*(char),*(char),*(char),*(*(char)))->(int)
(	O
buf	*(char)
,	O
"\\\n"	*(char)
,	O
"\\n"	*(char)
,	O
&	O
tok	int
)	O
;	O
mu_linetrack_advance	(*(struct),*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char),long)->(void)
(	O
trk	*(struct)
,	O
&	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
tok	int
,	O
strlen	(*(char))->(long)
(	O
tok	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
tok	int
)	O
;	O
mu_stream_lprintf	(*(struct),*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
mu_strout	*(struct)
,	O
&	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
"%s\n"	*(char)
,	O
buf	*(char)
)	O
;	O
mu_locus_range_deinit	(*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
&	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
mu_tesh_command	struct(*(char),*(char),*((int,*(*(char)),*(struct),*(void))->(int)),int,int,*(struct))
comtab	array(struct(*(char),*(char),*((int,*(*(char)),*(struct),*(void))->(int)),int,int,*(struct)))
[	O
]	O
=	O
{	O
{	O
"__LINEPROC__"	*(char)
,	O
""	*(char)
,	O
lineproc	(int,*(*(char)),*(struct),*(void))->(int)
}	O
,	O
{	O
"retreat"	*(char)
,	O
"COUNT"	*(char)
,	O
com_retreat	(int,*(*(char)),*(struct),*(void))->(int)
}	O
,	O
{	O
"origin"	*(char)
,	O
"FILE LINE COL"	*(char)
,	O
com_origin	(int,*(*(char)),*(struct),*(void))->(int)
}	O
,	O
{	O
"line"	*(char)
,	O
"NUMBER"	*(char)
,	O
com_line	(int,*(*(char)),*(struct),*(void))->(int)
}	O
,	O
{	O
"point"	*(char)
,	O
"NUMBER"	*(char)
,	O
com_point	(int,*(*(char)),*(struct),*(void))->(int)
}	O
,	O
{	O
"rebase"	*(char)
,	O
"FILE LINE COL"	*(char)
,	O
com_rebase	(int,*(*(char)),*(struct),*(void))->(int)
}	O
,	O
{	O
"bol"	*(char)
,	O
""	*(char)
,	O
com_bol_p	(int,*(*(char)),*(struct),*(void))->(int)
}	O
,	O
{	O
"stat"	*(char)
,	O
""	*(char)
,	O
com_stat	(int,*(*(char)),*(struct),*(void))->(int)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
unsigned	O
long	O
max_lines	long
;	O
char	O
*	O
end	struct(*(char),int,int)
;	O
mu_linetrack_t	*(struct)
trk	*(struct)
;	O
mu_tesh_init	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
argc	long
!=	O
3	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
"usage: %s FILE LINES"	*(char)
,	O
mu_program_name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
max_lines	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
argv	*(*(char))
[	O
2	int
]	O
,	O
&	O
end	struct(*(char),int,int)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
end	struct(*(char),int,int)
||	O
max_lines	long
==	O
0	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
"invalid number of lines"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
MU_ASSERT	O
(	O
mu_linetrack_create	(*(*(struct)),*(char),long)->(int)
(	O
&	O
trk	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
max_lines	long
)	O
)	O
;	O
mu_tesh_read_and_eval	(int,*(*(char)),*(struct(*(char),*(char),*((int,*`,*`,*`)->(int)),int,int,*(struct))),*(void))->(void)
(	O
argc	long
-	O
3	int
,	O
argv	*(*(char))
+	O
3	int
,	O
comtab	array(struct(*(char),*(char),*((int,*(*(char)),*(struct),*(void))->(int)),int,int,*(struct)))
,	O
trk	*(struct)
)	O
;	O
mu_linetrack_destroy	(*(*(struct)))->(void)
(	O
&	O
trk	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
