char	O
*	O
program_name	*(char)
=	O
"info"	*(char)
;	O
static	O
int	O
apropos_p	int
=	O
0	int
;	O
static	O
char	O
*	O
apropos_search_string	*(char)
=	O
NULL	O
;	O
static	O
int	O
index_search_p	int
=	O
0	int
;	O
static	O
int	O
goto_invocation_p	int
=	O
0	int
;	O
static	O
char	O
*	O
invocation_program_name	*(char)
=	O
0	int
;	O
static	O
char	O
*	O
index_search_string	*(char)
=	O
NULL	O
;	O
static	O
int	O
print_version_p	int
=	O
0	int
;	O
static	O
int	O
print_help_p	int
=	O
0	int
;	O
static	O
char	O
*	O
initial_file	*(char)
=	O
0	int
;	O
static	O
char	O
*	O
*	O
user_nodenames	*(*(char))
=	O
NULL	O
;	O
static	O
size_t	long
user_nodenames_index	long
=	O
0	int
;	O
static	O
size_t	long
user_nodenames_slots	long
=	O
0	int
;	O
static	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
=	O
NULL	O
;	O
static	O
size_t	long
ref_slots	long
=	O
0	int
;	O
static	O
size_t	long
ref_index	long
=	O
0	int
;	O
static	O
char	O
*	O
user_filename	*(char)
=	O
NULL	O
;	O
static	O
char	O
*	O
user_output_filename	*(char)
=	O
NULL	O
;	O
int	O
dump_subnodes	int
=	O
0	int
;	O
int	O
vi_keys_p	int
=	O
0	int
;	O
int	O
raw_escapes_p	int
=	O
1	int
;	O
static	O
int	O
all_matches_p	int
=	O
0	int
;	O
static	O
int	O
print_where_p	int
=	O
0	int
;	O
int	O
strict_node_location_p	int
=	O
0	int
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"all"	*(char)
,	O
0	int
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"apropos"	*(char)
,	O
1	int
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"debug"	*(char)
,	O
1	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"directory"	*(char)
,	O
1	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"dribble"	*(char)
,	O
1	int
,	O
0	int
,	O
DRIBBLE_OPTION	int
}	O
,	O
{	O
"file"	*(char)
,	O
1	int
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"help"	*(char)
,	O
0	int
,	O
&	O
print_help_p	int
,	O
1	int
}	O
,	O
{	O
"index-search"	*(char)
,	O
1	int
,	O
0	int
,	O
IDXSRCH_OPTION	int
}	O
,	O
{	O
"init-file"	*(char)
,	O
1	int
,	O
0	int
,	O
INITFLE_OPTION	int
}	O
,	O
{	O
"location"	*(char)
,	O
0	int
,	O
&	O
print_where_p	int
,	O
1	int
}	O
,	O
{	O
"node"	*(char)
,	O
1	int
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"output"	*(char)
,	O
1	int
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"raw-escapes"	*(char)
,	O
0	int
,	O
&	O
raw_escapes_p	int
,	O
1	int
}	O
,	O
{	O
"no-raw-escapes"	*(char)
,	O
0	int
,	O
&	O
raw_escapes_p	int
,	O
0	int
}	O
,	O
{	O
"show-malformed-multibytes"	*(char)
,	O
0	int
,	O
&	O
show_malformed_multibyte_p	int
,	O
1	int
}	O
,	O
{	O
"no-show-malformed-multibytes"	*(char)
,	O
0	int
,	O
&	O
show_malformed_multibyte_p	int
,	O
0	int
}	O
,	O
{	O
"restore"	*(char)
,	O
1	int
,	O
0	int
,	O
RESTORE_OPTION	int
}	O
,	O
{	O
"show-options"	*(char)
,	O
0	int
,	O
0	int
,	O
'O'	O
}	O
,	O
{	O
"strict-node-location"	*(char)
,	O
0	int
,	O
&	O
strict_node_location_p	int
,	O
1	int
}	O
,	O
{	O
"subnodes"	*(char)
,	O
0	int
,	O
&	O
dump_subnodes	int
,	O
1	int
}	O
,	O
{	O
"usage"	*(char)
,	O
0	int
,	O
0	int
,	O
'O'	O
}	O
,	O
{	O
"variable"	*(char)
,	O
1	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"version"	*(char)
,	O
0	int
,	O
&	O
print_version_p	int
,	O
1	int
}	O
,	O
{	O
"vi-keys"	*(char)
,	O
0	int
,	O
&	O
vi_keys_p	int
,	O
1	int
}	O
,	O
{	O
"where"	*(char)
,	O
0	int
,	O
&	O
print_where_p	int
,	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
char	O
*	O
short_options	*(char)
=	O
"ak:d:n:f:ho:ORv:wsx:"	*(char)
;	O
int	O
info_windows_initialized_p	int
=	O
0	int
;	O
static	O
void	O
info_short_help	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
init_messages	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
get_initial_file	(*(int),*(*(*(char))),*(*(char)))->(void)
(	O
int	O
*	O
argc	*(int)
,	O
char	O
*	O
*	O
*	O
argv	*(*(*(char)))
,	O
char	O
*	O
*	O
error	*(char)
)	O
{	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
if	O
(	O
user_filename	*(char)
)	O
{	O
if	O
(	O
!	O
IS_ABSOLUTE	O
(	O
user_filename	*(char)
)	O
&&	O
HAS_SLASH	O
(	O
user_filename	*(char)
)	O
&&	O
!	O
(	O
user_filename	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
IS_SLASH	O
(	O
user_filename	*(char)
[	O
1	int
]	O
)	O
)	O
)	O
{	O
char	O
*	O
s	*(char)
;	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
s	*(char)
,	O
"%s%s"	*(char)
,	O
"./"	*(char)
,	O
user_filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
user_filename	*(char)
)	O
;	O
user_filename	*(char)
=	O
s	*(char)
;	O
}	O
if	O
(	O
IS_ABSOLUTE	O
(	O
user_filename	*(char)
)	O
||	O
HAS_SLASH	O
(	O
user_filename	*(char)
)	O
)	O
initial_file	*(char)
=	O
info_add_extension	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
0	int
,	O
user_filename	*(char)
,	O
0	int
)	O
;	O
else	O
initial_file	*(char)
=	O
info_find_fullpath	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
user_filename	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
initial_file	*(char)
)	O
{	O
if	O
(	O
!	O
filesys_error_number	int
)	O
filesys_error_number	int
=	O
ENOENT	int
;	O
*	O
error	*(char)
=	O
filesys_error_string	(*(char),int)->(*(char))
(	O
user_filename	*(char)
,	O
filesys_error_number	int
)	O
;	O
}	O
return	O
;	O
}	O
if	O
(	O
!	O
(	O
*	O
argv	*(*(*(char)))
)	O
[	O
0	int
]	O
)	O
{	O
initial_file	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"dir"	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
*	O
argv	*(*(*(char)))
)	O
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'('	O
)	O
{	O
info_parse_node	(*(char))->(void)
(	O
(	O
*	O
argv	*(*(*(char)))
)	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
info_parsed_filename	*(char)
)	O
{	O
initial_file	*(char)
=	O
info_find_fullpath	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
info_parsed_filename	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
initial_file	*(char)
)	O
{	O
add_pointer_to_array	O
(	O
info_new_reference	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
initial_file	*(char)
,	O
info_parsed_nodename	*(char)
)	O
,	O
ref_index	long
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
ref_slots	long
,	O
2	int
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
*	O
argv	*(*(*(char)))
,	O
*	O
argv	*(*(*(char)))
+	O
1	int
,	O
*	O
argc	*(int)
--	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
return	O
;	O
}	O
}	O
}	O
{	O
if	O
(	O
(	O
*	O
argv	*(*(*(char)))
)	O
[	O
0	int
]	O
&&	O
mbscasecmp	(*(char),*(char))->(int)
(	O
(	O
*	O
argv	*(*(*(char)))
)	O
[	O
0	int
]	O
,	O
"info"	*(char)
)	O
==	O
0	int
)	O
(	O
*	O
argv	*(*(*(char)))
)	O
[	O
0	int
]	O
=	O
"info-stnd"	*(char)
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
lookup_dir_entry	(*(char),int)->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
(	O
*	O
argv	*(*(*(char)))
)	O
[	O
0	int
]	O
,	O
0	int
)	O
;	O
if	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
{	O
initial_file	*(char)
=	O
info_find_fullpath	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
initial_file	*(char)
)	O
{	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
copy	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
(	O
*	O
argv	*(*(*(char)))
)	O
++	O
;	O
(	O
*	O
argc	*(int)
)	O
--	O
;	O
copy	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
info_copy_reference	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
;	O
free	(*(void))->(void)
(	O
copy	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
)	O
;	O
copy	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
initial_file	*(char)
)	O
;	O
add_pointer_to_array	O
(	O
copy	*(struct(*(char),*(char),*(char),int,int,long,int))
,	O
ref_index	long
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
ref_slots	long
,	O
2	int
)	O
;	O
return	O
;	O
}	O
}	O
}	O
{	O
initial_file	*(char)
=	O
info_find_fullpath	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
(	O
*	O
argv	*(*(*(char)))
)	O
[	O
0	int
]	O
,	O
0	int
)	O
;	O
if	O
(	O
initial_file	*(char)
)	O
{	O
add_pointer_to_array	O
(	O
info_new_reference	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
(	O
*	O
argv	*(*(*(char)))
)	O
[	O
0	int
]	O
,	O
"Top"	*(char)
)	O
,	O
ref_index	long
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
ref_slots	long
,	O
2	int
)	O
;	O
(	O
*	O
argv	*(*(*(char)))
)	O
++	O
;	O
(	O
*	O
argc	*(int)
)	O
--	O
;	O
return	O
;	O
}	O
else	O
asprintf	(*(*(char)),*(char))->(int)
(	O
error	*(char)
,	O
_	O
(	O
"No menu item '%s' in node '%s'"	*(char)
)	O
,	O
(	O
*	O
argv	*(*(*(char)))
)	O
[	O
0	int
]	O
,	O
"(dir)Top"	*(char)
)	O
;	O
}	O
{	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
man_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
debug	O
(	O
3	int
,	O
(	O
"falling back to manpage node"	*(char)
)	O
)	O
;	O
man_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
get_manpage_node	(*(char))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
(	O
*	O
argv	*(*(*(char)))
)	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
man_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
{	O
add_pointer_to_array	O
(	O
info_new_reference	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
MANPAGE_FILE_BUFFER_NAME	*(char)
,	O
(	O
*	O
argv	*(*(*(char)))
)	O
[	O
0	int
]	O
)	O
,	O
ref_index	long
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
ref_slots	long
,	O
2	int
)	O
;	O
initial_file	*(char)
=	O
MANPAGE_FILE_BUFFER_NAME	*(char)
;	O
free	(*(void))->(void)
(	O
man_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
;	O
return	O
;	O
}	O
}	O
{	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
lookup_dir_entry	(*(char),int)->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
(	O
*	O
argv	*(*(*(char)))
)	O
[	O
0	int
]	O
,	O
1	int
)	O
;	O
if	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
{	O
initial_file	*(char)
=	O
info_find_fullpath	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
initial_file	*(char)
)	O
{	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
copy	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
(	O
*	O
argv	*(*(*(char)))
)	O
++	O
;	O
(	O
*	O
argc	*(int)
)	O
--	O
;	O
free	(*(void))->(void)
(	O
*	O
error	*(char)
)	O
;	O
*	O
error	*(char)
=	O
0	int
;	O
copy	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
info_copy_reference	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
;	O
free	(*(void))->(void)
(	O
copy	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
)	O
;	O
copy	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
=	O
initial_file	*(char)
;	O
add_pointer_to_array	O
(	O
copy	*(struct(*(char),*(char),*(char),int,int,long,int))
,	O
ref_index	long
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
ref_slots	long
,	O
2	int
)	O
;	O
return	O
;	O
}	O
}	O
}	O
return	O
;	O
}	O
static	O
void	O
add_initial_nodes	(int,*(*(char)),*(*(char)))->(void)
(	O
int	O
argc	*(int)
,	O
char	O
*	O
*	O
argv	*(*(*(char)))
,	O
char	O
*	O
*	O
error	*(char)
)	O
{	O
if	O
(	O
user_nodenames	*(*(char))
)	O
{	O
int	O
i	int
;	O
if	O
(	O
user_nodenames_index	long
>	O
0	int
&&	O
ref_index	long
>	O
0	int
)	O
{	O
info_reference_free	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(void)
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
)	O
;	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
=	O
0	int
;	O
ref_index	long
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
user_nodenames	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
char	O
*	O
node_filename	*(char)
=	O
0	int
;	O
char	O
*	O
node_nodename	*(char)
=	O
0	int
;	O
info_parse_node	(*(char))->(void)
(	O
user_nodenames	*(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
info_parsed_filename	*(char)
)	O
{	O
node_filename	*(char)
=	O
info_parsed_filename	*(char)
;	O
node_nodename	*(char)
=	O
info_parsed_nodename	*(char)
;	O
}	O
else	O
{	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
;	O
int	O
j	int
;	O
if	O
(	O
!	O
initial_file	*(char)
)	O
continue	O
;	O
node_filename	*(char)
=	O
initial_file	*(char)
;	O
node_nodename	*(char)
=	O
0	int
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
info_find_file	(*(char))->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
node_filename	*(char)
)	O
;	O
if	O
(	O
!	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
(	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
[	O
j	int
]	O
)	O
;	O
j	int
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
user_nodenames	*(*(char))
[	O
i	int
]	O
,	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodename	*(char)
)	O
==	O
0	int
)	O
{	O
node_nodename	*(char)
=	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodename	*(char)
;	O
break	O
;	O
}	O
if	O
(	O
!	O
node_nodename	*(char)
)	O
{	O
int	O
best_guess	int
=	O
-	O
1	int
;	O
int	O
len	long
=	O
strlen	(*(char))->(long)
(	O
user_nodenames	*(*(char))
[	O
i	int
]	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
(	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
[	O
j	int
]	O
)	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
mbscasecmp	(*(char),*(char))->(int)
(	O
user_nodenames	*(*(char))
[	O
i	int
]	O
,	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodename	*(char)
)	O
==	O
0	int
)	O
{	O
node_nodename	*(char)
=	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodename	*(char)
;	O
best_guess	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
best_guess	int
==	O
-	O
1	int
&&	O
(	O
mbsncasecmp	(*(char),*(char),long)->(int)
(	O
user_nodenames	*(*(char))
[	O
i	int
]	O
,	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodename	*(char)
,	O
len	long
)	O
==	O
0	int
)	O
)	O
best_guess	int
=	O
j	int
;	O
}	O
if	O
(	O
best_guess	int
!=	O
-	O
1	int
)	O
{	O
node_nodename	*(char)
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
[	O
best_guess	int
]	O
->	O
nodename	*(char)
;	O
}	O
}	O
if	O
(	O
!	O
node_nodename	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
*	O
error	*(char)
)	O
;	O
asprintf	(*(*(char)),*(char))->(int)
(	O
error	*(char)
,	O
_	O
(	O
"Cannot find node '%s'"	*(char)
)	O
,	O
user_nodenames	*(*(char))
[	O
i	int
]	O
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
node_filename	*(char)
&&	O
node_nodename	*(char)
)	O
add_pointer_to_array	O
(	O
info_new_reference	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
node_filename	*(char)
,	O
node_nodename	*(char)
)	O
,	O
ref_index	long
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
ref_slots	long
,	O
2	int
)	O
;	O
}	O
}	O
if	O
(	O
goto_invocation_p	int
)	O
{	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
top_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
0	int
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
invoc_ref	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
0	int
;	O
char	O
*	O
program	*(char)
;	O
if	O
(	O
ref_index	long
==	O
0	int
)	O
{	O
info_error	(*(char))->(void)
(	O
_	O
(	O
"No program name given"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
invocation_program_name	*(char)
)	O
program	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
invocation_program_name	*(char)
)	O
;	O
else	O
if	O
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
&&	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
->	O
filename	*(char)
)	O
program	*(char)
=	O
program_name_from_file_name	(*(char))->(*(char))
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
->	O
filename	*(char)
)	O
;	O
else	O
program	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
""	*(char)
)	O
;	O
if	O
(	O
ref_index	long
>	O
0	int
)	O
top_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
info_get_node	(*(char),*(char))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
->	O
filename	*(char)
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
->	O
nodename	*(char)
)	O
;	O
if	O
(	O
top_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
invoc_ref	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
info_intuit_options_node	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),*(char))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
top_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
program	*(char)
)	O
;	O
if	O
(	O
invoc_ref	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
{	O
info_reference_free	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(void)
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
)	O
;	O
ref_index	long
=	O
0	int
;	O
add_pointer_to_array	O
(	O
invoc_ref	*(struct(*(char),*(char),*(char),int,int,long,int))
,	O
ref_index	long
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
ref_slots	long
,	O
2	int
)	O
;	O
}	O
free	(*(void))->(void)
(	O
program	*(char)
)	O
;	O
}	O
if	O
(	O
ref_index	long
==	O
0	int
&&	O
initial_file	*(char)
)	O
{	O
add_pointer_to_array	O
(	O
info_new_reference	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
initial_file	*(char)
,	O
"Top"	*(char)
)	O
,	O
ref_index	long
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
ref_slots	long
,	O
2	int
)	O
;	O
}	O
if	O
(	O
*	O
argv	*(*(*(char)))
&&	O
ref_index	long
>	O
0	int
)	O
{	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
initial_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node_via_menus	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
initial_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
info_get_node_with_defaults	(*(char),*(char),*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
->	O
filename	*(char)
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
->	O
nodename	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
initial_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
return	O
;	O
node_via_menus	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
info_follow_menus	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),*(*(char)),*(*(char)),int)->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
initial_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
argv	*(*(*(char)))
,	O
error	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
node_via_menus	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
{	O
argv	*(*(*(char)))
+=	O
argc	*(int)
;	O
argc	*(int)
=	O
0	int
;	O
info_reference_free	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(void)
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
)	O
;	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
=	O
info_new_reference	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
node_via_menus	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
,	O
node_via_menus	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodename	*(char)
)	O
;	O
free_history_node	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(void)
(	O
node_via_menus	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
;	O
}	O
else	O
if	O
(	O
argc	*(int)
==	O
1	int
&&	O
argv	*(*(*(char)))
[	O
0	int
]	O
)	O
{	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
match	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
debug	O
(	O
3	int
,	O
(	O
"looking in indices"	*(char)
)	O
)	O
;	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
info_find_file	(*(char))->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
->	O
filename	*(char)
)	O
;	O
if	O
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
{	O
match	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
look_in_indices	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(char),int)->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
argv	*(*(*(char)))
[	O
0	int
]	O
,	O
0	int
)	O
;	O
if	O
(	O
match	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
{	O
argv	*(*(*(char)))
+=	O
argc	*(int)
;	O
argc	*(int)
=	O
0	int
;	O
free	(*(void))->(void)
(	O
*	O
error	*(char)
)	O
;	O
*	O
error	*(char)
=	O
0	int
;	O
info_reference_free	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(void)
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
)	O
;	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
=	O
info_copy_reference	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
match	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
;	O
}	O
}	O
}	O
if	O
(	O
argc	*(int)
!=	O
0	int
)	O
{	O
initial_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
info_get_node_with_defaults	(*(char),*(char),*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
->	O
filename	*(char)
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
->	O
nodename	*(char)
,	O
0	int
)	O
;	O
free	(*(void))->(void)
(	O
*	O
error	*(char)
)	O
;	O
*	O
error	*(char)
=	O
0	int
;	O
node_via_menus	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
info_follow_menus	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),*(*(char)),*(*(char)),int)->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
initial_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
argv	*(*(*(char)))
,	O
error	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
node_via_menus	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
{	O
if	O
(	O
argc	*(int)
>=	O
2	int
||	O
!	O
*	O
error	*(char)
)	O
{	O
argv	*(*(*(char)))
+=	O
argc	*(int)
;	O
argc	*(int)
=	O
0	int
;	O
info_reference_free	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(void)
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
)	O
;	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
=	O
info_new_reference	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
node_via_menus	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
,	O
node_via_menus	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodename	*(char)
)	O
;	O
}	O
free_history_node	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(void)
(	O
node_via_menus	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
;	O
}	O
}	O
if	O
(	O
argc	*(int)
==	O
1	int
)	O
{	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
nearest	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
debug	O
(	O
3	int
,	O
(	O
"looking in indices sloppily"	*(char)
)	O
)	O
;	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
info_find_file	(*(char))->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
->	O
filename	*(char)
)	O
;	O
if	O
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
{	O
nearest	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
look_in_indices	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(char),int)->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
argv	*(*(*(char)))
[	O
0	int
]	O
,	O
1	int
)	O
;	O
if	O
(	O
nearest	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
{	O
argv	*(*(*(char)))
+=	O
argc	*(int)
;	O
argc	*(int)
=	O
0	int
;	O
free	(*(void))->(void)
(	O
*	O
error	*(char)
)	O
;	O
*	O
error	*(char)
=	O
0	int
;	O
info_reference_free	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(void)
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
)	O
;	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
=	O
info_copy_reference	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
nearest	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
;	O
}	O
}	O
}	O
}	O
return	O
;	O
}	O
static	O
void	O
info_find_matching_files	(*(char))->(void)
(	O
char	O
*	O
filename	*(char)
)	O
{	O
int	O
i	int
;	O
char	O
*	O
searchdir	*(char)
;	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
man_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
i	int
=	O
0	int
;	O
for	O
(	O
searchdir	*(char)
=	O
infopath_first	(*(int))->(*(char))
(	O
&	O
i	int
)	O
;	O
searchdir	*(char)
;	O
searchdir	*(char)
=	O
infopath_next	(*(int))->(*(char))
(	O
&	O
i	int
)	O
)	O
{	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
new_ref	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
dir_entry_of_infodir	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
filename	*(char)
,	O
searchdir	*(char)
)	O
;	O
if	O
(	O
new_ref	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
add_pointer_to_array	O
(	O
new_ref	*(struct(*(char),*(char),*(char),int,int,long,int))
,	O
ref_index	long
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
ref_slots	long
,	O
2	int
)	O
;	O
}	O
i	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
char	O
*	O
p	*(void)
;	O
int	O
j	int
;	O
p	*(void)
=	O
info_file_find_next_in_path	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
filename	*(char)
,	O
&	O
i	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
break	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ref_index	long
;	O
j	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
j	int
]	O
->	O
filename	*(char)
)	O
)	O
break	O
;	O
}	O
if	O
(	O
j	int
==	O
ref_index	long
)	O
{	O
add_pointer_to_array	O
(	O
info_new_reference	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
p	*(void)
,	O
0	int
)	O
,	O
ref_index	long
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
ref_slots	long
,	O
2	int
)	O
;	O
}	O
free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
}	O
man_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
get_manpage_node	(*(char))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
filename	*(char)
)	O
;	O
if	O
(	O
man_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
{	O
free	(*(void))->(void)
(	O
man_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
;	O
add_pointer_to_array	O
(	O
info_new_reference	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
MANPAGE_FILE_BUFFER_NAME	*(char)
,	O
filename	*(char)
)	O
,	O
ref_index	long
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
ref_slots	long
,	O
2	int
)	O
;	O
}	O
}	O
static	O
void	O
set_debug_level	(*(char))->(void)
(	O
const	O
char	O
*	O
arg	*(char)
)	O
{	O
char	O
*	O
p	*(void)
;	O
long	O
n	long
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
,	O
&	O
p	*(void)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(void)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"invalid number: %s\n"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
n	long
<	O
0	int
||	O
n	long
>	O
UINT_MAX	O
)	O
debug_level	int
=	O
UINT_MAX	O
;	O
else	O
debug_level	int
=	O
n	long
;	O
}	O
static	O
void	O
add_file_directory_to_path	(*(char))->(void)
(	O
char	O
*	O
filename	*(char)
)	O
{	O
char	O
*	O
directory_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
char	O
*	O
temp	*(char)
=	O
filename_non_directory	(*(char))->(*(char))
(	O
directory_name	*(char)
)	O
;	O
if	O
(	O
temp	*(char)
!=	O
directory_name	*(char)
)	O
{	O
if	O
(	O
HAVE_DRIVE	O
(	O
directory_name	*(char)
)	O
&&	O
temp	*(char)
==	O
directory_name	*(char)
+	O
2	int
)	O
{	O
*	O
temp	*(char)
=	O
'.'	O
;	O
temp	*(char)
+=	O
2	int
;	O
}	O
temp	*(char)
[	O
-	O
1	int
]	O
=	O
0	int
;	O
infopath_add	(*(char))->(void)
(	O
directory_name	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
directory_name	*(char)
)	O
;	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	*(int)
,	O
char	O
*	O
argv	*(*(*(char)))
[	O
]	O
)	O
{	O
int	O
getopt_long_index	int
;	O
char	O
*	O
init_file	*(char)
=	O
0	int
;	O
char	O
*	O
error	*(char)
=	O
0	int
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
init_messages	()->(void)
(	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
option_character	int
;	O
option_character	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	*(int)
,	O
argv	*(*(*(char)))
,	O
short_options	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
&	O
getopt_long_index	int
)	O
;	O
if	O
(	O
option_character	int
==	O
EOF	O
)	O
break	O
;	O
if	O
(	O
option_character	int
==	O
0	int
&&	O
long_options	array(struct(*(char),int,*(int),int))
[	O
getopt_long_index	int
]	O
.	O
flag	*(int)
==	O
0	int
)	O
option_character	int
=	O
long_options	array(struct(*(char),int,*(int),int))
[	O
getopt_long_index	int
]	O
.	O
val	int
;	O
switch	O
(	O
option_character	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
'a'	O
:	O
all_matches_p	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
infopath_add	(*(char))->(void)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
add_pointer_to_array	O
(	O
optarg	*(char)
,	O
user_nodenames_index	long
,	O
user_nodenames	*(*(char))
,	O
user_nodenames_slots	long
,	O
10	int
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
user_filename	*(char)
)	O
free	(*(void))->(void)
(	O
user_filename	*(char)
)	O
;	O
user_filename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
print_help_p	int
=	O
1	int
;	O
break	O
;	O
case	O
'o'	O
:	O
if	O
(	O
user_output_filename	*(char)
)	O
free	(*(void))->(void)
(	O
user_output_filename	*(char)
)	O
;	O
user_output_filename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'O'	O
:	O
goto_invocation_p	int
=	O
1	int
;	O
break	O
;	O
case	O
'R'	O
:	O
raw_escapes_p	int
=	O
1	int
;	O
break	O
;	O
case	O
's'	O
:	O
dump_subnodes	int
=	O
1	int
;	O
break	O
;	O
case	O
'w'	O
:	O
print_where_p	int
=	O
1	int
;	O
break	O
;	O
case	O
'k'	O
:	O
apropos_p	int
=	O
1	int
;	O
free	(*(void))->(void)
(	O
apropos_search_string	*(char)
)	O
;	O
apropos_search_string	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
DRIBBLE_OPTION	int
:	O
close_dribble_file	()->(void)
(	O
)	O
;	O
open_dribble_file	(*(char))->(void)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
RESTORE_OPTION	int
:	O
info_set_input_from_file	(*(char))->(void)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
IDXSRCH_OPTION	int
:	O
index_search_p	int
=	O
1	int
;	O
free	(*(void))->(void)
(	O
index_search_string	*(char)
)	O
;	O
index_search_string	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
INITFLE_OPTION	int
:	O
init_file	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'v'	O
:	O
{	O
VARIABLE_ALIST	struct(*(char),*(char),*(void),*(*(char)),int)
*	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
;	O
char	O
*	O
p	*(void)
;	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
optarg	*(char)
,	O
'='	O
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
{	O
info_error	(*(char))->(void)
(	O
_	O
(	O
"malformed variable assignment: %s"	*(char)
)	O
,	O
optarg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
*	O
p	*(void)
++	O
=	O
0	int
;	O
if	O
(	O
!	O
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
=	O
variable_by_name	(*(char))->(*(struct(*(char),*(char),*(void),*(*(char)),int)))
(	O
optarg	*(char)
)	O
)	O
)	O
{	O
info_error	(*(char))->(void)
(	O
_	O
(	O
"%s: no such variable"	*(char)
)	O
,	O
optarg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
!	O
set_variable_to_value	(*(struct(*(char),*(char),*(void),*(*(char)),int)),*(char),int)->(int)
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
,	O
p	*(void)
,	O
SET_ON_COMMAND_LINE	int
)	O
)	O
{	O
info_error	(*(char))->(void)
(	O
_	O
(	O
"value %s is not valid for variable %s"	*(char)
)	O
,	O
p	*(void)
,	O
optarg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
'x'	O
:	O
set_debug_level	(*(char))->(void)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Try --help for more information.\n"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
if	O
(	O
(	O
!	O
isatty	(int)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
&&	O
(	O
user_output_filename	*(char)
==	O
NULL	O
)	O
)	O
{	O
user_output_filename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"-"	*(char)
)	O
;	O
dump_subnodes	int
=	O
1	int
;	O
}	O
if	O
(	O
print_version_p	int
)	O
{	O
printf	(*(char))->(int)
(	O
"info (GNU %s) %s\n"	*(char)
,	O
PACKAGE	*(char)
,	O
VERSION	*(char)
)	O
;	O
puts	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	*(char)
)	O
,	O
"2019"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
print_help_p	int
)	O
{	O
info_short_help	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
argc	*(int)
-=	O
optind	int
;	O
argv	*(*(*(char)))
+=	O
optind	int
;	O
if	O
(	O
!	O
user_filename	*(char)
&&	O
argv	*(*(*(char)))
[	O
0	int
]	O
&&	O
HAS_SLASH	O
(	O
argv	*(*(*(char)))
[	O
0	int
]	O
)	O
)	O
{	O
user_filename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
argv	*(*(*(char)))
[	O
0	int
]	O
)	O
;	O
argv	*(*(*(char)))
++	O
;	O
argc	*(int)
--	O
;	O
}	O
if	O
(	O
user_filename	*(char)
)	O
add_file_directory_to_path	(*(char))->(void)
(	O
user_filename	*(char)
)	O
;	O
initialize_terminal_and_keymaps	(*(char))->(void)
(	O
init_file	*(char)
)	O
;	O
infopath_init	()->(void)
(	O
)	O
;	O
if	O
(	O
apropos_p	int
)	O
{	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
apropos_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
;	O
apropos_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
=	O
apropos_in_all_indices	(*(char),int)->(*(*(struct(*(char),*(char),*(char),int,int,long,int))))
(	O
apropos_search_string	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
apropos_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
info_error	(*(char))->(void)
(	O
_	O
(	O
APROPOS_NONE	O
)	O
,	O
apropos_search_string	*(char)
)	O
;	O
else	O
{	O
register	O
int	O
i	int
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
apropos_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\"(%s)%s\" -- %s\n"	*(char)
,	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
,	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
,	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
)	O
;	O
}	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
add_pointer_to_array	O
(	O
0	int
,	O
ref_index	long
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
ref_slots	long
,	O
2	int
)	O
;	O
ref_index	long
--	O
;	O
if	O
(	O
all_matches_p	int
&&	O
!	O
index_search_p	int
)	O
{	O
if	O
(	O
!	O
user_filename	*(char)
&&	O
argv	*(*(*(char)))
[	O
0	int
]	O
)	O
{	O
user_filename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
argv	*(*(*(char)))
[	O
0	int
]	O
)	O
;	O
argv	*(*(*(char)))
++	O
;	O
argc	*(int)
--	O
;	O
}	O
else	O
if	O
(	O
!	O
user_filename	*(char)
)	O
{	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
info_find_matching_files	(*(char))->(void)
(	O
user_filename	*(char)
)	O
;	O
if	O
(	O
ref_index	long
==	O
1	int
)	O
all_matches_p	int
=	O
0	int
;	O
if	O
(	O
print_where_p	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
!	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
i	int
]	O
->	O
filename	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
goto_invocation_p	int
)	O
{	O
char	O
*	O
*	O
p	*(void)
=	O
argv	*(*(*(char)))
;	O
if	O
(	O
*	O
p	*(void)
)	O
{	O
while	O
(	O
p	*(void)
[	O
1	int
]	O
)	O
p	*(void)
++	O
;	O
invocation_program_name	*(char)
=	O
*	O
p	*(void)
;	O
}	O
}	O
get_initial_file	(*(int),*(*(*(char))),*(*(char)))->(void)
(	O
&	O
argc	*(int)
,	O
&	O
argv	*(*(*(char)))
,	O
&	O
error	*(char)
)	O
;	O
if	O
(	O
index_search_p	int
&&	O
all_matches_p	int
&&	O
initial_file	*(char)
)	O
{	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
initial_fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
initial_fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
info_find_file	(*(char))->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
initial_file	*(char)
)	O
;	O
if	O
(	O
initial_fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
{	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
create_virtual_index	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(char))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
initial_fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
index_search_string	*(char)
)	O
;	O
if	O
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
{	O
if	O
(	O
user_output_filename	*(char)
)	O
{	O
FILE	struct
*	O
output_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
0	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
user_output_filename	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
output_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
output_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
user_output_filename	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
output_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
write_node_to_stream	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
output_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
else	O
{	O
initialize_info_session	()->(void)
(	O
)	O
;	O
info_set_node_of_window	(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(void)
(	O
active_window	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
,	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
;	O
info_read_and_dispatch	()->(void)
(	O
)	O
;	O
close_info_session	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
index_search_p	int
&&	O
initial_file	*(char)
&&	O
!	O
user_output_filename	*(char)
)	O
{	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
initial_fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
initial_fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
info_find_file	(*(char))->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
initial_file	*(char)
)	O
;	O
if	O
(	O
initial_fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
{	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
result	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
int	O
i	int
,	O
match_offset	*(int)
;	O
result	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
next_index_match	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(char),int,int,*(int),*(int))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
initial_fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
index_search_string	*(char)
,	O
0	int
,	O
1	int
,	O
&	O
i	int
,	O
&	O
match_offset	*(int)
)	O
;	O
if	O
(	O
result	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
{	O
initialize_info_session	()->(void)
(	O
)	O
;	O
report_index_match	(int,int)->(void)
(	O
i	int
,	O
match_offset	*(int)
)	O
;	O
info_select_reference	(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),*(struct(*(char),*(char),*(char),int,int,long,int)))->(int)
(	O
active_window	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
,	O
result	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
;	O
info_read_and_dispatch	()->(void)
(	O
)	O
;	O
close_info_session	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"no index entries found for '%s'\n"	*(char)
)	O
,	O
index_search_string	*(char)
)	O
;	O
close_dribble_file	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
||	O
strcmp	(*(char),*(char))->(int)
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
[	O
0	int
]	O
->	O
filename	*(char)
,	O
MANPAGE_FILE_BUFFER_NAME	*(char)
)	O
)	O
{	O
add_initial_nodes	(int,*(*(char)),*(*(char)))->(void)
(	O
argc	*(int)
,	O
argv	*(*(*(char)))
,	O
&	O
error	*(char)
)	O
;	O
}	O
if	O
(	O
print_where_p	int
)	O
{	O
if	O
(	O
initial_file	*(char)
)	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
initial_file	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
user_output_filename	*(char)
)	O
{	O
if	O
(	O
error	*(char)
)	O
info_error	(*(char))->(void)
(	O
"%s"	*(char)
,	O
error	*(char)
)	O
;	O
preprocess_nodes_p	int
=	O
0	int
;	O
dump_nodes_to_file	(*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),int)->(void)
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
user_output_filename	*(char)
,	O
dump_subnodes	int
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
if	O
(	O
ref_index	long
==	O
0	int
)	O
{	O
if	O
(	O
error	*(char)
)	O
{	O
info_error	(*(char))->(void)
(	O
"%s"	*(char)
,	O
error	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
info_session	(*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char))->(void)
(	O
ref_list	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
all_matches_p	int
?	O
user_filename	*(char)
:	O
0	int
,	O
error	*(char)
)	O
;	O
close_info_session	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
static	O
void	O
info_short_help	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Usage: %s [OPTION]... [MENU-ITEM...]\n\nRead documentation in Info format.\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
puts	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
"Frequently-used options:\n  -a, --all                    use all matching manuals\n  -k, --apropos=STRING         look up STRING in all indices of all manuals\n  -d, --directory=DIR          add DIR to INFOPATH\n  -f, --file=MANUAL            specify Info manual to visit"	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
"  -h, --help                   display this help and exit\n      --index-search=STRING    go to node pointed by index entry STRING\n  -n, --node=NODENAME          specify nodes in first visited Info file\n  -o, --output=FILE            output selected nodes to FILE"	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
"  -O, --show-options, --usage  go to command-line options node"	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
"      --subnodes               recursively output menu items\n  -v, --variable VAR=VALUE     assign VALUE to Info variable VAR\n      --version                display version information and exit\n  -w, --where, --location      print physical location of Info file"	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
"\nThe first non-option argument, if present, is the menu entry to start from;\nit is searched for in all 'dir' files along INFOPATH.\nIf it is not present, info merges all 'dir' files and shows the result.\nAny remaining arguments are treated as the names of menu\nitems relative to the initial node visited."	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
"\nFor a summary of key bindings, type H within Info."	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
"\nExamples:\n  info                         show top-level dir menu\n  info info-stnd               show the manual for this Info program\n  info emacs                   start at emacs node from top-level dir\n  info emacs buffers           select buffers menu entry in emacs manual\n  info emacs -n Files          start at Files node within emacs manual\n  info '(emacs)Files'          alternative way to start at Files node\n  info --show-options emacs    start at node with emacs' command line options\n  info --subnodes -o out.txt emacs\n                               dump entire emacs manual to out.txt\n  info -f ./foo.info           show file ./foo.info, not searching dir"	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
"Email bug reports to bug-texinfo@gnu.org,\ngeneral questions and discussion to help-texinfo@gnu.org.\nTexinfo home page: http://www.gnu.org/software/texinfo/"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
const	O
char	O
*	O
msg_cant_find_node	*(char)
;	O
const	O
char	O
*	O
msg_cant_file_node	*(char)
;	O
const	O
char	O
*	O
msg_cant_find_window	*(char)
;	O
const	O
char	O
*	O
msg_cant_find_point	*(char)
;	O
const	O
char	O
*	O
msg_cant_kill_last	*(char)
;	O
const	O
char	O
*	O
msg_no_menu_node	*(char)
;	O
const	O
char	O
*	O
msg_no_foot_node	*(char)
;	O
const	O
char	O
*	O
msg_no_xref_node	*(char)
;	O
const	O
char	O
*	O
msg_no_pointer	*(char)
;	O
const	O
char	O
*	O
msg_unknown_command	*(char)
;	O
const	O
char	O
*	O
msg_term_too_dumb	*(char)
;	O
const	O
char	O
*	O
msg_at_node_bottom	*(char)
;	O
const	O
char	O
*	O
msg_at_node_top	*(char)
;	O
const	O
char	O
*	O
msg_one_window	*(char)
;	O
const	O
char	O
*	O
msg_win_too_small	*(char)
;	O
const	O
char	O
*	O
msg_cant_make_help	*(char)
;	O
static	O
void	O
init_messages	()->(void)
(	O
void	O
)	O
{	O
msg_cant_find_node	*(char)
=	O
_	O
(	O
"Cannot find node '%s'"	*(char)
)	O
;	O
msg_cant_file_node	*(char)
=	O
_	O
(	O
"Cannot find node '(%s)%s'"	*(char)
)	O
;	O
msg_cant_find_window	*(char)
=	O
_	O
(	O
"Cannot find a window!"	*(char)
)	O
;	O
msg_cant_find_point	*(char)
=	O
_	O
(	O
"Point doesn't appear within this window's node!"	*(char)
)	O
;	O
msg_cant_kill_last	*(char)
=	O
_	O
(	O
"Cannot delete the last window"	*(char)
)	O
;	O
msg_no_menu_node	*(char)
=	O
_	O
(	O
"No menu in this node"	*(char)
)	O
;	O
msg_no_foot_node	*(char)
=	O
_	O
(	O
"No footnotes in this node"	*(char)
)	O
;	O
msg_no_xref_node	*(char)
=	O
_	O
(	O
"No cross references in this node"	*(char)
)	O
;	O
msg_no_pointer	*(char)
=	O
_	O
(	O
"No '%s' pointer for this node"	*(char)
)	O
;	O
msg_unknown_command	*(char)
=	O
_	O
(	O
"Unknown Info command '%c'; try '?' for help"	*(char)
)	O
;	O
msg_term_too_dumb	*(char)
=	O
_	O
(	O
"Terminal type '%s' is not smart enough to run Info"	*(char)
)	O
;	O
msg_at_node_bottom	*(char)
=	O
_	O
(	O
"You are already at the last page of this node"	*(char)
)	O
;	O
msg_at_node_top	*(char)
=	O
_	O
(	O
"You are already at the first page of this node"	*(char)
)	O
;	O
msg_one_window	*(char)
=	O
_	O
(	O
"Only one window"	*(char)
)	O
;	O
msg_win_too_small	*(char)
=	O
_	O
(	O
"Resulting window would be too small"	*(char)
)	O
;	O
msg_cant_make_help	*(char)
=	O
_	O
(	O
"Not enough room for a help window, please delete a window"	*(char)
)	O
;	O
}	O
