typedef	O
enum	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
{	O
ERROR	int
,	O
BADOP	int
,	O
PLUS	int
,	O
MINUS	int
,	O
EXPONENT	int
,	O
TIMES	int
,	O
DIVIDE	int
,	O
MODULO	int
,	O
ASSIGN	int
,	O
EQ	int
,	O
NOTEQ	int
,	O
GT	int
,	O
GTEQ	int
,	O
LS	int
,	O
LSEQ	int
,	O
LSHIFT	int
,	O
RSHIFT	int
,	O
LNOT	int
,	O
LAND	int
,	O
LOR	int
,	O
NOT	int
,	O
AND	int
,	O
OR	int
,	O
XOR	int
,	O
LEFTP	int
,	O
RIGHTP	int
,	O
NUMBER	int
,	O
EOTEXT	int
}	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
typedef	O
enum	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
{	O
NO_ERROR	int
,	O
DIVIDE_ZERO	int
,	O
MODULO_ZERO	int
,	O
NEGATIVE_EXPONENT	int
,	O
SYNTAX_ERROR	int
,	O
MISSING_RIGHT	int
,	O
UNKNOWN_INPUT	int
,	O
EXCESS_INPUT	int
,	O
INVALID_OPERATOR	int
}	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
;	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
logical_or_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
logical_and_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
or_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
xor_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
and_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
equality_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
cmp_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
shift_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
add_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
mult_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
exp_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
unary_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
simple_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
)	O
;	O
static	O
const	O
char	O
*	O
eval_text	*(char)
;	O
static	O
const	O
char	O
*	O
last_text	*(char)
;	O
static	O
void	O
eval_init_lex	(*(char))->(void)
(	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
eval_text	*(char)
=	O
text	*(char)
;	O
last_text	*(char)
=	O
NULL	O
;	O
}	O
static	O
void	O
eval_undo	()->(void)
(	O
void	O
)	O
{	O
eval_text	*(char)
=	O
last_text	*(char)
;	O
}	O
static	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
int32_t	int
*	O
val	array(int)
)	O
{	O
while	O
(	O
isspace	(int)->(int)
(	O
to_uchar	O
(	O
*	O
eval_text	*(char)
)	O
)	O
)	O
eval_text	*(char)
++	O
;	O
last_text	*(char)
=	O
eval_text	*(char)
;	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'\0'	O
)	O
return	O
EOTEXT	int
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
to_uchar	O
(	O
*	O
eval_text	*(char)
)	O
)	O
)	O
{	O
int	O
base	*(char)
,	O
digit	int
;	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'0'	O
)	O
{	O
eval_text	*(char)
++	O
;	O
switch	O
(	O
*	O
eval_text	*(char)
)	O
{	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
base	*(char)
=	O
16	int
;	O
eval_text	*(char)
++	O
;	O
break	O
;	O
case	O
'b'	O
:	O
case	O
'B'	O
:	O
base	*(char)
=	O
2	int
;	O
eval_text	*(char)
++	O
;	O
break	O
;	O
case	O
'r'	O
:	O
case	O
'R'	O
:	O
base	*(char)
=	O
0	int
;	O
eval_text	*(char)
++	O
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
to_uchar	O
(	O
*	O
eval_text	*(char)
)	O
)	O
&&	O
base	*(char)
<=	O
36	int
)	O
base	*(char)
=	O
10	int
*	O
base	*(char)
+	O
*	O
eval_text	*(char)
++	O
-	O
'0'	O
;	O
if	O
(	O
base	*(char)
==	O
0	int
||	O
base	*(char)
>	O
36	int
||	O
*	O
eval_text	*(char)
!=	O
':'	O
)	O
return	O
ERROR	int
;	O
eval_text	*(char)
++	O
;	O
break	O
;	O
default	O
:	O
base	*(char)
=	O
8	int
;	O
}	O
}	O
else	O
base	*(char)
=	O
10	int
;	O
*	O
val	array(int)
=	O
0	int
;	O
for	O
(	O
;	O
*	O
eval_text	*(char)
;	O
eval_text	*(char)
++	O
)	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
to_uchar	O
(	O
*	O
eval_text	*(char)
)	O
)	O
)	O
digit	int
=	O
*	O
eval_text	*(char)
-	O
'0'	O
;	O
else	O
if	O
(	O
islower	(int)->(int)
(	O
to_uchar	O
(	O
*	O
eval_text	*(char)
)	O
)	O
)	O
digit	int
=	O
*	O
eval_text	*(char)
-	O
'a'	O
+	O
10	int
;	O
else	O
if	O
(	O
isupper	(int)->(int)
(	O
to_uchar	O
(	O
*	O
eval_text	*(char)
)	O
)	O
)	O
digit	int
=	O
*	O
eval_text	*(char)
-	O
'A'	O
+	O
10	int
;	O
else	O
break	O
;	O
if	O
(	O
base	*(char)
==	O
1	int
)	O
{	O
if	O
(	O
digit	int
==	O
1	int
)	O
(	O
*	O
val	array(int)
)	O
++	O
;	O
else	O
if	O
(	O
digit	int
==	O
0	int
&&	O
!	O
*	O
val	array(int)
)	O
continue	O
;	O
else	O
break	O
;	O
}	O
else	O
if	O
(	O
digit	int
>=	O
base	*(char)
)	O
break	O
;	O
else	O
*	O
val	array(int)
=	O
*	O
val	array(int)
*	O
base	*(char)
+	O
digit	int
;	O
}	O
return	O
NUMBER	int
;	O
}	O
switch	O
(	O
*	O
eval_text	*(char)
++	O
)	O
{	O
case	O
'+'	O
:	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'+'	O
||	O
*	O
eval_text	*(char)
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
PLUS	int
;	O
case	O
'-'	O
:	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'-'	O
||	O
*	O
eval_text	*(char)
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
MINUS	int
;	O
case	O
'*'	O
:	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'*'	O
)	O
{	O
eval_text	*(char)
++	O
;	O
return	O
EXPONENT	int
;	O
}	O
else	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
TIMES	int
;	O
case	O
'/'	O
:	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
DIVIDE	int
;	O
case	O
'%'	O
:	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
MODULO	int
;	O
case	O
'='	O
:	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'='	O
)	O
{	O
eval_text	*(char)
++	O
;	O
return	O
EQ	int
;	O
}	O
return	O
ASSIGN	int
;	O
case	O
'!'	O
:	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'='	O
)	O
{	O
eval_text	*(char)
++	O
;	O
return	O
NOTEQ	int
;	O
}	O
return	O
LNOT	int
;	O
case	O
'>'	O
:	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'='	O
)	O
{	O
eval_text	*(char)
++	O
;	O
return	O
GTEQ	int
;	O
}	O
else	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'>'	O
)	O
{	O
if	O
(	O
*	O
++	O
eval_text	*(char)
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
RSHIFT	int
;	O
}	O
return	O
GT	int
;	O
case	O
'<'	O
:	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'='	O
)	O
{	O
eval_text	*(char)
++	O
;	O
return	O
LSEQ	int
;	O
}	O
else	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'<'	O
)	O
{	O
if	O
(	O
*	O
++	O
eval_text	*(char)
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
LSHIFT	int
;	O
}	O
return	O
LS	int
;	O
case	O
'^'	O
:	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
XOR	int
;	O
case	O
'~'	O
:	O
return	O
NOT	int
;	O
case	O
'&'	O
:	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'&'	O
)	O
{	O
eval_text	*(char)
++	O
;	O
return	O
LAND	int
;	O
}	O
else	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
AND	int
;	O
case	O
'|'	O
:	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'|'	O
)	O
{	O
eval_text	*(char)
++	O
;	O
return	O
LOR	int
;	O
}	O
else	O
if	O
(	O
*	O
eval_text	*(char)
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
OR	int
;	O
case	O
'('	O
:	O
return	O
LEFTP	int
;	O
case	O
')'	O
:	O
return	O
RIGHTP	int
;	O
default	O
:	O
return	O
ERROR	int
;	O
}	O
}	O
bool	bool
evaluate	(*(char),*(int))->(bool)
(	O
const	O
char	O
*	O
expr	*(char)
,	O
int32_t	int
*	O
val	array(int)
)	O
{	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
err	enum(int,int,int,int,int,int,int,int,int)
;	O
eval_init_lex	(*(char))->(void)
(	O
expr	*(char)
)	O
;	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
val	array(int)
)	O
;	O
err	enum(int,int,int,int,int,int,int,int,int)
=	O
logical_or_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
val	array(int)
)	O
;	O
if	O
(	O
err	enum(int,int,int,int,int,int,int,int,int)
==	O
NO_ERROR	int
&&	O
*	O
eval_text	*(char)
!=	O
'\0'	O
)	O
{	O
if	O
(	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
val	array(int)
)	O
==	O
BADOP	int
)	O
err	enum(int,int,int,int,int,int,int,int,int)
=	O
INVALID_OPERATOR	int
;	O
else	O
err	enum(int,int,int,int,int,int,int,int,int)
=	O
EXCESS_INPUT	int
;	O
}	O
switch	O
(	O
err	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
NO_ERROR	int
:	O
break	O
;	O
case	O
MISSING_RIGHT	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"bad expression in eval (missing right parenthesis): %s"	*(char)
,	O
expr	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
SYNTAX_ERROR	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"bad expression in eval: %s"	*(char)
,	O
expr	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
UNKNOWN_INPUT	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"bad expression in eval (bad input): %s"	*(char)
,	O
expr	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
EXCESS_INPUT	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"bad expression in eval (excess input): %s"	*(char)
,	O
expr	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
INVALID_OPERATOR	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"invalid operator in eval: %s"	*(char)
,	O
expr	*(char)
)	O
)	O
;	O
retcode	int
=	O
EXIT_FAILURE	int
;	O
break	O
;	O
case	O
DIVIDE_ZERO	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"divide by zero in eval: %s"	*(char)
,	O
expr	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
MODULO_ZERO	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"modulo by zero in eval: %s"	*(char)
,	O
expr	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
NEGATIVE_EXPONENT	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"negative exponent in eval: %s"	*(char)
,	O
expr	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad error code in evaluate ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
return	O
err	enum(int,int,int,int,int,int,int,int,int)
!=	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
logical_or_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
v1	*(int)
)	O
{	O
int32_t	int
v2	int
;	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
er	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
logical_and_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
v1	*(int)
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
while	O
(	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
)	O
==	O
LOR	int
)	O
{	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
logical_and_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
v2	int
)	O
;	O
if	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
==	O
NO_ERROR	int
)	O
*	O
v1	*(int)
=	O
*	O
v1	*(int)
||	O
v2	int
;	O
else	O
if	O
(	O
*	O
v1	*(int)
!=	O
0	int
&&	O
er	enum(int,int,int,int,int,int,int,int,int)
<	O
SYNTAX_ERROR	int
)	O
*	O
v1	*(int)
=	O
1	int
;	O
else	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
}	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	()->(void)
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
logical_and_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
v1	*(int)
)	O
{	O
int32_t	int
v2	int
;	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
er	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
or_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
v1	*(int)
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
while	O
(	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
)	O
==	O
LAND	int
)	O
{	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
or_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
v2	int
)	O
;	O
if	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
==	O
NO_ERROR	int
)	O
*	O
v1	*(int)
=	O
*	O
v1	*(int)
&&	O
v2	int
;	O
else	O
if	O
(	O
*	O
v1	*(int)
==	O
0	int
&&	O
er	enum(int,int,int,int,int,int,int,int,int)
<	O
SYNTAX_ERROR	int
)	O
;	O
else	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
}	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	()->(void)
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
or_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
v1	*(int)
)	O
{	O
int32_t	int
v2	int
;	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
er	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
xor_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
v1	*(int)
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
while	O
(	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
)	O
==	O
OR	int
)	O
{	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
xor_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
*	O
v1	*(int)
|=	O
v2	int
;	O
}	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	()->(void)
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
xor_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
v1	*(int)
)	O
{	O
int32_t	int
v2	int
;	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
er	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
and_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
v1	*(int)
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
while	O
(	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
)	O
==	O
XOR	int
)	O
{	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
and_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
*	O
v1	*(int)
^=	O
v2	int
;	O
}	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	()->(void)
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
and_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
v1	*(int)
)	O
{	O
int32_t	int
v2	int
;	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
er	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
equality_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
v1	*(int)
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
while	O
(	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
)	O
==	O
AND	int
)	O
{	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
equality_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
*	O
v1	*(int)
&=	O
v2	int
;	O
}	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	()->(void)
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
equality_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
v1	*(int)
)	O
{	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
int32_t	int
v2	int
;	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
er	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
cmp_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
v1	*(int)
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
while	O
(	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
)	O
==	O
EQ	int
||	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
NOTEQ	int
||	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ASSIGN	int
)	O
{	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
cmp_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ASSIGN	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: recommend ==, not =, for equality operator"	*(char)
)	O
)	O
;	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
EQ	int
;	O
}	O
*	O
v1	*(int)
=	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
EQ	int
)	O
==	O
(	O
*	O
v1	*(int)
==	O
v2	int
)	O
;	O
}	O
if	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	()->(void)
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
cmp_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
v1	*(int)
)	O
{	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
int32_t	int
v2	int
;	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
er	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
shift_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
v1	*(int)
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
while	O
(	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
)	O
==	O
GT	int
||	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
GTEQ	int
||	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
LS	int
||	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
LSEQ	int
)	O
{	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
shift_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
switch	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
GT	int
:	O
*	O
v1	*(int)
=	O
*	O
v1	*(int)
>	O
v2	int
;	O
break	O
;	O
case	O
GTEQ	int
:	O
*	O
v1	*(int)
=	O
*	O
v1	*(int)
>=	O
v2	int
;	O
break	O
;	O
case	O
LS	int
:	O
*	O
v1	*(int)
=	O
*	O
v1	*(int)
<	O
v2	int
;	O
break	O
;	O
case	O
LSEQ	int
:	O
*	O
v1	*(int)
=	O
*	O
v1	*(int)
<=	O
v2	int
;	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad comparison operator in cmp_term ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	()->(void)
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
shift_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
v1	*(int)
)	O
{	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
int32_t	int
v2	int
;	O
uint32_t	int
u1	int
;	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
er	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
add_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
v1	*(int)
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
while	O
(	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
)	O
==	O
LSHIFT	int
||	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
RSHIFT	int
)	O
{	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
add_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
switch	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
LSHIFT	int
:	O
u1	int
=	O
*	O
v1	*(int)
;	O
u1	int
<<=	O
(	O
uint32_t	int
)	O
(	O
v2	int
&	O
0x1f	int
)	O
;	O
*	O
v1	*(int)
=	O
u1	int
;	O
break	O
;	O
case	O
RSHIFT	int
:	O
u1	int
=	O
*	O
v1	*(int)
<	O
0	int
?	O
~	O
*	O
v1	*(int)
:	O
*	O
v1	*(int)
;	O
u1	int
>>=	O
(	O
uint32_t	int
)	O
(	O
v2	int
&	O
0x1f	int
)	O
;	O
*	O
v1	*(int)
=	O
*	O
v1	*(int)
<	O
0	int
?	O
~	O
u1	int
:	O
u1	int
;	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad shift operator in shift_term ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	()->(void)
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
add_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
v1	*(int)
)	O
{	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
int32_t	int
v2	int
;	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
er	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
mult_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
v1	*(int)
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
while	O
(	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
)	O
==	O
PLUS	int
||	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
MINUS	int
)	O
{	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
mult_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
PLUS	int
)	O
*	O
v1	*(int)
=	O
(	O
int32_t	int
)	O
(	O
(	O
uint32_t	int
)	O
*	O
v1	*(int)
+	O
(	O
uint32_t	int
)	O
v2	int
)	O
;	O
else	O
*	O
v1	*(int)
=	O
(	O
int32_t	int
)	O
(	O
(	O
uint32_t	int
)	O
*	O
v1	*(int)
-	O
(	O
uint32_t	int
)	O
v2	int
)	O
;	O
}	O
if	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	()->(void)
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
mult_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
v1	*(int)
)	O
{	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
int32_t	int
v2	int
;	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
er	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
exp_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
v1	*(int)
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
while	O
(	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
)	O
==	O
TIMES	int
||	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DIVIDE	int
||	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
MODULO	int
)	O
{	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
exp_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
switch	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
TIMES	int
:	O
*	O
v1	*(int)
=	O
(	O
int32_t	int
)	O
(	O
(	O
uint32_t	int
)	O
*	O
v1	*(int)
*	O
(	O
uint32_t	int
)	O
v2	int
)	O
;	O
break	O
;	O
case	O
DIVIDE	int
:	O
if	O
(	O
v2	int
==	O
0	int
)	O
return	O
DIVIDE_ZERO	int
;	O
else	O
if	O
(	O
v2	int
==	O
-	O
1	int
)	O
*	O
v1	*(int)
=	O
(	O
int32_t	int
)	O
-	O
(	O
uint32_t	int
)	O
*	O
v1	*(int)
;	O
else	O
*	O
v1	*(int)
/=	O
v2	int
;	O
break	O
;	O
case	O
MODULO	int
:	O
if	O
(	O
v2	int
==	O
0	int
)	O
return	O
MODULO_ZERO	int
;	O
else	O
if	O
(	O
v2	int
==	O
-	O
1	int
)	O
*	O
v1	*(int)
=	O
0	int
;	O
else	O
*	O
v1	*(int)
%=	O
v2	int
;	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad operator in mult_term ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
op	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	()->(void)
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
exp_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
v1	*(int)
)	O
{	O
uint32_t	int
result	*(*(char))
;	O
int32_t	int
v2	int
;	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
er	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
unary_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
v1	*(int)
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
while	O
(	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
)	O
==	O
EXPONENT	int
)	O
{	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
exp_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
result	*(*(char))
=	O
1	int
;	O
if	O
(	O
v2	int
<	O
0	int
)	O
return	O
NEGATIVE_EXPONENT	int
;	O
if	O
(	O
*	O
v1	*(int)
==	O
0	int
&&	O
v2	int
==	O
0	int
)	O
return	O
DIVIDE_ZERO	int
;	O
while	O
(	O
v2	int
--	O
>	O
0	int
)	O
result	*(*(char))
*=	O
(	O
uint32_t	int
)	O
*	O
v1	*(int)
;	O
*	O
v1	*(int)
=	O
result	*(*(char))
;	O
}	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	()->(void)
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
unary_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
v1	*(int)
)	O
{	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
er	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
PLUS	int
||	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
MINUS	int
||	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
NOT	int
||	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
LNOT	int
)	O
{	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
et2	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
v1	*(int)
)	O
;	O
if	O
(	O
et2	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
unary_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et2	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
v1	*(int)
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
MINUS	int
)	O
*	O
v1	*(int)
=	O
(	O
int32_t	int
)	O
-	O
(	O
uint32_t	int
)	O
*	O
v1	*(int)
;	O
else	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
NOT	int
)	O
*	O
v1	*(int)
=	O
~	O
*	O
v1	*(int)
;	O
else	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
LNOT	int
)	O
*	O
v1	*(int)
=	O
*	O
v1	*(int)
==	O
0	int
?	O
1	int
:	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
simple_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
v1	*(int)
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
simple_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
eval_token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int32_t	int
*	O
v1	*(int)
)	O
{	O
int32_t	int
v2	int
;	O
eval_error	enum(int,int,int,int,int,int,int,int,int)
er	enum(int,int,int,int,int,int,int,int,int)
;	O
switch	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
LEFTP	int
:	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
v1	*(int)
)	O
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum(int,int,int,int,int,int,int,int,int)
=	O
logical_or_term	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(int))->(enum(int,int,int,int,int,int,int,int,int))
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
v1	*(int)
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum(int,int,int,int,int,int,int,int,int)
;	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
eval_lex	(*(int))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
et	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
RIGHTP	int
)	O
return	O
MISSING_RIGHT	int
;	O
break	O
;	O
case	O
NUMBER	int
:	O
break	O
;	O
case	O
BADOP	int
:	O
return	O
INVALID_OPERATOR	int
;	O
default	O
:	O
return	O
SYNTAX_ERROR	int
;	O
}	O
return	O
NO_ERROR	int
;	O
}	O
