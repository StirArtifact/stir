static	O
char	O
*	O
skipws	O
(	O
char	O
*	O
p	*(void)
)	O
{	O
while	O
(	O
*	O
p	*(void)
&&	O
ISWS	O
(	O
*	O
p	*(void)
)	O
)	O
p	*(void)
++	O
;	O
return	O
p	*(void)
;	O
}	O
static	O
char	O
*	O
eow	O
(	O
char	O
*	O
p	*(void)
)	O
{	O
while	O
(	O
*	O
p	*(void)
&&	O
!	O
ISWS	O
(	O
*	O
p	*(void)
)	O
)	O
p	*(void)
++	O
;	O
return	O
p	*(void)
;	O
}	O
static	O
int	O
parsegid	O
(	O
char	O
*	O
val	array(int)
,	O
gid_t	int
*	O
pgid	O
)	O
{	O
struct	O
group	struct(*(char),*(char),int,*(*(char)))
*	O
grp	O
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
val	array(int)
[	O
0	int
]	O
)	O
)	O
{	O
char	O
*	O
p	*(void)
;	O
unsigned	O
long	O
n	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
val	array(int)
,	O
&	O
p	*(void)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
0	int
)	O
{	O
*	O
pgid	O
=	O
n	long
;	O
return	O
0	int
;	O
}	O
}	O
grp	O
=	O
getgrnam	(*(char))->(*(struct(*(char),*(char),int,*(*(char)))))
(	O
val	array(int)
)	O
;	O
if	O
(	O
!	O
grp	O
)	O
return	O
1	int
;	O
*	O
pgid	O
=	O
grp	O
->	O
gr_gid	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parseuid	O
(	O
char	O
*	O
val	array(int)
,	O
uid_t	int
*	O
puid	O
)	O
{	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pwd	O
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
val	array(int)
[	O
0	int
]	O
)	O
)	O
{	O
char	O
*	O
p	*(void)
;	O
unsigned	O
long	O
n	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
val	array(int)
,	O
&	O
p	*(void)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
0	int
)	O
{	O
*	O
puid	O
=	O
n	long
;	O
return	O
0	int
;	O
}	O
}	O
pwd	O
=	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
val	array(int)
)	O
;	O
if	O
(	O
!	O
pwd	O
)	O
return	O
1	int
;	O
*	O
puid	O
=	O
pwd	O
->	O
pw_uid	int
;	O
return	O
0	int
;	O
}	O
struct	O
input_buf	O
{	O
CFSTREAM	O
*	O
cf	O
;	O
struct	O
cfloc	O
loc	O
;	O
struct	O
input_buf	O
*	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
;	O
}	O
;	O
typedef	O
struct	O
input_buf	O
*	O
input_buf_ptr	O
;	O
void	O
init_input_buf	O
(	O
input_buf_ptr	O
*	O
ibufptr	O
,	O
input_buf_ptr	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
,	O
CFSTREAM	O
*	O
cf	O
,	O
char	O
const	O
*	O
filename	O
,	O
int	O
line	O
)	O
{	O
input_buf_ptr	O
ibuf	O
;	O
ibuf	O
=	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
ibuf	O
)	O
)	O
;	O
ibuf	O
->	O
cf	O
=	O
cf	O
;	O
ibuf	O
->	O
loc	O
.	O
beg	O
.	O
filename	O
=	O
xstrdup	(*(char))->(*(char))
(	O
filename	O
)	O
;	O
ibuf	O
->	O
loc	O
.	O
beg	O
.	O
line	O
=	O
line	O
;	O
ibuf	O
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
=	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
;	O
*	O
ibufptr	O
=	O
ibuf	O
;	O
}	O
void	O
free_input_buf	O
(	O
input_buf_ptr	O
*	O
ibufptr	O
)	O
{	O
if	O
(	O
ibufptr	O
&&	O
*	O
ibufptr	O
)	O
{	O
input_buf_ptr	O
ibuf	O
=	O
*	O
ibufptr	O
;	O
cfstream_close	O
(	O
ibuf	O
->	O
cf	O
)	O
;	O
free	(*(void))->(void)
(	O
ibuf	O
)	O
;	O
*	O
ibufptr	O
=	O
NULL	O
;	O
}	O
}	O
static	O
char	O
*	O
read_line_plain	O
(	O
input_buf_ptr	O
ibuf	O
,	O
char	O
*	O
*	O
pbuf	*(*(char))
,	O
size_t	long
*	O
psize	*(long)
)	O
{	O
char	O
*	O
buf	O
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
;	O
size_t	long
len	long
=	O
0	int
;	O
int	O
c	int
;	O
while	O
(	O
1	int
)	O
{	O
c	int
=	O
cfstream_getc	O
(	O
ibuf	O
->	O
cf	O
)	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
len	long
==	O
size	long
)	O
buf	O
=	O
x2realloc	(*(void),*(long))->(*(void))
(	O
buf	O
,	O
&	O
size	long
)	O
;	O
buf	O
[	O
len	long
]	O
=	O
c	int
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
ibuf	O
->	O
loc	O
.	O
beg	O
.	O
line	O
++	O
;	O
if	O
(	O
len	long
>	O
0	int
&&	O
buf	O
[	O
len	long
-	O
1	int
]	O
==	O
'\\'	O
)	O
{	O
len	long
--	O
;	O
}	O
else	O
break	O
;	O
}	O
else	O
len	long
++	O
;	O
}	O
if	O
(	O
buf	O
)	O
{	O
if	O
(	O
len	long
==	O
size	long
)	O
buf	O
=	O
x2realloc	(*(void),*(long))->(*(void))
(	O
buf	O
,	O
&	O
size	long
)	O
;	O
buf	O
[	O
len	long
]	O
=	O
0	int
;	O
}	O
*	O
pbuf	*(*(char))
=	O
buf	O
;	O
*	O
psize	*(long)
=	O
len	long
;	O
return	O
buf	O
;	O
}	O
static	O
char	O
*	O
read_line	O
(	O
input_buf_ptr	O
*	O
ibufptr	O
,	O
char	O
*	O
*	O
pbuf	*(*(char))
,	O
size_t	long
*	O
psize	*(long)
)	O
{	O
do	O
{	O
char	O
*	O
p	*(void)
=	O
read_line_plain	O
(	O
*	O
ibufptr	O
,	O
pbuf	*(*(char))
,	O
psize	*(long)
)	O
;	O
if	O
(	O
p	*(void)
)	O
return	O
p	*(void)
;	O
else	O
{	O
input_buf_ptr	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
=	O
(	O
*	O
ibufptr	O
)	O
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
;	O
debug	O
(	O
3	int
,	O
_	O
(	O
"Finished parsing %s"	*(char)
)	O
,	O
(	O
*	O
ibufptr	O
)	O
->	O
loc	O
.	O
beg	O
.	O
filename	O
)	O
;	O
free_input_buf	O
(	O
ibufptr	O
)	O
;	O
*	O
ibufptr	O
=	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
;	O
if	O
(	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
)	O
debug	O
(	O
3	int
,	O
_	O
(	O
"Resuming parsing %s from line %d"	*(char)
)	O
,	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
->	O
loc	O
.	O
beg	O
.	O
filename	O
,	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
->	O
loc	O
.	O
beg	O
.	O
line	O
)	O
;	O
}	O
}	O
while	O
(	O
*	O
ibufptr	O
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
unquote_char	O
(	O
int	O
c	int
)	O
{	O
char	O
*	O
p	*(void)
;	O
static	O
char	O
quotetab	O
[	O
]	O
=	O
"\\\\a\ab\bf\fn\nr\rt\t"	*(char)
;	O
for	O
(	O
p	*(void)
=	O
quotetab	O
;	O
*	O
p	*(void)
;	O
p	*(void)
+=	O
2	int
)	O
if	O
(	O
*	O
p	*(void)
==	O
c	int
)	O
return	O
p	*(void)
[	O
1	int
]	O
;	O
return	O
c	int
;	O
}	O
static	O
char	O
*	O
copy_string	O
(	O
const	O
char	O
*	O
src	*(char)
)	O
{	O
char	O
*	O
p	*(void)
;	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
src	*(char)
)	O
;	O
char	O
*	O
dest	O
;	O
int	O
add_nl	O
=	O
len	long
>	O
0	int
&&	O
src	*(char)
[	O
len	long
-	O
1	int
]	O
!=	O
'\n'	O
;	O
dest	O
=	O
xmalloc	(long)->(*(void))
(	O
len	long
+	O
(	O
add_nl	O
?	O
1	int
:	O
0	int
)	O
+	O
1	int
)	O
;	O
for	O
(	O
p	*(void)
=	O
dest	O
;	O
*	O
src	*(char)
;	O
)	O
{	O
char	O
c	int
=	O
*	O
src	*(char)
++	O
;	O
if	O
(	O
c	int
==	O
'\\'	O
&&	O
*	O
src	*(char)
)	O
c	int
=	O
unquote_char	O
(	O
*	O
src	*(char)
++	O
)	O
;	O
*	O
p	*(void)
++	O
=	O
c	int
;	O
}	O
if	O
(	O
add_nl	O
)	O
*	O
p	*(void)
++	O
=	O
'\n'	O
;	O
*	O
p	*(void)
=	O
0	int
;	O
return	O
dest	O
;	O
}	O
int	O
parse_cmp_op	O
(	O
enum	O
cmp_op	enum(int,int,int,int,int,int,int,int)
*	O
op	enum(int,int,int,int,int,int,int,int)
,	O
char	O
*	O
*	O
pstr	O
)	O
{	O
char	O
*	O
str	*(char)
=	O
*	O
pstr	O
;	O
if	O
(	O
*	O
str	*(char)
==	O
'='	O
)	O
{	O
if	O
(	O
*	O
++	O
str	*(char)
==	O
'='	O
)	O
str	*(char)
++	O
;	O
*	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_eq	int
;	O
}	O
else	O
if	O
(	O
*	O
str	*(char)
==	O
'!'	O
)	O
{	O
if	O
(	O
*	O
++	O
str	*(char)
==	O
'='	O
)	O
str	*(char)
++	O
;	O
*	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_ne	int
;	O
}	O
else	O
if	O
(	O
*	O
str	*(char)
==	O
'>'	O
)	O
{	O
if	O
(	O
*	O
++	O
str	*(char)
==	O
'='	O
)	O
{	O
str	*(char)
++	O
;	O
*	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_ge	int
;	O
}	O
else	O
*	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_gt	int
;	O
}	O
else	O
if	O
(	O
*	O
str	*(char)
==	O
'<'	O
)	O
{	O
if	O
(	O
*	O
++	O
str	*(char)
==	O
'='	O
)	O
{	O
str	*(char)
++	O
;	O
*	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_le	int
;	O
}	O
else	O
*	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_lt	int
;	O
}	O
else	O
if	O
(	O
c_isascii	(int)->(bool)
(	O
*	O
str	*(char)
)	O
&&	O
c_isdigit	(int)->(bool)
(	O
*	O
str	*(char)
)	O
)	O
*	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_eq	int
;	O
else	O
return	O
1	int
;	O
str	*(char)
=	O
skipws	O
(	O
str	*(char)
)	O
;	O
*	O
pstr	O
=	O
str	*(char)
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
_parse_negation	O
(	O
struct	O
test_node	O
*	O
*	O
pnode	O
,	O
char	O
*	O
val	array(int)
)	O
{	O
if	O
(	O
val	array(int)
[	O
0	int
]	O
==	O
'!'	O
&&	O
val	array(int)
[	O
1	int
]	O
!=	O
'='	O
)	O
{	O
struct	O
test_node	O
*	O
neg	O
=	O
new_test_node	O
(	O
test_not	int
)	O
;	O
neg	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
0	int
]	O
=	O
*	O
pnode	O
;	O
*	O
pnode	O
=	O
neg	O
;	O
val	array(int)
=	O
skipws	O
(	O
val	array(int)
+	O
1	int
)	O
;	O
}	O
return	O
val	array(int)
;	O
}	O
static	O
int	O
numstrtonum	O
(	O
input_buf_ptr	O
ibuf	O
,	O
char	O
*	O
val	array(int)
,	O
struct	O
test_node	O
*	O
node	O
)	O
{	O
char	O
*	O
q	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
num	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
val	array(int)
,	O
&	O
q	O
,	O
10	int
)	O
;	O
if	O
(	O
*	O
q	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
_	O
(	O
"invalid number: %s"	*(char)
)	O
,	O
val	array(int)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
parse_numtest	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
test_node	O
*	O
numtest	O
,	O
char	O
*	O
val	array(int)
,	O
int	O
(	O
*	O
valtonum	O
)	O
(	O
input_buf_ptr	O
,	O
char	O
*	O
,	O
struct	O
test_node	O
*	O
)	O
)	O
{	O
if	O
(	O
parse_cmp_op	O
(	O
&	O
numtest	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
,	O
&	O
val	array(int)
)	O
&&	O
val	array(int)
[	O
strcspn	(*(char),*(char))->(long)
(	O
val	array(int)
,	O
" \t"	*(char)
)	O
]	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"invalid opcode"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
valtonum	O
(	O
ibuf	O
,	O
val	array(int)
,	O
numtest	O
)	O
;	O
}	O
struct	O
stmt_env	O
{	O
char	O
*	O
kw	O
;	O
char	O
*	O
val	array(int)
;	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	*(*(char))
;	O
int	O
index	(*(char),int)->(*(char))
;	O
int	O
progmod	O
;	O
struct	O
test_node	O
*	O
node	O
;	O
input_buf_ptr	O
ret_buf	O
;	O
}	O
;	O
void	O
regexp_error	O
(	O
input_buf_ptr	O
ibuf	O
,	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
*	O
regex	O
,	O
int	O
rc	O
)	O
{	O
char	O
errbuf	O
[	O
512	int
]	O
;	O
regerror	O
(	O
rc	O
,	O
regex	O
,	O
errbuf	O
,	O
sizeof	O
(	O
errbuf	O
)	O
)	O
;	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
_	O
(	O
"invalid regexp: %s"	*(char)
)	O
,	O
errbuf	O
)	O
;	O
}	O
static	O
int	O
_parse_re_flags	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
int	O
fc	O
=	O
env	O
->	O
argc	int
,	O
i	O
;	O
char	O
*	O
*	O
fv	O
=	O
env	O
->	O
argv	*(*(char))
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
fc	O
;	O
i	O
++	O
)	O
{	O
int	O
enable	O
,	O
flag	*(int)
;	O
char	O
*	O
p	*(void)
=	O
fv	O
[	O
i	O
]	O
;	O
switch	O
(	O
*	O
p	*(void)
)	O
{	O
case	O
'+'	O
:	O
p	*(void)
++	O
;	O
enable	O
=	O
1	int
;	O
break	O
;	O
case	O
'-'	O
:	O
p	*(void)
++	O
;	O
enable	O
=	O
0	int
;	O
break	O
;	O
default	O
:	O
enable	O
=	O
1	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"extended"	*(char)
)	O
==	O
0	int
)	O
flag	*(int)
=	O
REG_EXTENDED	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"basic"	*(char)
)	O
==	O
0	int
)	O
{	O
flag	*(int)
=	O
REG_EXTENDED	O
;	O
enable	O
=	O
!	O
enable	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"icase"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"ignore-case"	*(char)
)	O
==	O
0	int
)	O
flag	*(int)
=	O
REG_ICASE	O
;	O
else	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
_	O
(	O
"unknown regexp flag: %s"	*(char)
)	O
,	O
p	*(void)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
enable	O
)	O
re_flags	O
|=	O
flag	*(int)
;	O
else	O
re_flags	O
&=	O
~	O
flag	*(int)
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
check_argc	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
stmt_env	O
*	O
env	O
,	O
int	O
min	O
,	O
int	O
max	O
)	O
{	O
if	O
(	O
env	O
->	O
argc	int
<	O
min	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"too few arguments"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
env	O
->	O
argc	int
>	O
max	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"too many arguments"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_command	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
int	O
rc	O
;	O
struct	O
test_node	O
*	O
node	O
;	O
const	O
char	O
*	O
val	array(int)
;	O
node	O
=	O
new_test_node	O
(	O
test_cmps	int
)	O
;	O
val	array(int)
=	O
_parse_negation	O
(	O
&	O
node	O
,	O
env	O
->	O
val	array(int)
)	O
;	O
rc	O
=	O
regcomp	O
(	O
&	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
rx	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
val	array(int)
,	O
re_flags	O
)	O
;	O
if	O
(	O
rc	O
)	O
regexp_error	O
(	O
ibuf	O
,	O
&	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
rx	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
rc	O
)	O
;	O
else	O
{	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_match	int
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
"$command"	*(char)
;	O
}	O
env	O
->	O
node	O
=	O
node	O
;	O
return	O
rc	O
;	O
}	O
static	O
int	O
_parse_match	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
struct	O
test_node	O
*	O
node	O
;	O
int	O
rc	O
;	O
const	O
char	O
*	O
val	array(int)
;	O
node	O
=	O
new_test_node	O
(	O
test_cmps	int
)	O
;	O
val	array(int)
=	O
_parse_negation	O
(	O
&	O
node	O
,	O
env	O
->	O
val	array(int)
)	O
;	O
rc	O
=	O
regcomp	O
(	O
&	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
rx	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
val	array(int)
,	O
re_flags	O
)	O
;	O
if	O
(	O
rc	O
)	O
regexp_error	O
(	O
ibuf	O
,	O
&	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
rx	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
rc	O
)	O
;	O
else	O
{	O
char	O
buf	O
[	O
INT_BUFSIZE_BOUND	O
(	O
uintmax_t	long
)	O
]	O
;	O
char	O
*	O
p	*(void)
=	O
umaxtostr	(long,*(char))->(*(char))
(	O
env	O
->	O
index	(*(char),int)->(*(char))
,	O
buf	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
+	O
4	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
,	O
"${"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
,	O
p	*(void)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
,	O
"}"	*(char)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_match	int
;	O
}	O
env	O
->	O
node	O
=	O
node	O
;	O
return	O
rc	O
;	O
}	O
static	O
int	O
_parse_argc	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
char	O
*	O
val	array(int)
;	O
struct	O
test_node	O
*	O
node	O
=	O
new_test_node	O
(	O
test_cmpn	int
)	O
;	O
env	O
->	O
node	O
=	O
node	O
;	O
val	array(int)
=	O
_parse_negation	O
(	O
&	O
env	O
->	O
node	O
,	O
env	O
->	O
val	array(int)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
"$#"	*(char)
;	O
return	O
parse_numtest	O
(	O
ibuf	O
,	O
node	O
,	O
val	array(int)
,	O
numstrtonum	O
)	O
;	O
}	O
static	O
int	O
uidtonum	O
(	O
input_buf_ptr	O
ibuf	O
,	O
char	O
*	O
str	*(char)
,	O
struct	O
test_node	O
*	O
node	O
)	O
{	O
uid_t	int
uid	int
;	O
if	O
(	O
parseuid	O
(	O
str	*(char)
,	O
&	O
uid	int
)	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
_	O
(	O
"no such user: %s"	*(char)
)	O
,	O
str	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
num	long
=	O
uid	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_uid	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
char	O
*	O
val	array(int)
;	O
struct	O
test_node	O
*	O
node	O
=	O
new_test_node	O
(	O
test_cmpn	int
)	O
;	O
env	O
->	O
node	O
=	O
node	O
;	O
val	array(int)
=	O
_parse_negation	O
(	O
&	O
env	O
->	O
node	O
,	O
env	O
->	O
val	array(int)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
"$uid"	*(char)
;	O
return	O
parse_numtest	O
(	O
ibuf	O
,	O
node	O
,	O
val	array(int)
,	O
uidtonum	O
)	O
;	O
}	O
static	O
int	O
gidtonum	O
(	O
input_buf_ptr	O
ibuf	O
,	O
char	O
*	O
str	*(char)
,	O
struct	O
test_node	O
*	O
node	O
)	O
{	O
gid_t	int
gid	int
;	O
if	O
(	O
parsegid	O
(	O
str	*(char)
,	O
&	O
gid	int
)	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
_	O
(	O
"no such group: %s"	*(char)
)	O
,	O
str	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
num	long
=	O
gid	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_gid	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
char	O
*	O
val	array(int)
;	O
struct	O
test_node	O
*	O
node	O
=	O
new_test_node	O
(	O
test_cmpn	int
)	O
;	O
env	O
->	O
node	O
=	O
node	O
;	O
val	array(int)
=	O
_parse_negation	O
(	O
&	O
env	O
->	O
node	O
,	O
env	O
->	O
val	array(int)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
"$gid"	*(char)
;	O
return	O
parse_numtest	O
(	O
ibuf	O
,	O
node	O
,	O
val	array(int)
,	O
gidtonum	O
)	O
;	O
}	O
static	O
int	O
_parse_user	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
char	O
*	O
val	array(int)
;	O
struct	O
test_node	O
*	O
node	O
;	O
if	O
(	O
env	O
->	O
argc	int
==	O
1	int
)	O
{	O
node	O
=	O
new_test_node	O
(	O
test_cmps	int
)	O
;	O
val	array(int)
=	O
_parse_negation	O
(	O
&	O
node	O
,	O
env	O
->	O
val	array(int)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_eq	int
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
"$user"	*(char)
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
str	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
val	array(int)
)	O
;	O
}	O
else	O
{	O
size_t	long
i	O
;	O
node	O
=	O
new_test_node	O
(	O
test_in	int
)	O
;	O
val	array(int)
=	O
_parse_negation	O
(	O
&	O
node	O
,	O
env	O
->	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
=	O
cmp_in	int
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
=	O
"$user"	*(char)
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
strv	*(*(char))
=	O
xcalloc	(long,long)->(*(void))
(	O
env	O
->	O
argc	int
+	O
1	int
,	O
sizeof	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
strv	*(*(char))
[	O
0	int
]	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
strv	*(*(char))
[	O
0	int
]	O
=	O
xstrdup	(*(char))->(*(char))
(	O
val	array(int)
)	O
;	O
for	O
(	O
i	O
=	O
1	int
;	O
i	O
<	O
env	O
->	O
argc	int
;	O
i	O
++	O
)	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
strv	*(*(char))
[	O
i	O
]	O
=	O
xstrdup	(*(char))->(*(char))
(	O
env	O
->	O
argv	*(*(char))
[	O
i	O
]	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
strv	*(*(char))
[	O
i	O
]	O
=	O
NULL	O
;	O
}	O
env	O
->	O
node	O
=	O
node	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_group	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
char	O
*	O
val	array(int)
;	O
struct	O
test_node	O
*	O
node	O
;	O
size_t	long
i	O
;	O
node	O
=	O
new_test_node	O
(	O
test_group	int
)	O
;	O
val	array(int)
=	O
_parse_negation	O
(	O
&	O
node	O
,	O
env	O
->	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
groups	*(*(char))
=	O
xcalloc	(long,long)->(*(void))
(	O
env	O
->	O
argc	int
+	O
1	int
,	O
sizeof	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
groups	*(*(char))
[	O
0	int
]	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
groups	*(*(char))
[	O
0	int
]	O
=	O
xstrdup	(*(char))->(*(char))
(	O
val	array(int)
)	O
;	O
for	O
(	O
i	O
=	O
1	int
;	O
i	O
<	O
env	O
->	O
argc	int
;	O
i	O
++	O
)	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
groups	*(*(char))
[	O
i	O
]	O
=	O
xstrdup	(*(char))->(*(char))
(	O
env	O
->	O
argv	*(*(char))
[	O
i	O
]	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
groups	*(*(char))
[	O
i	O
]	O
=	O
NULL	O
;	O
env	O
->	O
node	O
=	O
node	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_umask	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
return	O
attrib_umask	O
(	O
rule	*(char)
,	O
env	O
->	O
val	array(int)
,	O
&	O
ibuf	O
->	O
loc	O
)	O
;	O
}	O
static	O
int	O
_parse_chroot	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
return	O
attrib_chroot	O
(	O
rule	*(char)
,	O
env	O
->	O
val	array(int)
,	O
&	O
ibuf	O
->	O
loc	O
)	O
;	O
}	O
static	O
int	O
_parse_limits	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
char	O
*	O
q	O
;	O
if	O
(	O
parse_limits	O
(	O
&	O
rule	*(char)
->	O
limits	O
,	O
env	O
->	O
val	array(int)
,	O
&	O
q	O
)	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
_	O
(	O
"unknown limit: %s"	*(char)
)	O
,	O
q	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
_parse_transform_common	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
;	O
char	O
*	O
expr	*(char)
;	O
if	O
(	O
check_argc	O
(	O
ibuf	O
,	O
env	O
,	O
1	int
,	O
3	int
)	O
)	O
return	O
NULL	O
;	O
else	O
if	O
(	O
env	O
->	O
argc	int
==	O
3	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
env	O
->	O
argv	*(*(char))
[	O
1	int
]	O
,	O
"~"	*(char)
)	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
_	O
(	O
"expected ~ as the second argument, but found %s"	*(char)
)	O
,	O
env	O
->	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
return	O
NULL	O
;	O
}	O
node	O
=	O
new_transform_node	O
(	O
rule	*(char)
,	O
transform_set	int
)	O
;	O
switch	O
(	O
env	O
->	O
argc	int
)	O
{	O
case	O
1	int
:	O
expr	*(char)
=	O
env	O
->	O
argv	*(*(char))
[	O
0	int
]	O
;	O
break	O
;	O
case	O
2	int
:	O
expr	*(char)
=	O
env	O
->	O
argv	*(*(char))
[	O
1	int
]	O
;	O
break	O
;	O
case	O
3	int
:	O
expr	*(char)
=	O
env	O
->	O
argv	*(*(char))
[	O
2	int
]	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
trans	*(struct)
=	O
compile_transform_expr	O
(	O
expr	*(char)
,	O
re_flags	O
,	O
&	O
ibuf	O
->	O
loc	O
)	O
;	O
if	O
(	O
env	O
->	O
argc	int
>	O
1	int
)	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
pattern	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
env	O
->	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
else	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
pattern	*(char)
=	O
NULL	O
;	O
return	O
node	O
;	O
}	O
static	O
int	O
_parse_transform	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
=	O
_parse_transform_common	O
(	O
ibuf	O
,	O
rule	*(char)
,	O
env	O
)	O
;	O
if	O
(	O
!	O
node	O
)	O
return	O
1	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_command	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_transform_ar	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
=	O
_parse_transform_common	O
(	O
ibuf	O
,	O
rule	*(char)
,	O
env	O
)	O
;	O
if	O
(	O
!	O
node	O
)	O
return	O
1	int
;	O
if	O
(	O
env	O
->	O
progmod	O
)	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_program	int
;	O
else	O
{	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_arg	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
ins	int
=	O
0	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
idx	int
=	O
env	O
->	O
index	(*(char),int)->(*(char))
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_chdir	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
return	O
attrib_chdir	O
(	O
rule	*(char)
,	O
env	O
->	O
val	array(int)
,	O
&	O
ibuf	O
->	O
loc	O
)	O
;	O
}	O
static	O
int	O
_parse_env	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
size_t	long
i	O
=	O
0	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
env	O
->	O
argv	*(*(char))
[	O
0	int
]	O
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
{	O
rule	*(char)
->	O
clrenv	O
=	O
1	int
;	O
i	O
++	O
;	O
}	O
for	O
(	O
;	O
i	O
<	O
env	O
->	O
argc	int
;	O
i	O
++	O
)	O
{	O
char	O
*	O
name	*(char)
=	O
env	O
->	O
argv	*(*(char))
[	O
i	O
]	O
;	O
size_t	long
len	long
=	O
strcspn	(*(char),*(char))->(long)
(	O
name	*(char)
,	O
"="	*(char)
)	O
;	O
char	O
*	O
value	O
;	O
size_t	long
vlen	O
;	O
char	O
*	O
mem	O
=	O
NULL	O
;	O
size_t	long
msize	O
=	O
0	int
;	O
enum	O
envar_type	O
type	enum(int,int,int,int)
;	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
name	*(char)
++	O
;	O
len	long
--	O
;	O
if	O
(	O
name	*(char)
[	O
len	long
]	O
)	O
{	O
value	O
=	O
name	*(char)
+	O
len	long
+	O
1	int
;	O
vlen	O
=	O
strlen	(*(char))->(long)
(	O
value	O
)	O
;	O
}	O
else	O
{	O
value	O
=	O
NULL	O
;	O
vlen	O
=	O
0	int
;	O
}	O
type	enum(int,int,int,int)
=	O
envar_unset	O
;	O
}	O
else	O
if	O
(	O
name	*(char)
[	O
len	long
]	O
)	O
{	O
if	O
(	O
len	long
==	O
0	int
)	O
continue	O
;	O
value	O
=	O
name	*(char)
+	O
len	long
+	O
1	int
;	O
vlen	O
=	O
strlen	(*(char))->(long)
(	O
value	O
)	O
;	O
name	*(char)
[	O
len	long
]	O
=	O
0	int
;	O
if	O
(	O
name	*(char)
[	O
len	long
-	O
1	int
]	O
==	O
'+'	O
)	O
{	O
name	*(char)
[	O
--	O
len	long
]	O
=	O
0	int
;	O
if	O
(	O
c_ispunct	(int)->(bool)
(	O
value	O
[	O
0	int
]	O
)	O
)	O
{	O
msize	O
=	O
2	int
*	O
len	long
+	O
9	int
+	O
vlen	O
+	O
1	int
;	O
mem	O
=	O
xmalloc	(long)->(*(void))
(	O
msize	O
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
mem	O
,	O
msize	O
,	O
"${%s:-}${%s+%c}%s"	*(char)
,	O
name	*(char)
,	O
name	*(char)
,	O
value	O
[	O
0	int
]	O
,	O
value	O
+	O
1	int
)	O
;	O
}	O
else	O
{	O
msize	O
=	O
len	long
+	O
vlen	O
+	O
6	int
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
mem	O
,	O
msize	O
,	O
"${%s:-}%s"	*(char)
,	O
name	*(char)
,	O
value	O
)	O
;	O
}	O
value	O
=	O
mem	O
;	O
vlen	O
=	O
strlen	(*(char))->(long)
(	O
value	O
)	O
;	O
}	O
else	O
if	O
(	O
value	O
[	O
0	int
]	O
==	O
'+'	O
)	O
{	O
value	O
++	O
;	O
vlen	O
--	O
;	O
if	O
(	O
vlen	O
>	O
0	int
&&	O
c_ispunct	(int)->(bool)
(	O
value	O
[	O
vlen	O
-	O
1	int
]	O
)	O
)	O
{	O
int	O
c	int
=	O
value	O
[	O
vlen	O
-	O
1	int
]	O
;	O
value	O
[	O
--	O
vlen	O
]	O
=	O
0	int
;	O
msize	O
=	O
2	int
*	O
len	long
+	O
10	int
+	O
vlen	O
+	O
1	int
;	O
mem	O
=	O
xmalloc	(long)->(*(void))
(	O
msize	O
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
mem	O
,	O
msize	O
,	O
"%s${%s+%c}${%s:-}"	*(char)
,	O
value	O
,	O
name	*(char)
,	O
c	int
,	O
name	*(char)
)	O
;	O
}	O
else	O
{	O
msize	O
=	O
len	long
+	O
vlen	O
+	O
6	int
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
mem	O
,	O
msize	O
,	O
"%s${%s:-}"	*(char)
,	O
value	O
,	O
name	*(char)
)	O
;	O
}	O
value	O
=	O
mem	O
;	O
vlen	O
=	O
strlen	(*(char))->(long)
(	O
value	O
)	O
;	O
}	O
type	enum(int,int,int,int)
=	O
envar_set	O
;	O
}	O
else	O
{	O
value	O
=	O
NULL	O
;	O
vlen	O
=	O
0	int
;	O
type	enum(int,int,int,int)
=	O
envar_keep	O
;	O
}	O
new_envar	O
(	O
rule	*(char)
,	O
name	*(char)
,	O
len	long
,	O
value	O
,	O
vlen	O
,	O
type	enum(int,int,int,int)
)	O
;	O
free	(*(void))->(void)
(	O
mem	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_debug	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
if	O
(	O
!	O
debug_option	O
)	O
{	O
debug_level	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
env	O
->	O
val	array(int)
,	O
NULL	O
,	O
0	int
)	O
;	O
debug	O
(	O
0	int
,	O
_	O
(	O
"debug level set to %d"	*(char)
)	O
,	O
debug_level	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_sleep_time	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
char	O
*	O
q	O
;	O
sleep_time	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
env	O
->	O
val	array(int)
,	O
&	O
q	O
,	O
10	int
)	O
;	O
if	O
(	O
*	O
q	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
_	O
(	O
"invalid time: %s"	*(char)
)	O
,	O
env	O
->	O
val	array(int)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_usage_error	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
set_error_msg	O
(	O
usage_error	int
,	O
copy_string	O
(	O
env	O
->	O
val	array(int)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_nologin_error	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
set_error_msg	O
(	O
nologin_error	int
,	O
copy_string	O
(	O
env	O
->	O
val	array(int)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_config_error	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
set_error_msg	O
(	O
config_error	int
,	O
copy_string	O
(	O
env	O
->	O
val	array(int)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_system_error	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
set_error_msg	O
(	O
system_error	int
,	O
copy_string	O
(	O
env	O
->	O
val	array(int)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_fall_through	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
RUSH_ARG_UNUSED	O
)	O
{	O
rule	*(char)
->	O
fall_through	O
=	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_exit	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
const	O
char	O
*	O
val	array(int)
=	O
env	O
->	O
val	array(int)
;	O
int	O
error_fd	O
;	O
if	O
(	O
c_isdigit	(int)->(bool)
(	O
val	array(int)
[	O
0	int
]	O
)	O
)	O
{	O
char	O
*	O
p	*(void)
;	O
unsigned	O
long	O
n	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
val	array(int)
,	O
&	O
p	*(void)
,	O
10	int
)	O
;	O
if	O
(	O
!	O
ISWS	O
(	O
p	*(void)
[	O
0	int
]	O
)	O
||	O
n	long
>	O
getmaxfd	O
(	O
)	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"invalid file descriptor"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
val	array(int)
=	O
skipws	O
(	O
p	*(void)
)	O
;	O
error_fd	O
=	O
n	long
;	O
}	O
else	O
error_fd	O
=	O
2	int
;	O
if	O
(	O
val	array(int)
[	O
0	int
]	O
==	O
'@'	O
)	O
{	O
if	O
(	O
val	array(int)
[	O
1	int
]	O
==	O
'@'	O
)	O
rule	*(char)
->	O
error	O
=	O
new_error	O
(	O
error_fd	O
,	O
val	array(int)
+	O
1	int
,	O
1	int
)	O
;	O
else	O
{	O
int	O
n	long
=	O
string_to_error_index	O
(	O
val	array(int)
+	O
1	int
)	O
;	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"Unknown message reference"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
rule	*(char)
->	O
error	O
=	O
new_standard_error	O
(	O
error_fd	O
,	O
n	long
)	O
;	O
}	O
}	O
else	O
rule	*(char)
->	O
error	O
=	O
new_error	O
(	O
error_fd	O
,	O
val	array(int)
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_fork	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
return	O
attrib_fork	O
(	O
rule	*(char)
,	O
env	O
->	O
val	array(int)
,	O
&	O
ibuf	O
->	O
loc	O
)	O
;	O
}	O
static	O
int	O
_parse_acct	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
return	O
attrib_acct	O
(	O
rule	*(char)
,	O
env	O
->	O
val	array(int)
,	O
&	O
ibuf	O
->	O
loc	O
)	O
;	O
}	O
static	O
int	O
_parse_acct_file_mode	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
return	O
parse_file_mode	O
(	O
env	O
->	O
val	array(int)
,	O
&	O
rushdb_file_mode	int
,	O
&	O
ibuf	O
->	O
loc	O
)	O
;	O
}	O
static	O
int	O
_parse_acct_dir_mode	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
return	O
parse_file_mode	O
(	O
env	O
->	O
val	array(int)
,	O
&	O
rushdb_dir_mode	int
,	O
&	O
ibuf	O
->	O
loc	O
)	O
;	O
}	O
static	O
int	O
_parse_acct_umask	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
return	O
parse_file_mode	O
(	O
env	O
->	O
val	array(int)
,	O
&	O
rushdb_umask	int
,	O
&	O
ibuf	O
->	O
loc	O
)	O
;	O
}	O
static	O
int	O
_parse_post_socket	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
return	O
attrib_post_socket	O
(	O
rule	*(char)
,	O
env	O
->	O
val	array(int)
,	O
&	O
ibuf	O
->	O
loc	O
)	O
;	O
}	O
static	O
int	O
_parse_text_domain	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
rule	*(char)
->	O
i18n	O
.	O
text_domain	O
=	O
xstrdup	(*(char))->(*(char))
(	O
env	O
->	O
val	array(int)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_locale_dir	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
rule	*(char)
->	O
i18n	O
.	O
localedir	O
=	O
xstrdup	(*(char))->(*(char))
(	O
env	O
->	O
val	array(int)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_locale	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
const	O
char	O
*	O
val	array(int)
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
env	O
->	O
val	array(int)
,	O
"\"\""	*(char)
)	O
==	O
0	int
)	O
val	array(int)
=	O
""	*(char)
;	O
else	O
val	array(int)
=	O
env	O
->	O
val	array(int)
;	O
rule	*(char)
->	O
i18n	O
.	O
locale	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
val	array(int)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_include	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	O
;	O
CFSTREAM	O
*	O
cf	O
;	O
name	*(char)
=	O
expand_tilde	O
(	O
env	O
->	O
val	array(int)
,	O
rush_pw	O
->	O
pw_dir	*(char)
)	O
;	O
if	O
(	O
trimslash	O
(	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"invalid include file name"	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
name	*(char)
,	O
&	O
st	O
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	O
)	O
{	O
debug	O
(	O
1	int
,	O
_	O
(	O
"Ignoring non-existing include file %s"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
env	O
->	O
ret_buf	O
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
_	O
(	O
"cannot stat file %s: %s"	*(char)
)	O
,	O
name	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
st	O
.	O
st_mode	int
)	O
)	O
{	O
char	O
*	O
file	*(char)
=	O
make_file_name	O
(	O
name	*(char)
,	O
rush_pw	O
->	O
pw_name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
file	*(char)
,	O
F_OK	O
)	O
)	O
{	O
return	O
0	int
;	O
}	O
name	*(char)
=	O
file	*(char)
;	O
}	O
cf	O
=	O
cfstream_open_file	O
(	O
name	*(char)
)	O
;	O
init_input_buf	O
(	O
&	O
env	O
->	O
ret_buf	O
,	O
ibuf	O
,	O
cf	O
,	O
name	*(char)
,	O
1	int
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_include_security	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
int	O
i	O
;	O
int	O
rc	O
=	O
0	int
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
env	O
->	O
argc	int
;	O
i	O
++	O
)	O
{	O
if	O
(	O
cfck_keyword	O
(	O
env	O
->	O
argv	*(*(char))
[	O
i	O
]	O
)	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
_	O
(	O
"unknown keyword: %s"	*(char)
)	O
,	O
env	O
->	O
argv	*(*(char))
[	O
i	O
]	O
)	O
;	O
rc	O
++	O
;	O
}	O
}	O
return	O
rc	O
;	O
}	O
static	O
int	O
_parse_interactive	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
rule	*(char)
->	O
interactive	O
=	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_map_ar	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
;	O
unsigned	O
long	O
n	long
;	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
check_argc	O
(	O
ibuf	O
,	O
env	O
,	O
5	int
,	O
6	int
)	O
)	O
return	O
1	int
;	O
node	O
=	O
new_transform_node	O
(	O
rule	*(char)
,	O
transform_map	int
)	O
;	O
if	O
(	O
env	O
->	O
progmod	O
)	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_program	int
;	O
else	O
{	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_arg	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
ins	int
=	O
0	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
idx	int
=	O
env	O
->	O
index	(*(char),int)->(*(char))
;	O
}	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
file	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
env	O
->	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
delim	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
env	O
->	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
key	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
env	O
->	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
n	long
=	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
key_field	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
env	O
->	O
argv	*(*(char))
[	O
3	int
]	O
,	O
&	O
p	*(void)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(void)
||	O
n	long
!=	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
key_field	int
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"key field is not a number"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
n	long
=	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
val_field	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
env	O
->	O
argv	*(*(char))
[	O
4	int
]	O
,	O
&	O
p	*(void)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(void)
||	O
n	long
!=	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
val_field	int
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"value field is not a number"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
env	O
->	O
argc	int
==	O
6	int
)	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
defval	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
env	O
->	O
argv	*(*(char))
[	O
5	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_delete_ar	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
=	O
new_transform_node	O
(	O
rule	*(char)
,	O
transform_delete	int
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_arg	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
ins	int
=	O
0	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
idx	int
=	O
env	O
->	O
index	(*(char),int)->(*(char))
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
arg_end	int
=	O
env	O
->	O
index	(*(char),int)->(*(char))
;	O
return	O
0	int
;	O
}	O
static	O
int	O
get_arg_index	O
(	O
char	O
*	O
str	*(char)
,	O
char	O
*	O
*	O
end	*(long)
)	O
{	O
if	O
(	O
*	O
str	*(char)
==	O
'$'	O
)	O
{	O
*	O
end	*(long)
=	O
str	*(char)
+	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
return	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
str	*(char)
,	O
end	*(long)
,	O
10	int
)	O
;	O
}	O
static	O
int	O
_parse_delete	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
;	O
int	O
from	O
,	O
to	O
;	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
check_argc	O
(	O
ibuf	O
,	O
env	O
,	O
2	int
,	O
2	int
)	O
)	O
return	O
1	int
;	O
from	O
=	O
get_arg_index	O
(	O
env	O
->	O
argv	*(*(char))
[	O
0	int
]	O
,	O
&	O
p	*(void)
)	O
;	O
if	O
(	O
*	O
p	*(void)
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
_	O
(	O
"%s: not a number"	*(char)
)	O
,	O
env	O
->	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
to	O
=	O
get_arg_index	O
(	O
env	O
->	O
argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
p	*(void)
)	O
;	O
if	O
(	O
*	O
p	*(void)
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
_	O
(	O
"%s: not a number"	*(char)
)	O
,	O
env	O
->	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
node	O
=	O
new_transform_node	O
(	O
rule	*(char)
,	O
transform_delete	int
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_arg	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
ins	int
=	O
0	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
idx	int
=	O
from	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
arg_end	int
=	O
to	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_set	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
=	O
new_transform_node	O
(	O
rule	*(char)
,	O
transform_set	int
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_command	int
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
pattern	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
env	O
->	O
val	array(int)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
trans	*(struct)
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_set_ar	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
=	O
new_transform_node	O
(	O
rule	*(char)
,	O
transform_set	int
)	O
;	O
if	O
(	O
env	O
->	O
progmod	O
)	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_program	int
;	O
else	O
{	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_arg	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
ins	int
=	O
0	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
idx	int
=	O
env	O
->	O
index	(*(char),int)->(*(char))
;	O
}	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
pattern	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
env	O
->	O
val	array(int)
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
trans	*(struct)
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_setvar	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
=	O
new_transform_node	O
(	O
rule	*(char)
,	O
transform_set	int
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_var	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
env	O
->	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
pattern	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
env	O
->	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
trans	*(struct)
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_unsetvar	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
=	O
new_transform_node	O
(	O
rule	*(char)
,	O
transform_delete	int
)	O
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
=	O
target_var	int
;	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
env	O
->	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_newgroup	O
(	O
input_buf_ptr	O
ibuf	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
stmt_env	O
*	O
env	O
)	O
{	O
if	O
(	O
parsegid	O
(	O
env	O
->	O
val	array(int)
,	O
&	O
rule	*(char)
->	O
gid	int
)	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
_	O
(	O
"no such group: %s"	*(char)
)	O
,	O
env	O
->	O
val	array(int)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
token	O
{	O
char	O
*	O
name	*(char)
;	O
size_t	long
namelen	O
;	O
int	O
flags	int
;	O
int	O
(	O
*	O
parser	O
)	O
(	O
input_buf_ptr	O
,	O
struct	O
rush_rule	O
*	O
,	O
struct	O
stmt_env	O
*	O
)	O
;	O
}	O
;	O
struct	O
token	O
toktab	O
[	O
]	O
=	O
{	O
{	O
KW	O
(	O
"command"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_command	O
}	O
,	O
{	O
KW	O
(	O
"match"	*(char)
)	O
,	O
TOK_DFL	O
|	O
TOK_IND	O
,	O
_parse_match	O
}	O
,	O
{	O
KW	O
(	O
"argc"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_argc	O
}	O
,	O
{	O
KW	O
(	O
"uid"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_uid	O
}	O
,	O
{	O
KW	O
(	O
"gid"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_gid	O
}	O
,	O
{	O
KW	O
(	O
"user"	*(char)
)	O
,	O
TOK_DFLN	O
,	O
_parse_user	O
}	O
,	O
{	O
KW	O
(	O
"group"	*(char)
)	O
,	O
TOK_DFLN	O
,	O
_parse_group	O
}	O
,	O
{	O
KW	O
(	O
"transform"	*(char)
)	O
,	O
TOK_DFL	O
|	O
TOK_SED	O
,	O
_parse_transform	O
}	O
,	O
{	O
KW	O
(	O
"transform"	*(char)
)	O
,	O
TOK_DFL	O
|	O
TOK_IND	O
|	O
TOK_SED	O
|	O
TOK_CRT	O
,	O
_parse_transform_ar	O
}	O
,	O
{	O
KW	O
(	O
"map"	*(char)
)	O
,	O
TOK_RUL	O
|	O
TOK_ARGN	O
|	O
TOK_IND	O
|	O
TOK_CRT	O
,	O
_parse_map_ar	O
}	O
,	O
{	O
KW	O
(	O
"delete"	*(char)
)	O
,	O
TOK_RUL	O
|	O
TOK_IND	O
,	O
_parse_delete_ar	O
}	O
,	O
{	O
KW	O
(	O
"delete"	*(char)
)	O
,	O
TOK_RUL	O
|	O
TOK_ARGN	O
,	O
_parse_delete	O
}	O
,	O
{	O
KW	O
(	O
"set"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_set	O
}	O
,	O
{	O
KW	O
(	O
"set"	*(char)
)	O
,	O
TOK_DFL	O
|	O
TOK_IND	O
|	O
TOK_CRT	O
,	O
_parse_set_ar	O
}	O
,	O
{	O
KW	O
(	O
"setvar"	*(char)
)	O
,	O
TOK_RUL	O
|	O
TOK_ARG	O
|	O
TOK_ASSC	O
,	O
_parse_setvar	O
}	O
,	O
{	O
KW	O
(	O
"unsetvar"	*(char)
)	O
,	O
TOK_RUL	O
|	O
TOK_ASSC	O
,	O
_parse_unsetvar	O
}	O
,	O
{	O
KW	O
(	O
"umask"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_umask	O
}	O
,	O
{	O
KW	O
(	O
"chroot"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_chroot	O
}	O
,	O
{	O
KW	O
(	O
"limits"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_limits	O
}	O
,	O
{	O
KW	O
(	O
"chdir"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_chdir	O
}	O
,	O
{	O
KW	O
(	O
"env"	*(char)
)	O
,	O
TOK_DFLN	O
|	O
TOK_ENV	O
,	O
_parse_env	O
}	O
,	O
{	O
KW	O
(	O
"fork"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_fork	O
}	O
,	O
{	O
KW	O
(	O
"acct"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_acct	O
}	O
,	O
{	O
KW	O
(	O
"post-socket"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_post_socket	O
}	O
,	O
{	O
KW	O
(	O
"text-domain"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_text_domain	O
}	O
,	O
{	O
KW	O
(	O
"locale-dir"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_locale_dir	O
}	O
,	O
{	O
KW	O
(	O
"locale"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_locale	O
}	O
,	O
{	O
KW	O
(	O
"include"	*(char)
)	O
,	O
TOK_ARG	O
|	O
TOK_NEWBUF	O
,	O
_parse_include	O
}	O
,	O
{	O
KW	O
(	O
"fall-through"	*(char)
)	O
,	O
TOK_RUL	O
,	O
_parse_fall_through	O
}	O
,	O
{	O
KW	O
(	O
"exit"	*(char)
)	O
,	O
TOK_RUL	O
,	O
_parse_exit	O
}	O
,	O
{	O
KW	O
(	O
"debug"	*(char)
)	O
,	O
TOK_ARG	O
,	O
_parse_debug	O
}	O
,	O
{	O
KW	O
(	O
"sleep-time"	*(char)
)	O
,	O
TOK_ARG	O
,	O
_parse_sleep_time	O
}	O
,	O
{	O
KW	O
(	O
"usage-error"	*(char)
)	O
,	O
TOK_ARG	O
,	O
_parse_usage_error	O
}	O
,	O
{	O
KW	O
(	O
"nologin-error"	*(char)
)	O
,	O
TOK_ARG	O
,	O
_parse_nologin_error	O
}	O
,	O
{	O
KW	O
(	O
"config-error"	*(char)
)	O
,	O
TOK_ARG	O
,	O
_parse_config_error	O
}	O
,	O
{	O
KW	O
(	O
"system-error"	*(char)
)	O
,	O
TOK_ARG	O
,	O
_parse_system_error	O
}	O
,	O
{	O
KW	O
(	O
"regexp"	*(char)
)	O
,	O
TOK_ARGN	O
,	O
_parse_re_flags	O
}	O
,	O
{	O
KW	O
(	O
"include-security"	*(char)
)	O
,	O
TOK_ARGN	O
,	O
_parse_include_security	O
}	O
,	O
{	O
KW	O
(	O
"interactive"	*(char)
)	O
,	O
TOK_RUL	O
,	O
_parse_interactive	O
}	O
,	O
{	O
KW	O
(	O
"acct-file-mode"	*(char)
)	O
,	O
TOK_ARG	O
,	O
_parse_acct_file_mode	O
}	O
,	O
{	O
KW	O
(	O
"acct-dir-mode"	*(char)
)	O
,	O
TOK_ARG	O
,	O
_parse_acct_dir_mode	O
}	O
,	O
{	O
KW	O
(	O
"acct-umask"	*(char)
)	O
,	O
TOK_ARG	O
,	O
_parse_acct_umask	O
}	O
,	O
{	O
KW	O
(	O
"newgroup"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_newgroup	O
}	O
,	O
{	O
KW	O
(	O
"newgrp"	*(char)
)	O
,	O
TOK_DFL	O
,	O
_parse_newgroup	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
token	O
*	O
find_token	O
(	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
*	O
plen	O
)	O
{	O
struct	O
token	O
*	O
tok	O
;	O
int	O
len	long
=	O
strcspn	(*(char),*(char))->(long)
(	O
name	*(char)
,	O
"["	*(char)
)	O
;	O
for	O
(	O
tok	O
=	O
toktab	O
;	O
tok	O
->	O
name	*(char)
;	O
tok	O
++	O
)	O
{	O
if	O
(	O
len	long
==	O
tok	O
->	O
namelen	O
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
tok	O
->	O
name	*(char)
,	O
name	*(char)
,	O
len	long
)	O
==	O
0	int
&&	O
(	O
name	*(char)
[	O
len	long
]	O
==	O
0	int
?	O
(	O
tok	O
->	O
flags	int
&	O
TOK_IND	O
)	O
==	O
0	int
:	O
(	O
tok	O
->	O
flags	int
&	O
TOK_IND	O
)	O
)	O
)	O
{	O
*	O
plen	O
=	O
len	long
;	O
return	O
tok	O
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
int	O
parse_input_buf	O
(	O
input_buf_ptr	O
ibuf	O
)	O
{	O
char	O
*	O
buf	O
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
;	O
int	O
err	long
=	O
0	int
;	O
struct	O
rush_rule	O
*	O
rule	*(char)
=	O
NULL	O
;	O
debug	O
(	O
3	int
,	O
_	O
(	O
"Parsing %s"	*(char)
)	O
,	O
ibuf	O
->	O
loc	O
.	O
beg	O
.	O
filename	O
)	O
;	O
while	O
(	O
read_line	O
(	O
&	O
ibuf	O
,	O
&	O
buf	O
,	O
&	O
size	long
)	O
)	O
{	O
char	O
*	O
kw	O
,	O
*	O
val	array(int)
;	O
char	O
*	O
p	*(void)
;	O
struct	O
token	O
*	O
tok	O
;	O
int	O
len	long
;	O
int	O
rc	O
;	O
struct	O
stmt_env	O
env	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
env	O
,	O
0	int
,	O
sizeof	O
env	O
)	O
;	O
p	*(void)
=	O
skipws	O
(	O
buf	O
)	O
;	O
debug	O
(	O
3	int
,	O
"%s:%d: %s"	*(char)
,	O
ibuf	O
->	O
loc	O
.	O
beg	O
.	O
filename	O
,	O
ibuf	O
->	O
loc	O
.	O
beg	O
.	O
line	O
,	O
p	*(void)
)	O
;	O
if	O
(	O
p	*(void)
[	O
0	int
]	O
==	O
0	int
||	O
p	*(void)
[	O
0	int
]	O
==	O
'#'	O
)	O
continue	O
;	O
kw	O
=	O
p	*(void)
;	O
p	*(void)
=	O
eow	O
(	O
kw	O
)	O
;	O
if	O
(	O
p	*(void)
[	O
0	int
]	O
)	O
{	O
*	O
p	*(void)
++	O
=	O
0	int
;	O
val	array(int)
=	O
skipws	O
(	O
p	*(void)
)	O
;	O
trimws	O
(	O
val	array(int)
)	O
;	O
}	O
else	O
val	array(int)
=	O
NULL	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
kw	O
,	O
"rule"	*(char)
)	O
==	O
0	int
)	O
{	O
rule	*(char)
=	O
new_rush_rule	O
(	O
val	array(int)
)	O
;	O
rule	*(char)
->	O
file	*(char)
=	O
ibuf	O
->	O
loc	O
.	O
beg	O
.	O
filename	O
;	O
rule	*(char)
->	O
line	O
=	O
ibuf	O
->	O
loc	O
.	O
beg	O
.	O
line	O
;	O
continue	O
;	O
}	O
tok	O
=	O
find_token	O
(	O
kw	O
,	O
&	O
len	long
)	O
;	O
if	O
(	O
!	O
tok	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
_	O
(	O
"unknown statement: %s"	*(char)
)	O
,	O
kw	O
)	O
;	O
err	long
=	O
1	int
;	O
continue	O
;	O
}	O
env	O
.	O
kw	O
=	O
kw	O
;	O
env	O
.	O
val	array(int)
=	O
val	array(int)
;	O
kw	O
+=	O
len	long
;	O
if	O
(	O
tok	O
->	O
flags	int
&	O
TOK_IND	O
)	O
{	O
char	O
*	O
q	O
;	O
if	O
(	O
(	O
tok	O
->	O
flags	int
&	O
TOK_ASSC	O
)	O
==	O
TOK_ASSC	O
)	O
{	O
q	O
=	O
strchr	(*(char),int)->(*(char))
(	O
kw	O
+	O
1	int
,	O
']'	O
)	O
;	O
if	O
(	O
q	O
)	O
{	O
size_t	long
len	long
=	O
q	O
-	O
kw	O
-	O
1	int
;	O
env	O
.	O
argc	int
=	O
2	int
;	O
env	O
.	O
argv	*(*(char))
=	O
xcalloc	(long,long)->(*(void))
(	O
env	O
.	O
argc	int
+	O
1	int
,	O
sizeof	O
(	O
env	O
.	O
argv	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
env	O
.	O
argv	*(*(char))
[	O
0	int
]	O
=	O
xmalloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
env	O
.	O
argv	*(*(char))
[	O
0	int
]	O
,	O
kw	O
+	O
1	int
,	O
len	long
)	O
;	O
env	O
.	O
argv	*(*(char))
[	O
0	int
]	O
[	O
len	long
]	O
=	O
0	int
;	O
env	O
.	O
argv	*(*(char))
[	O
1	int
]	O
=	O
env	O
.	O
val	array(int)
?	O
xstrdup	(*(char))->(*(char))
(	O
env	O
.	O
val	array(int)
)	O
:	O
NULL	O
;	O
}	O
}	O
else	O
if	O
(	O
kw	O
[	O
1	int
]	O
==	O
'$'	O
)	O
{	O
env	O
.	O
index	(*(char),int)->(*(char))
=	O
-	O
1	int
;	O
q	O
=	O
kw	O
+	O
2	int
;	O
}	O
else	O
if	O
(	O
tok	O
->	O
flags	int
&	O
TOK_CRT	O
&&	O
kw	O
[	O
1	int
]	O
==	O
'^'	O
)	O
{	O
env	O
.	O
progmod	O
=	O
1	int
;	O
q	O
=	O
kw	O
+	O
2	int
;	O
}	O
else	O
env	O
.	O
index	(*(char),int)->(*(char))
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
kw	O
+	O
1	int
,	O
&	O
q	O
,	O
10	int
)	O
;	O
if	O
(	O
*	O
q	O
!=	O
']'	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"missing ]"	*(char)
)	O
)	O
;	O
err	long
=	O
1	int
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
tok	O
->	O
flags	int
&	O
(	O
TOK_ARG	O
|	O
TOK_ARGN	O
)	O
&&	O
!	O
(	O
val	array(int)
&&	O
*	O
val	array(int)
)	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"invalid statement: missing value"	*(char)
)	O
)	O
;	O
err	long
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
tok	O
->	O
flags	int
&	O
TOK_ARGN	O
)	O
{	O
int	O
flags	int
=	O
WRDSF_DEFFLAGS	O
|	O
WRDSF_COMMENT	O
;	O
struct	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
if	O
(	O
tok	O
->	O
flags	int
&	O
TOK_SED	O
)	O
flags	int
|=	O
WRDSF_SED_EXPR	O
;	O
if	O
(	O
tok	O
->	O
flags	int
&	O
TOK_ENV	O
)	O
{	O
flags	int
&=	O
~	O
WRDSF_NOVAR	O
;	O
flags	int
|=	O
WRDSF_ENV	O
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_env	*(*(char))
=	O
(	O
const	O
char	O
*	O
*	O
)	O
environ	*(*(char))
;	O
}	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_comment	*(char)
=	O
"#"	*(char)
;	O
if	O
(	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
val	array(int)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
flags	int
)	O
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
_	O
(	O
"failed to parse value: %s"	*(char)
)	O
,	O
wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
;	O
err	long
=	O
1	int
;	O
continue	O
;	O
}	O
env	O
.	O
argc	int
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
;	O
env	O
.	O
argv	*(*(char))
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
=	O
0	int
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
=	O
NULL	O
;	O
wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
}	O
if	O
(	O
tok	O
->	O
flags	int
&	O
TOK_RUL	O
)	O
{	O
if	O
(	O
!	O
rule	*(char)
)	O
{	O
cferror	O
(	O
&	O
ibuf	O
->	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"statement cannot be used outside a rule"	*(char)
)	O
)	O
;	O
err	long
=	O
1	int
;	O
continue	O
;	O
}	O
}	O
rc	O
=	O
tok	O
->	O
parser	O
(	O
ibuf	O
,	O
rule	*(char)
,	O
&	O
env	O
)	O
;	O
err	long
|=	O
rc	O
;	O
if	O
(	O
rc	O
==	O
0	int
)	O
{	O
if	O
(	O
tok	O
->	O
flags	int
&	O
TOK_NEWBUF	O
&&	O
env	O
.	O
ret_buf	O
)	O
{	O
env	O
.	O
ret_buf	O
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
=	O
ibuf	O
;	O
ibuf	O
=	O
env	O
.	O
ret_buf	O
;	O
debug	O
(	O
3	int
,	O
_	O
(	O
"Parsing %s"	*(char)
)	O
,	O
ibuf	O
->	O
loc	O
.	O
beg	O
.	O
filename	O
)	O
;	O
}	O
if	O
(	O
env	O
.	O
node	O
)	O
{	O
if	O
(	O
rule	*(char)
->	O
test_node	O
)	O
{	O
struct	O
test_node	O
*	O
np	O
=	O
new_test_node	O
(	O
test_and	int
)	O
;	O
np	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
0	int
]	O
=	O
rule	*(char)
->	O
test_node	O
;	O
np	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
1	int
]	O
=	O
env	O
.	O
node	O
;	O
rule	*(char)
->	O
test_node	O
=	O
np	O
;	O
}	O
else	O
rule	*(char)
->	O
test_node	O
=	O
env	O
.	O
node	O
;	O
}	O
}	O
if	O
(	O
tok	O
->	O
flags	int
&	O
(	O
TOK_ARGN	O
|	O
TOK_ASSC	O
)	O
)	O
argcv_free	(int,*(*(char)))->(void)
(	O
env	O
.	O
argc	int
,	O
env	O
.	O
argv	*(*(char))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
buf	O
)	O
;	O
return	O
err	long
;	O
}	O
int	O
cfparse_old	O
(	O
CFSTREAM	O
*	O
cf	O
,	O
char	O
const	O
*	O
filename	O
,	O
int	O
line	O
)	O
{	O
input_buf_ptr	O
buf	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
filename	O
,	O
"<built-in>"	*(char)
)	O
==	O
0	int
)	O
{	O
logmsg	O
(	O
LOG_NOTICE	O
,	O
_	O
(	O
"parsing legacy built-in configuration"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
logmsg	O
(	O
LOG_NOTICE	O
,	O
_	O
(	O
"parsing legacy configuration file %s"	*(char)
)	O
,	O
filename	O
)	O
;	O
}	O
init_input_buf	O
(	O
&	O
buf	O
,	O
NULL	O
,	O
cf	O
,	O
filename	O
,	O
line	O
-	O
1	int
)	O
;	O
return	O
parse_input_buf	O
(	O
buf	O
)	O
;	O
}	O
