const	O
typeinfo_t	O
fd_ostream_typeinfo	O
=	O
{	O
"fd_ostream"	*(char)
}	O
;	O
static	O
const	O
typeinfo_t	O
*	O
const	O
fd_ostream_superclasses	array(*(int))
[	O
]	O
=	O
{	O
fd_ostream_SUPERCLASSES	O
}	O
;	O
static	O
inline	O
int	O
nonintr_tcdrain	(int)->(int)
(	O
int	O
fd	int
)	O
{	O
int	O
retval	int
;	O
do	O
retval	int
=	O
tcdrain	()->(int)
(	O
fd	int
)	O
;	O
while	O
(	O
retval	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	O
)	O
;	O
return	O
retval	int
;	O
}	O
static	O
void	O
fd_ostream__write_mem	(int,*(void),int)->(void)
(	O
fd_ostream_t	O
stream	int
,	O
const	O
void	O
*	O
data	*(void)
,	O
size_t	O
len	int
)	O
{	O
if	O
(	O
len	int
>	O
0	int
)	O
{	O
if	O
(	O
stream	int
->	O
buffer	O
!=	O
NULL	O
)	O
{	O
assert	()->(int)
(	O
stream	int
->	O
avail	O
>	O
0	int
)	O
;	O
if	O
(	O
len	int
<	O
stream	int
->	O
avail	O
)	O
{	O
memcpy	O
(	O
stream	int
->	O
buffer	O
+	O
BUFSIZE	int
-	O
stream	int
->	O
avail	O
,	O
data	*(void)
,	O
len	int
)	O
;	O
stream	int
->	O
avail	O
-=	O
len	int
;	O
}	O
else	O
{	O
size_t	O
n	O
=	O
stream	int
->	O
avail	O
;	O
memcpy	O
(	O
stream	int
->	O
buffer	O
+	O
BUFSIZE	int
-	O
stream	int
->	O
avail	O
,	O
data	*(void)
,	O
n	O
)	O
;	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
data	*(void)
+	O
n	O
;	O
len	int
-=	O
n	O
;	O
if	O
(	O
full_write	O
(	O
stream	int
->	O
fd	int
,	O
stream	int
->	O
buffer	O
,	O
BUFSIZE	int
)	O
<	O
BUFSIZE	int
)	O
error	()->(int)
(	O
EXIT_FAILURE	O
,	O
errno	O
,	O
_	O
(	O
"error writing to %s"	*(char)
)	O
,	O
stream	int
->	O
filename	*(char)
)	O
;	O
while	O
(	O
len	int
>=	O
BUFSIZE	int
)	O
{	O
if	O
(	O
full_write	O
(	O
stream	int
->	O
fd	int
,	O
data	*(void)
,	O
BUFSIZE	int
)	O
<	O
BUFSIZE	int
)	O
error	()->(int)
(	O
EXIT_FAILURE	O
,	O
errno	O
,	O
_	O
(	O
"error writing to %s"	*(char)
)	O
,	O
stream	int
->	O
filename	*(char)
)	O
;	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
data	*(void)
+	O
BUFSIZE	int
;	O
len	int
-=	O
BUFSIZE	int
;	O
}	O
if	O
(	O
len	int
>	O
0	int
)	O
memcpy	O
(	O
stream	int
->	O
buffer	O
,	O
data	*(void)
,	O
len	int
)	O
;	O
stream	int
->	O
avail	O
=	O
BUFSIZE	int
-	O
len	int
;	O
}	O
assert	()->(int)
(	O
stream	int
->	O
avail	O
>	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
full_write	O
(	O
stream	int
->	O
fd	int
,	O
data	*(void)
,	O
len	int
)	O
<	O
len	int
)	O
error	()->(int)
(	O
EXIT_FAILURE	O
,	O
errno	O
,	O
_	O
(	O
"error writing to %s"	*(char)
)	O
,	O
stream	int
->	O
filename	*(char)
)	O
;	O
}	O
}	O
}	O
static	O
void	O
fd_ostream__flush	(int,int)->(void)
(	O
fd_ostream_t	O
stream	int
,	O
ostream_flush_scope_t	O
scope	int
)	O
{	O
if	O
(	O
stream	int
->	O
buffer	O
!=	O
NULL	O
&&	O
stream	int
->	O
avail	O
<	O
BUFSIZE	int
)	O
{	O
size_t	O
filled	O
=	O
BUFSIZE	int
-	O
stream	int
->	O
avail	O
;	O
if	O
(	O
full_write	O
(	O
stream	int
->	O
fd	int
,	O
stream	int
->	O
buffer	O
,	O
filled	O
)	O
<	O
filled	O
)	O
error	()->(int)
(	O
EXIT_FAILURE	O
,	O
errno	O
,	O
_	O
(	O
"error writing to %s"	*(char)
)	O
,	O
stream	int
->	O
filename	*(char)
)	O
;	O
stream	int
->	O
avail	O
=	O
BUFSIZE	int
;	O
}	O
if	O
(	O
scope	int
==	O
FLUSH_ALL	O
)	O
{	O
fsync	()->(int)
(	O
stream	int
->	O
fd	int
)	O
;	O
nonintr_tcdrain	(int)->(int)
(	O
stream	int
->	O
fd	int
)	O
;	O
}	O
}	O
static	O
void	O
fd_ostream__free	(int)->(void)
(	O
fd_ostream_t	O
stream	int
)	O
{	O
fd_ostream_flush	()->(int)
(	O
stream	int
,	O
FLUSH_THIS_STREAM	O
)	O
;	O
free	()->(int)
(	O
stream	int
->	O
filename	*(char)
)	O
;	O
free	()->(int)
(	O
stream	int
)	O
;	O
}	O
fd_ostream_t	O
fd_ostream_create	(int,*(char),int)->(int)
(	O
int	O
fd	int
,	O
const	O
char	O
*	O
filename	*(char)
,	O
bool	O
buffered	int
)	O
{	O
fd_ostream_t	O
stream	int
=	O
(	O
struct	O
fd_ostream_representation	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
(	O
struct	O
fd_ostream_representation	O
)	O
+	O
(	O
buffered	int
?	O
BUFSIZE	int
:	O
0	int
)	O
)	O
;	O
stream	int
->	O
base	O
.	O
vtable	*(struct)
=	O
&	O
fd_ostream_vtable	O
;	O
stream	int
->	O
fd	int
=	O
fd	int
;	O
stream	int
->	O
filename	*(char)
=	O
xstrdup	O
(	O
filename	*(char)
)	O
;	O
if	O
(	O
buffered	int
)	O
{	O
stream	int
->	O
buffer	O
=	O
(	O
char	O
*	O
)	O
(	O
void	O
*	O
)	O
stream	int
+	O
sizeof	O
(	O
struct	O
fd_ostream_representation	O
)	O
;	O
stream	int
->	O
avail	O
=	O
BUFSIZE	int
;	O
}	O
else	O
stream	int
->	O
buffer	O
=	O
NULL	O
;	O
return	O
stream	int
;	O
}	O
const	O
struct	O
fd_ostream_implementation	O
fd_ostream_vtable	O
=	O
{	O
fd_ostream_superclasses	array(*(int))
,	O
sizeof	O
(	O
fd_ostream_superclasses	array(*(int))
)	O
/	O
sizeof	O
(	O
fd_ostream_superclasses	array(*(int))
[	O
0	int
]	O
)	O
,	O
sizeof	O
(	O
struct	O
fd_ostream_representation	O
)	O
,	O
fd_ostream__write_mem	(int,*(void),int)->(void)
,	O
fd_ostream__flush	(int,int)->(void)
,	O
fd_ostream__free	(int)->(void)
,	O
}	O
;	O
void	O
fd_ostream_write_mem	(int,*(void),int)->(void)
(	O
fd_ostream_t	O
first_arg	int
,	O
const	O
void	O
*	O
data	*(void)
,	O
size_t	O
len	int
)	O
{	O
const	O
struct	O
fd_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
fd_ostream_representation_header	O
*	O
)	O
(	O
struct	O
fd_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
vtable	*(struct)
->	O
write_mem	O
(	O
first_arg	int
,	O
data	*(void)
,	O
len	int
)	O
;	O
}	O
void	O
fd_ostream_flush	()->(int)
(	O
fd_ostream_t	O
first_arg	int
,	O
ostream_flush_scope_t	O
scope	int
)	O
{	O
const	O
struct	O
fd_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
fd_ostream_representation_header	O
*	O
)	O
(	O
struct	O
fd_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
vtable	*(struct)
->	O
flush	O
(	O
first_arg	int
,	O
scope	int
)	O
;	O
}	O
void	O
fd_ostream_free	(int)->(void)
(	O
fd_ostream_t	O
first_arg	int
)	O
{	O
const	O
struct	O
fd_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
fd_ostream_representation_header	O
*	O
)	O
(	O
struct	O
fd_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
vtable	*(struct)
->	O
free	()->(int)
(	O
first_arg	int
)	O
;	O
}	O
