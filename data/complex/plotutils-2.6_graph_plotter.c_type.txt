typedef	O
unsigned	O
int	O
outcode	int
;	O
enum	O
{	O
TOP	int
=	O
0x1	int
,	O
BOTTOM	int
=	O
0x2	int
,	O
RIGHT	int
=	O
0x4	int
,	O
LEFT	int
=	O
0x8	int
}	O
;	O
enum	O
{	O
ACCEPTED	int
=	O
0x1	int
,	O
CLIPPED_FIRST	int
=	O
0x2	int
,	O
CLIPPED_SECOND	int
=	O
0x4	int
}	O
;	O
typedef	O
struct	O
{	O
double	O
input_min	double
,	O
input_max	double
;	O
double	O
input_range	double
;	O
bool	enum(int,int)
reverse	enum(int,int)
;	O
double	O
squeezed_min	double
,	O
squeezed_max	double
;	O
double	O
squeezed_range	double
;	O
double	O
output_min	double
,	O
output_max	double
;	O
double	O
output_range	double
;	O
}	O
Transform	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
;	O
typedef	O
struct	O
{	O
const	O
char	O
*	O
font_name	*(char)
;	O
double	O
font_size	double
;	O
const	O
char	O
*	O
label	*(char)
;	O
int	O
type	*(char)
;	O
double	O
tick_spacing	double
;	O
int	O
min_tick_count	int
,	O
max_tick_count	int
;	O
bool	enum(int,int)
have_lin_subticks	enum(int,int)
;	O
double	O
lin_subtick_spacing	double
;	O
int	O
min_lin_subtick_count	int
,	O
max_lin_subtick_count	int
;	O
bool	enum(int,int)
have_normal_subsubticks	enum(int,int)
;	O
bool	enum(int,int)
user_specified_subsubticks	enum(int,int)
;	O
double	O
subsubtick_spacing	double
;	O
double	O
other_axis_loc	double
;	O
double	O
alt_other_axis_loc	double
;	O
bool	enum(int,int)
switch_axis_end	int
;	O
bool	enum(int,int)
omit_ticks	enum(int,int)
;	O
double	O
max_label_width	double
;	O
int	O
labelled_ticks	int
;	O
}	O
Axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
;	O
struct	O
MultigrapherStruct	struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)
{	O
plPlotter	struct
*	O
plotter	*(struct)
;	O
const	O
char	O
*	O
output_format	*(char)
;	O
const	O
char	O
*	O
bg_color	*(char)
;	O
bool	enum(int,int)
save_screen	enum(int,int)
;	O
Transform	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
,	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
;	O
Axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
,	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
;	O
grid_type	enum(int,int,int,int,int)
grid_spec	enum(int,int,int,int,int)
;	O
double	O
blankout_fraction	double
;	O
bool	enum(int,int)
no_rotate_y_label	enum(int,int)
;	O
double	O
tick_size	double
;	O
double	O
subtick_size	double
;	O
double	O
frame_line_width	double
;	O
double	O
half_line_width	double
;	O
const	O
char	O
*	O
frame_color	*(char)
;	O
const	O
char	O
*	O
title	*(char)
;	O
const	O
char	O
*	O
title_font_name	*(char)
;	O
double	O
title_font_size	double
;	O
int	O
clip_mode	int
;	O
bool	enum(int,int)
first_point_of_polyline	enum(int,int)
;	O
double	O
oldpoint_x	double
,	O
oldpoint_y	double
;	O
int	O
symbol	int
;	O
int	O
linemode	int
;	O
}	O
;	O
static	O
int	O
clip_line	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),*(double),*(double),*(double),*(double))->(int)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
double	O
*	O
x0_p	*(double)
,	O
double	O
*	O
y0_p	*(double)
,	O
double	O
*	O
x1_p	*(double)
,	O
double	O
*	O
y1_p	*(double)
)	O
;	O
static	O
int	O
spacing_type	(double)->(int)
(	O
double	O
spacing	double
)	O
;	O
static	O
outcode	int
compute_outcode	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),double,double,enum(int,int))->(int)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
double	O
x	int
,	O
double	O
y	int
,	O
bool	enum(int,int)
tolerant	enum(int,int)
)	O
;	O
static	O
void	O
plot_abscissa_log_subsubtick	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),double)->(void)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
double	O
xval	double
)	O
;	O
static	O
void	O
plot_errorbar	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(void)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
const	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
p	*(void)
)	O
;	O
static	O
void	O
plot_ordinate_log_subsubtick	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),double)->(void)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
double	O
xval	double
)	O
;	O
static	O
void	O
prepare_axis	(*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)),*(struct(double,double,double,enum(int,int),double,double,double,double,double,double)),double,double,double,*(char),double,*(char),double,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int))->(void)
(	O
Axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
*	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
,	O
Transform	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
*	O
trans	*(struct(double,double,double,enum(int,int),double,double,double,double,double,double))
,	O
double	O
min	double
,	O
double	O
max	double
,	O
double	O
spacing	double
,	O
const	O
char	O
*	O
font_name	*(char)
,	O
double	O
font_size	double
,	O
const	O
char	O
*	O
label	*(char)
,	O
double	O
subsubtick_spacing	double
,	O
bool	enum(int,int)
user_specified_subsubticks	enum(int,int)
,	O
bool	enum(int,int)
round_to_next_tick	int
,	O
bool	enum(int,int)
log_axis	int
,	O
bool	enum(int,int)
reverse_axis	enum(int,int)
,	O
bool	enum(int,int)
switch_axis_end	int
,	O
bool	enum(int,int)
omit_ticks	enum(int,int)
)	O
;	O
static	O
void	O
print_tick_label	(*(char),*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)),*(struct(double,double,double,enum(int,int),double,double,double,double,double,double)),double)->(void)
(	O
char	O
*	O
labelbuf	*(char)
,	O
const	O
Axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
*	O
axis	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
,	O
const	O
Transform	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
*	O
transform	*(struct(double,double,double,enum(int,int),double,double,double,double,double,double))
,	O
double	O
val	double
)	O
;	O
static	O
void	O
scale1	(double,double,*(double),*(int))->(void)
(	O
double	O
min	double
,	O
double	O
max	double
,	O
double	O
*	O
tick_spacing	double
,	O
int	O
*	O
tick_spacing_type	*(int)
)	O
;	O
static	O
void	O
set_line_style	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),int,enum(int,int))->(void)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
int	O
style	int
,	O
bool	enum(int,int)
use_color	enum(int,int)
)	O
;	O
static	O
void	O
transpose_portmanteau	(*(int))->(void)
(	O
int	O
*	O
val	double
)	O
;	O
static	O
void	O
print_tick_label	(*(char),*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)),*(struct(double,double,double,enum(int,int),double,double,double,double,double,double)),double)->(void)
(	O
char	O
*	O
labelbuf	*(char)
,	O
const	O
Axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
*	O
axis	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
,	O
const	O
Transform	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
*	O
transform	*(struct(double,double,double,enum(int,int),double,double,double,double,double,double))
,	O
double	O
val	double
)	O
{	O
int	O
prec	int
;	O
char	O
*	O
eloc	*(char)
,	O
*	O
ptr	*(char)
;	O
char	O
labelbuf_tmp	array(char)
[	O
64	int
]	O
,	O
incrbuf	array(char)
[	O
64	int
]	O
;	O
double	O
spacing	double
;	O
bool	enum(int,int)
big_exponents	enum(int,int)
;	O
double	O
min	double
,	O
max	double
;	O
min	double
=	O
(	O
axis	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
type	*(char)
==	O
A_LOG10	int
?	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
transform	*(struct(double,double,double,enum(int,int),double,double,double,double,double,double))
->	O
input_min	double
)	O
:	O
transform	*(struct(double,double,double,enum(int,int),double,double,double,double,double,double))
->	O
input_min	double
)	O
;	O
max	double
=	O
(	O
axis	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
type	*(char)
==	O
A_LOG10	int
?	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
transform	*(struct(double,double,double,enum(int,int),double,double,double,double,double,double))
->	O
input_max	double
)	O
:	O
transform	*(struct(double,double,double,enum(int,int),double,double,double,double,double,double))
->	O
input_max	double
)	O
;	O
big_exponents	enum(int,int)
=	O
(	O
(	O
(	O
min	double
!=	O
0.0	int
&&	O
fabs	(double)->(double)
(	O
log10	(double)->(double)
(	O
fabs	(double)->(double)
(	O
min	double
)	O
)	O
)	O
>=	O
4.0	int
)	O
||	O
(	O
max	double
!=	O
0.0	int
&&	O
fabs	(double)->(double)
(	O
log10	(double)->(double)
(	O
fabs	(double)->(double)
(	O
max	double
)	O
)	O
)	O
>=	O
4.0	int
)	O
)	O
?	O
true	int
:	O
false	int
)	O
;	O
if	O
(	O
big_exponents	enum(int,int)
)	O
{	O
char	O
*	O
src	*(char)
=	O
labelbuf_tmp	array(char)
,	O
*	O
dst	*(char)
=	O
labelbuf	*(char)
;	O
int	O
exponent	int
;	O
char	O
floatbuf	array(char)
[	O
64	int
]	O
;	O
char	O
*	O
fptr	*(int)
=	O
floatbuf	array(char)
;	O
double	O
prefactor	double
;	O
sprintf	(*(char),*(char))->(int)
(	O
labelbuf_tmp	array(char)
,	O
"%e"	*(char)
,	O
val	double
)	O
;	O
if	O
(	O
(	O
eloc	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
labelbuf_tmp	array(char)
,	O
(	O
int	O
)	O
'e'	O
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
axis	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
type	*(char)
==	O
A_LOG10	int
&&	O
!	O
axis	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
user_specified_subsubticks	enum(int,int)
)	O
{	O
sscanf	(*(char),*(char))->(int)
(	O
++	O
eloc	*(char)
,	O
"%d"	*(char)
,	O
&	O
exponent	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
dst	*(char)
,	O
"10\\sp%d\\ep"	*(char)
,	O
exponent	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
val	double
==	O
0.0	int
)	O
{	O
*	O
dst	*(char)
++	O
=	O
'0'	O
;	O
*	O
dst	*(char)
=	O
'\0'	O
;	O
return	O
;	O
}	O
while	O
(	O
src	*(char)
<	O
eloc	*(char)
)	O
*	O
fptr	*(int)
++	O
=	O
*	O
src	*(char)
++	O
;	O
*	O
fptr	*(int)
=	O
'\0'	O
;	O
sscanf	(*(char),*(char))->(int)
(	O
floatbuf	array(char)
,	O
"%lf"	*(char)
,	O
&	O
prefactor	double
)	O
;	O
sscanf	(*(char),*(char))->(int)
(	O
++	O
src	*(char)
,	O
"%d"	*(char)
,	O
&	O
exponent	int
)	O
;	O
spacing	double
=	O
(	O
axis	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
type	*(char)
==	O
A_LINEAR	int
?	O
axis	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
tick_spacing	double
:	O
axis	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
subsubtick_spacing	double
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
incrbuf	array(char)
,	O
"%f"	*(char)
,	O
spacing	double
/	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
(	O
double	O
)	O
exponent	int
)	O
)	O
;	O
ptr	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
incrbuf	array(char)
,	O
(	O
int	O
)	O
'.'	O
)	O
;	O
prec	int
=	O
0	int
;	O
if	O
(	O
ptr	*(char)
!=	O
NULL	O
)	O
{	O
int	O
count	int
=	O
0	int
;	O
while	O
(	O
*	O
(	O
++	O
ptr	*(char)
)	O
)	O
{	O
count	int
++	O
;	O
if	O
(	O
*	O
ptr	*(char)
!=	O
'0'	O
)	O
prec	int
=	O
count	int
;	O
}	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
dst	*(char)
,	O
"%.*f\\r6\\mu10\\sp%d\\ep"	*(char)
,	O
prec	int
,	O
prefactor	double
,	O
exponent	int
)	O
;	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
axis	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
type	*(char)
==	O
A_LOG10	int
&&	O
!	O
axis	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
user_specified_subsubticks	enum(int,int)
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
labelbuf	*(char)
,	O
"%.9g"	*(char)
,	O
val	double
)	O
;	O
return	O
;	O
}	O
spacing	double
=	O
(	O
axis	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
type	*(char)
==	O
A_LINEAR	int
?	O
axis	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
tick_spacing	double
:	O
axis	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
subsubtick_spacing	double
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
incrbuf	array(char)
,	O
"%.9f"	*(char)
,	O
spacing	double
)	O
;	O
ptr	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
incrbuf	array(char)
,	O
(	O
int	O
)	O
'.'	O
)	O
;	O
prec	int
=	O
0	int
;	O
if	O
(	O
ptr	*(char)
!=	O
NULL	O
)	O
{	O
int	O
count	int
=	O
0	int
;	O
while	O
(	O
*	O
(	O
++	O
ptr	*(char)
)	O
)	O
{	O
count	int
++	O
;	O
if	O
(	O
*	O
ptr	*(char)
!=	O
'0'	O
)	O
prec	int
=	O
count	int
;	O
}	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
labelbuf	*(char)
,	O
"%.*f"	*(char)
,	O
prec	int
,	O
val	double
)	O
;	O
return	O
;	O
}	O
}	O
static	O
void	O
scale1	(double,double,*(double),*(int))->(void)
(	O
double	O
min	double
,	O
double	O
max	double
,	O
double	O
*	O
tick_spacing	double
,	O
int	O
*	O
tick_spacing_type	*(int)
)	O
{	O
int	O
k	int
;	O
double	O
nal	double
;	O
double	O
a	double
,	O
b	double
;	O
static	O
const	O
double	O
vint	array(double)
[	O
]	O
=	O
{	O
1.0	int
,	O
2.0	int
,	O
5.0	int
,	O
10.0	int
}	O
;	O
static	O
const	O
double	O
sqr	array(double)
[	O
]	O
=	O
{	O
M_SQRT2	int
,	O
3.16228	int
,	O
7.07107	int
}	O
;	O
a	double
=	O
(	O
max	double
-	O
min	double
)	O
/	O
TRIAL_NUMBER_OF_TICK_INTERVALS	int
;	O
a	double
*=	O
(	O
max	double
>	O
min	double
)	O
?	O
1.0	int
:	O
-	O
1.0	int
;	O
if	O
(	O
a	double
<=	O
0.0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the trial inter-tick spacing '%g' is bad\n"	*(char)
,	O
progname	*(char)
,	O
a	double
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
nal	double
=	O
floor	(double)->(double)
(	O
log10	(double)->(double)
(	O
a	double
)	O
)	O
;	O
b	double
=	O
a	double
*	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
-	O
nal	double
)	O
;	O
k	int
=	O
0	int
;	O
do	O
{	O
if	O
(	O
b	double
<	O
sqr	array(double)
[	O
k	int
]	O
)	O
break	O
;	O
k	int
++	O
;	O
}	O
while	O
(	O
k	int
<	O
3	int
)	O
;	O
*	O
tick_spacing	double
=	O
(	O
max	double
>	O
min	double
?	O
1.0	int
:	O
-	O
1.0	int
)	O
*	O
vint	array(double)
[	O
k	int
]	O
*	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
nal	double
)	O
;	O
*	O
tick_spacing_type	*(int)
=	O
(	O
k	int
==	O
3	int
?	O
0	int
:	O
k	int
)	O
;	O
return	O
;	O
}	O
static	O
int	O
spacing_type	(double)->(int)
(	O
double	O
incr	double
)	O
{	O
int	O
i	int
;	O
int	O
i_tenpower	int
=	O
(	O
int	O
)	O
(	O
floor	(double)->(double)
(	O
log10	(double)->(double)
(	O
incr	double
)	O
)	O
)	O
;	O
double	O
tenpower	double
=	O
1.0	int
;	O
bool	enum(int,int)
neg_power	enum(int,int)
=	O
false	int
;	O
if	O
(	O
i_tenpower	int
<	O
0	int
)	O
{	O
neg_power	enum(int,int)
=	O
true	int
;	O
i_tenpower	int
=	O
-	O
i_tenpower	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
i_tenpower	int
;	O
i	int
++	O
)	O
tenpower	double
*=	O
10	int
;	O
if	O
(	O
neg_power	enum(int,int)
)	O
tenpower	double
=	O
1.0	int
/	O
tenpower	double
;	O
if	O
(	O
NEAR_EQUALITY	O
(	O
incr	double
,	O
tenpower	double
,	O
tenpower	double
)	O
)	O
return	O
S_ONE	int
;	O
else	O
if	O
(	O
NEAR_EQUALITY	O
(	O
incr	double
,	O
2	int
*	O
tenpower	double
,	O
tenpower	double
)	O
)	O
return	O
S_TWO	int
;	O
else	O
if	O
(	O
NEAR_EQUALITY	O
(	O
incr	double
,	O
2.5	int
*	O
tenpower	double
,	O
tenpower	double
)	O
)	O
return	O
S_TWO_FIVE	int
;	O
else	O
if	O
(	O
NEAR_EQUALITY	O
(	O
incr	double
,	O
5	int
*	O
tenpower	double
,	O
tenpower	double
)	O
)	O
return	O
S_FIVE	int
;	O
else	O
return	O
S_UNKNOWN	O
;	O
}	O
static	O
void	O
prepare_axis	(*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)),*(struct(double,double,double,enum(int,int),double,double,double,double,double,double)),double,double,double,*(char),double,*(char),double,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int))->(void)
(	O
Axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
*	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
,	O
Transform	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
*	O
trans	*(struct(double,double,double,enum(int,int),double,double,double,double,double,double))
,	O
double	O
min	double
,	O
double	O
max	double
,	O
double	O
spacing	double
,	O
const	O
char	O
*	O
font_name	*(char)
,	O
double	O
font_size	double
,	O
const	O
char	O
*	O
label	*(char)
,	O
double	O
subsubtick_spacing	double
,	O
bool	enum(int,int)
user_specified_subsubticks	enum(int,int)
,	O
bool	enum(int,int)
round_to_next_tick	int
,	O
bool	enum(int,int)
log_axis	int
,	O
bool	enum(int,int)
reverse_axis	enum(int,int)
,	O
bool	enum(int,int)
switch_axis_end	int
,	O
bool	enum(int,int)
omit_ticks	enum(int,int)
)	O
{	O
double	O
range	double
;	O
int	O
tick_spacing_type	*(int)
=	O
0	int
;	O
double	O
tick_spacing	double
,	O
lin_subtick_spacing	double
;	O
int	O
min_tick_count	int
,	O
max_tick_count	int
;	O
int	O
min_lin_subtick_count	int
,	O
max_lin_subtick_count	int
;	O
bool	enum(int,int)
have_lin_subticks	enum(int,int)
;	O
if	O
(	O
min	double
>	O
max	double
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: min > max for an axis, which is not allowed\n"	*(char)
,	O
progname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
min	double
==	O
max	double
)	O
{	O
max	double
=	O
floor	(double)->(double)
(	O
max	double
+	O
1.0	int
)	O
;	O
min	double
=	O
ceil	(double)->(double)
(	O
min	double
-	O
1.0	int
)	O
;	O
}	O
if	O
(	O
log_axis	int
)	O
{	O
scale1	(double,double,*(double),*(int))->(void)
(	O
min	double
,	O
max	double
,	O
&	O
tick_spacing	double
,	O
&	O
tick_spacing_type	*(int)
)	O
;	O
if	O
(	O
tick_spacing	double
<=	O
1.0	int
)	O
{	O
tick_spacing	double
=	O
1.0	int
;	O
tick_spacing_type	*(int)
=	O
S_ONE	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
spacing	double
==	O
0.0	int
)	O
scale1	(double,double,*(double),*(int))->(void)
(	O
min	double
,	O
max	double
,	O
&	O
tick_spacing	double
,	O
&	O
tick_spacing_type	*(int)
)	O
;	O
else	O
{	O
tick_spacing	double
=	O
spacing	double
;	O
tick_spacing_type	*(int)
=	O
spacing_type	(double)->(int)
(	O
spacing	double
)	O
;	O
}	O
}	O
range	double
=	O
max	double
-	O
min	double
;	O
if	O
(	O
round_to_next_tick	int
)	O
{	O
if	O
(	O
user_specified_subsubticks	enum(int,int)
)	O
{	O
double	O
true_min	double
=	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
min	double
)	O
,	O
true_max	double
=	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
max	double
)	O
;	O
double	O
true_range	double
=	O
true_max	double
-	O
true_min	double
;	O
int	O
min_count	int
,	O
max_count	int
;	O
min_count	int
=	O
(	O
int	O
)	O
(	O
floor	(double)->(double)
(	O
(	O
true_min	double
+	O
FUZZ	int
*	O
true_range	double
)	O
/	O
subsubtick_spacing	double
)	O
)	O
;	O
max_count	int
=	O
(	O
int	O
)	O
(	O
ceil	(double)->(double)
(	O
(	O
true_max	double
-	O
FUZZ	int
*	O
true_range	double
)	O
/	O
subsubtick_spacing	double
)	O
)	O
;	O
if	O
(	O
min_count	int
>	O
0	int
)	O
min	double
=	O
log10	(double)->(double)
(	O
min_count	int
*	O
subsubtick_spacing	double
)	O
;	O
max	double
=	O
log10	(double)->(double)
(	O
max_count	int
*	O
subsubtick_spacing	double
)	O
;	O
range	double
=	O
max	double
-	O
min	double
;	O
min_tick_count	int
=	O
max_tick_count	int
=	O
0	int
;	O
}	O
else	O
{	O
min_tick_count	int
=	O
(	O
int	O
)	O
(	O
floor	(double)->(double)
(	O
(	O
min	double
+	O
FUZZ	int
*	O
range	double
)	O
/	O
tick_spacing	double
)	O
)	O
;	O
max_tick_count	int
=	O
(	O
int	O
)	O
(	O
ceil	(double)->(double)
(	O
(	O
max	double
-	O
FUZZ	int
*	O
range	double
)	O
/	O
tick_spacing	double
)	O
)	O
;	O
min	double
=	O
tick_spacing	double
*	O
min_tick_count	int
;	O
max	double
=	O
tick_spacing	double
*	O
max_tick_count	int
;	O
range	double
=	O
max	double
-	O
min	double
;	O
}	O
}	O
else	O
{	O
min_tick_count	int
=	O
(	O
int	O
)	O
(	O
ceil	(double)->(double)
(	O
(	O
min	double
-	O
FUZZ	int
*	O
range	double
)	O
/	O
tick_spacing	double
)	O
)	O
;	O
max_tick_count	int
=	O
(	O
int	O
)	O
(	O
floor	(double)->(double)
(	O
(	O
max	double
+	O
FUZZ	int
*	O
range	double
)	O
/	O
tick_spacing	double
)	O
)	O
;	O
}	O
switch	O
(	O
tick_spacing_type	*(int)
)	O
{	O
case	O
S_FIVE	int
:	O
case	O
S_TWO_FIVE	int
:	O
lin_subtick_spacing	double
=	O
tick_spacing	double
/	O
5	int
;	O
break	O
;	O
case	O
S_TWO	int
:	O
lin_subtick_spacing	double
=	O
tick_spacing	double
/	O
2	int
;	O
break	O
;	O
case	O
S_ONE	int
:	O
lin_subtick_spacing	double
=	O
tick_spacing	double
/	O
10	int
;	O
min_lin_subtick_count	int
=	O
(	O
int	O
)	O
(	O
ceil	(double)->(double)
(	O
(	O
min	double
-	O
FUZZ	int
*	O
range	double
)	O
/	O
lin_subtick_spacing	double
)	O
)	O
;	O
max_lin_subtick_count	int
=	O
(	O
int	O
)	O
(	O
floor	(double)->(double)
(	O
(	O
max	double
+	O
FUZZ	int
*	O
range	double
)	O
/	O
lin_subtick_spacing	double
)	O
)	O
;	O
if	O
(	O
max_lin_subtick_count	int
-	O
min_lin_subtick_count	int
>	O
MAX_NUM_SUBTICKS	int
)	O
{	O
lin_subtick_spacing	double
=	O
tick_spacing	double
/	O
5	int
;	O
min_lin_subtick_count	int
=	O
(	O
int	O
)	O
(	O
ceil	(double)->(double)
(	O
(	O
min	double
-	O
FUZZ	int
*	O
range	double
)	O
/	O
lin_subtick_spacing	double
)	O
)	O
;	O
max_lin_subtick_count	int
=	O
(	O
int	O
)	O
(	O
floor	(double)->(double)
(	O
(	O
max	double
+	O
FUZZ	int
*	O
range	double
)	O
/	O
lin_subtick_spacing	double
)	O
)	O
;	O
if	O
(	O
max_lin_subtick_count	int
-	O
min_lin_subtick_count	int
>	O
MAX_NUM_SUBTICKS	int
)	O
lin_subtick_spacing	double
=	O
tick_spacing	double
/	O
2	int
;	O
}	O
break	O
;	O
default	O
:	O
lin_subtick_spacing	double
=	O
tick_spacing	double
;	O
break	O
;	O
}	O
if	O
(	O
log_axis	int
&&	O
lin_subtick_spacing	double
<=	O
1.0	int
)	O
lin_subtick_spacing	double
=	O
1.0	int
;	O
min_lin_subtick_count	int
=	O
(	O
int	O
)	O
(	O
ceil	(double)->(double)
(	O
(	O
min	double
-	O
FUZZ	int
*	O
range	double
)	O
/	O
lin_subtick_spacing	double
)	O
)	O
;	O
max_lin_subtick_count	int
=	O
(	O
int	O
)	O
(	O
floor	(double)->(double)
(	O
(	O
max	double
+	O
FUZZ	int
*	O
range	double
)	O
/	O
lin_subtick_spacing	double
)	O
)	O
;	O
have_lin_subticks	enum(int,int)
=	O
(	O
(	O
tick_spacing_type	*(int)
!=	O
S_UNKNOWN	O
&&	O
(	O
max_lin_subtick_count	int
-	O
min_lin_subtick_count	int
)	O
<=	O
MAX_NUM_SUBTICKS	int
)	O
?	O
true	int
:	O
false	int
)	O
;	O
trans	*(struct(double,double,double,enum(int,int),double,double,double,double,double,double))
->	O
input_min	double
=	O
min	double
;	O
trans	*(struct(double,double,double,enum(int,int),double,double,double,double,double,double))
->	O
input_max	double
=	O
max	double
;	O
trans	*(struct(double,double,double,enum(int,int),double,double,double,double,double,double))
->	O
input_range	double
=	O
range	double
;	O
trans	*(struct(double,double,double,enum(int,int),double,double,double,double,double,double))
->	O
reverse	enum(int,int)
=	O
reverse_axis	enum(int,int)
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
switch_axis_end	int
=	O
switch_axis_end	int
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
omit_ticks	enum(int,int)
=	O
omit_ticks	enum(int,int)
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
label	*(char)
=	O
label	*(char)
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
font_name	*(char)
=	O
font_name	*(char)
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
font_size	double
=	O
font_size	double
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
max_label_width	double
=	O
0.0	int
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
type	*(char)
=	O
log_axis	int
?	O
A_LOG10	int
:	O
A_LINEAR	int
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
tick_spacing	double
=	O
tick_spacing	double
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
min_tick_count	int
=	O
min_tick_count	int
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
max_tick_count	int
=	O
max_tick_count	int
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
have_lin_subticks	enum(int,int)
=	O
have_lin_subticks	enum(int,int)
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
lin_subtick_spacing	double
=	O
lin_subtick_spacing	double
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
min_lin_subtick_count	int
=	O
min_lin_subtick_count	int
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
max_lin_subtick_count	int
=	O
max_lin_subtick_count	int
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
user_specified_subsubticks	enum(int,int)
=	O
user_specified_subsubticks	enum(int,int)
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
subsubtick_spacing	double
=	O
subsubtick_spacing	double
;	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
labelled_ticks	int
=	O
0	int
;	O
if	O
(	O
log_axis	int
)	O
{	O
if	O
(	O
max	double
-	O
min	double
<=	O
MAX_DECADES_WITH_LOG_SUBSUBTICKS	int
+	O
FUZZ	int
)	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
have_normal_subsubticks	enum(int,int)
=	O
true	int
;	O
else	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
have_normal_subsubticks	enum(int,int)
=	O
false	int
;	O
}	O
else	O
axisp	*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int))
->	O
have_normal_subsubticks	enum(int,int)
=	O
false	int
;	O
}	O
Multigrapher	struct
*	O
new_multigrapher	(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),enum(int,int))->(*(struct))
(	O
const	O
char	O
*	O
output_format	*(char)
,	O
const	O
char	O
*	O
bg_color	*(char)
,	O
const	O
char	O
*	O
bitmap_size	*(char)
,	O
const	O
char	O
*	O
emulate_color	*(char)
,	O
const	O
char	O
*	O
max_line_length	*(char)
,	O
const	O
char	O
*	O
meta_portable	*(char)
,	O
const	O
char	O
*	O
page_size	*(char)
,	O
const	O
char	O
*	O
rotation_angle	*(char)
,	O
bool	enum(int,int)
save_screen	enum(int,int)
)	O
{	O
plPlotterParams	struct
*	O
plotter_params	*(struct)
;	O
plPlotter	struct
*	O
plotter	*(struct)
;	O
Multigrapher	struct
*	O
multigrapher	*(struct)
;	O
multigrapher	*(struct)
=	O
(	O
Multigrapher	struct
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
Multigrapher	struct
)	O
)	O
;	O
plotter_params	*(struct)
=	O
pl_newplparams	()->(*(struct))
(	O
)	O
;	O
pl_setplparam	(*(struct),*(char),*(void))->(int)
(	O
plotter_params	*(struct)
,	O
"BG_COLOR"	*(char)
,	O
(	O
void	O
*	O
)	O
bg_color	*(char)
)	O
;	O
pl_setplparam	(*(struct),*(char),*(void))->(int)
(	O
plotter_params	*(struct)
,	O
"BITMAPSIZE"	*(char)
,	O
(	O
void	O
*	O
)	O
bitmap_size	*(char)
)	O
;	O
pl_setplparam	(*(struct),*(char),*(void))->(int)
(	O
plotter_params	*(struct)
,	O
"EMULATE_COLOR"	*(char)
,	O
(	O
void	O
*	O
)	O
emulate_color	*(char)
)	O
;	O
pl_setplparam	(*(struct),*(char),*(void))->(int)
(	O
plotter_params	*(struct)
,	O
"MAX_LINE_LENGTH"	*(char)
,	O
(	O
void	O
*	O
)	O
max_line_length	*(char)
)	O
;	O
pl_setplparam	(*(struct),*(char),*(void))->(int)
(	O
plotter_params	*(struct)
,	O
"META_PORTABLE"	*(char)
,	O
(	O
void	O
*	O
)	O
meta_portable	*(char)
)	O
;	O
pl_setplparam	(*(struct),*(char),*(void))->(int)
(	O
plotter_params	*(struct)
,	O
"PAGESIZE"	*(char)
,	O
(	O
void	O
*	O
)	O
page_size	*(char)
)	O
;	O
pl_setplparam	(*(struct),*(char),*(void))->(int)
(	O
plotter_params	*(struct)
,	O
"ROTATION"	*(char)
,	O
(	O
void	O
*	O
)	O
rotation_angle	*(char)
)	O
;	O
plotter	*(struct)
=	O
pl_newpl_r	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct))->(*(struct))
(	O
output_format	*(char)
,	O
NULL	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
plotter_params	*(struct)
)	O
;	O
if	O
(	O
plotter	*(struct)
==	O
(	O
plPlotter	struct
*	O
)	O
NULL	O
)	O
return	O
(	O
Multigrapher	struct
*	O
)	O
NULL	O
;	O
pl_deleteplparams	(*(struct))->(int)
(	O
plotter_params	*(struct)
)	O
;	O
multigrapher	*(struct)
->	O
plotter	*(struct)
=	O
plotter	*(struct)
;	O
if	O
(	O
pl_openpl_r	(*(struct))->(int)
(	O
plotter	*(struct)
)	O
<	O
0	int
)	O
return	O
(	O
Multigrapher	struct
*	O
)	O
NULL	O
;	O
multigrapher	*(struct)
->	O
bg_color	*(char)
=	O
bg_color	*(char)
;	O
if	O
(	O
!	O
save_screen	enum(int,int)
||	O
bg_color	*(char)
)	O
pl_erase_r	(*(struct))->(int)
(	O
plotter	*(struct)
)	O
;	O
pl_fspace_r	(*(struct),double,double,double,double)->(int)
(	O
plotter	*(struct)
,	O
0.0	int
,	O
0.0	int
,	O
(	O
double	O
)	O
PLOT_SIZE	int
,	O
(	O
double	O
)	O
PLOT_SIZE	int
)	O
;	O
return	O
multigrapher	*(struct)
;	O
}	O
int	O
delete_multigrapher	(*(struct))->(int)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
)	O
{	O
int	O
retval	int
;	O
retval	int
=	O
pl_closepl_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
if	O
(	O
retval	int
>=	O
0	int
)	O
retval	int
=	O
pl_deletepl_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
multigrapher	*(struct)
)	O
;	O
return	O
retval	int
;	O
}	O
void	O
begin_graph	(*(struct),double,double,double)->(void)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
double	O
scale	double
,	O
double	O
trans_x	double
,	O
double	O
trans_y	double
)	O
{	O
pl_savestate_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
pl_fconcat_r	(*(struct),double,double,double,double,double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
scale	double
,	O
0.0	int
,	O
0.0	int
,	O
scale	double
,	O
trans_x	double
*	O
PLOT_SIZE	int
,	O
trans_y	double
*	O
PLOT_SIZE	int
)	O
;	O
}	O
void	O
end_graph	(*(struct))->(void)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
)	O
{	O
pl_restorestate_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
}	O
void	O
set_graph_parameters	(*(struct),double,*(char),*(char),*(char),double,double,enum(int,int,int,int,int),double,double,double,double,double,double,enum(int,int),enum(int,int),double,double,double,double,*(char),double,*(char),*(char),double,*(char),enum(int,int),int,int,int,int,int,double,enum(int,int))->(void)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
double	O
frame_line_width	double
,	O
const	O
char	O
*	O
frame_color	*(char)
,	O
const	O
char	O
*	O
title	*(char)
,	O
const	O
char	O
*	O
title_font_name	*(char)
,	O
double	O
title_font_size	double
,	O
double	O
tick_size	double
,	O
grid_type	enum(int,int,int,int,int)
grid_spec	enum(int,int,int,int,int)
,	O
double	O
x_min	double
,	O
double	O
x_max	double
,	O
double	O
x_spacing	double
,	O
double	O
y_min	double
,	O
double	O
y_max	double
,	O
double	O
y_spacing	double
,	O
bool	enum(int,int)
spec_x_spacing	enum(int,int)
,	O
bool	enum(int,int)
spec_y_spacing	enum(int,int)
,	O
double	O
width	double
,	O
double	O
height	double
,	O
double	O
up	double
,	O
double	O
right	double
,	O
const	O
char	O
*	O
x_font_name	*(char)
,	O
double	O
x_font_size	double
,	O
const	O
char	O
*	O
x_label	*(char)
,	O
const	O
char	O
*	O
y_font_name	*(char)
,	O
double	O
y_font_size	double
,	O
const	O
char	O
*	O
y_label	*(char)
,	O
bool	enum(int,int)
no_rotate_y_label	enum(int,int)
,	O
int	O
log_axis	int
,	O
int	O
round_to_next_tick	int
,	O
int	O
switch_axis_end	int
,	O
int	O
omit_ticks	enum(int,int)
,	O
int	O
clip_mode	int
,	O
double	O
blankout_fraction	double
,	O
bool	enum(int,int)
transpose_axes	enum(int,int)
)	O
{	O
double	O
x_subsubtick_spacing	double
=	O
0.0	int
,	O
y_subsubtick_spacing	double
=	O
0.0	int
;	O
int	O
reverse_axis	enum(int,int)
=	O
0	int
;	O
int	O
user_specified_subsubticks	enum(int,int)
=	O
0	int
;	O
if	O
(	O
log_axis	int
&	O
X_AXIS	int
)	O
{	O
if	O
(	O
spec_x_spacing	enum(int,int)
)	O
{	O
spec_x_spacing	enum(int,int)
=	O
false	int
;	O
user_specified_subsubticks	enum(int,int)
|=	O
X_AXIS	int
;	O
x_subsubtick_spacing	double
=	O
x_spacing	double
;	O
}	O
}	O
if	O
(	O
log_axis	int
&	O
Y_AXIS	int
)	O
{	O
if	O
(	O
spec_y_spacing	enum(int,int)
)	O
{	O
spec_y_spacing	enum(int,int)
=	O
false	int
;	O
user_specified_subsubticks	enum(int,int)
|=	O
Y_AXIS	int
;	O
y_subsubtick_spacing	double
=	O
y_spacing	double
;	O
}	O
}	O
if	O
(	O
x_max	double
<	O
x_min	double
)	O
{	O
reverse_axis	enum(int,int)
|=	O
X_AXIS	int
;	O
{	O
double	O
temp	double
;	O
temp	double
=	O
x_min	double
;	O
x_min	double
=	O
x_max	double
;	O
x_max	double
=	O
temp	double
;	O
}	O
}	O
if	O
(	O
x_max	double
==	O
x_min	double
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: identical upper and lower x limits are separated\n"	*(char)
,	O
progname	*(char)
)	O
;	O
x_max	double
+=	O
1.0	int
;	O
x_min	double
-=	O
1.0	int
;	O
}	O
if	O
(	O
y_max	double
<	O
y_min	double
)	O
{	O
reverse_axis	enum(int,int)
|=	O
Y_AXIS	int
;	O
{	O
double	O
temp	double
;	O
temp	double
=	O
y_min	double
;	O
y_min	double
=	O
y_max	double
;	O
y_max	double
=	O
temp	double
;	O
}	O
}	O
if	O
(	O
y_max	double
==	O
y_min	double
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: identical upper and lower y limits are separated\n"	*(char)
,	O
progname	*(char)
)	O
;	O
y_max	double
+=	O
1.0	int
;	O
y_min	double
-=	O
1.0	int
;	O
}	O
if	O
(	O
spec_x_spacing	enum(int,int)
)	O
{	O
if	O
(	O
x_spacing	double
==	O
0.0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the spacing between ticks on an axis is zero\n"	*(char)
,	O
progname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
x_spacing	double
=	O
fabs	(double)->(double)
(	O
x_spacing	double
)	O
;	O
}	O
if	O
(	O
spec_y_spacing	enum(int,int)
)	O
{	O
if	O
(	O
y_spacing	double
==	O
0.0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the spacing between ticks on an axis is zero\n"	*(char)
,	O
progname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
y_spacing	double
=	O
fabs	(double)->(double)
(	O
y_spacing	double
)	O
;	O
}	O
if	O
(	O
transpose_axes	enum(int,int)
)	O
{	O
const	O
char	O
*	O
temp_string	*(char)
;	O
double	O
temp_double	double
;	O
transpose_portmanteau	(*(int))->(void)
(	O
&	O
log_axis	int
)	O
;	O
transpose_portmanteau	(*(int))->(void)
(	O
&	O
round_to_next_tick	int
)	O
;	O
transpose_portmanteau	(*(int))->(void)
(	O
&	O
switch_axis_end	int
)	O
;	O
transpose_portmanteau	(*(int))->(void)
(	O
&	O
omit_ticks	enum(int,int)
)	O
;	O
transpose_portmanteau	(*(int))->(void)
(	O
&	O
reverse_axis	enum(int,int)
)	O
;	O
transpose_portmanteau	(*(int))->(void)
(	O
&	O
user_specified_subsubticks	enum(int,int)
)	O
;	O
temp_string	*(char)
=	O
x_label	*(char)
;	O
x_label	*(char)
=	O
y_label	*(char)
;	O
y_label	*(char)
=	O
temp_string	*(char)
;	O
temp_double	double
=	O
x_min	double
;	O
x_min	double
=	O
y_min	double
;	O
y_min	double
=	O
temp_double	double
;	O
temp_double	double
=	O
x_max	double
;	O
x_max	double
=	O
y_max	double
;	O
y_max	double
=	O
temp_double	double
;	O
temp_double	double
=	O
x_spacing	double
;	O
x_spacing	double
=	O
y_spacing	double
;	O
y_spacing	double
=	O
temp_double	double
;	O
temp_double	double
=	O
x_subsubtick_spacing	double
;	O
x_subsubtick_spacing	double
=	O
y_subsubtick_spacing	double
;	O
y_subsubtick_spacing	double
=	O
temp_double	double
;	O
}	O
multigrapher	*(struct)
->	O
frame_line_width	double
=	O
frame_line_width	double
;	O
multigrapher	*(struct)
->	O
frame_color	*(char)
=	O
frame_color	*(char)
;	O
multigrapher	*(struct)
->	O
no_rotate_y_label	enum(int,int)
=	O
no_rotate_y_label	enum(int,int)
;	O
multigrapher	*(struct)
->	O
blankout_fraction	double
=	O
blankout_fraction	double
;	O
if	O
(	O
title	*(char)
!=	O
NULL	O
)	O
multigrapher	*(struct)
->	O
title	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
title	*(char)
)	O
;	O
else	O
multigrapher	*(struct)
->	O
title	*(char)
=	O
NULL	O
;	O
if	O
(	O
title_font_name	*(char)
!=	O
NULL	O
)	O
multigrapher	*(struct)
->	O
title_font_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
title_font_name	*(char)
)	O
;	O
else	O
multigrapher	*(struct)
->	O
title_font_name	*(char)
=	O
NULL	O
;	O
multigrapher	*(struct)
->	O
title_font_size	double
=	O
title_font_size	double
;	O
multigrapher	*(struct)
->	O
tick_size	double
=	O
tick_size	double
;	O
multigrapher	*(struct)
->	O
subtick_size	double
=	O
RELATIVE_SUBTICK_SIZE	int
*	O
tick_size	double
;	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
=	O
grid_spec	enum(int,int,int,int,int)
;	O
multigrapher	*(struct)
->	O
clip_mode	int
=	O
clip_mode	int
;	O
prepare_axis	(*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)),*(struct(double,double,double,enum(int,int),double,double,double,double,double,double)),double,double,double,*(char),double,*(char),double,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int))->(void)
(	O
&	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
,	O
&	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
,	O
x_min	double
,	O
x_max	double
,	O
x_spacing	double
,	O
x_font_name	*(char)
,	O
x_font_size	double
,	O
x_label	*(char)
,	O
x_subsubtick_spacing	double
,	O
(	O
bool	enum(int,int)
)	O
(	O
user_specified_subsubticks	enum(int,int)
&	O
X_AXIS	int
)	O
,	O
(	O
bool	enum(int,int)
)	O
(	O
round_to_next_tick	int
&	O
X_AXIS	int
)	O
,	O
(	O
bool	enum(int,int)
)	O
(	O
log_axis	int
&	O
X_AXIS	int
)	O
,	O
(	O
bool	enum(int,int)
)	O
(	O
reverse_axis	enum(int,int)
&	O
X_AXIS	int
)	O
,	O
(	O
bool	enum(int,int)
)	O
(	O
switch_axis_end	int
&	O
X_AXIS	int
)	O
,	O
(	O
bool	enum(int,int)
)	O
(	O
omit_ticks	enum(int,int)
&	O
X_AXIS	int
)	O
)	O
;	O
prepare_axis	(*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)),*(struct(double,double,double,enum(int,int),double,double,double,double,double,double)),double,double,double,*(char),double,*(char),double,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int))->(void)
(	O
&	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
,	O
&	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
,	O
y_min	double
,	O
y_max	double
,	O
y_spacing	double
,	O
y_font_name	*(char)
,	O
y_font_size	double
,	O
y_label	*(char)
,	O
y_subsubtick_spacing	double
,	O
(	O
bool	enum(int,int)
)	O
(	O
user_specified_subsubticks	enum(int,int)
&	O
Y_AXIS	int
)	O
,	O
(	O
bool	enum(int,int)
)	O
(	O
round_to_next_tick	int
&	O
Y_AXIS	int
)	O
,	O
(	O
bool	enum(int,int)
)	O
(	O
log_axis	int
&	O
Y_AXIS	int
)	O
,	O
(	O
bool	enum(int,int)
)	O
(	O
reverse_axis	enum(int,int)
&	O
Y_AXIS	int
)	O
,	O
(	O
bool	enum(int,int)
)	O
(	O
switch_axis_end	int
&	O
Y_AXIS	int
)	O
,	O
(	O
bool	enum(int,int)
)	O
(	O
omit_ticks	enum(int,int)
&	O
Y_AXIS	int
)	O
)	O
;	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
squeezed_min	double
=	O
right	double
;	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
squeezed_max	double
=	O
right	double
+	O
width	double
;	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
squeezed_range	double
=	O
width	double
;	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
squeezed_min	double
=	O
up	double
;	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
squeezed_max	double
=	O
up	double
+	O
height	double
;	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
squeezed_range	double
=	O
height	double
;	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
output_min	double
=	O
0.0	int
;	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
output_max	double
=	O
(	O
double	O
)	O
PLOT_SIZE	int
;	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
output_range	double
=	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
output_max	double
-	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
output_min	double
;	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
output_min	double
=	O
0.0	int
;	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
output_max	double
=	O
(	O
double	O
)	O
PLOT_SIZE	int
;	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
output_range	double
=	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
output_max	double
-	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
output_min	double
;	O
if	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
!=	O
AXES_AT_ORIGIN	int
)	O
{	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
=	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
;	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
=	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
;	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
=	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
;	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
=	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
;	O
}	O
else	O
{	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
=	O
(	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
*	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
<=	O
0.0	int
)	O
?	O
0.0	int
:	O
(	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
:	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
)	O
;	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
=	O
(	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
*	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
<=	O
0.0	int
)	O
?	O
0.0	int
:	O
(	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
:	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
)	O
;	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
=	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
;	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
=	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
;	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
=	O
(	O
(	O
(	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
-	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
<	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
-	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
)	O
)	O
?	O
true	int
:	O
false	int
)	O
;	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
=	O
(	O
(	O
(	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
-	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
<	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
-	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
)	O
)	O
?	O
true	int
:	O
false	int
)	O
;	O
}	O
if	O
(	O
frame_line_width	double
<	O
0.0	int
||	O
pl_havecap_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"WIDE_LINES"	*(char)
)	O
==	O
0	int
)	O
multigrapher	*(struct)
->	O
half_line_width	double
=	O
0.0	int
;	O
else	O
multigrapher	*(struct)
->	O
half_line_width	double
=	O
0.5	int
*	O
frame_line_width	double
*	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
output_range	double
;	O
multigrapher	*(struct)
->	O
first_point_of_polyline	enum(int,int)
=	O
true	int
;	O
multigrapher	*(struct)
->	O
oldpoint_x	double
=	O
0.0	int
;	O
multigrapher	*(struct)
->	O
oldpoint_y	double
=	O
0.0	int
;	O
}	O
void	O
draw_frame_of_graph	(*(struct),enum(int,int))->(void)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
bool	enum(int,int)
draw_canvas	enum(int,int)
)	O
{	O
static	O
bool	enum(int,int)
tick_warning_printed	enum(int,int)
=	O
false	int
;	O
pl_savestate_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
if	O
(	O
multigrapher	*(struct)
->	O
frame_color	*(char)
)	O
pl_pencolorname_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
multigrapher	*(struct)
->	O
frame_color	*(char)
)	O
;	O
pl_flinewidth_r	(*(struct),double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
multigrapher	*(struct)
->	O
frame_line_width	double
*	O
(	O
double	O
)	O
PLOT_SIZE	int
)	O
;	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"solid"	*(char)
)	O
;	O
pl_filltype_r	(*(struct),int)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
draw_canvas	enum(int,int)
)	O
{	O
pl_savestate_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
if	O
(	O
pl_havecap_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"SETTABLE_BACKGROUND"	*(char)
)	O
!=	O
0	int
&&	O
multigrapher	*(struct)
->	O
bg_color	*(char)
)	O
pl_colorname_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
multigrapher	*(struct)
->	O
bg_color	*(char)
)	O
;	O
else	O
pl_colorname_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"white"	*(char)
)	O
;	O
pl_filltype_r	(*(struct),int)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
1	int
)	O
;	O
pl_fbox_r	(*(struct),double,double,double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XP	O
(	O
XSQ	O
(	O
0.5	int
-	O
0.5	int
*	O
multigrapher	*(struct)
->	O
blankout_fraction	double
)	O
)	O
,	O
YP	O
(	O
YSQ	O
(	O
0.5	int
-	O
0.5	int
*	O
multigrapher	*(struct)
->	O
blankout_fraction	double
)	O
)	O
,	O
XP	O
(	O
XSQ	O
(	O
0.5	int
+	O
0.5	int
*	O
multigrapher	*(struct)
->	O
blankout_fraction	double
)	O
)	O
,	O
YP	O
(	O
YSQ	O
(	O
0.5	int
+	O
0.5	int
*	O
multigrapher	*(struct)
->	O
blankout_fraction	double
)	O
)	O
)	O
;	O
pl_restorestate_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
}	O
if	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
!=	O
NO_AXES	int
&&	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
&&	O
multigrapher	*(struct)
->	O
title	*(char)
!=	O
NULL	O
&&	O
*	O
multigrapher	*(struct)
->	O
title	*(char)
!=	O
'\0'	O
)	O
{	O
double	O
title_font_size	double
;	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
multigrapher	*(struct)
->	O
title_font_name	*(char)
)	O
;	O
title_font_size	double
=	O
pl_ffontsize_r	(*(struct),double)->(double)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
SS	O
(	O
multigrapher	*(struct)
->	O
title_font_size	double
)	O
)	O
;	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XP	O
(	O
XSQ	O
(	O
0.5	int
)	O
)	O
,	O
YP	O
(	O
YSQ	O
(	O
1.0	int
+	O
(	O
(	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
==	O
AXES_AND_BOX	int
||	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
==	O
AXES	int
)	O
&&	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
<=	O
0.0	int
)	O
?	O
1.0	int
:	O
0.5	int
)	O
*	O
fabs	(double)->(double)
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
)	O
)	O
)	O
+	O
0.65	int
*	O
title_font_size	double
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
;	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
'c'	O
,	O
'b'	O
,	O
multigrapher	*(struct)
->	O
title	*(char)
)	O
;	O
}	O
switch	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
)	O
{	O
case	O
AXES_AND_BOX_AND_GRID	int
:	O
case	O
AXES_AND_BOX	int
:	O
pl_fbox_r	(*(struct),double,double,double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XP	O
(	O
XSQ	O
(	O
0.0	int
)	O
)	O
,	O
YP	O
(	O
YSQ	O
(	O
0.0	int
)	O
)	O
,	O
XP	O
(	O
XSQ	O
(	O
1.0	int
)	O
)	O
,	O
YP	O
(	O
YSQ	O
(	O
1.0	int
)	O
)	O
)	O
;	O
break	O
;	O
case	O
AXES	int
:	O
{	O
double	O
xstart	double
,	O
ystart	double
,	O
xmid	double
,	O
ymid	double
,	O
xend	double
,	O
yend	double
;	O
xstart	double
=	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
?	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
;	O
ystart	double
=	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
?	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
:	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
)	O
;	O
xmid	double
=	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
?	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
:	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
)	O
;	O
ymid	double
=	O
ystart	double
;	O
xend	double
=	O
xmid	double
;	O
yend	double
=	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
?	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
;	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
xstart	double
,	O
ystart	double
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
xmid	double
,	O
ymid	double
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
xend	double
,	O
yend	double
)	O
;	O
}	O
break	O
;	O
case	O
AXES_AT_ORIGIN	int
:	O
{	O
double	O
xpos	double
,	O
ypos	double
;	O
xpos	double
=	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
?	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
:	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
)	O
;	O
ypos	double
=	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
?	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
:	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
)	O
;	O
pl_fline_r	(*(struct),double,double,double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
xpos	double
,	O
YP	O
(	O
YSQ	O
(	O
0.0	int
)	O
)	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
,	O
xpos	double
,	O
YP	O
(	O
YSQ	O
(	O
1.0	int
)	O
)	O
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
;	O
pl_fline_r	(*(struct),double,double,double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XP	O
(	O
XSQ	O
(	O
0.0	int
)	O
)	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
,	O
ypos	double
,	O
XP	O
(	O
XSQ	O
(	O
1.0	int
)	O
)	O
+	O
multigrapher	*(struct)
->	O
half_line_width	double
,	O
ypos	double
)	O
;	O
}	O
break	O
;	O
case	O
NO_AXES	int
:	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
!=	O
NO_AXES	int
&&	O
!	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
omit_ticks	enum(int,int)
&&	O
!	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
user_specified_subsubticks	enum(int,int)
)	O
{	O
int	O
i	int
;	O
double	O
xval	double
,	O
xrange	double
=	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
-	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
;	O
char	O
labelbuf	*(char)
[	O
2048	int
]	O
;	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
font_name	*(char)
)	O
;	O
pl_ffontsize_r	(*(struct),double)->(double)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
SS	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
font_size	double
)	O
)	O
;	O
for	O
(	O
i	int
=	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
min_tick_count	int
;	O
i	int
<=	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
max_tick_count	int
;	O
i	int
++	O
)	O
{	O
xval	double
=	O
i	int
*	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
tick_spacing	double
;	O
if	O
(	O
xval	double
<	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
-	O
FUZZ	int
*	O
xrange	double
||	O
xval	double
>	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
FUZZ	int
*	O
xrange	double
)	O
continue	O
;	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
&&	O
!	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
==	O
AXES_AT_ORIGIN	int
&&	O
NEAR_EQUALITY	O
(	O
xval	double
,	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
,	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_range	double
)	O
&&	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
!=	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
)	O
&&	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
!=	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
)	O
)	O
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
-	O
(	O
SS	O
(	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>=	O
0.0	int
?	O
0.75	int
:	O
1.75	int
)	O
*	O
fabs	(double)->(double)
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
)	O
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
;	O
print_tick_label	(*(char),*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)),*(struct(double,double,double,enum(int,int),double,double,double,double,double,double)),double)->(void)
(	O
labelbuf	*(char)
,	O
&	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
,	O
&	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
,	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
type	*(char)
==	O
A_LOG10	int
)	O
?	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
xval	double
)	O
:	O
xval	double
)	O
;	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
'c'	O
,	O
't'	O
,	O
labelbuf	*(char)
)	O
;	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
labelled_ticks	int
++	O
;	O
}	O
else	O
if	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
&&	O
!	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
==	O
AXES_AT_ORIGIN	int
&&	O
NEAR_EQUALITY	O
(	O
xval	double
,	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
,	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_range	double
)	O
&&	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
!=	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
)	O
&&	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
!=	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
)	O
)	O
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
+	O
(	O
SS	O
(	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>=	O
0.0	int
?	O
0.75	int
:	O
1.75	int
)	O
*	O
fabs	(double)->(double)
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
)	O
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
;	O
print_tick_label	(*(char),*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)),*(struct(double,double,double,enum(int,int),double,double,double,double,double,double)),double)->(void)
(	O
labelbuf	*(char)
,	O
&	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
,	O
&	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
,	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
type	*(char)
==	O
A_LOG10	int
)	O
?	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
xval	double
)	O
:	O
xval	double
)	O
;	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
'c'	O
,	O
'b'	O
,	O
labelbuf	*(char)
)	O
;	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
labelled_ticks	int
++	O
;	O
}	O
switch	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
)	O
{	O
case	O
AXES_AND_BOX_AND_GRID	int
:	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"dotted"	*(char)
)	O
;	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YP	O
(	O
YSQ	O
(	O
0.0	int
)	O
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YP	O
(	O
YSQ	O
(	O
1.0	int
)	O
)	O
)	O
;	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"solid"	*(char)
)	O
;	O
case	O
AXES_AND_BOX	int
:	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
-	O
(	O
SS	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
+	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
)	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
+	O
(	O
SS	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
+	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
)	O
;	O
}	O
case	O
AXES	int
:	O
case	O
AXES_AT_ORIGIN	int
:	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
+	O
(	O
SS	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
+	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
)	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
-	O
(	O
SS	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
+	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
have_lin_subticks	enum(int,int)
)	O
{	O
double	O
subtick_size	double
;	O
subtick_size	double
=	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
type	*(char)
==	O
A_LOG10	int
?	O
SS	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
:	O
SS	O
(	O
multigrapher	*(struct)
->	O
subtick_size	double
)	O
)	O
;	O
for	O
(	O
i	int
=	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
min_lin_subtick_count	int
;	O
i	int
<=	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
max_lin_subtick_count	int
;	O
i	int
++	O
)	O
{	O
xval	double
=	O
i	int
*	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
lin_subtick_spacing	double
;	O
if	O
(	O
xval	double
<	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
-	O
FUZZ	int
*	O
xrange	double
||	O
xval	double
>	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
FUZZ	int
*	O
xrange	double
)	O
continue	O
;	O
switch	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
)	O
{	O
case	O
AXES_AND_BOX_AND_GRID	int
:	O
case	O
AXES_AND_BOX	int
:	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
-	O
(	O
subtick_size	double
+	O
(	O
subtick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
)	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
+	O
(	O
subtick_size	double
+	O
(	O
subtick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
)	O
;	O
}	O
case	O
AXES	int
:	O
case	O
AXES_AT_ORIGIN	int
:	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
+	O
(	O
subtick_size	double
+	O
(	O
subtick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
)	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
-	O
(	O
subtick_size	double
+	O
(	O
subtick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
!=	O
AXES_AT_ORIGIN	int
&&	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
type	*(char)
==	O
A_LINEAR	int
&&	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
*	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
<	O
0.0	int
)	O
{	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"dotted"	*(char)
)	O
;	O
pl_fline_r	(*(struct),double,double,double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
0.0	int
)	O
,	O
YP	O
(	O
YSQ	O
(	O
0.0	int
)	O
)	O
,	O
XV	O
(	O
0.0	int
)	O
,	O
YP	O
(	O
YSQ	O
(	O
1.0	int
)	O
)	O
)	O
;	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"solid"	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
!=	O
NO_AXES	int
&&	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
omit_ticks	enum(int,int)
&&	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
user_specified_subsubticks	enum(int,int)
)	O
{	O
int	O
i	int
;	O
double	O
yval	double
,	O
yrange	double
=	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
-	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
;	O
char	O
labelbuf	*(char)
[	O
2048	int
]	O
;	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
font_name	*(char)
)	O
;	O
pl_ffontsize_r	(*(struct),double)->(double)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
SS	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
font_size	double
)	O
)	O
;	O
for	O
(	O
i	int
=	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
min_tick_count	int
;	O
i	int
<=	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
max_tick_count	int
;	O
i	int
++	O
)	O
{	O
yval	double
=	O
i	int
*	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
tick_spacing	double
;	O
if	O
(	O
yval	double
<	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
-	O
FUZZ	int
*	O
yrange	double
||	O
yval	double
>	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
FUZZ	int
*	O
yrange	double
)	O
continue	O
;	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
&&	O
!	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
==	O
AXES_AT_ORIGIN	int
&&	O
NEAR_EQUALITY	O
(	O
yval	double
,	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
,	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_range	double
)	O
&&	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
!=	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
)	O
&&	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
!=	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
)	O
)	O
)	O
{	O
double	O
new_width	double
;	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
-	O
(	O
SS	O
(	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>=	O
0.0	int
?	O
0.75	int
:	O
1.75	int
)	O
*	O
fabs	(double)->(double)
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
)	O
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
print_tick_label	(*(char),*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)),*(struct(double,double,double,enum(int,int),double,double,double,double,double,double)),double)->(void)
(	O
labelbuf	*(char)
,	O
&	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
,	O
&	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
,	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
type	*(char)
==	O
A_LOG10	int
)	O
?	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
yval	double
)	O
:	O
yval	double
)	O
;	O
new_width	double
=	O
pl_flabelwidth_r	(*(struct),*(char))->(double)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
labelbuf	*(char)
)	O
;	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
'r'	O
,	O
'c'	O
,	O
labelbuf	*(char)
)	O
;	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
max_label_width	double
=	O
DMAX	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
max_label_width	double
,	O
new_width	double
)	O
;	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
labelled_ticks	int
++	O
;	O
}	O
else	O
if	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
&&	O
!	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
==	O
AXES_AT_ORIGIN	int
&&	O
NEAR_EQUALITY	O
(	O
yval	double
,	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
,	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_range	double
)	O
&&	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
!=	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
)	O
&&	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
!=	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
)	O
)	O
)	O
{	O
double	O
new_width	double
;	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
+	O
(	O
SS	O
(	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>=	O
0.0	int
?	O
0.75	int
:	O
1.75	int
)	O
*	O
fabs	(double)->(double)
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
)	O
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
print_tick_label	(*(char),*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)),*(struct(double,double,double,enum(int,int),double,double,double,double,double,double)),double)->(void)
(	O
labelbuf	*(char)
,	O
&	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
,	O
&	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
,	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
type	*(char)
==	O
A_LOG10	int
)	O
?	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
yval	double
)	O
:	O
yval	double
)	O
;	O
new_width	double
=	O
pl_flabelwidth_r	(*(struct),*(char))->(double)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
labelbuf	*(char)
)	O
;	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
'l'	O
,	O
'c'	O
,	O
labelbuf	*(char)
)	O
;	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
max_label_width	double
=	O
DMAX	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
max_label_width	double
,	O
new_width	double
)	O
;	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
labelled_ticks	int
++	O
;	O
}	O
switch	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
)	O
{	O
case	O
AXES_AND_BOX_AND_GRID	int
:	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"dotted"	*(char)
)	O
;	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XP	O
(	O
XSQ	O
(	O
0.0	int
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XP	O
(	O
XSQ	O
(	O
1.0	int
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"solid"	*(char)
)	O
;	O
case	O
AXES_AND_BOX	int
:	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
-	O
(	O
SS	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
+	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
+	O
(	O
SS	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
+	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
}	O
case	O
AXES	int
:	O
case	O
AXES_AT_ORIGIN	int
:	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
+	O
(	O
SS	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
+	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
-	O
(	O
SS	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
+	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
have_lin_subticks	enum(int,int)
)	O
{	O
double	O
subtick_size	double
;	O
subtick_size	double
=	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
type	*(char)
==	O
A_LOG10	int
?	O
SS	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
:	O
SS	O
(	O
multigrapher	*(struct)
->	O
subtick_size	double
)	O
)	O
;	O
for	O
(	O
i	int
=	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
min_lin_subtick_count	int
;	O
i	int
<=	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
max_lin_subtick_count	int
;	O
i	int
++	O
)	O
{	O
yval	double
=	O
i	int
*	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
lin_subtick_spacing	double
;	O
if	O
(	O
yval	double
<	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
-	O
FUZZ	int
*	O
yrange	double
||	O
yval	double
>	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
FUZZ	int
*	O
yrange	double
)	O
continue	O
;	O
switch	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
)	O
{	O
case	O
AXES_AND_BOX_AND_GRID	int
:	O
case	O
AXES_AND_BOX	int
:	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
-	O
(	O
subtick_size	double
+	O
(	O
subtick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
+	O
(	O
subtick_size	double
+	O
(	O
subtick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
}	O
case	O
AXES	int
:	O
case	O
AXES_AT_ORIGIN	int
:	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
+	O
(	O
subtick_size	double
+	O
(	O
subtick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
-	O
(	O
subtick_size	double
+	O
(	O
subtick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
!=	O
AXES_AT_ORIGIN	int
&&	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
type	*(char)
==	O
A_LINEAR	int
&&	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
*	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
<	O
0.0	int
)	O
{	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"dotted"	*(char)
)	O
;	O
pl_fline_r	(*(struct),double,double,double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XP	O
(	O
XSQ	O
(	O
0.0	int
)	O
)	O
,	O
YV	O
(	O
0.0	int
)	O
,	O
XP	O
(	O
XSQ	O
(	O
1.0	int
)	O
)	O
,	O
YV	O
(	O
0.0	int
)	O
)	O
;	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"solid"	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
!=	O
NO_AXES	int
&&	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
have_normal_subsubticks	enum(int,int)
&&	O
!	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
user_specified_subsubticks	enum(int,int)
&&	O
!	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
omit_ticks	enum(int,int)
)	O
{	O
int	O
i	int
,	O
m	int
,	O
imin	int
,	O
imax	int
;	O
double	O
xval	double
,	O
xrange	double
=	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
-	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
;	O
imin	int
=	O
(	O
int	O
)	O
(	O
floor	(double)->(double)
(	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
-	O
FUZZ	int
*	O
xrange	double
)	O
)	O
;	O
imax	int
=	O
(	O
int	O
)	O
(	O
ceil	(double)->(double)
(	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
FUZZ	int
*	O
xrange	double
)	O
)	O
;	O
for	O
(	O
i	int
=	O
imin	int
;	O
i	int
<	O
imax	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
m	int
=	O
1	int
;	O
m	int
<=	O
9	int
;	O
m	int
++	O
)	O
{	O
xval	double
=	O
i	int
+	O
log10	(double)->(double)
(	O
(	O
double	O
)	O
m	int
)	O
;	O
plot_abscissa_log_subsubtick	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),double)->(void)
(	O
multigrapher	*(struct)
,	O
xval	double
)	O
;	O
}	O
}	O
}	O
if	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
!=	O
NO_AXES	int
&&	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
user_specified_subsubticks	enum(int,int)
&&	O
!	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
omit_ticks	enum(int,int)
)	O
{	O
int	O
i	int
,	O
imin	int
,	O
imax	int
;	O
double	O
xval	double
,	O
xrange	double
=	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
-	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
;	O
imin	int
=	O
(	O
int	O
)	O
(	O
floor	(double)->(double)
(	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
-	O
FUZZ	int
*	O
xrange	double
)	O
/	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
subsubtick_spacing	double
)	O
)	O
;	O
imax	int
=	O
(	O
int	O
)	O
(	O
ceil	(double)->(double)
(	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
FUZZ	int
*	O
xrange	double
)	O
/	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
subsubtick_spacing	double
)	O
)	O
;	O
for	O
(	O
i	int
=	O
imin	int
;	O
i	int
<=	O
imax	int
;	O
i	int
++	O
)	O
{	O
xval	double
=	O
log10	(double)->(double)
(	O
i	int
*	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
subsubtick_spacing	double
)	O
;	O
plot_abscissa_log_subsubtick	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),double)->(void)
(	O
multigrapher	*(struct)
,	O
xval	double
)	O
;	O
}	O
}	O
if	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
!=	O
NO_AXES	int
&&	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
have_normal_subsubticks	enum(int,int)
&&	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
user_specified_subsubticks	enum(int,int)
&&	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
omit_ticks	enum(int,int)
)	O
{	O
int	O
i	int
,	O
m	int
,	O
imin	int
,	O
imax	int
;	O
double	O
yval	double
,	O
yrange	double
=	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
-	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
;	O
imin	int
=	O
(	O
int	O
)	O
(	O
floor	(double)->(double)
(	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
-	O
FUZZ	int
*	O
yrange	double
)	O
)	O
;	O
imax	int
=	O
(	O
int	O
)	O
(	O
ceil	(double)->(double)
(	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
FUZZ	int
*	O
yrange	double
)	O
)	O
;	O
for	O
(	O
i	int
=	O
imin	int
;	O
i	int
<	O
imax	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
m	int
=	O
1	int
;	O
m	int
<=	O
9	int
;	O
m	int
++	O
)	O
{	O
yval	double
=	O
i	int
+	O
log10	(double)->(double)
(	O
(	O
double	O
)	O
m	int
)	O
;	O
plot_ordinate_log_subsubtick	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),double)->(void)
(	O
multigrapher	*(struct)
,	O
yval	double
)	O
;	O
}	O
}	O
}	O
if	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
!=	O
NO_AXES	int
&&	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
user_specified_subsubticks	enum(int,int)
&&	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
omit_ticks	enum(int,int)
)	O
{	O
int	O
i	int
,	O
imin	int
,	O
imax	int
;	O
double	O
yval	double
,	O
yrange	double
=	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
-	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
;	O
imin	int
=	O
(	O
int	O
)	O
(	O
floor	(double)->(double)
(	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
-	O
FUZZ	int
*	O
yrange	double
)	O
/	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
subsubtick_spacing	double
)	O
)	O
;	O
imax	int
=	O
(	O
int	O
)	O
(	O
ceil	(double)->(double)
(	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
FUZZ	int
*	O
yrange	double
)	O
/	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
subsubtick_spacing	double
)	O
)	O
;	O
for	O
(	O
i	int
=	O
imin	int
;	O
i	int
<=	O
imax	int
;	O
i	int
++	O
)	O
{	O
yval	double
=	O
log10	(double)->(double)
(	O
i	int
*	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
subsubtick_spacing	double
)	O
;	O
plot_ordinate_log_subsubtick	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),double)->(void)
(	O
multigrapher	*(struct)
,	O
yval	double
)	O
;	O
}	O
}	O
if	O
(	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
!=	O
NO_AXES	int
)	O
&&	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
label	*(char)
!=	O
NULL	O
&&	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
label	*(char)
!=	O
'\0'	O
)	O
{	O
double	O
x_axis_font_size	double
;	O
double	O
xloc	double
;	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
font_name	*(char)
)	O
;	O
x_axis_font_size	double
=	O
pl_ffontsize_r	(*(struct),double)->(double)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
SS	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
font_size	double
)	O
)	O
;	O
if	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
!=	O
AXES_AT_ORIGIN	int
)	O
xloc	double
=	O
0.5	int
*	O
(	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
)	O
;	O
else	O
{	O
if	O
(	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
==	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
)	O
||	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
==	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
)	O
)	O
xloc	double
=	O
0.5	int
*	O
(	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
)	O
;	O
else	O
xloc	double
=	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
-	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
>=	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
-	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
?	O
0.5	int
*	O
(	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
:	O
0.5	int
*	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
+	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
)	O
;	O
}	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xloc	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
-	O
(	O
SS	O
(	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>=	O
0.0	int
?	O
0.875	int
:	O
2.125	int
)	O
*	O
fabs	(double)->(double)
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
)	O
+	O
(	O
6	int
*	O
x_axis_font_size	double
)	O
/	O
5	int
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
;	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
'c'	O
,	O
't'	O
,	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
label	*(char)
)	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xloc	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
+	O
(	O
SS	O
(	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>=	O
0.0	int
?	O
0.875	int
:	O
2.125	int
)	O
*	O
fabs	(double)->(double)
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
)	O
+	O
(	O
6	int
*	O
x_axis_font_size	double
)	O
/	O
5	int
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
;	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
'c'	O
,	O
'b'	O
,	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
label	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
!=	O
NO_AXES	int
)	O
&&	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
label	*(char)
!=	O
NULL	O
&&	O
*	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
label	*(char)
)	O
!=	O
'\0'	O
)	O
)	O
{	O
double	O
y_axis_font_size	double
;	O
double	O
yloc	double
;	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
font_name	*(char)
)	O
;	O
y_axis_font_size	double
=	O
pl_ffontsize_r	(*(struct),double)->(double)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
SS	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
font_size	double
)	O
)	O
;	O
if	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
!=	O
AXES_AT_ORIGIN	int
)	O
yloc	double
=	O
0.5	int
*	O
(	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
+	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
)	O
;	O
else	O
{	O
if	O
(	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
==	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
)	O
||	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
==	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
)	O
)	O
yloc	double
=	O
0.5	int
*	O
(	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
+	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
)	O
;	O
else	O
yloc	double
=	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
-	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
>=	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
-	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
?	O
0.5	int
*	O
(	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
:	O
0.5	int
*	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
+	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
)	O
;	O
}	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
-	O
(	O
libplot_has_font_metrics	int
?	O
(	O
SS	O
(	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>=	O
0.0	int
?	O
0.75	int
:	O
1.75	int
)	O
*	O
fabs	(double)->(double)
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
)	O
+	O
1.15	int
*	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
max_label_width	double
+	O
0.5	int
*	O
y_axis_font_size	double
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
:	O
(	O
SS	O
(	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>=	O
0.0	int
?	O
0.75	int
:	O
1.75	int
)	O
*	O
fabs	(double)->(double)
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
)	O
+	O
1.0	int
*	O
y_axis_font_size	double
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
,	O
YV	O
(	O
yloc	double
)	O
)	O
;	O
if	O
(	O
libplot_has_font_metrics	int
&&	O
!	O
multigrapher	*(struct)
->	O
no_rotate_y_label	enum(int,int)
)	O
{	O
pl_textangle_r	(*(struct),int)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
90	int
)	O
;	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
'c'	O
,	O
'x'	O
,	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
label	*(char)
)	O
;	O
pl_textangle_r	(*(struct),int)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
0	int
)	O
;	O
}	O
else	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
'r'	O
,	O
'c'	O
,	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
label	*(char)
)	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
+	O
(	O
libplot_has_font_metrics	int
?	O
(	O
SS	O
(	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>=	O
0.0	int
?	O
0.75	int
:	O
1.75	int
)	O
*	O
fabs	(double)->(double)
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
)	O
+	O
1.15	int
*	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
max_label_width	double
+	O
0.5	int
*	O
y_axis_font_size	double
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
:	O
(	O
SS	O
(	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>=	O
0.0	int
?	O
0.75	int
:	O
1.75	int
)	O
*	O
fabs	(double)->(double)
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
)	O
+	O
1.0	int
*	O
y_axis_font_size	double
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
,	O
YV	O
(	O
yloc	double
)	O
)	O
;	O
if	O
(	O
libplot_has_font_metrics	int
&&	O
!	O
multigrapher	*(struct)
->	O
no_rotate_y_label	enum(int,int)
)	O
{	O
pl_textangle_r	(*(struct),int)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
90	int
)	O
;	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
'c'	O
,	O
't'	O
,	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
label	*(char)
)	O
;	O
pl_textangle_r	(*(struct),int)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
0	int
)	O
;	O
}	O
else	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
'l'	O
,	O
'c'	O
,	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
label	*(char)
)	O
;	O
}	O
}	O
pl_flushpl_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
pl_restorestate_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
if	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
!=	O
NO_AXES	int
)	O
{	O
if	O
(	O
!	O
tick_warning_printed	enum(int,int)
&&	O
(	O
(	O
!	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
omit_ticks	enum(int,int)
&&	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
labelled_ticks	int
<=	O
2	int
)	O
||	O
(	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
omit_ticks	enum(int,int)
&&	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
labelled_ticks	int
<=	O
2	int
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the tick spacing is adjusted, as there were too few labelled axis ticks\n"	*(char)
,	O
progname	*(char)
)	O
;	O
tick_warning_printed	enum(int,int)
=	O
true	int
;	O
}	O
}	O
}	O
static	O
void	O
plot_abscissa_log_subsubtick	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),double)->(void)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
double	O
xval	double
)	O
{	O
double	O
xrange	double
=	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
-	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
;	O
char	O
labelbuf	*(char)
[	O
2048	int
]	O
;	O
double	O
tick_size	double
=	O
SS	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
;	O
double	O
subsubtick_size	double
=	O
SS	O
(	O
multigrapher	*(struct)
->	O
subtick_size	double
)	O
;	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
font_name	*(char)
)	O
;	O
pl_ffontsize_r	(*(struct),double)->(double)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
SS	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
font_size	double
)	O
)	O
;	O
if	O
(	O
xval	double
<	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
-	O
FUZZ	int
*	O
xrange	double
||	O
xval	double
>	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
FUZZ	int
*	O
xrange	double
)	O
return	O
;	O
if	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
user_specified_subsubticks	enum(int,int)
)	O
{	O
print_tick_label	(*(char),*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)),*(struct(double,double,double,enum(int,int),double,double,double,double,double,double)),double)->(void)
(	O
labelbuf	*(char)
,	O
&	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
,	O
&	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
,	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
xval	double
)	O
)	O
;	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
-	O
(	O
(	O
tick_size	double
>=	O
0	int
?	O
0.75	int
:	O
1.75	int
)	O
*	O
fabs	(double)->(double)
(	O
(	O
double	O
)	O
tick_size	double
)	O
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
;	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
'c'	O
,	O
't'	O
,	O
labelbuf	*(char)
)	O
;	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
labelled_ticks	int
++	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
+	O
(	O
(	O
tick_size	double
>=	O
0	int
?	O
0.75	int
:	O
1.75	int
)	O
*	O
fabs	(double)->(double)
(	O
(	O
double	O
)	O
tick_size	double
)	O
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
;	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
'c'	O
,	O
'b'	O
,	O
labelbuf	*(char)
)	O
;	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
labelled_ticks	int
++	O
;	O
}	O
}	O
switch	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
)	O
{	O
case	O
AXES_AND_BOX_AND_GRID	int
:	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"dotted"	*(char)
)	O
;	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YP	O
(	O
YSQ	O
(	O
0.0	int
)	O
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YP	O
(	O
YSQ	O
(	O
1.0	int
)	O
)	O
)	O
;	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"solid"	*(char)
)	O
;	O
case	O
AXES_AND_BOX	int
:	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
-	O
(	O
subsubtick_size	double
+	O
(	O
subsubtick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
)	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
+	O
(	O
subsubtick_size	double
+	O
(	O
subsubtick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
)	O
;	O
}	O
case	O
AXES	int
:	O
case	O
AXES_AT_ORIGIN	int
:	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
+	O
(	O
subsubtick_size	double
+	O
(	O
subsubtick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
)	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
xval	double
)	O
,	O
YN	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
-	O
(	O
subsubtick_size	double
+	O
(	O
subsubtick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
void	O
plot_ordinate_log_subsubtick	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),double)->(void)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
double	O
yval	double
)	O
{	O
double	O
yrange	double
=	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
-	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
;	O
char	O
labelbuf	*(char)
[	O
2048	int
]	O
;	O
double	O
tick_size	double
=	O
SS	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
)	O
;	O
double	O
subsubtick_size	double
=	O
SS	O
(	O
multigrapher	*(struct)
->	O
subtick_size	double
)	O
;	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
font_name	*(char)
)	O
;	O
pl_ffontsize_r	(*(struct),double)->(double)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
SS	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
font_size	double
)	O
)	O
;	O
if	O
(	O
yval	double
<	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
-	O
FUZZ	int
*	O
yrange	double
||	O
yval	double
>	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
FUZZ	int
*	O
yrange	double
)	O
return	O
;	O
if	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
user_specified_subsubticks	enum(int,int)
)	O
{	O
double	O
new_width	double
;	O
print_tick_label	(*(char),*(struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)),*(struct(double,double,double,enum(int,int),double,double,double,double,double,double)),double)->(void)
(	O
labelbuf	*(char)
,	O
&	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
,	O
&	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
,	O
pow	(double,double)->(double)
(	O
10.0	int
,	O
yval	double
)	O
)	O
;	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
-	O
(	O
(	O
tick_size	double
>=	O
0	int
?	O
0.75	int
:	O
1.75	int
)	O
*	O
fabs	(double)->(double)
(	O
(	O
double	O
)	O
tick_size	double
)	O
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
new_width	double
=	O
pl_flabelwidth_r	(*(struct),*(char))->(double)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
labelbuf	*(char)
)	O
;	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
'r'	O
,	O
'c'	O
,	O
labelbuf	*(char)
)	O
;	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
max_label_width	double
=	O
DMAX	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
max_label_width	double
,	O
new_width	double
)	O
;	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
labelled_ticks	int
++	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
+	O
(	O
(	O
tick_size	double
>=	O
0	int
?	O
0.75	int
:	O
1.75	int
)	O
*	O
fabs	(double)->(double)
(	O
(	O
double	O
)	O
tick_size	double
)	O
+	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
new_width	double
=	O
pl_flabelwidth_r	(*(struct),*(char))->(double)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
labelbuf	*(char)
)	O
;	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
'l'	O
,	O
'c'	O
,	O
labelbuf	*(char)
)	O
;	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
max_label_width	double
=	O
DMAX	O
(	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
max_label_width	double
,	O
new_width	double
)	O
;	O
multigrapher	*(struct)
->	O
y_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
labelled_ticks	int
++	O
;	O
}	O
}	O
switch	O
(	O
multigrapher	*(struct)
->	O
grid_spec	enum(int,int,int,int,int)
)	O
{	O
case	O
AXES_AND_BOX_AND_GRID	int
:	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"dotted"	*(char)
)	O
;	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XP	O
(	O
XSQ	O
(	O
0.0	int
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XP	O
(	O
XSQ	O
(	O
1.0	int
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"solid"	*(char)
)	O
;	O
case	O
AXES_AND_BOX	int
:	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
-	O
(	O
subsubtick_size	double
+	O
(	O
subsubtick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
+	O
(	O
subsubtick_size	double
+	O
(	O
subsubtick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
}	O
case	O
AXES	int
:	O
case	O
AXES_AT_ORIGIN	int
:	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
switch_axis_end	int
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
other_axis_loc	double
)	O
+	O
(	O
subsubtick_size	double
+	O
(	O
subsubtick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
}	O
else	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XN	O
(	O
multigrapher	*(struct)
->	O
x_axis	struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int)
.	O
alt_other_axis_loc	double
)	O
-	O
(	O
subsubtick_size	double
+	O
(	O
multigrapher	*(struct)
->	O
tick_size	double
>	O
0.0	int
?	O
multigrapher	*(struct)
->	O
half_line_width	double
:	O
-	O
multigrapher	*(struct)
->	O
half_line_width	double
)	O
)	O
,	O
YV	O
(	O
yval	double
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
void	O
set_line_style	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),int,enum(int,int))->(void)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
int	O
style	int
,	O
bool	enum(int,int)
use_color	enum(int,int)
)	O
{	O
if	O
(	O
!	O
use_color	enum(int,int)
)	O
{	O
if	O
(	O
style	int
>	O
0	int
)	O
{	O
int	O
i	int
;	O
i	int
=	O
(	O
style	int
-	O
1	int
)	O
%	O
NO_OF_LINEMODES	int
;	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
linemodes	array(*(char))
[	O
i	int
]	O
)	O
;	O
}	O
pl_colorname_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
multigrapher	*(struct)
->	O
frame_color	*(char)
)	O
;	O
}	O
else	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
style	int
>	O
0	int
)	O
{	O
i	int
=	O
(	O
(	O
style	int
-	O
1	int
)	O
/	O
NO_OF_LINEMODES	int
)	O
%	O
NO_OF_LINEMODES	int
;	O
j	int
=	O
(	O
style	int
-	O
1	int
)	O
%	O
NO_OF_LINEMODES	int
;	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
linemodes	array(*(char))
[	O
i	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
style	int
==	O
0	int
)	O
j	int
=	O
0	int
;	O
else	O
j	int
=	O
(	O
-	O
style	int
-	O
1	int
)	O
%	O
(	O
NO_OF_LINEMODES	int
-	O
1	int
)	O
;	O
pl_colorname_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
colorstyle	array(*(char))
[	O
j	int
]	O
)	O
;	O
}	O
}	O
void	O
plot_point_array	(*(struct),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))),int)->(void)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
const	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
p	*(void)
,	O
int	O
length	long
)	O
{	O
int	O
index	(*(char),int)->(*(char))
;	O
for	O
(	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
index	(*(char),int)->(*(char))
<	O
length	long
;	O
index	(*(char),int)->(*(char))
++	O
)	O
plot_point	(*(struct),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(void)
(	O
multigrapher	*(struct)
,	O
&	O
(	O
p	*(void)
[	O
index	(*(char),int)->(*(char))
]	O
)	O
)	O
;	O
}	O
void	O
plot_point	(*(struct),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(void)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
const	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
{	O
double	O
local_x0	double
,	O
local_y0	double
,	O
local_x1	double
,	O
local_y1	double
;	O
int	O
clipval	int
;	O
if	O
(	O
!	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
pendown	enum(int,int)
)	O
||	O
multigrapher	*(struct)
->	O
first_point_of_polyline	enum(int,int)
)	O
{	O
int	O
intfill	int
;	O
set_line_style	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),int,enum(int,int))->(void)
(	O
multigrapher	*(struct)
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
linemode	int
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
use_color	enum(int,int)
)	O
;	O
pl_flinewidth_r	(*(struct),double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
line_width	double
*	O
(	O
double	O
)	O
PLOT_SIZE	int
)	O
;	O
if	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
fill_fraction	double
<	O
0.0	int
)	O
intfill	int
=	O
0	int
;	O
else	O
intfill	int
=	O
1	int
+	O
IROUND	O
(	O
(	O
1.0	int
-	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
fill_fraction	double
)	O
*	O
0xfffe	int
)	O
;	O
pl_filltype_r	(*(struct),int)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
intfill	int
)	O
;	O
}	O
if	O
(	O
multigrapher	*(struct)
->	O
first_point_of_polyline	enum(int,int)
)	O
{	O
local_x0	double
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
;	O
local_y0	double
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
;	O
}	O
else	O
{	O
local_x0	double
=	O
multigrapher	*(struct)
->	O
oldpoint_x	double
;	O
local_y0	double
=	O
multigrapher	*(struct)
->	O
oldpoint_y	double
;	O
}	O
local_x1	double
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
;	O
local_y1	double
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
;	O
multigrapher	*(struct)
->	O
oldpoint_x	double
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
;	O
multigrapher	*(struct)
->	O
oldpoint_y	double
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
;	O
clipval	int
=	O
clip_line	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),*(double),*(double),*(double),*(double))->(int)
(	O
multigrapher	*(struct)
,	O
&	O
local_x0	double
,	O
&	O
local_y0	double
,	O
&	O
local_x1	double
,	O
&	O
local_y1	double
)	O
;	O
if	O
(	O
!	O
(	O
clipval	int
&	O
ACCEPTED	int
)	O
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
)	O
,	O
YV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
)	O
)	O
;	O
multigrapher	*(struct)
->	O
first_point_of_polyline	enum(int,int)
=	O
false	int
;	O
return	O
;	O
}	O
if	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
pendown	enum(int,int)
&&	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
linemode	int
>	O
0	int
)	O
)	O
{	O
switch	O
(	O
multigrapher	*(struct)
->	O
clip_mode	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
(	O
clipval	int
&	O
CLIPPED_FIRST	int
)	O
||	O
(	O
clipval	int
&	O
CLIPPED_SECOND	int
)	O
)	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
)	O
,	O
YV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
)	O
)	O
;	O
else	O
{	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
first_point_of_polyline	enum(int,int)
)	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
)	O
,	O
YV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
)	O
)	O
;	O
else	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
)	O
,	O
YV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
1	int
:	O
default	O
:	O
if	O
(	O
(	O
clipval	int
&	O
CLIPPED_FIRST	int
)	O
&&	O
(	O
clipval	int
&	O
CLIPPED_SECOND	int
)	O
)	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
)	O
,	O
YV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
)	O
)	O
;	O
else	O
{	O
if	O
(	O
clipval	int
&	O
CLIPPED_FIRST	int
)	O
{	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
first_point_of_polyline	enum(int,int)
)	O
{	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
local_x0	double
)	O
,	O
YV	O
(	O
local_y0	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
)	O
,	O
YV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
)	O
)	O
;	O
}	O
else	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
)	O
,	O
YV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
multigrapher	*(struct)
->	O
first_point_of_polyline	enum(int,int)
)	O
{	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
local_x1	double
)	O
,	O
YV	O
(	O
local_y1	double
)	O
)	O
;	O
}	O
else	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
)	O
,	O
YV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
)	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
(	O
clipval	int
&	O
CLIPPED_FIRST	int
)	O
||	O
multigrapher	*(struct)
->	O
first_point_of_polyline	enum(int,int)
)	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
local_x0	double
)	O
,	O
YV	O
(	O
local_y0	double
)	O
)	O
;	O
pl_fcont_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
local_x1	double
)	O
,	O
YV	O
(	O
local_y1	double
)	O
)	O
;	O
if	O
(	O
clipval	int
&	O
CLIPPED_SECOND	int
)	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
)	O
,	O
YV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
)	O
)	O
;	O
break	O
;	O
}	O
}	O
else	O
pl_fmove_r	(*(struct),double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
)	O
,	O
YV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
)	O
)	O
;	O
multigrapher	*(struct)
->	O
first_point_of_polyline	enum(int,int)
=	O
false	int
;	O
if	O
(	O
clipval	int
&	O
CLIPPED_SECOND	int
)	O
return	O
;	O
if	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
symbol	int
>=	O
32	int
)	O
{	O
pl_savestate_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
plot_errorbar	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(void)
(	O
multigrapher	*(struct)
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
symbol_font_name	*(char)
)	O
;	O
pl_fmarker_r	(*(struct),double,double,int,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
)	O
,	O
YV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
)	O
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
symbol	int
,	O
SS	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
symbol_size	double
)	O
)	O
;	O
pl_restorestate_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
}	O
else	O
if	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
symbol	int
>	O
0	int
)	O
{	O
if	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
linemode	int
>	O
0	int
)	O
{	O
pl_savestate_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
plot_errorbar	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(void)
(	O
multigrapher	*(struct)
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
pl_fmarker_r	(*(struct),double,double,int,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
)	O
,	O
YV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
)	O
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
symbol	int
,	O
SS	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
symbol_size	double
)	O
)	O
;	O
pl_restorestate_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
}	O
else	O
{	O
plot_errorbar	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(void)
(	O
multigrapher	*(struct)
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
pl_fmarker_r	(*(struct),double,double,int,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
)	O
,	O
YV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
)	O
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
symbol	int
,	O
SS	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
symbol_size	double
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
symbol	int
==	O
0	int
&&	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
linemode	int
==	O
0	int
)	O
{	O
plot_errorbar	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(void)
(	O
multigrapher	*(struct)
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
pl_fmarker_r	(*(struct),double,double,int,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	int
)	O
,	O
YV	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	int
)	O
,	O
M_DOT	int
,	O
SS	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
symbol_size	double
)	O
)	O
;	O
}	O
else	O
plot_errorbar	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(void)
(	O
multigrapher	*(struct)
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
return	O
;	O
}	O
static	O
int	O
clip_line	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),*(double),*(double),*(double),*(double))->(int)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
double	O
*	O
x0_p	*(double)
,	O
double	O
*	O
y0_p	*(double)
,	O
double	O
*	O
x1_p	*(double)
,	O
double	O
*	O
y1_p	*(double)
)	O
{	O
double	O
x0	int
=	O
*	O
x0_p	*(double)
;	O
double	O
y0	(double)->(double)
=	O
*	O
y0_p	*(double)
;	O
double	O
x1	int
=	O
*	O
x1_p	*(double)
;	O
double	O
y1	(double)->(double)
=	O
*	O
y1_p	*(double)
;	O
outcode	int
outcode0	int
=	O
compute_outcode	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),double,double,enum(int,int))->(int)
(	O
multigrapher	*(struct)
,	O
x0	int
,	O
y0	(double)->(double)
,	O
true	int
)	O
;	O
outcode	int
outcode1	int
=	O
compute_outcode	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),double,double,enum(int,int))->(int)
(	O
multigrapher	*(struct)
,	O
x1	int
,	O
y1	(double)->(double)
,	O
true	int
)	O
;	O
bool	enum(int,int)
accepted	enum(int,int)
;	O
int	O
clipval	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
!	O
(	O
outcode0	int
|	O
outcode1	int
)	O
)	O
{	O
accepted	enum(int,int)
=	O
true	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
outcode0	int
&	O
outcode1	int
)	O
{	O
accepted	enum(int,int)
=	O
false	int
;	O
break	O
;	O
}	O
else	O
{	O
outcode	int
outcode_out	int
=	O
(	O
outcode0	int
?	O
outcode0	int
:	O
outcode1	int
)	O
;	O
double	O
x	int
,	O
y	int
;	O
if	O
(	O
outcode_out	int
&	O
RIGHT	int
)	O
{	O
x	int
=	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
;	O
y	int
=	O
y0	(double)->(double)
+	O
(	O
y1	(double)->(double)
-	O
y0	(double)->(double)
)	O
*	O
(	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
-	O
x0	int
)	O
/	O
(	O
x1	int
-	O
x0	int
)	O
;	O
}	O
else	O
if	O
(	O
outcode_out	int
&	O
LEFT	int
)	O
{	O
x	int
=	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
;	O
y	int
=	O
y0	(double)->(double)
+	O
(	O
y1	(double)->(double)
-	O
y0	(double)->(double)
)	O
*	O
(	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
-	O
x0	int
)	O
/	O
(	O
x1	int
-	O
x0	int
)	O
;	O
}	O
else	O
if	O
(	O
outcode_out	int
&	O
TOP	int
)	O
{	O
x	int
=	O
x0	int
+	O
(	O
x1	int
-	O
x0	int
)	O
*	O
(	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
-	O
y0	(double)->(double)
)	O
/	O
(	O
y1	(double)->(double)
-	O
y0	(double)->(double)
)	O
;	O
y	int
=	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
;	O
}	O
else	O
{	O
x	int
=	O
x0	int
+	O
(	O
x1	int
-	O
x0	int
)	O
*	O
(	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
-	O
y0	(double)->(double)
)	O
/	O
(	O
y1	(double)->(double)
-	O
y0	(double)->(double)
)	O
;	O
y	int
=	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
;	O
}	O
if	O
(	O
outcode_out	int
==	O
outcode0	int
)	O
{	O
x0	int
=	O
x	int
;	O
y0	(double)->(double)
=	O
y	int
;	O
outcode0	int
=	O
compute_outcode	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),double,double,enum(int,int))->(int)
(	O
multigrapher	*(struct)
,	O
x0	int
,	O
y0	(double)->(double)
,	O
true	int
)	O
;	O
}	O
else	O
{	O
x1	int
=	O
x	int
;	O
y1	(double)->(double)
=	O
y	int
;	O
outcode1	int
=	O
compute_outcode	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),double,double,enum(int,int))->(int)
(	O
multigrapher	*(struct)
,	O
x1	int
,	O
y1	(double)->(double)
,	O
true	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
accepted	enum(int,int)
)	O
{	O
clipval	int
|=	O
ACCEPTED	int
;	O
if	O
(	O
(	O
x0	int
!=	O
*	O
x0_p	*(double)
)	O
||	O
(	O
y0	(double)->(double)
!=	O
*	O
y0_p	*(double)
)	O
)	O
clipval	int
|=	O
CLIPPED_FIRST	int
;	O
if	O
(	O
(	O
x1	int
!=	O
*	O
x1_p	*(double)
)	O
||	O
(	O
y1	(double)->(double)
!=	O
*	O
y1_p	*(double)
)	O
)	O
clipval	int
|=	O
CLIPPED_SECOND	int
;	O
*	O
x0_p	*(double)
=	O
x0	int
;	O
*	O
y0_p	*(double)
=	O
y0	(double)->(double)
;	O
*	O
x1_p	*(double)
=	O
x1	int
;	O
*	O
y1_p	*(double)
=	O
y1	(double)->(double)
;	O
}	O
return	O
clipval	int
;	O
}	O
static	O
outcode	int
compute_outcode	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),double,double,enum(int,int))->(int)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
double	O
x	int
,	O
double	O
y	int
,	O
bool	enum(int,int)
tolerant	enum(int,int)
)	O
{	O
outcode	int
code	int
=	O
0	int
;	O
double	O
xfuzz	double
=	O
FUZZ	int
*	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_range	double
;	O
double	O
yfuzz	double
=	O
FUZZ	int
*	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_range	double
;	O
int	O
sign	int
=	O
(	O
tolerant	enum(int,int)
==	O
true	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
if	O
(	O
x	int
>	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
sign	int
*	O
xfuzz	double
)	O
code	int
|=	O
RIGHT	int
;	O
else	O
if	O
(	O
x	int
<	O
multigrapher	*(struct)
->	O
x_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
-	O
sign	int
*	O
xfuzz	double
)	O
code	int
|=	O
LEFT	int
;	O
if	O
(	O
y	int
>	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_max	double
+	O
sign	int
*	O
yfuzz	double
)	O
code	int
|=	O
TOP	int
;	O
else	O
if	O
(	O
y	int
<	O
multigrapher	*(struct)
->	O
y_trans	struct(double,double,double,enum(int,int),double,double,double,double,double,double)
.	O
input_min	double
-	O
sign	int
*	O
yfuzz	double
)	O
code	int
|=	O
BOTTOM	int
;	O
return	O
code	int
;	O
}	O
static	O
void	O
transpose_portmanteau	(*(int))->(void)
(	O
int	O
*	O
val	double
)	O
{	O
bool	enum(int,int)
xtrue	enum(int,int)
,	O
ytrue	enum(int,int)
;	O
int	O
newval	int
;	O
xtrue	enum(int,int)
=	O
(	O
(	O
*	O
val	double
&	O
X_AXIS	int
)	O
?	O
true	int
:	O
false	int
)	O
;	O
ytrue	enum(int,int)
=	O
(	O
(	O
*	O
val	double
&	O
Y_AXIS	int
)	O
?	O
true	int
:	O
false	int
)	O
;	O
newval	int
=	O
(	O
xtrue	enum(int,int)
?	O
Y_AXIS	int
:	O
0	int
)	O
|	O
(	O
ytrue	enum(int,int)
?	O
X_AXIS	int
:	O
0	int
)	O
;	O
*	O
val	double
=	O
newval	int
;	O
}	O
static	O
void	O
plot_errorbar	(*(struct(*(struct),*(char),*(char),enum(int,int),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(double,double,double,enum(int,int),double,double,double,double,double,double),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),struct(*(char),double,*(char),int,double,int,int,enum(int,int),double,int,int,enum(int,int),enum(int,int),double,double,double,enum(int,int),enum(int,int),double,int),enum(int,int,int,int,int),double,enum(int,int),double,double,double,double,*(char),*(char),*(char),double,int,enum(int,int),double,double,int,int)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(void)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
,	O
const	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
p	*(void)
)	O
{	O
if	O
(	O
p	*(void)
->	O
have_x_errorbar	enum(int,int)
||	O
p	*(void)
->	O
have_y_errorbar	enum(int,int)
)	O
{	O
pl_savestate_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
"solid"	*(char)
)	O
;	O
if	O
(	O
p	*(void)
->	O
have_x_errorbar	enum(int,int)
)	O
{	O
pl_fline_r	(*(struct),double,double,double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
p	*(void)
->	O
xmin	double
)	O
,	O
YV	O
(	O
p	*(void)
->	O
y	int
)	O
-	O
0.5	int
*	O
SS	O
(	O
p	*(void)
->	O
symbol_size	double
)	O
,	O
XV	O
(	O
p	*(void)
->	O
xmin	double
)	O
,	O
YV	O
(	O
p	*(void)
->	O
y	int
)	O
+	O
0.5	int
*	O
SS	O
(	O
p	*(void)
->	O
symbol_size	double
)	O
)	O
;	O
pl_fline_r	(*(struct),double,double,double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
p	*(void)
->	O
xmin	double
)	O
,	O
YV	O
(	O
p	*(void)
->	O
y	int
)	O
,	O
XV	O
(	O
p	*(void)
->	O
xmax	double
)	O
,	O
YV	O
(	O
p	*(void)
->	O
y	int
)	O
)	O
;	O
pl_fline_r	(*(struct),double,double,double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
p	*(void)
->	O
xmax	double
)	O
,	O
YV	O
(	O
p	*(void)
->	O
y	int
)	O
-	O
0.5	int
*	O
SS	O
(	O
p	*(void)
->	O
symbol_size	double
)	O
,	O
XV	O
(	O
p	*(void)
->	O
xmax	double
)	O
,	O
YV	O
(	O
p	*(void)
->	O
y	int
)	O
+	O
0.5	int
*	O
SS	O
(	O
p	*(void)
->	O
symbol_size	double
)	O
)	O
;	O
}	O
if	O
(	O
p	*(void)
->	O
have_y_errorbar	enum(int,int)
)	O
{	O
pl_fline_r	(*(struct),double,double,double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
p	*(void)
->	O
x	int
)	O
-	O
0.5	int
*	O
SS	O
(	O
p	*(void)
->	O
symbol_size	double
)	O
,	O
YV	O
(	O
p	*(void)
->	O
ymin	double
)	O
,	O
XV	O
(	O
p	*(void)
->	O
x	int
)	O
+	O
0.5	int
*	O
SS	O
(	O
p	*(void)
->	O
symbol_size	double
)	O
,	O
YV	O
(	O
p	*(void)
->	O
ymin	double
)	O
)	O
;	O
pl_fline_r	(*(struct),double,double,double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
p	*(void)
->	O
x	int
)	O
,	O
YV	O
(	O
p	*(void)
->	O
ymin	double
)	O
,	O
XV	O
(	O
p	*(void)
->	O
x	int
)	O
,	O
YV	O
(	O
p	*(void)
->	O
ymax	double
)	O
)	O
;	O
pl_fline_r	(*(struct),double,double,double,double)->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
,	O
XV	O
(	O
p	*(void)
->	O
x	int
)	O
-	O
0.5	int
*	O
SS	O
(	O
p	*(void)
->	O
symbol_size	double
)	O
,	O
YV	O
(	O
p	*(void)
->	O
ymax	double
)	O
,	O
XV	O
(	O
p	*(void)
->	O
x	int
)	O
+	O
0.5	int
*	O
SS	O
(	O
p	*(void)
->	O
symbol_size	double
)	O
,	O
YV	O
(	O
p	*(void)
->	O
ymax	double
)	O
)	O
;	O
}	O
pl_restorestate_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
}	O
}	O
void	O
end_polyline_and_flush	(*(struct))->(void)
(	O
Multigrapher	struct
*	O
multigrapher	*(struct)
)	O
{	O
pl_endpath_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
pl_flushpl_r	(*(struct))->(int)
(	O
multigrapher	*(struct)
->	O
plotter	*(struct)
)	O
;	O
multigrapher	*(struct)
->	O
first_point_of_polyline	enum(int,int)
=	O
true	int
;	O
}	O
