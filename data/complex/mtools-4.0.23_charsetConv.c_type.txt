struct	O
doscp_t	struct
{	O
iconv_t	*(void)
from	*(void)
;	O
iconv_t	*(void)
to	*(void)
;	O
}	O
;	O
static	O
const	O
char	O
*	O
wcharCp	*(char)
=	O
NULL	O
;	O
static	O
const	O
char	O
*	O
wcharTries	array(*(char))
[	O
]	O
=	O
{	O
"WCHAR_T"	*(char)
,	O
"UTF-32BE"	*(char)
,	O
"UTF-32LE"	*(char)
,	O
"UTF-16BE"	*(char)
,	O
"UTF-16LE"	*(char)
,	O
"UTF-32"	*(char)
,	O
"UTF-16"	*(char)
,	O
"UCS-4BE"	*(char)
,	O
"UCS-4LE"	*(char)
,	O
"UCS-2BE"	*(char)
,	O
"UCS-2LE"	*(char)
,	O
"UCS-4"	*(char)
,	O
"UCS-2"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
asciiTries	array(*(char))
[	O
]	O
=	O
{	O
"ASCII"	*(char)
,	O
"ASCII-GR"	*(char)
,	O
"ISO8859-1"	*(char)
}	O
;	O
static	O
const	O
wchar_t	int
*	O
testString	*(int)
=	O
L"ab"	O
;	O
static	O
int	O
try	(*(char))->(int)
(	O
const	O
char	O
*	O
testCp	*(char)
)	O
{	O
size_t	long
res	long
;	O
char	O
*	O
inbuf	*(char)
=	O
(	O
char	O
*	O
)	O
testString	*(int)
;	O
size_t	long
inbufLen	long
=	O
2	int
*	O
sizeof	O
(	O
wchar_t	int
)	O
;	O
char	O
outbuf	array(char)
[	O
3	int
]	O
;	O
char	O
*	O
outbufP	*(char)
=	O
outbuf	array(char)
;	O
size_t	long
outbufLen	long
=	O
2	int
*	O
sizeof	O
(	O
char	O
)	O
;	O
iconv_t	*(void)
test	*(void)
=	O
0	int
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
sizeof	O
(	O
asciiTries	array(*(char))
)	O
/	O
sizeof	O
(	O
asciiTries	array(*(char))
[	O
0	int
]	O
)	O
;	O
i	long
++	O
)	O
{	O
test	*(void)
=	O
iconv_open	(*(char),*(char))->(*(void))
(	O
asciiTries	array(*(char))
[	O
i	long
]	O
,	O
testCp	*(char)
)	O
;	O
if	O
(	O
test	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
-	O
1	int
)	O
break	O
;	O
}	O
if	O
(	O
test	*(void)
==	O
(	O
iconv_t	*(void)
)	O
-	O
1	int
)	O
goto	O
fail0	O
;	O
res	long
=	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
test	*(void)
,	O
&	O
inbuf	*(char)
,	O
&	O
inbufLen	long
,	O
&	O
outbufP	*(char)
,	O
&	O
outbufLen	long
)	O
;	O
if	O
(	O
res	long
!=	O
0	int
||	O
outbufLen	long
!=	O
0	int
||	O
inbufLen	long
!=	O
0	int
)	O
goto	O
fail	O
;	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
outbuf	array(char)
,	O
"ab"	*(char)
,	O
2	int
)	O
)	O
goto	O
fail	O
;	O
return	O
1	int
;	O
fail	O
:	O
iconv_close	(*(void))->(int)
(	O
test	*(void)
)	O
;	O
fail0	O
:	O
return	O
0	int
;	O
}	O
static	O
const	O
char	O
*	O
getWcharCp	()->(*(char))
(	O
void	O
)	O
{	O
unsigned	O
int	O
i	long
;	O
if	O
(	O
wcharCp	*(char)
!=	O
NULL	O
)	O
return	O
wcharCp	*(char)
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
sizeof	O
(	O
wcharTries	array(*(char))
)	O
/	O
sizeof	O
(	O
wcharTries	array(*(char))
[	O
0	int
]	O
)	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
try	(*(char))->(int)
(	O
wcharTries	array(*(char))
[	O
i	long
]	O
)	O
)	O
return	O
(	O
wcharCp	*(char)
=	O
wcharTries	array(*(char))
[	O
i	long
]	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"No codepage found for wchar_t\n"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
doscp_t	struct
*	O
cp_open	(int)->(*(struct))
(	O
int	O
codepage	int
)	O
{	O
char	O
dosCp	array(char)
[	O
17	int
]	O
;	O
doscp_t	struct
*	O
ret	*(struct(*(void),*(void)))
;	O
iconv_t	*(void)
*	O
from	*(void)
;	O
iconv_t	*(void)
*	O
to	*(void)
;	O
if	O
(	O
codepage	int
==	O
0	int
)	O
codepage	int
=	O
mtools_default_codepage	int
;	O
if	O
(	O
codepage	int
<	O
0	int
||	O
codepage	int
>	O
9999	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Bad codepage %d\n"	*(char)
,	O
codepage	int
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
getWcharCp	()->(*(char))
(	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
dosCp	array(char)
,	O
"CP%d"	*(char)
,	O
codepage	int
)	O
;	O
from	*(void)
=	O
iconv_open	(*(char),*(char))->(*(void))
(	O
wcharCp	*(char)
,	O
dosCp	array(char)
)	O
;	O
if	O
(	O
from	*(void)
==	O
(	O
iconv_t	*(void)
)	O
-	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error converting to codepage %d %s\n"	*(char)
,	O
codepage	int
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
dosCp	array(char)
,	O
"CP%d//TRANSLIT"	*(char)
,	O
codepage	int
)	O
;	O
to	*(void)
=	O
iconv_open	(*(char),*(char))->(*(void))
(	O
dosCp	array(char)
,	O
wcharCp	*(char)
)	O
;	O
if	O
(	O
to	*(void)
==	O
(	O
iconv_t	*(void)
)	O
-	O
1	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
dosCp	array(char)
,	O
"CP%d"	*(char)
,	O
codepage	int
)	O
;	O
to	*(void)
=	O
iconv_open	(*(char),*(char))->(*(void))
(	O
dosCp	array(char)
,	O
wcharCp	*(char)
)	O
;	O
}	O
if	O
(	O
to	*(void)
==	O
(	O
iconv_t	*(void)
)	O
-	O
1	int
)	O
{	O
iconv_close	(*(void))->(int)
(	O
from	*(void)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error converting to codepage %d %s\n"	*(char)
,	O
codepage	int
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
ret	*(struct(*(void),*(void)))
=	O
New	O
(	O
doscp_t	struct
)	O
;	O
if	O
(	O
ret	*(struct(*(void),*(void)))
==	O
NULL	O
)	O
return	O
ret	*(struct(*(void),*(void)))
;	O
ret	*(struct(*(void),*(void)))
->	O
from	*(void)
=	O
from	*(void)
;	O
ret	*(struct(*(void),*(void)))
->	O
to	*(void)
=	O
to	*(void)
;	O
return	O
ret	*(struct(*(void),*(void)))
;	O
}	O
void	O
cp_close	(*(struct))->(void)
(	O
doscp_t	struct
*	O
cp	*(struct)
)	O
{	O
iconv_close	(*(void))->(int)
(	O
cp	*(struct)
->	O
to	*(void)
)	O
;	O
iconv_close	(*(void))->(int)
(	O
cp	*(struct)
->	O
from	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
cp	*(struct)
)	O
;	O
}	O
int	O
dos_to_wchar	(*(struct),*(char),*(int),long)->(int)
(	O
doscp_t	struct
*	O
cp	*(struct)
,	O
const	O
char	O
*	O
dos	*(char)
,	O
wchar_t	int
*	O
wchar	*(int)
,	O
size_t	long
len	long
)	O
{	O
int	O
r	int
;	O
size_t	long
in_len	long
=	O
len	long
;	O
size_t	long
out_len	long
=	O
len	long
*	O
sizeof	O
(	O
wchar_t	int
)	O
;	O
wchar_t	int
*	O
dptr	*(int)
=	O
wchar	*(int)
;	O
char	O
*	O
dos2	*(char)
=	O
(	O
char	O
*	O
)	O
dos	*(char)
;	O
r	int
=	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
cp	*(struct)
->	O
from	*(void)
,	O
&	O
dos2	*(char)
,	O
&	O
in_len	long
,	O
(	O
char	O
*	O
*	O
)	O
&	O
dptr	*(int)
,	O
&	O
out_len	long
)	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
return	O
r	int
;	O
*	O
dptr	*(int)
=	O
L'\0'	O
;	O
return	O
dptr	*(int)
-	O
wchar	*(int)
;	O
}	O
static	O
int	O
safe_iconv	(*(void),*(int),*(char),long,long,*(int))->(int)
(	O
iconv_t	*(void)
conv	*(void)
,	O
const	O
wchar_t	int
*	O
wchar	*(int)
,	O
char	O
*	O
dest	short
,	O
size_t	long
in_len	long
,	O
size_t	long
out_len	long
,	O
int	O
*	O
mangled	*(int)
)	O
{	O
int	O
r	int
;	O
unsigned	O
int	O
i	long
;	O
char	O
*	O
dptr	*(int)
=	O
dest	short
;	O
size_t	long
len	long
;	O
in_len	long
=	O
in_len	long
*	O
sizeof	O
(	O
wchar_t	int
)	O
;	O
while	O
(	O
in_len	long
>	O
0	int
&&	O
out_len	long
>	O
0	int
)	O
{	O
r	int
=	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
conv	*(void)
,	O
(	O
char	O
*	O
*	O
)	O
&	O
wchar	*(int)
,	O
&	O
in_len	long
,	O
&	O
dptr	*(int)
,	O
&	O
out_len	long
)	O
;	O
if	O
(	O
r	int
>=	O
0	int
||	O
errno	O
!=	O
EILSEQ	int
)	O
{	O
break	O
;	O
}	O
*	O
mangled	*(int)
|=	O
1	int
;	O
if	O
(	O
out_len	long
<=	O
0	int
)	O
break	O
;	O
if	O
(	O
dptr	*(int)
)	O
*	O
dptr	*(int)
++	O
=	O
'_'	O
;	O
in_len	long
-=	O
sizeof	O
(	O
wchar_t	int
)	O
;	O
wchar	*(int)
++	O
;	O
out_len	long
--	O
;	O
}	O
len	long
=	O
dptr	*(int)
-	O
dest	short
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
len	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
dest	short
[	O
i	long
]	O
==	O
'?'	O
)	O
{	O
dest	short
[	O
i	long
]	O
=	O
'_'	O
;	O
*	O
mangled	*(int)
|=	O
1	int
;	O
}	O
}	O
return	O
len	long
;	O
}	O
void	O
wchar_to_dos	(*(struct),*(int),*(char),long,*(int))->(void)
(	O
doscp_t	struct
*	O
cp	*(struct)
,	O
wchar_t	int
*	O
wchar	*(int)
,	O
char	O
*	O
dos	*(char)
,	O
size_t	long
len	long
,	O
int	O
*	O
mangled	*(int)
)	O
{	O
safe_iconv	(*(void),*(int),*(char),long,long,*(int))->(int)
(	O
cp	*(struct)
->	O
to	*(void)
,	O
wchar	*(int)
,	O
dos	*(char)
,	O
len	long
,	O
len	long
,	O
mangled	*(int)
)	O
;	O
}	O
static	O
iconv_t	*(void)
to_native	*(void)
=	O
NULL	O
;	O
static	O
void	O
initialize_to_native	()->(void)
(	O
void	O
)	O
{	O
char	O
*	O
li	*(char)
,	O
*	O
cp	*(struct)
;	O
int	O
len	long
;	O
if	O
(	O
to_native	*(void)
!=	O
NULL	O
)	O
return	O
;	O
li	*(char)
=	O
nl_langinfo	(int)->(*(char))
(	O
CODESET	int
)	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
li	*(char)
)	O
+	O
11	int
;	O
if	O
(	O
getWcharCp	()->(*(char))
(	O
)	O
==	O
NULL	O
)	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
cp	*(struct)
=	O
safe_malloc	(long)->(*(void))
(	O
len	long
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
cp	*(struct)
,	O
li	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
cp	*(struct)
,	O
"//TRANSLIT"	*(char)
)	O
;	O
to_native	*(void)
=	O
iconv_open	(*(char),*(char))->(*(void))
(	O
cp	*(struct)
,	O
wcharCp	*(char)
)	O
;	O
if	O
(	O
to_native	*(void)
==	O
(	O
iconv_t	*(void)
)	O
-	O
1	int
)	O
to_native	*(void)
=	O
iconv_open	(*(char),*(char))->(*(void))
(	O
li	*(char)
,	O
wcharCp	*(char)
)	O
;	O
if	O
(	O
to_native	*(void)
==	O
(	O
iconv_t	*(void)
)	O
-	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Could not allocate iconv for %s\n"	*(char)
,	O
cp	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
cp	*(struct)
)	O
;	O
if	O
(	O
to_native	*(void)
==	O
(	O
iconv_t	*(void)
)	O
-	O
1	int
)	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
int	O
wchar_to_native	(*(int),*(char),long,long)->(int)
(	O
const	O
wchar_t	int
*	O
wchar	*(int)
,	O
char	O
*	O
native	*(char)
,	O
size_t	long
len	long
,	O
size_t	long
out_len	long
)	O
{	O
int	O
mangled	*(int)
;	O
int	O
r	int
;	O
initialize_to_native	()->(void)
(	O
)	O
;	O
len	long
=	O
wcsnlen	(*(int),long)->(long)
(	O
wchar	*(int)
,	O
len	long
)	O
;	O
r	int
=	O
safe_iconv	(*(void),*(int),*(char),long,long,*(int))->(int)
(	O
to_native	*(void)
,	O
wchar	*(int)
,	O
native	*(char)
,	O
len	long
,	O
out_len	long
,	O
&	O
mangled	*(int)
)	O
;	O
native	*(char)
[	O
r	int
]	O
=	O
'\0'	O
;	O
return	O
r	int
;	O
}	O
int	O
native_to_wchar	(*(char),*(int),long,*(char),*(int))->(int)
(	O
const	O
char	O
*	O
native	*(char)
,	O
wchar_t	int
*	O
wchar	*(int)
,	O
size_t	long
len	long
,	O
const	O
char	O
*	O
end	*(char)
,	O
int	O
*	O
mangled	*(int)
)	O
{	O
mbstate_t	struct(int,union(int,array(char)))
ps	struct(int,union(int,array(char)))
;	O
unsigned	O
int	O
i	long
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
ps	struct(int,union(int,array(char)))
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
len	long
&&	O
(	O
native	*(char)
<	O
end	*(char)
||	O
!	O
end	*(char)
)	O
;	O
i	long
++	O
)	O
{	O
int	O
r	int
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
wchar	*(int)
+	O
i	long
,	O
native	*(char)
,	O
len	long
,	O
&	O
ps	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
{	O
char	O
c	char
=	O
*	O
native	*(char)
;	O
if	O
(	O
c	char
>=	O
'\xa0'	O
&&	O
c	char
<	O
'\xff'	O
)	O
wchar	*(int)
[	O
i	long
]	O
=	O
c	char
&	O
0xff	int
;	O
else	O
wchar	*(int)
[	O
i	long
]	O
=	O
'_'	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
ps	struct(int,union(int,array(char)))
)	O
)	O
;	O
r	int
=	O
1	int
;	O
}	O
if	O
(	O
r	int
==	O
0	int
)	O
break	O
;	O
native	*(char)
+=	O
r	int
;	O
}	O
if	O
(	O
mangled	*(int)
&&	O
(	O
(	O
end	*(char)
&&	O
native	*(char)
<	O
end	*(char)
)	O
||	O
(	O
!	O
end	*(char)
&&	O
*	O
native	*(char)
&&	O
i	long
==	O
len	long
)	O
)	O
)	O
*	O
mangled	*(int)
|=	O
3	int
;	O
wchar	*(int)
[	O
i	long
]	O
=	O
'\0'	O
;	O
return	O
i	long
;	O
}	O
