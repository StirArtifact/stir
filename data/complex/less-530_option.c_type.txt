static	O
struct	O
loption	struct(char,*(struct(*(char),*(struct(*(char),*(struct`))))),int,int,*(int),*((int,*(char))->(void)),array(*(char)))
*	O
pendopt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
;	O
public	O
int	O
plusoption	int
=	O
FALSE	int
;	O
static	O
char	O
*	O
optstring	()->(*(char))
(	O
)	O
;	O
static	O
int	O
flip_triple	()->(int)
(	O
)	O
;	O
extern	O
int	O
screen_trashed	int
;	O
extern	O
int	O
less_is_more	int
;	O
extern	O
int	O
quit_at_eof	int
;	O
extern	O
char	O
*	O
every_first_cmd	*(char)
;	O
extern	O
int	O
opt_use_backslash	int
;	O
static	O
char	O
*	O
opt_desc	(*(struct(char,*(struct(*`,*`)),int,int,*(int),*((int,*`)->(void)),array(*(char)))))->(*(char))
(	O
o	*(struct)
)	O
struct	O
loption	struct(char,*(struct(*(char),*(struct(*(char),*(struct`))))),int,int,*(int),*((int,*(char))->(void)),array(*(char)))
*	O
o	*(struct)
;	O
{	O
static	O
char	O
buf	*(char)
[	O
OPTNAME_MAX	int
+	O
10	int
]	O
;	O
if	O
(	O
o	*(struct)
->	O
oletter	char
==	O
OLETTER_NONE	char
)	O
SNPRINTF1	O
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
"--%s"	*(char)
,	O
o	*(struct)
->	O
onames	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
oname	*(char)
)	O
;	O
else	O
SNPRINTF2	O
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
"-%c (--%s)"	*(char)
,	O
o	*(struct)
->	O
oletter	char
,	O
o	*(struct)
->	O
onames	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
oname	*(char)
)	O
;	O
return	O
(	O
buf	*(char)
)	O
;	O
}	O
public	O
char	O
*	O
propt	(int)->(*(char))
(	O
c	int
)	O
int	O
c	int
;	O
{	O
static	O
char	O
buf	*(char)
[	O
8	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"-%s"	*(char)
,	O
prchar	(long)->(*(char))
(	O
c	int
)	O
)	O
;	O
return	O
(	O
buf	*(char)
)	O
;	O
}	O
public	O
void	O
scan_option	(*(char))->(void)
(	O
s	*(char)
)	O
char	O
*	O
s	*(char)
;	O
{	O
struct	O
loption	struct(char,*(struct(*(char),*(struct(*(char),*(struct`))))),int,int,*(int),*((int,*(char))->(void)),array(*(char)))
*	O
o	*(struct)
;	O
int	O
optc	int
;	O
char	O
*	O
optname	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
;	O
char	O
*	O
printopt	*(char)
;	O
char	O
*	O
str	*(char)
;	O
int	O
set_default	int
;	O
int	O
lc	int
;	O
int	O
err	int
;	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
if	O
(	O
s	*(char)
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
pendopt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
!=	O
NULL	O
)	O
{	O
switch	O
(	O
pendopt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
->	O
otype	int
&	O
OTYPE	O
)	O
{	O
case	O
STRING	int
:	O
(	O
*	O
pendopt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
->	O
ofunc	*((int,*(char))->(void))
)	O
(	O
INIT	int
,	O
s	*(char)
)	O
;	O
break	O
;	O
case	O
NUMBER	int
:	O
printopt	*(char)
=	O
opt_desc	(*(struct(char,*(struct(*`,*`)),int,int,*(int),*((int,*`)->(void)),array(*(char)))))->(*(char))
(	O
pendopt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
)	O
;	O
*	O
(	O
pendopt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
->	O
ovar	*(int)
)	O
=	O
getnum	(*(*(char)),*(char),*(int))->(int)
(	O
&	O
s	*(char)
,	O
printopt	*(char)
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
}	O
pendopt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
=	O
NULL	O
;	O
return	O
;	O
}	O
set_default	int
=	O
FALSE	int
;	O
optname	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
=	O
NULL	O
;	O
while	O
(	O
*	O
s	*(char)
!=	O
'\0'	O
)	O
{	O
switch	O
(	O
optc	int
=	O
*	O
s	*(char)
++	O
)	O
{	O
case	O
' '	O
:	O
case	O
'\t'	O
:	O
case	O
END_OPTION_STRING	O
:	O
continue	O
;	O
case	O
'-'	O
:	O
if	O
(	O
*	O
s	*(char)
==	O
'-'	O
)	O
{	O
optname	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
=	O
++	O
s	*(char)
;	O
break	O
;	O
}	O
set_default	int
=	O
(	O
*	O
s	*(char)
==	O
'+'	O
)	O
;	O
if	O
(	O
set_default	int
)	O
s	*(char)
++	O
;	O
continue	O
;	O
case	O
'+'	O
:	O
plusoption	int
=	O
TRUE	int
;	O
s	*(char)
=	O
optstring	()->(*(char))
(	O
s	*(char)
,	O
&	O
str	*(char)
,	O
propt	(int)->(*(char))
(	O
'+'	O
)	O
,	O
NULL	O
)	O
;	O
if	O
(	O
s	*(char)
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
*	O
str	*(char)
==	O
'+'	O
)	O
every_first_cmd	*(char)
=	O
save	(*(char))->(*(char))
(	O
str	*(char)
+	O
1	int
)	O
;	O
else	O
{	O
ungetcc	(long)->(void)
(	O
CHAR_END_COMMAND	int
)	O
;	O
ungetsc	(*(char))->(void)
(	O
str	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
str	*(char)
)	O
;	O
continue	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
s	*(char)
--	O
;	O
optc	int
=	O
'z'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
if	O
(	O
less_is_more	int
)	O
optc	int
=	O
'z'	O
;	O
break	O
;	O
}	O
err	int
=	O
0	int
;	O
if	O
(	O
optname	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
==	O
NULL	O
)	O
{	O
printopt	*(char)
=	O
propt	(int)->(*(char))
(	O
optc	int
)	O
;	O
lc	int
=	O
ASCII_IS_LOWER	O
(	O
optc	int
)	O
;	O
o	*(struct)
=	O
findopt	(int)->(*(struct))
(	O
optc	int
)	O
;	O
}	O
else	O
{	O
printopt	*(char)
=	O
optname	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
;	O
lc	int
=	O
ASCII_IS_LOWER	O
(	O
optname	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
[	O
0	int
]	O
)	O
;	O
o	*(struct)
=	O
findopt_name	(*(*(char)),*(*(char)),*(int))->(*(struct))
(	O
&	O
optname	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
,	O
NULL	O
,	O
&	O
err	int
)	O
;	O
s	*(char)
=	O
optname	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
;	O
optname	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
=	O
NULL	O
;	O
if	O
(	O
*	O
s	*(char)
==	O
'\0'	O
||	O
*	O
s	*(char)
==	O
' '	O
)	O
{	O
;	O
}	O
else	O
if	O
(	O
*	O
s	*(char)
==	O
'='	O
)	O
{	O
if	O
(	O
o	*(struct)
!=	O
NULL	O
&&	O
(	O
o	*(struct)
->	O
otype	int
&	O
OTYPE	O
)	O
!=	O
STRING	int
&&	O
(	O
o	*(struct)
->	O
otype	int
&	O
OTYPE	O
)	O
!=	O
NUMBER	int
)	O
{	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
printopt	*(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"The %s option should not be followed by ="	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
return	O
;	O
}	O
s	*(char)
++	O
;	O
}	O
else	O
{	O
o	*(struct)
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
o	*(struct)
==	O
NULL	O
)	O
{	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
printopt	*(char)
;	O
if	O
(	O
err	int
==	O
OPT_AMBIG	int
)	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"%s is an ambiguous abbreviation (\"less --help\" for help)"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
else	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"There is no %s option (\"less --help\" for help)"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
return	O
;	O
}	O
str	*(char)
=	O
NULL	O
;	O
switch	O
(	O
o	*(struct)
->	O
otype	int
&	O
OTYPE	O
)	O
{	O
case	O
BOOL	int
:	O
if	O
(	O
set_default	int
)	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
=	O
o	*(struct)
->	O
odefault	int
;	O
else	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
=	O
!	O
o	*(struct)
->	O
odefault	int
;	O
break	O
;	O
case	O
TRIPLE	int
:	O
if	O
(	O
set_default	int
)	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
=	O
o	*(struct)
->	O
odefault	int
;	O
else	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
=	O
flip_triple	()->(int)
(	O
o	*(struct)
->	O
odefault	int
,	O
lc	int
)	O
;	O
break	O
;	O
case	O
STRING	int
:	O
if	O
(	O
*	O
s	*(char)
==	O
'\0'	O
)	O
{	O
pendopt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
=	O
o	*(struct)
;	O
return	O
;	O
}	O
while	O
(	O
*	O
s	*(char)
==	O
' '	O
)	O
s	*(char)
++	O
;	O
s	*(char)
=	O
optstring	()->(*(char))
(	O
s	*(char)
,	O
&	O
str	*(char)
,	O
printopt	*(char)
,	O
o	*(struct)
->	O
odesc	array(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
s	*(char)
==	O
NULL	O
)	O
return	O
;	O
break	O
;	O
case	O
NUMBER	int
:	O
if	O
(	O
*	O
s	*(char)
==	O
'\0'	O
)	O
{	O
pendopt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
=	O
o	*(struct)
;	O
return	O
;	O
}	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
=	O
getnum	(*(*(char)),*(char),*(int))->(int)
(	O
&	O
s	*(char)
,	O
printopt	*(char)
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
o	*(struct)
->	O
ofunc	*((int,*(char))->(void))
!=	O
NULL	O
)	O
(	O
*	O
o	*(struct)
->	O
ofunc	*((int,*(char))->(void))
)	O
(	O
INIT	int
,	O
str	*(char)
)	O
;	O
if	O
(	O
str	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
str	*(char)
)	O
;	O
}	O
}	O
public	O
void	O
toggle_option	(*(struct),int,*(char),int)->(void)
(	O
o	*(struct)
,	O
lower	int
,	O
s	*(char)
,	O
how_toggle	int
)	O
struct	O
loption	struct(char,*(struct(*(char),*(struct(*(char),*(struct`))))),int,int,*(int),*((int,*(char))->(void)),array(*(char)))
*	O
o	*(struct)
;	O
int	O
lower	int
;	O
char	O
*	O
s	*(char)
;	O
int	O
how_toggle	int
;	O
{	O
int	O
num	long
;	O
int	O
no_prompt	int
;	O
int	O
err	int
;	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
no_prompt	int
=	O
(	O
how_toggle	int
&	O
OPT_NO_PROMPT	int
)	O
;	O
how_toggle	int
&=	O
~	O
OPT_NO_PROMPT	int
;	O
if	O
(	O
o	*(struct)
==	O
NULL	O
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"No such option"	*(char)
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
how_toggle	int
==	O
OPT_TOGGLE	int
&&	O
(	O
o	*(struct)
->	O
otype	int
&	O
NO_TOGGLE	int
)	O
)	O
{	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
opt_desc	(*(struct(char,*(struct(*`,*`)),int,int,*(int),*((int,*`)->(void)),array(*(char)))))->(*(char))
(	O
o	*(struct)
)	O
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Cannot change the %s option"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
how_toggle	int
==	O
OPT_NO_TOGGLE	int
&&	O
(	O
o	*(struct)
->	O
otype	int
&	O
NO_QUERY	int
)	O
)	O
{	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
opt_desc	(*(struct(char,*(struct(*`,*`)),int,int,*(int),*((int,*`)->(void)),array(*(char)))))->(*(char))
(	O
o	*(struct)
)	O
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Cannot query the %s option"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
o	*(struct)
->	O
otype	int
&	O
OTYPE	O
)	O
{	O
case	O
STRING	int
:	O
case	O
NUMBER	int
:	O
if	O
(	O
how_toggle	int
==	O
OPT_TOGGLE	int
&&	O
*	O
s	*(char)
==	O
'\0'	O
)	O
how_toggle	int
=	O
OPT_NO_TOGGLE	int
;	O
break	O
;	O
}	O
if	O
(	O
how_toggle	int
!=	O
OPT_NO_TOGGLE	int
&&	O
(	O
o	*(struct)
->	O
otype	int
&	O
HL_REPAINT	int
)	O
)	O
repaint_hilite	(int)->(void)
(	O
0	int
)	O
;	O
if	O
(	O
how_toggle	int
!=	O
OPT_NO_TOGGLE	int
)	O
{	O
switch	O
(	O
o	*(struct)
->	O
otype	int
&	O
OTYPE	O
)	O
{	O
case	O
BOOL	int
:	O
switch	O
(	O
how_toggle	int
)	O
{	O
case	O
OPT_TOGGLE	int
:	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
=	O
!	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
;	O
break	O
;	O
case	O
OPT_UNSET	int
:	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
=	O
o	*(struct)
->	O
odefault	int
;	O
break	O
;	O
case	O
OPT_SET	int
:	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
=	O
!	O
o	*(struct)
->	O
odefault	int
;	O
break	O
;	O
}	O
break	O
;	O
case	O
TRIPLE	int
:	O
switch	O
(	O
how_toggle	int
)	O
{	O
case	O
OPT_TOGGLE	int
:	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
=	O
flip_triple	()->(int)
(	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
,	O
lower	int
)	O
;	O
break	O
;	O
case	O
OPT_UNSET	int
:	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
=	O
o	*(struct)
->	O
odefault	int
;	O
break	O
;	O
case	O
OPT_SET	int
:	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
=	O
flip_triple	()->(int)
(	O
o	*(struct)
->	O
odefault	int
,	O
lower	int
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
STRING	int
:	O
switch	O
(	O
how_toggle	int
)	O
{	O
case	O
OPT_SET	int
:	O
case	O
OPT_UNSET	int
:	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Cannot use \"-+\" or \"--\" for a string option"	*(char)
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
break	O
;	O
case	O
NUMBER	int
:	O
switch	O
(	O
how_toggle	int
)	O
{	O
case	O
OPT_TOGGLE	int
:	O
num	long
=	O
getnum	(*(*(char)),*(char),*(int))->(int)
(	O
&	O
s	*(char)
,	O
NULL	O
,	O
&	O
err	int
)	O
;	O
if	O
(	O
!	O
err	int
)	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
=	O
num	long
;	O
break	O
;	O
case	O
OPT_UNSET	int
:	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
=	O
o	*(struct)
->	O
odefault	int
;	O
break	O
;	O
case	O
OPT_SET	int
:	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Can't use \"-!\" for a numeric option"	*(char)
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
o	*(struct)
->	O
ofunc	*((int,*(char))->(void))
!=	O
NULL	O
)	O
(	O
*	O
o	*(struct)
->	O
ofunc	*((int,*(char))->(void))
)	O
(	O
(	O
how_toggle	int
==	O
OPT_NO_TOGGLE	int
)	O
?	O
QUERY	int
:	O
TOGGLE	int
,	O
s	*(char)
)	O
;	O
if	O
(	O
how_toggle	int
!=	O
OPT_NO_TOGGLE	int
&&	O
(	O
o	*(struct)
->	O
otype	int
&	O
HL_REPAINT	int
)	O
)	O
chg_hilite	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
no_prompt	int
)	O
{	O
switch	O
(	O
o	*(struct)
->	O
otype	int
&	O
OTYPE	O
)	O
{	O
case	O
BOOL	int
:	O
case	O
TRIPLE	int
:	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
o	*(struct)
->	O
odesc	array(*(char))
[	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
]	O
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
NUMBER	int
:	O
parg	union(*(char),int,long)
.	O
p_int	int
=	O
*	O
(	O
o	*(struct)
->	O
ovar	*(int)
)	O
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
o	*(struct)
->	O
odesc	array(*(char))
[	O
1	int
]	O
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
break	O
;	O
case	O
STRING	int
:	O
break	O
;	O
}	O
}	O
if	O
(	O
how_toggle	int
!=	O
OPT_NO_TOGGLE	int
&&	O
(	O
o	*(struct)
->	O
otype	int
&	O
REPAINT	int
)	O
)	O
screen_trashed	int
=	O
TRUE	int
;	O
}	O
static	O
int	O
flip_triple	()->(int)
(	O
val	int
,	O
lc	int
)	O
int	O
val	int
;	O
int	O
lc	int
;	O
{	O
if	O
(	O
lc	int
)	O
return	O
(	O
(	O
val	int
==	O
OPT_ON	int
)	O
?	O
OPT_OFF	int
:	O
OPT_ON	int
)	O
;	O
else	O
return	O
(	O
(	O
val	int
==	O
OPT_ONPLUS	int
)	O
?	O
OPT_OFF	int
:	O
OPT_ONPLUS	int
)	O
;	O
}	O
public	O
int	O
opt_has_param	(*(struct))->(int)
(	O
o	*(struct)
)	O
struct	O
loption	struct(char,*(struct(*(char),*(struct(*(char),*(struct`))))),int,int,*(int),*((int,*(char))->(void)),array(*(char)))
*	O
o	*(struct)
;	O
{	O
if	O
(	O
o	*(struct)
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
o	*(struct)
->	O
otype	int
&	O
(	O
BOOL	int
|	O
TRIPLE	int
|	O
NOVAR	int
|	O
NO_TOGGLE	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
public	O
char	O
*	O
opt_prompt	(*(struct))->(*(char))
(	O
o	*(struct)
)	O
struct	O
loption	struct(char,*(struct(*(char),*(struct(*(char),*(struct`))))),int,int,*(int),*((int,*(char))->(void)),array(*(char)))
*	O
o	*(struct)
;	O
{	O
if	O
(	O
o	*(struct)
==	O
NULL	O
||	O
(	O
o	*(struct)
->	O
otype	int
&	O
(	O
STRING	int
|	O
NUMBER	int
)	O
)	O
==	O
0	int
)	O
return	O
(	O
"?"	*(char)
)	O
;	O
return	O
(	O
o	*(struct)
->	O
odesc	array(*(char))
[	O
0	int
]	O
)	O
;	O
}	O
public	O
int	O
isoptpending	()->(int)
(	O
)	O
{	O
return	O
(	O
pendopt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
!=	O
NULL	O
)	O
;	O
}	O
static	O
void	O
nostring	(*(char))->(void)
(	O
printopt	*(char)
)	O
char	O
*	O
printopt	*(char)
;	O
{	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
printopt	*(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Value is required after %s"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
}	O
public	O
void	O
nopendopt	()->(void)
(	O
)	O
{	O
nostring	(*(char))->(void)
(	O
opt_desc	(*(struct(char,*(struct(*`,*`)),int,int,*(int),*((int,*`)->(void)),array(*(char)))))->(*(char))
(	O
pendopt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
)	O
)	O
;	O
}	O
static	O
char	O
*	O
optstring	()->(*(char))
(	O
s	*(char)
,	O
p_str	*(*(char))
,	O
printopt	*(char)
,	O
validchars	*(char)
)	O
char	O
*	O
s	*(char)
;	O
char	O
*	O
*	O
p_str	*(*(char))
;	O
char	O
*	O
printopt	*(char)
;	O
char	O
*	O
validchars	*(char)
;	O
{	O
char	O
*	O
p	*(char)
;	O
char	O
*	O
out	*(char)
;	O
if	O
(	O
*	O
s	*(char)
==	O
'\0'	O
)	O
{	O
nostring	(*(char))->(void)
(	O
printopt	*(char)
)	O
;	O
return	O
(	O
NULL	O
)	O
;	O
}	O
*	O
p_str	*(*(char))
=	O
(	O
char	O
*	O
)	O
ecalloc	(int,int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
+	O
1	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
out	*(char)
=	O
*	O
p_str	*(*(char))
;	O
for	O
(	O
p	*(char)
=	O
s	*(char)
;	O
*	O
p	*(char)
!=	O
'\0'	O
;	O
p	*(char)
++	O
)	O
{	O
if	O
(	O
opt_use_backslash	int
&&	O
*	O
p	*(char)
==	O
'\\'	O
&&	O
p	*(char)
[	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
++	O
p	*(char)
;	O
}	O
else	O
{	O
if	O
(	O
*	O
p	*(char)
==	O
END_OPTION_STRING	O
||	O
(	O
validchars	*(char)
!=	O
NULL	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
validchars	*(char)
,	O
*	O
p	*(char)
)	O
==	O
NULL	O
)	O
)	O
break	O
;	O
}	O
*	O
out	*(char)
++	O
=	O
*	O
p	*(char)
;	O
}	O
*	O
out	*(char)
=	O
'\0'	O
;	O
return	O
(	O
p	*(char)
)	O
;	O
}	O
static	O
int	O
num_error	(*(char),*(int))->(int)
(	O
printopt	*(char)
,	O
errp	*(int)
)	O
char	O
*	O
printopt	*(char)
;	O
int	O
*	O
errp	*(int)
;	O
{	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
if	O
(	O
errp	*(int)
!=	O
NULL	O
)	O
{	O
*	O
errp	*(int)
=	O
TRUE	int
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
printopt	*(char)
!=	O
NULL	O
)	O
{	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
printopt	*(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Number is required after %s"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
}	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
public	O
int	O
getnum	(*(*(char)),*(char),*(int))->(int)
(	O
sp	*(*(char))
,	O
printopt	*(char)
,	O
errp	*(int)
)	O
char	O
*	O
*	O
sp	*(*(char))
;	O
char	O
*	O
printopt	*(char)
;	O
int	O
*	O
errp	*(int)
;	O
{	O
char	O
*	O
s	*(char)
;	O
int	O
n	int
;	O
int	O
neg	int
;	O
s	*(char)
=	O
skipsp	(*(char))->(*(char))
(	O
*	O
sp	*(*(char))
)	O
;	O
neg	int
=	O
FALSE	int
;	O
if	O
(	O
*	O
s	*(char)
==	O
'-'	O
)	O
{	O
neg	int
=	O
TRUE	int
;	O
s	*(char)
++	O
;	O
}	O
if	O
(	O
*	O
s	*(char)
<	O
'0'	O
||	O
*	O
s	*(char)
>	O
'9'	O
)	O
return	O
(	O
num_error	(*(char),*(int))->(int)
(	O
printopt	*(char)
,	O
errp	*(int)
)	O
)	O
;	O
n	int
=	O
0	int
;	O
while	O
(	O
*	O
s	*(char)
>=	O
'0'	O
&&	O
*	O
s	*(char)
<=	O
'9'	O
)	O
n	int
=	O
10	int
*	O
n	int
+	O
*	O
s	*(char)
++	O
-	O
'0'	O
;	O
*	O
sp	*(*(char))
=	O
s	*(char)
;	O
if	O
(	O
errp	*(int)
!=	O
NULL	O
)	O
*	O
errp	*(int)
=	O
FALSE	int
;	O
if	O
(	O
neg	int
)	O
n	int
=	O
-	O
n	int
;	O
return	O
(	O
n	int
)	O
;	O
}	O
public	O
long	O
getfraction	(*(*(char)),*(char),*(int))->(long)
(	O
sp	*(*(char))
,	O
printopt	*(char)
,	O
errp	*(int)
)	O
char	O
*	O
*	O
sp	*(*(char))
;	O
char	O
*	O
printopt	*(char)
;	O
int	O
*	O
errp	*(int)
;	O
{	O
char	O
*	O
s	*(char)
;	O
long	O
frac	*(long)
=	O
0	int
;	O
int	O
fraclen	int
=	O
0	int
;	O
s	*(char)
=	O
skipsp	(*(char))->(*(char))
(	O
*	O
sp	*(*(char))
)	O
;	O
if	O
(	O
*	O
s	*(char)
<	O
'0'	O
||	O
*	O
s	*(char)
>	O
'9'	O
)	O
return	O
(	O
num_error	(*(char),*(int))->(int)
(	O
printopt	*(char)
,	O
errp	*(int)
)	O
)	O
;	O
for	O
(	O
;	O
*	O
s	*(char)
>=	O
'0'	O
&&	O
*	O
s	*(char)
<=	O
'9'	O
;	O
s	*(char)
++	O
)	O
{	O
frac	*(long)
=	O
(	O
frac	*(long)
*	O
10	int
)	O
+	O
(	O
*	O
s	*(char)
-	O
'0'	O
)	O
;	O
fraclen	int
++	O
;	O
}	O
if	O
(	O
fraclen	int
>	O
NUM_LOG_FRAC_DENOM	int
)	O
while	O
(	O
fraclen	int
--	O
>	O
NUM_LOG_FRAC_DENOM	int
)	O
frac	*(long)
/=	O
10	int
;	O
else	O
while	O
(	O
fraclen	int
++	O
<	O
NUM_LOG_FRAC_DENOM	int
)	O
frac	*(long)
*=	O
10	int
;	O
*	O
sp	*(*(char))
=	O
s	*(char)
;	O
if	O
(	O
errp	*(int)
!=	O
NULL	O
)	O
*	O
errp	*(int)
=	O
FALSE	int
;	O
return	O
(	O
frac	*(long)
)	O
;	O
}	O
public	O
int	O
get_quit_at_eof	()->(int)
(	O
)	O
{	O
if	O
(	O
!	O
less_is_more	int
)	O
return	O
quit_at_eof	int
;	O
return	O
quit_at_eof	int
?	O
OPT_ONPLUS	int
:	O
OPT_ON	int
;	O
}	O
