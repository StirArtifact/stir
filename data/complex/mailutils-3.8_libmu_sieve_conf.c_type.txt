mu_list_t	*(struct)
mu_sieve_include_path	*(struct)
=	O
NULL	O
;	O
mu_list_t	*(struct)
mu_sieve_library_path	*(struct)
=	O
NULL	O
;	O
mu_list_t	*(struct)
mu_sieve_library_path_prefix	*(struct)
=	O
NULL	O
;	O
mu_debug_handle_t	int
mu_sieve_debug_handle	int
;	O
void	O
mu_sieve_debug_init	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
!	O
mu_sieve_debug_handle	int
)	O
mu_sieve_debug_handle	int
=	O
mu_debug_register_category	(*(char))->(long)
(	O
"sieve"	*(char)
)	O
;	O
}	O
struct	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
{	O
int	O
clearflags	int
;	O
mu_list_t	*(struct)
include_path	*(struct)
;	O
mu_list_t	*(struct)
library_path_prefix	*(struct)
;	O
mu_list_t	*(struct)
library_path	*(struct)
;	O
}	O
;	O
static	O
struct	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
sieve_settings	struct(int,*(struct),*(struct),*(struct))
;	O
static	O
int	O
_path_append	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
mu_list_t	*(struct)
*	O
plist	*(*(struct))
=	O
data	*(void)
;	O
char	O
*	O
p	*(char)
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
*	O
plist	*(*(struct))
)	O
{	O
rc	int
=	O
mu_list_create	(*(*(struct)))->(int)
(	O
plist	*(*(struct))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create list: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
mu_list_set_destroy_item	(*(struct),*((*(void))->(void)))->(*((*(void))->(void)))
(	O
*	O
plist	*(*(struct))
,	O
mu_list_free_item	(*(void))->(void)
)	O
;	O
}	O
p	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
item	*(void)
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
rc	int
=	O
errno	O
;	O
else	O
rc	int
=	O
mu_list_append	(*(struct),*(void))->(int)
(	O
*	O
plist	*(*(struct))
,	O
p	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"can't add directory to path: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_clear_library_path	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	*(char)
)	O
{	O
int	O
flag	int
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	*(char)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
mu_str_to_c	(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*(*(char)))->(int)
(	O
val	*(char)
->	O
v	array(*(char))
.	O
string	*(*(char))
,	O
mu_c_bool	int
,	O
&	O
flag	int
,	O
NULL	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"not a boolean"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
flag	int
)	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
clearflags	int
|=	O
MU_SIEVE_CLEAR_LIBRARY_PATH	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_clear_include_path	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	*(char)
)	O
{	O
int	O
flag	int
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	*(char)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
mu_str_to_c	(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*(*(char)))->(int)
(	O
val	*(char)
->	O
v	array(*(char))
.	O
string	*(*(char))
,	O
mu_c_bool	int
,	O
&	O
flag	int
,	O
NULL	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"not a boolean"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
flag	int
)	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
clearflags	int
|=	O
MU_SIEVE_CLEAR_INCLUDE_PATH	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_add_path	(*(char),*(void))->(int)
(	O
const	O
char	O
*	O
arg	*(char)
,	O
void	O
*	O
data	*(void)
)	O
{	O
mu_list_t	*(struct)
*	O
plist	*(*(struct))
=	O
data	*(void)
;	O
if	O
(	O
!	O
*	O
plist	*(*(struct))
)	O
{	O
int	O
rc	int
=	O
mu_list_create	(*(*(struct)))->(int)
(	O
plist	*(*(struct))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create list: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
mu_list_set_destroy_item	(*(struct),*((*(void))->(void)))->(*((*(void))->(void)))
(	O
*	O
plist	*(*(struct))
,	O
mu_list_free_item	(*(void))->(void)
)	O
;	O
}	O
return	O
mu_string_split	(*(char),*(char),*(struct))->(int)
(	O
arg	*(char)
,	O
":"	*(char)
,	O
*	O
plist	*(*(struct))
)	O
;	O
}	O
static	O
int	O
cb_include_path	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	*(char)
)	O
{	O
return	O
mu_cfg_string_value_cb	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*((*(char),*(void))->(int)),*(void))->(int)
(	O
val	*(char)
,	O
_add_path	(*(char),*(void))->(int)
,	O
&	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
include_path	*(struct)
)	O
;	O
}	O
static	O
int	O
cb_library_path	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	*(char)
)	O
{	O
return	O
mu_cfg_string_value_cb	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*((*(char),*(void))->(int)),*(void))->(int)
(	O
val	*(char)
,	O
_add_path	(*(char),*(void))->(int)
,	O
&	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
library_path	*(struct)
)	O
;	O
}	O
static	O
int	O
cb_library_path_prefix	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	*(char)
)	O
{	O
return	O
mu_cfg_string_value_cb	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),*((*(char),*(void))->(int)),*(void))->(int)
(	O
val	*(char)
,	O
_add_path	(*(char),*(void))->(int)
,	O
&	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
library_path_prefix	*(struct)
)	O
;	O
}	O
static	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
mu_sieve_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"clear-library-path"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_clear_library_path	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Clear library search path."	*(char)
)	O
,	O
N_	O
(	O
"arg: directory list"	*(char)
)	O
}	O
,	O
{	O
"clear-include-path"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_clear_include_path	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Clear include search path."	*(char)
)	O
,	O
N_	O
(	O
"arg: directory list"	*(char)
)	O
}	O
,	O
{	O
"library-path"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_library_path	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Add directories to the library search path.  Argument is a "	*(char)
"colon-separated list of directories."	*(char)
)	O
,	O
N_	O
(	O
"arg: directory list"	*(char)
)	O
}	O
,	O
{	O
"library-path-prefix"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_library_path_prefix	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Add directories to the beginning of the library search path.  "	*(char)
"Argument is a colon-separated list of directories."	*(char)
)	O
,	O
N_	O
(	O
"arg: directory list"	*(char)
)	O
}	O
,	O
{	O
"include-path"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_include_path	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Add directories to the include search path.  Argument is a "	*(char)
"colon-separated list of directories."	*(char)
)	O
,	O
N_	O
(	O
"arg: directory list"	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
void	O
cli_includedir	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
_add_path	(*(char),*(void))->(int)
(	O
arg	*(char)
,	O
&	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
include_path	*(struct)
)	O
;	O
}	O
static	O
void	O
cli_libdir	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
_add_path	(*(char),*(void))->(int)
(	O
arg	*(char)
,	O
&	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
library_path	*(struct)
)	O
;	O
}	O
static	O
void	O
cli_libdir_prefix	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
_add_path	(*(char),*(void))->(int)
(	O
arg	*(char)
,	O
&	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
library_path_prefix	*(struct)
)	O
;	O
}	O
static	O
void	O
cli_clear_include_path	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
clearflags	int
|=	O
MU_SIEVE_CLEAR_INCLUDE_PATH	int
;	O
}	O
static	O
void	O
cli_clear_library_path	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
clearflags	int
|=	O
MU_SIEVE_CLEAR_LIBRARY_PATH	int
;	O
}	O
static	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
sieve_option	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
[	O
]	O
=	O
{	O
MU_OPTION_GROUP	O
(	O
N_	O
(	O
"Sieve options"	*(char)
)	O
)	O
,	O
{	O
"includedir"	*(char)
,	O
'I'	O
,	O
N_	O
(	O
"DIR"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"append DIR to the list of directories searched for include files"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_includedir	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"libdir"	*(char)
,	O
'L'	O
,	O
N_	O
(	O
"DIR"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"append DIR to the list of directories searched for library files"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_libdir	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"libdir-prefix"	*(char)
,	O
0	int
,	O
N_	O
(	O
"DIR"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"add DIR to the beginning of the list of directories searched for "	*(char)
"library files"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_libdir_prefix	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"clear-include-path"	*(char)
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"clear Sieve include path"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_clear_include_path	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"clear-library-path"	*(char)
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"clear Sieve library path"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_clear_library_path	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"clearpath"	*(char)
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_ALIAS	int
}	O
,	O
MU_OPTION_END	O
}	O
;	O
static	O
void	O
sieve_commit	(*(void))->(void)
(	O
void	O
*	O
ptr	*(*(void))
)	O
{	O
if	O
(	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
clearflags	int
&	O
MU_SIEVE_CLEAR_INCLUDE_PATH	int
)	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
mu_sieve_include_path	*(struct)
)	O
;	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
include_path	*(struct)
,	O
_path_append	(*(void),*(void))->(int)
,	O
&	O
mu_sieve_include_path	*(struct)
)	O
;	O
if	O
(	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
clearflags	int
&	O
MU_SIEVE_CLEAR_LIBRARY_PATH	int
)	O
{	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
mu_sieve_library_path	*(struct)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
mu_sieve_library_path_prefix	*(struct)
)	O
;	O
}	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
library_path_prefix	*(struct)
,	O
_path_append	(*(void),*(void))->(int)
,	O
&	O
mu_sieve_library_path_prefix	*(struct)
)	O
;	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
library_path	*(struct)
,	O
_path_append	(*(void),*(void))->(int)
,	O
&	O
mu_sieve_library_path	*(struct)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
library_path	*(struct)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
library_path_prefix	*(struct)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
sieve_settings	struct(int,*(struct),*(struct),*(struct))
.	O
include_path	*(struct)
)	O
;	O
mu_sieve_debug_init	()->(void)
(	O
)	O
;	O
}	O
struct	O
mu_cli_capa	struct(*(char),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int)),*((*(void))->(void)))
mu_cli_capa_sieve	struct(*(char),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*((*(void))->(void)))
=	O
{	O
"sieve"	*(char)
,	O
sieve_option	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
,	O
mu_sieve_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
,	O
NULL	O
,	O
sieve_commit	(*(void))->(void)
}	O
;	O
