WInput	struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,*(*(char)),int,*(char))
*	O
cmdline	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct`),*(struct`))),int,*(*(char)),int,*(char)))
;	O
static	O
int	O
examine_cd	(*(char))->(int)
(	O
char	O
*	O
path	*(char)
)	O
{	O
int	O
result	long
,	O
qlen	int
;	O
char	O
*	O
path_tilde	*(char)
;	O
char	O
*	O
p	*(void)
,	O
*	O
q	*(char)
,	O
*	O
r	*(struct)
,	O
*	O
s	*(char)
,	O
c	int
;	O
const	O
char	O
*	O
t	long
;	O
path_tilde	*(char)
=	O
tilde_expand	(*(char))->(*(char))
(	O
path	*(char)
)	O
;	O
qlen	int
=	O
strlen	(*(char))->(long)
(	O
path_tilde	*(char)
)	O
+	O
MC_MAXPATHLEN	O
;	O
q	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
qlen	int
)	O
;	O
for	O
(	O
p	*(void)
=	O
path_tilde	*(char)
,	O
r	*(struct)
=	O
q	*(char)
;	O
*	O
p	*(void)
&&	O
r	*(struct)
<	O
q	*(char)
+	O
MC_MAXPATHLEN	O
;	O
)	O
{	O
if	O
(	O
*	O
p	*(void)
!=	O
'$'	O
||	O
(	O
p	*(void)
[	O
1	int
]	O
==	O
'['	O
||	O
p	*(void)
[	O
1	int
]	O
==	O
'('	O
)	O
)	O
*	O
(	O
r	*(struct)
++	O
)	O
=	O
*	O
(	O
p	*(void)
++	O
)	O
;	O
else	O
{	O
p	*(void)
++	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'{'	O
)	O
{	O
p	*(void)
++	O
;	O
s	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
'}'	O
)	O
;	O
}	O
else	O
s	*(char)
=	O
NULL	O
;	O
if	O
(	O
s	*(char)
==	O
NULL	O
)	O
s	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
PATH_SEP	char
)	O
;	O
if	O
(	O
s	*(char)
==	O
NULL	O
)	O
s	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
0	int
)	O
;	O
c	int
=	O
*	O
s	*(char)
;	O
*	O
s	*(char)
=	O
0	int
;	O
t	long
=	O
getenv	(*(char))->(*(char))
(	O
p	*(void)
)	O
;	O
*	O
s	*(char)
=	O
c	int
;	O
if	O
(	O
t	long
==	O
NULL	O
)	O
{	O
*	O
(	O
r	*(struct)
++	O
)	O
=	O
'$'	O
;	O
if	O
(	O
*	O
(	O
p	*(void)
-	O
1	int
)	O
!=	O
'$'	O
)	O
*	O
(	O
r	*(struct)
++	O
)	O
=	O
'{'	O
;	O
}	O
else	O
{	O
if	O
(	O
r	*(struct)
+	O
strlen	(*(char))->(long)
(	O
t	long
)	O
<	O
q	*(char)
+	O
MC_MAXPATHLEN	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
r	*(struct)
,	O
t	long
)	O
;	O
r	*(struct)
=	O
strchr	(*(char),int)->(*(char))
(	O
r	*(struct)
,	O
0	int
)	O
;	O
}	O
if	O
(	O
*	O
s	*(char)
==	O
'}'	O
)	O
p	*(void)
=	O
s	*(char)
+	O
1	int
;	O
else	O
p	*(void)
=	O
s	*(char)
;	O
}	O
}	O
}	O
*	O
r	*(struct)
=	O
0	int
;	O
result	long
=	O
do_cd	(*(char),enum(int,int))->(int)
(	O
q	*(char)
,	O
cd_parse_command	int
)	O
;	O
if	O
(	O
*	O
q	*(char)
!=	O
PATH_SEP	char
&&	O
!	O
result	long
)	O
{	O
char	O
*	O
const	O
cdpath	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
getenv	(*(char))->(*(char))
(	O
"CDPATH"	*(char)
)	O
)	O
;	O
char	O
*	O
p	*(void)
=	O
cdpath	*(char)
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
c	int
=	O
0	int
;	O
else	O
c	int
=	O
':'	O
;	O
while	O
(	O
!	O
result	long
&&	O
c	int
==	O
':'	O
)	O
{	O
s	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
':'	O
)	O
;	O
if	O
(	O
s	*(char)
==	O
NULL	O
)	O
s	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
0	int
)	O
;	O
c	int
=	O
*	O
s	*(char)
;	O
*	O
s	*(char)
=	O
0	int
;	O
if	O
(	O
*	O
p	*(void)
)	O
{	O
r	*(struct)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
q	*(char)
)	O
;	O
result	long
=	O
do_cd	(*(char),enum(int,int))->(int)
(	O
r	*(struct)
,	O
cd_parse_command	int
)	O
;	O
g_free	(*(void))->(void)
(	O
r	*(struct)
)	O
;	O
}	O
*	O
s	*(char)
=	O
c	int
;	O
p	*(void)
=	O
s	*(char)
+	O
1	int
;	O
}	O
g_free	(*(void))->(void)
(	O
cdpath	*(char)
)	O
;	O
}	O
g_free	(*(void))->(void)
(	O
q	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
path_tilde	*(char)
)	O
;	O
return	O
result	long
;	O
}	O
void	O
do_cd_command	(*(char))->(void)
(	O
char	O
*	O
cmd	*(char)
)	O
{	O
int	O
len	int
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
cmd	*(char)
)	O
-	O
1	int
;	O
while	O
(	O
len	int
>=	O
0	int
&&	O
(	O
cmd	*(char)
[	O
len	int
]	O
==	O
' '	O
||	O
cmd	*(char)
[	O
len	int
]	O
==	O
'\t'	O
||	O
cmd	*(char)
[	O
len	int
]	O
==	O
'\n'	O
)	O
)	O
{	O
cmd	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
len	int
--	O
;	O
}	O
if	O
(	O
cmd	*(char)
[	O
2	int
]	O
==	O
0	int
)	O
cmd	*(char)
=	O
"cd "	*(char)
;	O
if	O
(	O
get_current_type	()->(int)
(	O
)	O
==	O
view_tree	int
)	O
{	O
if	O
(	O
cmd	*(char)
[	O
0	int
]	O
==	O
0	int
)	O
{	O
sync_tree	(*(char))->(void)
(	O
home_dir	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
+	O
3	int
,	O
".."	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
dir	*(struct)
=	O
current_panel	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),struct(*(struct(int,*`,struct`,struct`)),int),int,int,array(char),array(char),*(struct(*(void),*(struct`),*(struct`))),*(char),int,int,int,double,int,int,int,int,int,int,int,*((*(void),*(void))->(int)),*(char),int,int,*(char),array(*(char)),*(struct),*(struct),int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,array(char)))
->	O
cwd	short
;	O
int	O
len	int
=	O
strlen	(*(char))->(long)
(	O
dir	*(struct)
)	O
;	O
while	O
(	O
len	int
&&	O
dir	*(struct)
[	O
--	O
len	int
]	O
!=	O
PATH_SEP	char
)	O
;	O
dir	*(struct)
[	O
len	int
]	O
=	O
0	int
;	O
if	O
(	O
len	int
)	O
sync_tree	(*(char))->(void)
(	O
dir	*(struct)
)	O
;	O
else	O
sync_tree	(*(char))->(void)
(	O
PATH_SEP_STR	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
cmd	*(char)
[	O
3	int
]	O
==	O
PATH_SEP	char
)	O
{	O
sync_tree	(*(char))->(void)
(	O
cmd	*(char)
+	O
3	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
current_panel	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),struct(*(struct(int,*`,struct`,struct`)),int),int,int,array(char),array(char),*(struct(*(void),*(struct`),*(struct`))),*(char),int,int,int,double,int,int,int,int,int,int,int,*((*(void),*(void))->(int)),*(char),int,int,*(char),array(*(char)),*(struct),*(struct),int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,array(char)))
->	O
cwd	short
;	O
char	O
*	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
,	O
cmd	*(char)
+	O
3	int
)	O
;	O
sync_tree	(*(char))->(void)
(	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
;	O
g_free	(*(void))->(void)
(	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
examine_cd	(*(char))->(int)
(	O
&	O
cmd	*(char)
[	O
3	int
]	O
)	O
)	O
{	O
char	O
*	O
d	double
=	O
strip_password	(*(char),int)->(*(char))
(	O
g_strdup	(*(char))->(*(char))
(	O
&	O
cmd	*(char)
[	O
3	int
]	O
)	O
,	O
1	int
)	O
;	O
message	*(char)
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot chdir to \"%s\" \n %s "	*(char)
)	O
,	O
d	double
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
g_free	(*(void))->(void)
(	O
d	double
)	O
;	O
return	O
;	O
}	O
}	O
static	O
cb_ret_t	enum(int,int)
enter	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))))->(enum(int,int))
(	O
WInput	struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,*(*(char)),int,*(char))
*	O
cmdline	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct`),*(struct`))),int,*(*(char)),int,*(char)))
)	O
{	O
char	O
*	O
cmd	*(char)
=	O
cmdline	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct`),*(struct`))),int,*(*(char)),int,*(char)))
->	O
buffer	*(char)
;	O
if	O
(	O
!	O
command_prompt	int
)	O
return	O
MSG_HANDLED	int
;	O
while	O
(	O
*	O
cmd	*(char)
==	O
' '	O
||	O
*	O
cmd	*(char)
==	O
'\t'	O
||	O
*	O
cmd	*(char)
==	O
'\n'	O
)	O
cmd	*(char)
++	O
;	O
if	O
(	O
!	O
*	O
cmd	*(char)
)	O
return	O
MSG_HANDLED	int
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
cmd	*(char)
,	O
"cd "	*(char)
,	O
3	int
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"cd"	*(char)
)	O
==	O
0	int
)	O
{	O
do_cd_command	(*(char))->(void)
(	O
cmd	*(char)
)	O
;	O
new_input	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))))->(void)
(	O
cmdline	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct`),*(struct`))),int,*(*(char)),int,*(char)))
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
else	O
{	O
char	O
*	O
command	*(char)
,	O
*	O
s	*(char)
;	O
size_t	long
i	array(int)
,	O
j	long
,	O
cmd_len	long
;	O
if	O
(	O
!	O
vfs_current_is_local	()->(int)
(	O
)	O
)	O
{	O
message	*(char)
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot execute commands on non-local filesystems"	*(char)
)	O
)	O
;	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
if	O
(	O
use_subshell	int
&&	O
subshell_state	enum(int,int,int)
!=	O
INACTIVE	int
)	O
{	O
message	*(char)
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" The shell is already running a command "	*(char)
)	O
)	O
;	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
cmd_len	long
=	O
strlen	(*(char))->(long)
(	O
cmd	*(char)
)	O
;	O
command	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
cmd_len	long
+	O
1	int
)	O
;	O
command	*(char)
[	O
0	int
]	O
=	O
0	int
;	O
for	O
(	O
i	array(int)
=	O
j	long
=	O
0	int
;	O
i	array(int)
<	O
cmd_len	long
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
cmd	*(char)
[	O
i	array(int)
]	O
==	O
'%'	O
)	O
{	O
i	array(int)
++	O
;	O
s	*(char)
=	O
expand_format	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),char,int)->(*(char))
(	O
NULL	O
,	O
cmd	*(char)
[	O
i	array(int)
]	O
,	O
1	int
)	O
;	O
command	*(char)
=	O
g_realloc	(*(void),long)->(*(void))
(	O
command	*(char)
,	O
j	long
+	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
+	O
cmd_len	long
-	O
i	array(int)
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
command	*(char)
+	O
j	long
,	O
s	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
j	long
=	O
strlen	(*(char))->(long)
(	O
command	*(char)
)	O
;	O
}	O
else	O
{	O
command	*(char)
[	O
j	long
]	O
=	O
cmd	*(char)
[	O
i	array(int)
]	O
;	O
j	long
++	O
;	O
}	O
command	*(char)
[	O
j	long
]	O
=	O
0	int
;	O
}	O
new_input	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))))->(void)
(	O
cmdline	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct`),*(struct`))),int,*(*(char)),int,*(char)))
)	O
;	O
shell_execute	(*(char),int)->(void)
(	O
command	*(char)
,	O
0	int
)	O
;	O
g_free	(*(void))->(void)
(	O
command	*(char)
)	O
;	O
if	O
(	O
quit	int
&	O
SUBSHELL_EXIT	int
)	O
{	O
quiet_quit_cmd	()->(void)
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
use_subshell	int
)	O
load_prompt	(int,*(void))->(int)
(	O
0	int
,	O
0	int
)	O
;	O
}	O
return	O
MSG_HANDLED	int
;	O
}	O
static	O
cb_ret_t	enum(int,int)
command_callback	(*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))
(	O
Widget	struct
*	O
w	*(int)
,	O
widget_msg_t	enum(int,int,int,int,int,int,int,int,int,int)
msg	*(char)
,	O
int	O
parm	int
)	O
{	O
WInput	struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,*(*(char)),int,*(char))
*	O
cmd	*(char)
=	O
(	O
WInput	struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,*(*(char)),int,*(char))
*	O
)	O
w	*(int)
;	O
switch	O
(	O
msg	*(char)
)	O
{	O
case	O
WIDGET_FOCUS	int
:	O
return	O
MSG_NOT_HANDLED	int
;	O
case	O
WIDGET_KEY	int
:	O
if	O
(	O
parm	int
==	O
'\n'	O
)	O
{	O
return	O
enter	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))))->(enum(int,int))
(	O
cmd	*(char)
)	O
;	O
}	O
default	O
:	O
return	O
input_callback	(*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))
(	O
w	*(int)
,	O
msg	*(char)
,	O
parm	int
)	O
;	O
}	O
}	O
WInput	struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,*(*(char)),int,*(char))
*	O
command_new	(int,int,int)->(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))))
(	O
int	O
y	short
,	O
int	O
x	array(long)
,	O
int	O
cols	int
)	O
{	O
WInput	struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,*(*(char)),int,*(char))
*	O
cmd	*(char)
;	O
cmd	*(char)
=	O
input_new	(int,int,int,int,*(char),*(char))->(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))))
(	O
y	short
,	O
x	array(long)
,	O
DEFAULT_COLOR	O
,	O
cols	int
,	O
""	*(char)
,	O
"cmdline"	*(char)
)	O
;	O
cmd	*(char)
->	O
widget	*(struct)
.	O
callback	*((*(void))->(int))
=	O
command_callback	(*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))
;	O
cmd	*(char)
->	O
completion_flags	int
|=	O
INPUT_COMPLETE_COMMANDS	int
;	O
return	O
cmd	*(char)
;	O
}	O
void	O
command_insert	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))),*(char),int)->(void)
(	O
WInput	struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,*(*(char)),int,*(char))
*	O
in	*(char)
,	O
const	O
char	O
*	O
text	*(char)
,	O
int	O
insert_extra_space	int
)	O
{	O
char	O
*	O
quoted_text	*(char)
;	O
quoted_text	*(char)
=	O
name_quote	(*(char),int)->(*(char))
(	O
text	*(char)
,	O
1	int
)	O
;	O
stuff	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))),*(char),int)->(void)
(	O
in	*(char)
,	O
quoted_text	*(char)
,	O
insert_extra_space	int
)	O
;	O
g_free	(*(void))->(void)
(	O
quoted_text	*(char)
)	O
;	O
}	O
