extern	O
char	O
*	O
version_string	*(char)
;	O
static	O
FILE	struct
*	O
input_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
static	O
char	O
*	O
linebuf	*(char)
;	O
static	O
int	O
keep_stdin	int
=	O
0	int
;	O
static	O
size_t	long
lineno	long
=	O
0	int
;	O
static	O
struct	O
buildcmd_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
;	O
static	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
;	O
static	O
int	O
nullwarning_given	int
=	O
0	int
;	O
static	O
char	O
*	O
eof_str	*(char)
=	O
NULL	O
;	O
static	O
bool	bool
initial_args	int
=	O
true	int
;	O
static	O
volatile	O
sig_atomic_t	int
proc_max	int
=	O
1	int
;	O
static	O
bool	bool
procs_executed	bool
=	O
false	int
;	O
static	O
unsigned	O
long	O
int	O
procs_executing	long
=	O
0uL	int
;	O
static	O
pid_t	int
*	O
pids	*(int)
=	O
NULL	O
;	O
static	O
size_t	long
pids_alloc	long
=	O
0u	int
;	O
static	O
pid_t	int
parent	int
;	O
static	O
volatile	O
sig_atomic_t	int
stop_waiting	int
=	O
0	int
;	O
static	O
volatile	O
int	O
child_error	int
=	O
EXIT_SUCCESS	int
;	O
static	O
volatile	O
int	O
original_exit_value	int
;	O
static	O
bool	bool
print_command	bool
=	O
false	int
;	O
static	O
bool	bool
query_before_executing	bool
=	O
false	int
;	O
static	O
char	O
input_delimiter	char
=	O
'\0'	O
;	O
static	O
char	O
*	O
slot_var_name	*(char)
=	O
NULL	O
;	O
enum	O
LongOptionIdentifier	enum(int)
{	O
PROCESS_SLOT_VAR	int
=	O
CHAR_MAX	O
+	O
1	int
}	O
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
const	O
longopts	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"null"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'0'	O
}	O
,	O
{	O
"arg-file"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'a'	O
}	O
,	O
{	O
"delimiter"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"eof"	*(char)
,	O
optional_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"replace"	*(char)
,	O
optional_argument	int
,	O
NULL	O
,	O
'I'	O
}	O
,	O
{	O
"max-lines"	*(char)
,	O
optional_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"max-args"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
{	O
"interactive"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'p'	O
}	O
,	O
{	O
"no-run-if-empty"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"max-chars"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"verbose"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
't'	O
}	O
,	O
{	O
"show-limits"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'S'	O
}	O
,	O
{	O
"exit"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'x'	O
}	O
,	O
{	O
"max-procs"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'P'	O
}	O
,	O
{	O
"process-slot-var"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
PROCESS_SLOT_VAR	int
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
NULL	O
,	O
no_argument	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
enum	O
XargsStatusValues	enum(int,int,int,int,int)
{	O
XARGS_EXIT_CLIENT_EXIT_NONZERO	int
=	O
123	int
,	O
XARGS_EXIT_CLIENT_EXIT_255	int
=	O
124	int
,	O
XARGS_EXIT_CLIENT_FATAL_SIG	int
=	O
125	int
,	O
XARGS_EXIT_COMMAND_CANNOT_BE_RUN	int
=	O
126	int
,	O
XARGS_EXIT_COMMAND_NOT_FOUND	int
=	O
127	int
,	O
}	O
;	O
enum	O
ClientStatusValues	enum(int)
{	O
CHILD_EXIT_PLEASE_STOP_IMMEDIATELY	int
=	O
255	int
}	O
;	O
static	O
int	O
read_line	()->(int)
(	O
void	O
)	O
;	O
static	O
int	O
read_string	()->(int)
(	O
void	O
)	O
;	O
static	O
bool	bool
print_args	(bool)->(bool)
(	O
bool	bool
ask	bool
)	O
;	O
static	O
int	O
xargs_do_exec	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)
(	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
*	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
void	O
*	O
usercontext	*(void)
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
;	O
static	O
void	O
exec_if_possible	()->(void)
(	O
void	O
)	O
;	O
static	O
unsigned	O
int	O
add_proc	(int)->(int)
(	O
pid_t	int
pid	int
)	O
;	O
static	O
void	O
wait_for_proc	(bool,int)->(void)
(	O
bool	bool
all	bool
,	O
unsigned	O
int	O
minreap	int
)	O
;	O
static	O
void	O
wait_for_proc_all	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
increment_proc_max	(int)->(void)
(	O
int	O
)	O
;	O
static	O
void	O
decrement_proc_max	(int)->(void)
(	O
int	O
)	O
;	O
static	O
long	O
parse_num	(*(char),int,long,long,int)->(long)
(	O
char	O
*	O
str	*(char)
,	O
int	O
option	struct(*(char),int,*(int),int)
,	O
long	O
min	long
,	O
long	O
max	long
,	O
int	O
fatal	int
)	O
;	O
static	O
void	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
static	O
char	O
get_char_oct_or_hex_escape	(*(char))->(char)
(	O
const	O
char	O
*	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
int	O
base	int
=	O
8	int
;	O
unsigned	O
long	O
val	int
;	O
char	O
*	O
endp	*(char)
;	O
assert	O
(	O
'\\'	O
==	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
[	O
0	int
]	O
)	O
;	O
if	O
(	O
'x'	O
==	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
[	O
1	int
]	O
)	O
{	O
p	*(void)
=	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
+	O
2	int
;	O
base	int
=	O
16	int
;	O
}	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
[	O
1	int
]	O
)	O
)	O
{	O
p	*(void)
=	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
+	O
1	int
;	O
base	int
=	O
8	int
;	O
}	O
else	O
{	O
p	*(void)
=	O
NULL	O
;	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Invalid escape sequence %s in input delimiter specification."	*(char)
)	O
,	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
}	O
errno	O
=	O
0	int
;	O
endp	*(char)
=	O
NULL	O
;	O
val	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
p	*(void)
,	O
&	O
endp	*(char)
,	O
base	int
)	O
;	O
if	O
(	O
(	O
ULONG_MAX	O
==	O
val	int
&&	O
ERANGE	int
==	O
errno	O
)	O
||	O
(	O
val	int
>	O
UCHAR_MAX	O
)	O
)	O
{	O
if	O
(	O
16	int
==	O
base	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Invalid escape sequence %s in input delimiter specification; character values must not exceed %lx."	*(char)
)	O
,	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
,	O
(	O
unsigned	O
long	O
)	O
UCHAR_MAX	O
)	O
;	O
}	O
else	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Invalid escape sequence %s in input delimiter specification; character values must not exceed %lo."	*(char)
)	O
,	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
,	O
(	O
unsigned	O
long	O
)	O
UCHAR_MAX	O
)	O
;	O
}	O
}	O
if	O
(	O
0	int
!=	O
*	O
endp	*(char)
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Invalid escape sequence %s in input delimiter specification; trailing characters %s not recognised."	*(char)
)	O
,	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
,	O
endp	*(char)
)	O
;	O
}	O
return	O
(	O
char	O
)	O
val	int
;	O
}	O
static	O
char	O
get_input_delimiter	(*(char))->(char)
(	O
const	O
char	O
*	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
if	O
(	O
1	int
==	O
strlen	(*(char))->(long)
(	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
)	O
)	O
{	O
return	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
[	O
0	int
]	O
;	O
}	O
else	O
{	O
if	O
(	O
'\\'	O
==	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
[	O
0	int
]	O
)	O
{	O
switch	O
(	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
[	O
1	int
]	O
)	O
{	O
case	O
'a'	O
:	O
return	O
'\a'	O
;	O
case	O
'b'	O
:	O
return	O
'\b'	O
;	O
case	O
'f'	O
:	O
return	O
'\f'	O
;	O
case	O
'n'	O
:	O
return	O
'\n'	O
;	O
case	O
'r'	O
:	O
return	O
'\r'	O
;	O
case	O
't'	O
:	O
return	O
'\t'	O
;	O
case	O
'v'	O
:	O
return	O
'\v'	O
;	O
case	O
'\\'	O
:	O
return	O
'\\'	O
;	O
default	O
:	O
return	O
get_char_oct_or_hex_escape	(*(char))->(char)
(	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
}	O
}	O
else	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Invalid input delimiter specification %s: the delimiter must be either a single character or an escape sequence starting with \\."	*(char)
)	O
,	O
s	enum(int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
static	O
void	O
noop	()->(void)
(	O
void	O
)	O
{	O
}	O
static	O
void	O
fail_due_to_env_size	()->(void)
(	O
void	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"environment is too large for exec"	*(char)
)	O
)	O
;	O
}	O
static	O
size_t	long
smaller_of	(long,long)->(long)
(	O
size_t	long
a	long
,	O
size_t	long
b	long
)	O
{	O
if	O
(	O
a	long
<	O
b	long
)	O
return	O
a	long
;	O
else	O
return	O
b	long
;	O
}	O
static	O
FILE	struct
*	O
fopen_cloexec_for_read_only	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
const	O
char	O
*	O
file_name	*(char)
)	O
{	O
int	O
fd	int
=	O
open_cloexec	(*(char),int)->(int)
(	O
file_name	*(char)
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
return	O
NULL	O
;	O
}	O
else	O
{	O
FILE	struct
*	O
result	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fd	int
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
result	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
NULL	O
;	O
}	O
return	O
result	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
optc	int
,	O
option_index	int
;	O
int	O
show_limits	int
=	O
0	int
;	O
int	O
always_run_command	int
=	O
1	int
;	O
const	O
char	O
*	O
input_file	*(char)
=	O
"-"	*(char)
;	O
char	O
default_cmd	array(char)
[	O
]	O
=	O
"echo"	*(char)
;	O
char	O
*	O
default_arglist	array(*(char))
[	O
1	int
]	O
;	O
int	O
(	O
*	O
read_args	*(()->(int))
)	O
(	O
void	O
)	O
=	O
read_line	()->(int)
;	O
void	O
(	O
*	O
act_on_init_result	*(()->(void))
)	O
(	O
void	O
)	O
=	O
noop	()->(void)
;	O
enum	O
BC_INIT_STATUS	enum(int,int,int)
bcstatus	enum(int,int,int)
;	O
enum	O
{	O
XARGS_POSIX_HEADROOM	int
=	O
2048u	int
}	O
;	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
sigact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
if	O
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
else	O
set_program_name	(*(char))->(void)
(	O
"xargs"	*(char)
)	O
;	O
remember_non_cloexec_fds	()->(void)
(	O
)	O
;	O
parent	int
=	O
getpid	()->(int)
(	O
)	O
;	O
original_exit_value	int
=	O
EXIT_SUCCESS	int
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
if	O
(	O
atexit	(*(()->(void)))->(int)
(	O
close_stdin	()->(void)
)	O
||	O
atexit	(*(()->(void)))->(int)
(	O
wait_for_proc_all	()->(void)
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"The atexit library function failed"	*(char)
)	O
)	O
;	O
}	O
bcstatus	enum(int,int,int)
=	O
bc_init_controlinfo	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),long)->(enum(int,int,int))
(	O
&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
,	O
XARGS_POSIX_HEADROOM	int
)	O
;	O
if	O
(	O
BC_INIT_ENV_TOO_BIG	int
==	O
bcstatus	enum(int,int,int)
)	O
{	O
act_on_init_result	*(()->(void))
=	O
fail_due_to_env_size	()->(void)
;	O
}	O
else	O
if	O
(	O
BC_INIT_CANNOT_ACCOMODATE_HEADROOM	int
==	O
bcstatus	enum(int,int,int)
)	O
{	O
act_on_init_result	*(()->(void))
=	O
fail_due_to_env_size	()->(void)
;	O
}	O
else	O
{	O
long	O
val	int
;	O
val	int
=	O
sysconf	(int)->(long)
(	O
_SC_ARG_MAX	int
)	O
;	O
if	O
(	O
val	int
>	O
0	int
)	O
{	O
assert	O
(	O
val	int
>	O
XARGS_POSIX_HEADROOM	int
)	O
;	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
arg_max	long
=	O
smaller_of	(long,long)->(long)
(	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
arg_max	long
,	O
(	O
size_t	long
)	O
val	int
-	O
XARGS_POSIX_HEADROOM	int
)	O
;	O
}	O
else	O
{	O
}	O
assert	O
(	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
arg_max	long
>=	O
LINE_MAX	O
)	O
;	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
exec_callback	*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int))
=	O
xargs_do_exec	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)
;	O
bc_use_sensible_arg_max	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)))->(void)
(	O
&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
)	O
;	O
}	O
while	O
(	O
(	O
optc	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"+0a:E:e::i::I:l::L:n:prs:txP:d:"	*(char)
,	O
longopts	array(struct(*(char),int,*(int),int))
,	O
&	O
option_index	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'0'	O
:	O
read_args	*(()->(int))
=	O
read_string	()->(int)
;	O
input_delimiter	char
=	O
'\0'	O
;	O
break	O
;	O
case	O
'd'	O
:	O
read_args	*(()->(int))
=	O
read_string	()->(int)
;	O
input_delimiter	char
=	O
get_input_delimiter	(*(char))->(char)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
case	O
'e'	O
:	O
if	O
(	O
optarg	*(char)
&&	O
(	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
>	O
0	int
)	O
)	O
eof_str	*(char)
=	O
optarg	*(char)
;	O
else	O
eof_str	*(char)
=	O
0	int
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
0	int
;	O
case	O
'I'	O
:	O
case	O
'i'	O
:	O
if	O
(	O
optarg	*(char)
)	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
replace_pat	*(char)
=	O
optarg	*(char)
;	O
else	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
replace_pat	*(char)
=	O
"{}"	*(char)
;	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
args_per_exec	long
=	O
0	int
;	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
lines_per_exec	long
=	O
0	int
;	O
break	O
;	O
case	O
'L'	O
:	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
lines_per_exec	long
=	O
parse_num	(*(char),int,long,long,int)->(long)
(	O
optarg	*(char)
,	O
'L'	O
,	O
1L	int
,	O
-	O
1L	int
,	O
1	int
)	O
;	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
args_per_exec	long
=	O
0	int
;	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
replace_pat	*(char)
=	O
NULL	O
;	O
break	O
;	O
case	O
'l'	O
:	O
if	O
(	O
optarg	*(char)
)	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
lines_per_exec	long
=	O
parse_num	(*(char),int,long,long,int)->(long)
(	O
optarg	*(char)
,	O
'l'	O
,	O
1L	int
,	O
-	O
1L	int
,	O
1	int
)	O
;	O
else	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
lines_per_exec	long
=	O
1	int
;	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
args_per_exec	long
=	O
0	int
;	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
replace_pat	*(char)
=	O
NULL	O
;	O
break	O
;	O
case	O
'n'	O
:	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
args_per_exec	long
=	O
parse_num	(*(char),int,long,long,int)->(long)
(	O
optarg	*(char)
,	O
'n'	O
,	O
1L	int
,	O
-	O
1L	int
,	O
1	int
)	O
;	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
lines_per_exec	long
=	O
0	int
;	O
if	O
(	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
args_per_exec	long
==	O
1	int
&&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
replace_pat	*(char)
)	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
args_per_exec	long
=	O
0	int
;	O
else	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
replace_pat	*(char)
=	O
NULL	O
;	O
break	O
;	O
case	O
's'	O
:	O
{	O
size_t	long
arg_size	long
;	O
act_on_init_result	*(()->(void))
(	O
)	O
;	O
arg_size	long
=	O
parse_num	(*(char),int,long,long,int)->(long)
(	O
optarg	*(char)
,	O
's'	O
,	O
1L	int
,	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
posix_arg_size_max	long
,	O
0	int
)	O
;	O
if	O
(	O
arg_size	long
>	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
posix_arg_size_max	long
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: value %ld for -s option is too large, "	*(char)
"using %ld instead"	*(char)
)	O
,	O
(	O
long	O
)	O
arg_size	long
,	O
(	O
long	O
)	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
posix_arg_size_max	long
)	O
;	O
arg_size	long
=	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
posix_arg_size_max	long
;	O
}	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
arg_max	long
=	O
arg_size	long
;	O
}	O
break	O
;	O
case	O
'S'	O
:	O
show_limits	int
=	O
true	int
;	O
break	O
;	O
case	O
't'	O
:	O
print_command	bool
=	O
true	int
;	O
break	O
;	O
case	O
'x'	O
:	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
exit_if_size_exceeded	int
=	O
true	int
;	O
break	O
;	O
case	O
'p'	O
:	O
query_before_executing	bool
=	O
true	int
;	O
print_command	bool
=	O
true	int
;	O
break	O
;	O
case	O
'r'	O
:	O
always_run_command	int
=	O
0	int
;	O
break	O
;	O
case	O
'P'	O
:	O
proc_max	int
=	O
parse_num	(*(char),int,long,long,int)->(long)
(	O
optarg	*(char)
,	O
'P'	O
,	O
0L	int
,	O
MAX_PROC_MAX	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
input_file	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'v'	O
:	O
display_findutils_version	(*(char))->(void)
(	O
"xargs"	*(char)
)	O
;	O
return	O
0	int
;	O
case	O
PROCESS_SLOT_VAR	int
:	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
optarg	*(char)
,	O
'='	O
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"option --%s may not be set to a value which includes `='"	*(char)
)	O
,	O
longopts	array(struct(*(char),int,*(int),int))
[	O
option_index	int
]	O
.	O
name	*(char)
)	O
;	O
}	O
slot_var_name	*(char)
=	O
optarg	*(char)
;	O
if	O
(	O
0	int
!=	O
unsetenv	(*(char))->(int)
(	O
slot_var_name	*(char)
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"failed to unset environment variable %s"	*(char)
)	O
,	O
slot_var_name	*(char)
)	O
;	O
}	O
break	O
;	O
default	O
:	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
eof_str	*(char)
&&	O
(	O
read_args	*(()->(int))
==	O
read_string	()->(int)
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: the -E option has no effect if -0 or -d is used.\n"	*(char)
)	O
)	O
;	O
}	O
act_on_init_result	*(()->(void))
(	O
)	O
;	O
assert	O
(	O
BC_INIT_OK	int
==	O
bcstatus	enum(int,int,int)
)	O
;	O
sigact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
=	O
increment_proc_max	(int)->(void)
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
sigact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
sigact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
0	int
;	O
if	O
(	O
0	int
!=	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGUSR1	int
,	O
&	O
sigact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
(	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
*	O
)	O
NULL	O
)	O
)	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"Cannot set SIGUSR1 signal handler"	*(char)
)	O
)	O
;	O
sigact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
=	O
decrement_proc_max	(int)->(void)
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
sigact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
sigact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
0	int
;	O
if	O
(	O
0	int
!=	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGUSR2	int
,	O
&	O
sigact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
(	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
*	O
)	O
NULL	O
)	O
)	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"Cannot set SIGUSR2 signal handler"	*(char)
)	O
)	O
;	O
if	O
(	O
0	int
==	O
strcmp	(*(char),*(char))->(int)
(	O
input_file	*(char)
,	O
"-"	*(char)
)	O
)	O
{	O
input_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
else	O
{	O
keep_stdin	int
=	O
1	int
;	O
input_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen_cloexec_for_read_only	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
input_file	*(char)
)	O
;	O
if	O
(	O
NULL	O
==	O
input_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Cannot open input file %s"	*(char)
)	O
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
input_file	*(char)
)	O
)	O
;	O
}	O
}	O
if	O
(	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
replace_pat	*(char)
||	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
lines_per_exec	long
)	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
exit_if_size_exceeded	int
=	O
true	int
;	O
if	O
(	O
optind	int
==	O
argc	int
)	O
{	O
optind	int
=	O
0	int
;	O
argc	int
=	O
1	int
;	O
default_arglist	array(*(char))
[	O
0	int
]	O
=	O
default_cmd	array(char)
;	O
argv	*(*(char))
=	O
default_arglist	array(*(char))
;	O
}	O
if	O
(	O
show_limits	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Your environment variables take up %"	*(char)
PRIuMAX	O
" bytes\n"	*(char)
)	O
,	O
(	O
uintmax_t	long
)	O
bc_size_of_environment	()->(long)
(	O
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"POSIX upper limit on argument length (this system): %"	*(char)
PRIuMAX	O
"\n"	*(char)
)	O
,	O
(	O
uintmax_t	long
)	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
posix_arg_size_max	long
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"POSIX smallest allowable upper limit on argument length (all systems): %"	*(char)
PRIuMAX	O
"\n"	*(char)
)	O
,	O
(	O
uintmax_t	long
)	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
posix_arg_size_min	long
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Maximum length of command we could actually use: %"	*(char)
PRIuMAX	O
"\n"	*(char)
)	O
,	O
(	O
uintmax_t	long
)	O
(	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
posix_arg_size_max	long
-	O
bc_size_of_environment	()->(long)
(	O
)	O
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Size of command buffer we are actually using: %"	*(char)
PRIuMAX	O
"\n"	*(char)
)	O
,	O
(	O
uintmax_t	long
)	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
arg_max	long
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Maximum parallelism (--max-procs must be no greater): %"	*(char)
PRIuMAX	O
"\n"	*(char)
)	O
,	O
(	O
uintmax_t	long
)	O
MAX_PROC_MAX	O
)	O
;	O
if	O
(	O
isatty	(int)->(int)
(	O
STDIN_FILENO	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\n"	*(char)
"Execution of xargs will continue now, and it will "	*(char)
"try to read its input and run commands; if this is "	*(char)
"not what you wanted to happen, please type the "	*(char)
"end-of-file keystroke.\n"	*(char)
)	O
)	O
;	O
if	O
(	O
always_run_command	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Warning: %s will be run at least once.  "	*(char)
"If you do not want that to happen, then press "	*(char)
"the interrupt keystroke.\n"	*(char)
)	O
,	O
argv	*(*(char))
[	O
optind	int
]	O
)	O
;	O
}	O
}	O
}	O
linebuf	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
arg_max	long
+	O
1	int
)	O
;	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
.	O
argbuf	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
arg_max	long
+	O
1	int
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
if	O
(	O
!	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
replace_pat	*(char)
)	O
{	O
for	O
(	O
;	O
optind	int
<	O
argc	int
;	O
optind	int
++	O
)	O
bc_push_arg	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(char),long,*(char),long,int)->(void)
(	O
&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
,	O
&	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
,	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
strlen	(*(char))->(long)
(	O
argv	*(*(char))
[	O
optind	int
]	O
)	O
+	O
1	int
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
initial_args	int
=	O
false	int
;	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
initial_argc	long
=	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
.	O
cmd_argc	long
;	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
.	O
cmd_initial_argv_chars	long
=	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
.	O
cmd_argv_chars	long
;	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
initial_argc	long
=	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
.	O
cmd_argc	long
;	O
while	O
(	O
(	O
*	O
read_args	*(()->(int))
)	O
(	O
)	O
!=	O
-	O
1	int
)	O
if	O
(	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
lines_per_exec	long
&&	O
lineno	long
>=	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
lines_per_exec	long
)	O
{	O
bc_do_exec	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(void)
(	O
&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
,	O
&	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
)	O
;	O
lineno	long
=	O
0	int
;	O
}	O
if	O
(	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
.	O
cmd_argc	long
!=	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
initial_argc	long
||	O
(	O
always_run_command	int
&&	O
procs_executed	bool
==	O
0	int
)	O
)	O
bc_do_exec	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(void)
(	O
&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
,	O
&	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
)	O
;	O
}	O
else	O
{	O
int	O
i	int
,	O
args	int
;	O
size_t	long
*	O
arglen	long
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
size_t	long
)	O
*	O
argc	int
)	O
;	O
for	O
(	O
i	int
=	O
optind	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
arglen	long
[	O
i	int
]	O
=	O
strlen	(*(char))->(long)
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
rplen	long
=	O
strlen	(*(char))->(long)
(	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
replace_pat	*(char)
)	O
;	O
while	O
(	O
(	O
args	int
=	O
(	O
*	O
read_args	*(()->(int))
)	O
(	O
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
size_t	long
len	long
=	O
(	O
size_t	long
)	O
args	int
;	O
bc_clear_args	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(void)
(	O
&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
,	O
&	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
)	O
;	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
.	O
cmd_argv_chars	long
=	O
0	int
;	O
bc_push_arg	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(char),long,*(char),long,int)->(void)
(	O
&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
,	O
&	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
,	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
arglen	long
[	O
optind	int
]	O
+	O
1	int
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
len	long
--	O
;	O
initial_args	int
=	O
false	int
;	O
for	O
(	O
i	int
=	O
optind	int
+	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
bc_do_insert	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(char),long,*(char),long,*(char),long,int)->(void)
(	O
&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
,	O
&	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
,	O
argv	*(*(char))
[	O
i	int
]	O
,	O
arglen	long
[	O
i	int
]	O
,	O
NULL	O
,	O
0	int
,	O
linebuf	*(char)
,	O
len	long
,	O
initial_args	int
)	O
;	O
bc_do_exec	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(void)
(	O
&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
,	O
&	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
)	O
;	O
}	O
}	O
original_exit_value	int
=	O
child_error	int
;	O
return	O
child_error	int
;	O
}	O
static	O
int	O
read_line	()->(int)
(	O
void	O
)	O
{	O
enum	O
read_line_state	enum(int,int,int,int)
{	O
NORM	int
=	O
0	int
,	O
SPACE	int
=	O
1	int
,	O
QUOTE	int
=	O
2	int
,	O
BACKSLASH	int
=	O
3	int
}	O
;	O
static	O
bool	bool
eof	bool
=	O
false	int
;	O
enum	O
read_line_state	enum(int,int,int,int)
state	*(int)
=	O
SPACE	int
;	O
int	O
prevc	int
;	O
int	O
quotc	int
=	O
0	int
;	O
int	O
c	char
=	O
EOF	O
;	O
bool	bool
first	bool
=	O
true	int
;	O
bool	bool
seen_arg	bool
=	O
false	int
;	O
int	O
len	long
;	O
char	O
*	O
p	*(void)
=	O
linebuf	*(char)
;	O
char	O
*	O
endbuf	*(char)
=	O
linebuf	*(char)
+	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
arg_max	long
-	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
.	O
cmd_initial_argv_chars	long
-	O
1	int
;	O
if	O
(	O
eof	bool
)	O
return	O
-	O
1	int
;	O
while	O
(	O
1	int
)	O
{	O
prevc	int
=	O
c	char
;	O
c	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
{	O
eof	bool
=	O
true	int
;	O
if	O
(	O
p	*(void)
==	O
linebuf	*(char)
)	O
return	O
-	O
1	int
;	O
*	O
p	*(void)
++	O
=	O
'\0'	O
;	O
len	long
=	O
p	*(void)
-	O
linebuf	*(char)
;	O
if	O
(	O
state	*(int)
==	O
QUOTE	int
)	O
{	O
exec_if_possible	()->(void)
(	O
)	O
;	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"unmatched %s quote; by default quotes are special to xargs unless you use the -0 option"	*(char)
)	O
,	O
quotc	int
==	O
'"'	O
?	O
_	O
(	O
"double"	*(char)
)	O
:	O
_	O
(	O
"single"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
first	bool
&&	O
EOF_STR	O
(	O
linebuf	*(char)
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
replace_pat	*(char)
)	O
bc_push_arg	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(char),long,*(char),long,int)->(void)
(	O
&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
,	O
&	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
,	O
linebuf	*(char)
,	O
len	long
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
return	O
len	long
;	O
}	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
SPACE	int
:	O
if	O
(	O
ISSPACE	O
(	O
c	char
)	O
)	O
continue	O
;	O
state	*(int)
=	O
NORM	int
;	O
case	O
NORM	int
:	O
if	O
(	O
c	char
==	O
'\n'	O
)	O
{	O
if	O
(	O
!	O
ISBLANK	O
(	O
prevc	int
)	O
)	O
lineno	long
++	O
;	O
if	O
(	O
p	*(void)
==	O
linebuf	*(char)
)	O
{	O
if	O
(	O
seen_arg	bool
)	O
{	O
}	O
else	O
{	O
state	*(int)
=	O
SPACE	int
;	O
continue	O
;	O
}	O
}	O
*	O
p	*(void)
++	O
=	O
'\0'	O
;	O
len	long
=	O
p	*(void)
-	O
linebuf	*(char)
;	O
if	O
(	O
EOF_STR	O
(	O
linebuf	*(char)
)	O
)	O
{	O
eof	bool
=	O
true	int
;	O
return	O
first	bool
?	O
-	O
1	int
:	O
len	long
;	O
}	O
if	O
(	O
!	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
replace_pat	*(char)
)	O
bc_push_arg	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(char),long,*(char),long,int)->(void)
(	O
&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
,	O
&	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
,	O
linebuf	*(char)
,	O
len	long
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
return	O
len	long
;	O
}	O
seen_arg	bool
=	O
true	int
;	O
if	O
(	O
!	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
replace_pat	*(char)
&&	O
ISBLANK	O
(	O
c	char
)	O
)	O
{	O
*	O
p	*(void)
++	O
=	O
'\0'	O
;	O
len	long
=	O
p	*(void)
-	O
linebuf	*(char)
;	O
if	O
(	O
EOF_STR	O
(	O
linebuf	*(char)
)	O
)	O
{	O
eof	bool
=	O
true	int
;	O
return	O
first	bool
?	O
-	O
1	int
:	O
len	long
;	O
}	O
bc_push_arg	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(char),long,*(char),long,int)->(void)
(	O
&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
,	O
&	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
,	O
linebuf	*(char)
,	O
len	long
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
p	*(void)
=	O
linebuf	*(char)
;	O
state	*(int)
=	O
SPACE	int
;	O
first	bool
=	O
false	int
;	O
continue	O
;	O
}	O
switch	O
(	O
c	char
)	O
{	O
case	O
'\\'	O
:	O
state	*(int)
=	O
BACKSLASH	int
;	O
continue	O
;	O
case	O
'\''	O
:	O
case	O
'"'	O
:	O
state	*(int)
=	O
QUOTE	int
;	O
quotc	int
=	O
c	char
;	O
continue	O
;	O
}	O
break	O
;	O
case	O
QUOTE	int
:	O
if	O
(	O
c	char
==	O
'\n'	O
)	O
{	O
exec_if_possible	()->(void)
(	O
)	O
;	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"unmatched %s quote; by default quotes are special to xargs unless you use the -0 option"	*(char)
)	O
,	O
quotc	int
==	O
'"'	O
?	O
_	O
(	O
"double"	*(char)
)	O
:	O
_	O
(	O
"single"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
c	char
==	O
quotc	int
)	O
{	O
state	*(int)
=	O
NORM	int
;	O
seen_arg	bool
=	O
true	int
;	O
continue	O
;	O
}	O
break	O
;	O
case	O
BACKSLASH	int
:	O
state	*(int)
=	O
NORM	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
0	int
==	O
c	char
)	O
&&	O
!	O
nullwarning_given	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"WARNING: a NUL character occurred in the input.  "	*(char)
"It cannot be passed through in the argument list.  "	*(char)
"Did you mean to use the --null option?"	*(char)
)	O
)	O
;	O
nullwarning_given	int
=	O
1	int
;	O
}	O
if	O
(	O
p	*(void)
>=	O
endbuf	*(char)
)	O
{	O
exec_if_possible	()->(void)
(	O
)	O
;	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"argument line too long"	*(char)
)	O
)	O
;	O
}	O
*	O
p	*(void)
++	O
=	O
c	char
;	O
}	O
}	O
static	O
int	O
read_string	()->(int)
(	O
void	O
)	O
{	O
static	O
bool	bool
eof	bool
=	O
false	int
;	O
int	O
len	long
;	O
char	O
*	O
p	*(void)
=	O
linebuf	*(char)
;	O
char	O
*	O
endbuf	*(char)
=	O
linebuf	*(char)
+	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
arg_max	long
-	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
.	O
cmd_initial_argv_chars	long
-	O
1	int
;	O
if	O
(	O
eof	bool
)	O
return	O
-	O
1	int
;	O
while	O
(	O
1	int
)	O
{	O
int	O
c	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
{	O
eof	bool
=	O
true	int
;	O
if	O
(	O
p	*(void)
==	O
linebuf	*(char)
)	O
return	O
-	O
1	int
;	O
*	O
p	*(void)
++	O
=	O
'\0'	O
;	O
len	long
=	O
p	*(void)
-	O
linebuf	*(char)
;	O
if	O
(	O
!	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
replace_pat	*(char)
)	O
bc_push_arg	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(char),long,*(char),long,int)->(void)
(	O
&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
,	O
&	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
,	O
linebuf	*(char)
,	O
len	long
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
return	O
len	long
;	O
}	O
if	O
(	O
c	char
==	O
input_delimiter	char
)	O
{	O
lineno	long
++	O
;	O
*	O
p	*(void)
++	O
=	O
'\0'	O
;	O
len	long
=	O
p	*(void)
-	O
linebuf	*(char)
;	O
if	O
(	O
!	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
replace_pat	*(char)
)	O
bc_push_arg	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(char),long,*(char),long,int)->(void)
(	O
&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
,	O
&	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
,	O
linebuf	*(char)
,	O
len	long
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
return	O
len	long
;	O
}	O
if	O
(	O
p	*(void)
>=	O
endbuf	*(char)
)	O
{	O
exec_if_possible	()->(void)
(	O
)	O
;	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"argument line too long"	*(char)
)	O
)	O
;	O
}	O
*	O
p	*(void)
++	O
=	O
c	char
;	O
}	O
}	O
static	O
bool	bool
print_args	(bool)->(bool)
(	O
bool	bool
ask	bool
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
.	O
cmd_argc	long
-	O
1	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s "	*(char)
,	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
.	O
cmd_argv	*(*(char))
[	O
i	int
]	O
)	O
<	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Failed to write to stderr"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
ask	bool
)	O
{	O
static	O
FILE	struct
*	O
tty_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
c	char
,	O
savec	int
;	O
if	O
(	O
!	O
tty_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
tty_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen_cloexec_for_read_only	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
"/dev/tty"	*(char)
)	O
;	O
if	O
(	O
!	O
tty_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"failed to open /dev/tty for reading"	*(char)
)	O
)	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"?..."	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Failed to write to stderr"	*(char)
)	O
)	O
;	O
c	char
=	O
savec	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
tty_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
c	char
!=	O
EOF	O
&&	O
c	char
!=	O
'\n'	O
)	O
c	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
tty_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
EOF	O
==	O
c	char
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Failed to read from stdin"	*(char)
)	O
)	O
;	O
if	O
(	O
savec	int
==	O
'y'	O
||	O
savec	int
==	O
'Y'	O
)	O
return	O
true	int
;	O
}	O
else	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
false	int
;	O
}	O
static	O
void	O
set_slot_var	(int)->(void)
(	O
unsigned	O
int	O
n	long
)	O
{	O
static	O
const	O
char	O
*	O
fmt	*(char)
=	O
"%u"	*(char)
;	O
int	O
size	*(long)
;	O
char	O
*	O
buf	*(char)
;	O
size	*(long)
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
NULL	O
,	O
0u	int
,	O
fmt	*(char)
,	O
n	long
)	O
;	O
assert	O
(	O
size	*(long)
>	O
0	int
)	O
;	O
if	O
(	O
NULL	O
==	O
(	O
buf	*(char)
=	O
malloc	(long)->(*(void))
(	O
size	*(long)
+	O
1	int
)	O
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(char)
,	O
size	*(long)
+	O
1	int
,	O
fmt	*(char)
,	O
n	long
)	O
;	O
if	O
(	O
slot_var_name	*(char)
)	O
{	O
if	O
(	O
setenv	(*(char),*(char),int)->(int)
(	O
slot_var_name	*(char)
,	O
buf	*(char)
,	O
1	int
)	O
<	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"failed to set environment variable %s"	*(char)
)	O
,	O
slot_var_name	*(char)
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
prep_child_for_exec	()->(void)
(	O
void	O
)	O
{	O
complain_about_leaky_fds	()->(void)
(	O
)	O
;	O
unsigned	O
int	O
slot	int
=	O
add_proc	(int)->(int)
(	O
0	int
)	O
;	O
set_slot_var	(int)->(void)
(	O
slot	int
)	O
;	O
if	O
(	O
!	O
keep_stdin	int
)	O
{	O
const	O
char	O
inputfile	array(char)
[	O
]	O
=	O
"/dev/null"	*(char)
;	O
close	*((*(void))->(int))
(	O
0	int
)	O
;	O
if	O
(	O
open	(*(char),int)->(int)
(	O
inputfile	array(char)
,	O
O_RDONLY	int
)	O
<	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
inputfile	array(char)
)	O
)	O
;	O
}	O
}	O
}	O
static	O
int	O
xargs_do_exec	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)
(	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
*	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
void	O
*	O
usercontext	*(void)
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
pid_t	int
child	int
;	O
int	O
fd	int
[	O
2	int
]	O
;	O
int	O
buf	*(char)
;	O
size_t	long
r	long
;	O
(	O
void	O
)	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
;	O
(	O
void	O
)	O
argc	int
;	O
(	O
void	O
)	O
usercontext	*(void)
;	O
if	O
(	O
proc_max	int
)	O
{	O
while	O
(	O
procs_executing	long
>=	O
proc_max	int
)	O
{	O
wait_for_proc	(bool,int)->(void)
(	O
false	int
,	O
1u	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
query_before_executing	bool
||	O
print_args	(bool)->(bool)
(	O
true	int
)	O
)	O
{	O
if	O
(	O
!	O
query_before_executing	bool
&&	O
print_command	bool
)	O
print_args	(bool)->(bool)
(	O
false	int
)	O
;	O
wait_for_proc	(bool,int)->(void)
(	O
false	int
,	O
0u	int
)	O
;	O
if	O
(	O
pipe	(array(int))->(int)
(	O
fd	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"could not create pipe before fork"	*(char)
)	O
)	O
;	O
fcntl	(int,int)->(int)
(	O
fd	int
[	O
1	int
]	O
,	O
F_SETFD	int
,	O
FD_CLOEXEC	int
)	O
;	O
while	O
(	O
(	O
child	int
=	O
fork	()->(int)
(	O
)	O
)	O
<	O
0	int
&&	O
errno	O
==	O
EAGAIN	int
&&	O
procs_executing	long
)	O
wait_for_proc	(bool,int)->(void)
(	O
false	int
,	O
1u	int
)	O
;	O
switch	O
(	O
child	int
)	O
{	O
case	O
-	O
1	int
:	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot fork"	*(char)
)	O
)	O
;	O
case	O
0	int
:	O
{	O
close	*((*(void))->(int))
(	O
fd	int
[	O
0	int
]	O
)	O
;	O
child_error	int
=	O
EXIT_SUCCESS	int
;	O
prep_child_for_exec	()->(void)
(	O
)	O
;	O
if	O
(	O
bc_args_exceed_testing_limit	(*(*(char)))->(bool)
(	O
argv	*(*(char))
)	O
)	O
errno	O
=	O
E2BIG	int
;	O
else	O
execvp	(*(char),array(*(char)))->(int)
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
argv	*(*(char))
)	O
;	O
if	O
(	O
errno	O
)	O
{	O
write	*((*(void),*(char),long)->(long))
(	O
fd	int
[	O
1	int
]	O
,	O
&	O
errno	O
,	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
}	O
close	*((*(void))->(int))
(	O
fd	int
[	O
1	int
]	O
)	O
;	O
if	O
(	O
E2BIG	int
!=	O
errno	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
}	O
_exit	(int)->(void)
(	O
errno	O
==	O
ENOENT	int
?	O
XARGS_EXIT_COMMAND_NOT_FOUND	int
:	O
XARGS_EXIT_COMMAND_CANNOT_BE_RUN	int
)	O
;	O
}	O
default	O
:	O
{	O
close	*((*(void))->(int))
(	O
fd	int
[	O
1	int
]	O
)	O
;	O
}	O
}	O
switch	O
(	O
r	long
=	O
safe_read	(int,*(void),long)->(long)
(	O
fd	int
[	O
0	int
]	O
,	O
&	O
buf	*(char)
,	O
sizeof	O
(	O
int	O
)	O
)	O
)	O
{	O
case	O
SAFE_READ_ERROR	O
:	O
{	O
close	*((*(void))->(int))
(	O
fd	int
[	O
0	int
]	O
)	O
;	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"errno-buffer safe_read failed in xargs_do_exec "	*(char)
"(this is probably a bug, please report it)"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
case	O
sizeof	O
(	O
int	O
)	O
:	O
{	O
int	O
childstatus	int
;	O
close	*((*(void))->(int))
(	O
fd	int
[	O
0	int
]	O
)	O
;	O
waitpid	(int,*(int),int)->(int)
(	O
child	int
,	O
&	O
childstatus	int
,	O
0	int
)	O
;	O
if	O
(	O
E2BIG	int
==	O
buf	*(char)
)	O
{	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
ENOENT	int
==	O
buf	*(char)
)	O
{	O
exit	(int)->(void)
(	O
XARGS_EXIT_COMMAND_NOT_FOUND	int
)	O
;	O
}	O
else	O
{	O
exit	(int)->(void)
(	O
XARGS_EXIT_COMMAND_CANNOT_BE_RUN	int
)	O
;	O
}	O
break	O
;	O
}	O
case	O
0	int
:	O
{	O
add_proc	(int)->(int)
(	O
child	int
)	O
;	O
break	O
;	O
}	O
default	O
:	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"read returned unexpected value %zu; "	*(char)
"this is probably a bug, please report it"	*(char)
)	O
,	O
r	long
)	O
;	O
}	O
}	O
close	*((*(void))->(int))
(	O
fd	int
[	O
0	int
]	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
exec_if_possible	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
replace_pat	*(char)
||	O
initial_args	int
||	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
.	O
cmd_argc	long
==	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
initial_argc	long
||	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
.	O
exit_if_size_exceeded	int
)	O
return	O
;	O
bc_do_exec	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(void)
(	O
&	O
bc_ctl	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long)
,	O
&	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
)	O
;	O
}	O
static	O
unsigned	O
int	O
add_proc	(int)->(int)
(	O
pid_t	int
pid	int
)	O
{	O
unsigned	O
int	O
i	int
,	O
j	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pids_alloc	long
&&	O
pids	*(int)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
i	int
==	O
pids_alloc	long
)	O
{	O
pids	*(int)
=	O
x2nrealloc	(*(void),*(long),long)->(*(void))
(	O
pids	*(int)
,	O
&	O
pids_alloc	long
,	O
sizeof	O
*	O
pids	*(int)
)	O
;	O
for	O
(	O
j	int
=	O
i	int
;	O
j	int
<	O
pids_alloc	long
;	O
++	O
j	int
)	O
pids	*(int)
[	O
j	int
]	O
=	O
(	O
pid_t	int
)	O
0	int
;	O
}	O
assert	O
(	O
0	int
==	O
pids	*(int)
[	O
i	int
]	O
)	O
;	O
pids	*(int)
[	O
i	int
]	O
=	O
pid	int
;	O
procs_executing	long
++	O
;	O
procs_executed	bool
=	O
true	int
;	O
return	O
i	int
;	O
}	O
static	O
void	O
wait_for_proc	(bool,int)->(void)
(	O
bool	bool
all	bool
,	O
unsigned	O
int	O
minreap	int
)	O
{	O
unsigned	O
int	O
reaped	int
=	O
0	int
;	O
while	O
(	O
procs_executing	long
)	O
{	O
unsigned	O
int	O
i	int
;	O
int	O
status	int
;	O
pid_t	int
pid	int
;	O
int	O
wflags	int
=	O
0	int
;	O
if	O
(	O
!	O
all	bool
)	O
{	O
if	O
(	O
reaped	int
>=	O
minreap	int
)	O
{	O
wflags	int
=	O
WNOHANG	int
;	O
}	O
}	O
stop_waiting	int
=	O
0	int
;	O
do	O
{	O
while	O
(	O
(	O
pid	int
=	O
waitpid	(int,*(int),int)->(int)
(	O
-	O
1	int
,	O
&	O
status	int
,	O
wflags	int
)	O
)	O
==	O
(	O
pid_t	int
)	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EINTR	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"error waiting for child process"	*(char)
)	O
)	O
;	O
if	O
(	O
stop_waiting	int
&&	O
!	O
all	bool
)	O
{	O
wflags	int
=	O
WNOHANG	int
;	O
}	O
}	O
if	O
(	O
pid	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pids_alloc	long
&&	O
pid	int
!=	O
pids	*(int)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
}	O
}	O
while	O
(	O
pid	int
&&	O
i	int
==	O
pids_alloc	long
)	O
;	O
if	O
(	O
!	O
pid	int
)	O
{	O
if	O
(	O
!	O
(	O
wflags	int
&	O
WNOHANG	int
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"WARNING: Lost track of %lu child processes"	*(char)
)	O
,	O
procs_executing	long
)	O
;	O
}	O
else	O
{	O
}	O
break	O
;	O
}	O
pids	*(int)
[	O
i	int
]	O
=	O
0	int
;	O
procs_executing	long
--	O
;	O
reaped	int
++	O
;	O
if	O
(	O
WEXITSTATUS	O
(	O
status	int
)	O
==	O
CHILD_EXIT_PLEASE_STOP_IMMEDIATELY	int
)	O
error	(int,int,*(char))->(void)
(	O
XARGS_EXIT_CLIENT_EXIT_255	int
,	O
0	int
,	O
_	O
(	O
"%s: exited with status 255; aborting"	*(char)
)	O
,	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
.	O
cmd_argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
WIFSTOPPED	O
(	O
status	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
XARGS_EXIT_CLIENT_FATAL_SIG	int
,	O
0	int
,	O
_	O
(	O
"%s: stopped by signal %d"	*(char)
)	O
,	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
.	O
cmd_argv	*(*(char))
[	O
0	int
]	O
,	O
WSTOPSIG	O
(	O
status	int
)	O
)	O
;	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
XARGS_EXIT_CLIENT_FATAL_SIG	int
,	O
0	int
,	O
_	O
(	O
"%s: terminated by signal %d"	*(char)
)	O
,	O
bc_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
.	O
cmd_argv	*(*(char))
[	O
0	int
]	O
,	O
WTERMSIG	O
(	O
status	int
)	O
)	O
;	O
if	O
(	O
WEXITSTATUS	O
(	O
status	int
)	O
!=	O
0	int
)	O
child_error	int
=	O
XARGS_EXIT_CLIENT_EXIT_NONZERO	int
;	O
}	O
}	O
static	O
void	O
wait_for_proc_all	()->(void)
(	O
void	O
)	O
{	O
static	O
bool	bool
waiting	bool
=	O
false	int
;	O
assert	O
(	O
getpid	()->(int)
(	O
)	O
==	O
parent	int
)	O
;	O
if	O
(	O
waiting	bool
)	O
return	O
;	O
waiting	bool
=	O
true	int
;	O
wait_for_proc	(bool,int)->(void)
(	O
true	int
,	O
0u	int
)	O
;	O
waiting	bool
=	O
false	int
;	O
if	O
(	O
original_exit_value	int
!=	O
child_error	int
)	O
{	O
_exit	(int)->(void)
(	O
child_error	int
)	O
;	O
}	O
}	O
static	O
void	O
increment_proc_max	(int)->(void)
(	O
int	O
ignore	int
)	O
{	O
(	O
void	O
)	O
ignore	int
;	O
if	O
(	O
proc_max	int
<	O
MAX_PROC_MAX	O
)	O
proc_max	int
++	O
;	O
stop_waiting	int
=	O
1	int
;	O
}	O
static	O
void	O
decrement_proc_max	(int)->(void)
(	O
int	O
ignore	int
)	O
{	O
(	O
void	O
)	O
ignore	int
;	O
if	O
(	O
proc_max	int
>	O
1	int
)	O
proc_max	int
--	O
;	O
}	O
static	O
long	O
parse_num	(*(char),int,long,long,int)->(long)
(	O
char	O
*	O
str	*(char)
,	O
int	O
option	struct(*(char),int,*(int),int)
,	O
long	O
int	O
min	long
,	O
long	O
int	O
max	long
,	O
int	O
fatal	int
)	O
{	O
char	O
*	O
eptr	*(char)
;	O
long	O
val	int
;	O
val	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
str	*(char)
,	O
&	O
eptr	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
eptr	*(char)
==	O
str	*(char)
||	O
*	O
eptr	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: invalid number for -%c option\n"	*(char)
)	O
,	O
program_name	*(char)
,	O
option	struct(*(char),int,*(int),int)
)	O
;	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
if	O
(	O
val	int
<	O
min	long
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: value for -%c option should be >= %ld\n"	*(char)
)	O
,	O
program_name	*(char)
,	O
option	struct(*(char),int,*(int),int)
,	O
min	long
)	O
;	O
if	O
(	O
fatal	int
)	O
{	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
val	int
=	O
min	long
;	O
}	O
}	O
else	O
if	O
(	O
max	long
>=	O
0	int
&&	O
val	int
>	O
max	long
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: value for -%c option should be <= %ld\n"	*(char)
)	O
,	O
program_name	*(char)
,	O
option	struct(*(char),int,*(int),int)
,	O
max	long
)	O
;	O
if	O
(	O
fatal	int
)	O
{	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
val	int
=	O
max	long
;	O
}	O
}	O
return	O
val	int
;	O
}	O
static	O
void	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Usage: %s [OPTION]... COMMAND [INITIAL-ARGS]...\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
HTL	O
(	O
_	O
(	O
"Run COMMAND with arguments INITIAL-ARGS and more arguments read from input.\n"	*(char)
"\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"Mandatory and optional arguments to long options are also\n"	*(char)
"mandatory or optional for the corresponding short option.\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -0, --null                   items are separated by a null, not whitespace;\n"	*(char)
"                                 disables quote and backslash processing and\n"	*(char)
"                                 logical EOF processing\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -a, --arg-file=FILE          read arguments from FILE, not standard input\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -d, --delimiter=CHARACTER    items in input stream are separated by CHARACTER,\n"	*(char)
"                                 not by whitespace; disables quote and backslash\n"	*(char)
"                                 processing and logical EOF processing\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -E END                       set logical EOF string; if END occurs as a line\n"	*(char)
"                                 of input, the rest of the input is ignored\n"	*(char)
"                                 (ignored if -0 or -d was specified)\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -e, --eof[=END]              equivalent to -E END if END is specified;\n"	*(char)
"                                 otherwise, there is no end-of-file string\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -I R                         same as --replace=R\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -i, --replace[=R]            replace R in INITIAL-ARGS with names read\n"	*(char)
"                                 from standard input; if R is unspecified,\n"	*(char)
"                                 assume {}\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -L, --max-lines=MAX-LINES    use at most MAX-LINES non-blank input lines per\n"	*(char)
"                                 command line\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -l[MAX-LINES]                similar to -L but defaults to at most one non-\n"	*(char)
"                                 blank input line if MAX-LINES is not specified\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -n, --max-args=MAX-ARGS      use at most MAX-ARGS arguments per command line\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -P, --max-procs=MAX-PROCS    run at most MAX-PROCS processes at a time\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -p, --interactive            prompt before running commands\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"      --process-slot-var=VAR   set environment variable VAR in child processes\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -r, --no-run-if-empty        if there are no arguments, then do not run COMMAND;\n"	*(char)
"                                 if this option is not given, COMMAND will be\n"	*(char)
"                                 run at least once\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -s, --max-chars=MAX-CHARS    limit length of command line to MAX-CHARS\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"      --show-limits            show limits on command-line length\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -t, --verbose                print commands before executing them\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -x, --exit                   exit if the size (see -s) is exceeded\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"      --help                   display this help and exit\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"      --version                output version information and exit\n"	*(char)
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"\n"	*(char)
"Report bugs to <bug-findutils@gnu.org>.\n"	*(char)
)	O
)	O
;	O
}	O
