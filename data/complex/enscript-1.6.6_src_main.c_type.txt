static	O
void	O
open_output_file	()->(void)
(	O
)	O
;	O
static	O
void	O
close_output_file	()->(void)
(	O
)	O
;	O
static	O
void	O
handle_env_options	(*(char))->(void)
___P	O
(	O
(	O
char	O
*	O
var	*(char)
)	O
)	O
;	O
static	O
void	O
handle_options	(int,array(*(char)))->(void)
___P	O
(	O
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
)	O
;	O
static	O
void	O
usage	()->(void)
(	O
)	O
;	O
static	O
void	O
version	double
(	O
)	O
;	O
char	O
*	O
program	*(char)
;	O
FILE	struct
*	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
void	O
*	O
printer_context	*(void)
;	O
char	O
*	O
date_string	*(char)
=	O
NULL	O
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
;	O
char	O
*	O
enscript_library	*(char)
=	O
LIBRARY	O
;	O
char	O
*	O
libpath	*(char)
=	O
NULL	O
;	O
char	O
*	O
afm_path	*(char)
=	O
NULL	O
;	O
MediaEntry	struct(*(struct(*(struct(*`,*`,int,int,int,int,int,int)),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int)
*	O
media_names	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
=	O
NULL	O
;	O
MediaEntry	struct(*(struct(*(struct(*`,*`,int,int,int,int,int,int)),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int)
*	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
=	O
NULL	O
;	O
int	O
bs	int
=	O
8	int
;	O
int	O
total_pages	int
=	O
0	int
;	O
int	O
num_truncated_lines	int
=	O
0	int
;	O
int	O
num_missing_chars	int
=	O
0	int
;	O
int	O
missing_chars	array(int)
[	O
256	int
]	O
=	O
{	O
0	int
}	O
;	O
int	O
num_non_printable_chars	int
=	O
0	int
;	O
int	O
non_printable_chars	array(int)
[	O
256	int
]	O
=	O
{	O
0	int
}	O
;	O
int	O
d_page_w	int
=	O
0	int
;	O
int	O
d_page_h	int
=	O
0	int
;	O
int	O
d_header_w	int
=	O
0	int
;	O
int	O
d_header_h	int
=	O
0	int
;	O
int	O
d_footer_h	int
=	O
0	int
;	O
int	O
d_output_w	int
=	O
0	int
;	O
int	O
d_output_h	int
=	O
0	int
;	O
int	O
d_output_x_margin	int
=	O
5	int
;	O
int	O
d_output_y_margin	int
=	O
2	int
;	O
StringHashPtr	*(struct)
res_fonts	*(struct)
;	O
StringHashPtr	*(struct)
download_fonts	*(struct)
;	O
StringHashPtr	*(struct)
pagedevice	*(struct)
;	O
StringHashPtr	*(struct)
statusdict	*(struct)
;	O
StringHashPtr	*(struct)
user_strings	*(struct)
;	O
StringHashPtr	*(struct)
afm_cache	*(struct)
=	O
NULL	O
;	O
StringHashPtr	*(struct)
afm_info_cache	*(struct)
=	O
NULL	O
;	O
AFMHandle	*(struct)
afm	*(struct)
=	O
NULL	O
;	O
int	O
num_columns	int
=	O
1	int
;	O
PageRange	struct(*(struct(*(struct(*`,int,int,int,int)),int,int,int,int)),int,int,int,int)
*	O
page_ranges	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
=	O
NULL	O
;	O
unsigned	O
int	O
file_align	int
=	O
1	int
;	O
char	O
*	O
page_header	*(char)
=	O
NULL	O
;	O
LineEndType	enum(int,int,int)
line_end	enum(int,int,int)
=	O
LE_CHAR_WRAP	int
;	O
int	O
line_numbers	int
=	O
0	int
;	O
unsigned	O
int	O
start_line_number	int
=	O
1	int
;	O
char	O
*	O
printer	*(char)
=	O
NULL	O
;	O
int	O
special_escapes	int
=	O
0	int
;	O
int	O
escape_char	int
=	O
'\0'	O
;	O
int	O
default_escape_char	int
;	O
int	O
highlight	int
=	O
0	int
;	O
char	O
*	O
hl_start_state	*(char)
=	O
NULL	O
;	O
char	O
*	O
Fname	*(char)
=	O
"Courier"	*(char)
;	O
FontPoint	struct(double,double)
Fpt	struct(double,double)
=	O
{	O
10.0	int
,	O
10.0	int
}	O
;	O
FontPoint	struct(double,double)
default_Fpt	struct(double,double)
;	O
char	O
*	O
default_Fname	*(char)
;	O
InputEncoding	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
default_Fencoding	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
int	O
user_body_font_defined	int
=	O
0	int
;	O
double	O
font_widths	array(double)
[	O
256	int
]	O
;	O
char	O
font_ctype	array(char)
[	O
256	int
]	O
;	O
int	O
font_is_fixed	enum(int,int)
;	O
double	O
font_bbox_lly	double
;	O
char	O
*	O
HFname	*(char)
=	O
"Courier-Bold"	*(char)
;	O
FontPoint	struct(double,double)
HFpt	struct(double,double)
=	O
{	O
10.0	int
,	O
10.0	int
}	O
;	O
HeaderType	enum(int,int,int)
header	enum(int,int,int)
=	O
HDR_SIMPLE	int
;	O
char	O
*	O
fancy_header_name	*(char)
=	O
NULL	O
;	O
char	O
*	O
fancy_header_default	*(char)
=	O
NULL	O
;	O
static	O
int	O
no_job_header	int
=	O
0	int
;	O
unsigned	O
int	O
highlight_bars	int
=	O
0	int
;	O
double	O
line_indent	double
=	O
0.0	int
;	O
char	O
*	O
line_indent_spec	*(char)
=	O
"0"	*(char)
;	O
char	O
*	O
input_filter	*(char)
=	O
NULL	O
;	O
int	O
borders	int
=	O
0	int
;	O
int	O
page_prefeed	int
=	O
0	int
;	O
unsigned	O
int	O
lines_per_page	int
=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
;	O
int	O
mail	int
=	O
0	int
;	O
char	O
*	O
media_name	*(char)
=	O
NULL	O
;	O
int	O
num_copies	int
=	O
1	int
;	O
int	O
nl	int
=	O
-	O
1	int
;	O
char	O
*	O
output_file	*(char)
=	O
OUTPUT_FILE_NONE	O
;	O
int	O
list_missing_characters	int
=	O
0	int
;	O
int	O
quiet	int
=	O
0	int
;	O
int	O
landscape	int
=	O
0	int
;	O
double	O
baselineskip	double
=	O
1.0	int
;	O
char	O
*	O
title	*(char)
=	O
"Enscript Output"	*(char)
;	O
int	O
title_given	int
=	O
0	int
;	O
int	O
tabsize	int
=	O
8	int
;	O
double	O
ul_gray	double
=	O
.8	int
;	O
FontPoint	struct(double,double)
ul_ptsize	struct(double,double)
=	O
{	O
200.0	int
,	O
200.0	int
}	O
;	O
char	O
*	O
ul_font	*(char)
=	O
"Times-Roman"	*(char)
;	O
char	O
*	O
underlay	*(char)
=	O
NULL	O
;	O
char	O
*	O
ul_position	*(char)
=	O
NULL	O
;	O
double	O
ul_x	double
;	O
double	O
ul_y	double
;	O
double	O
ul_angle	double
;	O
unsigned	O
int	O
ul_style	int
=	O
UL_STYLE_OUTLINE	int
;	O
char	O
*	O
ul_style_str	*(char)
=	O
NULL	O
;	O
int	O
ul_position_p	int
=	O
0	int
;	O
int	O
ul_angle_p	int
=	O
0	int
;	O
unsigned	O
int	O
nup	int
=	O
1	int
;	O
unsigned	O
int	O
nup_exp	int
=	O
0	int
;	O
unsigned	O
int	O
nup_rows	int
=	O
1	int
;	O
unsigned	O
int	O
nup_columns	int
=	O
1	int
;	O
int	O
nup_landscape	int
=	O
0	int
;	O
unsigned	O
int	O
nup_width	int
;	O
unsigned	O
int	O
nup_height	int
;	O
double	O
nup_scale	double
;	O
int	O
verbose	int
=	O
0	int
;	O
char	O
*	O
output_language	*(char)
=	O
"PostScript"	*(char)
;	O
int	O
output_language_pass_through	int
=	O
0	int
;	O
Buffer	struct(*(char),long,long)
*	O
helper_options	array(*(struct(*(char),long,long)))
[	O
256	int
]	O
=	O
{	O
0	int
}	O
;	O
InputEncoding	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
encoding	array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char))))))
=	O
ENC_ISO_8859_1	int
;	O
char	O
*	O
encoding_name	*(char)
=	O
NULL	O
;	O
int	O
interpret_formfeed	int
=	O
1	int
;	O
int	O
pass_through	int
=	O
0	int
;	O
int	O
continuous_page_numbers	int
=	O
0	int
;	O
int	O
extended_return_values	int
=	O
0	int
;	O
char	O
*	O
input_filter_stdin	*(char)
=	O
""	*(char)
;	O
char	O
*	O
page_footer	*(char)
=	O
NULL	O
;	O
double	O
horizontal_column_height	double
=	O
283465.0	int
;	O
int	O
help_highlight	int
=	O
0	int
;	O
double	O
highlight_bar_gray	double
=	O
.97	int
;	O
int	O
list_media	int
=	O
0	int
;	O
char	O
*	O
margins_spec	*(char)
=	O
NULL	O
;	O
char	O
*	O
mark_wrapped_lines_style_name	*(char)
=	O
NULL	O
;	O
MarkWrappedLinesStyle	enum(int,int,int,int)
mark_wrapped_lines_style	enum(int,int,int,int)
=	O
MWLS_NONE	int
;	O
char	O
*	O
npf_name	*(char)
=	O
NULL	O
;	O
NonPrintableFormat	enum(int,int,int,int)
non_printable_format	enum(int,int,int,int)
=	O
NPF_OCTAL	int
;	O
int	O
nup_columnwise	int
=	O
0	int
;	O
unsigned	O
int	O
nup_xpad	int
=	O
10	int
;	O
unsigned	O
int	O
nup_ypad	int
=	O
10	int
;	O
char	O
*	O
page_label_format	*(char)
=	O
NULL	O
;	O
PageLabelFormat	enum(int,int)
page_label	enum(int,int)
;	O
unsigned	O
int	O
pslevel	int
=	O
2	int
;	O
char	O
*	O
printer_options	*(char)
=	O
NULL	O
;	O
int	O
rotate_even_pages	int
=	O
0	int
;	O
int	O
slicing	int
=	O
0	int
;	O
unsigned	O
int	O
slice	int
=	O
1	int
;	O
int	O
swap_even_page_margins	int
=	O
0	int
;	O
int	O
toc	int
=	O
0	int
;	O
FILE	struct
*	O
toc_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
toc_fmt_string	*(char)
;	O
int	O
accept_composites	int
=	O
0	int
;	O
int	O
append_ctrl_D	int
=	O
0	int
;	O
int	O
clean_7bit	int
=	O
1	int
;	O
FormFeedType	enum(int,int,int)
formfeed_type	enum(int,int,int)
=	O
FORMFEED_COLUMN	int
;	O
int	O
generate_PageSize	int
=	O
1	int
;	O
char	O
*	O
no_job_header_switch	*(char)
=	O
NULL	O
;	O
char	O
*	O
output_first_line	*(char)
=	O
NULL	O
;	O
char	O
*	O
queue_param	*(char)
=	O
NULL	O
;	O
char	O
*	O
spooler_command	*(char)
=	O
NULL	O
;	O
char	O
*	O
states_binary	*(char)
=	O
NULL	O
;	O
int	O
states_color	int
=	O
0	int
;	O
char	O
*	O
states_config_file	*(char)
=	O
NULL	O
;	O
char	O
*	O
states_highlight_style	*(char)
=	O
NULL	O
;	O
char	O
*	O
states_path	*(char)
=	O
NULL	O
;	O
double	O
line_highlight_gray	double
=	O
1.0	int
;	O
double	O
bggray	double
=	O
1.0	int
;	O
EncodingRegistry	struct(array(*(char)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
encodings	array(struct(array(*(char)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int))
[	O
]	O
=	O
{	O
{	O
{	O
"88591"	*(char)
,	O
"latin1"	*(char)
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_1	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"88592"	*(char)
,	O
"latin2"	*(char)
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_2	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"88593"	*(char)
,	O
"latin3"	*(char)
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_3	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"88594"	*(char)
,	O
"latin4"	*(char)
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_4	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"88595"	*(char)
,	O
"cyrillic"	*(char)
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_5	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"88597"	*(char)
,	O
"greek"	*(char)
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_7	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"88599"	*(char)
,	O
"latin5"	*(char)
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_9	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"885910"	*(char)
,	O
"latin6"	*(char)
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_10	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"ascii"	*(char)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
ENC_ASCII	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"asciifise"	*(char)
,	O
"asciifi"	*(char)
,	O
"asciise"	*(char)
}	O
,	O
ENC_ASCII_FISE	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"asciidkno"	*(char)
,	O
"asciidk"	*(char)
,	O
"asciino"	*(char)
}	O
,	O
ENC_ASCII_DKNO	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"ibmpc"	*(char)
,	O
"pc"	*(char)
,	O
"dos"	*(char)
}	O
,	O
ENC_IBMPC	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"mac"	*(char)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
ENC_MAC	int
,	O
'\r'	O
,	O
8	int
}	O
,	O
{	O
{	O
"vms"	*(char)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
ENC_VMS	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"hp8"	*(char)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
ENC_HP8	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"koi8"	*(char)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
ENC_KOI8	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"ps"	*(char)
,	O
"PS"	*(char)
,	O
NULL	O
}	O
,	O
ENC_PS	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"pslatin1"	*(char)
,	O
"ISOLatin1Encoding"	*(char)
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_1	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"columns"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"pages"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"file-align"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'A'	O
}	O
,	O
{	O
"header"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'b'	O
}	O
,	O
{	O
"no-header"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'B'	O
}	O
,	O
{	O
"truncate-lines"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"line-numbers"	*(char)
,	O
optional_argument	int
,	O
0	int
,	O
'C'	O
}	O
,	O
{	O
"printer"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"setpagedevice"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"escapes"	*(char)
,	O
optional_argument	int
,	O
0	int
,	O
'e'	O
}	O
,	O
{	O
"highlight"	*(char)
,	O
optional_argument	int
,	O
0	int
,	O
'E'	O
}	O
,	O
{	O
"font"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"header-font"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'F'	O
}	O
,	O
{	O
"print-anyway"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'g'	O
}	O
,	O
{	O
"fancy-header"	*(char)
,	O
optional_argument	int
,	O
0	int
,	O
'G'	O
}	O
,	O
{	O
"no-job-header"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"highlight-bars"	*(char)
,	O
optional_argument	int
,	O
0	int
,	O
'H'	O
}	O
,	O
{	O
"indent"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"filter"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'I'	O
}	O
,	O
{	O
"borders"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'j'	O
}	O
,	O
{	O
"page-prefeed"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"no-page-prefeed"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'K'	O
}	O
,	O
{	O
"lineprinter"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"lines-per-page"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'L'	O
}	O
,	O
{	O
"mail"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'm'	O
}	O
,	O
{	O
"media"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'M'	O
}	O
,	O
{	O
"copies"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"newline"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'N'	O
}	O
,	O
{	O
"output"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"missing-characters"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'O'	O
}	O
,	O
{	O
"quiet"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'q'	O
}	O
,	O
{	O
"silent"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'q'	O
}	O
,	O
{	O
"landscape"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"portrait"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'R'	O
}	O
,	O
{	O
"baselineskip"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"statusdict"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"title"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"tabsize"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'T'	O
}	O
,	O
{	O
"underlay"	*(char)
,	O
optional_argument	int
,	O
0	int
,	O
'u'	O
}	O
,	O
{	O
"nup"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'U'	O
}	O
,	O
{	O
"verbose"	*(char)
,	O
optional_argument	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'V'	O
}	O
,	O
{	O
"language"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'w'	O
}	O
,	O
{	O
"option"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'W'	O
}	O
,	O
{	O
"encoding"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'X'	O
}	O
,	O
{	O
"no-formfeed"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'z'	O
}	O
,	O
{	O
"pass-through"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'Z'	O
}	O
,	O
{	O
"color"	*(char)
,	O
optional_argument	int
,	O
0	int
,	O
142	int
}	O
,	O
{	O
"continuous-page-numbers"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
156	int
}	O
,	O
{	O
"download-font"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
131	int
}	O
,	O
{	O
"extended-return-values"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
154	int
}	O
,	O
{	O
"filter-stdin"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
138	int
}	O
,	O
{	O
"footer"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
155	int
}	O
,	O
{	O
"h-column-height"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
148	int
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
135	int
}	O
,	O
{	O
"help-highlight"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
141	int
}	O
,	O
{	O
"highlight-bar-gray"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
136	int
}	O
,	O
{	O
"list-media"	*(char)
,	O
no_argument	int
,	O
&	O
list_media	int
,	O
1	int
}	O
,	O
{	O
"margins"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
144	int
}	O
,	O
{	O
"mark-wrapped-lines"	*(char)
,	O
optional_argument	int
,	O
0	int
,	O
143	int
}	O
,	O
{	O
"non-printable-format"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
134	int
}	O
,	O
{	O
"nup-columnwise"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
152	int
}	O
,	O
{	O
"nup-xpad"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
145	int
}	O
,	O
{	O
"nup-ypad"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
146	int
}	O
,	O
{	O
"page-label-format"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
130	int
}	O
,	O
{	O
"ps-level"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
149	int
}	O
,	O
{	O
"printer-options"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
139	int
}	O
,	O
{	O
"rotate-even-pages"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
150	int
}	O
,	O
{	O
"slice"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
140	int
}	O
,	O
{	O
"style"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
151	int
}	O
,	O
{	O
"swap-even-page-margins"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
153	int
}	O
,	O
{	O
"toc"	*(char)
,	O
no_argument	int
,	O
&	O
toc	int
,	O
1	int
}	O
,	O
{	O
"word-wrap"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
147	int
}	O
,	O
{	O
"ul-angle"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
132	int
}	O
,	O
{	O
"ul-font"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
128	int
}	O
,	O
{	O
"ul-gray"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
129	int
}	O
,	O
{	O
"ul-position"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
133	int
}	O
,	O
{	O
"ul-style"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
137	int
}	O
,	O
{	O
"pretty-print"	*(char)
,	O
optional_argument	int
,	O
0	int
,	O
'E'	O
}	O
,	O
{	O
"help-pretty-print"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
141	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
InputStream	struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int)
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
;	O
time_t	long
tim	long
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
int	O
i	int
,	O
j	int
,	O
found	int
;	O
unsigned	O
int	O
ui	int
;	O
MediaEntry	struct(*(struct(*(struct(*`,*`,int,int,int,int,int,int)),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int)
*	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
;	O
AFMError	int
afm_error	int
;	O
char	O
*	O
cp	*(char)
,	O
*	O
cp2	*(char)
;	O
int	O
retval	int
=	O
0	int
;	O
Buffer	struct(*(char),long,long)
buffer	*(struct(*(char),long,long))
;	O
buffer_init	(*(struct(*(char),long,long)))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
program	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
'/'	O
)	O
;	O
if	O
(	O
program	*(char)
==	O
NULL	O
)	O
program	*(char)
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
else	O
program	*(char)
++	O
;	O
argv	*(*(char))
[	O
0	int
]	O
=	O
program	*(char)
;	O
toc_fmt_string	*(char)
=	O
_	O
(	O
"$3v $-40N $3% pages $4L lines  $E $C"	*(char)
)	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_MESSAGES	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
tim	long
=	O
time	struct(long,long)
(	O
NULL	O
)	O
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
=	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
tim	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
sizeof	O
(	O
*	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
)	O
;	O
date_string	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
asctime	(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(*(char))
(	O
&	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
)	O
;	O
i	int
=	O
strlen	(*(char))->(long)
(	O
date_string	*(char)
)	O
;	O
date_string	*(char)
[	O
i	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
=	O
getpwuid	(int)->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
getuid	()->(int)
(	O
)	O
)	O
;	O
if	O
(	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
==	O
NULL	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"couldn't get passwd entry for uid=%d: %s"	*(char)
)	O
,	O
getuid	()->(int)
(	O
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
media_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"A4"	*(char)
)	O
;	O
encoding_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"88591"	*(char)
)	O
;	O
npf_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"octal"	*(char)
)	O
;	O
page_label_format	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"short"	*(char)
)	O
;	O
ul_style_str	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"outline"	*(char)
)	O
;	O
ul_position	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"+0-0"	*(char)
)	O
;	O
spooler_command	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"lpr"	*(char)
)	O
;	O
queue_param	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"-P"	*(char)
)	O
;	O
no_job_header_switch	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"-h"	*(char)
)	O
;	O
fancy_header_default	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"enscript"	*(char)
)	O
;	O
output_first_line	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"%!PS-Adobe-3.0"	*(char)
)	O
;	O
cp	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"ENSCRIPT_LIBRARY"	*(char)
)	O
;	O
if	O
(	O
cp	*(char)
)	O
enscript_library	*(char)
=	O
cp	*(char)
;	O
cp	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
;	O
if	O
(	O
cp	*(char)
==	O
NULL	O
)	O
cp	*(char)
=	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
->	O
pw_dir	*(char)
;	O
buffer_clear	(*(struct(*(char),long,long)))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
enscript_library	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
PATH_SEPARATOR_STR	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
cp	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
"/.enscript"	*(char)
)	O
;	O
libpath	*(char)
=	O
buffer_copy	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
states_binary	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"states"	*(char)
)	O
;	O
buffer_clear	(*(struct(*(char),long,long)))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
enscript_library	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
"/hl/enscript.st"	*(char)
)	O
;	O
states_config_file	*(char)
=	O
buffer_copy	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
states_highlight_style	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"emacs"	*(char)
)	O
;	O
buffer_clear	(*(struct(*(char),long,long)))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
cp	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
"/.enscript"	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
PATH_SEPARATOR_STR	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
enscript_library	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
"/hl"	*(char)
)	O
;	O
states_path	*(char)
=	O
buffer_copy	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
res_fonts	*(struct)
=	O
strhash_init	()->(*(struct))
(	O
)	O
;	O
download_fonts	*(struct)
=	O
strhash_init	()->(*(struct))
(	O
)	O
;	O
pagedevice	*(struct)
=	O
strhash_init	()->(*(struct))
(	O
)	O
;	O
statusdict	*(struct)
=	O
strhash_init	()->(*(struct))
(	O
)	O
;	O
user_strings	*(struct)
=	O
strhash_init	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
read_config	(*(char),*(char))->(int)
(	O
SYSCONFDIR	O
,	O
CFG_FILE_NAME	*(char)
)	O
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
if	O
(	O
!	O
read_config	(*(char),*(char))->(int)
(	O
enscript_library	*(char)
,	O
CFG_FILE_NAME	*(char)
)	O
)	O
{	O
buffer_clear	(*(struct(*(char),long,long)))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
enscript_library	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
"/../../etc"	*(char)
)	O
;	O
if	O
(	O
!	O
read_config	(*(char),*(char))->(int)
(	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
,	O
CFG_FILE_NAME	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
read_config	(*(char),*(char))->(int)
(	O
"../lib"	*(char)
,	O
CFG_FILE_NAME	*(char)
)	O
&&	O
!	O
read_config	(*(char),*(char))->(int)
(	O
"../../lib"	*(char)
,	O
CFG_FILE_NAME	*(char)
)	O
)	O
{	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"couldn't read config file \"%s/%s\": %s"	*(char)
)	O
,	O
enscript_library	*(char)
,	O
CFG_FILE_NAME	*(char)
,	O
strerror	(int)->(*(char))
(	O
saved_errno	int
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"I did also try the following directories:"	*(char)
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\t%s"	*(char)
)	O
,	O
SYSCONFDIR	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\t%s"	*(char)
)	O
,	O
enscript_library	*(char)
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\t%s"	*(char)
)	O
,	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\t../lib"	*(char)
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\t../../lib"	*(char)
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"This is probably an installation error.  Please, try to rebuild:"	*(char)
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\tmake distclean"	*(char)
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\t./configure --prefix=PREFIX"	*(char)
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\tmake"	*(char)
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\tmake check"	*(char)
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\tmake install"	*(char)
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"or set the environment variable `ENSCRIPT_LIBRARY'"	*(char)
" to point to your library directory."	*(char)
)	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
buffer_clear	(*(struct(*(char),long,long)))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
libpath	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
PATH_SEPARATOR_STR	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
"../lib"	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
PATH_SEPARATOR_STR	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
"../../lib"	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
libpath	*(char)
)	O
;	O
libpath	*(char)
=	O
buffer_copy	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
}	O
}	O
}	O
read_config	(*(char),*(char))->(int)
(	O
SYSCONFDIR	O
,	O
"enscriptsite.cfg"	*(char)
)	O
;	O
read_config	(*(char),*(char))->(int)
(	O
cp	*(char)
,	O
".enscriptrc"	*(char)
)	O
;	O
handle_env_options	(*(char))->(void)
(	O
"ENSCRIPT"	*(char)
)	O
;	O
handle_env_options	(*(char))->(void)
(	O
"GENSCRIPT"	*(char)
)	O
;	O
handle_options	(int,array(*(char)))->(void)
(	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
default_escape_char	int
=	O
escape_char	int
;	O
found	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
!	O
found	int
&&	O
encodings	array(struct(array(*(char)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int))
[	O
i	int
]	O
.	O
names	array(*(char))
[	O
0	int
]	O
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
3	int
;	O
j	int
++	O
)	O
if	O
(	O
encodings	array(struct(array(*(char)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int))
[	O
i	int
]	O
.	O
names	array(*(char))
[	O
j	int
]	O
!=	O
NULL	O
&&	O
MATCH	O
(	O
encodings	array(struct(array(*(char)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int))
[	O
i	int
]	O
.	O
names	array(*(char))
[	O
j	int
]	O
,	O
encoding_name	*(char)
)	O
)	O
{	O
encoding	array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char))))))
=	O
encodings	array(struct(array(*(char)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int))
[	O
i	int
]	O
.	O
encoding	array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char))))))
;	O
xfree	(*(void))->(void)
(	O
encoding_name	*(char)
)	O
;	O
encoding_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
encodings	array(struct(array(*(char)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int))
[	O
i	int
]	O
.	O
names	array(*(char))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
nl	int
<	O
0	int
)	O
nl	int
=	O
encodings	array(struct(array(*(char)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int))
[	O
i	int
]	O
.	O
nl	int
;	O
bs	int
=	O
encodings	array(struct(array(*(char)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int))
[	O
i	int
]	O
.	O
bs	int
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
found	int
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"unknown encoding: %s"	*(char)
)	O
,	O
encoding_name	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
user_body_font_defined	int
&&	O
landscape	int
&&	O
num_columns	int
>	O
1	int
)	O
Fpt	struct(double,double)
.	O
w	int
=	O
Fpt	struct(double,double)
.	O
h	int
=	O
7.0	int
;	O
afm_cache	*(struct)
=	O
strhash_init	()->(*(struct))
(	O
)	O
;	O
afm_info_cache	*(struct)
=	O
strhash_init	()->(*(struct))
(	O
)	O
;	O
afm_error	int
=	O
afm_create	(*(char),int,*(*(struct)))->(int)
(	O
afm_path	*(char)
,	O
verbose	int
,	O
&	O
afm	*(struct)
)	O
;	O
if	O
(	O
afm_error	int
!=	O
AFM_SUCCESS	int
)	O
{	O
char	O
buf	*(char)
[	O
256	int
]	O
;	O
afm_error_to_string	(int,*(char))->(void)
(	O
afm_error	int
,	O
buf	*(char)
)	O
;	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"couldn't open AFM library: %s"	*(char)
)	O
,	O
buf	*(char)
)	O
)	O
;	O
}	O
default_Fpt	struct(double,double)
.	O
w	int
=	O
Fpt	struct(double,double)
.	O
w	int
;	O
default_Fpt	struct(double,double)
.	O
h	int
=	O
Fpt	struct(double,double)
.	O
h	int
;	O
default_Fname	*(char)
=	O
Fname	*(char)
;	O
default_Fencoding	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
encoding	array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char))))))
;	O
strhash_put	(*(struct),*(char),int,*(void),*(*(void)))->(int)
(	O
res_fonts	*(struct)
,	O
Fname	*(char)
,	O
strlen	(*(char))->(long)
(	O
Fname	*(char)
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
strhash_put	(*(struct),*(char),int,*(void),*(*(void)))->(int)
(	O
res_fonts	*(struct)
,	O
HFname	*(char)
,	O
strlen	(*(char))->(long)
(	O
HFname	*(char)
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
strhash_put	(*(struct),*(char),int,*(void),*(*(void)))->(int)
(	O
download_fonts	*(struct)
,	O
Fname	*(char)
,	O
strlen	(*(char))->(long)
(	O
Fname	*(char)
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
strhash_put	(*(struct),*(char),int,*(void),*(*(void)))->(int)
(	O
download_fonts	*(struct)
,	O
HFname	*(char)
,	O
strlen	(*(char))->(long)
(	O
HFname	*(char)
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
read_font_info	()->(void)
(	O
)	O
;	O
line_indent	double
=	O
parse_float	(*(char),int,int)->(double)
(	O
line_indent_spec	*(char)
,	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
list_media	int
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"known media:\nname             width\theight\tllx\tlly\turx\tury\n------------------------------------------------------------\n"	*(char)
)	O
)	O
;	O
for	O
(	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
=	O
media_names	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
;	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
;	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
=	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
)	O
printf	(*(char))->(int)
(	O
"%-16s %d\t%d\t%d\t%d\t%d\t%d\n"	*(char)
,	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
name	*(char)
,	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
w	int
,	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
h	int
,	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
llx	double
,	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
lly	double
,	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
urx	double
,	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
ury	double
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
for	O
(	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
=	O
media_names	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
;	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
;	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
=	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
media_name	*(char)
,	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
=	O
mentry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
;	O
break	O
;	O
}	O
if	O
(	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
==	O
NULL	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"do not know anything about media \"%s\""	*(char)
)	O
,	O
media_name	*(char)
)	O
)	O
;	O
if	O
(	O
margins_spec	*(char)
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
*	O
margins_spec	*(char)
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
*	O
margins_spec	*(char)
==	O
':'	O
)	O
{	O
margins_spec	*(char)
++	O
;	O
continue	O
;	O
}	O
j	int
=	O
atoi	(*(char))->(int)
(	O
margins_spec	*(char)
)	O
;	O
for	O
(	O
;	O
*	O
margins_spec	*(char)
!=	O
':'	O
&&	O
*	O
margins_spec	*(char)
!=	O
'\0'	O
;	O
margins_spec	*(char)
++	O
)	O
;	O
if	O
(	O
*	O
margins_spec	*(char)
==	O
':'	O
)	O
margins_spec	*(char)
++	O
;	O
switch	O
(	O
i	int
)	O
{	O
case	O
0	int
:	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
llx	double
=	O
j	int
;	O
break	O
;	O
case	O
1	int
:	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
urx	double
=	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
w	int
-	O
j	int
;	O
break	O
;	O
case	O
2	int
:	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
ury	double
=	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
h	int
-	O
j	int
;	O
break	O
;	O
case	O
3	int
:	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
lly	double
=	O
j	int
;	O
break	O
;	O
}	O
}	O
MESSAGE	O
(	O
1	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"set new marginals for media `%s' (%dx%d): llx=%d, lly=%d, urx=%d, ury=%d\n"	*(char)
)	O
,	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
name	*(char)
,	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
w	int
,	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
h	int
,	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
llx	double
,	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
lly	double
,	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
urx	double
,	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
ury	double
)	O
)	O
;	O
}	O
if	O
(	O
MATCH	O
(	O
page_label_format	*(char)
,	O
"short"	*(char)
)	O
)	O
page_label	enum(int,int)
=	O
LABEL_SHORT	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
page_label_format	*(char)
,	O
"long"	*(char)
)	O
)	O
page_label	enum(int,int)
=	O
LABEL_LONG	int
;	O
else	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"illegal page label format \"%s\""	*(char)
)	O
,	O
page_label_format	*(char)
)	O
)	O
;	O
if	O
(	O
MATCH	O
(	O
npf_name	*(char)
,	O
"space"	*(char)
)	O
)	O
non_printable_format	enum(int,int,int,int)
=	O
NPF_SPACE	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
npf_name	*(char)
,	O
"questionmark"	*(char)
)	O
)	O
non_printable_format	enum(int,int,int,int)
=	O
NPF_QUESTIONMARK	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
npf_name	*(char)
,	O
"caret"	*(char)
)	O
)	O
non_printable_format	enum(int,int,int,int)
=	O
NPF_CARET	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
npf_name	*(char)
,	O
"octal"	*(char)
)	O
)	O
non_printable_format	enum(int,int,int,int)
=	O
NPF_OCTAL	int
;	O
else	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"illegal non-printable format \"%s\""	*(char)
)	O
,	O
npf_name	*(char)
)	O
)	O
;	O
if	O
(	O
mark_wrapped_lines_style_name	*(char)
)	O
{	O
if	O
(	O
MATCH	O
(	O
mark_wrapped_lines_style_name	*(char)
,	O
"none"	*(char)
)	O
)	O
mark_wrapped_lines_style	enum(int,int,int,int)
=	O
MWLS_NONE	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
mark_wrapped_lines_style_name	*(char)
,	O
"plus"	*(char)
)	O
)	O
mark_wrapped_lines_style	enum(int,int,int,int)
=	O
MWLS_PLUS	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
mark_wrapped_lines_style_name	*(char)
,	O
"box"	*(char)
)	O
)	O
mark_wrapped_lines_style	enum(int,int,int,int)
=	O
MWLS_BOX	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
mark_wrapped_lines_style_name	*(char)
,	O
"arrow"	*(char)
)	O
)	O
mark_wrapped_lines_style	enum(int,int,int,int)
=	O
MWLS_ARROW	int
;	O
else	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"illegal style for wrapped line marker: \"%s\""	*(char)
)	O
,	O
mark_wrapped_lines_style_name	*(char)
)	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
;	O
i	int
++	O
)	O
{	O
ui	int
=	O
nup	int
>>	O
i	int
;	O
if	O
(	O
ui	int
==	O
0	int
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"illegal N-up argument: %d"	*(char)
)	O
,	O
nup	int
)	O
)	O
;	O
if	O
(	O
ui	int
&	O
0x1	int
)	O
{	O
if	O
(	O
ui	int
!=	O
1	int
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"N-up argument must be power of 2: %d"	*(char)
)	O
,	O
nup	int
)	O
)	O
;	O
nup_exp	int
=	O
i	int
;	O
break	O
;	O
}	O
}	O
nup_rows	int
=	O
nup_exp	int
/	O
2	int
*	O
2	int
;	O
if	O
(	O
nup_rows	int
==	O
0	int
)	O
nup_rows	int
=	O
1	int
;	O
nup_columns	int
=	O
(	O
nup_exp	int
+	O
1	int
)	O
/	O
2	int
*	O
2	int
;	O
if	O
(	O
nup_columns	int
==	O
0	int
)	O
nup_columns	int
=	O
1	int
;	O
nup_landscape	int
=	O
nup_exp	int
&	O
0x1	int
;	O
if	O
(	O
landscape	int
)	O
{	O
d_page_w	int
=	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
ury	double
-	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
lly	double
;	O
d_page_h	int
=	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
urx	double
-	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
llx	double
;	O
}	O
else	O
{	O
d_page_w	int
=	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
urx	double
-	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
llx	double
;	O
d_page_h	int
=	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
ury	double
-	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
lly	double
;	O
}	O
if	O
(	O
nup_landscape	int
)	O
{	O
nup_width	int
=	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
ury	double
-	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
lly	double
;	O
nup_height	int
=	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
urx	double
-	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
llx	double
;	O
}	O
else	O
{	O
nup_width	int
=	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
urx	double
-	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
llx	double
;	O
nup_height	int
=	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
ury	double
-	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
lly	double
;	O
}	O
{	O
double	O
w	int
,	O
h	int
;	O
w	int
=	O
(	O
(	O
double	O
)	O
nup_width	int
-	O
(	O
nup_columns	int
-	O
1	int
)	O
*	O
nup_xpad	int
)	O
/	O
nup_columns	int
;	O
h	int
=	O
(	O
(	O
double	O
)	O
nup_height	int
-	O
(	O
nup_rows	int
-	O
1	int
)	O
*	O
nup_ypad	int
)	O
/	O
nup_rows	int
;	O
nup_width	int
=	O
w	int
;	O
nup_height	int
=	O
h	int
;	O
w	int
=	O
w	int
/	O
(	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
urx	double
-	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
llx	double
)	O
;	O
h	int
=	O
h	int
/	O
(	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
ury	double
-	O
media	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
lly	double
)	O
;	O
nup_scale	double
=	O
w	int
<	O
h	int
?	O
w	int
:	O
h	int
;	O
}	O
if	O
(	O
underlay	*(char)
!=	O
NULL	O
)	O
{	O
strhash_put	(*(struct),*(char),int,*(void),*(*(void)))->(int)
(	O
res_fonts	*(struct)
,	O
ul_font	*(char)
,	O
strlen	(*(char))->(long)
(	O
ul_font	*(char)
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
underlay	*(char)
=	O
escape_string	(*(char))->(*(char))
(	O
underlay	*(char)
)	O
;	O
}	O
ul_x	double
=	O
strtod	(*(char),*(*(char)))->(double)
(	O
ul_position	*(char)
,	O
&	O
cp	*(char)
)	O
;	O
if	O
(	O
cp	*(char)
==	O
ul_position	*(char)
)	O
{	O
malformed_position	O
:	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"malformed underlay position: %s"	*(char)
)	O
,	O
ul_position	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
ul_position	*(char)
[	O
0	int
]	O
==	O
'-'	O
)	O
ul_x	double
+=	O
d_page_w	int
;	O
ul_y	double
=	O
strtod	(*(char),*(*(char)))->(double)
(	O
cp	*(char)
,	O
&	O
cp2	*(char)
)	O
;	O
if	O
(	O
cp2	*(char)
==	O
cp	*(char)
)	O
goto	O
malformed_position	O
;	O
if	O
(	O
cp	*(char)
[	O
0	int
]	O
==	O
'-'	O
)	O
ul_y	double
+=	O
d_page_h	int
;	O
if	O
(	O
!	O
ul_angle_p	int
)	O
ul_angle	double
=	O
(	O
atan2	(double,double)->(double)
(	O
-	O
d_page_h	int
,	O
d_page_w	int
)	O
/	O
3.14159265	int
*	O
180	int
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ul_style_str	*(char)
,	O
"outline"	*(char)
)	O
==	O
0	int
)	O
ul_style	int
=	O
UL_STYLE_OUTLINE	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ul_style_str	*(char)
,	O
"filled"	*(char)
)	O
==	O
0	int
)	O
ul_style	int
=	O
UL_STYLE_FILLED	int
;	O
else	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"illegal underlay style: %s"	*(char)
)	O
,	O
ul_style_str	*(char)
)	O
)	O
;	O
d_header_w	int
=	O
d_page_w	int
;	O
switch	O
(	O
header	enum(int,int,int)
)	O
{	O
case	O
HDR_NONE	int
:	O
d_header_h	int
=	O
0	int
;	O
break	O
;	O
case	O
HDR_SIMPLE	int
:	O
d_header_h	int
=	O
HFpt	struct(double,double)
.	O
h	int
*	O
1.5	int
;	O
break	O
;	O
case	O
HDR_FANCY	int
:	O
d_header_h	int
=	O
36	int
;	O
break	O
;	O
}	O
if	O
(	O
help_highlight	int
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Highlighting is supported for the following languages and file formats:\n\n"	*(char)
)	O
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
buffer_clear	(*(struct(*(char),long,long)))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
states_binary	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
" -f \""	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
states_config_file	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
"\" -p \""	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
states_path	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
"\" -s describe_languages "	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
enscript_library	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
"/hl/*.st"	*(char)
)	O
;	O
system	(*(char))->(int)
(	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
if	O
(	O
output_language_pass_through	int
)	O
{	O
char	O
*	O
start_state	*(char)
;	O
Buffer	struct(*(char),long,long)
cmd	*(char)
;	O
char	O
intbuf	array(char)
[	O
256	int
]	O
;	O
if	O
(	O
hl_start_state	*(char)
)	O
start_state	*(char)
=	O
hl_start_state	*(char)
;	O
else	O
if	O
(	O
highlight	int
)	O
start_state	*(char)
=	O
NULL	O
;	O
else	O
start_state	*(char)
=	O
"passthrough"	*(char)
;	O
buffer_init	(*(struct(*(char),long,long)))->(void)
(	O
&	O
cmd	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
states_binary	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
" -f \""	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
states_config_file	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
"\" -p \""	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
states_path	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
"\" "	*(char)
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
"-v "	*(char)
)	O
;	O
if	O
(	O
start_state	*(char)
)	O
{	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
"-s"	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
start_state	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
" "	*(char)
)	O
;	O
}	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
"-Dcolor="	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
states_color	int
?	O
"1"	*(char)
:	O
"0"	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
" "	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
"-Dstyle="	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
states_highlight_style	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
" "	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
"-Dlanguage="	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
output_language	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
" "	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
"-Dnum_input_files="	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
intbuf	array(char)
,	O
"%d"	*(char)
,	O
optind	int
==	O
argc	int
?	O
1	int
:	O
argc	int
-	O
optind	int
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
intbuf	array(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
" "	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
"-Ddocument_title=\'"	*(char)
)	O
;	O
if	O
(	O
(	O
cp	*(char)
=	O
shell_escape	(*(char))->(*(char))
(	O
title	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
cp	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cp	*(char)
)	O
;	O
}	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
"\' "	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
"-Dtoc="	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
toc	int
?	O
"1"	*(char)
:	O
"0"	*(char)
)	O
;	O
if	O
(	O
helper_options	array(*(struct(*(char),long,long)))
[	O
's'	O
]	O
)	O
{	O
Buffer	struct(*(char),long,long)
*	O
opts	*(struct(*(char),long,long))
=	O
helper_options	array(*(struct(*(char),long,long)))
[	O
's'	O
]	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
" "	*(char)
)	O
;	O
buffer_append_len	(*(struct(*(char),long,long)),*(char),long)->(void)
(	O
&	O
cmd	*(char)
,	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
opts	*(struct(*(char),long,long))
)	O
,	O
buffer_len	(*(struct(*(char),long,long)))->(long)
(	O
opts	*(struct(*(char),long,long))
)	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
optind	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
cp	*(char)
;	O
if	O
(	O
(	O
cp	*(char)
=	O
shell_escape	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
" \'"	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
cp	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
cmd	*(char)
,	O
"\'"	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cp	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
is_open	(*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char))->(int)
(	O
&	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
NULL	O
,	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
cmd	*(char)
)	O
)	O
)	O
{	O
open_output_file	()->(void)
(	O
)	O
;	O
process_file	(*(char),*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)),int)->(void)
(	O
"unused"	*(char)
,	O
&	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
,	O
0	int
)	O
;	O
is_close	(*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)))->(void)
(	O
&	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
)	O
;	O
}	O
buffer_uninit	(*(struct(*(char),long,long)))->(void)
(	O
&	O
cmd	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
highlight	int
)	O
{	O
char	O
fbuf	array(char)
[	O
256	int
]	O
;	O
buffer_clear	(*(struct(*(char),long,long)))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
states_binary	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
" -f \""	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
states_config_file	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
"\" -p \""	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
states_path	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
"\""	*(char)
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
" -v"	*(char)
)	O
;	O
if	O
(	O
hl_start_state	*(char)
)	O
{	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
" -s "	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
hl_start_state	*(char)
)	O
;	O
}	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
" -Dcolor="	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
states_color	int
?	O
"1"	*(char)
:	O
"0"	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
" -Dstyle="	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
states_highlight_style	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
" -Dfont_spec="	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
Fname	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
fbuf	array(char)
,	O
"@%g/%g"	*(char)
,	O
Fpt	struct(double,double)
.	O
w	int
,	O
Fpt	struct(double,double)
.	O
h	int
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
fbuf	array(char)
)	O
;	O
if	O
(	O
helper_options	array(*(struct(*(char),long,long)))
[	O
's'	O
]	O
)	O
{	O
Buffer	struct(*(char),long,long)
*	O
opts	*(struct(*(char),long,long))
=	O
helper_options	array(*(struct(*(char),long,long)))
[	O
's'	O
]	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
" "	*(char)
)	O
;	O
buffer_append_len	(*(struct(*(char),long,long)),*(char),long)->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
opts	*(struct(*(char),long,long))
)	O
,	O
buffer_len	(*(struct(*(char),long,long)))->(long)
(	O
opts	*(struct(*(char),long,long))
)	O
)	O
;	O
}	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
" \'%s\'"	*(char)
)	O
;	O
input_filter	*(char)
=	O
buffer_copy	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
input_filter_stdin	*(char)
=	O
"-"	*(char)
;	O
}	O
if	O
(	O
toc	int
)	O
{	O
toc_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
tmpfile	()->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
)	O
;	O
if	O
(	O
toc_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"couldn't create temporary toc file: %s"	*(char)
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
}	O
if	O
(	O
optind	int
==	O
argc	int
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
&	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
sizeof	O
(	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
)	O
;	O
if	O
(	O
is_open	(*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char))->(int)
(	O
&	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
NULL	O
,	O
input_filter	*(char)
)	O
)	O
{	O
open_output_file	()->(void)
(	O
)	O
;	O
process_file	(*(char),*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)),int)->(void)
(	O
title_given	int
?	O
title	*(char)
:	O
""	*(char)
,	O
&	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
,	O
0	int
)	O
;	O
is_close	(*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)))->(void)
(	O
&	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
;	O
optind	int
<	O
argc	int
;	O
optind	int
++	O
)	O
{	O
if	O
(	O
is_open	(*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char))->(int)
(	O
&	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
,	O
NULL	O
,	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
input_filter	*(char)
)	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
stat_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
&	O
stat_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
)	O
{	O
tim	long
=	O
stat_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
=	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
tim	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
sizeof	O
(	O
*	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
)	O
;	O
open_output_file	()->(void)
(	O
)	O
;	O
process_file	(*(char),*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)),int)->(void)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
&	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
,	O
0	int
)	O
;	O
}	O
else	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"couldn't stat input file \"%s\": %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
is_close	(*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)))->(void)
(	O
&	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
)	O
;	O
}	O
}	O
}	O
if	O
(	O
toc	int
)	O
{	O
toc	int
=	O
0	int
;	O
special_escapes	int
=	O
1	int
;	O
line_numbers	int
=	O
0	int
;	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
toc_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"couldn't rewind toc file: %s"	*(char)
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
&	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
sizeof	O
(	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
)	O
;	O
if	O
(	O
is_open	(*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char))->(int)
(	O
&	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
,	O
toc_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
NULL	O
,	O
NULL	O
)	O
)	O
{	O
process_file	(*(char),*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)),int)->(void)
(	O
_	O
(	O
"Table of Contents"	*(char)
)	O
,	O
&	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
,	O
1	int
)	O
;	O
is_close	(*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)))->(void)
(	O
&	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
)	O
;	O
}	O
}	O
dump_ps_trailer	()->(void)
(	O
)	O
;	O
if	O
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
&&	O
append_ctrl_D	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\004\n"	*(char)
)	O
;	O
}	O
close_output_file	()->(void)
(	O
)	O
;	O
if	O
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"no output generated\n"	*(char)
)	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
output_language_pass_through	int
)	O
{	O
if	O
(	O
output_file	*(char)
==	O
OUTPUT_FILE_NONE	O
)	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"output sent to %s\n"	*(char)
)	O
,	O
printer	*(char)
?	O
printer	*(char)
:	O
_	O
(	O
"printer"	*(char)
)	O
)	O
)	O
;	O
else	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"output left in %s\n"	*(char)
)	O
,	O
output_file	*(char)
==	O
OUTPUT_FILE_STDOUT	O
?	O
"-"	*(char)
:	O
output_file	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
unsigned	O
int	O
real_total_pages	int
;	O
if	O
(	O
nup	int
>	O
1	int
)	O
{	O
if	O
(	O
total_pages	int
>	O
0	int
)	O
real_total_pages	int
=	O
(	O
total_pages	int
-	O
1	int
)	O
/	O
nup	int
+	O
1	int
;	O
else	O
real_total_pages	int
=	O
0	int
;	O
}	O
else	O
real_total_pages	int
=	O
total_pages	int
;	O
char	O
message	array(char)
[	O
80	int
]	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
message	array(char)
,	O
sizeof	O
message	array(char)
,	O
"%s%s%s%s%s"	*(char)
,	O
"[ "	*(char)
,	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"%d page"	*(char)
,	O
"%d pages"	*(char)
,	O
real_total_pages	int
)	O
,	O
" * "	*(char)
,	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"%d copy"	*(char)
,	O
"%d copies"	*(char)
,	O
num_copies	int
)	O
,	O
" ]"	*(char)
)	O
;	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
message	array(char)
,	O
real_total_pages	int
,	O
num_copies	int
)	O
)	O
;	O
if	O
(	O
output_file	*(char)
==	O
OUTPUT_FILE_NONE	O
)	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
" sent to %s\n"	*(char)
)	O
,	O
printer	*(char)
?	O
printer	*(char)
:	O
_	O
(	O
"printer"	*(char)
)	O
)	O
)	O
;	O
else	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
" left in %s\n"	*(char)
)	O
,	O
output_file	*(char)
==	O
OUTPUT_FILE_STDOUT	O
?	O
"-"	*(char)
:	O
output_file	*(char)
)	O
)	O
;	O
if	O
(	O
num_truncated_lines	int
)	O
{	O
retval	int
|=	O
2	int
;	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"%d line was %s\n"	*(char)
,	O
"%d lines were %s\n"	*(char)
,	O
num_truncated_lines	int
)	O
,	O
num_truncated_lines	int
,	O
line_end	enum(int,int,int)
==	O
LE_TRUNCATE	int
?	O
_	O
(	O
"truncated"	*(char)
)	O
:	O
_	O
(	O
"wrapped"	*(char)
)	O
)	O
)	O
;	O
}	O
if	O
(	O
num_missing_chars	int
)	O
{	O
retval	int
|=	O
4	int
;	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"%d character was missing\n"	*(char)
,	O
"%d characters were missing\n"	*(char)
,	O
num_missing_chars	int
)	O
,	O
num_missing_chars	int
)	O
)	O
;	O
if	O
(	O
list_missing_characters	int
)	O
{	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"missing character codes (decimal):\n"	*(char)
)	O
)	O
)	O
;	O
do_list_missing_characters	(*(int))->(void)
(	O
missing_chars	array(int)
)	O
;	O
}	O
}	O
if	O
(	O
num_non_printable_chars	int
)	O
{	O
retval	int
|=	O
8	int
;	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"%d non-printable character\n"	*(char)
,	O
"%d non-printable characters\n"	*(char)
,	O
num_non_printable_chars	int
)	O
,	O
num_non_printable_chars	int
)	O
)	O
;	O
if	O
(	O
list_missing_characters	int
)	O
{	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"non-printable character codes (decimal):\n"	*(char)
)	O
)	O
)	O
;	O
do_list_missing_characters	(*(int))->(void)
(	O
non_printable_chars	array(int)
)	O
;	O
}	O
}	O
}	O
buffer_uninit	(*(struct(*(char),long,long)))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
if	O
(	O
!	O
extended_return_values	int
)	O
retval	int
=	O
0	int
;	O
return	O
retval	int
;	O
}	O
static	O
void	O
open_output_file	()->(void)
(	O
)	O
{	O
if	O
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
return	O
;	O
if	O
(	O
output_file	*(char)
==	O
OUTPUT_FILE_NONE	O
)	O
{	O
char	O
spooler_options	array(char)
[	O
512	int
]	O
;	O
spooler_options	array(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
mail	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
spooler_options	array(char)
,	O
"-m "	*(char)
)	O
;	O
if	O
(	O
no_job_header	int
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
spooler_options	array(char)
,	O
no_job_header_switch	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
spooler_options	array(char)
,	O
" "	*(char)
)	O
;	O
}	O
if	O
(	O
printer_options	*(char)
)	O
strcat	(*(char),*(char))->(*(char))
(	O
spooler_options	array(char)
,	O
printer_options	*(char)
)	O
;	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
printer_open	(*(char),*(char),*(char),*(char),*(*(void)))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
spooler_command	*(char)
,	O
spooler_options	array(char)
,	O
queue_param	*(char)
,	O
printer	*(char)
,	O
&	O
printer_context	*(void)
)	O
;	O
if	O
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"couldn't open printer `%s': %s"	*(char)
)	O
,	O
printer	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
output_file	*(char)
==	O
OUTPUT_FILE_STDOUT	O
)	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
{	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
output_file	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"couldn't create output file \"%s\": %s"	*(char)
)	O
,	O
output_file	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
}	O
}	O
static	O
void	O
close_output_file	()->(void)
(	O
)	O
{	O
if	O
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
output_file	*(char)
==	O
OUTPUT_FILE_NONE	O
)	O
printer_close	(*(void))->(void)
(	O
printer_context	*(void)
)	O
;	O
else	O
if	O
(	O
output_file	*(char)
!=	O
OUTPUT_FILE_STDOUT	O
)	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"couldn't close output file \"%s\": %s"	*(char)
)	O
,	O
output_file	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
}	O
static	O
void	O
handle_env_options	(*(char))->(void)
(	O
char	O
*	O
var	*(char)
)	O
{	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	*(*(char))
;	O
char	O
*	O
string	*(char)
;	O
char	O
*	O
str	*(char)
;	O
int	O
i	int
;	O
string	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
var	*(char)
)	O
;	O
if	O
(	O
string	*(char)
==	O
NULL	O
)	O
return	O
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"handle_env_options(): %s=\"%s\"\n"	*(char)
,	O
var	*(char)
,	O
string	*(char)
)	O
)	O
;	O
str	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
string	*(char)
)	O
;	O
argc	int
=	O
(	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
+	O
1	int
)	O
/	O
2	int
+	O
2	int
;	O
argv	*(*(char))
=	O
xcalloc	(long,long)->(*(void))
(	O
argc	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
argc	int
=	O
0	int
;	O
argv	*(*(char))
[	O
argc	int
++	O
]	O
=	O
program	*(char)
;	O
i	int
=	O
0	int
;	O
while	O
(	O
str	*(char)
[	O
i	int
]	O
)	O
{	O
for	O
(	O
;	O
str	*(char)
[	O
i	int
]	O
&&	O
isspace	(int)->(int)
(	O
str	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
!	O
str	*(char)
[	O
i	int
]	O
)	O
break	O
;	O
if	O
(	O
str	*(char)
[	O
i	int
]	O
==	O
'"'	O
||	O
str	*(char)
[	O
i	int
]	O
==	O
'\''	O
)	O
{	O
int	O
endch	int
=	O
str	*(char)
[	O
i	int
++	O
]	O
;	O
argv	*(*(char))
[	O
argc	int
++	O
]	O
=	O
str	*(char)
+	O
i	int
;	O
for	O
(	O
;	O
str	*(char)
[	O
i	int
]	O
&&	O
str	*(char)
[	O
i	int
]	O
!=	O
endch	int
;	O
i	int
++	O
)	O
;	O
if	O
(	O
!	O
str	*(char)
[	O
i	int
]	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"syntax error in option string %s=\"%s\":\nmissing end of quotation: %c"	*(char)
)	O
,	O
var	*(char)
,	O
string	*(char)
,	O
endch	int
)	O
)	O
;	O
str	*(char)
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
argv	*(*(char))
[	O
argc	int
++	O
]	O
=	O
str	*(char)
+	O
i	int
;	O
for	O
(	O
;	O
str	*(char)
[	O
i	int
]	O
&&	O
!	O
isspace	(int)->(int)
(	O
str	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
str	*(char)
[	O
i	int
]	O
)	O
str	*(char)
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
}	O
}	O
argv	*(*(char))
[	O
argc	int
]	O
=	O
NULL	O
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"found following options (argc=%d):\n"	*(char)
,	O
argc	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%3d = \"%s\"\n"	*(char)
,	O
i	int
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
)	O
;	O
handle_options	(int,array(*(char)))->(void)
(	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
if	O
(	O
optind	int
!=	O
argc	int
)	O
{	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"warning: didn't process following options from environment variable %s:\n"	*(char)
)	O
,	O
var	*(char)
)	O
)	O
;	O
for	O
(	O
;	O
optind	int
<	O
argc	int
;	O
optind	int
++	O
)	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  option %d = \"%s\"\n"	*(char)
)	O
,	O
optind	int
,	O
argv	*(*(char))
[	O
optind	int
]	O
)	O
)	O
;	O
}	O
xfree	(*(void))->(void)
(	O
argv	*(*(char))
)	O
;	O
}	O
static	O
void	O
handle_options	(int,array(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
int	O
c	int
;	O
PageRange	struct(*(struct(*(struct(*`,int,int,int,int)),int,int,int,int)),int,int,int,int)
*	O
prange	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
;	O
optind	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
int	O
option_index	int
=	O
0	int
;	O
const	O
char	O
*	O
cp	*(char)
;	O
int	O
i	int
;	O
c	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"#:123456789a:A:b:BcC::d:D:e::E::f:F:gGhH::i:I:jJ:kKlL:mM:n:N:o:Op:P:qrRs:S:t:T:u::U:vVw:W:X:zZ"	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
&	O
option_index	int
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
0	int
:	O
cp	*(char)
=	O
long_options	array(struct(*(char),int,*(int),int))
[	O
option_index	int
]	O
.	O
name	*(char)
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cp	*(char)
,	O
"columns"	*(char)
)	O
==	O
0	int
)	O
{	O
num_columns	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
num_columns	int
<	O
1	int
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"number of columns must be larger than zero"	*(char)
)	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
num_columns	int
=	O
c	int
-	O
'0'	O
;	O
break	O
;	O
case	O
'a'	O
:	O
prange	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
=	O
(	O
PageRange	struct(*(struct(*(struct(*`,int,int,int,int)),int,int,int,int)),int,int,int,int)
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
PageRange	struct(*(struct(*(struct(*`,int,int,int,int)),int,int,int,int)),int,int,int,int)
)	O
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"odd"	*(char)
)	O
==	O
0	int
)	O
prange	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
->	O
odd	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"even"	*(char)
)	O
==	O
0	int
)	O
prange	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
->	O
even	int
=	O
1	int
;	O
else	O
{	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
optarg	*(char)
,	O
'-'	O
)	O
;	O
if	O
(	O
cp	*(char)
)	O
{	O
if	O
(	O
optarg	*(char)
[	O
0	int
]	O
==	O
'-'	O
)	O
prange	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
->	O
end	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
+	O
1	int
)	O
;	O
else	O
if	O
(	O
cp	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
prange	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
->	O
start	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
prange	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
->	O
end	int
=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
;	O
}	O
else	O
{	O
prange	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
->	O
start	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
prange	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
->	O
end	int
=	O
atoi	(*(char))->(int)
(	O
cp	*(char)
+	O
1	int
)	O
;	O
}	O
}	O
else	O
prange	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
->	O
start	int
=	O
prange	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
->	O
end	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
}	O
prange	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
=	O
page_ranges	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
;	O
page_ranges	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
=	O
prange	*(struct(*(struct(*(struct`),int,int,int,int)),int,int,int,int))
;	O
break	O
;	O
case	O
'A'	O
:	O
file_align	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
file_align	int
==	O
0	int
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"file alignment must be larger than zero"	*(char)
)	O
)	O
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
page_header	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'B'	O
:	O
header	enum(int,int,int)
=	O
HDR_NONE	int
;	O
break	O
;	O
case	O
'c'	O
:	O
line_end	enum(int,int,int)
=	O
LE_TRUNCATE	int
;	O
break	O
;	O
case	O
'C'	O
:	O
line_numbers	int
=	O
1	int
;	O
if	O
(	O
optarg	*(char)
)	O
start_line_number	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
case	O
'P'	O
:	O
xfree	(*(void))->(void)
(	O
printer	*(char)
)	O
;	O
printer	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
output_file	*(char)
=	O
OUTPUT_FILE_NONE	O
;	O
break	O
;	O
case	O
'D'	O
:	O
parse_key_value_pair	(*(struct),*(char))->(void)
(	O
pagedevice	*(struct)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
special_escapes	int
=	O
1	int
;	O
if	O
(	O
optarg	*(char)
)	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
optarg	*(char)
[	O
0	int
]	O
)	O
)	O
escape_char	int
=	O
(	O
int	O
)	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
NULL	O
,	O
0	int
)	O
;	O
else	O
escape_char	int
=	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
optarg	*(char)
)	O
[	O
0	int
]	O
;	O
}	O
break	O
;	O
case	O
'E'	O
:	O
highlight	int
=	O
1	int
;	O
special_escapes	int
=	O
1	int
;	O
escape_char	int
=	O
'\0'	O
;	O
hl_start_state	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
!	O
parse_font_spec	(*(char),*(*(char)),*(struct(double,double)),*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))->(int)
(	O
optarg	*(char)
,	O
&	O
Fname	*(char)
,	O
&	O
Fpt	struct(double,double)
,	O
NULL	O
)	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"malformed font spec: %s"	*(char)
)	O
,	O
optarg	*(char)
)	O
)	O
;	O
user_body_font_defined	int
=	O
1	int
;	O
break	O
;	O
case	O
'F'	O
:	O
if	O
(	O
!	O
parse_font_spec	(*(char),*(*(char)),*(struct(double,double)),*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))->(int)
(	O
optarg	*(char)
,	O
&	O
HFname	*(char)
,	O
&	O
HFpt	struct(double,double)
,	O
NULL	O
)	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"malformed font spec: %s"	*(char)
)	O
,	O
optarg	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
break	O
;	O
case	O
'G'	O
:	O
header	enum(int,int,int)
=	O
HDR_FANCY	int
;	O
if	O
(	O
optarg	*(char)
)	O
fancy_header_name	*(char)
=	O
optarg	*(char)
;	O
else	O
fancy_header_name	*(char)
=	O
fancy_header_default	*(char)
;	O
if	O
(	O
!	O
file_existsp	(*(char),*(char))->(int)
(	O
fancy_header_name	*(char)
,	O
".hdr"	*(char)
)	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"couldn't find header definition file \"%s.hdr\""	*(char)
)	O
,	O
fancy_header_name	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
no_job_header	int
=	O
1	int
;	O
break	O
;	O
case	O
'H'	O
:	O
if	O
(	O
optarg	*(char)
)	O
highlight_bars	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
else	O
highlight_bars	int
=	O
2	int
;	O
break	O
;	O
case	O
'i'	O
:	O
line_indent_spec	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'I'	O
:	O
input_filter	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'j'	O
:	O
borders	int
=	O
1	int
;	O
break	O
;	O
case	O
'k'	O
:	O
page_prefeed	int
=	O
1	int
;	O
break	O
;	O
case	O
'K'	O
:	O
page_prefeed	int
=	O
0	int
;	O
break	O
;	O
case	O
'l'	O
:	O
lines_per_page	int
=	O
66	int
;	O
header	enum(int,int,int)
=	O
HDR_NONE	int
;	O
break	O
;	O
case	O
'L'	O
:	O
lines_per_page	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
lines_per_page	int
<=	O
0	int
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"must print at least one line per each page: %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
optind	int
]	O
)	O
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
mail	int
=	O
1	int
;	O
break	O
;	O
case	O
'M'	O
:	O
media_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
case	O
'#'	O
:	O
num_copies	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
if	O
(	O
!	O
(	O
optarg	*(char)
[	O
0	int
]	O
==	O
'n'	O
||	O
optarg	*(char)
[	O
0	int
]	O
==	O
'r'	O
)	O
||	O
optarg	*(char)
[	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: illegal newline character specifier: '%s': expected 'n' or 'r'\n"	*(char)
)	O
,	O
program	*(char)
,	O
optarg	*(char)
)	O
;	O
goto	O
option_error	O
;	O
}	O
if	O
(	O
optarg	*(char)
[	O
0	int
]	O
==	O
'n'	O
)	O
nl	int
=	O
'\n'	O
;	O
else	O
nl	int
=	O
'\r'	O
;	O
break	O
;	O
case	O
'o'	O
:	O
case	O
'p'	O
:	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
output_file	*(char)
=	O
OUTPUT_FILE_STDOUT	O
;	O
else	O
output_file	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'O'	O
:	O
list_missing_characters	int
=	O
1	int
;	O
break	O
;	O
case	O
'q'	O
:	O
quiet	int
=	O
1	int
;	O
verbose	int
=	O
0	int
;	O
break	O
;	O
case	O
'r'	O
:	O
landscape	int
=	O
1	int
;	O
break	O
;	O
case	O
'R'	O
:	O
landscape	int
=	O
0	int
;	O
break	O
;	O
case	O
's'	O
:	O
baselineskip	double
=	O
atof	(*(char))->(double)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
parse_key_value_pair	(*(struct),*(char))->(void)
(	O
statusdict	*(struct)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
case	O
'J'	O
:	O
title	*(char)
=	O
optarg	*(char)
;	O
title_given	int
=	O
1	int
;	O
break	O
;	O
case	O
'T'	O
:	O
tabsize	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
tabsize	int
<=	O
0	int
)	O
tabsize	int
=	O
1	int
;	O
break	O
;	O
case	O
'u'	O
:	O
underlay	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'U'	O
:	O
nup	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
if	O
(	O
optarg	*(char)
)	O
verbose	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
else	O
verbose	int
++	O
;	O
quiet	int
=	O
0	int
;	O
break	O
;	O
case	O
'V'	O
:	O
version	double
(	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'w'	O
:	O
output_language	*(char)
=	O
optarg	*(char)
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
output_language	*(char)
,	O
"PostScript"	*(char)
)	O
!=	O
0	int
)	O
output_language_pass_through	int
=	O
1	int
;	O
break	O
;	O
case	O
'W'	O
:	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
optarg	*(char)
,	O
','	O
)	O
;	O
if	O
(	O
cp	*(char)
==	O
NULL	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"malformed argument `%s' for option -W, --option: no comma found"	*(char)
)	O
,	O
optarg	*(char)
)	O
)	O
;	O
if	O
(	O
cp	*(char)
-	O
optarg	*(char)
!=	O
1	int
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"helper application specification must be single character: %s"	*(char)
)	O
,	O
optarg	*(char)
)	O
)	O
;	O
i	int
=	O
*	O
optarg	*(char)
;	O
cp	*(char)
++	O
;	O
if	O
(	O
helper_options	array(*(struct(*(char),long,long)))
[	O
i	int
]	O
==	O
NULL	O
)	O
helper_options	array(*(struct(*(char),long,long)))
[	O
i	int
]	O
=	O
buffer_alloc	()->(*(struct(*(char),long,long)))
(	O
)	O
;	O
else	O
{	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
helper_options	array(*(struct(*(char),long,long)))
[	O
i	int
]	O
,	O
" "	*(char)
)	O
;	O
}	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
helper_options	array(*(struct(*(char),long,long)))
[	O
i	int
]	O
,	O
cp	*(char)
)	O
;	O
break	O
;	O
case	O
'X'	O
:	O
xfree	(*(void))->(void)
(	O
encoding_name	*(char)
)	O
;	O
encoding_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'z'	O
:	O
interpret_formfeed	int
=	O
0	int
;	O
break	O
;	O
case	O
'Z'	O
:	O
pass_through	int
=	O
1	int
;	O
break	O
;	O
case	O
128	int
:	O
if	O
(	O
!	O
parse_font_spec	(*(char),*(*(char)),*(struct(double,double)),*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))->(int)
(	O
optarg	*(char)
,	O
&	O
ul_font	*(char)
,	O
&	O
ul_ptsize	struct(double,double)
,	O
NULL	O
)	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"malformed font spec: %s"	*(char)
)	O
,	O
optarg	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
129	int
:	O
ul_gray	double
=	O
atof	(*(char))->(double)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
130	int
:	O
xfree	(*(void))->(void)
(	O
page_label_format	*(char)
)	O
;	O
page_label_format	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
131	int
:	O
strhash_put	(*(struct),*(char),int,*(void),*(*(void)))->(int)
(	O
download_fonts	*(struct)
,	O
optarg	*(char)
,	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
132	int
:	O
ul_angle	double
=	O
atof	(*(char))->(double)
(	O
optarg	*(char)
)	O
;	O
ul_angle_p	int
=	O
1	int
;	O
break	O
;	O
case	O
133	int
:	O
xfree	(*(void))->(void)
(	O
ul_position	*(char)
)	O
;	O
ul_position	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
ul_position_p	int
=	O
1	int
;	O
break	O
;	O
case	O
134	int
:	O
xfree	(*(void))->(void)
(	O
npf_name	*(char)
)	O
;	O
npf_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
135	int
:	O
usage	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
break	O
;	O
case	O
136	int
:	O
highlight_bar_gray	double
=	O
atof	(*(char))->(double)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
137	int
:	O
xfree	(*(void))->(void)
(	O
ul_style_str	*(char)
)	O
;	O
ul_style_str	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
138	int
:	O
input_filter_stdin	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
139	int
:	O
printer_options	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
140	int
:	O
slicing	int
=	O
1	int
;	O
slice	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
slice	int
<=	O
0	int
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"slice must be greater than zero"	*(char)
)	O
)	O
)	O
;	O
break	O
;	O
case	O
141	int
:	O
help_highlight	int
=	O
1	int
;	O
break	O
;	O
case	O
142	int
:	O
if	O
(	O
optarg	*(char)
==	O
NULL	O
)	O
states_color	int
=	O
1	int
;	O
else	O
states_color	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
143	int
:	O
if	O
(	O
optarg	*(char)
)	O
{	O
xfree	(*(void))->(void)
(	O
mark_wrapped_lines_style_name	*(char)
)	O
;	O
mark_wrapped_lines_style_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
}	O
else	O
mark_wrapped_lines_style	enum(int,int,int,int)
=	O
MWLS_BOX	int
;	O
break	O
;	O
case	O
144	int
:	O
margins_spec	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
145	int
:	O
nup_xpad	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
146	int
:	O
nup_ypad	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
147	int
:	O
line_end	enum(int,int,int)
=	O
LE_WORD_WRAP	int
;	O
break	O
;	O
case	O
148	int
:	O
horizontal_column_height	double
=	O
atof	(*(char))->(double)
(	O
optarg	*(char)
)	O
;	O
formfeed_type	enum(int,int,int)
=	O
FORMFEED_HCOLUMN	int
;	O
break	O
;	O
case	O
149	int
:	O
pslevel	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
150	int
:	O
rotate_even_pages	int
=	O
1	int
;	O
break	O
;	O
case	O
151	int
:	O
xfree	(*(void))->(void)
(	O
states_highlight_style	*(char)
)	O
;	O
states_highlight_style	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
152	int
:	O
nup_columnwise	int
=	O
1	int
;	O
break	O
;	O
case	O
153	int
:	O
swap_even_page_margins	int
=	O
1	int
;	O
break	O
;	O
case	O
154	int
:	O
extended_return_values	int
=	O
1	int
;	O
break	O
;	O
case	O
155	int
:	O
page_footer	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
156	int
:	O
continuous_page_numbers	int
=	O
1	int
;	O
break	O
;	O
case	O
'?'	O
:	O
option_error	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Try `%s --help' for more information.\n"	*(char)
)	O
,	O
program	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"Hey!  main() didn't handle option \"%c\" (%d)"	*(char)
,	O
c	int
,	O
c	int
)	O
;	O
if	O
(	O
optarg	*(char)
)	O
printf	(*(char))->(int)
(	O
" with arg %s"	*(char)
,	O
optarg	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"This is a bug!"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
usage	()->(void)
(	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Usage: %s [OPTION]... [FILE]...\nMandatory arguments to long options are mandatory for short options too.\n  -#                         an alias for option -n, --copies\n  -1                         same as --columns=1\n  -2                         same as --columns=2\n      --columns=NUM          specify the number of columns per page\n  -a, --pages=PAGES          specify which pages are printed\n  -A, --file-align=ALIGN     align separate input files to ALIGN\n  -b, --header=HEADER        set page header\n  -B, --no-header            no page headers\n  -c, --truncate-lines       cut long lines (default is to wrap)\n  -C[START], --line-numbers[=START]\n                             precede each line with its line number\n  -d                         an alias for option --printer\n  -D, --setpagedevice=KEY[:VALUE]\n                             pass a page device definition to output\n  -e[CHAR], --escapes[=CHAR]       enable special escape interpretation\n"	*(char)
)	O
,	O
program	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -E[LANG], --highlight[=LANG]     highlight source code\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -f, --font=NAME            use font NAME for body text\n  -F, --header-font=NAME     use font NAME for header texts\n  -g, --print-anyway         nothing (compatibility option)\n  -G                         same as --fancy-header\n      --fancy-header[=NAME]  select fancy page header\n  -h, --no-job-header        suppress the job header page\n  -H[NUM], --highlight-bars[=NUM]  specify how high highlight bars are\n  -i, --indent=NUM           set line indent to NUM characters\n  -I, --filter=CMD           read input files through input filter CMD\n  -j, --borders              print borders around columns\n  -J,                        an alias for option --title\n  -k, --page-prefeed         enable page prefeed\n  -K, --no-page-prefeed      disable page prefeed\n  -l, --lineprinter          simulate lineprinter, this is an alias for:\n                               --lines-per-page=66, --no-header, --portrait,\n                               --columns=1\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -L, --lines-per-page=NUM   specify how many lines are printed on each page\n  -m, --mail                 send mail upon completion\n  -M, --media=NAME           use output media NAME\n  -n, --copies=NUM           print NUM copies of each page\n  -N, --newline=NL           select the newline character.  Possible\n                             values for NL are: n (`\\n') and r (`\\r').\n  -o                         an alias for option --output\n  -O, --missing-characters   list missing characters\n  -p, --output=FILE          leave output to file FILE.  If FILE is `-',\n                             leave output to stdout.\n  -P, --printer=NAME         print output to printer NAME\n  -q, --quiet, --silent      be really quiet\n  -r, --landscape            print in landscape mode\n  -R, --portrait             print in portrait mode\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -s, --baselineskip=NUM     set baselineskip to NUM\n  -S, --statusdict=KEY[:VALUE]\n                             pass a statusdict definition to the output\n  -t, --title=TITLE          set banner page's job title to TITLE.  Option\n                             sets also the name of the input file stdin.\n  -T, --tabsize=NUM          set tabulator size to NUM\n  -u[TEXT], --underlay[=TEXT]      print TEXT under every page\n  -U, --nup=NUM              print NUM logical pages on each output page\n  -v, --verbose              tell what we are doing\n  -V, --version              print version number\n  -w, --language=LANG        set output language to LANG\n  -W, --options=APP,OPTION   pass option OPTION to helper application APP\n  -X, --encoding=NAME        use input encoding NAME\n  -z, --no-formfeed          do not interpret form feed characters\n  -Z, --pass-through         pass through PostScript and PCL files\n                             without any modifications\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Long-only options:\n  --color[=bool]             create color outputs with states\n  --continuous-page-numbers  count page numbers across input files.  Don't\n                             restart numbering at beginning of each file.\n  --download-font=NAME       download font NAME\n  --extended-return-values   enable extended return values\n  --filter-stdin=NAME        specify how stdin is shown to the input filter\n  --footer=FOOTER            set page footer\n  --h-column-height=HEIGHT   set the horizontal column height to HEIGHT\n  --help                     print this help and exit\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  --help-highlight           describe all supported --highlight languages\n                             and file formats\n  --highlight-bar-gray=NUM   print highlight bars with gray NUM (0 - 1)\n  --list-media               list names of all known media\n  --margins=LEFT:RIGHT:TOP:BOTTOM\n                             adjust page marginals\n  --mark-wrapped-lines[STYLE]\n                             mark wrapped lines in the output with STYLE\n  --non-printable-format=FMT specify how non-printable chars are printed\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  --nup-columnwise           layout pages in the N-up printing columnwise\n  --nup-xpad=NUM             set the page x-padding of N-up printing to NUM\n  --nup-ypad=NUM             set the page y-padding of N-up printing to NUM\n  --page-label-format=FMT    set page label format to FMT\n  --ps-level=LEVEL           set the PostScript language level that enscript\n                             should use\n  --printer-options=OPTIONS  pass extra options to the printer command\n  --rotate-even-pages        rotate even-numbered pages 180 degrees\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  --slice=NUM                print vertical slice NUM\n  --style=STYLE              use highlight style STYLE\n  --swap-even-page-margins   swap left and right side margins for each even\n                             numbered page\n  --toc                      print table of contents\n  --ul-angle=ANGLE           set underlay text's angle to ANGLE\n  --ul-font=NAME             print underlays with font NAME\n  --ul-gray=NUM              print underlays with gray value NUM\n  --ul-position=POS          set underlay's starting position to POS\n  --ul-style=STYLE           print underlays with style STYLE\n  --word-wrap                wrap long lines from word boundaries\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nReport bugs to <%s>.\n"	*(char)
)	O
,	O
PACKAGE_BUGREPORT	*(char)
)	O
;	O
}	O
static	O
void	O
version	double
(	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%s\nCopyright (C) 1995-2003, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n%s comes with NO WARRANTY, to the extent permitted by law.\nYou may redistribute copies of %s under the terms of the GNU\nGeneral Public License, version 3 or, at your option, any later version.\nFor more information about these matters, see the files named COPYING.\n"	*(char)
,	O
PACKAGE_STRING	*(char)
,	O
PACKAGE_NAME	*(char)
,	O
PACKAGE_NAME	*(char)
)	O
;	O
}	O
