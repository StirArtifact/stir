static	O
inline	O
struct	O
ids	O
*	O
make_ids	(*(int),int)->(*(struct))
(	O
const	O
uid_t	O
*	O
uids	*(int)
,	O
size_t	O
nuids	int
)	O
{	O
struct	O
ids	O
*	O
i	*(struct)
;	O
i	*(struct)
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
ids	O
)	O
+	O
sizeof	O
(	O
uid_t	O
)	O
*	O
nuids	int
)	O
;	O
;	O
if	O
(	O
!	O
i	*(struct)
)	O
return	O
NULL	O
;	O
i	*(struct)
->	O
i_nuids	O
=	O
nuids	int
;	O
i	*(struct)
->	O
i_refcnt	O
=	O
1	int
;	O
memcpy	O
(	O
&	O
i	*(struct)
->	O
i_uids	O
,	O
uids	*(int)
,	O
sizeof	O
(	O
uid_t	O
)	O
*	O
nuids	int
)	O
;	O
return	O
i	*(struct)
;	O
}	O
static	O
inline	O
void	O
ids_ref	(*(struct))->(void)
(	O
struct	O
ids	O
*	O
i	*(struct)
)	O
{	O
i	*(struct)
->	O
i_refcnt	O
++	O
;	O
}	O
static	O
inline	O
void	O
ids_rele	(*(struct))->(void)
(	O
struct	O
ids	O
*	O
i	*(struct)
)	O
{	O
i	*(struct)
->	O
i_refcnt	O
--	O
;	O
if	O
(	O
i	*(struct)
->	O
i_refcnt	O
==	O
0	int
)	O
free	()->(int)
(	O
i	*(struct)
)	O
;	O
}	O
int	O
check_uid	(*(struct),int)->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
uid_t	O
uid	int
)	O
{	O
int	O
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
p	*(struct)
->	O
p_id	O
->	O
i_nuids	O
;	O
i	*(struct)
++	O
)	O
if	O
(	O
p	*(struct)
->	O
p_id	O
->	O
i_uids	O
[	O
i	*(struct)
]	O
==	O
uid	int
||	O
p	*(struct)
->	O
p_id	O
->	O
i_uids	O
[	O
i	*(struct)
]	O
==	O
0	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_reauthenticate	(*(struct),int)->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
mach_port_t	O
rendport	int
)	O
{	O
error_t	O
err	O
;	O
uid_t	O
gubuf	O
[	O
50	int
]	O
,	O
aubuf	O
[	O
50	int
]	O
,	O
ggbuf	O
[	O
50	int
]	O
,	O
agbuf	O
[	O
50	int
]	O
;	O
uid_t	O
*	O
gen_uids	O
,	O
*	O
aux_uids	O
,	O
*	O
gen_gids	O
,	O
*	O
aux_gids	O
;	O
size_t	O
ngen_uids	O
,	O
naux_uids	O
,	O
ngen_gids	O
,	O
naux_gids	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
gen_uids	O
=	O
gubuf	O
;	O
aux_uids	O
=	O
aubuf	O
;	O
gen_gids	O
=	O
ggbuf	O
;	O
aux_gids	O
=	O
agbuf	O
;	O
ngen_uids	O
=	O
sizeof	O
(	O
gubuf	O
)	O
/	O
sizeof	O
(	O
uid_t	O
)	O
;	O
naux_uids	O
=	O
sizeof	O
(	O
aubuf	O
)	O
/	O
sizeof	O
(	O
uid_t	O
)	O
;	O
ngen_gids	O
=	O
sizeof	O
(	O
ggbuf	O
)	O
/	O
sizeof	O
(	O
uid_t	O
)	O
;	O
naux_gids	O
=	O
sizeof	O
(	O
agbuf	O
)	O
/	O
sizeof	O
(	O
uid_t	O
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
do	O
err	O
=	O
auth_server_authenticate	()->(int)
(	O
authserver	O
,	O
rendport	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
MACH_PORT_NULL	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
&	O
gen_uids	O
,	O
&	O
ngen_uids	O
,	O
&	O
aux_uids	O
,	O
&	O
naux_uids	O
,	O
&	O
gen_gids	O
,	O
&	O
ngen_gids	O
,	O
&	O
aux_gids	O
,	O
&	O
naux_gids	O
)	O
;	O
while	O
(	O
err	O
==	O
EINTR	O
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
if	O
(	O
p	*(struct)
->	O
p_dead	O
)	O
err	O
=	O
EAGAIN	O
;	O
else	O
{	O
ids_rele	(*(struct))->(void)
(	O
p	*(struct)
->	O
p_id	O
)	O
;	O
p	*(struct)
->	O
p_id	O
=	O
make_ids	(*(int),int)->(*(struct))
(	O
gen_uids	O
,	O
ngen_uids	O
)	O
;	O
if	O
(	O
!	O
p	*(struct)
->	O
p_id	O
)	O
err	O
=	O
ENOMEM	O
;	O
}	O
if	O
(	O
gen_uids	O
!=	O
gubuf	O
)	O
munmap	()->(int)
(	O
gen_uids	O
,	O
ngen_uids	O
*	O
sizeof	O
(	O
uid_t	O
)	O
)	O
;	O
if	O
(	O
aux_uids	O
!=	O
aubuf	O
)	O
munmap	()->(int)
(	O
aux_uids	O
,	O
naux_uids	O
*	O
sizeof	O
(	O
uid_t	O
)	O
)	O
;	O
if	O
(	O
gen_gids	O
!=	O
ggbuf	O
)	O
munmap	()->(int)
(	O
gen_gids	O
,	O
ngen_gids	O
*	O
sizeof	O
(	O
uid_t	O
)	O
)	O
;	O
if	O
(	O
aux_gids	O
!=	O
agbuf	O
)	O
munmap	()->(int)
(	O
aux_gids	O
,	O
naux_gids	O
*	O
sizeof	O
(	O
uid_t	O
)	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
rendport	int
)	O
;	O
return	O
err	O
;	O
}	O
kern_return_t	O
S_proc_child	(*(struct),int)->(int)
(	O
struct	O
proc	O
*	O
parentp	*(struct)
,	O
task_t	O
childt	int
)	O
{	O
struct	O
proc	O
*	O
childp	*(struct)
;	O
if	O
(	O
!	O
parentp	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
childp	*(struct)
=	O
task_find	()->(int)
(	O
childt	int
)	O
;	O
if	O
(	O
!	O
childp	*(struct)
)	O
return	O
ESRCH	O
;	O
if	O
(	O
childp	*(struct)
->	O
p_parentset	O
)	O
return	O
EBUSY	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
childt	int
)	O
;	O
if	O
(	O
!	O
--	O
childp	*(struct)
->	O
p_login	O
->	O
l_refcnt	O
)	O
free	()->(int)
(	O
childp	*(struct)
->	O
p_login	O
)	O
;	O
childp	*(struct)
->	O
p_login	O
=	O
parentp	*(struct)
->	O
p_login	O
;	O
childp	*(struct)
->	O
p_login	O
->	O
l_refcnt	O
++	O
;	O
childp	*(struct)
->	O
p_owner	O
=	O
parentp	*(struct)
->	O
p_owner	O
;	O
childp	*(struct)
->	O
p_noowner	O
=	O
parentp	*(struct)
->	O
p_noowner	O
;	O
ids_rele	(*(struct))->(void)
(	O
childp	*(struct)
->	O
p_id	O
)	O
;	O
ids_ref	(*(struct))->(void)
(	O
parentp	*(struct)
->	O
p_id	O
)	O
;	O
childp	*(struct)
->	O
p_id	O
=	O
parentp	*(struct)
->	O
p_id	O
;	O
assert	()->(int)
(	O
childp	*(struct)
->	O
p_parent	O
==	O
init_proc	O
)	O
;	O
if	O
(	O
childp	*(struct)
->	O
p_sib	O
)	O
childp	*(struct)
->	O
p_sib	O
->	O
p_prevsib	O
=	O
childp	*(struct)
->	O
p_prevsib	O
;	O
*	O
childp	*(struct)
->	O
p_prevsib	O
=	O
childp	*(struct)
->	O
p_sib	O
;	O
childp	*(struct)
->	O
p_parent	O
=	O
parentp	*(struct)
;	O
childp	*(struct)
->	O
p_sib	O
=	O
parentp	*(struct)
->	O
p_ochild	O
;	O
childp	*(struct)
->	O
p_prevsib	O
=	O
&	O
parentp	*(struct)
->	O
p_ochild	O
;	O
if	O
(	O
parentp	*(struct)
->	O
p_ochild	O
)	O
parentp	*(struct)
->	O
p_ochild	O
->	O
p_prevsib	O
=	O
&	O
childp	*(struct)
->	O
p_sib	O
;	O
parentp	*(struct)
->	O
p_ochild	O
=	O
childp	*(struct)
;	O
if	O
(	O
childp	*(struct)
->	O
p_pgrp	O
!=	O
parentp	*(struct)
->	O
p_pgrp	O
)	O
{	O
leave_pgrp	()->(int)
(	O
childp	*(struct)
)	O
;	O
childp	*(struct)
->	O
p_pgrp	O
=	O
parentp	*(struct)
->	O
p_pgrp	O
;	O
join_pgrp	()->(int)
(	O
childp	*(struct)
)	O
;	O
}	O
else	O
if	O
(	O
childp	*(struct)
->	O
p_msgport	O
!=	O
MACH_PORT_NULL	O
)	O
nowait_msg_proc_newids	()->(int)
(	O
childp	*(struct)
->	O
p_msgport	O
,	O
childp	*(struct)
->	O
p_task	O
,	O
childp	*(struct)
->	O
p_parent	O
->	O
p_pid	O
,	O
childp	*(struct)
->	O
p_pgrp	O
->	O
pg_pgid	O
,	O
!	O
childp	*(struct)
->	O
p_pgrp	O
->	O
pg_orphcnt	O
)	O
;	O
childp	*(struct)
->	O
p_parentset	O
=	O
1	int
;	O
if	O
(	O
!	O
childp	*(struct)
->	O
start_code	int
&&	O
!	O
childp	*(struct)
->	O
end_code	int
)	O
{	O
childp	*(struct)
->	O
start_code	int
=	O
parentp	*(struct)
->	O
start_code	int
;	O
childp	*(struct)
->	O
end_code	int
=	O
parentp	*(struct)
->	O
end_code	int
;	O
}	O
if	O
(	O
MACH_PORT_VALID	()->(int)
(	O
parentp	*(struct)
->	O
p_task_namespace	O
)	O
)	O
{	O
mach_port_mod_refs	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
parentp	*(struct)
->	O
p_task_namespace	O
,	O
MACH_PORT_RIGHT_SEND	O
,	O
+	O
1	int
)	O
;	O
childp	*(struct)
->	O
p_task_namespace	O
=	O
parentp	*(struct)
->	O
p_task_namespace	O
;	O
}	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_reassign	(*(struct),int)->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
task_t	O
newt	int
)	O
{	O
struct	O
proc	O
*	O
stubp	*(struct)
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
stubp	*(struct)
=	O
task_find	()->(int)
(	O
newt	int
)	O
;	O
if	O
(	O
!	O
stubp	*(struct)
)	O
return	O
ESRCH	O
;	O
if	O
(	O
stubp	*(struct)
==	O
p	*(struct)
)	O
return	O
EINVAL	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
newt	int
)	O
;	O
remove_proc_from_hash	()->(int)
(	O
p	*(struct)
)	O
;	O
task_terminate	()->(int)
(	O
p	*(struct)
->	O
p_task	O
)	O
;	O
mach_port_destroy	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
p	*(struct)
->	O
p_task	O
)	O
;	O
p	*(struct)
->	O
p_task	O
=	O
stubp	*(struct)
->	O
p_task	O
;	O
ports_transfer_right	()->(int)
(	O
p	*(struct)
,	O
stubp	*(struct)
)	O
;	O
if	O
(	O
p	*(struct)
->	O
p_msgport	O
!=	O
MACH_PORT_NULL	O
)	O
{	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
p	*(struct)
->	O
p_msgport	O
)	O
;	O
p	*(struct)
->	O
p_msgport	O
=	O
MACH_PORT_NULL	O
;	O
p	*(struct)
->	O
p_deadmsg	O
=	O
1	int
;	O
}	O
p	*(struct)
->	O
p_argv	O
=	O
stubp	*(struct)
->	O
p_argv	O
;	O
p	*(struct)
->	O
p_envp	O
=	O
stubp	*(struct)
->	O
p_envp	O
;	O
stubp	*(struct)
->	O
p_task	O
=	O
MACH_PORT_NULL	O
;	O
process_has_exited	()->(int)
(	O
stubp	*(struct)
)	O
;	O
stubp	*(struct)
->	O
p_waited	O
=	O
1	int
;	O
complete_exit	()->(int)
(	O
stubp	*(struct)
)	O
;	O
add_proc_to_hash	()->(int)
(	O
p	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_setowner	(*(struct),int,int)->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
uid_t	O
owner	int
,	O
int	O
clear	int
)	O
{	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
clear	int
)	O
p	*(struct)
->	O
p_noowner	O
=	O
1	int
;	O
else	O
{	O
if	O
(	O
!	O
check_uid	(*(struct),int)->(int)
(	O
p	*(struct)
,	O
owner	int
)	O
)	O
return	O
EPERM	O
;	O
p	*(struct)
->	O
p_owner	O
=	O
owner	int
;	O
p	*(struct)
->	O
p_noowner	O
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getpids	(*(struct),*(int),*(int),*(int))->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
pid_t	O
*	O
pid	*(int)
,	O
pid_t	O
*	O
ppid	*(int)
,	O
int	O
*	O
orphaned	*(int)
)	O
{	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
*	O
pid	*(int)
=	O
p	*(struct)
->	O
p_pid	O
;	O
*	O
ppid	*(int)
=	O
p	*(struct)
->	O
p_parent	O
->	O
p_pid	O
;	O
*	O
orphaned	*(int)
=	O
!	O
p	*(struct)
->	O
p_pgrp	O
->	O
pg_orphcnt	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_set_arg_locations	(*(struct),int,int)->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
vm_address_t	O
argv	int
,	O
vm_address_t	O
envp	int
)	O
{	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
p	*(struct)
->	O
p_argv	O
=	O
argv	int
;	O
p	*(struct)
->	O
p_envp	O
=	O
envp	int
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_get_arg_locations	(*(struct),*(int),*(int))->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
vm_address_t	O
*	O
argv	int
,	O
vm_address_t	O
*	O
envp	int
)	O
{	O
*	O
argv	int
=	O
p	*(struct)
->	O
p_argv	O
;	O
*	O
envp	int
=	O
p	*(struct)
->	O
p_envp	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_dostop	(*(struct),int)->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
thread_t	O
contthread	int
)	O
{	O
thread_t	O
threadbuf	O
[	O
2	int
]	O
,	O
*	O
threads	O
=	O
threadbuf	O
;	O
size_t	O
nthreads	O
=	O
sizeof	O
(	O
threadbuf	O
)	O
/	O
sizeof	O
(	O
thread_t	O
)	O
;	O
int	O
i	*(struct)
;	O
error_t	O
err	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
err	O
=	O
task_suspend	()->(int)
(	O
p	*(struct)
->	O
p_task	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
err	O
=	O
task_threads	()->(int)
(	O
p	*(struct)
->	O
p_task	O
,	O
&	O
threads	O
,	O
&	O
nthreads	O
)	O
;	O
if	O
(	O
err	O
)	O
{	O
task_resume	()->(int)
(	O
p	*(struct)
->	O
p_task	O
)	O
;	O
return	O
err	O
;	O
}	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
nthreads	O
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
threads	O
[	O
i	*(struct)
]	O
!=	O
contthread	int
)	O
thread_suspend	()->(int)
(	O
threads	O
[	O
i	*(struct)
]	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
threads	O
[	O
i	*(struct)
]	O
)	O
;	O
}	O
if	O
(	O
threads	O
!=	O
threadbuf	O
)	O
munmap	()->(int)
(	O
threads	O
,	O
nthreads	O
*	O
sizeof	O
(	O
thread_t	O
)	O
)	O
;	O
err	O
=	O
task_resume	()->(int)
(	O
p	*(struct)
->	O
p_task	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
contthread	int
)	O
;	O
return	O
0	int
;	O
}	O
void	O
exc_clean	(*(void))->(void)
(	O
void	O
*	O
arg	*(void)
)	O
{	O
struct	O
exc	O
*	O
e	*(struct)
=	O
arg	*(void)
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
e	*(struct)
->	O
forwardport	int
)	O
;	O
}	O
kern_return_t	O
S_proc_handle_exceptions	(*(struct),int,int,int,int,int)->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
mach_port_t	O
msgport	int
,	O
mach_port_t	O
forwardport	int
,	O
int	O
flavor	int
,	O
thread_state_t	O
new_state	int
,	O
mach_msg_type_number_t	O
statecnt	int
)	O
{	O
struct	O
exc	O
*	O
e	*(struct)
;	O
error_t	O
err	O
;	O
err	O
=	O
ports_import_port	()->(int)
(	O
exc_class	O
,	O
proc_bucket	O
,	O
msgport	int
,	O
(	O
sizeof	O
(	O
struct	O
exc	O
)	O
+	O
(	O
statecnt	int
*	O
sizeof	O
(	O
natural_t	O
)	O
)	O
)	O
,	O
&	O
e	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
e	*(struct)
->	O
forwardport	int
=	O
forwardport	int
;	O
e	*(struct)
->	O
flavor	int
=	O
flavor	int
;	O
e	*(struct)
->	O
statecnt	int
=	O
statecnt	int
;	O
memcpy	O
(	O
e	*(struct)
->	O
thread_state	O
,	O
new_state	int
,	O
statecnt	int
*	O
sizeof	O
(	O
natural_t	O
)	O
)	O
;	O
ports_port_deref	()->(int)
(	O
e	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_exception_raise	(*(struct),int,int,int,int,int,int,int)->(int)
(	O
struct	O
exc	O
*	O
e	*(struct)
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
mach_port_t	O
thread	int
,	O
mach_port_t	O
task	int
,	O
integer_t	O
exception	int
,	O
integer_t	O
code	int
,	O
integer_t	O
subcode	int
)	O
{	O
error_t	O
err	O
;	O
struct	O
proc	O
*	O
p	*(struct)
;	O
if	O
(	O
!	O
e	*(struct)
||	O
e	*(struct)
->	O
pi	O
.	O
bucket	O
!=	O
proc_bucket	O
||	O
e	*(struct)
->	O
pi	O
.	O
class	O
!=	O
exc_class	O
)	O
return	O
EOPNOTSUPP	O
;	O
p	*(struct)
=	O
task_find	()->(int)
(	O
task	int
)	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
{	O
return	O
EINVAL	O
;	O
}	O
err	O
=	O
proc_exception_raise	()->(int)
(	O
e	*(struct)
->	O
forwardport	int
,	O
reply	int
,	O
reply_type	int
,	O
MACH_SEND_NOTIFY	O
,	O
thread	int
,	O
task	int
,	O
exception	int
,	O
code	int
,	O
subcode	int
)	O
;	O
switch	O
(	O
err	O
)	O
{	O
struct	O
hurd_signal_detail	O
hsd	struct
;	O
int	O
signo	int
;	O
case	O
0	int
:	O
err	O
=	O
thread_set_state	()->(int)
(	O
thread	int
,	O
e	*(struct)
->	O
flavor	int
,	O
e	*(struct)
->	O
thread_state	O
,	O
e	*(struct)
->	O
statecnt	int
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
thread	int
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
task	int
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
return	O
MIG_NO_REPLY	O
;	O
default	O
:	O
case	O
MACH_SEND_NOTIFY_IN_PROGRESS	O
:	O
hsd	struct
.	O
exc	O
=	O
exception	int
;	O
hsd	struct
.	O
exc_code	O
=	O
code	int
;	O
hsd	struct
.	O
exc_subcode	O
=	O
subcode	int
;	O
_hurd_exception2signal	()->(int)
(	O
&	O
hsd	struct
,	O
&	O
signo	int
)	O
;	O
p	*(struct)
->	O
p_exiting	O
=	O
1	int
;	O
p	*(struct)
->	O
p_status	O
=	O
W_EXITCODE	()->(int)
(	O
0	int
,	O
signo	int
)	O
;	O
p	*(struct)
->	O
p_sigcode	O
=	O
hsd	struct
.	O
code	int
;	O
task_terminate	()->(int)
(	O
task	int
)	O
;	O
mach_port_destroy	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
thread	int
)	O
;	O
return	O
MIG_NO_REPLY	O
;	O
}	O
}	O
static	O
void	O
count_up	(*(struct),*(void))->(void)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
void	O
*	O
counter	*(void)
)	O
{	O
++	O
*	O
(	O
int	O
*	O
)	O
counter	*(void)
;	O
}	O
static	O
void	O
store_pid	(*(struct),*(void))->(void)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
void	O
*	O
loc	*(void)
)	O
{	O
*	O
(	O
*	O
(	O
pid_t	O
*	O
*	O
)	O
loc	*(void)
)	O
++	O
=	O
p	*(struct)
->	O
p_pid	O
;	O
}	O
kern_return_t	O
S_proc_getallpids	(*(struct),*(*(int)),*(int))->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
pid_t	O
*	O
*	O
pids	*(*(int))
,	O
size_t	O
*	O
pidslen	*(int)
)	O
{	O
int	O
nprocs	int
;	O
pid_t	O
*	O
loc	*(void)
;	O
add_tasks	()->(int)
(	O
0	int
)	O
;	O
nprocs	int
=	O
0	int
;	O
prociterate	()->(int)
(	O
count_up	(*(struct),*(void))->(void)
,	O
&	O
nprocs	int
)	O
;	O
if	O
(	O
nprocs	int
>	O
*	O
pidslen	*(int)
)	O
{	O
*	O
pids	*(*(int))
=	O
mmap	()->(int)
(	O
0	int
,	O
nprocs	int
*	O
sizeof	O
(	O
pid_t	O
)	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
*	O
pids	*(*(int))
==	O
MAP_FAILED	O
)	O
return	O
ENOMEM	O
;	O
}	O
loc	*(void)
=	O
*	O
pids	*(*(int))
;	O
prociterate	()->(int)
(	O
store_pid	(*(struct),*(void))->(void)
,	O
&	O
loc	*(void)
)	O
;	O
*	O
pidslen	*(int)
=	O
nprocs	int
;	O
return	O
0	int
;	O
}	O
struct	O
proc	O
*	O
allocate_proc	(int)->(*(struct))
(	O
task_t	O
task	int
)	O
{	O
error_t	O
err	O
;	O
struct	O
proc	O
*	O
p	*(struct)
;	O
err	O
=	O
ports_create_port	()->(int)
(	O
proc_class	O
,	O
proc_bucket	O
,	O
sizeof	O
(	O
struct	O
proc	O
)	O
,	O
&	O
p	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
return	O
NULL	O
;	O
memset	O
(	O
&	O
p	*(struct)
->	O
p_pi	O
+	O
1	int
,	O
0	int
,	O
sizeof	O
*	O
p	*(struct)
-	O
sizeof	O
p	*(struct)
->	O
p_pi	O
)	O
;	O
p	*(struct)
->	O
p_task	O
=	O
task	int
;	O
p	*(struct)
->	O
p_task_namespace	O
=	O
MACH_PORT_NULL	O
;	O
p	*(struct)
->	O
p_msgport	O
=	O
MACH_PORT_NULL	O
;	O
pthread_cond_init	()->(int)
(	O
&	O
p	*(struct)
->	O
p_wakeup	O
,	O
NULL	O
)	O
;	O
return	O
p	*(struct)
;	O
}	O
struct	O
proc	O
*	O
create_init_proc	()->(*(struct))
(	O
void	O
)	O
{	O
static	O
const	O
uid_t	O
zero	int
;	O
struct	O
proc	O
*	O
p	*(struct)
;	O
const	O
char	O
*	O
rootsname	*(char)
=	O
"root"	*(char)
;	O
p	*(struct)
=	O
allocate_proc	(int)->(*(struct))
(	O
MACH_PORT_NULL	O
)	O
;	O
assert	()->(int)
(	O
p	*(struct)
)	O
;	O
p	*(struct)
->	O
p_pid	O
=	O
HURD_PID_INIT	O
;	O
p	*(struct)
->	O
p_parent	O
=	O
p	*(struct)
;	O
p	*(struct)
->	O
p_sib	O
=	O
0	int
;	O
p	*(struct)
->	O
p_prevsib	O
=	O
&	O
p	*(struct)
->	O
p_ochild	O
;	O
p	*(struct)
->	O
p_ochild	O
=	O
p	*(struct)
;	O
p	*(struct)
->	O
p_parentset	O
=	O
1	int
;	O
p	*(struct)
->	O
p_deadmsg	O
=	O
1	int
;	O
p	*(struct)
->	O
p_important	O
=	O
1	int
;	O
p	*(struct)
->	O
p_noowner	O
=	O
0	int
;	O
p	*(struct)
->	O
p_id	O
=	O
make_ids	(*(int),int)->(*(struct))
(	O
&	O
zero	int
,	O
1	int
)	O
;	O
assert	()->(int)
(	O
p	*(struct)
->	O
p_id	O
)	O
;	O
p	*(struct)
->	O
p_loginleader	O
=	O
1	int
;	O
p	*(struct)
->	O
p_login	O
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
login	O
)	O
+	O
strlen	O
(	O
rootsname	*(char)
)	O
+	O
1	int
)	O
;	O
assert	()->(int)
(	O
p	*(struct)
->	O
p_login	O
)	O
;	O
p	*(struct)
->	O
p_login	O
->	O
l_refcnt	O
=	O
1	int
;	O
strcpy	O
(	O
p	*(struct)
->	O
p_login	O
->	O
l_name	O
,	O
rootsname	*(char)
)	O
;	O
boot_setsid	()->(int)
(	O
p	*(struct)
)	O
;	O
return	O
p	*(struct)
;	O
}	O
void	O
proc_death_notify	(*(struct))->(void)
(	O
struct	O
proc	O
*	O
p	*(struct)
)	O
{	O
error_t	O
err	O
;	O
mach_port_t	O
old	O
;	O
err	O
=	O
mach_port_request_notification	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
p	*(struct)
->	O
p_task	O
,	O
MACH_NOTIFY_DEAD_NAME	O
,	O
1	int
,	O
p	*(struct)
->	O
p_pi	O
.	O
port_right	O
,	O
MACH_MSG_TYPE_MAKE_SEND_ONCE	O
,	O
&	O
old	O
)	O
;	O
assert_perror	()->(int)
(	O
err	O
)	O
;	O
if	O
(	O
old	O
!=	O
MACH_PORT_NULL	O
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
old	O
)	O
;	O
}	O
void	O
complete_proc	(*(struct),int)->(void)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
pid_t	O
pid	*(int)
)	O
{	O
static	O
struct	O
login	O
*	O
nulllogin	*(struct)
;	O
static	O
struct	O
ids	O
nullids	struct
=	O
{	O
i_refcnt	O
:	O
1	int
,	O
i_nuids	O
:	O
0	int
}	O
;	O
const	O
char	O
nullsname	array(char)
[	O
]	O
=	O
"<none>"	*(char)
;	O
if	O
(	O
!	O
nulllogin	*(struct)
)	O
{	O
nulllogin	*(struct)
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
login	O
)	O
+	O
sizeof	O
(	O
nullsname	array(char)
)	O
+	O
1	int
)	O
;	O
nulllogin	*(struct)
->	O
l_refcnt	O
=	O
1	int
;	O
strcpy	O
(	O
nulllogin	*(struct)
->	O
l_name	O
,	O
nullsname	array(char)
)	O
;	O
}	O
p	*(struct)
->	O
p_pid	O
=	O
pid	*(int)
;	O
if	O
(	O
pid	*(int)
==	O
HURD_PID_STARTUP	O
)	O
{	O
static	O
const	O
uid_t	O
zero	int
;	O
p	*(struct)
->	O
p_id	O
=	O
make_ids	(*(int),int)->(*(struct))
(	O
&	O
zero	int
,	O
1	int
)	O
;	O
assert	()->(int)
(	O
p	*(struct)
->	O
p_id	O
)	O
;	O
}	O
else	O
{	O
ids_ref	(*(struct))->(void)
(	O
&	O
nullids	struct
)	O
;	O
p	*(struct)
->	O
p_id	O
=	O
&	O
nullids	struct
;	O
}	O
p	*(struct)
->	O
p_login	O
=	O
nulllogin	*(struct)
;	O
p	*(struct)
->	O
p_login	O
->	O
l_refcnt	O
++	O
;	O
p	*(struct)
->	O
p_parent	O
=	O
init_proc	O
;	O
p	*(struct)
->	O
p_sib	O
=	O
init_proc	O
->	O
p_ochild	O
;	O
p	*(struct)
->	O
p_prevsib	O
=	O
&	O
init_proc	O
->	O
p_ochild	O
;	O
if	O
(	O
p	*(struct)
->	O
p_sib	O
)	O
p	*(struct)
->	O
p_sib	O
->	O
p_prevsib	O
=	O
&	O
p	*(struct)
->	O
p_sib	O
;	O
init_proc	O
->	O
p_ochild	O
=	O
p	*(struct)
;	O
p	*(struct)
->	O
p_loginleader	O
=	O
0	int
;	O
p	*(struct)
->	O
p_ochild	O
=	O
0	int
;	O
p	*(struct)
->	O
p_parentset	O
=	O
0	int
;	O
p	*(struct)
->	O
p_noowner	O
=	O
1	int
;	O
p	*(struct)
->	O
p_pgrp	O
=	O
init_proc	O
->	O
p_pgrp	O
;	O
if	O
(	O
pid	*(int)
!=	O
HURD_PID_STARTUP	O
)	O
{	O
proc_death_notify	(*(struct))->(void)
(	O
p	*(struct)
)	O
;	O
add_proc_to_hash	()->(int)
(	O
p	*(struct)
)	O
;	O
}	O
join_pgrp	()->(int)
(	O
p	*(struct)
)	O
;	O
}	O
static	O
struct	O
proc	O
*	O
new_proc	(int)->(*(struct))
(	O
task_t	O
task	int
)	O
{	O
struct	O
proc	O
*	O
p	*(struct)
;	O
p	*(struct)
=	O
allocate_proc	(int)->(*(struct))
(	O
task	int
)	O
;	O
if	O
(	O
p	*(struct)
)	O
complete_proc	(*(struct),int)->(void)
(	O
p	*(struct)
,	O
genpid	()->(int)
(	O
)	O
)	O
;	O
return	O
p	*(struct)
;	O
}	O
static	O
void	O
namespace_terminate	(*(struct),*(void))->(void)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
void	O
*	O
cookie	*(void)
)	O
{	O
mach_port_t	O
*	O
namespacep	O
=	O
cookie	*(void)
;	O
if	O
(	O
p	*(struct)
->	O
p_task_namespace	O
==	O
*	O
namespacep	O
)	O
task_terminate	()->(int)
(	O
p	*(struct)
->	O
p_task	O
)	O
;	O
}	O
void	O
process_has_exited	()->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
)	O
{	O
if	O
(	O
p	*(struct)
->	O
p_dead	O
)	O
return	O
;	O
p	*(struct)
->	O
p_waited	O
=	O
0	int
;	O
if	O
(	O
p	*(struct)
->	O
p_task	O
!=	O
MACH_PORT_NULL	O
)	O
alert_parent	()->(int)
(	O
p	*(struct)
)	O
;	O
if	O
(	O
p	*(struct)
->	O
p_msgport	O
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
p	*(struct)
->	O
p_msgport	O
)	O
;	O
p	*(struct)
->	O
p_msgport	O
=	O
MACH_PORT_NULL	O
;	O
prociterate	()->(int)
(	O
(	O
void	O
(	O
*	O
)	O
(	O
struct	O
proc	O
*	O
,	O
void	O
*	O
)	O
)	O
check_message_dying	O
,	O
p	*(struct)
)	O
;	O
ports_destroy_right	()->(int)
(	O
p	*(struct)
)	O
;	O
if	O
(	O
!	O
--	O
p	*(struct)
->	O
p_login	O
->	O
l_refcnt	O
)	O
free	()->(int)
(	O
p	*(struct)
->	O
p_login	O
)	O
;	O
ids_rele	(*(struct))->(void)
(	O
p	*(struct)
->	O
p_id	O
)	O
;	O
if	O
(	O
p	*(struct)
->	O
p_ochild	O
)	O
{	O
struct	O
proc	O
*	O
reparent_to	*(struct)
=	O
init_proc	O
;	O
struct	O
proc	O
*	O
tp	*(struct)
;	O
int	O
isdead	int
=	O
0	int
;	O
if	O
(	O
MACH_PORT_VALID	()->(int)
(	O
p	*(struct)
->	O
p_task_namespace	O
)	O
)	O
{	O
for	O
(	O
tp	*(struct)
=	O
p	*(struct)
;	O
MACH_PORT_VALID	()->(int)
(	O
tp	*(struct)
->	O
p_parent	O
->	O
p_task_namespace	O
)	O
;	O
tp	*(struct)
=	O
tp	*(struct)
->	O
p_parent	O
)	O
{	O
}	O
if	O
(	O
p	*(struct)
==	O
tp	*(struct)
)	O
{	O
prociterate	()->(int)
(	O
namespace_terminate	(*(struct),*(void))->(void)
,	O
&	O
p	*(struct)
->	O
p_task_namespace	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
p	*(struct)
->	O
p_task_namespace	O
)	O
;	O
p	*(struct)
->	O
p_task_namespace	O
=	O
MACH_PORT_NULL	O
;	O
}	O
else	O
reparent_to	*(struct)
=	O
tp	*(struct)
;	O
}	O
for	O
(	O
tp	*(struct)
=	O
p	*(struct)
->	O
p_ochild	O
;	O
tp	*(struct)
->	O
p_sib	O
;	O
tp	*(struct)
=	O
tp	*(struct)
->	O
p_sib	O
)	O
{	O
if	O
(	O
tp	*(struct)
->	O
p_msgport	O
!=	O
MACH_PORT_NULL	O
)	O
nowait_msg_proc_newids	()->(int)
(	O
tp	*(struct)
->	O
p_msgport	O
,	O
tp	*(struct)
->	O
p_task	O
,	O
1	int
,	O
tp	*(struct)
->	O
p_pgrp	O
->	O
pg_pgid	O
,	O
!	O
tp	*(struct)
->	O
p_pgrp	O
->	O
pg_orphcnt	O
)	O
;	O
tp	*(struct)
->	O
p_parent	O
=	O
reparent_to	*(struct)
;	O
if	O
(	O
tp	*(struct)
->	O
p_dead	O
)	O
isdead	int
=	O
1	int
;	O
}	O
if	O
(	O
tp	*(struct)
->	O
p_msgport	O
!=	O
MACH_PORT_NULL	O
)	O
nowait_msg_proc_newids	()->(int)
(	O
tp	*(struct)
->	O
p_msgport	O
,	O
tp	*(struct)
->	O
p_task	O
,	O
1	int
,	O
tp	*(struct)
->	O
p_pgrp	O
->	O
pg_pgid	O
,	O
!	O
tp	*(struct)
->	O
p_pgrp	O
->	O
pg_orphcnt	O
)	O
;	O
tp	*(struct)
->	O
p_parent	O
=	O
reparent_to	*(struct)
;	O
tp	*(struct)
->	O
p_sib	O
=	O
reparent_to	*(struct)
->	O
p_ochild	O
;	O
if	O
(	O
tp	*(struct)
->	O
p_sib	O
)	O
tp	*(struct)
->	O
p_sib	O
->	O
p_prevsib	O
=	O
&	O
tp	*(struct)
->	O
p_sib	O
;	O
reparent_to	*(struct)
->	O
p_ochild	O
=	O
p	*(struct)
->	O
p_ochild	O
;	O
p	*(struct)
->	O
p_ochild	O
->	O
p_prevsib	O
=	O
&	O
reparent_to	*(struct)
->	O
p_ochild	O
;	O
if	O
(	O
isdead	int
)	O
alert_parent	()->(int)
(	O
reparent_to	*(struct)
)	O
;	O
}	O
if	O
(	O
p	*(struct)
->	O
p_waiting	O
||	O
p	*(struct)
->	O
p_msgportwait	O
)	O
pthread_cond_broadcast	()->(int)
(	O
&	O
p	*(struct)
->	O
p_wakeup	O
)	O
;	O
p	*(struct)
->	O
p_dead	O
=	O
1	int
;	O
ports_interrupt_rpcs	()->(int)
(	O
p	*(struct)
)	O
;	O
if	O
(	O
MACH_PORT_VALID	()->(int)
(	O
p	*(struct)
->	O
p_task_namespace	O
)	O
)	O
{	O
mach_port_t	O
task	int
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
p	*(struct)
->	O
p_task_namespace	O
)	O
;	O
p	*(struct)
->	O
p_waited	O
=	O
1	int
;	O
task	int
=	O
p	*(struct)
->	O
p_task	O
;	O
p	*(struct)
->	O
p_task	O
=	O
MACH_PORT_NULL	O
;	O
complete_exit	()->(int)
(	O
p	*(struct)
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
task	int
)	O
;	O
}	O
}	O
void	O
complete_exit	()->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
)	O
{	O
assert	()->(int)
(	O
p	*(struct)
->	O
p_dead	O
)	O
;	O
assert	()->(int)
(	O
p	*(struct)
->	O
p_waited	O
)	O
;	O
remove_proc_from_hash	()->(int)
(	O
p	*(struct)
)	O
;	O
if	O
(	O
p	*(struct)
->	O
p_task	O
!=	O
MACH_PORT_NULL	O
)	O
mach_port_destroy	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
p	*(struct)
->	O
p_task	O
)	O
;	O
if	O
(	O
p	*(struct)
->	O
p_sib	O
)	O
p	*(struct)
->	O
p_sib	O
->	O
p_prevsib	O
=	O
p	*(struct)
->	O
p_prevsib	O
;	O
*	O
p	*(struct)
->	O
p_prevsib	O
=	O
p	*(struct)
->	O
p_sib	O
;	O
leave_pgrp	()->(int)
(	O
p	*(struct)
)	O
;	O
ports_port_deref	()->(int)
(	O
p	*(struct)
)	O
;	O
}	O
struct	O
proc	O
*	O
add_tasks	()->(int)
(	O
task_t	O
task	int
)	O
{	O
mach_port_t	O
*	O
psets	O
;	O
size_t	O
npsets	O
;	O
int	O
i	*(struct)
;	O
struct	O
proc	O
*	O
foundp	*(struct)
=	O
0	int
;	O
host_processor_sets	()->(int)
(	O
mach_host_self	()->(int)
(	O
)	O
,	O
&	O
psets	O
,	O
&	O
npsets	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
npsets	O
;	O
i	*(struct)
++	O
)	O
{	O
mach_port_t	O
psetpriv	O
;	O
mach_port_t	O
*	O
tasks	O
;	O
size_t	O
ntasks	O
;	O
int	O
j	int
;	O
if	O
(	O
!	O
foundp	*(struct)
)	O
{	O
host_processor_set_priv	()->(int)
(	O
_hurd_host_priv	O
,	O
psets	O
[	O
i	*(struct)
]	O
,	O
&	O
psetpriv	O
)	O
;	O
processor_set_tasks	()->(int)
(	O
psetpriv	O
,	O
&	O
tasks	O
,	O
&	O
ntasks	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ntasks	O
;	O
j	int
++	O
)	O
{	O
int	O
set	int
=	O
0	int
;	O
if	O
(	O
!	O
MACH_PORT_VALID	()->(int)
(	O
tasks	O
[	O
j	int
]	O
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
foundp	*(struct)
)	O
{	O
struct	O
proc	O
*	O
p	*(struct)
=	O
task_find_nocreate	()->(int)
(	O
tasks	O
[	O
j	int
]	O
)	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
{	O
p	*(struct)
=	O
new_proc	(int)->(*(struct))
(	O
tasks	O
[	O
j	int
]	O
)	O
;	O
set	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
foundp	*(struct)
&&	O
tasks	O
[	O
j	int
]	O
==	O
task	int
)	O
foundp	*(struct)
=	O
p	*(struct)
;	O
}	O
if	O
(	O
!	O
set	int
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
tasks	O
[	O
j	int
]	O
)	O
;	O
}	O
munmap	()->(int)
(	O
tasks	O
,	O
ntasks	O
*	O
sizeof	O
(	O
task_t	O
)	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
psetpriv	O
)	O
;	O
}	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
psets	O
[	O
i	*(struct)
]	O
)	O
;	O
}	O
munmap	()->(int)
(	O
psets	O
,	O
npsets	O
*	O
sizeof	O
(	O
mach_port_t	O
)	O
)	O
;	O
return	O
foundp	*(struct)
;	O
}	O
int	O
genpid	()->(int)
(	O
)	O
{	O
static	O
int	O
nextpid	int
=	O
1	int
;	O
static	O
int	O
wrap	int
=	O
WRAP_AROUND	int
;	O
while	O
(	O
nextpid	int
<	O
wrap	int
&&	O
!	O
pidfree	()->(int)
(	O
nextpid	int
)	O
)	O
++	O
nextpid	int
;	O
if	O
(	O
nextpid	int
>=	O
wrap	int
)	O
{	O
nextpid	int
=	O
START_OVER	int
;	O
while	O
(	O
!	O
pidfree	()->(int)
(	O
nextpid	int
)	O
)	O
nextpid	int
++	O
;	O
while	O
(	O
nextpid	int
>	O
wrap	int
)	O
wrap	int
*=	O
2	int
;	O
}	O
return	O
nextpid	int
++	O
;	O
}	O
error_t	O
S_proc_set_init_task	(*(struct),int)->(int)
(	O
struct	O
proc	O
*	O
callerp	*(struct)
,	O
task_t	O
task	int
)	O
{	O
if	O
(	O
!	O
callerp	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
callerp	*(struct)
!=	O
startup_proc	O
)	O
return	O
EPERM	O
;	O
init_proc	O
->	O
p_task	O
=	O
task	int
;	O
proc_death_notify	(*(struct))->(void)
(	O
init_proc	O
)	O
;	O
add_proc_to_hash	()->(int)
(	O
init_proc	O
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_mark_important	(*(struct))->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
)	O
{	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
!	O
check_uid	(*(struct),int)->(int)
(	O
p	*(struct)
,	O
0	int
)	O
&&	O
p	*(struct)
->	O
p_parent	O
!=	O
startup_proc	O
)	O
return	O
EPERM	O
;	O
p	*(struct)
->	O
p_important	O
=	O
1	int
;	O
return	O
0	int
;	O
}	O
error_t	O
S_proc_is_important	(*(struct),*(int))->(int)
(	O
struct	O
proc	O
*	O
callerp	*(struct)
,	O
boolean_t	O
*	O
essential	*(int)
)	O
{	O
if	O
(	O
!	O
callerp	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
*	O
essential	*(int)
=	O
callerp	*(struct)
->	O
p_important	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_proc_set_code	(*(struct),int,int)->(int)
(	O
struct	O
proc	O
*	O
callerp	*(struct)
,	O
vm_address_t	O
start_code	int
,	O
vm_address_t	O
end_code	int
)	O
{	O
if	O
(	O
!	O
callerp	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
callerp	*(struct)
->	O
start_code	int
=	O
start_code	int
;	O
callerp	*(struct)
->	O
end_code	int
=	O
end_code	int
;	O
return	O
0	int
;	O
}	O
error_t	O
S_proc_get_code	(*(struct),*(int),*(int))->(int)
(	O
struct	O
proc	O
*	O
callerp	*(struct)
,	O
vm_address_t	O
*	O
start_code	int
,	O
vm_address_t	O
*	O
end_code	int
)	O
{	O
if	O
(	O
!	O
callerp	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
*	O
start_code	int
=	O
callerp	*(struct)
->	O
start_code	int
;	O
*	O
end_code	int
=	O
callerp	*(struct)
->	O
end_code	int
;	O
return	O
0	int
;	O
}	O
error_t	O
S_mach_notify_new_task	(*(struct),int,int)->(int)
(	O
struct	O
port_info	O
*	O
notify	*(struct)
,	O
mach_port_t	O
task	int
,	O
mach_port_t	O
parent	int
)	O
{	O
struct	O
proc	O
*	O
parentp	*(struct)
,	O
*	O
childp	*(struct)
;	O
if	O
(	O
!	O
notify	*(struct)
||	O
notify	*(struct)
->	O
class	O
!=	O
generic_port_class	O
)	O
return	O
EOPNOTSUPP	O
;	O
parentp	*(struct)
=	O
task_find_nocreate	()->(int)
(	O
parent	int
)	O
;	O
if	O
(	O
!	O
parentp	*(struct)
)	O
{	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
task	int
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
parent	int
)	O
;	O
return	O
ESRCH	O
;	O
}	O
childp	*(struct)
=	O
task_find_nocreate	()->(int)
(	O
task	int
)	O
;	O
if	O
(	O
!	O
childp	*(struct)
)	O
{	O
mach_port_mod_refs	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
task	int
,	O
MACH_PORT_RIGHT_SEND	O
,	O
+	O
1	int
)	O
;	O
childp	*(struct)
=	O
new_proc	(int)->(*(struct))
(	O
task	int
)	O
;	O
}	O
if	O
(	O
MACH_PORT_VALID	()->(int)
(	O
parentp	*(struct)
->	O
p_task_namespace	O
)	O
)	O
{	O
error_t	O
err	O
;	O
mach_port_mod_refs	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
task	int
,	O
MACH_PORT_RIGHT_SEND	O
,	O
+	O
1	int
)	O
;	O
err	O
=	O
S_proc_child	(*(struct),int)->(int)
(	O
parentp	*(struct)
,	O
task	int
)	O
;	O
assert_perror	()->(int)
(	O
err	O
)	O
;	O
return	O
mach_notify_new_task	()->(int)
(	O
childp	*(struct)
->	O
p_task_namespace	O
,	O
task	int
,	O
parent	int
)	O
;	O
}	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
task	int
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
parent	int
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_proc_make_task_namespace	(*(struct),int)->(int)
(	O
struct	O
proc	O
*	O
callerp	*(struct)
,	O
mach_port_t	O
notify	*(struct)
)	O
{	O
if	O
(	O
!	O
callerp	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
!	O
MACH_PORT_VALID	()->(int)
(	O
notify	*(struct)
)	O
)	O
return	O
EINVAL	O
;	O
if	O
(	O
MACH_PORT_VALID	()->(int)
(	O
callerp	*(struct)
->	O
p_task_namespace	O
)	O
)	O
{	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
notify	*(struct)
)	O
;	O
return	O
EBUSY	O
;	O
}	O
callerp	*(struct)
->	O
p_task_namespace	O
=	O
notify	*(struct)
;	O
return	O
0	int
;	O
}	O
