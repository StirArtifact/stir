error_t	O
proc_stat_list_create	(*(struct),*(*(struct)))->(int)
(	O
struct	O
ps_context	O
*	O
context	*(struct)
,	O
struct	O
proc_stat_list	O
*	O
*	O
pp	*(*(struct))
)	O
{	O
*	O
pp	*(*(struct))
=	O
NEW	()->(int)
(	O
struct	O
proc_stat_list	O
)	O
;	O
if	O
(	O
*	O
pp	*(*(struct))
==	O
NULL	O
)	O
return	O
ENOMEM	O
;	O
(	O
*	O
pp	*(*(struct))
)	O
->	O
proc_stats	*(*(*(struct)))
=	O
0	int
;	O
(	O
*	O
pp	*(*(struct))
)	O
->	O
num_procs	int
=	O
0	int
;	O
(	O
*	O
pp	*(*(struct))
)	O
->	O
alloced	O
=	O
0	int
;	O
(	O
*	O
pp	*(*(struct))
)	O
->	O
context	*(struct)
=	O
context	*(struct)
;	O
return	O
0	int
;	O
}	O
void	O
proc_stat_list_free	(*(struct))->(void)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
)	O
{	O
proc_stat_list_remove_threads	()->(int)
(	O
pp	*(*(struct))
)	O
;	O
FREE	()->(int)
(	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
)	O
;	O
FREE	()->(int)
(	O
pp	*(*(struct))
)	O
;	O
}	O
error_t	O
proc_stat_list_clone	(*(struct),*(*(struct)))->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
struct	O
proc_stat_list	O
*	O
*	O
copy	*(*(struct))
)	O
{	O
struct	O
proc_stat_list	O
*	O
new	*(struct)
=	O
NEW	()->(int)
(	O
struct	O
proc_stat_list	O
)	O
;	O
struct	O
proc_stat	O
*	O
*	O
procs	*(*(struct))
=	O
NEWVEC	()->(int)
(	O
struct	O
proc_stat	O
*	O
,	O
pp	*(*(struct))
->	O
num_procs	int
)	O
;	O
if	O
(	O
!	O
new	*(struct)
||	O
!	O
procs	*(*(struct))
)	O
{	O
if	O
(	O
new	*(struct)
)	O
free	()->(int)
(	O
new	*(struct)
)	O
;	O
if	O
(	O
procs	*(*(struct))
)	O
free	()->(int)
(	O
procs	*(*(struct))
)	O
;	O
return	O
ENOMEM	O
;	O
}	O
bcopy	()->(int)
(	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
,	O
procs	*(*(struct))
,	O
pp	*(*(struct))
->	O
num_procs	int
)	O
;	O
new	*(struct)
->	O
proc_stats	*(*(*(struct)))
=	O
procs	*(*(struct))
;	O
new	*(struct)
->	O
num_procs	int
=	O
pp	*(*(struct))
->	O
num_procs	int
;	O
new	*(struct)
->	O
alloced	O
=	O
pp	*(*(struct))
->	O
num_procs	int
;	O
new	*(struct)
->	O
context	*(struct)
=	O
pp	*(*(struct))
->	O
context	*(struct)
;	O
*	O
copy	*(*(struct))
=	O
new	*(struct)
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
proc_stat_list_grow	(*(struct),int)->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
int	O
amount	int
)	O
{	O
amount	int
+=	O
pp	*(*(struct))
->	O
num_procs	int
;	O
if	O
(	O
amount	int
>	O
pp	*(*(struct))
->	O
alloced	O
)	O
{	O
struct	O
proc_stat	O
*	O
*	O
new_procs	*(*(struct))
=	O
GROWVEC	()->(int)
(	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
,	O
struct	O
proc_stat	O
*	O
,	O
amount	int
)	O
;	O
if	O
(	O
new_procs	*(*(struct))
==	O
NULL	O
)	O
return	O
ENOMEM	O
;	O
pp	*(*(struct))
->	O
alloced	O
=	O
amount	int
;	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
=	O
new_procs	*(*(struct))
;	O
}	O
return	O
0	int
;	O
}	O
error_t	O
proc_stat_list_add_pids	(*(struct),*(int),int,*(*(*(struct))))->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
pid_t	O
*	O
pids	*(int)
,	O
unsigned	O
num_procs	int
,	O
struct	O
proc_stat	O
*	O
*	O
*	O
proc_stats	*(*(*(struct)))
)	O
{	O
error_t	O
err	O
=	O
proc_stat_list_grow	(*(struct),int)->(int)
(	O
pp	*(*(struct))
,	O
num_procs	int
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
else	O
{	O
int	O
i	int
;	O
struct	O
proc_stat	O
*	O
*	O
end	*(*(struct))
=	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
+	O
pp	*(*(struct))
->	O
num_procs	int
;	O
if	O
(	O
proc_stats	*(*(*(struct)))
)	O
*	O
proc_stats	*(*(*(struct)))
=	O
NEWVEC	()->(int)
(	O
struct	O
proc_stat	O
*	O
,	O
num_procs	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_procs	int
;	O
i	int
++	O
)	O
{	O
int	O
pid	int
=	O
*	O
pids	*(int)
++	O
;	O
struct	O
proc_stat	O
*	O
ps	*(struct)
=	O
proc_stat_list_pid_proc_stat	()->(int)
(	O
pp	*(*(struct))
,	O
pid	int
)	O
;	O
if	O
(	O
ps	*(struct)
==	O
NULL	O
)	O
{	O
err	O
=	O
ps_context_find_proc_stat	()->(int)
(	O
pp	*(*(struct))
->	O
context	*(struct)
,	O
pid	int
,	O
end	*(*(struct))
)	O
;	O
if	O
(	O
err	O
)	O
{	O
if	O
(	O
proc_stats	*(*(*(struct)))
)	O
free	()->(int)
(	O
*	O
proc_stats	*(*(*(struct)))
)	O
;	O
return	O
err	O
;	O
}	O
else	O
ps	*(struct)
=	O
*	O
end	*(*(struct))
++	O
;	O
}	O
if	O
(	O
proc_stats	*(*(*(struct)))
)	O
(	O
*	O
proc_stats	*(*(*(struct)))
)	O
[	O
i	int
]	O
=	O
ps	*(struct)
;	O
}	O
pp	*(*(struct))
->	O
num_procs	int
=	O
end	*(*(struct))
-	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
;	O
return	O
0	int
;	O
}	O
}	O
error_t	O
proc_stat_list_add_pid	(*(struct),int,*(*(struct)))->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
pid_t	O
pid	int
,	O
struct	O
proc_stat	O
*	O
*	O
ps	*(struct)
)	O
{	O
struct	O
proc_stat	O
*	O
_ps	*(struct)
=	O
proc_stat_list_pid_proc_stat	()->(int)
(	O
pp	*(*(struct))
,	O
pid	int
)	O
;	O
if	O
(	O
_ps	*(struct)
==	O
NULL	O
)	O
{	O
error_t	O
err	O
;	O
if	O
(	O
pp	*(*(struct))
->	O
num_procs	int
==	O
pp	*(*(struct))
->	O
alloced	O
)	O
{	O
err	O
=	O
proc_stat_list_grow	(*(struct),int)->(int)
(	O
pp	*(*(struct))
,	O
32	int
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
}	O
err	O
=	O
ps_context_find_proc_stat	()->(int)
(	O
pp	*(*(struct))
->	O
context	*(struct)
,	O
pid	int
,	O
&	O
_ps	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
[	O
pp	*(*(struct))
->	O
num_procs	int
++	O
]	O
=	O
_ps	*(struct)
;	O
}	O
if	O
(	O
ps	*(struct)
)	O
*	O
ps	*(struct)
=	O
_ps	*(struct)
;	O
return	O
0	int
;	O
}	O
struct	O
proc_stat	O
*	O
proc_stat_list_pid_proc_stat	()->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
pid_t	O
pid	int
)	O
{	O
unsigned	O
nprocs	int
=	O
pp	*(*(struct))
->	O
num_procs	int
;	O
struct	O
proc_stat	O
*	O
*	O
procs	*(*(struct))
=	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
;	O
while	O
(	O
nprocs	int
--	O
>	O
0	int
)	O
if	O
(	O
proc_stat_pid	()->(int)
(	O
*	O
procs	*(*(struct))
)	O
==	O
pid	int
)	O
return	O
*	O
procs	*(*(struct))
;	O
else	O
procs	*(*(struct))
++	O
;	O
return	O
NULL	O
;	O
}	O
error_t	O
proc_stat_list_merge	(*(struct),*(struct))->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
struct	O
proc_stat_list	O
*	O
mergee	*(struct)
)	O
{	O
if	O
(	O
pp	*(*(struct))
->	O
context	*(struct)
!=	O
mergee	*(struct)
->	O
context	*(struct)
)	O
return	O
EINVAL	O
;	O
else	O
{	O
error_t	O
err	O
=	O
proc_stat_list_grow	(*(struct),int)->(int)
(	O
pp	*(*(struct))
,	O
mergee	*(struct)
->	O
num_procs	int
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
else	O
{	O
int	O
mnprocs	int
=	O
mergee	*(struct)
->	O
num_procs	int
;	O
struct	O
proc_stat	O
*	O
*	O
mprocs	*(*(struct))
=	O
mergee	*(struct)
->	O
proc_stats	*(*(*(struct)))
;	O
int	O
nprocs	int
=	O
pp	*(*(struct))
->	O
num_procs	int
;	O
struct	O
proc_stat	O
*	O
*	O
procs	*(*(struct))
=	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
;	O
while	O
(	O
mnprocs	int
--	O
>	O
0	int
)	O
if	O
(	O
proc_stat_list_pid_proc_stat	()->(int)
(	O
pp	*(*(struct))
,	O
proc_stat_pid	()->(int)
(	O
mprocs	*(*(struct))
[	O
mnprocs	int
]	O
)	O
)	O
==	O
NULL	O
)	O
{	O
procs	*(*(struct))
[	O
nprocs	int
++	O
]	O
=	O
mprocs	*(*(struct))
[	O
mnprocs	int
]	O
;	O
mprocs	*(*(struct))
[	O
mnprocs	int
]	O
=	O
NULL	O
;	O
}	O
proc_stat_list_free	(*(struct))->(void)
(	O
mergee	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
static	O
error_t	O
proc_stat_list_add_fn_pids	(*(struct),(*(int))->(int),*(*(*(struct))),*(long))->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
kern_return_t	(*(int))->(int)
(	O
*	O
fetch_fn	*(int)
)	O
(	O
process_t	O
proc	int
,	O
pid_t	O
*	O
*	O
pids	*(int)
,	O
size_t	long
*	O
num_pids	*(long)
)	O
,	O
struct	O
proc_stat	O
*	O
*	O
*	O
proc_stats	*(*(*(struct)))
,	O
size_t	long
*	O
num_procs	int
)	O
{	O
error_t	O
err	O
;	O
pid_t	O
pid_array	O
[	O
STATICPIDS	int
]	O
,	O
*	O
pids	*(int)
=	O
pid_array	O
;	O
size_t	long
num_pids	*(long)
=	O
STATICPIDS	int
;	O
err	O
=	O
(	O
*	O
fetch_fn	*(int)
)	O
(	O
ps_context_server	()->(int)
(	O
pp	*(*(struct))
->	O
context	*(struct)
)	O
,	O
&	O
pids	*(int)
,	O
&	O
num_pids	*(long)
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
err	O
=	O
proc_stat_list_add_pids	(*(struct),*(int),int,*(*(*(struct))))->(int)
(	O
pp	*(*(struct))
,	O
pids	*(int)
,	O
num_pids	*(long)
,	O
proc_stats	*(*(*(struct)))
)	O
;	O
if	O
(	O
!	O
err	O
&&	O
num_procs	int
)	O
*	O
num_procs	int
=	O
num_pids	*(long)
;	O
if	O
(	O
pids	*(int)
!=	O
pid_array	O
)	O
VMFREE	()->(int)
(	O
pids	*(int)
,	O
sizeof	O
(	O
pid_t	O
)	O
*	O
num_pids	*(long)
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
proc_stat_list_add_id_fn_pids	(*(struct),int,(*(int))->(int),*(*(*(struct))),*(long))->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
unsigned	O
id	int
,	O
kern_return_t	(*(int))->(int)
(	O
*	O
fetch_fn	*(int)
)	O
(	O
process_t	O
proc	int
,	O
pid_t	O
id	int
,	O
pid_t	O
*	O
*	O
pids	*(int)
,	O
size_t	long
*	O
num_pids	*(long)
)	O
,	O
struct	O
proc_stat	O
*	O
*	O
*	O
proc_stats	*(*(*(struct)))
,	O
size_t	long
*	O
num_procs	int
)	O
{	O
error_t	O
id_fetch_fn	O
(	O
process_t	O
proc	int
,	O
pid_t	O
*	O
*	O
pids	*(int)
,	O
size_t	long
*	O
num_pids	*(long)
)	O
{	O
return	O
(	O
*	O
fetch_fn	*(int)
)	O
(	O
proc	int
,	O
id	int
,	O
pids	*(int)
,	O
num_pids	*(long)
)	O
;	O
}	O
return	O
proc_stat_list_add_fn_pids	(*(struct),(*(int))->(int),*(*(*(struct))),*(long))->(int)
(	O
pp	*(*(struct))
,	O
id_fetch_fn	O
,	O
proc_stats	*(*(*(struct)))
,	O
num_procs	int
)	O
;	O
}	O
error_t	O
proc_stat_list_add_all	(*(struct),*(*(*(struct))),*(long))->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
struct	O
proc_stat	O
*	O
*	O
*	O
proc_stats	*(*(*(struct)))
,	O
size_t	long
*	O
num_procs	int
)	O
{	O
return	O
proc_stat_list_add_fn_pids	(*(struct),(*(int))->(int),*(*(*(struct))),*(long))->(int)
(	O
pp	*(*(struct))
,	O
proc_getallpids	O
,	O
proc_stats	*(*(*(struct)))
,	O
num_procs	int
)	O
;	O
}	O
error_t	O
proc_stat_list_add_login_coll	(*(struct),int,*(*(*(struct))),*(long))->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
pid_t	O
login_id	int
,	O
struct	O
proc_stat	O
*	O
*	O
*	O
proc_stats	*(*(*(struct)))
,	O
size_t	long
*	O
num_procs	int
)	O
{	O
return	O
proc_stat_list_add_id_fn_pids	(*(struct),int,(*(int))->(int),*(*(*(struct))),*(long))->(int)
(	O
pp	*(*(struct))
,	O
login_id	int
,	O
proc_getloginpids	O
,	O
proc_stats	*(*(*(struct)))
,	O
num_procs	int
)	O
;	O
}	O
error_t	O
proc_stat_list_add_session	(*(struct),int,*(*(*(struct))),*(long))->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
pid_t	O
session_id	int
,	O
struct	O
proc_stat	O
*	O
*	O
*	O
proc_stats	*(*(*(struct)))
,	O
size_t	long
*	O
num_procs	int
)	O
{	O
return	O
proc_stat_list_add_id_fn_pids	(*(struct),int,(*(int))->(int),*(*(*(struct))),*(long))->(int)
(	O
pp	*(*(struct))
,	O
session_id	int
,	O
proc_getsessionpids	O
,	O
proc_stats	*(*(*(struct)))
,	O
num_procs	int
)	O
;	O
}	O
error_t	O
proc_stat_list_add_pgrp	(*(struct),int,*(*(*(struct))),*(long))->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
pid_t	O
pgrp	int
,	O
struct	O
proc_stat	O
*	O
*	O
*	O
proc_stats	*(*(*(struct)))
,	O
size_t	long
*	O
num_procs	int
)	O
{	O
return	O
proc_stat_list_add_id_fn_pids	(*(struct),int,(*(int))->(int),*(*(*(struct))),*(long))->(int)
(	O
pp	*(*(struct))
,	O
pgrp	int
,	O
proc_getpgrppids	O
,	O
proc_stats	*(*(*(struct)))
,	O
num_procs	int
)	O
;	O
}	O
error_t	O
proc_stat_list_set_flags	(*(struct),int)->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
ps_flags_t	O
flags	int
)	O
{	O
unsigned	O
nprocs	int
=	O
pp	*(*(struct))
->	O
num_procs	int
;	O
struct	O
proc_stat	O
*	O
*	O
procs	*(*(struct))
=	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
;	O
while	O
(	O
nprocs	int
--	O
>	O
0	int
)	O
{	O
struct	O
proc_stat	O
*	O
ps	*(struct)
=	O
*	O
procs	*(*(struct))
++	O
;	O
if	O
(	O
!	O
proc_stat_has	()->(int)
(	O
ps	*(struct)
,	O
flags	int
)	O
)	O
{	O
error_t	O
err	O
=	O
proc_stat_set_flags	O
(	O
ps	*(struct)
,	O
flags	int
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
error_t	O
proc_stat_list_filter1	(*(struct),*((*(struct))->(int)),int,int)->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
int	O
(	O
*	O
predicate	*((*(struct))->(int))
)	O
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
,	O
ps_flags_t	O
flags	int
,	O
int	O
invert	int
)	O
{	O
unsigned	O
which	int
=	O
0	int
;	O
unsigned	O
num_procs	int
=	O
pp	*(*(struct))
->	O
num_procs	int
;	O
struct	O
proc_stat	O
*	O
*	O
procs	*(*(struct))
=	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
;	O
struct	O
proc_stat	O
*	O
*	O
kept	*(*(struct))
=	O
procs	*(*(struct))
;	O
error_t	O
err	O
=	O
proc_stat_list_set_flags	(*(struct),int)->(int)
(	O
pp	*(*(struct))
,	O
flags	int
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
invert	int
=	O
!	O
!	O
invert	int
;	O
while	O
(	O
which	int
<	O
num_procs	int
)	O
{	O
struct	O
proc_stat	O
*	O
ps	*(struct)
=	O
procs	*(*(struct))
[	O
which	int
++	O
]	O
;	O
if	O
(	O
!	O
proc_stat_has	()->(int)
(	O
ps	*(struct)
,	O
flags	int
)	O
||	O
!	O
!	O
predicate	*((*(struct))->(int))
(	O
ps	*(struct)
)	O
!=	O
invert	int
)	O
*	O
kept	*(*(struct))
++	O
=	O
ps	*(struct)
;	O
}	O
pp	*(*(struct))
->	O
num_procs	int
=	O
kept	*(*(struct))
-	O
procs	*(*(struct))
;	O
return	O
0	int
;	O
}	O
error_t	O
proc_stat_list_filter	(*(struct),*(struct),int)->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
const	O
struct	O
ps_filter	O
*	O
filter	*(struct)
,	O
int	O
invert	int
)	O
{	O
return	O
proc_stat_list_filter1	(*(struct),*((*(struct))->(int)),int,int)->(int)
(	O
pp	*(*(struct))
,	O
ps_filter_predicate	()->(int)
(	O
filter	*(struct)
)	O
,	O
ps_filter_needs	()->(int)
(	O
filter	*(struct)
)	O
,	O
invert	int
)	O
;	O
}	O
error_t	O
proc_stat_list_sort1	(*(struct),*(struct),*((*(struct),*(struct),*(struct))->(int)),int)->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
,	O
int	O
(	O
*	O
cmp_fn	*((*(struct),*(struct),*(struct))->(int))
)	O
(	O
struct	O
proc_stat	O
*	O
ps1	*(struct)
,	O
struct	O
proc_stat	O
*	O
ps2	*(struct)
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
)	O
,	O
int	O
reverse	int
)	O
{	O
int	O
needs	int
=	O
ps_getter_needs	()->(int)
(	O
getter	*(struct)
)	O
;	O
struct	O
proc_stat	O
*	O
*	O
procs	*(*(struct))
=	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
;	O
error_t	O
err	O
=	O
proc_stat_list_set_flags	(*(struct),int)->(int)
(	O
pp	*(*(struct))
,	O
needs	int
)	O
;	O
int	O
lessp	O
(	O
const	O
void	O
*	O
p1	*(void)
,	O
const	O
void	O
*	O
p2	*(void)
)	O
{	O
struct	O
proc_stat	O
*	O
ps1	*(struct)
=	O
*	O
(	O
struct	O
proc_stat	O
*	O
*	O
)	O
p1	*(void)
;	O
struct	O
proc_stat	O
*	O
ps2	*(struct)
=	O
*	O
(	O
struct	O
proc_stat	O
*	O
*	O
)	O
p2	*(void)
;	O
int	O
is_th_1	O
=	O
proc_stat_is_thread	O
(	O
ps1	*(struct)
)	O
;	O
int	O
is_th_2	O
=	O
proc_stat_is_thread	O
(	O
ps2	*(struct)
)	O
;	O
if	O
(	O
!	O
is_th_1	O
||	O
!	O
is_th_2	O
||	O
proc_stat_thread_origin	O
(	O
ps1	*(struct)
)	O
!=	O
proc_stat_thread_origin	O
(	O
ps2	*(struct)
)	O
)	O
{	O
if	O
(	O
is_th_1	O
)	O
ps1	*(struct)
=	O
proc_stat_thread_origin	O
(	O
ps1	*(struct)
)	O
;	O
if	O
(	O
is_th_2	O
)	O
ps2	*(struct)
=	O
proc_stat_thread_origin	O
(	O
ps2	*(struct)
)	O
;	O
}	O
if	O
(	O
ps1	*(struct)
==	O
ps2	*(struct)
||	O
!	O
proc_stat_has	()->(int)
(	O
ps1	*(struct)
,	O
needs	int
)	O
||	O
!	O
proc_stat_has	()->(int)
(	O
ps2	*(struct)
,	O
needs	int
)	O
)	O
return	O
p1	*(void)
-	O
p2	*(void)
;	O
else	O
if	O
(	O
reverse	int
)	O
return	O
cmp_fn	*((*(struct),*(struct),*(struct))->(int))
(	O
ps2	*(struct)
,	O
ps1	*(struct)
,	O
getter	*(struct)
)	O
;	O
else	O
return	O
cmp_fn	*((*(struct),*(struct),*(struct))->(int))
(	O
ps1	*(struct)
,	O
ps2	*(struct)
,	O
getter	*(struct)
)	O
;	O
}	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
qsort	()->(int)
(	O
(	O
void	O
*	O
)	O
procs	*(*(struct))
,	O
(	O
size_t	long
)	O
pp	*(*(struct))
->	O
num_procs	int
,	O
sizeof	O
(	O
struct	O
proc_stat	O
*	O
)	O
,	O
lessp	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
proc_stat_list_sort	(*(struct),*(struct),int)->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
const	O
struct	O
ps_fmt_spec	O
*	O
key	*(struct)
,	O
int	O
reverse	int
)	O
{	O
int	O
(	O
*	O
cmp_fn	*((*(struct),*(struct),*(struct))->(int))
)	O
(	O
)	O
=	O
ps_fmt_spec_compare_fn	()->(int)
(	O
key	*(struct)
)	O
;	O
if	O
(	O
cmp_fn	*((*(struct),*(struct),*(struct))->(int))
==	O
NULL	O
)	O
return	O
EINVAL	O
;	O
else	O
return	O
proc_stat_list_sort1	(*(struct),*(struct),*((*(struct),*(struct),*(struct))->(int)),int)->(int)
(	O
pp	*(*(struct))
,	O
ps_fmt_spec_getter	()->(int)
(	O
key	*(struct)
)	O
,	O
cmp_fn	*((*(struct),*(struct),*(struct))->(int))
,	O
reverse	int
)	O
;	O
}	O
error_t	O
proc_stat_list_fmt	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
struct	O
ps_fmt	O
*	O
fmt	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
unsigned	O
nprocs	int
=	O
pp	*(*(struct))
->	O
num_procs	int
;	O
struct	O
proc_stat	O
*	O
*	O
procs	*(*(struct))
=	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
;	O
error_t	O
err	O
=	O
proc_stat_list_set_flags	(*(struct),int)->(int)
(	O
pp	*(*(struct))
,	O
ps_fmt_needs	O
(	O
fmt	*(struct)
)	O
)	O
;	O
while	O
(	O
!	O
err	O
&&	O
nprocs	int
--	O
>	O
0	int
)	O
{	O
err	O
=	O
ps_fmt_write_proc_stat	()->(int)
(	O
fmt	*(struct)
,	O
*	O
procs	*(*(struct))
++	O
,	O
stream	*(struct)
)	O
;	O
if	O
(	O
!	O
err	O
)	O
ps_stream_newline	()->(int)
(	O
stream	*(struct)
)	O
;	O
}	O
return	O
err	O
;	O
}	O
error_t	O
proc_stat_list_find_bogus_flags	(*(struct),*(int))->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
ps_flags_t	O
*	O
flags	int
)	O
{	O
unsigned	O
nprocs	int
=	O
pp	*(*(struct))
->	O
num_procs	int
;	O
struct	O
proc_stat	O
*	O
*	O
procs	*(*(struct))
=	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
;	O
error_t	O
err	O
=	O
proc_stat_list_set_flags	(*(struct),int)->(int)
(	O
pp	*(*(struct))
,	O
*	O
flags	int
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
while	O
(	O
nprocs	int
--	O
>	O
0	int
&&	O
*	O
flags	int
!=	O
0	int
)	O
*	O
flags	int
&=	O
~	O
proc_stat_flags	()->(int)
(	O
*	O
procs	*(*(struct))
++	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
proc_stat_list_add_threads	(*(struct))->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
)	O
{	O
error_t	O
err	O
=	O
proc_stat_list_set_flags	(*(struct),int)->(int)
(	O
pp	*(*(struct))
,	O
PSTAT_NUM_THREADS	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
else	O
{	O
int	O
new_entries	int
=	O
0	int
;	O
int	O
nprocs	int
=	O
pp	*(*(struct))
->	O
num_procs	int
;	O
struct	O
proc_stat	O
*	O
*	O
procs	*(*(struct))
=	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
;	O
while	O
(	O
nprocs	int
--	O
>	O
0	int
)	O
{	O
struct	O
proc_stat	O
*	O
ps	*(struct)
=	O
*	O
procs	*(*(struct))
++	O
;	O
if	O
(	O
proc_stat_has	()->(int)
(	O
ps	*(struct)
,	O
PSTAT_NUM_THREADS	O
)	O
)	O
new_entries	int
+=	O
proc_stat_num_threads	()->(int)
(	O
ps	*(struct)
)	O
;	O
}	O
err	O
=	O
proc_stat_list_grow	(*(struct),int)->(int)
(	O
pp	*(*(struct))
,	O
new_entries	int
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
else	O
{	O
struct	O
proc_stat	O
*	O
*	O
end	*(*(struct))
=	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
+	O
pp	*(*(struct))
->	O
num_procs	int
+	O
new_entries	int
;	O
nprocs	int
=	O
pp	*(*(struct))
->	O
num_procs	int
;	O
procs	*(*(struct))
=	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
+	O
nprocs	int
;	O
while	O
(	O
nprocs	int
--	O
>	O
0	int
)	O
{	O
struct	O
proc_stat	O
*	O
ps	*(struct)
=	O
*	O
--	O
procs	*(*(struct))
;	O
if	O
(	O
proc_stat_has	()->(int)
(	O
ps	*(struct)
,	O
PSTAT_NUM_THREADS	O
)	O
)	O
{	O
int	O
nthreads	int
=	O
proc_stat_num_threads	()->(int)
(	O
ps	*(struct)
)	O
;	O
while	O
(	O
nthreads	int
--	O
>	O
0	int
)	O
proc_stat_thread_create	()->(int)
(	O
ps	*(struct)
,	O
nthreads	int
,	O
--	O
end	*(*(struct))
)	O
;	O
}	O
*	O
--	O
end	*(*(struct))
=	O
ps	*(struct)
;	O
}	O
pp	*(*(struct))
->	O
num_procs	int
+=	O
new_entries	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
error_t	O
proc_stat_list_remove_threads	()->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
)	O
{	O
int	O
is_thread	O
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_is_thread	O
(	O
ps	*(struct)
)	O
;	O
}	O
return	O
proc_stat_list_filter1	(*(struct),*((*(struct))->(int)),int,int)->(int)
(	O
pp	*(*(struct))
,	O
is_thread	O
,	O
0	int
,	O
FALSE	O
)	O
;	O
}	O
int	O
proc_stat_list_for_each	(*(struct),*((*(struct))->(int)))->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
int	O
(	O
*	O
fn	*((*(struct))->(int))
)	O
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
)	O
{	O
unsigned	O
nprocs	int
=	O
pp	*(*(struct))
->	O
num_procs	int
;	O
struct	O
proc_stat	O
*	O
*	O
procs	*(*(struct))
=	O
pp	*(*(struct))
->	O
proc_stats	*(*(*(struct)))
;	O
while	O
(	O
nprocs	int
--	O
>	O
0	int
)	O
{	O
int	O
val	int
=	O
(	O
*	O
fn	*((*(struct))->(int))
)	O
(	O
*	O
procs	*(*(struct))
++	O
)	O
;	O
if	O
(	O
val	int
)	O
return	O
val	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
proc_stat_list_spec_nominal	(*(struct),*(struct))->(int)
(	O
struct	O
proc_stat_list	O
*	O
pp	*(*(struct))
,	O
const	O
struct	O
ps_fmt_spec	O
*	O
spec	*(struct)
)	O
{	O
int	O
(	O
*	O
nominal_fn	*((*(struct),*(struct))->(int))
)	O
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
)	O
=	O
spec	*(struct)
->	O
nominal_fn	*((*(struct),*(struct))->(int))
;	O
if	O
(	O
nominal_fn	*((*(struct),*(struct))->(int))
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
else	O
{	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
=	O
ps_fmt_spec_getter	()->(int)
(	O
spec	*(struct)
)	O
;	O
ps_flags_t	O
needs	int
=	O
ps_getter_needs	()->(int)
(	O
getter	*(struct)
)	O
;	O
int	O
interesting	O
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_has	()->(int)
(	O
ps	*(struct)
,	O
needs	int
)	O
&&	O
!	O
(	O
*	O
nominal_fn	*((*(struct),*(struct))->(int))
)	O
(	O
ps	*(struct)
,	O
getter	*(struct)
)	O
;	O
}	O
proc_stat_list_set_flags	(*(struct),int)->(int)
(	O
pp	*(*(struct))
,	O
needs	int
)	O
;	O
return	O
!	O
proc_stat_list_for_each	(*(struct),*((*(struct))->(int)))->(int)
(	O
pp	*(*(struct))
,	O
interesting	O
)	O
;	O
}	O
}	O
