static	O
int	O
copy_regular_file	(*(char),*(char),int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
const	O
char	O
*	O
srcpath	*(char)
,	O
const	O
char	O
*	O
dstpath	*(char)
,	O
int	O
flags	int
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
st	*(struct(long,long,long))
)	O
;	O
static	O
int	O
copy_symlink	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
srcpath	*(char)
,	O
const	O
char	O
*	O
dstpath	*(char)
)	O
;	O
static	O
int	O
copy_dir	(*(char),*(char),int)->(int)
(	O
const	O
char	O
*	O
srcpath	*(char)
,	O
const	O
char	O
*	O
dstpath	*(char)
,	O
int	O
flags	int
)	O
;	O
int	O
mu_copy_file	(*(char),*(char),int)->(int)
(	O
const	O
char	O
*	O
srcpath	*(char)
,	O
const	O
char	O
*	O
dstpath	*(char)
,	O
int	O
flags	int
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long))
;	O
if	O
(	O
(	O
(	O
flags	int
&	O
MU_COPY_DEREF	int
)	O
?	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
:	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
)	O
(	O
srcpath	*(char)
,	O
&	O
st	*(struct(long,long,long))
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"can't stat file %s: %s"	*(char)
)	O
,	O
srcpath	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
errno	O
;	O
}	O
if	O
(	O
access	(*(char),int)->(int)
(	O
dstpath	*(char)
,	O
F_OK	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
flags	int
&	O
MU_COPY_OVERWRITE	int
)	O
{	O
rc	int
=	O
mu_remove_file	(*(char))->(int)
(	O
dstpath	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"can't remove destination %s: %s"	*(char)
)	O
,	O
dstpath	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
}	O
else	O
return	O
EEXIST	int
;	O
}	O
switch	O
(	O
st	*(struct(long,long,long))
.	O
st_mode	int
&	O
S_IFMT	O
)	O
{	O
case	O
S_IFREG	O
:	O
return	O
copy_regular_file	(*(char),*(char),int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
srcpath	*(char)
,	O
dstpath	*(char)
,	O
flags	int
,	O
&	O
st	*(struct(long,long,long))
)	O
;	O
case	O
S_IFLNK	O
:	O
return	O
copy_symlink	(*(char),*(char))->(int)
(	O
srcpath	*(char)
,	O
dstpath	*(char)
)	O
;	O
case	O
S_IFDIR	O
:	O
return	O
copy_dir	(*(char),*(char),int)->(int)
(	O
srcpath	*(char)
,	O
dstpath	*(char)
,	O
flags	int
)	O
;	O
case	O
S_IFBLK	O
:	O
case	O
S_IFCHR	O
:	O
if	O
(	O
mknod	(*(char),int,long)->(int)
(	O
dstpath	*(char)
,	O
st	*(struct(long,long,long))
.	O
st_mode	int
&	O
0777	int
,	O
st	*(struct(long,long,long))
.	O
st_dev	long
)	O
)	O
{	O
rc	int
=	O
errno	O
;	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: cannot create node: %s"	*(char)
)	O
,	O
dstpath	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
S_IFIFO	O
:	O
if	O
(	O
mkfifo	(*(char),int)->(int)
(	O
dstpath	*(char)
,	O
st	*(struct(long,long,long))
.	O
st_mode	int
&	O
0777	int
)	O
)	O
{	O
rc	int
=	O
errno	O
;	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: cannot create node: %s"	*(char)
)	O
,	O
dstpath	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: don't know how to copy file of that type"	*(char)
)	O
,	O
srcpath	*(char)
)	O
)	O
;	O
return	O
ENOTSUP	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
copy_regular_file	(*(char),*(char),int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
const	O
char	O
*	O
srcpath	*(char)
,	O
const	O
char	O
*	O
dstpath	*(char)
,	O
int	O
flags	int
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
st	*(struct(long,long,long))
)	O
{	O
int	O
rc	int
;	O
mu_stream_t	*(struct)
src	*(struct)
,	O
dst	*(struct)
;	O
mode_t	int
mask	int
,	O
mode	int
;	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
src	*(struct)
,	O
srcpath	*(char)
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"cannot open source file %s: %s"	*(char)
)	O
,	O
srcpath	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
mask	int
=	O
umask	(int)->(int)
(	O
077	int
)	O
;	O
mode	int
=	O
(	O
(	O
flags	int
&	O
MU_COPY_MODE	int
)	O
?	O
st	*(struct(long,long,long))
->	O
st_mode	int
:	O
(	O
0666	int
&	O
~	O
mask	int
)	O
)	O
&	O
0777	int
;	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
dst	*(struct)
,	O
dstpath	*(char)
,	O
MU_STREAM_CREAT	int
|	O
MU_STREAM_WRITE	int
)	O
;	O
umask	(int)->(int)
(	O
mask	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"cannot open destination file %s: %s"	*(char)
)	O
,	O
dstpath	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
src	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
dst	*(struct)
,	O
src	*(struct)
,	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"failed to copy %s to %s: %s"	*(char)
)	O
,	O
srcpath	*(char)
,	O
dstpath	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
else	O
{	O
mu_transport_t	*(void)
trans	array(*(void))
[	O
2	int
]	O
;	O
rc	int
=	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
dst	*(struct)
,	O
MU_IOCTL_TRANSPORT	int
,	O
MU_IOCTL_OP_GET	int
,	O
trans	array(*(void))
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
fchmod	(int,int)->(int)
(	O
(	O
int	O
)	O
(	O
intptr_t	long
)	O
trans	array(*(void))
[	O
0	int
]	O
,	O
mode	int
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: cannot chmod: %s"	*(char)
)	O
,	O
dstpath	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
rc	int
=	O
MU_ERR_RESTORE_META	O
;	O
}	O
else	O
if	O
(	O
flags	int
&	O
MU_COPY_OWNER	int
)	O
{	O
uid_t	int
uid	int
;	O
gid_t	int
gid	int
;	O
if	O
(	O
getuid	()->(int)
(	O
)	O
==	O
0	int
)	O
{	O
uid	int
=	O
st	*(struct(long,long,long))
->	O
st_uid	int
;	O
gid	int
=	O
st	*(struct(long,long,long))
->	O
st_gid	int
;	O
}	O
else	O
if	O
(	O
getuid	()->(int)
(	O
)	O
==	O
st	*(struct(long,long,long))
->	O
st_uid	int
)	O
{	O
uid	int
=	O
-	O
1	int
;	O
gid	int
=	O
st	*(struct(long,long,long))
->	O
st_gid	int
;	O
}	O
else	O
{	O
uid	int
=	O
-	O
1	int
;	O
gid	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
gid	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
fchown	(int,int,int)->(int)
(	O
(	O
int	O
)	O
(	O
intptr_t	long
)	O
trans	array(*(void))
[	O
0	int
]	O
,	O
uid	int
,	O
gid	int
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: cannot chown to %lu.%lu: %s"	*(char)
)	O
,	O
dstpath	*(char)
,	O
(	O
unsigned	O
long	O
)	O
uid	int
,	O
(	O
unsigned	O
long	O
)	O
gid	int
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
rc	int
=	O
MU_ERR_RESTORE_META	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"can't change file mode and ownership after copying %s to %s;"	*(char)
" cannot get file handle: %s"	*(char)
)	O
,	O
srcpath	*(char)
,	O
dstpath	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
}	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
src	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
dst	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
copy_symlink	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
srcpath	*(char)
,	O
const	O
char	O
*	O
dstpath	*(char)
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
buf	*(void)
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
;	O
rc	int
=	O
mu_readlink	(*(char),*(*(char)),*(long),*(long))->(int)
(	O
srcpath	*(char)
,	O
&	O
buf	*(void)
,	O
&	O
size	long
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: cannot read link: %s"	*(char)
)	O
,	O
srcpath	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
symlink	(*(char),*(char))->(int)
(	O
buf	*(void)
,	O
dstpath	*(char)
)	O
)	O
{	O
rc	int
=	O
errno	O
;	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: can't link %s to %s: %s"	*(char)
)	O
,	O
srcpath	*(char)
,	O
buf	*(void)
,	O
dstpath	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
copy_dir	(*(char),*(char),int)->(int)
(	O
const	O
char	O
*	O
srcpath	*(char)
,	O
const	O
char	O
*	O
dstpath	*(char)
,	O
int	O
flags	int
)	O
{	O
DIR	struct
*	O
dirp	*(struct)
;	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dp	*(struct(long,long,short,char,array(char)))
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long))
;	O
int	O
rc	int
;	O
mode_t	int
mode	int
,	O
mask	int
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
srcpath	*(char)
,	O
&	O
st	*(struct(long,long,long))
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"can't stat file %s: %s"	*(char)
)	O
,	O
srcpath	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
errno	O
;	O
}	O
mask	int
=	O
umask	(int)->(int)
(	O
077	int
)	O
;	O
mode	int
=	O
(	O
(	O
flags	int
&	O
MU_COPY_MODE	int
)	O
?	O
st	*(struct(long,long,long))
.	O
st_mode	int
:	O
(	O
0777	int
&	O
~	O
mask	int
)	O
)	O
&	O
0777	int
;	O
rc	int
=	O
mkdir	(*(char),int)->(int)
(	O
dstpath	*(char)
,	O
0700	int
)	O
;	O
umask	(int)->(int)
(	O
mask	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"can't create directory %s: %s"	*(char)
)	O
,	O
dstpath	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
errno	O
;	O
}	O
dirp	*(struct)
=	O
opendir	(*(char))->(*(struct))
(	O
srcpath	*(char)
)	O
;	O
if	O
(	O
dirp	*(struct)
==	O
NULL	O
)	O
{	O
rc	int
=	O
errno	O
;	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"cannot open directory %s: %s"	*(char)
,	O
srcpath	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
while	O
(	O
(	O
dp	*(struct(long,long,short,char,array(char)))
=	O
readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
dirp	*(struct)
)	O
)	O
)	O
{	O
char	O
const	O
*	O
ename	*(char)
=	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
;	O
char	O
*	O
src	*(struct)
,	O
*	O
dst	*(struct)
;	O
if	O
(	O
ename	*(char)
[	O
ename	*(char)
[	O
0	int
]	O
!=	O
'.'	O
?	O
0	int
:	O
ename	*(char)
[	O
1	int
]	O
!=	O
'.'	O
?	O
1	int
:	O
2	int
]	O
==	O
0	int
)	O
continue	O
;	O
src	*(struct)
=	O
mu_make_file_name	O
(	O
srcpath	*(char)
,	O
ename	*(char)
)	O
;	O
dst	*(struct)
=	O
mu_make_file_name	O
(	O
dstpath	*(char)
,	O
ename	*(char)
)	O
;	O
rc	int
=	O
mu_copy_file	(*(char),*(char),int)->(int)
(	O
src	*(struct)
,	O
dst	*(struct)
,	O
flags	int
)	O
;	O
free	(*(void))->(void)
(	O
dst	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
src	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
}	O
closedir	(*(struct))->(int)
(	O
dirp	*(struct)
)	O
;	O
if	O
(	O
chmod	(*(char),int)->(int)
(	O
dstpath	*(char)
,	O
mode	int
)	O
)	O
{	O
rc	int
=	O
errno	O
;	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: cannot chmod: %s"	*(char)
)	O
,	O
dstpath	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
flags	int
&	O
MU_COPY_OWNER	int
)	O
{	O
uid_t	int
uid	int
;	O
gid_t	int
gid	int
;	O
if	O
(	O
getuid	()->(int)
(	O
)	O
==	O
0	int
)	O
{	O
uid	int
=	O
st	*(struct(long,long,long))
.	O
st_uid	int
;	O
gid	int
=	O
st	*(struct(long,long,long))
.	O
st_gid	int
;	O
}	O
else	O
if	O
(	O
getuid	()->(int)
(	O
)	O
==	O
st	*(struct(long,long,long))
.	O
st_uid	int
)	O
{	O
uid	int
=	O
-	O
1	int
;	O
gid	int
=	O
st	*(struct(long,long,long))
.	O
st_gid	int
;	O
}	O
else	O
{	O
uid	int
=	O
-	O
1	int
;	O
gid	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
gid	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
chown	(*(char),int,int)->(int)
(	O
dstpath	*(char)
,	O
uid	int
,	O
gid	int
)	O
)	O
{	O
rc	int
=	O
errno	O
;	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: cannot chown to %lu.%lu: %s"	*(char)
)	O
,	O
dstpath	*(char)
,	O
(	O
unsigned	O
long	O
)	O
uid	int
,	O
(	O
unsigned	O
long	O
)	O
gid	int
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
}	O
}	O
return	O
rc	int
;	O
}	O
