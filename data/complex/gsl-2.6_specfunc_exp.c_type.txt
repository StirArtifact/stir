static	O
int	O
exprel_n_CF	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
N	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
RECUR_BIG	double
=	O
GSL_SQRT_DBL_MAX	int
;	O
const	O
int	O
maxiter	int
=	O
5000	int
;	O
int	O
n	int
=	O
1	int
;	O
double	O
Anm2	double
=	O
1.0	int
;	O
double	O
Bnm2	double
=	O
0.0	int
;	O
double	O
Anm1	double
=	O
0.0	int
;	O
double	O
Bnm1	double
=	O
1.0	int
;	O
double	O
a1	double
=	O
1.0	int
;	O
double	O
b1	double
=	O
1.0	int
;	O
double	O
a2	double
=	O
-	O
x	double
;	O
double	O
b2	double
=	O
N	double
+	O
1	int
;	O
double	O
an	double
,	O
bn	double
;	O
double	O
fn	double
;	O
double	O
An	double
=	O
b1	double
*	O
Anm1	double
+	O
a1	double
*	O
Anm2	double
;	O
double	O
Bn	double
=	O
b1	double
*	O
Bnm1	double
+	O
a1	double
*	O
Bnm2	double
;	O
n	int
++	O
;	O
Anm2	double
=	O
Anm1	double
;	O
Bnm2	double
=	O
Bnm1	double
;	O
Anm1	double
=	O
An	double
;	O
Bnm1	double
=	O
Bn	double
;	O
An	double
=	O
b2	double
*	O
Anm1	double
+	O
a2	double
*	O
Anm2	double
;	O
Bn	double
=	O
b2	double
*	O
Bnm1	double
+	O
a2	double
*	O
Bnm2	double
;	O
fn	double
=	O
An	double
/	O
Bn	double
;	O
while	O
(	O
n	int
<	O
maxiter	int
)	O
{	O
double	O
old_fn	double
;	O
double	O
del	double
;	O
n	int
++	O
;	O
Anm2	double
=	O
Anm1	double
;	O
Bnm2	double
=	O
Bnm1	double
;	O
Anm1	double
=	O
An	double
;	O
Bnm1	double
=	O
Bn	double
;	O
an	double
=	O
(	O
GSL_IS_ODD	O
(	O
n	int
)	O
?	O
(	O
(	O
n	int
-	O
1	int
)	O
/	O
2	int
)	O
*	O
x	double
:	O
-	O
(	O
N	double
+	O
(	O
n	int
/	O
2	int
)	O
-	O
1	int
)	O
*	O
x	double
)	O
;	O
bn	double
=	O
N	double
+	O
n	int
-	O
1	int
;	O
An	double
=	O
bn	double
*	O
Anm1	double
+	O
an	double
*	O
Anm2	double
;	O
Bn	double
=	O
bn	double
*	O
Bnm1	double
+	O
an	double
*	O
Bnm2	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
An	double
)	O
>	O
RECUR_BIG	double
||	O
fabs	(double)->(double)
(	O
Bn	double
)	O
>	O
RECUR_BIG	double
)	O
{	O
An	double
/=	O
RECUR_BIG	double
;	O
Bn	double
/=	O
RECUR_BIG	double
;	O
Anm1	double
/=	O
RECUR_BIG	double
;	O
Bnm1	double
/=	O
RECUR_BIG	double
;	O
Anm2	double
/=	O
RECUR_BIG	double
;	O
Bnm2	double
/=	O
RECUR_BIG	double
;	O
}	O
old_fn	double
=	O
fn	double
;	O
fn	double
=	O
An	double
/	O
Bn	double
;	O
del	double
=	O
old_fn	double
/	O
fn	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
del	double
-	O
1.0	int
)	O
<	O
2.0	int
*	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
fn	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
4.0	int
*	O
(	O
n	int
+	O
1.0	int
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
fn	double
)	O
;	O
if	O
(	O
n	int
==	O
maxiter	int
)	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_exp_e	(double,*(struct(double,double)))->(int)
(	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
x	double
>	O
GSL_LOG_DBL_MAX	int
)	O
{	O
OVERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
GSL_LOG_DBL_MIN	O
)	O
{	O
UNDERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
exp	(double)->(double)
(	O
x	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_exp_e10_e	(double,*(struct(double,double,int)))->(int)
(	O
const	O
double	O
x	double
,	O
gsl_sf_result_e10	struct(double,double,int)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
x	double
>	O
INT_MAX	O
-	O
1	int
)	O
{	O
OVERFLOW_ERROR_E10	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
INT_MIN	O
+	O
1	int
)	O
{	O
UNDERFLOW_ERROR_E10	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
const	O
int	O
N	double
=	O
(	O
x	double
>	O
GSL_LOG_DBL_MAX	int
||	O
x	double
<	O
GSL_LOG_DBL_MIN	O
)	O
?	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
x	double
/	O
M_LN10	int
)	O
:	O
0	int
;	O
result	*(struct(double,double))
->	O
val	double
=	O
exp	(double)->(double)
(	O
x	double
-	O
N	double
*	O
M_LN10	int
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
(	O
fabs	(double)->(double)
(	O
x	double
)	O
+	O
1.0	int
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
N	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_exp_mult_e	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
x	double
,	O
const	O
double	O
y	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
ay	double
=	O
fabs	(double)->(double)
(	O
y	double
)	O
;	O
if	O
(	O
y	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
(	O
x	double
<	O
0.5	int
*	O
GSL_LOG_DBL_MAX	int
&&	O
x	double
>	O
0.5	int
*	O
GSL_LOG_DBL_MIN	O
)	O
&&	O
(	O
ay	double
<	O
0.8	int
*	O
GSL_SQRT_DBL_MAX	int
&&	O
ay	double
>	O
1.2	int
*	O
GSL_SQRT_DBL_MIN	int
)	O
)	O
{	O
const	O
double	O
ex	double
=	O
exp	(double)->(double)
(	O
x	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
y	double
*	O
ex	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
(	O
2.0	int
+	O
fabs	(double)->(double)
(	O
x	double
)	O
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
ly	double
=	O
log	(double)->(double)
(	O
ay	double
)	O
;	O
const	O
double	O
lnr	*(struct(double,double))
=	O
x	double
+	O
ly	double
;	O
if	O
(	O
lnr	*(struct(double,double))
>	O
GSL_LOG_DBL_MAX	int
-	O
0.01	int
)	O
{	O
OVERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
lnr	*(struct(double,double))
<	O
GSL_LOG_DBL_MIN	O
+	O
0.01	int
)	O
{	O
UNDERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
const	O
double	O
sy	double
=	O
GSL_SIGN	O
(	O
y	double
)	O
;	O
const	O
double	O
M	double
=	O
floor	(double)->(double)
(	O
x	double
)	O
;	O
const	O
double	O
N	double
=	O
floor	(double)->(double)
(	O
ly	double
)	O
;	O
const	O
double	O
a	double
=	O
x	double
-	O
M	double
;	O
const	O
double	O
b	double
=	O
ly	double
-	O
N	double
;	O
const	O
double	O
berr	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
ly	double
)	O
+	O
fabs	(double)->(double)
(	O
N	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
sy	double
*	O
exp	(double)->(double)
(	O
M	double
+	O
N	double
)	O
*	O
exp	(double)->(double)
(	O
a	double
+	O
b	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
berr	double
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
M	double
+	O
N	double
+	O
1.0	int
)	O
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
}	O
int	O
gsl_sf_exp_mult_e10_e	(double,double,*(struct(double,double,int)))->(int)
(	O
const	O
double	O
x	double
,	O
const	O
double	O
y	double
,	O
gsl_sf_result_e10	struct(double,double,int)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
ay	double
=	O
fabs	(double)->(double)
(	O
y	double
)	O
;	O
if	O
(	O
y	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
(	O
x	double
<	O
0.5	int
*	O
GSL_LOG_DBL_MAX	int
&&	O
x	double
>	O
0.5	int
*	O
GSL_LOG_DBL_MIN	O
)	O
&&	O
(	O
ay	double
<	O
0.8	int
*	O
GSL_SQRT_DBL_MAX	int
&&	O
ay	double
>	O
1.2	int
*	O
GSL_SQRT_DBL_MIN	int
)	O
)	O
{	O
const	O
double	O
ex	double
=	O
exp	(double)->(double)
(	O
x	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
y	double
*	O
ex	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
(	O
2.0	int
+	O
fabs	(double)->(double)
(	O
x	double
)	O
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
ly	double
=	O
log	(double)->(double)
(	O
ay	double
)	O
;	O
const	O
double	O
l10_val	double
=	O
(	O
x	double
+	O
ly	double
)	O
/	O
M_LN10	int
;	O
if	O
(	O
l10_val	double
>	O
INT_MAX	O
-	O
1	int
)	O
{	O
OVERFLOW_ERROR_E10	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
l10_val	double
<	O
INT_MIN	O
+	O
1	int
)	O
{	O
UNDERFLOW_ERROR_E10	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
const	O
double	O
sy	double
=	O
GSL_SIGN	O
(	O
y	double
)	O
;	O
const	O
int	O
N	double
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
l10_val	double
)	O
;	O
const	O
double	O
arg_val	double
=	O
(	O
l10_val	double
-	O
N	double
)	O
*	O
M_LN10	int
;	O
const	O
double	O
arg_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
x	double
)	O
+	O
fabs	(double)->(double)
(	O
ly	double
)	O
+	O
M_LN10	int
*	O
fabs	(double)->(double)
(	O
N	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
sy	double
*	O
exp	(double)->(double)
(	O
arg_val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
arg_err	double
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
N	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
}	O
int	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
x	double
,	O
const	O
double	O
dx	double
,	O
const	O
double	O
y	double
,	O
const	O
double	O
dy	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
ay	double
=	O
fabs	(double)->(double)
(	O
y	double
)	O
;	O
if	O
(	O
y	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
fabs	(double)->(double)
(	O
dy	double
*	O
exp	(double)->(double)
(	O
x	double
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
(	O
x	double
<	O
0.5	int
*	O
GSL_LOG_DBL_MAX	int
&&	O
x	double
>	O
0.5	int
*	O
GSL_LOG_DBL_MIN	O
)	O
&&	O
(	O
ay	double
<	O
0.8	int
*	O
GSL_SQRT_DBL_MAX	int
&&	O
ay	double
>	O
1.2	int
*	O
GSL_SQRT_DBL_MIN	int
)	O
)	O
{	O
double	O
ex	double
=	O
exp	(double)->(double)
(	O
x	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
y	double
*	O
ex	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
ex	double
*	O
(	O
fabs	(double)->(double)
(	O
dy	double
)	O
+	O
fabs	(double)->(double)
(	O
y	double
*	O
dx	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
ly	double
=	O
log	(double)->(double)
(	O
ay	double
)	O
;	O
const	O
double	O
lnr	*(struct(double,double))
=	O
x	double
+	O
ly	double
;	O
if	O
(	O
lnr	*(struct(double,double))
>	O
GSL_LOG_DBL_MAX	int
-	O
0.01	int
)	O
{	O
OVERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
lnr	*(struct(double,double))
<	O
GSL_LOG_DBL_MIN	O
+	O
0.01	int
)	O
{	O
UNDERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
const	O
double	O
sy	double
=	O
GSL_SIGN	O
(	O
y	double
)	O
;	O
const	O
double	O
M	double
=	O
floor	(double)->(double)
(	O
x	double
)	O
;	O
const	O
double	O
N	double
=	O
floor	(double)->(double)
(	O
ly	double
)	O
;	O
const	O
double	O
a	double
=	O
x	double
-	O
M	double
;	O
const	O
double	O
b	double
=	O
ly	double
-	O
N	double
;	O
const	O
double	O
eMN	double
=	O
exp	(double)->(double)
(	O
M	double
+	O
N	double
)	O
;	O
const	O
double	O
eab	double
=	O
exp	(double)->(double)
(	O
a	double
+	O
b	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
sy	double
*	O
eMN	double
*	O
eab	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
eMN	double
*	O
eab	double
*	O
2.0	int
*	O
GSL_DBL_EPSILON	int
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
eMN	double
*	O
eab	double
*	O
fabs	(double)->(double)
(	O
dy	double
/	O
y	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
eMN	double
*	O
eab	double
*	O
fabs	(double)->(double)
(	O
dx	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
}	O
int	O
gsl_sf_exp_mult_err_e10_e	(double,double,double,double,*(struct(double,double,int)))->(int)
(	O
const	O
double	O
x	double
,	O
const	O
double	O
dx	double
,	O
const	O
double	O
y	double
,	O
const	O
double	O
dy	double
,	O
gsl_sf_result_e10	struct(double,double,int)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
ay	double
=	O
fabs	(double)->(double)
(	O
y	double
)	O
;	O
if	O
(	O
y	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
fabs	(double)->(double)
(	O
dy	double
*	O
exp	(double)->(double)
(	O
x	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
(	O
x	double
<	O
0.5	int
*	O
GSL_LOG_DBL_MAX	int
&&	O
x	double
>	O
0.5	int
*	O
GSL_LOG_DBL_MIN	O
)	O
&&	O
(	O
ay	double
<	O
0.8	int
*	O
GSL_SQRT_DBL_MAX	int
&&	O
ay	double
>	O
1.2	int
*	O
GSL_SQRT_DBL_MIN	int
)	O
)	O
{	O
const	O
double	O
ex	double
=	O
exp	(double)->(double)
(	O
x	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
y	double
*	O
ex	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
ex	double
*	O
(	O
fabs	(double)->(double)
(	O
dy	double
)	O
+	O
fabs	(double)->(double)
(	O
y	double
*	O
dx	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
ly	double
=	O
log	(double)->(double)
(	O
ay	double
)	O
;	O
const	O
double	O
l10_val	double
=	O
(	O
x	double
+	O
ly	double
)	O
/	O
M_LN10	int
;	O
if	O
(	O
l10_val	double
>	O
INT_MAX	O
-	O
1	int
)	O
{	O
OVERFLOW_ERROR_E10	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
l10_val	double
<	O
INT_MIN	O
+	O
1	int
)	O
{	O
UNDERFLOW_ERROR_E10	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
const	O
double	O
sy	double
=	O
GSL_SIGN	O
(	O
y	double
)	O
;	O
const	O
int	O
N	double
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
l10_val	double
)	O
;	O
const	O
double	O
arg_val	double
=	O
(	O
l10_val	double
-	O
N	double
)	O
*	O
M_LN10	int
;	O
const	O
double	O
arg_err	double
=	O
dy	double
/	O
fabs	(double)->(double)
(	O
y	double
)	O
+	O
dx	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
arg_val	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
sy	double
*	O
exp	(double)->(double)
(	O
arg_val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
arg_err	double
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
N	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
}	O
int	O
gsl_sf_expm1_e	(double,*(struct(double,double)))->(int)
(	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
cut	double
=	O
0.002	int
;	O
if	O
(	O
x	double
<	O
GSL_LOG_DBL_MIN	O
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
-	O
cut	double
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
exp	(double)->(double)
(	O
x	double
)	O
-	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
cut	double
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
x	double
*	O
(	O
1.0	int
+	O
0.5	int
*	O
x	double
*	O
(	O
1.0	int
+	O
x	double
/	O
3.0	int
*	O
(	O
1.0	int
+	O
0.25	int
*	O
x	double
*	O
(	O
1.0	int
+	O
0.2	int
*	O
x	double
)	O
)	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
GSL_LOG_DBL_MAX	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
exp	(double)->(double)
(	O
x	double
)	O
-	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
OVERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
int	O
gsl_sf_exprel_e	(double,*(struct(double,double)))->(int)
(	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
cut	double
=	O
0.002	int
;	O
if	O
(	O
x	double
<	O
GSL_LOG_DBL_MIN	O
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
1.0	int
/	O
x	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
-	O
cut	double
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
(	O
exp	(double)->(double)
(	O
x	double
)	O
-	O
1.0	int
)	O
/	O
x	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
cut	double
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
(	O
1.0	int
+	O
0.5	int
*	O
x	double
*	O
(	O
1.0	int
+	O
x	double
/	O
3.0	int
*	O
(	O
1.0	int
+	O
0.25	int
*	O
x	double
*	O
(	O
1.0	int
+	O
0.2	int
*	O
x	double
)	O
)	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
GSL_LOG_DBL_MAX	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
(	O
exp	(double)->(double)
(	O
x	double
)	O
-	O
1.0	int
)	O
/	O
x	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
OVERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
int	O
gsl_sf_exprel_2_e	(double,*(struct(double,double)))->(int)
(	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
cut	double
=	O
0.002	int
;	O
if	O
(	O
x	double
<	O
GSL_LOG_DBL_MIN	O
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
2.0	int
/	O
x	double
*	O
(	O
1.0	int
+	O
1.0	int
/	O
x	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
-	O
cut	double
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
2.0	int
*	O
(	O
exp	(double)->(double)
(	O
x	double
)	O
-	O
1.0	int
-	O
x	double
)	O
/	O
(	O
x	double
*	O
x	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
cut	double
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
(	O
1.0	int
+	O
1.0	int
/	O
3.0	int
*	O
x	double
*	O
(	O
1.0	int
+	O
0.25	int
*	O
x	double
*	O
(	O
1.0	int
+	O
0.2	int
*	O
x	double
*	O
(	O
1.0	int
+	O
1.0	int
/	O
6.0	int
*	O
x	double
)	O
)	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
GSL_LOG_DBL_MAX	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
2.0	int
*	O
(	O
exp	(double)->(double)
(	O
x	double
)	O
-	O
1.0	int
-	O
x	double
)	O
/	O
(	O
x	double
*	O
x	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
OVERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
int	O
gsl_sf_exprel_n_CF_e	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
N	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
return	O
exprel_n_CF	(double,double,*(struct(double,double)))->(int)
(	O
N	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
int	O
gsl_sf_exprel_n_e	(int,double,*(struct(double,double)))->(int)
(	O
const	O
int	O
N	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
N	double
<	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
x	double
)	O
<	O
GSL_ROOT3_DBL_EPSILON	int
*	O
N	double
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
+	O
x	double
/	O
(	O
N	double
+	O
1	int
)	O
*	O
(	O
1.0	int
+	O
x	double
/	O
(	O
N	double
+	O
2	int
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
N	double
==	O
0	int
)	O
{	O
return	O
gsl_sf_exp_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
N	double
==	O
1	int
)	O
{	O
return	O
gsl_sf_exprel_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
N	double
==	O
2	int
)	O
{	O
return	O
gsl_sf_exprel_2_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
x	double
>	O
N	double
&&	O
(	O
-	O
x	double
+	O
N	double
*	O
(	O
1.0	int
+	O
log	(double)->(double)
(	O
x	double
/	O
N	double
)	O
)	O
<	O
GSL_LOG_DBL_EPSILON	O
)	O
)	O
{	O
gsl_sf_result	struct(double,double)
lnf_N	struct(double,double)
;	O
double	O
lnr_val	double
;	O
double	O
lnr_err	double
;	O
double	O
lnterm	double
;	O
gsl_sf_lnfact_e	(int,*(struct(double,double)))->(int)
(	O
N	double
,	O
&	O
lnf_N	struct(double,double)
)	O
;	O
lnterm	double
=	O
N	double
*	O
log	(double)->(double)
(	O
x	double
)	O
;	O
lnr_val	double
=	O
x	double
+	O
lnf_N	struct(double,double)
.	O
val	double
-	O
lnterm	double
;	O
lnr_err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
x	double
)	O
+	O
fabs	(double)->(double)
(	O
lnf_N	struct(double,double)
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
lnterm	double
)	O
)	O
;	O
lnr_err	double
+=	O
lnf_N	struct(double,double)
.	O
err	double
;	O
return	O
gsl_sf_exp_err_e	(double,double,*(struct(double,double)))->(int)
(	O
lnr_val	double
,	O
lnr_err	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
>	O
N	double
)	O
{	O
double	O
ln_x	double
=	O
log	(double)->(double)
(	O
x	double
)	O
;	O
gsl_sf_result	struct(double,double)
lnf_N	struct(double,double)
;	O
double	O
lg_N	double
;	O
double	O
lnpre_val	double
;	O
double	O
lnpre_err	double
;	O
gsl_sf_lnfact_e	(int,*(struct(double,double)))->(int)
(	O
N	double
,	O
&	O
lnf_N	struct(double,double)
)	O
;	O
lg_N	double
=	O
lnf_N	struct(double,double)
.	O
val	double
-	O
log	(double)->(double)
(	O
N	double
)	O
;	O
lnpre_val	double
=	O
x	double
+	O
lnf_N	struct(double,double)
.	O
val	double
-	O
N	double
*	O
ln_x	double
;	O
lnpre_err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
x	double
)	O
+	O
fabs	(double)->(double)
(	O
lnf_N	struct(double,double)
.	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
N	double
*	O
ln_x	double
)	O
)	O
;	O
lnpre_err	double
+=	O
lnf_N	struct(double,double)
.	O
err	double
;	O
if	O
(	O
lnpre_val	double
<	O
GSL_LOG_DBL_MAX	int
-	O
5.0	int
)	O
{	O
int	O
stat_eG	int
;	O
gsl_sf_result	struct(double,double)
bigG_ratio	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
pre	struct(double,double)
;	O
int	O
stat_ex	int
=	O
gsl_sf_exp_err_e	(double,double,*(struct(double,double)))->(int)
(	O
lnpre_val	double
,	O
lnpre_err	double
,	O
&	O
pre	struct(double,double)
)	O
;	O
double	O
ln_bigG_ratio_pre	double
=	O
-	O
x	double
+	O
(	O
N	double
-	O
1	int
)	O
*	O
ln_x	double
-	O
lg_N	double
;	O
double	O
bigGsum	double
=	O
1.0	int
;	O
double	O
term	double
=	O
1.0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
N	double
;	O
k	int
++	O
)	O
{	O
term	double
*=	O
(	O
N	double
-	O
k	int
)	O
/	O
x	double
;	O
bigGsum	double
+=	O
term	double
;	O
}	O
stat_eG	int
=	O
gsl_sf_exp_mult_e	(double,double,*(struct(double,double)))->(int)
(	O
ln_bigG_ratio_pre	double
,	O
bigGsum	double
,	O
&	O
bigG_ratio	struct(double,double)
)	O
;	O
if	O
(	O
stat_eG	int
==	O
GSL_SUCCESS	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
pre	struct(double,double)
.	O
val	double
*	O
(	O
1.0	int
-	O
bigG_ratio	struct(double,double)
.	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
pre	struct(double,double)
.	O
val	double
*	O
(	O
2.0	int
*	O
GSL_DBL_EPSILON	int
+	O
bigG_ratio	struct(double,double)
.	O
err	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
pre	struct(double,double)
.	O
err	double
*	O
fabs	(double)->(double)
(	O
1.0	int
-	O
bigG_ratio	struct(double,double)
.	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
stat_ex	int
;	O
}	O
else	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
stat_eG	int
;	O
}	O
}	O
else	O
{	O
OVERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
x	double
>	O
-	O
10.0	int
*	O
N	double
)	O
{	O
return	O
exprel_n_CF	(double,double,*(struct(double,double)))->(int)
(	O
N	double
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
double	O
sum	double
=	O
1.0	int
;	O
double	O
term	double
=	O
1.0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
N	double
;	O
k	int
++	O
)	O
{	O
term	double
*=	O
(	O
N	double
-	O
k	int
)	O
/	O
x	double
;	O
sum	double
+=	O
term	double
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
N	double
/	O
x	double
*	O
sum	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
}	O
int	O
gsl_sf_exp_err_e	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
x	double
,	O
const	O
double	O
dx	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
adx	double
=	O
fabs	(double)->(double)
(	O
dx	double
)	O
;	O
if	O
(	O
x	double
+	O
adx	double
>	O
GSL_LOG_DBL_MAX	int
)	O
{	O
OVERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
-	O
adx	double
<	O
GSL_LOG_DBL_MIN	O
)	O
{	O
UNDERFLOW_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
const	O
double	O
ex	double
=	O
exp	(double)->(double)
(	O
x	double
)	O
;	O
const	O
double	O
edx	double
=	O
exp	(double)->(double)
(	O
adx	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
ex	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
ex	double
*	O
GSL_MAX_DBL	(double,double)->(double)
(	O
GSL_DBL_EPSILON	int
,	O
edx	double
-	O
1.0	int
/	O
edx	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_exp_err_e10_e	(double,double,*(struct(double,double,int)))->(int)
(	O
const	O
double	O
x	double
,	O
const	O
double	O
dx	double
,	O
gsl_sf_result_e10	struct(double,double,int)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
adx	double
=	O
fabs	(double)->(double)
(	O
dx	double
)	O
;	O
if	O
(	O
x	double
+	O
adx	double
>	O
INT_MAX	O
-	O
1	int
)	O
{	O
OVERFLOW_ERROR_E10	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
-	O
adx	double
<	O
INT_MIN	O
+	O
1	int
)	O
{	O
UNDERFLOW_ERROR_E10	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
const	O
int	O
N	double
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
x	double
/	O
M_LN10	int
)	O
;	O
const	O
double	O
ex	double
=	O
exp	(double)->(double)
(	O
x	double
-	O
N	double
*	O
M_LN10	int
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
ex	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
ex	double
*	O
(	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
x	double
)	O
+	O
1.0	int
)	O
+	O
adx	double
)	O
;	O
result	*(struct(double,double))
->	O
e10	int
=	O
N	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
double	O
gsl_sf_exp	(double)->(double)
(	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_exp_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_exp_mult	(double,double)->(double)
(	O
const	O
double	O
x	double
,	O
const	O
double	O
y	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_exp_mult_e	(double,double,*(struct(double,double)))->(int)
(	O
x	double
,	O
y	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_expm1	(double)->(double)
(	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_expm1_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_exprel	(double)->(double)
(	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_exprel_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_exprel_2	(double)->(double)
(	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_exprel_2_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_exprel_n	(int,double)->(double)
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_exprel_n_e	(int,double,*(struct(double,double)))->(int)
(	O
n	int
,	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
