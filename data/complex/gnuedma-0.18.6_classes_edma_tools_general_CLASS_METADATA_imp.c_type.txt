typedef	O
struct	O
t_md_property	struct(array(char),array(char),array(char),int)
{	O
EChar	char
p_name	array(char)
[	O
50	int
]	O
;	O
EChar	char
p_type	array(char)
[	O
20	int
]	O
;	O
EChar	char
p_access	array(char)
[	O
20	int
]	O
;	O
ESint32	int
p_n_elems	int
;	O
}	O
MD_PROPERTY	struct(array(char),array(char),array(char),int)
;	O
typedef	O
struct	O
t_md_method	struct(array(char),array(char),long,long,long)
{	O
EChar	char
m_name	array(char)
[	O
50	int
]	O
;	O
EChar	char
m_sig	array(char)
[	O
50	int
]	O
;	O
EUint32	long
m_virtual	long
;	O
EUint32	long
m_abstract	long
;	O
EUint32	long
m_static	long
;	O
}	O
MD_METHOD	struct(array(char),array(char),long,long,long)
;	O
typedef	O
struct	O
t_md_sc	struct(array(char))
{	O
EChar	char
sc_name	array(char)
[	O
50	int
]	O
;	O
}	O
MD_SC	struct(array(char))
;	O
typedef	O
struct	O
{	O
EPChar	*(char)
FileName	*(char)
;	O
EUint32	long
h	long
;	O
EDMAT_BUFFER	struct(long,long,*(void))
Prop	struct(long,long,*(void))
;	O
EDMAT_BUFFER	struct(long,long,*(void))
Met	struct(long,long,*(void))
;	O
EDMAT_BUFFER	struct(long,long,*(void))
SCList	struct(long,long,*(void))
;	O
ESint32	int
nProp	int
;	O
ESint32	int
nMet	int
;	O
ESint32	int
nSC	int
;	O
EPChar	*(char)
ClassName	*(char)
;	O
EPChar	*(char)
ModuleName	*(char)
;	O
EUint32	long
maxProp	long
;	O
EUint32	long
maxMet	long
;	O
EUint32	long
maxSC	long
;	O
EPChar	*(char)
Machine	*(char)
;	O
EPChar	*(char)
OperatingSystem	*(char)
;	O
EPChar	*(char)
SIUProxy	*(char)
;	O
EPChar	*(char)
IDFParser	*(char)
;	O
EUint32	long
IsIDFParser	char
;	O
EUint32	long
IsSIUProxy	char
;	O
EUint32	long
IsEMI	long
;	O
EPChar	*(char)
Language	*(char)
;	O
EPChar	*(char)
NameSpace	*(char)
;	O
ESint32	int
MajorVersion	int
;	O
ESint32	int
MinorVersion	int
;	O
}	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
;	O
ESint32	int
EDMAPROC	O
CLASS_METADATASetNPropU32	(int,int)->(int)
(	O
OBJID	int
IdObj	int
,	O
ESint32	int
n	int
)	O
{	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
=	O
(	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nProp	int
=	O
0	int
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
maxProp	long
=	O
n	int
;	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
Prop	struct(long,long,*(void))
,	O
n	int
*	O
sizeof	O
(	O
MD_PROPERTY	struct(array(char),array(char),array(char),int)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
CLASS_METADATASetNMetU32	(int,long)->(int)
(	O
OBJID	int
IdObj	int
,	O
EUint32	long
n	int
)	O
{	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
=	O
(	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nMet	int
=	O
0	int
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
maxMet	long
=	O
n	int
;	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
Met	struct(long,long,*(void))
,	O
n	int
*	O
sizeof	O
(	O
MD_METHOD	struct(array(char),array(char),long,long,long)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
CLASS_METADATASetNSCU32	(int,int)->(int)
(	O
OBJID	int
IdObj	int
,	O
ESint32	int
n	int
)	O
{	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
=	O
(	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nSC	int
=	O
0	int
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
maxSC	long
=	O
n	int
;	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
SCList	struct(long,long,*(void))
,	O
n	int
*	O
sizeof	O
(	O
MD_SC	struct(array(char))
)	O
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
CLASS_METADATAAddPropZZZU32	(int,*(char),*(char),*(char),long)->(int)
(	O
OBJID	int
IdObj	int
,	O
EPChar	*(char)
name	*(char)
,	O
EPChar	*(char)
type	long
,	O
EPChar	*(char)
access	int
,	O
EUint32	long
n	int
)	O
{	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
;	O
MD_PROPERTY	struct(array(char),array(char),array(char),int)
*	O
aux	*(struct(array(char),array(char),array(char),int))
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
=	O
(	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
if	O
(	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nProp	int
>=	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
maxProp	long
)	O
return	O
-	O
1	int
;	O
aux	*(struct(array(char),array(char),array(char),int))
=	O
(	O
MD_PROPERTY	struct(array(char),array(char),array(char),int)
*	O
)	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
Prop	struct(long,long,*(void))
.	O
dat	*(void)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nProp	int
]	O
.	O
p_name	array(char)
,	O
name	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nProp	int
]	O
.	O
p_type	array(char)
,	O
type	long
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nProp	int
]	O
.	O
p_access	array(char)
,	O
access	int
)	O
;	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nProp	int
]	O
.	O
p_n_elems	int
=	O
n	int
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nProp	int
++	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
CLASS_METADATAAddMetZZU32U32U32	(int,*(char),*(char),long,long,long)->(int)
(	O
OBJID	int
IdObj	int
,	O
EPChar	*(char)
name	*(char)
,	O
EPChar	*(char)
sig	*(char)
,	O
EUint32	long
virtual	long
,	O
EUint32	long
m_abstract	long
,	O
EUint32	long
m_static	long
)	O
{	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
;	O
MD_METHOD	struct(array(char),array(char),long,long,long)
*	O
aux	*(struct(array(char),array(char),array(char),int))
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
=	O
(	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
if	O
(	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nMet	int
>=	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
maxMet	long
)	O
return	O
-	O
1	int
;	O
aux	*(struct(array(char),array(char),array(char),int))
=	O
(	O
MD_METHOD	struct(array(char),array(char),long,long,long)
*	O
)	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
Met	struct(long,long,*(void))
.	O
dat	*(void)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nMet	int
]	O
.	O
m_name	array(char)
,	O
name	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nMet	int
]	O
.	O
m_sig	array(char)
,	O
sig	*(char)
)	O
;	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nMet	int
]	O
.	O
m_virtual	long
=	O
virtual	long
;	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nMet	int
]	O
.	O
m_abstract	long
=	O
m_abstract	long
;	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nMet	int
]	O
.	O
m_static	long
=	O
m_static	long
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nMet	int
++	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
CLASS_METADATAAddSCZ	(int,*(char))->(int)
(	O
OBJID	int
IdObj	int
,	O
EPChar	*(char)
name	*(char)
)	O
{	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
;	O
MD_SC	struct(array(char))
*	O
aux	*(struct(array(char),array(char),array(char),int))
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
=	O
(	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
if	O
(	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nSC	int
>	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
maxSC	long
)	O
return	O
-	O
1	int
;	O
aux	*(struct(array(char),array(char),array(char),int))
=	O
(	O
MD_SC	struct(array(char))
*	O
)	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
SCList	struct(long,long,*(void))
.	O
dat	*(void)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nSC	int
]	O
.	O
sc_name	array(char)
,	O
name	*(char)
)	O
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nSC	int
++	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
CLASS_METADATAInitU32U32U32	(int)->(int)
(	O
OBJID	int
IdObj	int
)	O
{	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
=	O
(	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Not yet Implemented"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
CLASS_METADATArip	(int)->(int)
(	O
OBJID	int
IdObj	int
)	O
{	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
=	O
(	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
edma_buffer_free	(*(struct(long,long,*(void))))->(int)
(	O
&	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
Prop	struct(long,long,*(void))
)	O
;	O
edma_buffer_free	(*(struct(long,long,*(void))))->(int)
(	O
&	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
Met	struct(long,long,*(void))
)	O
;	O
edma_buffer_free	(*(struct(long,long,*(void))))->(int)
(	O
&	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
SCList	struct(long,long,*(void))
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
CLASS_METADATAClear	(int)->(int)
(	O
OBJID	int
IdObj	int
)	O
{	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
=	O
(	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
edma_buffer_free	(*(struct(long,long,*(void))))->(int)
(	O
&	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
Prop	struct(long,long,*(void))
)	O
;	O
edma_buffer_free	(*(struct(long,long,*(void))))->(int)
(	O
&	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
Met	struct(long,long,*(void))
)	O
;	O
edma_buffer_free	(*(struct(long,long,*(void))))->(int)
(	O
&	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
SCList	struct(long,long,*(void))
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
CLASS_METADATAGetSCU32sZ	(int,long,*(char))->(int)
(	O
OBJID	int
IdObj	int
,	O
EUint32	long
indx	long
,	O
EPChar	*(char)
name	*(char)
)	O
{	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
;	O
MD_SC	struct(array(char))
*	O
aux	*(struct(array(char),array(char),array(char),int))
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
=	O
(	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
if	O
(	O
indx	long
>	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
maxSC	long
)	O
return	O
-	O
1	int
;	O
aux	*(struct(array(char),array(char),array(char),int))
=	O
(	O
MD_SC	struct(array(char))
*	O
)	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
SCList	struct(long,long,*(void))
.	O
dat	*(void)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
name	*(char)
,	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
indx	long
]	O
.	O
sc_name	array(char)
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
CLASS_METADATAGetPropU32sZsZsZsU32	(int,long,*(char),*(char),*(char),*(long))->(int)
(	O
OBJID	int
IdObj	int
,	O
EUint32	long
indx	long
,	O
EPChar	*(char)
name	*(char)
,	O
EPChar	*(char)
type	long
,	O
EPChar	*(char)
access	int
,	O
EPUint32	*(long)
n	int
)	O
{	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
;	O
MD_PROPERTY	struct(array(char),array(char),array(char),int)
*	O
aux	*(struct(array(char),array(char),array(char),int))
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
=	O
(	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
if	O
(	O
indx	long
>	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
maxProp	long
)	O
return	O
-	O
1	int
;	O
aux	*(struct(array(char),array(char),array(char),int))
=	O
(	O
MD_PROPERTY	struct(array(char),array(char),array(char),int)
*	O
)	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
Prop	struct(long,long,*(void))
.	O
dat	*(void)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
name	*(char)
,	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
indx	long
]	O
.	O
p_name	array(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
type	long
,	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
indx	long
]	O
.	O
p_type	array(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
access	int
,	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
indx	long
]	O
.	O
p_access	array(char)
)	O
;	O
*	O
n	int
=	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
indx	long
]	O
.	O
p_n_elems	int
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
CLASS_METADATAGetMetU32sZsZsU32sU32sU32	(int,long,*(char),*(char),*(long),*(long),*(long))->(int)
(	O
OBJID	int
IdObj	int
,	O
EUint32	long
indx	long
,	O
EPChar	*(char)
name	*(char)
,	O
EPChar	*(char)
sig	*(char)
,	O
EPUint32	*(long)
virtual	long
,	O
EPUint32	*(long)
m_abstract	long
,	O
EPUint32	*(long)
m_static	long
)	O
{	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
;	O
MD_METHOD	struct(array(char),array(char),long,long,long)
*	O
aux	*(struct(array(char),array(char),array(char),int))
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
=	O
(	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
if	O
(	O
indx	long
>	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
maxMet	long
)	O
return	O
-	O
1	int
;	O
aux	*(struct(array(char),array(char),array(char),int))
=	O
(	O
MD_METHOD	struct(array(char),array(char),long,long,long)
*	O
)	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
Met	struct(long,long,*(void))
.	O
dat	*(void)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
name	*(char)
,	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
indx	long
]	O
.	O
m_name	array(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
sig	*(char)
,	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
indx	long
]	O
.	O
m_sig	array(char)
)	O
;	O
*	O
virtual	long
=	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
indx	long
]	O
.	O
m_virtual	long
;	O
*	O
m_abstract	long
=	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
indx	long
]	O
.	O
m_abstract	long
;	O
*	O
m_static	long
=	O
aux	*(struct(array(char),array(char),array(char),int))
[	O
indx	long
]	O
.	O
m_static	long
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
CLASS_METADATAShow	(int)->(int)
(	O
OBJID	int
IdObj	int
)	O
{	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
;	O
EUint32	long
i	int
;	O
MD_PROPERTY	struct(array(char),array(char),array(char),int)
*	O
aux_prop	*(struct(array(char),array(char),array(char),int))
;	O
MD_METHOD	struct(array(char),array(char),long,long,long)
*	O
aux_met	*(struct(array(char),array(char),long,long,long))
;	O
MD_SC	struct(array(char))
*	O
aux_sc	*(struct(array(char)))
;	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
=	O
(	O
DtCLASS_METADATA	struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">>METADATA report for class %s"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
ClassName	*(char)
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">> Module Name      : %s"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
ModuleName	*(char)
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">> Name space       : %s"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
NameSpace	*(char)
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">> Version          : %d.%d"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
MajorVersion	int
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
MinorVersion	int
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">> Name space       : %s"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
NameSpace	*(char)
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">> Machine          : %s"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
Machine	*(char)
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">> Operating System : %s"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
OperatingSystem	*(char)
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">> Name space       : %s"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
NameSpace	*(char)
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">> SIU Proxy        : %s"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
SIUProxy	*(char)
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">> IDF Parser       : %s"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
IDFParser	*(char)
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">> Is IDF Parser    : %d"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
IsIDFParser	char
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">> Is SIU Proxy     : %d"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
IsSIUProxy	char
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">> Is EMI Component : %d"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
IsEMI	long
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">> %d SuperClasses"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nSC	int
)	O
;	O
aux_sc	*(struct(array(char)))
=	O
(	O
MD_SC	struct(array(char))
*	O
)	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
SCList	struct(long,long,*(void))
.	O
dat	*(void)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nSC	int
;	O
i	int
++	O
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">>  %02d -> %s "	*(char)
,	O
i	int
,	O
aux_sc	*(struct(array(char)))
[	O
i	int
]	O
.	O
sc_name	array(char)
)	O
;	O
}	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">> %d Properties"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nProp	int
)	O
;	O
aux_prop	*(struct(array(char),array(char),array(char),int))
=	O
(	O
MD_PROPERTY	struct(array(char),array(char),array(char),int)
*	O
)	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
Prop	struct(long,long,*(void))
.	O
dat	*(void)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nProp	int
;	O
i	int
++	O
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">>  %02d -> %s [%d] (%s:%s)"	*(char)
,	O
i	int
,	O
aux_prop	*(struct(array(char),array(char),array(char),int))
[	O
i	int
]	O
.	O
p_name	array(char)
,	O
aux_prop	*(struct(array(char),array(char),array(char),int))
[	O
i	int
]	O
.	O
p_n_elems	int
,	O
aux_prop	*(struct(array(char),array(char),array(char),int))
[	O
i	int
]	O
.	O
p_type	array(char)
,	O
aux_prop	*(struct(array(char),array(char),array(char),int))
[	O
i	int
]	O
.	O
p_access	array(char)
)	O
;	O
}	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">> %d Methods"	*(char)
,	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nMet	int
)	O
;	O
aux_met	*(struct(array(char),array(char),long,long,long))
=	O
(	O
MD_METHOD	struct(array(char),array(char),long,long,long)
*	O
)	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
Met	struct(long,long,*(void))
.	O
dat	*(void)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
m	*(struct(*(char),long,struct(long,long,*(void)),struct(long,long,*(void)),struct(long,long,*(void)),int,int,int,*(char),*(char),long,long,long,*(char),*(char),*(char),*(char),long,long,long,*(char),*(char),int,int))
->	O
nMet	int
;	O
i	int
++	O
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
">>  %02d -> [%s|%s|%s] %s [%s] "	*(char)
,	O
i	int
,	O
aux_met	*(struct(array(char),array(char),long,long,long))
[	O
i	int
]	O
.	O
m_virtual	long
?	O
"V"	*(char)
:	O
"-"	*(char)
,	O
aux_met	*(struct(array(char),array(char),long,long,long))
[	O
i	int
]	O
.	O
m_abstract	long
?	O
"A"	*(char)
:	O
"-"	*(char)
,	O
aux_met	*(struct(array(char),array(char),long,long,long))
[	O
i	int
]	O
.	O
m_static	long
?	O
"S"	*(char)
:	O
"-"	*(char)
,	O
aux_met	*(struct(array(char),array(char),long,long,long))
[	O
i	int
]	O
.	O
m_name	array(char)
,	O
aux_met	*(struct(array(char),array(char),long,long,long))
[	O
i	int
]	O
.	O
m_sig	array(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
