struct	O
dico_assoc_list	struct(int,*(struct))
{	O
int	O
flags	int
;	O
dico_list_t	*(struct)
list	array(*(struct))
;	O
}	O
;	O
struct	O
find_closure	struct(long)
{	O
size_t	long
count	long
;	O
}	O
;	O
static	O
int	O
assoc_key_cmp	(*(void),*(void),*(void))->(int)
(	O
const	O
void	O
*	O
item	*(void)
,	O
const	O
void	O
*	O
data	*(void)
,	O
void	O
*	O
closure	*(void)
)	O
{	O
const	O
struct	O
dico_assoc	struct(*(char),*(char))
*	O
aptr	*(struct(*(char),*(char)))
=	O
item	*(void)
;	O
char	O
const	O
*	O
str	*(struct)
=	O
data	*(void)
;	O
struct	O
find_closure	struct(long)
*	O
clos	*(struct(long))
=	O
closure	*(void)
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
aptr	*(struct(*(char),*(char)))
->	O
key	*(char)
,	O
str	*(struct)
)	O
==	O
0	int
&&	O
--	O
clos	*(struct(long))
->	O
count	long
==	O
0	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
assoc_key_cmp_ci	(*(void),*(void),*(void))->(int)
(	O
const	O
void	O
*	O
item	*(void)
,	O
const	O
void	O
*	O
data	*(void)
,	O
void	O
*	O
closure	*(void)
)	O
{	O
const	O
struct	O
dico_assoc	struct(*(char),*(char))
*	O
aptr	*(struct(*(char),*(char)))
=	O
item	*(void)
;	O
char	O
const	O
*	O
str	*(struct)
=	O
data	*(void)
;	O
struct	O
find_closure	struct(long)
*	O
clos	*(struct(long))
=	O
closure	*(void)
;	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
aptr	*(struct(*(char),*(char)))
->	O
key	*(char)
,	O
str	*(struct)
)	O
==	O
0	int
&&	O
--	O
clos	*(struct(long))
->	O
count	long
==	O
0	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
assoc_free	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
dico_assoc	struct(*(char),*(char))
*	O
a	*(struct)
=	O
item	*(void)
;	O
free	(*(void))->(void)
(	O
a	*(struct)
->	O
value	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
a	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
dico_assoc_list_t	*(struct)
dico_assoc_create	(int)->(*(struct))
(	O
int	O
flags	int
)	O
{	O
struct	O
dico_assoc_list	struct(int,*(struct))
*	O
assoc	*(struct)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
assoc	*(struct)
)	O
)	O
;	O
if	O
(	O
assoc	*(struct)
)	O
{	O
assoc	*(struct)
->	O
flags	int
=	O
flags	int
;	O
assoc	*(struct)
->	O
list	array(*(struct))
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
assoc	*(struct)
->	O
list	array(*(struct))
)	O
{	O
int	O
ec	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
assoc	*(struct)
)	O
;	O
assoc	*(struct)
=	O
NULL	O
;	O
errno	O
=	O
ec	int
;	O
}	O
else	O
{	O
dico_list_set_comparator	(*(struct),*((*(void),*(void),*(void))->(int)),*(void))->(int)
(	O
assoc	*(struct)
->	O
list	array(*(struct))
,	O
(	O
flags	int
&	O
DICO_ASSOC_CI	int
)	O
?	O
assoc_key_cmp_ci	(*(void),*(void),*(void))->(int)
:	O
assoc_key_cmp	(*(void),*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
dico_list_set_free_item	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
assoc	*(struct)
->	O
list	array(*(struct))
,	O
assoc_free	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
}	O
}	O
return	O
assoc	*(struct)
;	O
}	O
dico_assoc_list_t	*(struct)
dico_assoc_dup	(*(struct))->(*(struct))
(	O
dico_assoc_list_t	*(struct)
src	*(char)
)	O
{	O
dico_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
;	O
struct	O
dico_assoc	struct(*(char),*(char))
*	O
p	*(char)
;	O
dico_assoc_list_t	*(struct)
dst	*(char)
;	O
dst	*(char)
=	O
dico_assoc_create	(int)->(*(struct))
(	O
src	*(char)
->	O
flags	int
)	O
;	O
if	O
(	O
dst	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
itr	*((*(void),*(void))->(int))
=	O
dico_assoc_iterator	(*(struct))->(*(struct))
(	O
src	*(char)
)	O
;	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
)	O
{	O
int	O
ec	int
=	O
errno	O
;	O
dico_assoc_destroy	(*(*(struct)))->(void)
(	O
&	O
dst	*(char)
)	O
;	O
errno	O
=	O
ec	int
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
p	*(char)
=	O
dico_iterator_first	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
p	*(char)
;	O
p	*(char)
=	O
dico_iterator_next	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
)	O
{	O
if	O
(	O
dico_assoc_append	(*(struct),*(char),*(char))->(int)
(	O
dst	*(char)
,	O
p	*(char)
->	O
key	*(char)
,	O
p	*(char)
->	O
value	*(char)
)	O
)	O
{	O
int	O
ec	int
=	O
errno	O
;	O
dico_assoc_destroy	(*(*(struct)))->(void)
(	O
&	O
dst	*(char)
)	O
;	O
errno	O
=	O
ec	int
;	O
break	O
;	O
}	O
}	O
dico_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
;	O
return	O
dst	*(char)
;	O
}	O
struct	O
dico_assoc	struct(*(char),*(char))
*	O
_dico_assoc_find_n	(*(struct(int,*(struct))),*(char),long)->(*(struct(*(char),*(char))))
(	O
dico_assoc_list_t	*(struct)
assoc	*(struct)
,	O
const	O
char	O
*	O
key	*(char)
,	O
size_t	long
n	long
)	O
{	O
struct	O
find_closure	struct(long)
clos	*(struct(long))
;	O
struct	O
dico_assoc	struct(*(char),*(char))
*	O
res	*(struct(*(char),*(char)))
;	O
if	O
(	O
!	O
assoc	*(struct)
||	O
n	long
==	O
0	int
)	O
return	O
NULL	O
;	O
clos	*(struct(long))
.	O
count	long
=	O
n	long
;	O
dico_list_set_comparator_data	(*(struct),*(void))->(int)
(	O
assoc	*(struct)
->	O
list	array(*(struct))
,	O
&	O
clos	*(struct(long))
)	O
;	O
res	*(struct(*(char),*(char)))
=	O
dico_list_locate	(*(struct),*(void))->(*(void))
(	O
assoc	*(struct)
->	O
list	array(*(struct))
,	O
(	O
void	O
*	O
)	O
key	*(char)
)	O
;	O
dico_list_set_comparator_data	(*(struct),*(void))->(int)
(	O
assoc	*(struct)
->	O
list	array(*(struct))
,	O
NULL	O
)	O
;	O
return	O
res	*(struct(*(char),*(char)))
;	O
}	O
const	O
char	O
*	O
dico_assoc_find_n	(*(struct),*(char),long)->(*(char))
(	O
dico_assoc_list_t	*(struct)
assoc	*(struct)
,	O
const	O
char	O
*	O
key	*(char)
,	O
size_t	long
n	long
)	O
{	O
struct	O
dico_assoc	struct(*(char),*(char))
*	O
kvp	*(struct(*(char),*(char)))
=	O
_dico_assoc_find_n	(*(struct(int,*(struct))),*(char),long)->(*(struct(*(char),*(char))))
(	O
assoc	*(struct)
,	O
key	*(char)
,	O
n	long
)	O
;	O
return	O
kvp	*(struct(*(char),*(char)))
?	O
kvp	*(struct(*(char),*(char)))
->	O
value	*(char)
:	O
NULL	O
;	O
}	O
const	O
char	O
*	O
dico_assoc_find	(*(struct),*(char))->(*(char))
(	O
dico_assoc_list_t	*(struct)
assoc	*(struct)
,	O
const	O
char	O
*	O
key	*(char)
)	O
{	O
return	O
dico_assoc_find_n	(*(struct),*(char),long)->(*(char))
(	O
assoc	*(struct)
,	O
key	*(char)
,	O
1	int
)	O
;	O
}	O
void	O
dico_assoc_remove_n	(*(struct),*(char),long)->(void)
(	O
dico_assoc_list_t	*(struct)
assoc	*(struct)
,	O
const	O
char	O
*	O
key	*(char)
,	O
size_t	long
n	long
)	O
{	O
struct	O
find_closure	struct(long)
clos	*(struct(long))
;	O
if	O
(	O
n	long
==	O
0	int
)	O
return	O
;	O
clos	*(struct(long))
.	O
count	long
=	O
n	long
;	O
dico_list_set_comparator_data	(*(struct),*(void))->(int)
(	O
assoc	*(struct)
->	O
list	array(*(struct))
,	O
&	O
clos	*(struct(long))
)	O
;	O
dico_list_remove	(*(struct),*(void),*(*(void)))->(int)
(	O
assoc	*(struct)
->	O
list	array(*(struct))
,	O
(	O
void	O
*	O
)	O
key	*(char)
,	O
NULL	O
)	O
;	O
dico_list_set_comparator_data	(*(struct),*(void))->(int)
(	O
assoc	*(struct)
->	O
list	array(*(struct))
,	O
NULL	O
)	O
;	O
}	O
void	O
dico_assoc_remove	(*(struct),*(char))->(void)
(	O
dico_assoc_list_t	*(struct)
assoc	*(struct)
,	O
const	O
char	O
*	O
key	*(char)
)	O
{	O
return	O
dico_assoc_remove_n	(*(struct),*(char),long)->(void)
(	O
assoc	*(struct)
,	O
key	*(char)
,	O
1	int
)	O
;	O
}	O
int	O
dico_assoc_add	(*(struct),*(char),*(char),long,int)->(int)
(	O
dico_assoc_list_t	*(struct)
assoc	*(struct)
,	O
const	O
char	O
*	O
key	*(char)
,	O
const	O
char	O
*	O
value	*(char)
,	O
size_t	long
count	long
,	O
int	O
replace	int
)	O
{	O
struct	O
dico_assoc	struct(*(char),*(char))
*	O
a	*(struct)
;	O
size_t	long
size	long
;	O
if	O
(	O
value	*(char)
==	O
NULL	O
)	O
{	O
dico_assoc_remove_n	(*(struct),*(char),long)->(void)
(	O
assoc	*(struct)
,	O
key	*(char)
,	O
count	long
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
(	O
assoc	*(struct)
->	O
flags	int
&	O
DICO_ASSOC_MULT	int
)	O
)	O
{	O
a	*(struct)
=	O
_dico_assoc_find_n	(*(struct(int,*(struct))),*(char),long)->(*(struct(*(char),*(char))))
(	O
assoc	*(struct)
,	O
key	*(char)
,	O
count	long
)	O
;	O
if	O
(	O
a	*(struct)
)	O
{	O
if	O
(	O
replace	int
)	O
{	O
char	O
*	O
s	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
value	*(char)
)	O
;	O
if	O
(	O
!	O
s	*(char)
)	O
return	O
1	int
;	O
free	(*(void))->(void)
(	O
a	*(struct)
->	O
value	*(char)
)	O
;	O
a	*(struct)
->	O
value	*(char)
=	O
s	*(char)
;	O
return	O
0	int
;	O
}	O
errno	O
=	O
EEXIST	int
;	O
return	O
1	int
;	O
}	O
}	O
size	long
=	O
sizeof	O
(	O
*	O
a	*(struct)
)	O
+	O
strlen	(*(char))->(long)
(	O
key	*(char)
)	O
+	O
1	int
;	O
a	*(struct)
=	O
malloc	(long)->(*(void))
(	O
size	long
)	O
;	O
if	O
(	O
!	O
a	*(struct)
)	O
return	O
1	int
;	O
a	*(struct)
->	O
key	*(char)
=	O
(	O
char	O
*	O
)	O
(	O
a	*(struct)
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
a	*(struct)
->	O
key	*(char)
,	O
key	*(char)
)	O
;	O
a	*(struct)
->	O
value	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
value	*(char)
)	O
;	O
if	O
(	O
!	O
a	*(struct)
->	O
value	*(char)
)	O
{	O
int	O
ec	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
a	*(struct)
)	O
;	O
errno	O
=	O
ec	int
;	O
return	O
1	int
;	O
}	O
return	O
dico_list_append	(*(struct),*(void))->(int)
(	O
assoc	*(struct)
->	O
list	array(*(struct))
,	O
a	*(struct)
)	O
;	O
}	O
int	O
dico_assoc_append	(*(struct),*(char),*(char))->(int)
(	O
dico_assoc_list_t	*(struct)
assoc	*(struct)
,	O
const	O
char	O
*	O
key	*(char)
,	O
const	O
char	O
*	O
value	*(char)
)	O
{	O
return	O
dico_assoc_add	(*(struct),*(char),*(char),long,int)->(int)
(	O
assoc	*(struct)
,	O
key	*(char)
,	O
value	*(char)
,	O
1	int
,	O
0	int
)	O
;	O
}	O
int	O
dico_assoc_clear	(*(struct))->(int)
(	O
dico_assoc_list_t	*(struct)
assoc	*(struct)
)	O
{	O
if	O
(	O
!	O
assoc	*(struct)
)	O
{	O
errno	O
=	O
EINVAL	int
;	O
return	O
1	int
;	O
}	O
return	O
dico_list_clear	(*(struct))->(int)
(	O
assoc	*(struct)
->	O
list	array(*(struct))
)	O
;	O
}	O
void	O
dico_assoc_destroy	(*(*(struct)))->(void)
(	O
dico_assoc_list_t	*(struct)
*	O
passoc	*(*(struct))
)	O
{	O
if	O
(	O
passoc	*(*(struct))
&&	O
*	O
passoc	*(*(struct))
)	O
{	O
dico_assoc_list_t	*(struct)
assoc	*(struct)
=	O
*	O
passoc	*(*(struct))
;	O
dico_list_destroy	(*(*(struct)))->(void)
(	O
&	O
assoc	*(struct)
->	O
list	array(*(struct))
)	O
;	O
free	(*(void))->(void)
(	O
assoc	*(struct)
)	O
;	O
}	O
}	O
dico_iterator_t	*(struct)
dico_assoc_iterator	(*(struct))->(*(struct))
(	O
dico_assoc_list_t	*(struct)
assoc	*(struct)
)	O
{	O
if	O
(	O
!	O
assoc	*(struct)
)	O
return	O
NULL	O
;	O
return	O
dico_list_iterator	(*(struct))->(*(struct))
(	O
assoc	*(struct)
->	O
list	array(*(struct))
)	O
;	O
}	O
size_t	long
dico_assoc_count	(*(struct))->(long)
(	O
dico_assoc_list_t	*(struct)
assoc	*(struct)
)	O
{	O
if	O
(	O
!	O
assoc	*(struct)
)	O
return	O
0	int
;	O
return	O
dico_list_count	(*(struct))->(long)
(	O
assoc	*(struct)
->	O
list	array(*(struct))
)	O
;	O
}	O
