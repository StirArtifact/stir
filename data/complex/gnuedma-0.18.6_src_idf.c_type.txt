ESint32	long
EDMAPROC	O
_edma_read_class_interface	(long,*(char))->(long)
(	O
EUint32	long
ClassId	long
,	O
EPChar	*(char)
Name	*(char)
)	O
{	O
CLASSID	long
CId	long
,	O
aux_cid	long
;	O
EChar	char
FilePath	array(char)
[	O
256	int
]	O
;	O
static	O
EChar	char
Buffer	array(char)
[	O
200	int
]	O
;	O
EChar	char
IFaceKey	array(char)
[	O
256	int
]	O
;	O
EChar	char
IFaceValue	array(char)
[	O
256	int
]	O
;	O
ESint32	long
*	O
IFaceList	*(long)
;	O
EChar	char
Ver	array(char)
[	O
100	int
]	O
;	O
EDWord	long
Result	long
;	O
FILE	struct
*	O
f	*(char)
;	O
EUint32	long
nProp	short
,	O
nMet	short
,	O
nNot	short
,	O
i	long
,	O
j	long
,	O
ii	long
,	O
indx	long
;	O
EUint32	long
nTotalProp	long
,	O
nTotalMet	long
,	O
nTotalNot	long
;	O
ESint32	long
nIFaces	long
;	O
ESint32	long
n_vmets	long
;	O
HMEM	long
h	long
,	O
h1	long
,	O
h2	long
;	O
EUint32	long
DataSize	long
;	O
EPChar	*(char)
*	O
clist	*(*(char))
;	O
EPChar	*(char)
*	O
idlist	*(*(char))
,	O
*	O
idlist1	*(*(char))
,	O
aux	*(char)
,	O
aux1	*(char)
;	O
PINIFILE	*(void)
pi	*(void)
;	O
if	O
(	O
Name	*(char)
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[_edma_read_class_interface] Interface name "	*(char)
"invalid"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
ClassId	long
==	O
-	O
1	int
)	O
CId	long
=	O
edma_get_class_id	(*(char))->(long)
(	O
Name	*(char)
)	O
;	O
else	O
CId	long
=	O
ClassId	long
;	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
ClassId	long
,	O
"_edma_read_class_interface"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ProcMapTable	*(char)
[	O
CId	long
]	O
>=	O
CLASS_ILOADED	int
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"[_edma_read_class_interface] Interface for Class %d is "	*(char)
"already loaded"	*(char)
,	O
CId	long
)	O
;	O
if	O
(	O
ProcMapTable	*(char)
[	O
CId	long
]	O
>=	O
CLASS_IMAPPED	int
)	O
return	O
0	int
;	O
}	O
ProcMapTable	*(char)
[	O
CId	long
]	O
=	O
CLASS_TEMP	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
Ver	array(char)
,	O
""	*(char)
)	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
Name	*(char)
,	O
':'	O
)	O
==	O
0	int
)	O
{	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
FilePath	array(char)
,	O
edma_repo_manager_get_repo_dir	(long)->(*(char))
(	O
gClass	O
[	O
CId	long
]	O
->	O
repo_id	long
)	O
,	O
256	int
)	O
;	O
if	O
(	O
edma_repo_manager_get_repo_type	(long)->(long)
(	O
gClass	O
[	O
CId	long
]	O
->	O
repo_id	long
)	O
==	O
EDMA_SHARED_REPO	int
)	O
{	O
strncat	(*(char),*(char),int)->(*(char))
(	O
FilePath	array(char)
,	O
IDFDIR	*(char)
,	O
256	int
)	O
;	O
}	O
else	O
{	O
strncat	(*(char),*(char),int)->(*(char))
(	O
FilePath	array(char)
,	O
edma_repo_manager_get_repo_name	(long)->(*(char))
(	O
gClass	O
[	O
CId	long
]	O
->	O
repo_id	long
)	O
,	O
256	int
)	O
;	O
strncat	(*(char),*(char),int)->(*(char))
(	O
FilePath	array(char)
,	O
"/idf/"	*(char)
,	O
256	int
)	O
;	O
}	O
strncat	(*(char),*(char),int)->(*(char))
(	O
FilePath	array(char)
,	O
gClass	O
[	O
CId	long
]	O
->	O
NameSpace	array(char)
,	O
256	int
)	O
;	O
strncat	(*(char),*(char),int)->(*(char))
(	O
FilePath	array(char)
,	O
"/"	*(char)
,	O
256	int
)	O
;	O
strncat	(*(char),*(char),int)->(*(char))
(	O
FilePath	array(char)
,	O
Name	*(char)
,	O
256	int
)	O
;	O
if	O
(	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
MajorVer	char
==	O
0	int
)	O
&&	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
MinorVer	char
==	O
0	int
)	O
)	O
strncat	(*(char),*(char),int)->(*(char))
(	O
FilePath	array(char)
,	O
".idf"	*(char)
,	O
256	int
)	O
;	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
Ver	array(char)
,	O
"_%d_%d"	*(char)
,	O
gClass	O
[	O
CId	long
]	O
->	O
MajorVer	char
,	O
gClass	O
[	O
CId	long
]	O
->	O
MinorVer	char
)	O
;	O
strncat	(*(char),*(char),int)->(*(char))
(	O
FilePath	array(char)
,	O
Ver	array(char)
,	O
256	int
)	O
;	O
strncat	(*(char),*(char),int)->(*(char))
(	O
FilePath	array(char)
,	O
".idf"	*(char)
,	O
256	int
)	O
;	O
}	O
}	O
else	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
FilePath	array(char)
,	O
Name	*(char)
,	O
256	int
)	O
;	O
if	O
(	O
(	O
f	*(char)
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))))
(	O
FilePath	array(char)
,	O
"rt"	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[_edma_read_class_interface] Interface definition "	*(char)
"file %s not found"	*(char)
,	O
FilePath	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))))->(int)
(	O
f	*(char)
)	O
;	O
pi	*(void)
=	O
edma_open_ini	(*(char))->(*(void))
(	O
FilePath	array(char)
)	O
;	O
nProp	short
=	O
edma_get_ini_int	(*(void),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
"Definition"	*(char)
,	O
"PropertiesNum"	*(char)
,	O
0	int
)	O
;	O
nMet	short
=	O
edma_get_ini_int	(*(void),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
"Definition"	*(char)
,	O
"MethodsNum"	*(char)
,	O
0	int
)	O
;	O
nNot	short
=	O
edma_get_ini_int	(*(void),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
"Definition"	*(char)
,	O
"NotificationsNum"	*(char)
,	O
0	int
)	O
;	O
nIFaces	long
=	O
edma_get_ini_int	(*(void),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
"Definition"	*(char)
,	O
"InterfacesNum"	*(char)
,	O
0	int
)	O
;	O
nTotalProp	long
=	O
nProp	short
;	O
nTotalMet	long
=	O
nMet	short
;	O
nTotalNot	long
=	O
nNot	short
;	O
if	O
(	O
nIFaces	long
)	O
{	O
if	O
(	O
(	O
h	long
=	O
edma_palloc	(long)->(long)
(	O
sizeof	O
(	O
ESint32	long
)	O
*	O
nIFaces	long
)	O
)	O
==	O
(	O
HMEM	long
)	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[_edma_read_class_interface] Can't allocate memory"	*(char)
" for interface processing on Class %d"	*(char)
,	O
CId	long
)	O
;	O
}	O
else	O
{	O
IFaceList	*(long)
=	O
(	O
ESint32	long
*	O
)	O
edma_pget	(long)->(*(void))
(	O
h	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nIFaces	long
;	O
i	long
++	O
)	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
IFaceKey	array(char)
,	O
256	int
,	O
"Interface%ld"	*(char)
,	O
i	long
)	O
;	O
edma_get_ini_string	(*(void),*(char),*(char),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
"Interface"	*(char)
,	O
IFaceKey	array(char)
,	O
NULL	O
,	O
IFaceValue	array(char)
,	O
256	int
)	O
;	O
IFaceList	*(long)
[	O
i	long
]	O
=	O
edma_get_class_id	(*(char))->(long)
(	O
IFaceValue	array(char)
)	O
;	O
if	O
(	O
IFaceList	*(long)
[	O
i	long
]	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[_edma_read_class_interface] Interface "	*(char)
"%d:'%s' does not exists"	*(char)
,	O
i	long
,	O
IFaceValue	array(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
ProcMapTable	*(char)
[	O
IFaceList	*(long)
[	O
i	long
]	O
]	O
<	O
CLASS_ILOADED	int
)	O
if	O
(	O
(	O
edma_load_class_int	(long)->(long)
(	O
IFaceList	*(long)
[	O
i	long
]	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
IFaceList	*(long)
[	O
i	long
]	O
=	O
-	O
1	int
;	O
continue	O
;	O
}	O
nTotalProp	long
+=	O
gClass	O
[	O
IFaceList	*(long)
[	O
i	long
]	O
]	O
->	O
nProp	short
;	O
nTotalMet	long
+=	O
gClass	O
[	O
IFaceList	*(long)
[	O
i	long
]	O
]	O
->	O
nMet	short
;	O
}	O
}	O
}	O
if	O
(	O
(	O
edma_idf_set_def	(long,long,long,long)->(long)
(	O
CId	long
,	O
nTotalProp	long
,	O
nTotalMet	long
,	O
nNot	short
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[_edma_read_class_interface] Build Property class "	*(char)
"failed for class %d"	*(char)
,	O
CId	long
)	O
;	O
edma_printf_err	(*(char))->(long)
(	O
"[_edma_read_class_interface] Oops!... "	*(char)
"this shouldn't happen"	*(char)
)	O
;	O
}	O
DataSize	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nProp	short
;	O
i	long
++	O
)	O
{	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
i	long
]	O
.	O
Off	short
=	O
DataSize	long
;	O
DataSize	long
+=	O
_edma_read_edmaidf_prop	(*(void),long,long)->(long)
(	O
pi	*(void)
,	O
CId	long
,	O
i	long
)	O
;	O
}	O
indx	long
=	O
nProp	short
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nIFaces	long
;	O
i	long
++	O
)	O
if	O
(	O
IFaceList	*(long)
[	O
i	long
]	O
!=	O
-	O
1	int
)	O
{	O
aux_cid	long
=	O
IFaceList	*(long)
[	O
i	long
]	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gClass	O
[	O
aux_cid	long
]	O
->	O
nProp	short
;	O
j	long
++	O
,	O
indx	long
++	O
)	O
{	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
IdProp	array(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
aux_cid	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
j	long
]	O
.	O
IdProp	array(char)
,	O
EDMA_PROP_NAME_LEN	O
)	O
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
Tipo	long
=	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
aux_cid	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
j	long
]	O
.	O
Tipo	long
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
ioTipo	char
=	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
aux_cid	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
j	long
]	O
.	O
ioTipo	char
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
nElem	long
=	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
aux_cid	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
j	long
]	O
.	O
nElem	long
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
Off	short
=	O
DataSize	long
;	O
DataSize	long
+=	O
(	O
tipo	array(struct(array(char),long,long,array(char)))
[	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
aux_cid	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
j	long
]	O
.	O
Tipo	long
]	O
.	O
tam	long
*	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
aux_cid	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
j	long
]	O
.	O
nElem	long
)	O
;	O
}	O
}	O
gClass	O
[	O
CId	long
]	O
->	O
TamDatos	long
=	O
DataSize	long
;	O
gClass	O
[	O
CId	long
]	O
->	O
nProp	short
=	O
indx	long
;	O
n_vmets	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nMet	short
;	O
i	long
++	O
)	O
n_vmets	long
+=	O
_edma_read_edmaidf_met	(*(void),long,long)->(long)
(	O
pi	*(void)
,	O
CId	long
,	O
i	long
)	O
;	O
indx	long
=	O
nMet	short
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nIFaces	long
;	O
i	long
++	O
)	O
if	O
(	O
IFaceList	*(long)
[	O
i	long
]	O
!=	O
-	O
1	int
)	O
{	O
aux_cid	long
=	O
IFaceList	*(long)
[	O
i	long
]	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gClass	O
[	O
aux_cid	long
]	O
->	O
nMet	short
;	O
j	long
++	O
,	O
indx	long
++	O
)	O
{	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
IdMet	array(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
aux_cid	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
j	long
]	O
.	O
IdMet	array(char)
,	O
EDMA_MET_NAME_LEN	O
)	O
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Sign	array(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
aux_cid	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
j	long
]	O
.	O
Sign	array(char)
,	O
EDMA_MET_SIG_LEN	int
)	O
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Virtual	char
=	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
aux_cid	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
j	long
]	O
.	O
Virtual	char
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Abstract	char
=	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
aux_cid	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
j	long
]	O
.	O
Abstract	char
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Static	char
=	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
aux_cid	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
j	long
]	O
.	O
Static	char
;	O
n_vmets	long
+=	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
aux_cid	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
j	long
]	O
.	O
Virtual	char
;	O
}	O
}	O
gClass	O
[	O
CId	long
]	O
->	O
nMet	short
=	O
indx	long
;	O
gClass	O
[	O
CId	long
]	O
->	O
nMetVir	long
=	O
n_vmets	long
;	O
if	O
(	O
nIFaces	long
)	O
edma_pfree	(long,*(void))->(void)
(	O
h	long
,	O
IFaceList	*(long)
)	O
;	O
Buffer	array(char)
[	O
0	int
]	O
=	O
0	int
;	O
Result	long
=	O
0	int
;	O
Result	long
=	O
edma_get_ini_string	(*(void),*(char),*(char),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
"Definition"	*(char)
,	O
"SCList"	*(char)
,	O
NULL	O
,	O
Buffer	array(char)
,	O
200	int
)	O
;	O
if	O
(	O
Result	long
!=	O
0	int
)	O
{	O
j	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
Result	long
;	O
i	long
++	O
)	O
if	O
(	O
Buffer	array(char)
[	O
i	long
]	O
==	O
','	O
)	O
j	long
++	O
;	O
j	long
++	O
;	O
edma_printf_dbg	(long,long,*(char))->(long)
(	O
12	int
,	O
-	O
1	int
,	O
"[_edma_read_class_interface] %d superclases "	*(char)
"located :"	*(char)
,	O
j	long
)	O
;	O
gClass	O
[	O
CId	long
]	O
->	O
Derived	long
=	O
j	long
;	O
if	O
(	O
(	O
h	long
=	O
edma_palloc	(long)->(long)
(	O
sizeof	O
(	O
EPChar	*(char)
)	O
*	O
(	O
j	long
+	O
1	int
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[_edma_read_class_interface] Can't create "	*(char)
"inheritance info"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
clist	*(*(char))
=	O
(	O
EPChar	*(char)
*	O
)	O
edma_pget	(long)->(*(void))
(	O
h	long
)	O
;	O
clist	*(*(char))
[	O
0	int
]	O
=	O
Buffer	array(char)
;	O
if	O
(	O
(	O
h1	long
=	O
edma_palloc	(long)->(long)
(	O
sizeof	O
(	O
EPChar	*(char)
)	O
*	O
(	O
j	long
+	O
1	int
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[_edma_read_class_interface] Can't create "	*(char)
"anchor point info..."	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
idlist	*(*(char))
=	O
(	O
EPChar	*(char)
*	O
)	O
edma_pget	(long)->(*(void))
(	O
h1	long
)	O
;	O
if	O
(	O
(	O
h2	long
=	O
edma_palloc	(long)->(long)
(	O
sizeof	O
(	O
EPChar	*(char)
)	O
*	O
(	O
j	long
+	O
1	int
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[_edma_read_class_interface] Can't create "	*(char)
"anchor point info..."	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
idlist1	*(*(char))
=	O
(	O
EPChar	*(char)
*	O
)	O
edma_pget	(long)->(*(void))
(	O
h2	long
)	O
;	O
ii	long
=	O
j	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
Result	long
+	O
1	int
;	O
i	long
++	O
)	O
if	O
(	O
(	O
Buffer	array(char)
[	O
i	long
]	O
==	O
','	O
)	O
||	O
(	O
Buffer	array(char)
[	O
i	long
]	O
==	O
0	int
)	O
)	O
{	O
clist	*(*(char))
[	O
j	long
]	O
=	O
(	O
Buffer	array(char)
+	O
ii	long
)	O
;	O
Buffer	array(char)
[	O
i	long
]	O
=	O
0	int
;	O
if	O
(	O
(	O
aux	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
clist	*(*(char))
[	O
j	long
]	O
,	O
':'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
idlist	*(*(char))
[	O
j	long
]	O
=	O
aux	*(char)
+	O
1	int
;	O
*	O
aux	*(char)
=	O
0	int
;	O
if	O
(	O
(	O
aux1	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
idlist	*(*(char))
[	O
j	long
]	O
,	O
'|'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
idlist1	*(*(char))
[	O
j	long
]	O
=	O
aux1	*(char)
+	O
1	int
;	O
*	O
aux1	*(char)
=	O
0	int
;	O
}	O
else	O
idlist1	*(*(char))
[	O
j	long
]	O
=	O
NULL	O
;	O
}	O
else	O
idlist	*(*(char))
[	O
j	long
]	O
=	O
NULL	O
;	O
j	long
++	O
;	O
ii	long
=	O
i	long
+	O
1	int
;	O
}	O
clist	*(*(char))
[	O
j	long
]	O
=	O
0	int
;	O
idlist	*(*(char))
[	O
j	long
]	O
=	O
0	int
;	O
idlist1	*(*(char))
[	O
j	long
]	O
=	O
0	int
;	O
gClass	O
[	O
CId	long
]	O
->	O
Status	char
=	O
CLASS_ILOADED	int
;	O
ProcMapTable	*(char)
[	O
CId	long
]	O
=	O
CLASS_IMAPPED	int
;	O
if	O
(	O
(	O
edma_derive_class	(*(char),*(*(char)),*(*(char)),*(*(char)))->(long)
(	O
gClass	O
[	O
CId	long
]	O
->	O
ClassName	array(char)
,	O
clist	*(*(char))
,	O
idlist	*(*(char))
,	O
idlist1	*(*(char))
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"Can't load interfaz for class %s"	*(char)
,	O
gClass	O
[	O
CId	long
]	O
->	O
ClassName	array(char)
)	O
;	O
edma_pfree	(long,*(void))->(void)
(	O
h	long
,	O
clist	*(*(char))
)	O
;	O
edma_pfree	(long,*(void))->(void)
(	O
h1	long
,	O
idlist	*(*(char))
)	O
;	O
edma_pfree	(long,*(void))->(void)
(	O
h2	long
,	O
idlist1	*(*(char))
)	O
;	O
edma_close_ini	(*(void))->(long)
(	O
pi	*(void)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_pfree	(long,*(void))->(void)
(	O
h	long
,	O
clist	*(*(char))
)	O
;	O
edma_pfree	(long,*(void))->(void)
(	O
h1	long
,	O
idlist	*(*(char))
)	O
;	O
edma_pfree	(long,*(void))->(void)
(	O
h2	long
,	O
idlist1	*(*(char))
)	O
;	O
}	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
met_dict	*(struct(long,long,long,long,long,*(struct(*(char),long,long))))
=	O
edma_dict_new	(long)->(*(struct(long,long,long,long,long,*(struct(*`,long,long)))))
(	O
gClass	O
[	O
CId	long
]	O
->	O
nMet	short
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
CId	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
edma_dict_add_entry	(*(struct(long,long,long,long,long,*(struct(*`,long,long)))),*(char),long)->(long)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
met_dict	*(struct(long,long,long,long,long,*(struct(*(char),long,long))))
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
IdMet	array(char)
,	O
i	long
)	O
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
prop_dict	*(struct(long,long,long,long,long,*(struct(*(char),long,long))))
=	O
edma_dict_new	(long)->(*(struct(long,long,long,long,long,*(struct(*`,long,long)))))
(	O
gClass	O
[	O
CId	long
]	O
->	O
nProp	short
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
CId	long
]	O
->	O
nProp	short
;	O
i	long
++	O
)	O
edma_dict_add_entry	(*(struct(long,long,long,long,long,*(struct(*`,long,long)))),*(char),long)->(long)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
prop_dict	*(struct(long,long,long,long,long,*(struct(*(char),long,long))))
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
i	long
]	O
.	O
IdProp	array(char)
,	O
i	long
)	O
;	O
edma_close_ini	(*(void))->(long)
(	O
pi	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_free_class_interface	(long,*(char))->(long)
(	O
EUint32	long
ClassId	long
,	O
EPChar	*(char)
Name	*(char)
)	O
{	O
CLASSID	long
CId	long
;	O
if	O
(	O
(	O
ClassId	long
==	O
-	O
1	int
)	O
&&	O
(	O
Name	*(char)
==	O
NULL	O
)	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[_edma_free_class_interface] Not enough "	*(char)
"information to locate class"	*(char)
)	O
;	O
}	O
if	O
(	O
ClassId	long
==	O
-	O
1	int
)	O
CId	long
=	O
edma_get_class_id	(*(char))->(long)
(	O
Name	*(char)
)	O
;	O
else	O
CId	long
=	O
ClassId	long
;	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
ClassId	long
,	O
"_edma_free_class_interface"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ProcMapTable	*(char)
[	O
CId	long
]	O
>=	O
CLASS_ILOADED	int
)	O
{	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
Derived	long
)	O
{	O
edma_sunget	(*(void))->(*(void))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
SCList	*(long)
)	O
;	O
edma_sunget	(*(void))->(*(void))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
SCIdList	*(array(char))
)	O
;	O
}	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
nProp	short
)	O
edma_sunget	(*(void))->(*(void))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
)	O
;	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
nMet	short
)	O
edma_sunget	(*(void))->(*(void))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
)	O
;	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
nNot	short
)	O
edma_sunget	(*(void))->(*(void))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Not	*(struct(array(char),long,*(char),long,*(()->(long)),long))
)	O
;	O
ProcMapTable	*(char)
[	O
CId	long
]	O
=	O
CLASS_ILOADED	int
;	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
Ocurrences	long
==	O
0	int
)	O
{	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
Derived	long
)	O
{	O
edma_sfree	(long,*(void))->(void)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hSCList	long
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
SCList	*(long)
)	O
;	O
edma_sfree	(long,*(void))->(void)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hSCIdList	long
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
SCIdList	*(array(char))
)	O
;	O
}	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
nProp	short
)	O
edma_sfree	(long,*(void))->(void)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hProp	long
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
)	O
;	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
nMet	short
)	O
edma_sfree	(long,*(void))->(void)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hMet	long
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
)	O
;	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
nNot	short
)	O
edma_sfree	(long,*(void))->(void)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hNot	long
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
CId	long
]	O
->	O
Not	*(struct(array(char),long,*(char),long,*(()->(long)),long))
)	O
;	O
ProcMapTable	*(char)
[	O
CId	long
]	O
=	O
CLASS_DEF	int
;	O
gClass	O
[	O
CId	long
]	O
->	O
Status	char
=	O
CLASS_DEF	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
EUint32	long
_edma_read_edmaidf_prop	(*(void),long,long)->(long)
(	O
PINIFILE	*(void)
pi	*(void)
,	O
EUint32	long
class_id	long
,	O
EUint32	long
property_indx	long
)	O
{	O
EChar	char
prop_name	array(char)
[	O
EDMA_PROP_NAME_LEN	O
]	O
;	O
EChar	char
prop_type	array(char)
[	O
EDMA_GENERAL_ID_LEN	int
]	O
;	O
EChar	char
prop_access	array(char)
[	O
EDMA_GENERAL_ID_LEN	int
]	O
;	O
EChar	char
user_data	array(char)
[	O
EDMA_CLASS_NAME_LEN	int
]	O
;	O
EChar	char
Aux	array(char)
[	O
100	int
]	O
;	O
EDWord	long
Result	long
;	O
EUint32	long
n_elems	long
,	O
size	long
;	O
size	long
=	O
0	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
Aux	array(char)
,	O
"Prop%ld"	*(char)
,	O
property_indx	long
)	O
;	O
Result	long
=	O
edma_get_ini_string	(*(void),*(char),*(char),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
Aux	array(char)
,	O
"Name"	*(char)
,	O
NULL	O
,	O
prop_name	array(char)
,	O
EDMA_PROP_NAME_LEN	O
)	O
;	O
Result	long
=	O
edma_get_ini_string	(*(void),*(char),*(char),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
Aux	array(char)
,	O
"Type"	*(char)
,	O
NULL	O
,	O
prop_type	array(char)
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
Result	long
=	O
edma_get_ini_string	(*(void),*(char),*(char),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
Aux	array(char)
,	O
"UserType"	*(char)
,	O
NULL	O
,	O
user_data	array(char)
,	O
EDMA_CLASS_NAME_LEN	int
)	O
;	O
Result	long
=	O
edma_get_ini_string	(*(void),*(char),*(char),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
Aux	array(char)
,	O
"Access"	*(char)
,	O
NULL	O
,	O
prop_access	array(char)
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
n_elems	long
=	O
edma_get_ini_int	(*(void),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
Aux	array(char)
,	O
"ArrayElems"	*(char)
,	O
0	int
)	O
;	O
size	long
=	O
edma_idf_set_prop	(long,long,*(char),*(char),*(char),long,*(char))->(long)
(	O
class_id	long
,	O
property_indx	long
,	O
prop_name	array(char)
,	O
prop_type	array(char)
,	O
prop_access	array(char)
,	O
n_elems	long
,	O
user_data	array(char)
)	O
;	O
if	O
(	O
size	long
<	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[_edma_read_edmaidf_prop] Error reading property "	*(char)
"%s on class %s:%d"	*(char)
,	O
prop_name	array(char)
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
size	long
;	O
}	O
EUint32	long
_edma_read_edmaidf_met	(*(void),long,long)->(long)
(	O
PINIFILE	*(void)
pi	*(void)
,	O
EUint32	long
class_id	long
,	O
EUint32	long
method_indx	long
)	O
{	O
EChar	char
method_name	array(char)
[	O
EDMA_MET_NAME_LEN	O
]	O
;	O
EChar	char
method_sig	array(char)
[	O
EDMA_MET_SIG_LEN	int
]	O
;	O
EChar	char
Aux	array(char)
[	O
100	int
]	O
;	O
EDWord	long
Result	long
;	O
ESint32	long
m_abstract	long
,	O
m_static	long
,	O
m_virtual	long
;	O
sprintf	(*(char),*(char))->(int)
(	O
Aux	array(char)
,	O
"Met%ld"	*(char)
,	O
method_indx	long
)	O
;	O
Result	long
=	O
edma_get_ini_string	(*(void),*(char),*(char),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
Aux	array(char)
,	O
"Name"	*(char)
,	O
NULL	O
,	O
method_name	array(char)
,	O
EDMA_MET_NAME_LEN	O
)	O
;	O
Result	long
=	O
edma_get_ini_string	(*(void),*(char),*(char),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
Aux	array(char)
,	O
"Signature"	*(char)
,	O
NULL	O
,	O
method_sig	array(char)
,	O
EDMA_MET_SIG_LEN	int
)	O
;	O
m_static	long
=	O
edma_get_ini_int	(*(void),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
Aux	array(char)
,	O
"Static"	*(char)
,	O
0	int
)	O
;	O
m_abstract	long
=	O
edma_get_ini_int	(*(void),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
Aux	array(char)
,	O
"Abstract"	*(char)
,	O
0	int
)	O
;	O
m_virtual	long
=	O
edma_get_ini_int	(*(void),*(char),*(char),long)->(long)
(	O
pi	*(void)
,	O
Aux	array(char)
,	O
"Virtual"	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
m_abstract	long
)	O
if	O
(	O
m_virtual	long
==	O
0	int
)	O
{	O
edma_log	(*(char))->(long)
(	O
"[_edma_read_edmaidf_met] WARNNING. Method '%s' declared "	*(char)
"abstract but not virtual. Setting virtual flag"	*(char)
,	O
method_name	array(char)
)	O
;	O
m_virtual	long
=	O
1	int
;	O
}	O
edma_idf_set_met	(long,long,*(char),*(char),char,char,char)->(long)
(	O
class_id	long
,	O
method_indx	long
,	O
method_name	array(char)
,	O
method_sig	array(char)
,	O
m_virtual	long
,	O
m_abstract	long
,	O
m_static	long
)	O
;	O
return	O
m_virtual	long
;	O
}	O
