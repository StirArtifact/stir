static	O
int	O
sr_construct_swverid	(*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)),*(struct(*`,*`,int,int,int,char,int)),int)),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))))->(int)
(	O
SWICAT_SR	struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int)
*	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
,	O
SWICAT_SE	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))
*	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
)	O
{	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
buf	*(char)
;	O
SWVERID	struct(*(char),*(char),*(char),int,*(struct(*(*(char)),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct(array(char),array(char),array(char),array(char),int,*`,*`)))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int)
*	O
swverid	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
;	O
buf	*(char)
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
30	int
)	O
;	O
if	O
(	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
bundleM	*(char)
)	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
buf	*(char)
,	O
STROB_DO_APPEND	int
,	O
"%s"	*(char)
,	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
bundleM	*(char)
)	O
;	O
if	O
(	O
strob_strlen	(*(struct(*(char),*(char),int,int,int,char,int)))->(long)
(	O
buf	*(char)
)	O
)	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
buf	*(char)
,	O
STROB_DO_APPEND	int
,	O
"."	*(char)
)	O
;	O
if	O
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
tagM	*(char)
)	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
buf	*(char)
,	O
STROB_DO_APPEND	int
,	O
"%s"	*(char)
,	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
tagM	*(char)
)	O
;	O
if	O
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
vendor_tagM	*(char)
)	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
buf	*(char)
,	O
STROB_DO_APPEND	int
,	O
","	*(char)
SWVERID_VERIDS_VENDOR_TAG	*(char)
SWVERID_RELOP_EQ2	*(char)
"%s"	*(char)
,	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
vendor_tagM	*(char)
)	O
;	O
if	O
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
revisionM	*(char)
)	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
buf	*(char)
,	O
STROB_DO_APPEND	int
,	O
","	*(char)
SWVERID_VERIDS_REVISION	*(char)
SWVERID_RELOP_EQ	*(char)
"%s"	*(char)
,	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
revisionM	*(char)
)	O
;	O
if	O
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
locationM	*(char)
)	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
buf	*(char)
,	O
STROB_DO_APPEND	int
,	O
","	*(char)
SWVERID_VERIDS_LOCATION	*(char)
SWVERID_RELOP_EQ2	*(char)
"%s"	*(char)
,	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
locationM	*(char)
)	O
;	O
if	O
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
qualifierM	*(char)
)	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
buf	*(char)
,	O
STROB_DO_APPEND	int
,	O
","	*(char)
SWVERID_VERIDS_QUALIFIER	*(char)
SWVERID_RELOP_EQ2	*(char)
"%s"	*(char)
,	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
qualifierM	*(char)
)	O
;	O
E_DEBUG2	O
(	O
"fully qualified swspec=[%s]"	*(char)
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
buf	*(char)
)	O
)	O
;	O
swverid	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
=	O
swverid_open	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)))
(	O
SW_A_product	*(char)
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
buf	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
swverid	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: construction of version id failed for %s\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
buf	*(char)
)	O
)	O
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
swspecM	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
=	O
swverid	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
buf	*(char)
)	O
;	O
return	O
swverid	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
==	O
NULL	O
?	O
1	int
:	O
0	int
;	O
}	O
SWICAT_SE	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))
*	O
swicat_se_create	()->(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))))
(	O
void	O
)	O
{	O
SWICAT_SE	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))
*	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
=	O
(	O
SWICAT_SE	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
SWICAT_SE	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))
)	O
)	O
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
entryM	*(char)
=	O
NULL	O
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
tagM	*(char)
=	O
NULL	O
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
revisionM	*(char)
=	O
NULL	O
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
vendor_tagM	*(char)
=	O
NULL	O
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
locationM	*(char)
=	O
NULL	O
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
sequenceM	*(char)
=	O
NULL	O
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
qualifierM	*(char)
=	O
NULL	O
;	O
return	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
;	O
}	O
void	O
swicat_se_delete	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
SWICAT_SE	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))
*	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
)	O
{	O
if	O
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
entryM	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
entryM	*(char)
)	O
;	O
if	O
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
tagM	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
tagM	*(char)
)	O
;	O
if	O
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
revisionM	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
revisionM	*(char)
)	O
;	O
if	O
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
vendor_tagM	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
vendor_tagM	*(char)
)	O
;	O
if	O
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
locationM	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
locationM	*(char)
)	O
;	O
if	O
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
sequenceM	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
sequenceM	*(char)
)	O
;	O
if	O
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
qualifierM	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
qualifierM	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
)	O
;	O
}	O
int	O
swicat_se_parse	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(char))->(int)
(	O
SWICAT_SE	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))
*	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
,	O
char	O
*	O
entry	*(char)
)	O
{	O
int	O
fn	int
;	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
;	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
80	int
)	O
;	O
E_DEBUG2	O
(	O
"Entering: [%s]"	*(char)
,	O
entry	*(char)
)	O
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
entryM	*(char)
=	O
swlib_strdup	(*(char))->(*(char))
(	O
entry	*(char)
)	O
;	O
fn	int
=	O
0	int
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
entry	*(char)
,	O
" \t\n\r"	*(char)
)	O
;	O
while	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
switch	O
(	O
fn	int
)	O
{	O
case	O
0	int
:	O
E_DEBUG2	O
(	O
"assigning tag: [%s]"	*(char)
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
tagM	*(char)
=	O
swlib_strdup	(*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"r="	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
{	O
s	*(struct(*(char),*(char),int,int,int,char,int))
+=	O
2	int
;	O
E_DEBUG2	O
(	O
"assigning revision: [%s]"	*(char)
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
revisionM	*(char)
=	O
swlib_strdup	(*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
else	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"v="	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
{	O
s	*(struct(*(char),*(char),int,int,int,char,int))
+=	O
2	int
;	O
E_DEBUG2	O
(	O
"assigning vendor_tag: [%s]"	*(char)
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
vendor_tagM	*(char)
=	O
swlib_strdup	(*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
else	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"i="	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
{	O
s	*(struct(*(char),*(char),int,int,int,char,int))
+=	O
2	int
;	O
E_DEBUG2	O
(	O
"assigning sequence: [%s]"	*(char)
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
sequenceM	*(char)
=	O
swlib_strdup	(*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
else	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"l="	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
{	O
s	*(struct(*(char),*(char),int,int,int,char,int))
+=	O
2	int
;	O
E_DEBUG2	O
(	O
"assigning location: [%s]"	*(char)
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
locationM	*(char)
=	O
swlib_strdup	(*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
else	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"q="	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
{	O
s	*(struct(*(char),*(char),int,int,int,char,int))
+=	O
2	int
;	O
E_DEBUG2	O
(	O
"assigning qualifier: [%s]"	*(char)
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
qualifierM	*(char)
=	O
swlib_strdup	(*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
fn	int
++	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
NULL	O
,	O
" \t\r\n"	*(char)
)	O
;	O
}	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
return	O
0	int
;	O
}	O
SWICAT_SQ	struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)))
*	O
swicat_sq_create	()->(*(struct(*(char),int,array(char),*(char),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)))))
(	O
void	O
)	O
{	O
SWICAT_SQ	struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)))
*	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
;	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
=	O
(	O
SWICAT_SQ	struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)))
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
SWICAT_SQ	struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)))
)	O
)	O
;	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
numberM	*(char)
=	O
0	int
;	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
levelM	array(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
levelM	array(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
lineM	*(char)
=	O
NULL	O
;	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
swspec_stringM	*(char)
=	O
NULL	O
;	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
swspecM	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
=	O
NULL	O
;	O
return	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
;	O
}	O
void	O
swicat_sq_delete	(*(struct(*(char),int,array(char),*(char),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)))))->(void)
(	O
SWICAT_SQ	struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)))
*	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
)	O
{	O
if	O
(	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
lineM	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
lineM	*(char)
)	O
;	O
if	O
(	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
swspec_stringM	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
swspec_stringM	*(char)
)	O
;	O
if	O
(	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
swspecM	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
!=	O
NULL	O
)	O
swverid_close	(*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)))->(void)
(	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
swspecM	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
)	O
;	O
free	(*(void))->(void)
(	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
)	O
;	O
}	O
int	O
swicat_sq_parse	(*(struct(*(char),int,array(char),*(char),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)))),*(char))->(int)
(	O
SWICAT_SQ	struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)))
*	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
,	O
char	O
*	O
line	*(char)
)	O
{	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
;	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
int	O
field_no	int
;	O
int	O
status	int
;	O
field_no	int
=	O
0	int
;	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
80	int
)	O
;	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
lineM	*(char)
=	O
swlib_strdup	(*(char))->(*(char))
(	O
line	*(char)
)	O
;	O
E_DEBUG2	O
(	O
"line=[%s]"	*(char)
,	O
line	*(char)
)	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
line	*(char)
,	O
":\r\n"	*(char)
)	O
;	O
while	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
switch	O
(	O
field_no	int
)	O
{	O
case	O
0	int
:	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
numberM	*(char)
=	O
swlib_atoi	(*(char),*(int))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
+	O
1	int
,	O
&	O
status	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
1	int
:	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
levelM	array(char)
[	O
0	int
]	O
=	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
break	O
;	O
case	O
2	int
:	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
swspec_stringM	*(char)
=	O
swlib_strdup	(*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
swspecM	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
=	O
swverid_open	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)))
(	O
NULL	O
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
if	O
(	O
sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
->	O
swspecM	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
break	O
;	O
}	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
NULL	O
,	O
":\r\n"	*(char)
)	O
;	O
field_no	int
++	O
;	O
}	O
return	O
0	int
;	O
}	O
SWICAT_SR	struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int)
*	O
swicat_sr_create	()->(*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)),*(struct(*`,*`,int,int,int,char,int)),int)))
(	O
void	O
)	O
{	O
SWICAT_SR	struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int)
*	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
=	O
(	O
SWICAT_SR	struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int)
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
SWICAT_SR	struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int)
)	O
)	O
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
lineM	*(char)
=	O
NULL	O
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
bundleM	*(char)
=	O
NULL	O
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
entry_lineM	*(char)
=	O
NULL	O
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
swspecM	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
=	O
NULL	O
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
catalog_entry_pathM	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
48	int
)	O
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
seM	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
=	O
NULL	O
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
foundM	int
=	O
0	int
;	O
return	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
;	O
}	O
void	O
swicat_sr_delete	(*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)),*(struct(*`,*`,int,int,int,char,int)),int)))->(void)
(	O
SWICAT_SR	struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int)
*	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
)	O
{	O
if	O
(	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
lineM	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
lineM	*(char)
)	O
;	O
if	O
(	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
bundleM	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
bundleM	*(char)
)	O
;	O
if	O
(	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
swspecM	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
!=	O
NULL	O
)	O
swverid_close	(*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)))->(void)
(	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
swspecM	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
)	O
;	O
free	(*(void))->(void)
(	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
)	O
;	O
}	O
int	O
swicat_sr_parse	(*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)),*(struct(*`,*`,int,int,int,char,int)),int)),*(char))->(int)
(	O
SWICAT_SR	struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int)
*	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
,	O
char	O
*	O
line	*(char)
)	O
{	O
SWICAT_SE	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))
*	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
;	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
int	O
field_no	int
;	O
int	O
status	int
;	O
int	O
ret	int
;	O
int	O
retval	int
;	O
E_DEBUG2	O
(	O
"Entering: [%s]"	*(char)
,	O
line	*(char)
)	O
;	O
retval	int
=	O
0	int
;	O
field_no	int
=	O
0	int
;	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
80	int
)	O
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
lineM	*(char)
=	O
swlib_strdup	(*(char))->(*(char))
(	O
line	*(char)
)	O
;	O
E_DEBUG2	O
(	O
"sr_parse line=[%s]"	*(char)
,	O
line	*(char)
)	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
line	*(char)
,	O
":\n\r"	*(char)
)	O
;	O
while	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
E_DEBUG2	O
(	O
"[%s]"	*(char)
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
switch	O
(	O
field_no	int
)	O
{	O
case	O
0	int
:	O
E_DEBUG	O
(	O
"case 0"	*(char)
)	O
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
numberM	*(char)
=	O
swlib_atoi	(*(char),*(int))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
+	O
1	int
,	O
&	O
status	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
1	int
:	O
E_DEBUG	O
(	O
"case 1"	*(char)
)	O
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
levelM	array(char)
[	O
0	int
]	O
=	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
break	O
;	O
case	O
2	int
:	O
E_DEBUG	O
(	O
"case 2"	*(char)
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
!=	O
3	int
)	O
return	O
-	O
3	int
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
matches_bundleM	int
=	O
0	int
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
matches_productM	int
=	O
0	int
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
matches_filesetM	int
=	O
0	int
;	O
if	O
(	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
==	O
'B'	O
)	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
matches_bundleM	int
=	O
1	int
;	O
if	O
(	O
*	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
+	O
1	int
)	O
==	O
'P'	O
)	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
matches_productM	int
=	O
1	int
;	O
if	O
(	O
*	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
+	O
2	int
)	O
==	O
'F'	O
)	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
matches_filesetM	int
=	O
1	int
;	O
break	O
;	O
case	O
3	int
:	O
E_DEBUG	O
(	O
"case 4"	*(char)
)	O
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
bundleM	*(char)
=	O
swlib_strdup	(*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
break	O
;	O
case	O
4	int
:	O
E_DEBUG	O
(	O
"case 5"	*(char)
)	O
;	O
E_DEBUG2	O
(	O
"parsing (_se_parse) [%s]"	*(char)
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
=	O
swicat_se_create	()->(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))))
(	O
)	O
;	O
ret	int
=	O
swicat_se_parse	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(char))->(int)
(	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
if	O
(	O
ret	int
)	O
return	O
-	O
4	int
;	O
ret	int
=	O
sr_construct_swverid	(*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)),*(struct(*`,*`,int,int,int,char,int)),int)),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))))->(int)
(	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
,	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
)	O
;	O
retval	int
=	O
ret	int
;	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
seM	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
=	O
se	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
;	O
break	O
;	O
}	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
NULL	O
,	O
":\r\n"	*(char)
)	O
;	O
field_no	int
++	O
;	O
E_DEBUG2	O
(	O
"field number: %d"	*(char)
,	O
field_no	int
)	O
;	O
}	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
return	O
retval	int
;	O
}	O
SWICAT_SC	struct(*(struct(*(char),int,array(char),*(char),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)))),*(union(struct(*(*`),int,int,long,int))),int,int)
*	O
swicat_sc_create	()->(*(struct(*(struct(*`,int,array(char),*`,*`)),*(union(struct`)),int,int)))
(	O
void	O
)	O
{	O
SWICAT_SC	struct(*(struct(*(char),int,array(char),*(char),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)))),*(union(struct(*(*`),int,int,long,int))),int,int)
*	O
sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
;	O
sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
=	O
(	O
SWICAT_SC	struct(*(struct(*(char),int,array(char),*(char),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)))),*(union(struct(*(*`),int,int,long,int))),int,int)
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
SWICAT_SC	struct(*(struct(*(char),int,array(char),*(char),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)))),*(union(struct(*(*`),int,int,long,int))),int,int)
)	O
)	O
;	O
sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
->	O
srM	*(union(struct(*(*(char)),int,int,long,int)))
=	O
vplob_open	()->(*(union(struct(*(*`),int,int,long,int))))
(	O
)	O
;	O
sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
->	O
sqM	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
=	O
NULL	O
;	O
sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
->	O
statusM	int
=	O
0	int
;	O
sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
->	O
swverid_uuidM	int
=	O
0	int
;	O
return	O
sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
;	O
}	O
void	O
swicat_sc_delete	(*(struct(*(struct(*`,int,array(char),*`,*`)),*(union(struct`)),int,int)))->(void)
(	O
SWICAT_SC	struct(*(struct(*(char),int,array(char),*(char),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)))),*(union(struct(*(*`),int,int,long,int))),int,int)
*	O
swicat_sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
)	O
{	O
vplob_delete_store	(*(union(struct(*(*`),int,int,long,int))),*((*(void))->(void)))->(int)
(	O
swicat_sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
->	O
srM	*(union(struct(*(*(char)),int,int,long,int)))
,	O
(	O
void	O
(	O
*	O
)	O
(	O
void	O
*	O
)	O
)	O
(	O
swicat_sr_delete	(*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)),*(struct(*`,*`,int,int,int,char,int)),int)))->(void)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
swicat_sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
)	O
;	O
}	O
void	O
swicat_sc_add_sr	(*(struct(*(struct(*`,int,array(char),*`,*`)),*(union(struct`)),int,int)),*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)),*(struct(*`,*`,int,int,int,char,int)),int)))->(void)
(	O
SWICAT_SC	struct(*(struct(*(char),int,array(char),*(char),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)))),*(union(struct(*(*`),int,int,long,int))),int,int)
*	O
swicat_sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
,	O
SWICAT_SR	struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int)
*	O
swicat_sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
)	O
{	O
vplob_add	(*(union(struct(*(*`),int,int,long,int))),*(void))->(void)
(	O
swicat_sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
->	O
srM	*(union(struct(*(*(char)),int,int,long,int)))
,	O
swicat_sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
)	O
;	O
}	O
void	O
swicat_sc_set_sq	(*(struct(*(struct(*`,int,array(char),*`,*`)),*(union(struct`)),int,int)),*(struct(*(char),int,array(char),*(char),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)))))->(void)
(	O
SWICAT_SC	struct(*(struct(*(char),int,array(char),*(char),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)))),*(union(struct(*(*`),int,int,long,int))),int,int)
*	O
swicat_sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
,	O
SWICAT_SQ	struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)))
*	O
swicat_sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
)	O
{	O
swicat_sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
->	O
sqM	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
=	O
swicat_sq	*(struct(*(char),int,array(char),*(char),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int))))
;	O
}	O
SWICAT_SL	struct(*(union(struct(*(*`),int,int,long,int))))
*	O
swicat_sl_create	()->(*(struct(*(union(struct`)))))
(	O
void	O
)	O
{	O
SWICAT_SL	struct(*(union(struct(*(*`),int,int,long,int))))
*	O
sl	*(struct(*(union(struct(*`,int,int,long,int)))))
;	O
sl	*(struct(*(union(struct(*`,int,int,long,int)))))
=	O
(	O
SWICAT_SL	struct(*(union(struct(*(*`),int,int,long,int))))
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
SWICAT_SL	struct(*(union(struct(*(*`),int,int,long,int))))
)	O
)	O
;	O
sl	*(struct(*(union(struct(*`,int,int,long,int)))))
->	O
scM	*(union(struct(*(*(char)),int,int,long,int)))
=	O
vplob_open	()->(*(union(struct(*(*`),int,int,long,int))))
(	O
)	O
;	O
return	O
sl	*(struct(*(union(struct(*`,int,int,long,int)))))
;	O
}	O
void	O
swicat_sl_delete	(*(struct(*(union(struct`)))))->(void)
(	O
SWICAT_SL	struct(*(union(struct(*(*`),int,int,long,int))))
*	O
swicat_sl	*(struct(*(union(struct(*`,int,int,long,int)))))
)	O
{	O
vplob_delete_store	(*(union(struct(*(*`),int,int,long,int))),*((*(void))->(void)))->(int)
(	O
swicat_sl	*(struct(*(union(struct(*`,int,int,long,int)))))
->	O
scM	*(union(struct(*(*(char)),int,int,long,int)))
,	O
(	O
void	O
(	O
*	O
)	O
(	O
void	O
*	O
)	O
)	O
(	O
swicat_sc_delete	(*(struct(*(struct(*`,int,array(char),*`,*`)),*(union(struct`)),int,int)))->(void)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
swicat_sl	*(struct(*(union(struct(*`,int,int,long,int)))))
)	O
;	O
}	O
void	O
swicat_sl_add_sc	(*(struct(*(union(struct`)))),*(struct(*(struct(*`,int,array(char),*`,*`)),*(union(struct`)),int,int)))->(void)
(	O
SWICAT_SL	struct(*(union(struct(*(*`),int,int,long,int))))
*	O
swicat_sl	*(struct(*(union(struct(*`,int,int,long,int)))))
,	O
SWICAT_SC	struct(*(struct(*(char),int,array(char),*(char),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)))),*(union(struct(*(*`),int,int,long,int))),int,int)
*	O
swicat_sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
)	O
{	O
vplob_add	(*(union(struct(*(*`),int,int,long,int))),*(void))->(void)
(	O
swicat_sl	*(struct(*(union(struct(*`,int,int,long,int)))))
->	O
scM	*(union(struct(*(*(char)),int,int,long,int)))
,	O
swicat_sc	*(struct(*(struct(*(char),int,array(char),*(char),*(struct`))),*(union(struct(*`,int,int,long,int))),int,int))
)	O
;	O
}	O
char	O
*	O
swicat_sr_form_swspec	(*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)),*(struct(*`,*`,int,int,int,char,int)),int)),*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
SWICAT_SR	struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int)
*	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
,	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
buf	*(char)
)	O
{	O
char	O
*	O
path	*(char)
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
48	int
)	O
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
buf	*(char)
,	O
""	*(char)
)	O
;	O
path	*(char)
=	O
swicat_sr_form_catalog_path	(*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)),*(struct(*`,*`,int,int,int,char,int)),int)),*(char),*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
,	O
""	*(char)
,	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
if	O
(	O
path	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
path	*(char)
=	O
swicat_sr_form_swspec_from_catalog_path	(*(char),*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
path	*(char)
,	O
buf	*(char)
)	O
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
return	O
path	*(char)
;	O
}	O
char	O
*	O
swicat_sr_form_catalog_path	(*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)),*(struct(*`,*`,int,int,int,char,int)),int)),*(char),*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
SWICAT_SR	struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int)
*	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
,	O
char	O
*	O
installed_software_catalog	*(char)
,	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
buf	*(char)
)	O
{	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
sb	*(struct(*(char),*(char),int,int,int,char,int))
;	O
if	O
(	O
buf	*(char)
==	O
NULL	O
)	O
{	O
sb	*(struct(*(char),*(char),int,int,int,char,int))
=	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
catalog_entry_pathM	*(struct(*(char),*(char),int,int,int,char,int))
;	O
}	O
else	O
{	O
sb	*(struct(*(char),*(char),int,int,int,char,int))
=	O
buf	*(char)
;	O
}	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
sb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
""	*(char)
)	O
;	O
if	O
(	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
matches_bundleM	int
==	O
0	int
&&	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
matches_productM	int
==	O
0	int
)	O
{	O
return	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
sb	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
sb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
installed_software_catalog	*(char)
)	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
bundleM	*(char)
;	O
swlib_unix_dircat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(int)
(	O
sb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
seM	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
tagM	*(char)
;	O
swlib_unix_dircat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(int)
(	O
sb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
seM	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
revisionM	*(char)
;	O
swlib_unix_dircat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(int)
(	O
sb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
sr	*(struct(int,array(char),int,int,int,*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),*(struct(*(char),*(char),int,int,int,char,int)),int))
->	O
seM	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
sequenceM	*(char)
;	O
swlib_unix_dircat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(int)
(	O
sb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
if	O
(	O
swlib_check_clean_path	(*(char))->(int)
(	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
sb	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"error: path tainted: %s\n"	*(char)
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
sb	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
;	O
}	O
return	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
sb	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
char	O
*	O
swicat_sr_form_swspec_from_catalog_path	(*(char),*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
char	O
*	O
path	*(char)
,	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
swspec	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
int	O
n	long
;	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
;	O
STRAR	struct(int,int,*(struct(*(*(char)),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int)))
*	O
dir_components	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
swspec	*(struct(*(char),*(char),int,int,int,char,int))
,	O
""	*(char)
)	O
;	O
if	O
(	O
path	*(char)
==	O
NULL	O
||	O
strlen	(*(char))->(long)
(	O
path	*(char)
)	O
==	O
0	int
)	O
{	O
return	O
NULL	O
;	O
}	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
100	int
)	O
;	O
dir_components	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
=	O
strar_open	()->(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))))
(	O
)	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
path	*(char)
,	O
"/"	*(char)
)	O
;	O
while	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
strar_add	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),*(char))->(int)
(	O
dir_components	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
NULL	O
,	O
"/"	*(char)
)	O
;	O
}	O
n	long
=	O
strar_num_elements	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))))->(int)
(	O
dir_components	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
)	O
;	O
if	O
(	O
n	long
<	O
4	int
)	O
{	O
return	O
NULL	O
;	O
}	O
n	long
--	O
;	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
swspec	*(struct(*(char),*(char),int,int,int,char,int))
,	O
0	int
,	O
"%s.%s,r==%s,i=%s"	*(char)
,	O
strar_get	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),int)->(*(char))
(	O
dir_components	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
n	long
-	O
3	int
)	O
,	O
strar_get	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),int)->(*(char))
(	O
dir_components	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
n	long
-	O
2	int
)	O
,	O
strar_get	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),int)->(*(char))
(	O
dir_components	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
n	long
-	O
1	int
)	O
,	O
strar_get	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),int)->(*(char))
(	O
dir_components	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
n	long
-	O
0	int
)	O
)	O
;	O
return	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
swspec	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
