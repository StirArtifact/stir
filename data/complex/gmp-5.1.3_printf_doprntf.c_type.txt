int	O
__gmp_doprnt_mpf	O
(	O
const	O
struct	O
doprnt_funs_t	struct(*((*(void),*(char),array(struct(int,int,*(void),*(void))))->(int)),*((*(void),*(char),long)->(int)),*((*(void),int,int)->(int)),*((*(void))->(int)))
*	O
funs	*(struct(*((*(void),*(char),array(struct(int,int,*(void),*(void))))->(int)),*((*(void),*(char),long)->(int)),*((*(void),int,int)->(int)),*((*(void))->(int))))
,	O
void	O
*	O
data	*(void)
,	O
const	O
struct	O
doprnt_params_t	struct(int,int,*(char),int,char,int,int,int,int,int,char,int)
*	O
p	*(char)
,	O
const	O
char	O
*	O
point	*(char)
,	O
mpf_srcptr	*(struct(int,int,long,*(long)))
f	*(struct(int,int,long,*(long)))
)	O
{	O
int	O
prec	int
,	O
ndigits	int
,	O
free_size	int
,	O
len	int
,	O
newlen	int
,	O
justify	int
,	O
justlen	int
,	O
explen	int
;	O
int	O
showbaselen	int
,	O
sign	char
,	O
signlen	int
,	O
intlen	int
,	O
intzeros	int
,	O
pointlen	int
;	O
int	O
fraczeros	int
,	O
fraclen	int
,	O
preczeros	int
;	O
char	O
*	O
s	array(char)
,	O
*	O
free_ptr	*(char)
;	O
mp_exp_t	long
exp	int
;	O
char	O
exponent	array(char)
[	O
GMP_LIMB_BITS	int
+	O
10	int
]	O
;	O
const	O
char	O
*	O
showbase	int
;	O
int	O
retval	int
=	O
0	int
;	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"__gmp_doprnt_float\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"  conv=%d prec=%d\n"	*(char)
,	O
p	*(char)
->	O
conv	int
,	O
p	*(char)
->	O
prec	int
)	O
)	O
;	O
prec	int
=	O
p	*(char)
->	O
prec	int
;	O
if	O
(	O
prec	int
<=	O
-	O
1	int
)	O
{	O
ndigits	int
=	O
0	int
;	O
if	O
(	O
p	*(char)
->	O
conv	int
==	O
DOPRNT_CONV_GENERAL	int
)	O
MPF_SIGNIFICANT_DIGITS	O
(	O
prec	int
,	O
PREC	O
(	O
f	*(struct(int,int,long,*(long)))
)	O
,	O
ABS	O
(	O
p	*(char)
->	O
base	int
)	O
)	O
;	O
}	O
else	O
{	O
switch	O
(	O
p	*(char)
->	O
conv	int
)	O
{	O
case	O
DOPRNT_CONV_FIXED	int
:	O
ndigits	int
=	O
prec	int
+	O
2	int
+	O
1	int
+	O
EXP	O
(	O
f	*(struct(int,int,long,*(long)))
)	O
*	O
(	O
mp_bases	O
[	O
ABS	O
(	O
p	*(char)
->	O
base	int
)	O
]	O
.	O
chars_per_limb	int
+	O
(	O
EXP	O
(	O
f	*(struct(int,int,long,*(long)))
)	O
>=	O
0	int
)	O
)	O
;	O
ndigits	int
=	O
MAX	O
(	O
ndigits	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
DOPRNT_CONV_SCIENTIFIC	int
:	O
ndigits	int
=	O
prec	int
+	O
1	int
;	O
break	O
;	O
default	O
:	O
ASSERT	O
(	O
0	int
)	O
;	O
case	O
DOPRNT_CONV_GENERAL	int
:	O
ndigits	int
=	O
MAX	O
(	O
prec	int
,	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"  ndigits %d\n"	*(char)
,	O
ndigits	int
)	O
)	O
;	O
s	array(char)
=	O
mpf_get_str	O
(	O
NULL	O
,	O
&	O
exp	int
,	O
p	*(char)
->	O
base	int
,	O
ndigits	int
,	O
f	*(struct(int,int,long,*(long)))
)	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
s	array(char)
)	O
;	O
free_ptr	*(char)
=	O
s	array(char)
;	O
free_size	int
=	O
len	int
+	O
1	int
;	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"  s   %s\n"	*(char)
,	O
s	array(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"  exp %ld\n"	*(char)
,	O
exp	int
)	O
;	O
printf	(*(char))->(int)
(	O
"  len %d\n"	*(char)
,	O
len	int
)	O
)	O
;	O
ASSERT	O
(	O
(	O
p	*(char)
->	O
conv	int
==	O
DOPRNT_CONV_FIXED	int
&&	O
p	*(char)
->	O
prec	int
>	O
-	O
1	int
)	O
?	O
ndigits	int
>=	O
MAX	O
(	O
1	int
,	O
exp	int
+	O
p	*(char)
->	O
prec	int
+	O
2	int
)	O
:	O
1	int
)	O
;	O
sign	char
=	O
p	*(char)
->	O
sign	char
;	O
if	O
(	O
s	array(char)
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
sign	char
=	O
s	array(char)
[	O
0	int
]	O
;	O
s	array(char)
++	O
,	O
len	int
--	O
;	O
}	O
signlen	int
=	O
(	O
sign	char
!=	O
'\0'	O
)	O
;	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"  sign %c  signlen %d\n"	*(char)
,	O
sign	char
,	O
signlen	int
)	O
)	O
;	O
switch	O
(	O
p	*(char)
->	O
conv	int
)	O
{	O
case	O
DOPRNT_CONV_FIXED	int
:	O
if	O
(	O
prec	int
<=	O
-	O
1	int
)	O
prec	int
=	O
MAX	O
(	O
0	int
,	O
len	int
-	O
exp	int
)	O
;	O
ASSERT	O
(	O
prec	int
>=	O
0	int
)	O
;	O
newlen	int
=	O
exp	int
+	O
prec	int
;	O
if	O
(	O
newlen	int
<	O
0	int
)	O
{	O
len	int
=	O
0	int
;	O
exp	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
len	int
<=	O
newlen	int
)	O
{	O
}	O
else	O
{	O
const	O
char	O
*	O
num_to_text	*(char)
=	O
(	O
p	*(char)
->	O
base	int
>=	O
0	int
?	O
"0123456789abcdefghijklmnopqrstuvwxyz"	*(char)
:	O
"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"	*(char)
)	O
;	O
int	O
base	int
=	O
ABS	O
(	O
p	*(char)
->	O
base	int
)	O
;	O
int	O
n	long
;	O
ASSERT	O
(	O
base	int
<=	O
36	int
)	O
;	O
len	int
=	O
newlen	int
;	O
n	long
=	O
DIGIT_VALUE	O
(	O
s	array(char)
[	O
len	int
]	O
)	O
;	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"  rounding with %d\n"	*(char)
,	O
n	long
)	O
)	O
;	O
if	O
(	O
n	long
>=	O
(	O
base	int
+	O
1	int
)	O
/	O
2	int
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
len	int
==	O
0	int
)	O
{	O
s	array(char)
[	O
0	int
]	O
=	O
'1'	O
;	O
len	int
=	O
1	int
;	O
exp	int
++	O
;	O
break	O
;	O
}	O
n	long
=	O
DIGIT_VALUE	O
(	O
s	array(char)
[	O
len	int
-	O
1	int
]	O
)	O
;	O
ASSERT	O
(	O
n	long
>=	O
0	int
&&	O
n	long
<	O
base	int
)	O
;	O
n	long
++	O
;	O
if	O
(	O
n	long
!=	O
base	int
)	O
{	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"  storing now %d\n"	*(char)
,	O
n	long
)	O
)	O
;	O
s	array(char)
[	O
len	int
-	O
1	int
]	O
=	O
num_to_text	*(char)
[	O
n	long
]	O
;	O
break	O
;	O
}	O
len	int
--	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
len	int
>	O
0	int
&&	O
s	array(char)
[	O
len	int
-	O
1	int
]	O
==	O
'0'	O
)	O
len	int
--	O
;	O
}	O
if	O
(	O
len	int
==	O
0	int
)	O
exp	int
=	O
0	int
;	O
}	O
fixed	O
:	O
ASSERT	O
(	O
len	int
==	O
0	int
?	O
exp	int
==	O
0	int
:	O
1	int
)	O
;	O
if	O
(	O
exp	int
<=	O
0	int
)	O
{	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"  fixed 0.000sss\n"	*(char)
)	O
)	O
;	O
intlen	int
=	O
0	int
;	O
intzeros	int
=	O
1	int
;	O
fraczeros	int
=	O
-	O
exp	int
;	O
fraclen	int
=	O
len	int
;	O
}	O
else	O
{	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"  fixed sss.sss or sss000\n"	*(char)
)	O
)	O
;	O
intlen	int
=	O
MIN	O
(	O
len	int
,	O
exp	int
)	O
;	O
intzeros	int
=	O
exp	int
-	O
intlen	int
;	O
fraczeros	int
=	O
0	int
;	O
fraclen	int
=	O
len	int
-	O
intlen	int
;	O
}	O
explen	int
=	O
0	int
;	O
break	O
;	O
case	O
DOPRNT_CONV_SCIENTIFIC	int
:	O
{	O
long	O
int	O
expval	long
;	O
char	O
expsign	char
;	O
if	O
(	O
prec	int
<=	O
-	O
1	int
)	O
prec	int
=	O
MAX	O
(	O
0	int
,	O
len	int
-	O
1	int
)	O
;	O
scientific	O
:	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"  scientific s.sss\n"	*(char)
)	O
)	O
;	O
intlen	int
=	O
MIN	O
(	O
1	int
,	O
len	int
)	O
;	O
intzeros	int
=	O
(	O
intlen	int
==	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
fraczeros	int
=	O
0	int
;	O
fraclen	int
=	O
len	int
-	O
intlen	int
;	O
expval	long
=	O
(	O
exp	int
-	O
intlen	int
)	O
;	O
if	O
(	O
p	*(char)
->	O
exptimes4	int
)	O
expval	long
<<=	O
2	int
;	O
expsign	char
=	O
(	O
expval	long
>=	O
0	int
?	O
'+'	O
:	O
'-'	O
)	O
;	O
expval	long
=	O
ABS	O
(	O
expval	long
)	O
;	O
explen	int
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
exponent	array(char)
,	O
sizeof	O
(	O
exponent	array(char)
)	O
,	O
p	*(char)
->	O
expfmt	*(char)
,	O
expsign	char
,	O
expval	long
)	O
;	O
ASSERT	O
(	O
explen	int
>=	O
0	int
&&	O
explen	int
<	O
sizeof	O
(	O
exponent	array(char)
)	O
-	O
1	int
)	O
;	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"  expfmt %s gives %s\n"	*(char)
,	O
p	*(char)
->	O
expfmt	*(char)
,	O
exponent	array(char)
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
ASSERT	O
(	O
0	int
)	O
;	O
case	O
DOPRNT_CONV_GENERAL	int
:	O
if	O
(	O
exp	int
-	O
1	int
<	O
-	O
4	int
||	O
exp	int
-	O
1	int
>=	O
MAX	O
(	O
1	int
,	O
prec	int
)	O
)	O
goto	O
scientific	O
;	O
else	O
goto	O
fixed	O
;	O
}	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"  intlen %d intzeros %d fraczeros %d fraclen %d\n"	*(char)
,	O
intlen	int
,	O
intzeros	int
,	O
fraczeros	int
,	O
fraclen	int
)	O
)	O
;	O
ASSERT	O
(	O
p	*(char)
->	O
prec	int
<=	O
-	O
1	int
?	O
intlen	int
+	O
fraclen	int
==	O
strlen	(*(char))->(long)
(	O
s	array(char)
)	O
:	O
intlen	int
+	O
fraclen	int
<=	O
strlen	(*(char))->(long)
(	O
s	array(char)
)	O
)	O
;	O
if	O
(	O
p	*(char)
->	O
showtrailing	int
)	O
{	O
preczeros	int
=	O
prec	int
-	O
(	O
fraczeros	int
+	O
fraclen	int
+	O
(	O
p	*(char)
->	O
conv	int
==	O
DOPRNT_CONV_GENERAL	int
?	O
intlen	int
+	O
intzeros	int
:	O
0	int
)	O
)	O
;	O
preczeros	int
=	O
MAX	O
(	O
0	int
,	O
preczeros	int
)	O
;	O
}	O
else	O
preczeros	int
=	O
0	int
;	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"  prec=%d showtrailing=%d, pad with preczeros %d\n"	*(char)
,	O
prec	int
,	O
p	*(char)
->	O
showtrailing	int
,	O
preczeros	int
)	O
)	O
;	O
pointlen	int
=	O
(	O
(	O
fraczeros	int
+	O
fraclen	int
+	O
preczeros	int
)	O
!=	O
0	int
||	O
p	*(char)
->	O
showpoint	int
!=	O
0	int
)	O
?	O
strlen	(*(char))->(long)
(	O
point	*(char)
)	O
:	O
0	int
;	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"  point |%s|  pointlen %d\n"	*(char)
,	O
point	*(char)
,	O
pointlen	int
)	O
)	O
;	O
showbase	int
=	O
NULL	O
;	O
showbaselen	int
=	O
0	int
;	O
switch	O
(	O
p	*(char)
->	O
showbase	int
)	O
{	O
default	O
:	O
ASSERT	O
(	O
0	int
)	O
;	O
case	O
DOPRNT_SHOWBASE_NO	int
:	O
break	O
;	O
case	O
DOPRNT_SHOWBASE_NONZERO	int
:	O
if	O
(	O
intlen	int
==	O
0	int
&&	O
fraclen	int
==	O
0	int
)	O
break	O
;	O
case	O
DOPRNT_SHOWBASE_YES	int
:	O
switch	O
(	O
p	*(char)
->	O
base	int
)	O
{	O
case	O
16	int
:	O
showbase	int
=	O
"0x"	*(char)
;	O
showbaselen	int
=	O
2	int
;	O
break	O
;	O
case	O
-	O
16	int
:	O
showbase	int
=	O
"0X"	*(char)
;	O
showbaselen	int
=	O
2	int
;	O
break	O
;	O
case	O
8	int
:	O
showbase	int
=	O
"0"	*(char)
;	O
showbaselen	int
=	O
1	int
;	O
break	O
;	O
}	O
break	O
;	O
}	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"  showbase %s showbaselen %d\n"	*(char)
,	O
showbase	int
==	O
NULL	O
?	O
""	*(char)
:	O
showbase	int
,	O
showbaselen	int
)	O
)	O
;	O
justlen	int
=	O
p	*(char)
->	O
width	int
-	O
(	O
signlen	int
+	O
showbaselen	int
+	O
intlen	int
+	O
intzeros	int
+	O
pointlen	int
+	O
fraczeros	int
+	O
fraclen	int
+	O
preczeros	int
+	O
explen	int
)	O
;	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"  justlen %d fill 0x%X\n"	*(char)
,	O
justlen	int
,	O
p	*(char)
->	O
fill	char
)	O
)	O
;	O
justify	int
=	O
p	*(char)
->	O
justify	int
;	O
if	O
(	O
justlen	int
<=	O
0	int
)	O
justify	int
=	O
DOPRNT_JUSTIFY_NONE	int
;	O
TRACE	O
(	O
printf	(*(char))->(int)
(	O
"  justify type %d  intlen %d pointlen %d fraclen %d\n"	*(char)
,	O
justify	int
,	O
intlen	int
,	O
pointlen	int
,	O
fraclen	int
)	O
)	O
;	O
if	O
(	O
justify	int
==	O
DOPRNT_JUSTIFY_RIGHT	int
)	O
DOPRNT_REPS	O
(	O
p	*(char)
->	O
fill	char
,	O
justlen	int
)	O
;	O
if	O
(	O
signlen	int
)	O
DOPRNT_REPS	O
(	O
sign	char
,	O
1	int
)	O
;	O
DOPRNT_MEMORY_MAYBE	O
(	O
showbase	int
,	O
showbaselen	int
)	O
;	O
if	O
(	O
justify	int
==	O
DOPRNT_JUSTIFY_INTERNAL	int
)	O
DOPRNT_REPS	O
(	O
p	*(char)
->	O
fill	char
,	O
justlen	int
)	O
;	O
DOPRNT_MEMORY	O
(	O
s	array(char)
,	O
intlen	int
)	O
;	O
DOPRNT_REPS_MAYBE	O
(	O
'0'	O
,	O
intzeros	int
)	O
;	O
DOPRNT_MEMORY_MAYBE	O
(	O
point	*(char)
,	O
pointlen	int
)	O
;	O
DOPRNT_REPS_MAYBE	O
(	O
'0'	O
,	O
fraczeros	int
)	O
;	O
DOPRNT_MEMORY_MAYBE	O
(	O
s	array(char)
+	O
intlen	int
,	O
fraclen	int
)	O
;	O
DOPRNT_REPS_MAYBE	O
(	O
'0'	O
,	O
preczeros	int
)	O
;	O
DOPRNT_MEMORY_MAYBE	O
(	O
exponent	array(char)
,	O
explen	int
)	O
;	O
if	O
(	O
justify	int
==	O
DOPRNT_JUSTIFY_LEFT	int
)	O
DOPRNT_REPS	O
(	O
p	*(char)
->	O
fill	char
,	O
justlen	int
)	O
;	O
done	O
:	O
(	O
*	O
__gmp_free_func	*((*(void),long)->(void))
)	O
(	O
free_ptr	*(char)
,	O
free_size	int
)	O
;	O
return	O
retval	int
;	O
error	O
:	O
retval	int
=	O
-	O
1	int
;	O
goto	O
done	O
;	O
}	O
