const	O
char	O
*	O
optstring	*(char)
=	O
"-BCHOQVstE:F:f:g:h:k:K:I:l:L:m:N:q:R:r:T:u:w:W:X:Y:a::x::y::S::"	*(char)
;	O
struct	O
option	struct(*(char),int,*(int),int)
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"output-format"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'T'	O
}	O
,	O
{	O
"display-type"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'T'	O
<<	O
8	int
}	O
,	O
{	O
"auto-abscissa"	*(char)
,	O
ARG_OPTIONAL	int
,	O
NULL	O
,	O
'a'	O
}	O
,	O
{	O
"clip-mode"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'K'	O
}	O
,	O
{	O
"fill-fraction"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'q'	O
}	O
,	O
{	O
"font-name"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'F'	O
}	O
,	O
{	O
"font-size"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'f'	O
}	O
,	O
{	O
"grid-style"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'g'	O
}	O
,	O
{	O
"height-of-plot"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"input-format"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'I'	O
}	O
,	O
{	O
"line-mode"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'm'	O
}	O
,	O
{	O
"line-width"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'W'	O
}	O
,	O
{	O
"right-shift"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"save-screen"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"symbol"	*(char)
,	O
ARG_OPTIONAL	int
,	O
NULL	O
,	O
'S'	O
}	O
,	O
{	O
"tick-size"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'k'	O
}	O
,	O
{	O
"toggle-auto-bump"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'B'	O
}	O
,	O
{	O
"toggle-axis-end"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'E'	O
}	O
,	O
{	O
"toggle-frame-on-top"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'H'	O
}	O
,	O
{	O
"toggle-log-axis"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"toggle-no-ticks"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'N'	O
}	O
,	O
{	O
"toggle-rotate-y-label"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'Q'	O
}	O
,	O
{	O
"toggle-round-to-next-tick"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'R'	O
}	O
,	O
{	O
"toggle-transpose-axes"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
't'	O
}	O
,	O
{	O
"toggle-use-color"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'C'	O
}	O
,	O
{	O
"top-label"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'L'	O
}	O
,	O
{	O
"upward-shift"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'u'	O
}	O
,	O
{	O
"width-of-plot"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'w'	O
}	O
,	O
{	O
"x-label"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'X'	O
}	O
,	O
{	O
"x-limits"	*(char)
,	O
ARG_OPTIONAL	int
,	O
NULL	O
,	O
'x'	O
}	O
,	O
{	O
"y-label"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'Y'	O
}	O
,	O
{	O
"y-limits"	*(char)
,	O
ARG_OPTIONAL	int
,	O
NULL	O
,	O
'y'	O
}	O
,	O
{	O
"bg-color"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'q'	O
<<	O
8	int
}	O
,	O
{	O
"bitmap-size"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'B'	O
<<	O
8	int
}	O
,	O
{	O
"blankout"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'b'	O
<<	O
8	int
}	O
,	O
{	O
"emulate-color"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'e'	O
<<	O
8	int
}	O
,	O
{	O
"frame-line-width"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'W'	O
<<	O
8	int
}	O
,	O
{	O
"frame-color"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'C'	O
<<	O
8	int
}	O
,	O
{	O
"max-line-length"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'M'	O
<<	O
8	int
}	O
,	O
{	O
"pen-colors"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'p'	O
<<	O
8	int
}	O
,	O
{	O
"reposition"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'R'	O
<<	O
8	int
}	O
,	O
{	O
"rotation"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'r'	O
<<	O
8	int
}	O
,	O
{	O
"symbol-font-name"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'G'	O
<<	O
8	int
}	O
,	O
{	O
"title-font-name"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'Z'	O
<<	O
8	int
}	O
,	O
{	O
"title-font-size"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'F'	O
<<	O
8	int
}	O
,	O
{	O
"page-size"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'P'	O
<<	O
8	int
}	O
,	O
{	O
"portable-output"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'O'	O
}	O
,	O
{	O
"help-fonts"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'f'	O
<<	O
8	int
}	O
,	O
{	O
"list-fonts"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'l'	O
<<	O
8	int
}	O
,	O
{	O
"version"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'V'	O
<<	O
8	int
}	O
,	O
{	O
"help"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'h'	O
<<	O
8	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
const	O
int	O
hidden_options	array(int)
[	O
]	O
=	O
{	O
(	O
int	O
)	O
(	O
'T'	O
<<	O
8	int
)	O
,	O
0	int
}	O
;	O
const	O
char	O
*	O
progname	*(char)
=	O
"graph"	*(char)
;	O
const	O
char	O
*	O
written	*(char)
=	O
"Written by Robert S. Maier."	*(char)
;	O
const	O
char	O
*	O
copyright	*(char)
=	O
"Copyright (C) 2009 Free Software Foundation, Inc."	*(char)
;	O
const	O
char	O
*	O
usage_appendage	*(char)
=	O
" [FILE]...\nWith no FILE, or when FILE is -, read standard input.\n"	*(char)
;	O
static	O
void	O
close_file	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
char	O
*	O
filename	*(char)
,	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
static	O
void	O
open_file_for_reading	(*(char),*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(void)
(	O
char	O
*	O
filename	*(char)
,	O
FILE	struct
*	O
*	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
static	O
bool	enum(int,int)
parse_pen_string	(*(char))->(enum(int,int))
(	O
const	O
char	O
*	O
pen_s	*(char)
)	O
;	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
int	O
option	struct(*(char),int,*(int),int)
;	O
int	O
opt_index	int
;	O
int	O
errcnt	int
=	O
0	int
;	O
int	O
matched	int
;	O
bool	enum(int,int)
using_getopt	enum(int,int)
=	O
true	int
;	O
bool	enum(int,int)
continue_parse	enum(int,int)
=	O
true	int
;	O
bool	enum(int,int)
show_version	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
show_usage	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
show_fonts	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
do_list_fonts	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
filter	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
new_symbol	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
new_symbol_size	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
new_symbol_font_name	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
new_linemode	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
new_plot_line_width	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
new_fill_fraction	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
new_use_color	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
first_file_of_graph	enum(int,int)
=	O
true	int
;	O
bool	enum(int,int)
first_graph_of_multigraph	enum(int,int)
=	O
true	int
;	O
FILE	struct
*	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
Reader	struct
*	O
reader	*(struct)
=	O
NULL	O
;	O
data_type	enum(int,int,int,int,int,int)
input_type	enum(int,int,int,int,int,int)
=	O
T_ASCII	int
;	O
bool	enum(int,int)
auto_bump	enum(int,int)
=	O
true	int
;	O
bool	enum(int,int)
auto_abscissa	enum(int,int)
=	O
false	int
;	O
double	O
x_start	double
=	O
0.	int
;	O
double	O
delta_x	double
=	O
1.	int
;	O
int	O
linemode_index	int
=	O
1	int
;	O
double	O
plot_line_width	double
=	O
-	O
0.001	int
;	O
int	O
symbol_index	int
=	O
0	int
;	O
double	O
symbol_size	double
=	O
.03	int
;	O
double	O
fill_fraction	double
=	O
-	O
1.0	int
;	O
bool	enum(int,int)
use_color	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
transpose_axes	enum(int,int)
=	O
false	int
;	O
Multigrapher	struct
*	O
multigrapher	*(struct)
=	O
NULL	O
;	O
const	O
char	O
*	O
output_format	*(char)
=	O
"meta"	*(char)
;	O
const	O
char	O
*	O
bg_color	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
bitmap_size	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
emulate_color	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
max_line_length	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
meta_portable	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
page_size	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
rotation_angle	*(char)
=	O
NULL	O
;	O
bool	enum(int,int)
save_screen	enum(int,int)
=	O
false	int
;	O
grid_type	enum(int,int,int,int,int)
grid_spec	enum(int,int,int,int,int)
=	O
AXES_AND_BOX	int
;	O
bool	enum(int,int)
no_rotate_y_label	enum(int,int)
=	O
false	int
;	O
const	O
char	O
*	O
frame_color	*(char)
=	O
"black"	*(char)
;	O
int	O
clip_mode	int
=	O
1	int
;	O
int	O
log_axis	int
=	O
0	int
;	O
int	O
round_to_next_tick	int
=	O
0	int
;	O
int	O
switch_axis_end	int
=	O
0	int
;	O
int	O
omit_ticks	int
=	O
0	int
;	O
double	O
frame_line_width	double
=	O
-	O
0.001	int
;	O
double	O
margin_below	double
=	O
.2	int
;	O
double	O
margin_left	double
=	O
.2	int
;	O
double	O
plot_height	double
=	O
.6	int
;	O
double	O
plot_width	double
=	O
.6	int
;	O
double	O
tick_size	double
=	O
.02	int
;	O
double	O
font_size	double
=	O
0.0525	int
;	O
double	O
title_font_size	double
=	O
0.07	int
;	O
double	O
blankout_fraction	double
=	O
1.3	int
;	O
const	O
char	O
*	O
font_name	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
title_font_name	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
symbol_font_name	*(char)
=	O
"ZapfDingbats"	*(char)
;	O
const	O
char	O
*	O
x_label	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
y_label	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
top_label	*(char)
=	O
NULL	O
;	O
double	O
min_x	*(double)
=	O
0.0	int
,	O
min_y	*(double)
=	O
0.0	int
,	O
max_x	*(double)
=	O
0.0	int
,	O
max_y	*(double)
=	O
0.0	int
;	O
double	O
spacing_x	double
=	O
0.0	int
,	O
spacing_y	double
=	O
0.0	int
;	O
bool	enum(int,int)
spec_min_x	enum(int,int)
=	O
false	int
,	O
spec_min_y	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
spec_max_x	enum(int,int)
=	O
false	int
,	O
spec_max_y	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
spec_spacing_x	enum(int,int)
=	O
false	int
,	O
spec_spacing_y	enum(int,int)
=	O
false	int
;	O
double	O
local_x_start	double
,	O
local_delta_x	double
;	O
int	O
local_grid_style	int
;	O
int	O
local_symbol_index	int
;	O
int	O
local_clip_mode	int
;	O
double	O
local_symbol_size	double
,	O
local_font_size	double
,	O
local_title_font_size	double
;	O
double	O
local_frame_line_width	double
,	O
local_plot_line_width	double
;	O
double	O
local_min_x	double
,	O
local_min_y	double
;	O
double	O
local_max_x	double
,	O
local_max_y	double
;	O
double	O
local_spacing_x	double
,	O
local_spacing_y	double
;	O
double	O
local_fill_fraction	double
;	O
int	O
final_log_axis	int
=	O
0	int
;	O
int	O
final_round_to_next_tick	int
=	O
0	int
;	O
double	O
final_min_x	double
=	O
0.0	int
,	O
final_max_x	double
=	O
0.0	int
,	O
final_spacing_x	double
=	O
0.0	int
;	O
double	O
final_min_y	double
=	O
0.0	int
,	O
final_max_y	double
=	O
0.0	int
,	O
final_spacing_y	double
=	O
0.0	int
;	O
bool	enum(int,int)
final_spec_min_x	enum(int,int)
=	O
false	int
,	O
final_spec_min_y	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
final_spec_max_x	enum(int,int)
=	O
false	int
,	O
final_spec_max_y	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
final_spec_spacing_x	enum(int,int)
=	O
false	int
,	O
final_spec_spacing_y	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
final_transpose_axes	enum(int,int)
=	O
false	int
;	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
p	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
;	O
int	O
points_length	int
=	O
1024	int
;	O
int	O
no_of_points	*(int)
=	O
0	int
;	O
double	O
reposition_trans_x	double
=	O
0.0	int
,	O
reposition_trans_y	double
=	O
0.0	int
;	O
double	O
reposition_scale	double
=	O
1.0	int
;	O
double	O
old_reposition_trans_x	double
,	O
old_reposition_trans_y	double
;	O
double	O
old_reposition_scale	double
;	O
bool	enum(int,int)
frame_on_top	enum(int,int)
=	O
false	int
;	O
while	O
(	O
continue_parse	enum(int,int)
)	O
{	O
if	O
(	O
using_getopt	enum(int,int)
)	O
{	O
option	struct(*(char),int,*(int),int)
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
optstring	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
&	O
opt_index	int
)	O
;	O
if	O
(	O
option	struct(*(char),int,*(int),int)
==	O
EOF	O
)	O
{	O
using_getopt	enum(int,int)
=	O
false	int
;	O
continue	O
;	O
}	O
if	O
(	O
option	struct(*(char),int,*(int),int)
==	O
1	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
open_file_for_reading	(*(char),*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(void)
(	O
optarg	*(char)
,	O
&	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
optind	int
>=	O
argc	int
)	O
{	O
if	O
(	O
first_graph_of_multigraph	enum(int,int)
&&	O
first_file_of_graph	enum(int,int)
)	O
{	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
option	struct(*(char),int,*(int),int)
=	O
1	int
;	O
}	O
else	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
open_file_for_reading	(*(char),*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(void)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
&	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
optarg	*(char)
=	O
argv	*(*(char))
[	O
optind	int
]	O
;	O
optind	int
++	O
;	O
option	struct(*(char),int,*(int),int)
=	O
1	int
;	O
}	O
}	O
switch	O
(	O
option	struct(*(char),int,*(int),int)
)	O
{	O
case	O
's'	O
:	O
save_screen	enum(int,int)
=	O
true	int
;	O
break	O
;	O
case	O
't'	O
:	O
transpose_axes	enum(int,int)
=	O
(	O
transpose_axes	enum(int,int)
==	O
true	int
?	O
false	int
:	O
true	int
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
auto_bump	enum(int,int)
=	O
(	O
auto_bump	enum(int,int)
==	O
true	int
?	O
false	int
:	O
true	int
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
new_use_color	enum(int,int)
=	O
true	int
;	O
use_color	enum(int,int)
=	O
(	O
use_color	enum(int,int)
==	O
true	int
?	O
false	int
:	O
true	int
)	O
;	O
break	O
;	O
case	O
'H'	O
:	O
frame_on_top	enum(int,int)
=	O
(	O
frame_on_top	enum(int,int)
==	O
true	int
?	O
false	int
:	O
true	int
)	O
;	O
break	O
;	O
case	O
'O'	O
:	O
meta_portable	*(char)
=	O
"yes"	*(char)
;	O
break	O
;	O
case	O
'e'	O
<<	O
8	int
:	O
emulate_color	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'V'	O
<<	O
8	int
:	O
show_version	enum(int,int)
=	O
true	int
;	O
continue_parse	enum(int,int)
=	O
false	int
;	O
break	O
;	O
case	O
'h'	O
<<	O
8	int
:	O
show_usage	enum(int,int)
=	O
true	int
;	O
continue_parse	enum(int,int)
=	O
false	int
;	O
break	O
;	O
case	O
'f'	O
<<	O
8	int
:	O
show_fonts	enum(int,int)
=	O
true	int
;	O
continue_parse	enum(int,int)
=	O
false	int
;	O
break	O
;	O
case	O
'l'	O
<<	O
8	int
:	O
do_list_fonts	enum(int,int)
=	O
true	int
;	O
continue_parse	enum(int,int)
=	O
false	int
;	O
break	O
;	O
case	O
'Q'	O
:	O
no_rotate_y_label	enum(int,int)
=	O
(	O
no_rotate_y_label	enum(int,int)
==	O
true	int
?	O
false	int
:	O
true	int
)	O
;	O
break	O
;	O
case	O
'I'	O
:	O
switch	O
(	O
*	O
optarg	*(char)
)	O
{	O
case	O
'a'	O
:	O
case	O
'A'	O
:	O
input_type	enum(int,int,int,int,int,int)
=	O
T_ASCII	int
;	O
break	O
;	O
case	O
'f'	O
:	O
case	O
'F'	O
:	O
input_type	enum(int,int,int,int,int,int)
=	O
T_SINGLE	int
;	O
break	O
;	O
case	O
'd'	O
:	O
case	O
'D'	O
:	O
input_type	enum(int,int,int,int,int,int)
=	O
T_DOUBLE	int
;	O
break	O
;	O
case	O
'i'	O
:	O
case	O
'I'	O
:	O
input_type	enum(int,int,int,int,int,int)
=	O
T_INTEGER	int
;	O
break	O
;	O
case	O
'e'	O
:	O
case	O
'E'	O
:	O
input_type	enum(int,int,int,int,int,int)
=	O
T_ASCII_ERRORBAR	int
;	O
break	O
;	O
case	O
'g'	O
:	O
case	O
'G'	O
:	O
input_type	enum(int,int,int,int,int,int)
=	O
T_GNUPLOT	int
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: `%s' is an unrecognized data option\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
}	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%lf"	*(char)
,	O
&	O
local_font_size	double
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the font size should be a number, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
}	O
else	O
{	O
if	O
(	O
local_font_size	double
>=	O
1.0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the too-large font size `%f' is disregarded (it should be less than 1.0)\n"	*(char)
,	O
progname	*(char)
,	O
local_font_size	double
)	O
;	O
else	O
if	O
(	O
local_font_size	double
<	O
0.0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the negative font size `%f' is disregarded\n"	*(char)
,	O
progname	*(char)
,	O
local_font_size	double
)	O
;	O
else	O
font_size	double
=	O
local_font_size	double
;	O
}	O
break	O
;	O
case	O
'g'	O
:	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%d"	*(char)
,	O
&	O
local_grid_style	int
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the grid style should be a (small) integer, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
break	O
;	O
}	O
switch	O
(	O
local_grid_style	int
)	O
{	O
case	O
0	int
:	O
grid_spec	enum(int,int,int,int,int)
=	O
NO_AXES	int
;	O
break	O
;	O
case	O
1	int
:	O
grid_spec	enum(int,int,int,int,int)
=	O
AXES	int
;	O
break	O
;	O
case	O
2	int
:	O
grid_spec	enum(int,int,int,int,int)
=	O
AXES_AND_BOX	int
;	O
break	O
;	O
case	O
3	int
:	O
grid_spec	enum(int,int,int,int,int)
=	O
AXES_AND_BOX_AND_GRID	int
;	O
break	O
;	O
case	O
4	int
:	O
grid_spec	enum(int,int,int,int,int)
=	O
AXES_AT_ORIGIN	int
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the grid style number `%s' is out of bounds\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
}	O
break	O
;	O
case	O
'h'	O
:	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%lf"	*(char)
,	O
&	O
plot_height	double
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the plot height should be a number, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
}	O
break	O
;	O
case	O
'K'	O
:	O
if	O
(	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%d"	*(char)
,	O
&	O
local_clip_mode	int
)	O
<=	O
0	int
)	O
||	O
local_clip_mode	int
<	O
0	int
||	O
local_clip_mode	int
>	O
2	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the bad clip mode `%s' is disregarded (it should be 0, 1, or 2)\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
else	O
clip_mode	int
=	O
local_clip_mode	int
;	O
break	O
;	O
case	O
'l'	O
:	O
switch	O
(	O
*	O
optarg	*(char)
)	O
{	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
log_axis	int
^=	O
X_AXIS	int
;	O
break	O
;	O
case	O
'y'	O
:	O
case	O
'Y'	O
:	O
log_axis	int
^=	O
Y_AXIS	int
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the unrecognized axis specification `%s' is disregarded\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'N'	O
:	O
switch	O
(	O
*	O
optarg	*(char)
)	O
{	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
omit_ticks	int
^=	O
X_AXIS	int
;	O
break	O
;	O
case	O
'y'	O
:	O
case	O
'Y'	O
:	O
omit_ticks	int
^=	O
Y_AXIS	int
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the unrecognized axis specification `%s' is disregarded\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'm'	O
:	O
new_linemode	enum(int,int)
=	O
true	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%d"	*(char)
,	O
&	O
linemode_index	int
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the linemode should be a (small) integer, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
}	O
break	O
;	O
case	O
'q'	O
:	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%lf"	*(char)
,	O
&	O
local_fill_fraction	double
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the fill fraction should be a number, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
}	O
else	O
{	O
if	O
(	O
local_fill_fraction	double
>	O
1.0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the region fill fraction `%f' was disregarded (it should be less than or equal to 1.0)\n"	*(char)
,	O
progname	*(char)
,	O
local_fill_fraction	double
)	O
;	O
else	O
{	O
fill_fraction	double
=	O
local_fill_fraction	double
;	O
new_fill_fraction	enum(int,int)
=	O
true	int
;	O
}	O
}	O
break	O
;	O
case	O
'r'	O
:	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%lf"	*(char)
,	O
&	O
margin_left	double
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the rightward displacement for the plot should be a number, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
}	O
break	O
;	O
case	O
'u'	O
:	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%lf"	*(char)
,	O
&	O
margin_below	double
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the upward displacement for the plot should be a number, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
}	O
break	O
;	O
case	O
'w'	O
:	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%lf"	*(char)
,	O
&	O
plot_width	double
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the plot width should be a number, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
}	O
break	O
;	O
case	O
'T'	O
:	O
case	O
'T'	O
<<	O
8	int
:	O
output_format	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
font_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'r'	O
<<	O
8	int
:	O
rotation_angle	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'Z'	O
<<	O
8	int
:	O
title_font_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'G'	O
<<	O
8	int
:	O
symbol_font_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
new_symbol_font_name	enum(int,int)
=	O
true	int
;	O
break	O
;	O
case	O
'R'	O
:	O
switch	O
(	O
*	O
optarg	*(char)
)	O
{	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
round_to_next_tick	int
^=	O
X_AXIS	int
;	O
break	O
;	O
case	O
'y'	O
:	O
case	O
'Y'	O
:	O
round_to_next_tick	int
^=	O
Y_AXIS	int
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the unrecognized axis specification `%s' is disregarded\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'L'	O
:	O
top_label	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%lf"	*(char)
,	O
&	O
tick_size	double
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the tick size should be a number, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
}	O
break	O
;	O
case	O
'W'	O
:	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%lf"	*(char)
,	O
&	O
local_plot_line_width	double
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the line thickness for the plot should be a number, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
}	O
if	O
(	O
local_plot_line_width	double
<	O
0.0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the negative plot line thickness `%f' is disregarded\n"	*(char)
,	O
progname	*(char)
,	O
local_plot_line_width	double
)	O
;	O
else	O
{	O
plot_line_width	double
=	O
local_plot_line_width	double
;	O
new_plot_line_width	enum(int,int)
=	O
true	int
;	O
}	O
break	O
;	O
case	O
'X'	O
:	O
x_label	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'Y'	O
:	O
y_label	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
switch	O
(	O
*	O
optarg	*(char)
)	O
{	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
switch_axis_end	int
^=	O
Y_AXIS	int
;	O
break	O
;	O
case	O
'y'	O
:	O
case	O
'Y'	O
:	O
switch_axis_end	int
^=	O
X_AXIS	int
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the unrecognized axis specification `%s' is disregarded\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'b'	O
<<	O
8	int
:	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%lf"	*(char)
,	O
&	O
blankout_fraction	double
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the fractional blankout should be a number, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
}	O
break	O
;	O
case	O
'B'	O
<<	O
8	int
:	O
bitmap_size	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'F'	O
<<	O
8	int
:	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%lf"	*(char)
,	O
&	O
local_title_font_size	double
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the font size for the title should be a number, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
}	O
else	O
if	O
(	O
local_title_font_size	double
>=	O
1.0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the too-large title font size `%f' is disregarded (it should be less than 1.0)\n"	*(char)
,	O
progname	*(char)
,	O
local_title_font_size	double
)	O
;	O
else	O
if	O
(	O
local_title_font_size	double
<	O
0.0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the negative title font size `%f' is disregarded\n"	*(char)
,	O
progname	*(char)
,	O
local_title_font_size	double
)	O
;	O
if	O
(	O
local_title_font_size	double
==	O
0.0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the request for a zero title font size is disregarded\n"	*(char)
,	O
progname	*(char)
)	O
;	O
else	O
title_font_size	double
=	O
local_title_font_size	double
;	O
break	O
;	O
case	O
'W'	O
<<	O
8	int
:	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%lf"	*(char)
,	O
&	O
local_frame_line_width	double
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the line thickness for the frame should be a number, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
}	O
if	O
(	O
local_frame_line_width	double
<	O
0.0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the negative frame line thickness `%f' is disregarded\n"	*(char)
,	O
progname	*(char)
,	O
local_frame_line_width	double
)	O
;	O
else	O
frame_line_width	double
=	O
local_frame_line_width	double
;	O
break	O
;	O
case	O
'M'	O
<<	O
8	int
:	O
max_line_length	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'P'	O
<<	O
8	int
:	O
page_size	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'p'	O
<<	O
8	int
:	O
if	O
(	O
parse_pen_string	(*(char))->(enum(int,int))
(	O
optarg	*(char)
)	O
==	O
false	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the unparseable pen string `%s' is disregarded\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
'q'	O
<<	O
8	int
:	O
bg_color	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'C'	O
<<	O
8	int
:	O
frame_color	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
auto_abscissa	enum(int,int)
=	O
true	int
;	O
if	O
(	O
optind	int
>=	O
argc	int
)	O
break	O
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"%lf"	*(char)
,	O
&	O
local_delta_x	double
)	O
<=	O
0	int
)	O
break	O
;	O
optind	int
++	O
;	O
if	O
(	O
local_delta_x	double
==	O
0.0	int
)	O
{	O
auto_abscissa	enum(int,int)
=	O
false	int
;	O
break	O
;	O
}	O
delta_x	double
=	O
local_delta_x	double
;	O
if	O
(	O
optind	int
>=	O
argc	int
)	O
break	O
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"%lf"	*(char)
,	O
&	O
local_x_start	double
)	O
<=	O
0	int
)	O
break	O
;	O
x_start	double
=	O
local_x_start	double
;	O
optind	int
++	O
;	O
break	O
;	O
case	O
'x'	O
:	O
matched	int
=	O
0	int
;	O
if	O
(	O
optind	int
>=	O
argc	int
||	O
(	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"-"	*(char)
)	O
!=	O
0	int
)	O
&&	O
(	O
matched	int
=	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"%lf"	*(char)
,	O
&	O
local_min_x	double
)	O
)	O
<=	O
0	int
)	O
)	O
{	O
spec_min_x	enum(int,int)
=	O
spec_max_x	enum(int,int)
=	O
spec_spacing_x	enum(int,int)
=	O
false	int
;	O
break	O
;	O
}	O
if	O
(	O
matched	int
>	O
0	int
)	O
{	O
spec_min_x	enum(int,int)
=	O
true	int
;	O
min_x	*(double)
=	O
local_min_x	double
;	O
}	O
else	O
spec_min_x	enum(int,int)
=	O
false	int
;	O
optind	int
++	O
;	O
matched	int
=	O
0	int
;	O
if	O
(	O
optind	int
>=	O
argc	int
||	O
(	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"-"	*(char)
)	O
!=	O
0	int
)	O
&&	O
(	O
matched	int
=	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"%lf"	*(char)
,	O
&	O
local_max_x	double
)	O
)	O
<=	O
0	int
)	O
)	O
{	O
spec_max_x	enum(int,int)
=	O
spec_spacing_x	enum(int,int)
=	O
false	int
;	O
break	O
;	O
}	O
if	O
(	O
matched	int
>	O
0	int
)	O
{	O
spec_max_x	enum(int,int)
=	O
true	int
;	O
max_x	*(double)
=	O
local_max_x	double
;	O
}	O
else	O
spec_max_x	enum(int,int)
=	O
false	int
;	O
optind	int
++	O
;	O
matched	int
=	O
0	int
;	O
if	O
(	O
optind	int
>=	O
argc	int
||	O
(	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"-"	*(char)
)	O
!=	O
0	int
)	O
&&	O
(	O
matched	int
=	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"%lf"	*(char)
,	O
&	O
local_spacing_x	double
)	O
)	O
<=	O
0	int
)	O
)	O
{	O
spec_spacing_x	enum(int,int)
=	O
false	int
;	O
break	O
;	O
}	O
if	O
(	O
matched	int
>	O
0	int
)	O
{	O
spec_spacing_x	enum(int,int)
=	O
true	int
;	O
spacing_x	double
=	O
local_spacing_x	double
;	O
}	O
else	O
spec_spacing_x	enum(int,int)
=	O
false	int
;	O
optind	int
++	O
;	O
break	O
;	O
case	O
'y'	O
:	O
matched	int
=	O
0	int
;	O
if	O
(	O
optind	int
>=	O
argc	int
||	O
(	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"-"	*(char)
)	O
!=	O
0	int
)	O
&&	O
(	O
matched	int
=	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"%lf"	*(char)
,	O
&	O
local_min_y	double
)	O
)	O
<=	O
0	int
)	O
)	O
{	O
spec_min_y	enum(int,int)
=	O
spec_max_y	enum(int,int)
=	O
spec_spacing_y	enum(int,int)
=	O
false	int
;	O
break	O
;	O
}	O
if	O
(	O
matched	int
>	O
0	int
)	O
{	O
spec_min_y	enum(int,int)
=	O
true	int
;	O
min_y	*(double)
=	O
local_min_y	double
;	O
}	O
else	O
spec_min_y	enum(int,int)
=	O
false	int
;	O
optind	int
++	O
;	O
matched	int
=	O
0	int
;	O
if	O
(	O
optind	int
>=	O
argc	int
||	O
(	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"-"	*(char)
)	O
!=	O
0	int
)	O
&&	O
(	O
matched	int
=	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"%lf"	*(char)
,	O
&	O
local_max_y	double
)	O
)	O
<=	O
0	int
)	O
)	O
{	O
spec_max_y	enum(int,int)
=	O
spec_spacing_y	enum(int,int)
=	O
false	int
;	O
break	O
;	O
}	O
if	O
(	O
matched	int
>	O
0	int
)	O
{	O
spec_max_y	enum(int,int)
=	O
true	int
;	O
max_y	*(double)
=	O
local_max_y	double
;	O
}	O
else	O
spec_max_y	enum(int,int)
=	O
false	int
;	O
optind	int
++	O
;	O
matched	int
=	O
0	int
;	O
if	O
(	O
optind	int
>=	O
argc	int
||	O
(	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"-"	*(char)
)	O
!=	O
0	int
)	O
&&	O
(	O
matched	int
=	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"%lf"	*(char)
,	O
&	O
local_spacing_y	double
)	O
)	O
<=	O
0	int
)	O
)	O
{	O
spec_spacing_y	enum(int,int)
=	O
false	int
;	O
break	O
;	O
}	O
if	O
(	O
matched	int
>	O
0	int
)	O
{	O
spec_spacing_y	enum(int,int)
=	O
true	int
;	O
spacing_y	double
=	O
local_spacing_y	double
;	O
}	O
else	O
spec_spacing_y	enum(int,int)
=	O
false	int
;	O
optind	int
++	O
;	O
break	O
;	O
case	O
'S'	O
:	O
new_symbol	enum(int,int)
=	O
true	int
;	O
symbol_index	int
=	O
1	int
;	O
if	O
(	O
optind	int
>=	O
argc	int
)	O
break	O
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"%d"	*(char)
,	O
&	O
local_symbol_index	int
)	O
<=	O
0	int
)	O
break	O
;	O
if	O
(	O
local_symbol_index	int
<	O
0	int
||	O
local_symbol_index	int
>	O
255	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the symbol type `%d' is disregarded (it should be in the range 0..255)\n"	*(char)
,	O
progname	*(char)
,	O
local_symbol_index	int
)	O
;	O
else	O
symbol_index	int
=	O
local_symbol_index	int
;	O
optind	int
++	O
;	O
if	O
(	O
optind	int
>=	O
argc	int
)	O
break	O
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"%lf"	*(char)
,	O
&	O
local_symbol_size	double
)	O
<=	O
0	int
)	O
break	O
;	O
if	O
(	O
local_symbol_size	double
<	O
0.0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the negative symbol size `%f' is disregarded\n"	*(char)
,	O
progname	*(char)
,	O
local_symbol_size	double
)	O
;	O
else	O
if	O
(	O
local_symbol_size	double
==	O
0.0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the request for a zero symbol size is disregarded\n"	*(char)
,	O
progname	*(char)
)	O
;	O
else	O
{	O
symbol_size	double
=	O
local_symbol_size	double
;	O
new_symbol_size	enum(int,int)
=	O
true	int
;	O
}	O
optind	int
++	O
;	O
break	O
;	O
case	O
'R'	O
<<	O
8	int
:	O
old_reposition_trans_x	double
=	O
reposition_trans_x	double
;	O
old_reposition_trans_y	double
=	O
reposition_trans_y	double
;	O
old_reposition_scale	double
=	O
reposition_scale	double
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%lf"	*(char)
,	O
&	O
reposition_trans_x	double
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the x repositioning should be a number, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
optind	int
>=	O
argc	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: one or more arguments to the --reposition option were missing\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"%lf"	*(char)
,	O
&	O
reposition_trans_y	double
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the y repositioning should be a number, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
argv	*(*(char))
[	O
optind	int
]	O
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
optind	int
++	O
;	O
if	O
(	O
optind	int
>=	O
argc	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: one or more arguments to the --reposition option were missing\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"%lf"	*(char)
,	O
&	O
reposition_scale	double
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the reposition scale factor should be a number, but it was `%s'\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
reposition_scale	double
==	O
0.0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the reposition scale factor should not be zero\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
optind	int
++	O
;	O
if	O
(	O
!	O
first_file_of_graph	enum(int,int)
)	O
{	O
if	O
(	O
!	O
filter	enum(int,int)
)	O
{	O
array_bounds	(*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))),int,enum(int,int),int,*(double),*(double),*(double),*(double),enum(int,int),enum(int,int),enum(int,int),enum(int,int))->(void)
(	O
p	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
,	O
no_of_points	*(int)
,	O
final_transpose_axes	enum(int,int)
,	O
clip_mode	int
,	O
&	O
final_min_x	double
,	O
&	O
final_min_y	double
,	O
&	O
final_max_x	double
,	O
&	O
final_max_y	double
,	O
final_spec_min_x	enum(int,int)
,	O
final_spec_min_y	enum(int,int)
,	O
final_spec_max_x	enum(int,int)
,	O
final_spec_max_y	enum(int,int)
)	O
;	O
if	O
(	O
first_graph_of_multigraph	enum(int,int)
)	O
{	O
if	O
(	O
(	O
multigrapher	*(struct)
=	O
new_multigrapher	(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),enum(int,int))->(*(struct))
(	O
output_format	*(char)
,	O
bg_color	*(char)
,	O
bitmap_size	*(char)
,	O
emulate_color	*(char)
,	O
max_line_length	*(char)
,	O
meta_portable	*(char)
,	O
page_size	*(char)
,	O
rotation_angle	*(char)
,	O
save_screen	enum(int,int)
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the graphing device could not be opened\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
begin_graph	(*(struct),double,double,double)->(void)
(	O
multigrapher	*(struct)
,	O
old_reposition_scale	double
,	O
old_reposition_trans_x	double
,	O
old_reposition_trans_y	double
)	O
;	O
if	O
(	O
(	O
title_font_name	*(char)
==	O
NULL	O
)	O
&&	O
(	O
font_name	*(char)
!=	O
NULL	O
)	O
)	O
title_font_name	*(char)
=	O
font_name	*(char)
;	O
set_graph_parameters	(*(struct),double,*(char),*(char),*(char),double,double,enum(int,int,int,int,int),double,double,double,double,double,double,enum(int,int),enum(int,int),double,double,double,double,*(char),double,*(char),*(char),double,*(char),enum(int,int),int,int,int,int,int,double,enum(int,int))->(void)
(	O
multigrapher	*(struct)
,	O
frame_line_width	double
,	O
frame_color	*(char)
,	O
top_label	*(char)
,	O
title_font_name	*(char)
,	O
title_font_size	double
,	O
tick_size	double
,	O
grid_spec	enum(int,int,int,int,int)
,	O
final_min_x	double
,	O
final_max_x	double
,	O
final_spacing_x	double
,	O
final_min_y	double
,	O
final_max_y	double
,	O
final_spacing_y	double
,	O
final_spec_spacing_x	enum(int,int)
,	O
final_spec_spacing_y	enum(int,int)
,	O
plot_width	double
,	O
plot_height	double
,	O
margin_below	double
,	O
margin_left	double
,	O
font_name	*(char)
,	O
font_size	double
,	O
x_label	*(char)
,	O
font_name	*(char)
,	O
font_size	double
,	O
y_label	*(char)
,	O
no_rotate_y_label	enum(int,int)
,	O
final_log_axis	int
,	O
final_round_to_next_tick	int
,	O
switch_axis_end	int
,	O
omit_ticks	int
,	O
clip_mode	int
,	O
blankout_fraction	double
,	O
final_transpose_axes	enum(int,int)
)	O
;	O
draw_frame_of_graph	(*(struct),enum(int,int))->(void)
(	O
multigrapher	*(struct)
,	O
(	O
first_graph_of_multigraph	enum(int,int)
?	O
false	int
:	O
true	int
)	O
)	O
;	O
plot_point_array	(*(struct),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))),int)->(void)
(	O
multigrapher	*(struct)
,	O
p	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
,	O
no_of_points	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
no_of_points	*(int)
=	O
0	int
;	O
first_file_of_graph	enum(int,int)
=	O
false	int
;	O
}	O
if	O
(	O
frame_on_top	enum(int,int)
)	O
{	O
end_polyline_and_flush	(*(struct))->(void)
(	O
multigrapher	*(struct)
)	O
;	O
draw_frame_of_graph	(*(struct),enum(int,int))->(void)
(	O
multigrapher	*(struct)
,	O
false	int
)	O
;	O
}	O
end_graph	(*(struct))->(void)
(	O
multigrapher	*(struct)
)	O
;	O
first_graph_of_multigraph	enum(int,int)
=	O
false	int
;	O
first_file_of_graph	enum(int,int)
=	O
true	int
;	O
}	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
first_file_of_graph	enum(int,int)
)	O
{	O
if	O
(	O
log_axis	int
&	O
X_AXIS	int
)	O
{	O
if	O
(	O
spec_min_x	enum(int,int)
)	O
{	O
if	O
(	O
min_x	*(double)
>	O
0.0	int
)	O
min_x	*(double)
=	O
log10	(double)->(double)
(	O
min_x	*(double)
)	O
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the limit %g on a logarithmic axis is nonpositive\n"	*(char)
,	O
progname	*(char)
,	O
min_x	*(double)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
if	O
(	O
spec_max_x	enum(int,int)
)	O
{	O
if	O
(	O
max_x	*(double)
>	O
0.0	int
)	O
max_x	*(double)
=	O
log10	(double)->(double)
(	O
max_x	*(double)
)	O
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the limit %g on a logarithmic axis is nonpositive\n"	*(char)
,	O
progname	*(char)
,	O
max_x	*(double)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
}	O
if	O
(	O
log_axis	int
&	O
Y_AXIS	int
)	O
{	O
if	O
(	O
spec_min_y	enum(int,int)
)	O
{	O
if	O
(	O
min_y	*(double)
>	O
0.0	int
)	O
min_y	*(double)
=	O
log10	(double)->(double)
(	O
min_y	*(double)
)	O
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the limit %g on a logarithmic axis is nonpositive\n"	*(char)
,	O
progname	*(char)
,	O
min_y	*(double)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
if	O
(	O
spec_max_y	enum(int,int)
)	O
{	O
if	O
(	O
max_y	*(double)
>	O
0.0	int
)	O
max_y	*(double)
=	O
log10	(double)->(double)
(	O
max_y	*(double)
)	O
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the limit %g on a logarithmic axis is nonpositive\n"	*(char)
,	O
progname	*(char)
,	O
max_y	*(double)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
}	O
final_log_axis	int
=	O
log_axis	int
;	O
final_round_to_next_tick	int
=	O
round_to_next_tick	int
;	O
final_transpose_axes	enum(int,int)
=	O
transpose_axes	enum(int,int)
;	O
final_min_x	double
=	O
min_x	*(double)
;	O
final_max_x	double
=	O
max_x	*(double)
;	O
final_spacing_x	double
=	O
spacing_x	double
;	O
final_spec_min_x	enum(int,int)
=	O
spec_min_x	enum(int,int)
;	O
final_spec_max_x	enum(int,int)
=	O
spec_max_x	enum(int,int)
;	O
final_spec_spacing_x	enum(int,int)
=	O
spec_spacing_x	enum(int,int)
;	O
final_min_y	double
=	O
min_y	*(double)
;	O
final_max_y	double
=	O
max_y	*(double)
;	O
final_spec_min_y	enum(int,int)
=	O
spec_min_y	enum(int,int)
;	O
final_spec_max_y	enum(int,int)
=	O
spec_max_y	enum(int,int)
;	O
final_spacing_y	double
=	O
spacing_y	double
;	O
final_spec_spacing_y	enum(int,int)
=	O
spec_spacing_y	enum(int,int)
;	O
if	O
(	O
!	O
final_spec_min_x	enum(int,int)
&&	O
!	O
final_spec_max_x	enum(int,int)
)	O
final_round_to_next_tick	int
|=	O
X_AXIS	int
;	O
if	O
(	O
!	O
final_spec_min_y	enum(int,int)
&&	O
!	O
final_spec_max_y	enum(int,int)
)	O
final_round_to_next_tick	int
|=	O
Y_AXIS	int
;	O
filter	enum(int,int)
=	O
(	O
(	O
final_spec_min_x	enum(int,int)
&&	O
final_spec_max_x	enum(int,int)
&&	O
final_spec_min_y	enum(int,int)
&&	O
final_spec_max_y	enum(int,int)
)	O
?	O
true	int
:	O
false	int
)	O
;	O
}	O
if	O
(	O
filter	enum(int,int)
)	O
{	O
if	O
(	O
first_file_of_graph	enum(int,int)
)	O
{	O
if	O
(	O
first_graph_of_multigraph	enum(int,int)
)	O
{	O
if	O
(	O
(	O
multigrapher	*(struct)
=	O
new_multigrapher	(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),enum(int,int))->(*(struct))
(	O
output_format	*(char)
,	O
bg_color	*(char)
,	O
bitmap_size	*(char)
,	O
emulate_color	*(char)
,	O
max_line_length	*(char)
,	O
meta_portable	*(char)
,	O
page_size	*(char)
,	O
rotation_angle	*(char)
,	O
save_screen	enum(int,int)
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the graphing device could not be opened\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
begin_graph	(*(struct),double,double,double)->(void)
(	O
multigrapher	*(struct)
,	O
reposition_scale	double
,	O
reposition_trans_x	double
,	O
reposition_trans_y	double
)	O
;	O
if	O
(	O
(	O
title_font_name	*(char)
==	O
NULL	O
)	O
&&	O
(	O
font_name	*(char)
!=	O
NULL	O
)	O
)	O
title_font_name	*(char)
=	O
font_name	*(char)
;	O
set_graph_parameters	(*(struct),double,*(char),*(char),*(char),double,double,enum(int,int,int,int,int),double,double,double,double,double,double,enum(int,int),enum(int,int),double,double,double,double,*(char),double,*(char),*(char),double,*(char),enum(int,int),int,int,int,int,int,double,enum(int,int))->(void)
(	O
multigrapher	*(struct)
,	O
frame_line_width	double
,	O
frame_color	*(char)
,	O
top_label	*(char)
,	O
title_font_name	*(char)
,	O
title_font_size	double
,	O
tick_size	double
,	O
grid_spec	enum(int,int,int,int,int)
,	O
final_min_x	double
,	O
final_max_x	double
,	O
final_spacing_x	double
,	O
final_min_y	double
,	O
final_max_y	double
,	O
final_spacing_y	double
,	O
final_spec_spacing_x	enum(int,int)
,	O
final_spec_spacing_y	enum(int,int)
,	O
plot_width	double
,	O
plot_height	double
,	O
margin_below	double
,	O
margin_left	double
,	O
font_name	*(char)
,	O
font_size	double
,	O
x_label	*(char)
,	O
font_name	*(char)
,	O
font_size	double
,	O
y_label	*(char)
,	O
no_rotate_y_label	enum(int,int)
,	O
final_log_axis	int
,	O
final_round_to_next_tick	int
,	O
switch_axis_end	int
,	O
omit_ticks	int
,	O
clip_mode	int
,	O
blankout_fraction	double
,	O
final_transpose_axes	enum(int,int)
)	O
;	O
draw_frame_of_graph	(*(struct),enum(int,int))->(void)
(	O
multigrapher	*(struct)
,	O
first_graph_of_multigraph	enum(int,int)
?	O
false	int
:	O
true	int
)	O
;	O
reader	*(struct)
=	O
new_reader	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,enum(int,int),int,double,*(char),int,double,double,enum(int,int))->(*(struct))
(	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
input_type	enum(int,int,int,int,int,int)
,	O
auto_abscissa	enum(int,int)
,	O
delta_x	double
,	O
x_start	double
,	O
final_transpose_axes	enum(int,int)
,	O
final_log_axis	int
,	O
auto_bump	enum(int,int)
,	O
symbol_index	int
,	O
symbol_size	double
,	O
symbol_font_name	*(char)
,	O
linemode_index	int
,	O
plot_line_width	double
,	O
fill_fraction	double
,	O
use_color	enum(int,int)
)	O
;	O
new_symbol	enum(int,int)
=	O
new_symbol_size	enum(int,int)
=	O
new_symbol_font_name	enum(int,int)
=	O
false	int
;	O
new_linemode	enum(int,int)
=	O
new_plot_line_width	enum(int,int)
=	O
false	int
;	O
new_fill_fraction	enum(int,int)
=	O
new_use_color	enum(int,int)
=	O
false	int
;	O
}	O
else	O
{	O
alter_reader_parameters	(*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,int,double,*(char),int,double,double,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int))->(void)
(	O
reader	*(struct)
,	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
input_type	enum(int,int,int,int,int,int)
,	O
auto_abscissa	enum(int,int)
,	O
delta_x	double
,	O
x_start	double
,	O
symbol_index	int
,	O
symbol_size	double
,	O
symbol_font_name	*(char)
,	O
linemode_index	int
,	O
plot_line_width	double
,	O
fill_fraction	double
,	O
use_color	enum(int,int)
,	O
new_symbol	enum(int,int)
,	O
new_symbol_size	enum(int,int)
,	O
new_symbol_font_name	enum(int,int)
,	O
new_linemode	enum(int,int)
,	O
new_plot_line_width	enum(int,int)
,	O
new_fill_fraction	enum(int,int)
,	O
new_use_color	enum(int,int)
)	O
;	O
new_symbol	enum(int,int)
=	O
new_symbol_size	enum(int,int)
=	O
new_symbol_font_name	enum(int,int)
=	O
false	int
;	O
new_linemode	enum(int,int)
=	O
new_plot_line_width	enum(int,int)
=	O
false	int
;	O
new_fill_fraction	enum(int,int)
=	O
new_use_color	enum(int,int)
=	O
false	int
;	O
}	O
read_and_plot_file	(*(struct),*(struct))->(void)
(	O
reader	*(struct)
,	O
multigrapher	*(struct)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
first_file_of_graph	enum(int,int)
)	O
{	O
p	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
=	O
(	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
)	O
xmalloc	(long)->(*(void))
(	O
points_length	int
*	O
sizeof	O
(	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
)	O
)	O
;	O
reader	*(struct)
=	O
new_reader	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,enum(int,int),int,double,*(char),int,double,double,enum(int,int))->(*(struct))
(	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
input_type	enum(int,int,int,int,int,int)
,	O
auto_abscissa	enum(int,int)
,	O
delta_x	double
,	O
x_start	double
,	O
final_transpose_axes	enum(int,int)
,	O
final_log_axis	int
,	O
auto_bump	enum(int,int)
,	O
symbol_index	int
,	O
symbol_size	double
,	O
symbol_font_name	*(char)
,	O
linemode_index	int
,	O
plot_line_width	double
,	O
fill_fraction	double
,	O
use_color	enum(int,int)
)	O
;	O
new_symbol	enum(int,int)
=	O
new_symbol_size	enum(int,int)
=	O
new_symbol_font_name	enum(int,int)
=	O
false	int
;	O
new_linemode	enum(int,int)
=	O
new_plot_line_width	enum(int,int)
=	O
false	int
;	O
new_fill_fraction	enum(int,int)
=	O
new_use_color	enum(int,int)
=	O
false	int
;	O
}	O
else	O
{	O
alter_reader_parameters	(*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,int,double,*(char),int,double,double,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int))->(void)
(	O
reader	*(struct)
,	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
input_type	enum(int,int,int,int,int,int)
,	O
auto_abscissa	enum(int,int)
,	O
delta_x	double
,	O
x_start	double
,	O
symbol_index	int
,	O
symbol_size	double
,	O
symbol_font_name	*(char)
,	O
linemode_index	int
,	O
plot_line_width	double
,	O
fill_fraction	double
,	O
use_color	enum(int,int)
,	O
new_symbol	enum(int,int)
,	O
new_symbol_size	enum(int,int)
,	O
new_symbol_font_name	enum(int,int)
,	O
new_linemode	enum(int,int)
,	O
new_plot_line_width	enum(int,int)
,	O
new_fill_fraction	enum(int,int)
,	O
new_use_color	enum(int,int)
)	O
;	O
new_symbol	enum(int,int)
=	O
new_symbol_size	enum(int,int)
=	O
new_symbol_font_name	enum(int,int)
=	O
false	int
;	O
new_linemode	enum(int,int)
=	O
new_plot_line_width	enum(int,int)
=	O
false	int
;	O
new_fill_fraction	enum(int,int)
=	O
new_use_color	enum(int,int)
=	O
false	int
;	O
}	O
read_file	(*(struct),*(*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))),*(int),*(int))->(void)
(	O
reader	*(struct)
,	O
&	O
p	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
,	O
&	O
points_length	int
,	O
&	O
no_of_points	*(int)
)	O
;	O
}	O
if	O
(	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
close_file	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
optarg	*(char)
,	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
first_file_of_graph	enum(int,int)
=	O
false	int
;	O
break	O
;	O
default	O
:	O
errcnt	int
++	O
;	O
continue_parse	enum(int,int)
=	O
false	int
;	O
break	O
;	O
}	O
if	O
(	O
errcnt	int
>	O
0	int
)	O
continue_parse	enum(int,int)
=	O
false	int
;	O
}	O
if	O
(	O
errcnt	int
>	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Try `%s --help' for more information\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
show_version	enum(int,int)
)	O
{	O
display_version	(*(char),*(char),*(char))->(void)
(	O
progname	*(char)
,	O
written	*(char)
,	O
copyright	*(char)
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
if	O
(	O
do_list_fonts	enum(int,int)
)	O
{	O
int	O
success	int
;	O
success	int
=	O
list_fonts	(*(char),*(char))->(int)
(	O
output_format	*(char)
,	O
progname	*(char)
)	O
;	O
if	O
(	O
success	int
)	O
return	O
EXIT_SUCCESS	int
;	O
else	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
show_fonts	enum(int,int)
)	O
{	O
int	O
success	int
;	O
success	int
=	O
display_fonts	(*(char),*(char))->(int)
(	O
output_format	*(char)
,	O
progname	*(char)
)	O
;	O
if	O
(	O
success	int
)	O
return	O
EXIT_SUCCESS	int
;	O
else	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
show_usage	enum(int,int)
)	O
{	O
display_usage	(*(char),*(int),*(char),int)->(void)
(	O
progname	*(char)
,	O
hidden_options	array(int)
,	O
usage_appendage	*(char)
,	O
2	int
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
if	O
(	O
first_file_of_graph	enum(int,int)
==	O
false	int
)	O
{	O
if	O
(	O
!	O
filter	enum(int,int)
)	O
{	O
array_bounds	(*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))),int,enum(int,int),int,*(double),*(double),*(double),*(double),enum(int,int),enum(int,int),enum(int,int),enum(int,int))->(void)
(	O
p	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
,	O
no_of_points	*(int)
,	O
final_transpose_axes	enum(int,int)
,	O
clip_mode	int
,	O
&	O
final_min_x	double
,	O
&	O
final_min_y	double
,	O
&	O
final_max_x	double
,	O
&	O
final_max_y	double
,	O
final_spec_min_x	enum(int,int)
,	O
final_spec_min_y	enum(int,int)
,	O
final_spec_max_x	enum(int,int)
,	O
final_spec_max_y	enum(int,int)
)	O
;	O
if	O
(	O
first_graph_of_multigraph	enum(int,int)
)	O
{	O
if	O
(	O
(	O
multigrapher	*(struct)
=	O
new_multigrapher	(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),enum(int,int))->(*(struct))
(	O
output_format	*(char)
,	O
bg_color	*(char)
,	O
bitmap_size	*(char)
,	O
emulate_color	*(char)
,	O
max_line_length	*(char)
,	O
meta_portable	*(char)
,	O
page_size	*(char)
,	O
rotation_angle	*(char)
,	O
save_screen	enum(int,int)
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the graphing device could not be opened\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
begin_graph	(*(struct),double,double,double)->(void)
(	O
multigrapher	*(struct)
,	O
reposition_scale	double
,	O
reposition_trans_x	double
,	O
reposition_trans_y	double
)	O
;	O
if	O
(	O
(	O
title_font_name	*(char)
==	O
NULL	O
)	O
&&	O
(	O
font_name	*(char)
!=	O
NULL	O
)	O
)	O
title_font_name	*(char)
=	O
font_name	*(char)
;	O
set_graph_parameters	(*(struct),double,*(char),*(char),*(char),double,double,enum(int,int,int,int,int),double,double,double,double,double,double,enum(int,int),enum(int,int),double,double,double,double,*(char),double,*(char),*(char),double,*(char),enum(int,int),int,int,int,int,int,double,enum(int,int))->(void)
(	O
multigrapher	*(struct)
,	O
frame_line_width	double
,	O
frame_color	*(char)
,	O
top_label	*(char)
,	O
title_font_name	*(char)
,	O
title_font_size	double
,	O
tick_size	double
,	O
grid_spec	enum(int,int,int,int,int)
,	O
final_min_x	double
,	O
final_max_x	double
,	O
final_spacing_x	double
,	O
final_min_y	double
,	O
final_max_y	double
,	O
final_spacing_y	double
,	O
final_spec_spacing_x	enum(int,int)
,	O
final_spec_spacing_y	enum(int,int)
,	O
plot_width	double
,	O
plot_height	double
,	O
margin_below	double
,	O
margin_left	double
,	O
font_name	*(char)
,	O
font_size	double
,	O
x_label	*(char)
,	O
font_name	*(char)
,	O
font_size	double
,	O
y_label	*(char)
,	O
no_rotate_y_label	enum(int,int)
,	O
final_log_axis	int
,	O
final_round_to_next_tick	int
,	O
switch_axis_end	int
,	O
omit_ticks	int
,	O
clip_mode	int
,	O
blankout_fraction	double
,	O
final_transpose_axes	enum(int,int)
)	O
;	O
draw_frame_of_graph	(*(struct),enum(int,int))->(void)
(	O
multigrapher	*(struct)
,	O
first_graph_of_multigraph	enum(int,int)
?	O
false	int
:	O
true	int
)	O
;	O
plot_point_array	(*(struct),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))),int)->(void)
(	O
multigrapher	*(struct)
,	O
p	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
,	O
no_of_points	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
no_of_points	*(int)
=	O
0	int
;	O
}	O
if	O
(	O
frame_on_top	enum(int,int)
)	O
{	O
end_polyline_and_flush	(*(struct))->(void)
(	O
multigrapher	*(struct)
)	O
;	O
draw_frame_of_graph	(*(struct),enum(int,int))->(void)
(	O
multigrapher	*(struct)
,	O
false	int
)	O
;	O
}	O
end_graph	(*(struct))->(void)
(	O
multigrapher	*(struct)
)	O
;	O
}	O
if	O
(	O
delete_multigrapher	(*(struct))->(int)
(	O
multigrapher	*(struct)
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the graphing device could not be closed\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
static	O
void	O
open_file_for_reading	(*(char),*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(void)
(	O
char	O
*	O
filename	*(char)
,	O
FILE	struct
*	O
*	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
FILE	struct
*	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s: %s\n"	*(char)
,	O
progname	*(char)
,	O
filename	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
*	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
static	O
void	O
close_file	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
char	O
*	O
filename	*(char)
,	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
<	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the input file `%s' could not be closed\n"	*(char)
,	O
progname	*(char)
,	O
filename	*(char)
)	O
;	O
}	O
static	O
bool	enum(int,int)
parse_pen_string	(*(char))->(enum(int,int))
(	O
const	O
char	O
*	O
pen_s	*(char)
)	O
{	O
const	O
char	O
*	O
charp	*(char)
;	O
char	O
name	*(char)
[	O
MAX_COLOR_NAME_LEN	int
]	O
;	O
int	O
i	int
;	O
charp	*(char)
=	O
pen_s	*(char)
;	O
while	O
(	O
*	O
charp	*(char)
)	O
{	O
int	O
pen_num	int
;	O
bool	enum(int,int)
got_digit	enum(int,int)
;	O
const	O
char	O
*	O
tmp	*(char)
;	O
if	O
(	O
*	O
charp	*(char)
==	O
':'	O
)	O
{	O
charp	*(char)
++	O
;	O
continue	O
;	O
}	O
pen_num	int
=	O
0	int
;	O
got_digit	enum(int,int)
=	O
false	int
;	O
while	O
(	O
*	O
charp	*(char)
>=	O
'0'	O
&&	O
*	O
charp	*(char)
<=	O
'9'	O
)	O
{	O
pen_num	int
=	O
10	int
*	O
pen_num	int
+	O
(	O
int	O
)	O
*	O
charp	*(char)
-	O
(	O
int	O
)	O
'0'	O
;	O
got_digit	enum(int,int)
=	O
true	int
;	O
charp	*(char)
++	O
;	O
}	O
if	O
(	O
!	O
got_digit	enum(int,int)
||	O
pen_num	int
<	O
1	int
||	O
pen_num	int
>	O
NO_OF_LINEMODES	int
)	O
return	O
false	int
;	O
if	O
(	O
*	O
charp	*(char)
!=	O
'='	O
)	O
return	O
false	int
;	O
charp	*(char)
++	O
;	O
for	O
(	O
tmp	*(char)
=	O
charp	*(char)
,	O
i	int
=	O
0	int
;	O
i	int
<	O
MAX_COLOR_NAME_LEN	int
;	O
tmp	*(char)
++	O
,	O
i	int
++	O
)	O
{	O
if	O
(	O
*	O
tmp	*(char)
==	O
':'	O
)	O
{	O
name	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
charp	*(char)
=	O
tmp	*(char)
+	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
*	O
tmp	*(char)
==	O
'\0'	O
)	O
{	O
name	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
charp	*(char)
=	O
tmp	*(char)
;	O
break	O
;	O
}	O
else	O
name	*(char)
[	O
i	int
]	O
=	O
*	O
tmp	*(char)
;	O
}	O
colorstyle	array(*(char))
[	O
pen_num	int
-	O
1	int
]	O
=	O
xstrdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
}	O
return	O
true	int
;	O
}	O
