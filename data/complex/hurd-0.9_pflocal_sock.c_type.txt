error_t	O
sock_acquire_read_pipe	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(*(struct)))->(int)
(	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
,	O
struct	O
pipe	*(*(struct))
*	O
*	O
pipe	*(*(struct))
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
*	O
pipe	*(*(struct))
=	O
sock	*(struct)
->	O
read_pipe	*(struct)
;	O
if	O
(	O
*	O
pipe	*(*(struct))
!=	O
NULL	O
)	O
if	O
(	O
!	O
(	O
sock	*(struct)
->	O
pipe_class	*(struct)
->	O
flags	int
&	O
PIPE_CLASS_CONNECTIONLESS	O
)	O
&&	O
!	O
(	O
sock	*(struct)
->	O
flags	int
&	O
PFLOCAL_SOCK_CONNECTED	int
)	O
)	O
err	O
=	O
ENOTCONN	O
;	O
else	O
pipe_acquire_reader	()->(int)
(	O
*	O
pipe	*(*(struct))
)	O
;	O
else	O
if	O
(	O
sock	*(struct)
->	O
flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_READ	int
)	O
err	O
=	O
EPIPE	O
;	O
else	O
err	O
=	O
ENOTCONN	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	O
;	O
}	O
error_t	O
sock_acquire_write_pipe	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(*(struct)))->(int)
(	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
,	O
struct	O
pipe	*(*(struct))
*	O
*	O
pipe	*(*(struct))
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
*	O
pipe	*(*(struct))
=	O
sock	*(struct)
->	O
write_pipe	*(struct)
;	O
if	O
(	O
*	O
pipe	*(*(struct))
!=	O
NULL	O
)	O
pipe_acquire_writer	()->(int)
(	O
*	O
pipe	*(*(struct))
)	O
;	O
else	O
if	O
(	O
sock	*(struct)
->	O
flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_WRITE	int
)	O
err	O
=	O
EPIPE	O
;	O
else	O
if	O
(	O
sock	*(struct)
->	O
pipe_class	*(struct)
->	O
flags	int
&	O
PIPE_CLASS_CONNECTIONLESS	O
)	O
err	O
=	O
EDESTADDRREQ	O
;	O
else	O
err	O
=	O
ENOTCONN	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	O
;	O
}	O
error_t	O
sock_create	(*(struct),int,*(*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))->(int)
(	O
struct	O
pipe_class	*(struct)
*	O
pipe_class	*(struct)
,	O
mode_t	O
mode	int
,	O
struct	O
sock	*(struct)
*	O
*	O
sock	*(struct)
)	O
{	O
error_t	O
err	O
;	O
struct	O
sock	*(struct)
*	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
sock	*(struct)
)	O
)	O
;	O
if	O
(	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
==	O
NULL	O
)	O
return	O
ENOMEM	O
;	O
err	O
=	O
pipe_create	()->(int)
(	O
pipe_class	*(struct)
,	O
&	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
read_pipe	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
{	O
free	()->(int)
(	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
;	O
return	O
err	O
;	O
}	O
pipe_add_reader	()->(int)
(	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
read_pipe	*(struct)
)	O
;	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
refs	int
=	O
0	int
;	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
flags	int
=	O
0	int
;	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
write_pipe	*(struct)
=	O
NULL	O
;	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
mode	int
=	O
mode	int
;	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
id	int
=	O
MACH_PORT_NULL	O
;	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
listen_queue	*(struct)
=	O
NULL	O
;	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
connect_queue	*(struct)
=	O
NULL	O
;	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
pipe_class	*(struct)
=	O
pipe_class	*(struct)
;	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
addr	*(struct)
=	O
NULL	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
change_time	int
,	O
0	int
,	O
sizeof	O
(	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
change_time	int
)	O
)	O
;	O
pthread_mutex_init	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)),*(union(array(char),int)))->(int)
(	O
&	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
,	O
NULL	O
)	O
;	O
*	O
sock	*(struct)
=	O
new	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
;	O
return	O
0	int
;	O
}	O
void	O
sock_free	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(void)
(	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
)	O
{	O
sock_shutdown	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),int)->(void)
(	O
sock	*(struct)
,	O
PFLOCAL_SOCK_SHUTDOWN_READ	int
|	O
PFLOCAL_SOCK_SHUTDOWN_WRITE	int
)	O
;	O
if	O
(	O
sock	*(struct)
->	O
id	int
!=	O
MACH_PORT_NULL	O
)	O
mach_port_destroy	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
sock	*(struct)
->	O
id	int
)	O
;	O
if	O
(	O
sock	*(struct)
->	O
listen_queue	*(struct)
)	O
connq_destroy	()->(int)
(	O
sock	*(struct)
->	O
listen_queue	*(struct)
)	O
;	O
free	()->(int)
(	O
sock	*(struct)
)	O
;	O
}	O
void	O
_sock_norefs	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(void)
(	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
)	O
{	O
assert	()->(int)
(	O
sock	*(struct)
->	O
addr	*(struct)
==	O
NULL	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
sock_free	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(void)
(	O
sock	*(struct)
)	O
;	O
}	O
error_t	O
sock_clone	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))->(int)
(	O
struct	O
sock	*(struct)
*	O
template	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
,	O
struct	O
sock	*(struct)
*	O
*	O
sock	*(struct)
)	O
{	O
error_t	O
err	O
=	O
sock_create	(*(struct),int,*(*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))->(int)
(	O
template	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
pipe_class	*(struct)
,	O
template	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
mode	int
,	O
sock	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
(	O
*	O
sock	*(struct)
)	O
->	O
flags	int
=	O
template	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
flags	int
&	O
~	O
PFLOCAL_SOCK_CONNECTED	int
;	O
return	O
0	int
;	O
}	O
struct	O
port_class	O
*	O
sock_user_port_class	*(struct)
;	O
static	O
void	O
sock_user_clean	(*(void))->(void)
(	O
void	O
*	O
vuser	*(void)
)	O
{	O
struct	O
sock_user	struct(struct,*(struct))
*	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
vuser	*(void)
;	O
sock_deref	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(void)
(	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
)	O
;	O
}	O
error_t	O
sock_create_port	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(int))->(int)
(	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
,	O
mach_port_t	O
*	O
port	*(int)
)	O
{	O
struct	O
sock_user	struct(struct,*(struct))
*	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
error_t	O
err	O
=	O
ports_create_port	O
(	O
sock_user_port_class	*(struct)
,	O
sock_port_bucket	O
,	O
sizeof	O
(	O
struct	O
sock_user	struct(struct,*(struct))
)	O
,	O
&	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
ensure_sock_server	()->(int)
(	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
sock	*(struct)
->	O
refs	int
++	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
=	O
sock	*(struct)
;	O
*	O
port	*(int)
=	O
ports_get_right	()->(int)
(	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
ports_port_deref	()->(int)
(	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
addr	*(struct)
{	O
struct	O
port_info	O
pi	struct
;	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
;	O
pthread_mutex_t	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
;	O
}	O
;	O
struct	O
port_class	O
*	O
addr_port_class	*(struct)
;	O
static	O
void	O
addr_unbind	(*(void))->(void)
(	O
void	O
*	O
vaddr	*(void)
)	O
{	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
;	O
struct	O
addr	*(struct)
*	O
addr	*(struct)
=	O
vaddr	*(void)
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
addr	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
sock	*(struct)
=	O
addr	*(struct)
->	O
sock	*(struct)
;	O
if	O
(	O
sock	*(struct)
)	O
{	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
sock	*(struct)
->	O
addr	*(struct)
=	O
NULL	O
;	O
addr	*(struct)
->	O
sock	*(struct)
=	O
NULL	O
;	O
ports_port_deref_weak	()->(int)
(	O
addr	*(struct)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
sock_deref	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(void)
(	O
sock	*(struct)
)	O
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
addr	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
}	O
static	O
void	O
addr_clean	(*(void))->(void)
(	O
void	O
*	O
vaddr	*(void)
)	O
{	O
struct	O
addr	*(struct)
*	O
addr	*(struct)
=	O
vaddr	*(void)
;	O
assert	()->(int)
(	O
addr	*(struct)
->	O
sock	*(struct)
==	O
NULL	O
)	O
;	O
}	O
inline	O
error_t	O
addr_create	(*(*(struct)))->(int)
(	O
struct	O
addr	*(struct)
*	O
*	O
addr	*(struct)
)	O
{	O
error_t	O
err	O
=	O
ports_create_port	O
(	O
addr_port_class	*(struct)
,	O
sock_port_bucket	O
,	O
sizeof	O
(	O
struct	O
addr	*(struct)
)	O
,	O
addr	*(struct)
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
ensure_sock_server	()->(int)
(	O
)	O
;	O
(	O
*	O
addr	*(struct)
)	O
->	O
sock	*(struct)
=	O
NULL	O
;	O
pthread_mutex_init	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)),*(union(array(char),int)))->(int)
(	O
&	O
(	O
*	O
addr	*(struct)
)	O
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
,	O
NULL	O
)	O
;	O
}	O
return	O
err	O
;	O
}	O
error_t	O
sock_bind	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(struct))->(int)
(	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
,	O
struct	O
addr	*(struct)
*	O
addr	*(struct)
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
struct	O
addr	*(struct)
*	O
old_addr	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))
;	O
if	O
(	O
addr	*(struct)
)	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
addr	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
old_addr	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))
=	O
sock	*(struct)
->	O
addr	*(struct)
;	O
if	O
(	O
addr	*(struct)
&&	O
old_addr	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))
)	O
err	O
=	O
EINVAL	O
;	O
else	O
if	O
(	O
!	O
addr	*(struct)
&&	O
!	O
old_addr	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))
)	O
err	O
=	O
EINVAL	O
;	O
else	O
if	O
(	O
addr	*(struct)
&&	O
addr	*(struct)
->	O
sock	*(struct)
)	O
err	O
=	O
EADDRINUSE	O
;	O
else	O
if	O
(	O
addr	*(struct)
)	O
addr	*(struct)
->	O
sock	*(struct)
=	O
sock	*(struct)
;	O
else	O
old_addr	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))
->	O
sock	*(struct)
=	O
NULL	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
sock	*(struct)
->	O
addr	*(struct)
=	O
addr	*(struct)
;	O
if	O
(	O
addr	*(struct)
)	O
{	O
sock	*(struct)
->	O
refs	int
++	O
;	O
ports_port_ref_weak	()->(int)
(	O
addr	*(struct)
)	O
;	O
}	O
if	O
(	O
old_addr	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))
)	O
{	O
sock	*(struct)
->	O
refs	int
--	O
;	O
ports_port_deref_weak	()->(int)
(	O
old_addr	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))
)	O
;	O
assert	()->(int)
(	O
sock	*(struct)
->	O
refs	int
>	O
0	int
)	O
;	O
}	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
addr	*(struct)
)	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
addr	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	O
;	O
}	O
static	O
inline	O
error_t	O
ensure_addr	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct(struct`,*`,union`)),*(struct(struct`,*`,union`)),*(struct),*(struct))),*(*(struct(struct,*(struct`),union(struct`,array(char),long)))))->(int)
(	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
,	O
struct	O
addr	*(struct)
*	O
*	O
addr	*(struct)
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
if	O
(	O
!	O
sock	*(struct)
->	O
addr	*(struct)
)	O
{	O
err	O
=	O
addr_create	(*(*(struct)))->(int)
(	O
&	O
sock	*(struct)
->	O
addr	*(struct)
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
sock	*(struct)
->	O
addr	*(struct)
->	O
sock	*(struct)
=	O
sock	*(struct)
;	O
sock	*(struct)
->	O
refs	int
++	O
;	O
ports_port_ref_weak	()->(int)
(	O
sock	*(struct)
->	O
addr	*(struct)
)	O
;	O
}	O
}	O
else	O
ports_port_ref	()->(int)
(	O
sock	*(struct)
->	O
addr	*(struct)
)	O
;	O
if	O
(	O
!	O
err	O
)	O
*	O
addr	*(struct)
=	O
sock	*(struct)
->	O
addr	*(struct)
;	O
return	O
err	O
;	O
}	O
error_t	O
addr_get_sock	(*(struct),*(*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))->(int)
(	O
struct	O
addr	*(struct)
*	O
addr	*(struct)
,	O
struct	O
sock	*(struct)
*	O
*	O
sock	*(struct)
)	O
{	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
addr	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
*	O
sock	*(struct)
=	O
addr	*(struct)
->	O
sock	*(struct)
;	O
if	O
(	O
*	O
sock	*(struct)
)	O
(	O
*	O
sock	*(struct)
)	O
->	O
refs	int
++	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
addr	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
*	O
sock	*(struct)
?	O
0	int
:	O
EADDRNOTAVAIL	O
;	O
}	O
error_t	O
sock_get_addr	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(*(struct)))->(int)
(	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
,	O
struct	O
addr	*(struct)
*	O
*	O
addr	*(struct)
)	O
{	O
error_t	O
err	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
err	O
=	O
ensure_addr	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct(struct`,*`,union`)),*(struct(struct`,*`,union`)),*(struct),*(struct))),*(*(struct(struct,*(struct`),union(struct`,array(char),long)))))->(int)
(	O
sock	*(struct)
,	O
addr	*(struct)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	O
;	O
}	O
static	O
pthread_mutex_t	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
socket_pair_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
;	O
error_t	O
sock_connect	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(int)
(	O
struct	O
sock	*(struct)
*	O
sock1	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
,	O
struct	O
sock	*(struct)
*	O
sock2	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
struct	O
pipe	*(*(struct))
*	O
old_sock1_write_pipe	*(struct)
=	O
NULL	O
;	O
struct	O
addr	*(struct)
*	O
old_sock1_write_addr	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))
=	O
NULL	O
;	O
void	O
connect	()->(int)
(	O
struct	O
sock	*(struct)
*	O
wr	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct(struct,*(struct`),union(struct`,array(char),long))),*(struct(struct,*(struct`),union(struct`,array(char),long))),*(struct),*(struct)))
,	O
struct	O
sock	*(struct)
*	O
rd	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct(struct,*(struct`),union(struct`,array(char),long))),*(struct(struct,*(struct`),union(struct`,array(char),long))),*(struct),*(struct)))
)	O
{	O
if	O
(	O
!	O
(	O
(	O
wr	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct(struct,*(struct`),union(struct`,array(char),long))),*(struct(struct,*(struct`),union(struct`,array(char),long))),*(struct),*(struct)))
->	O
flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_WRITE	int
)	O
||	O
(	O
rd	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct(struct,*(struct`),union(struct`,array(char),long))),*(struct(struct,*(struct`),union(struct`,array(char),long))),*(struct),*(struct)))
->	O
flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_READ	int
)	O
)	O
)	O
{	O
struct	O
pipe	*(*(struct))
*	O
pipe	*(*(struct))
=	O
rd	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct(struct,*(struct`),union(struct`,array(char),long))),*(struct(struct,*(struct`),union(struct`,array(char),long))),*(struct),*(struct)))
->	O
read_pipe	*(struct)
;	O
assert	()->(int)
(	O
pipe	*(*(struct))
)	O
;	O
pipe_add_writer	O
(	O
pipe	*(*(struct))
)	O
;	O
wr	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct(struct,*(struct`),union(struct`,array(char),long))),*(struct(struct,*(struct`),union(struct`,array(char),long))),*(struct),*(struct)))
->	O
write_pipe	*(struct)
=	O
pipe	*(*(struct))
;	O
}	O
}	O
if	O
(	O
sock1	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
pipe_class	*(struct)
!=	O
sock2	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
pipe_class	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
socket_pair_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock1	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
sock1	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
!=	O
sock2	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock2	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
(	O
sock1	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
flags	int
&	O
PFLOCAL_SOCK_CONNECTED	int
)	O
||	O
(	O
sock2	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
flags	int
&	O
PFLOCAL_SOCK_CONNECTED	int
)	O
)	O
err	O
=	O
EISCONN	O
;	O
else	O
{	O
old_sock1_write_pipe	*(struct)
=	O
sock1	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
write_pipe	*(struct)
;	O
old_sock1_write_addr	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))
=	O
sock1	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
write_addr	*(struct)
;	O
connect	()->(int)
(	O
sock1	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
,	O
sock2	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
;	O
if	O
(	O
!	O
(	O
sock1	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
pipe_class	*(struct)
->	O
flags	int
&	O
PIPE_CLASS_CONNECTIONLESS	O
)	O
)	O
{	O
sock1	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
flags	int
|=	O
PFLOCAL_SOCK_CONNECTED	int
;	O
if	O
(	O
sock1	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
!=	O
sock2	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
{	O
connect	()->(int)
(	O
sock2	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
,	O
sock1	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
;	O
sock2	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
flags	int
|=	O
PFLOCAL_SOCK_CONNECTED	int
;	O
}	O
}	O
}	O
if	O
(	O
sock1	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
!=	O
sock2	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock2	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock1	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
socket_pair_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
old_sock1_write_pipe	*(struct)
)	O
{	O
pipe_remove_writer	()->(int)
(	O
old_sock1_write_pipe	*(struct)
)	O
;	O
ports_port_deref	()->(int)
(	O
old_sock1_write_addr	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))
)	O
;	O
}	O
return	O
err	O
;	O
}	O
void	O
sock_shutdown	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),int)->(void)
(	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
,	O
unsigned	O
flags	int
)	O
{	O
unsigned	O
old_flags	int
;	O
struct	O
pipe	*(*(struct))
*	O
read_pipe	*(struct)
=	O
NULL	O
;	O
struct	O
pipe	*(*(struct))
*	O
write_pipe	*(struct)
=	O
NULL	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
old_flags	int
=	O
sock	*(struct)
->	O
flags	int
;	O
sock	*(struct)
->	O
flags	int
|=	O
flags	int
;	O
if	O
(	O
flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_READ	int
&&	O
!	O
(	O
old_flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_READ	int
)	O
)	O
{	O
read_pipe	*(struct)
=	O
sock	*(struct)
->	O
read_pipe	*(struct)
;	O
sock	*(struct)
->	O
read_pipe	*(struct)
=	O
NULL	O
;	O
}	O
if	O
(	O
flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_WRITE	int
&&	O
!	O
(	O
old_flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_WRITE	int
)	O
)	O
{	O
write_pipe	*(struct)
=	O
sock	*(struct)
->	O
write_pipe	*(struct)
;	O
sock	*(struct)
->	O
write_pipe	*(struct)
=	O
NULL	O
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
read_pipe	*(struct)
)	O
pipe_remove_reader	()->(int)
(	O
read_pipe	*(struct)
)	O
;	O
if	O
(	O
write_pipe	*(struct)
)	O
pipe_remove_writer	()->(int)
(	O
write_pipe	*(struct)
)	O
;	O
}	O
error_t	O
sock_global_init	()->(int)
(	O
)	O
{	O
sock_port_bucket	O
=	O
ports_create_bucket	()->(int)
(	O
)	O
;	O
sock_user_port_class	*(struct)
=	O
ports_create_class	()->(int)
(	O
sock_user_clean	(*(void))->(void)
,	O
NULL	O
)	O
;	O
addr_port_class	*(struct)
=	O
ports_create_class	()->(int)
(	O
addr_clean	(*(void))->(void)
,	O
addr_unbind	(*(void))->(void)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
sock_global_shutdown	()->(int)
(	O
)	O
{	O
int	O
num_ports	int
=	O
ports_count_bucket	()->(int)
(	O
sock_port_bucket	O
)	O
;	O
ports_enable_bucket	()->(int)
(	O
sock_port_bucket	O
)	O
;	O
return	O
(	O
num_ports	int
==	O
0	int
?	O
0	int
:	O
EBUSY	O
)	O
;	O
}	O
