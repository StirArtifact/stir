extern	O
int	O
tputs	(*(char),int,*(()->(int)))->(int)
PROTO	O
(	O
(	O
const	O
char	O
*	O
__string	*(char)
,	O
int	O
__nlines	int
,	O
int	O
(	O
*	O
outfun	*(()->(int))
)	O
(	O
)	O
)	O
)	O
;	O
extern	O
int	O
tgetent	(*(void),*(char))->(int)
PROTO	O
(	O
(	O
void	O
*	O
__buffer	*(struct(array(short),array(short),short,short,long long))
,	O
const	O
char	O
*	O
__termtype	*(char)
)	O
)	O
;	O
extern	O
char	O
*	O
tgetstr	(*(char),*(*(char)))->(*(char))
PROTO	O
(	O
(	O
const	O
char	O
*	O
__name	*(char)
,	O
char	O
*	O
*	O
__area	*(*(char))
)	O
)	O
;	O
extern	O
int	O
tgetnum	(*(char))->(int)
PROTO	O
(	O
(	O
const	O
char	O
*	O
__name	*(char)
)	O
)	O
;	O
extern	O
int	O
tgetflag	(*(char))->(int)
PROTO	O
(	O
(	O
const	O
char	O
*	O
__name	*(char)
)	O
)	O
;	O
extern	O
char	O
*	O
tgoto	(*(char),int,int)->(*(char))
PROTO	O
(	O
(	O
const	O
char	O
*	O
__cstring	*(char)
,	O
int	O
__hpos	int
,	O
int	O
__vpos	int
)	O
)	O
;	O
static	O
int	O
vcs_read_ok	int
;	O
static	O
int	O
vcs_is_monochrome	int
;	O
static	O
int	O
tty_kbdmode	int
;	O
static	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
old_term	struct(int,int,int,int,char,array(char),int,int)
;	O
static	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
new_term	struct(int,int,int,int,char,array(char),int,int)
;	O
int	O
tty_lines	int
;	O
int	O
tty_columns	int
;	O
char	O
*	O
tty_device	*(char)
;	O
static	O
unsigned	O
char	O
*	O
tty_key_seq	*(char)
;	O
static	O
int	O
tty_device_length	int
;	O
static	O
int	O
tty_last_char_flag	int
;	O
static	O
int	O
tty_cursor_x	int
;	O
static	O
int	O
tty_cursor_y	int
;	O
static	O
unsigned	O
char	O
tty_current_attribute	char
;	O
static	O
unsigned	O
char	O
tty_io_current_attribute	char
;	O
static	O
int	O
tty_interrupt_char	int
=	O
key_INTERRUPT	O
;	O
static	O
int	O
fg_cache	int
=	O
INVALID_CACHE	int
;	O
static	O
int	O
bg_cache	int
=	O
INVALID_CACHE	int
;	O
static	O
int	O
br_cache	int
=	O
INVALID_CACHE	int
;	O
static	O
int	O
rv_cache	int
=	O
INVALID_CACHE	int
;	O
static	O
unsigned	O
char	O
*	O
tty_scr	*(char)
;	O
static	O
unsigned	O
char	O
*	O
tty_atr	*(char)
;	O
static	O
unsigned	O
char	O
*	O
tty_prev_scr	*(char)
;	O
static	O
unsigned	O
char	O
*	O
tty_prev_atr	*(char)
;	O
static	O
char	O
ansi_foreground	array(char)
[	O
]	O
=	O
{	O
0x1b	int
,	O
'['	O
,	O
'3'	O
,	O
'0'	O
,	O
'm'	O
}	O
;	O
static	O
char	O
ansi_background	array(char)
[	O
]	O
=	O
{	O
0x1b	int
,	O
'['	O
,	O
'4'	O
,	O
'0'	O
,	O
'm'	O
}	O
;	O
static	O
char	O
ansi_defaults	array(char)
[	O
]	O
=	O
{	O
0x1b	int
,	O
'['	O
,	O
'0'	O
,	O
'm'	O
}	O
;	O
extern	O
int	O
AnsiColors	int
;	O
int	O
LinuxConsole	int
;	O
tty_key_t	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
*	O
key_list_head	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
;	O
tty_key_t	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
*	O
current_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
;	O
tty_key_t	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
default_key	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
;	O
static	O
char	O
tty_cache	array(char)
[	O
TTY_CACHE_SIZE	int
]	O
;	O
static	O
int	O
tty_index	int
;	O
static	O
char	O
vt100	array(char)
[	O
]	O
=	O
"vt100"	*(char)
;	O
int	O
tty_mode	int
=	O
TTY_CANONIC	int
;	O
char	O
*	O
tty_type	*(char)
;	O
char	O
PC	char
;	O
char	O
*	O
BC	*(char)
;	O
char	O
*	O
UP	*(char)
;	O
speed_t	int
ospeed	int
;	O
typedef	O
struct	O
{	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
string	*(char)
;	O
int	O
integer	int
;	O
int	O
required	int
;	O
char	O
*	O
symbol	*(char)
;	O
}	O
tty_capability_t	struct(*(char),*(char),int,int,*(char))
;	O
static	O
tty_capability_t	struct(*(char),*(char),int,int,*(char))
tty_capability	array(struct(*(char),*(char),int,int,*(char)))
[	O
TTY_CAPABILITIES_USED	int
]	O
=	O
{	O
{	O
"me"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"mr"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"md"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"vi"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"ve"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"cl"	*(char)
,	O
NULL	O
,	O
0	int
,	O
1	int
,	O
NULL	O
}	O
,	O
{	O
"cm"	*(char)
,	O
NULL	O
,	O
0	int
,	O
1	int
,	O
NULL	O
}	O
,	O
{	O
"pc"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"up"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"le"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"so"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"sg"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"ms"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"co"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"li"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"ti"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"te"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"ku"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"UP"	*(char)
}	O
,	O
{	O
"kd"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"DOWN"	*(char)
}	O
,	O
{	O
"kr"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"RIGHT"	*(char)
}	O
,	O
{	O
"kl"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"LEFT"	*(char)
}	O
,	O
{	O
"kI"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"INS"	*(char)
}	O
,	O
{	O
"kD"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"DEL"	*(char)
}	O
,	O
{	O
"kh"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"HOME"	*(char)
}	O
,	O
{	O
"@7"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"END"	*(char)
}	O
,	O
{	O
"kP"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"PGUP"	*(char)
}	O
,	O
{	O
"kN"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"PGDOWN"	*(char)
}	O
,	O
{	O
"k0"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F0"	*(char)
}	O
,	O
{	O
"k1"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F1"	*(char)
}	O
,	O
{	O
"k2"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F2"	*(char)
}	O
,	O
{	O
"k3"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F3"	*(char)
}	O
,	O
{	O
"k4"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F4"	*(char)
}	O
,	O
{	O
"k5"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F5"	*(char)
}	O
,	O
{	O
"k6"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F6"	*(char)
}	O
,	O
{	O
"k7"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F7"	*(char)
}	O
,	O
{	O
"k8"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F8"	*(char)
}	O
,	O
{	O
"k9"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F9"	*(char)
}	O
,	O
{	O
"k;"	*(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F10"	*(char)
}	O
,	O
}	O
;	O
static	O
char	O
term_database	array(char)
[	O
]	O
=	O
"terminfo"	*(char)
;	O
static	O
char	O
term_env	array(char)
[	O
]	O
=	O
"TERMINFO"	*(char)
;	O
static	O
void	O
tty_io_goto	(int,int)->(void)
PROTO	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
tty_io_foreground	(int)->(void)
PROTO	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
tty_io_background	(int)->(void)
PROTO	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
tty_io_brightness	(int)->(void)
PROTO	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
tty_io_reversevid	(int)->(void)
PROTO	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
tty_io_colors	(int)->(void)
PROTO	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
tty_is_xterm	(*(char))->(int)
PROTO	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
extern	O
void	O
fatal	(*(char))->(void)
PROTO	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
colors	array(*(char))
[	O
10	int
]	O
=	O
{	O
"BLACK"	*(char)
,	O
"RED"	*(char)
,	O
"GREEN"	*(char)
,	O
"YELLOW"	*(char)
,	O
"BLUE"	*(char)
,	O
"MAGENTA"	*(char)
,	O
"CYAN"	*(char)
,	O
"WHITE"	*(char)
,	O
"OFF"	*(char)
,	O
"ON"	*(char)
}	O
;	O
unsigned	O
char	O
key_ctrl_table	array(char)
[	O
0x5f	int
]	O
=	O
{	O
0x20	int
,	O
0x21	int
,	O
0x22	int
,	O
0x23	int
,	O
0xff	int
,	O
0x25	int
,	O
0x26	int
,	O
0x07	int
,	O
0x28	int
,	O
0x29	int
,	O
0x2a	int
,	O
0x2b	int
,	O
0x2c	int
,	O
0x2d	int
,	O
0x2e	int
,	O
0x2f	int
,	O
0x20	int
,	O
0x20	int
,	O
0xff	int
,	O
0x1b	int
,	O
0x1c	int
,	O
0x1d	int
,	O
0x1e	int
,	O
0x1f	int
,	O
0x7f	int
,	O
0x39	int
,	O
0x3a	int
,	O
0x3b	int
,	O
0x3c	int
,	O
0x20	int
,	O
0x3e	int
,	O
0x20	int
,	O
0x20	int
,	O
0x01	int
,	O
0x02	int
,	O
0x03	int
,	O
0x04	int
,	O
0x05	int
,	O
0x06	int
,	O
0x07	int
,	O
0x08	int
,	O
0x09	int
,	O
0x0a	int
,	O
0x0b	int
,	O
0x0c	int
,	O
0x0d	int
,	O
0x0e	int
,	O
0x0f	int
,	O
0x10	int
,	O
0x11	int
,	O
0x12	int
,	O
0x13	int
,	O
0x14	int
,	O
0x15	int
,	O
0x16	int
,	O
0x17	int
,	O
0x18	int
,	O
0x19	int
,	O
0x1a	int
,	O
0x1b	int
,	O
0x1c	int
,	O
0x1d	int
,	O
0x5e	int
,	O
0x7f	int
,	O
0x20	int
,	O
0x01	int
,	O
0x02	int
,	O
0x03	int
,	O
0x04	int
,	O
0x05	int
,	O
0x06	int
,	O
0x07	int
,	O
0x08	int
,	O
0x09	int
,	O
0x0a	int
,	O
0x0b	int
,	O
0x0c	int
,	O
0x0d	int
,	O
0x0e	int
,	O
0x0f	int
,	O
0x10	int
,	O
0x11	int
,	O
0x12	int
,	O
0x13	int
,	O
0x14	int
,	O
0x15	int
,	O
0x16	int
,	O
0x17	int
,	O
0x18	int
,	O
0x19	int
,	O
0x1a	int
,	O
0x20	int
,	O
0x20	int
,	O
0x20	int
,	O
0x20	int
,	O
}	O
;	O
static	O
int	O
keyno	int
=	O
0	int
;	O
static	O
int	O
keyindex	int
=	O
0	int
;	O
static	O
char	O
keybuf	array(char)
[	O
1024	int
]	O
;	O
static	O
unsigned	O
char	O
keystr	array(char)
[	O
MAX_KEY_LENGTH	int
*	O
20	int
]	O
;	O
static	O
int	O
partial	int
=	O
0	int
;	O
static	O
int	O
key_on_display	int
=	O
0	int
;	O
void	O
(	O
*	O
tty_enter_idle_hook	*(()->(void))
)	O
(	O
)	O
;	O
void	O
(	O
*	O
tty_exit_idle_hook	*(()->(void))
)	O
(	O
)	O
;	O
void	O
tty_set_last_char_flag	(int)->(void)
(	O
last_char_flag	int
)	O
int	O
last_char_flag	int
;	O
{	O
tty_last_char_flag	int
=	O
last_char_flag	int
;	O
}	O
void	O
tty_set_mode	(int)->(void)
(	O
mode	int
)	O
int	O
mode	int
;	O
{	O
if	O
(	O
mode	int
==	O
TTY_NONCANONIC	int
)	O
{	O
new_term	struct(int,int,int,int,char,array(char),int,int)
=	O
old_term	struct(int,int,int,int,char,array(char),int,int)
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_iflag	short
&=	O
~	O
(	O
IXON	int
|	O
ICRNL	int
|	O
IGNCR	int
|	O
INLCR	int
|	O
IGNBRK	int
|	O
BRKINT	int
)	O
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_oflag	short
&=	O
~	O
OPOST	int
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_lflag	short
|=	O
ISIG	int
|	O
NOFLSH	int
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_lflag	short
&=	O
~	O
(	O
ICANON	int
|	O
ECHO	int
)	O
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VINTR	int
]	O
=	O
key_INTERRUPT	O
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VQUIT	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VSTART	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VSTOP	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VMIN	int
]	O
=	O
1	int
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VTIME	int
]	O
=	O
0	int
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VERASE	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VKILL	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VEOL	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VEOL2	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VSUSP	int
]	O
=	O
key_SUSPEND	O
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VREPRINT	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VDISCARD	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VWERASE	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VLNEXT	int
]	O
=	O
CDISABLE	O
;	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
TTY_OUTPUT	int
,	O
TCSADRAIN	int
,	O
&	O
new_term	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
ospeed	int
=	O
cfgetospeed	(*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
&	O
new_term	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
ioctl	(int,long)->(int)
(	O
TTY_OUTPUT	int
,	O
TCXONC	int
,	O
1	int
)	O
;	O
tcflow	(int,int)->(int)
(	O
TTY_OUTPUT	int
,	O
TCOON	int
)	O
;	O
tty_set_interrupt_char	(int)->(void)
(	O
tty_interrupt_char	int
)	O
;	O
}	O
else	O
{	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
TTY_OUTPUT	int
,	O
TCSADRAIN	int
,	O
&	O
old_term	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
}	O
tty_mode	int
=	O
mode	int
;	O
}	O
int	O
tty_get_mode	()->(int)
(	O
)	O
{	O
return	O
tty_mode	int
;	O
}	O
void	O
tty_set_interrupt_char	(int)->(void)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
current_term	struct(int,int,int,int,char,array(char),int,int)
;	O
tcgetattr	(int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
TTY_OUTPUT	int
,	O
&	O
current_term	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
current_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VINTR	int
]	O
=	O
c	int
;	O
current_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VQUIT	int
]	O
=	O
CDISABLE	O
;	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
TTY_OUTPUT	int
,	O
TCSADRAIN	int
,	O
&	O
current_term	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
tty_interrupt_char	int
=	O
c	int
;	O
}	O
void	O
tty_flush	()->(void)
(	O
)	O
{	O
int	O
bytes_transferred	int
=	O
0	int
;	O
while	O
(	O
bytes_transferred	int
<	O
tty_index	int
)	O
{	O
int	O
count	int
=	O
xwrite	(int,*(char),long)->(int)
(	O
TTY_OUTPUT	int
,	O
tty_cache	array(char)
+	O
bytes_transferred	int
,	O
tty_index	int
-	O
bytes_transferred	int
)	O
;	O
if	O
(	O
count	int
<	O
0	int
)	O
break	O
;	O
bytes_transferred	int
+=	O
count	int
;	O
}	O
tty_index	int
=	O
0	int
;	O
}	O
int	O
tty_writec	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
if	O
(	O
tty_index	int
==	O
TTY_CACHE_SIZE	int
)	O
tty_flush	()->(void)
(	O
)	O
;	O
tty_cache	array(char)
[	O
tty_index	int
++	O
]	O
=	O
(	O
char	O
)	O
c	int
;	O
return	O
1	int
;	O
}	O
void	O
tty_io_clear	()->(void)
(	O
)	O
{	O
tputs	(*(char),int,*(()->(int)))->(int)
(	O
TTY_CLEAR_SCREEN	O
,	O
tty_lines	int
,	O
tty_writec	(int)->(int)
)	O
;	O
tty_flush	()->(void)
(	O
)	O
;	O
}	O
void	O
tty_start_cursorapp	()->(void)
(	O
)	O
{	O
tputs	(*(char),int,*(()->(int)))->(int)
(	O
TTY_START_CURSORAPP	O
,	O
tty_lines	int
-	O
1	int
,	O
tty_writec	(int)->(int)
)	O
;	O
tty_flush	()->(void)
(	O
)	O
;	O
}	O
void	O
tty_end_cursorapp	()->(void)
(	O
)	O
{	O
tty_io_clear	()->(void)
(	O
)	O
;	O
tputs	(*(char),int,*(()->(int)))->(int)
(	O
TTY_END_CURSORAPP	O
,	O
tty_lines	int
-	O
1	int
,	O
tty_writec	(int)->(int)
)	O
;	O
tty_flush	()->(void)
(	O
)	O
;	O
}	O
void	O
tty_end	(*(char))->(void)
(	O
screen	*(char)
)	O
char	O
*	O
screen	*(char)
;	O
{	O
if	O
(	O
tty_mode	int
==	O
TTY_NONCANONIC	int
)	O
tty_set_mode	(int)->(void)
(	O
TTY_CANONIC	int
)	O
;	O
tty_defaults	()->(void)
(	O
)	O
;	O
if	O
(	O
screen	*(char)
&&	O
LinuxConsole	int
)	O
tty_put_screen	(*(char))->(void)
(	O
screen	*(char)
)	O
;	O
tty_end_cursorapp	()->(void)
(	O
)	O
;	O
tty_io_goto	(int,int)->(void)
(	O
tty_lines	int
,	O
0	int
)	O
;	O
tty_flush	()->(void)
(	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
char	O
*	O
tty_key_human2machine	(*(char))->(*(char))
(	O
key_seq	*(char)
)	O
unsigned	O
char	O
*	O
key_seq	*(char)
;	O
{	O
unsigned	O
char	O
*	O
first	*(char)
;	O
unsigned	O
char	O
*	O
second	*(char)
;	O
first	*(char)
=	O
second	*(char)
=	O
key_seq	*(char)
;	O
if	O
(	O
tty_kbdmode	int
==	O
TTY_RESTRICTED_INPUT	int
&&	O
*	O
key_seq	*(char)
!=	O
'^'	O
)	O
return	O
NULL	O
;	O
while	O
(	O
*	O
second	*(char)
)	O
{	O
if	O
(	O
*	O
second	*(char)
==	O
'^'	O
)	O
{	O
if	O
(	O
*	O
++	O
second	*(char)
)	O
{	O
if	O
(	O
toupper	(int)->(int)
(	O
*	O
second	*(char)
)	O
==	O
'G'	O
||	O
toupper	(int)->(int)
(	O
*	O
second	*(char)
)	O
==	O
'Z'	O
)	O
return	O
NULL	O
;	O
*	O
first	*(char)
++	O
=	O
key_ctrl_table	array(char)
[	O
(	O
*	O
second	*(char)
++	O
&	O
0x7F	int
)	O
-	O
' '	O
]	O
;	O
}	O
else	O
return	O
NULL	O
;	O
}	O
else	O
*	O
first	*(char)
++	O
=	O
*	O
second	*(char)
++	O
;	O
}	O
*	O
first	*(char)
=	O
0	int
;	O
return	O
(	O
char	O
*	O
)	O
key_seq	*(char)
;	O
}	O
unsigned	O
char	O
*	O
tty_key_machine2human	(*(char))->(*(char))
(	O
key_seq	*(char)
)	O
char	O
*	O
key_seq	*(char)
;	O
{	O
unsigned	O
char	O
*	O
ptr	*(char)
;	O
keystr	array(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
ptr	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
key_seq	*(char)
;	O
*	O
ptr	*(char)
;	O
ptr	*(char)
++	O
)	O
{	O
if	O
(	O
ptr	*(char)
!=	O
(	O
unsigned	O
char	O
*	O
)	O
key_seq	*(char)
)	O
strcat	(*(char),*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
keystr	array(char)
,	O
" "	*(char)
)	O
;	O
if	O
(	O
*	O
ptr	*(char)
==	O
key_ESC	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
keystr	array(char)
,	O
"escape"	*(char)
)	O
;	O
else	O
if	O
(	O
*	O
ptr	*(char)
==	O
' '	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
keystr	array(char)
,	O
"space"	*(char)
)	O
;	O
else	O
if	O
(	O
*	O
ptr	*(char)
==	O
key_BACKSPACE	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
keystr	array(char)
,	O
"backspace"	*(char)
)	O
;	O
else	O
if	O
(	O
*	O
ptr	*(char)
==	O
key_CTRL_SPACE	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
keystr	array(char)
,	O
"^space"	*(char)
)	O
;	O
else	O
if	O
(	O
iscntrl	(int)->(int)
(	O
*	O
ptr	*(char)
)	O
)	O
{	O
char	O
x	int
[	O
3	int
]	O
;	O
x	int
[	O
0	int
]	O
=	O
'^'	O
;	O
x	int
[	O
1	int
]	O
=	O
*	O
ptr	*(char)
+	O
'A'	O
-	O
1	int
;	O
x	int
[	O
2	int
]	O
=	O
'\0'	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
keystr	array(char)
,	O
x	int
)	O
;	O
}	O
else	O
{	O
char	O
x	int
[	O
2	int
]	O
;	O
x	int
[	O
0	int
]	O
=	O
*	O
ptr	*(char)
;	O
x	int
[	O
1	int
]	O
=	O
'\0'	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
keystr	array(char)
,	O
x	int
)	O
;	O
}	O
}	O
return	O
(	O
unsigned	O
char	O
*	O
)	O
keystr	array(char)
;	O
}	O
void	O
tty_update	()->(void)
(	O
)	O
{	O
int	O
pos	int
,	O
x	int
,	O
y	int
;	O
int	O
tty_io_cursor_x	int
=	O
-	O
1	int
;	O
int	O
tty_io_cursor_y	int
=	O
-	O
1	int
;	O
int	O
last_pos	int
=	O
tty_columns	int
*	O
tty_lines	int
;	O
if	O
(	O
tty_last_char_flag	int
==	O
OFF	int
)	O
last_pos	int
--	O
;	O
tty_cursor	(int)->(void)
(	O
OFF	int
)	O
;	O
for	O
(	O
pos	int
=	O
0	int
;	O
pos	int
<	O
last_pos	int
;	O
pos	int
++	O
)	O
if	O
(	O
tty_scr	*(char)
[	O
pos	int
]	O
!=	O
tty_prev_scr	*(char)
[	O
pos	int
]	O
||	O
tty_atr	*(char)
[	O
pos	int
]	O
!=	O
tty_prev_atr	*(char)
[	O
pos	int
]	O
)	O
{	O
y	int
=	O
pos	int
/	O
tty_columns	int
;	O
x	int
=	O
pos	int
%	O
tty_columns	int
;	O
if	O
(	O
x	int
!=	O
tty_io_cursor_x	int
||	O
y	int
!=	O
tty_io_cursor_y	int
)	O
tty_io_goto	(int,int)->(void)
(	O
tty_io_cursor_y	int
=	O
y	int
,	O
tty_io_cursor_x	int
=	O
x	int
)	O
;	O
tty_io_colors	(int)->(void)
(	O
tty_atr	*(char)
[	O
pos	int
]	O
)	O
;	O
tty_writec	(int)->(int)
(	O
tty_scr	*(char)
[	O
pos	int
]	O
)	O
;	O
if	O
(	O
++	O
tty_io_cursor_x	int
==	O
tty_columns	int
)	O
{	O
tty_io_cursor_x	int
=	O
0	int
;	O
tty_io_cursor_y	int
=	O
-	O
1	int
;	O
}	O
}	O
tty_io_goto	(int,int)->(void)
(	O
tty_cursor_y	int
,	O
tty_cursor_x	int
)	O
;	O
tty_cursor	(int)->(void)
(	O
ON	int
)	O
;	O
if	O
(	O
tty_index	int
)	O
tty_flush	()->(void)
(	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
tty_prev_scr	*(char)
,	O
tty_scr	*(char)
,	O
tty_columns	int
*	O
tty_lines	int
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
tty_prev_atr	*(char)
,	O
tty_atr	*(char)
,	O
tty_columns	int
*	O
tty_lines	int
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
}	O
static	O
int	O
tty_writes	(*(char),int)->(int)
(	O
s	long
,	O
len	int
)	O
char	O
*	O
s	long
;	O
int	O
len	int
;	O
{	O
if	O
(	O
tty_index	int
+	O
len	int
>=	O
TTY_CACHE_SIZE	int
)	O
tty_flush	()->(void)
(	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
tty_cache	array(char)
+	O
tty_index	int
,	O
s	long
,	O
len	int
)	O
;	O
tty_index	int
+=	O
len	int
;	O
return	O
len	int
;	O
}	O
int	O
tty_puts	(*(char),int)->(int)
(	O
buf	*(char)
,	O
length	int
)	O
char	O
*	O
buf	*(char)
;	O
int	O
length	int
;	O
{	O
int	O
tty_offset	int
;	O
int	O
x	int
=	O
tty_cursor_x	int
;	O
tty_cursor_x	int
+=	O
length	int
;	O
if	O
(	O
x	int
>=	O
tty_columns	int
)	O
return	O
0	int
;	O
if	O
(	O
tty_cursor_y	int
>=	O
tty_lines	int
)	O
return	O
0	int
;	O
if	O
(	O
x	int
+	O
length	int
>	O
tty_columns	int
)	O
length	int
=	O
tty_columns	int
-	O
x	int
;	O
tty_offset	int
=	O
(	O
tty_cursor_y	int
*	O
tty_columns	int
)	O
+	O
x	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
tty_scr	*(char)
+	O
tty_offset	int
,	O
buf	*(char)
,	O
length	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
tty_atr	*(char)
+	O
tty_offset	int
,	O
tty_current_attribute	char
,	O
length	int
)	O
;	O
return	O
length	int
;	O
}	O
int	O
tty_putc	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
char	O
character	char
=	O
c	int
;	O
return	O
tty_puts	(*(char),int)->(int)
(	O
&	O
character	char
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
}	O
int	O
tty_read	(*(char),int)->(int)
(	O
buf	*(char)
,	O
length	int
)	O
char	O
*	O
buf	*(char)
;	O
int	O
length	int
;	O
{	O
int	O
bytes	int
;	O
tty_update	()->(void)
(	O
)	O
;	O
if	O
(	O
tty_enter_idle_hook	*(()->(void))
)	O
(	O
*	O
tty_enter_idle_hook	*(()->(void))
)	O
(	O
)	O
;	O
bytes	int
=	O
xread	(int,*(char),long)->(int)
(	O
TTY_INPUT	int
,	O
buf	*(char)
,	O
length	int
)	O
;	O
if	O
(	O
tty_exit_idle_hook	*(()->(void))
)	O
(	O
*	O
tty_exit_idle_hook	*(()->(void))
)	O
(	O
)	O
;	O
return	O
bytes	int
;	O
}	O
void	O
tty_clear	()->(void)
(	O
)	O
{	O
tty_io_clear	()->(void)
(	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
tty_scr	*(char)
,	O
'\0'	O
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
tty_atr	*(char)
,	O
'\0'	O
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
tty_prev_scr	*(char)
,	O
'\0'	O
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
tty_prev_atr	*(char)
,	O
'\0'	O
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
tty_cursor_x	int
=	O
0	int
;	O
tty_cursor_y	int
=	O
0	int
;	O
}	O
void	O
tty_fill	()->(void)
(	O
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
tty_scr	*(char)
,	O
' '	O
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
tty_atr	*(char)
,	O
tty_current_attribute	char
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
tty_touch	()->(void)
(	O
)	O
;	O
}	O
void	O
tty_touch	()->(void)
(	O
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
tty_prev_scr	*(char)
,	O
'\0'	O
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
}	O
static	O
void	O
tty_io_goto	(int,int)->(void)
(	O
y	int
,	O
x	int
)	O
int	O
y	int
,	O
x	int
;	O
{	O
if	O
(	O
TTY_MS_FLAG	O
==	O
0	int
)	O
tty_defaults	()->(void)
(	O
)	O
;	O
if	O
(	O
x	int
<	O
0	int
||	O
x	int
>=	O
tty_columns	int
||	O
y	int
<	O
0	int
||	O
y	int
>=	O
tty_lines	int
)	O
tputs	(*(char),int,*(()->(int)))->(int)
(	O
tgoto	(*(char),int,int)->(*(char))
(	O
TTY_CURSOR_MOVE	O
,	O
tty_columns	int
-	O
1	int
,	O
tty_lines	int
-	O
1	int
)	O
,	O
1	int
,	O
tty_writec	(int)->(int)
)	O
;	O
else	O
tputs	(*(char),int,*(()->(int)))->(int)
(	O
tgoto	(*(char),int,int)->(*(char))
(	O
TTY_CURSOR_MOVE	O
,	O
x	int
,	O
y	int
)	O
,	O
1	int
,	O
tty_writec	(int)->(int)
)	O
;	O
}	O
static	O
void	O
tty_io_foreground	(int)->(void)
(	O
color	int
)	O
int	O
color	int
;	O
{	O
char	O
str	*(char)
[	O
16	int
]	O
;	O
if	O
(	O
fg_cache	int
==	O
VALID_CACHE	int
&&	O
color	int
==	O
TTY_IO_FOREGROUND	O
)	O
return	O
;	O
if	O
(	O
AnsiColors	int
==	O
ON	int
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
str	*(char)
,	O
ansi_foreground	array(char)
,	O
sizeof	O
(	O
ansi_foreground	array(char)
)	O
)	O
;	O
str	*(char)
[	O
3	int
]	O
+=	O
color	int
;	O
tty_writes	(*(char),int)->(int)
(	O
str	*(char)
,	O
sizeof	O
(	O
ansi_foreground	array(char)
)	O
)	O
;	O
}	O
else	O
tty_io_reversevid	(int)->(void)
(	O
color	int
!=	O
WHITE	int
)	O
;	O
fg_cache	int
=	O
VALID_CACHE	int
;	O
TTY_IO_SET_FOREGROUND	O
(	O
color	int
)	O
;	O
}	O
static	O
void	O
tty_io_background	(int)->(void)
(	O
color	int
)	O
int	O
color	int
;	O
{	O
char	O
str	*(char)
[	O
16	int
]	O
;	O
if	O
(	O
bg_cache	int
==	O
VALID_CACHE	int
&&	O
color	int
==	O
TTY_IO_BACKGROUND	O
)	O
return	O
;	O
if	O
(	O
AnsiColors	int
==	O
ON	int
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
str	*(char)
,	O
ansi_background	array(char)
,	O
sizeof	O
(	O
ansi_background	array(char)
)	O
)	O
;	O
str	*(char)
[	O
3	int
]	O
+=	O
color	int
;	O
tty_writes	(*(char),int)->(int)
(	O
str	*(char)
,	O
sizeof	O
(	O
ansi_background	array(char)
)	O
)	O
;	O
}	O
else	O
tty_io_reversevid	(int)->(void)
(	O
color	int
!=	O
BLACK	int
)	O
;	O
bg_cache	int
=	O
VALID_CACHE	int
;	O
TTY_IO_SET_BACKGROUND	O
(	O
color	int
)	O
;	O
}	O
static	O
void	O
tty_io_brightness	(int)->(void)
(	O
status	int
)	O
int	O
status	int
;	O
{	O
if	O
(	O
br_cache	int
==	O
VALID_CACHE	int
&&	O
status	int
==	O
TTY_IO_BRIGHTNESS	O
)	O
return	O
;	O
if	O
(	O
status	int
==	O
ON	int
)	O
{	O
if	O
(	O
TTY_BRIGHT_ON	O
)	O
tputs	(*(char),int,*(()->(int)))->(int)
(	O
TTY_BRIGHT_ON	O
,	O
1	int
,	O
tty_writec	(int)->(int)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
TTY_ATTRIBUTES_OFF	O
)	O
tputs	(*(char),int,*(()->(int)))->(int)
(	O
TTY_ATTRIBUTES_OFF	O
,	O
1	int
,	O
tty_writec	(int)->(int)
)	O
;	O
fg_cache	int
=	O
INVALID_CACHE	int
;	O
bg_cache	int
=	O
INVALID_CACHE	int
;	O
TTY_IO_SET_BRIGHTNESS	O
(	O
OFF	int
)	O
;	O
if	O
(	O
TTY_IO_REVERSEVID	O
==	O
ON	int
)	O
{	O
rv_cache	int
=	O
INVALID_CACHE	int
;	O
tty_io_reversevid	(int)->(void)
(	O
ON	int
)	O
;	O
}	O
}	O
br_cache	int
=	O
VALID_CACHE	int
;	O
TTY_IO_SET_BRIGHTNESS	O
(	O
status	int
)	O
;	O
}	O
static	O
void	O
tty_io_reversevid	(int)->(void)
(	O
status	int
)	O
int	O
status	int
;	O
{	O
if	O
(	O
rv_cache	int
==	O
VALID_CACHE	int
&&	O
status	int
==	O
TTY_IO_REVERSEVID	O
)	O
return	O
;	O
if	O
(	O
status	int
==	O
ON	int
)	O
{	O
if	O
(	O
TTY_REVERSE_ON	O
)	O
tputs	(*(char),int,*(()->(int)))->(int)
(	O
TTY_REVERSE_ON	O
,	O
1	int
,	O
tty_writec	(int)->(int)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
TTY_ATTRIBUTES_OFF	O
)	O
tputs	(*(char),int,*(()->(int)))->(int)
(	O
TTY_ATTRIBUTES_OFF	O
,	O
1	int
,	O
tty_writec	(int)->(int)
)	O
;	O
fg_cache	int
=	O
INVALID_CACHE	int
;	O
bg_cache	int
=	O
INVALID_CACHE	int
;	O
TTY_IO_SET_REVERSEVID	O
(	O
OFF	int
)	O
;	O
if	O
(	O
TTY_IO_BRIGHTNESS	O
==	O
ON	int
)	O
{	O
br_cache	int
=	O
INVALID_CACHE	int
;	O
tty_io_brightness	(int)->(void)
(	O
ON	int
)	O
;	O
}	O
}	O
rv_cache	int
=	O
VALID_CACHE	int
;	O
TTY_IO_SET_REVERSEVID	O
(	O
status	int
)	O
;	O
}	O
static	O
void	O
tty_io_colors	(int)->(void)
(	O
attributes	int
)	O
int	O
attributes	int
;	O
{	O
tty_io_brightness	(int)->(void)
(	O
_TTY_BRIGHTNESS	O
(	O
attributes	int
)	O
)	O
;	O
tty_io_foreground	(int)->(void)
(	O
_TTY_FOREGROUND	O
(	O
attributes	int
)	O
)	O
;	O
tty_io_background	(int)->(void)
(	O
_TTY_BACKGROUND	O
(	O
attributes	int
)	O
)	O
;	O
}	O
void	O
tty_goto	(int,int)->(void)
(	O
y	int
,	O
x	int
)	O
int	O
y	int
,	O
x	int
;	O
{	O
tty_cursor_y	int
=	O
y	int
;	O
tty_cursor_x	int
=	O
x	int
;	O
}	O
void	O
tty_get_cursor	(*(int),*(int))->(void)
(	O
y	int
,	O
x	int
)	O
int	O
*	O
y	int
,	O
*	O
x	int
;	O
{	O
*	O
y	int
=	O
tty_cursor_y	int
;	O
*	O
x	int
=	O
tty_cursor_x	int
;	O
}	O
void	O
tty_foreground	(int)->(void)
(	O
color	int
)	O
int	O
color	int
;	O
{	O
TTY_SET_FOREGROUND	O
(	O
color	int
)	O
;	O
}	O
void	O
tty_background	(int)->(void)
(	O
color	int
)	O
int	O
color	int
;	O
{	O
TTY_SET_BACKGROUND	O
(	O
color	int
)	O
;	O
}	O
void	O
tty_brightness	(int)->(void)
(	O
status	int
)	O
int	O
status	int
;	O
{	O
TTY_SET_BRIGHTNESS	O
(	O
status	int
)	O
;	O
}	O
void	O
tty_reversevid	(int)->(void)
(	O
status	int
)	O
int	O
status	int
;	O
{	O
TTY_SET_REVERSEVID	O
(	O
status	int
)	O
;	O
}	O
void	O
tty_colors	(int,int,int)->(void)
(	O
brightness	int
,	O
foreground	int
,	O
background	int
)	O
int	O
brightness	int
,	O
foreground	int
,	O
background	int
;	O
{	O
tty_brightness	(int)->(void)
(	O
brightness	int
)	O
;	O
tty_foreground	(int)->(void)
(	O
foreground	int
)	O
;	O
tty_background	(int)->(void)
(	O
background	int
)	O
;	O
}	O
void	O
tty_beep	()->(void)
(	O
)	O
{	O
tty_writec	(int)->(int)
(	O
7	int
)	O
;	O
tty_flush	()->(void)
(	O
)	O
;	O
}	O
void	O
tty_cursor	(int)->(void)
(	O
status	int
)	O
int	O
status	int
;	O
{	O
if	O
(	O
status	int
)	O
{	O
if	O
(	O
TTY_CURSOR_ON	O
)	O
tputs	(*(char),int,*(()->(int)))->(int)
(	O
TTY_CURSOR_ON	O
,	O
1	int
,	O
tty_writec	(int)->(int)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
TTY_CURSOR_OFF	O
)	O
tputs	(*(char),int,*(()->(int)))->(int)
(	O
TTY_CURSOR_OFF	O
,	O
1	int
,	O
tty_writec	(int)->(int)
)	O
;	O
}	O
}	O
void	O
tty_save	(*(char))->(void)
(	O
status	int
)	O
tty_status_t	char
*	O
status	int
;	O
{	O
*	O
status	int
=	O
tty_current_attribute	char
;	O
}	O
void	O
tty_restore	(*(char))->(void)
(	O
status	int
)	O
tty_status_t	char
*	O
status	int
;	O
{	O
tty_current_attribute	char
=	O
*	O
status	int
;	O
}	O
void	O
tty_defaults	()->(void)
(	O
)	O
{	O
if	O
(	O
AnsiColors	int
==	O
ON	int
)	O
tty_writes	(*(char),int)->(int)
(	O
ansi_defaults	array(char)
,	O
sizeof	O
(	O
ansi_defaults	array(char)
)	O
)	O
;	O
if	O
(	O
TTY_ATTRIBUTES_OFF	O
)	O
tputs	(*(char),int,*(()->(int)))->(int)
(	O
TTY_ATTRIBUTES_OFF	O
,	O
1	int
,	O
tty_writec	(int)->(int)
)	O
;	O
fg_cache	int
=	O
INVALID_CACHE	int
;	O
bg_cache	int
=	O
INVALID_CACHE	int
;	O
br_cache	int
=	O
INVALID_CACHE	int
;	O
rv_cache	int
=	O
INVALID_CACHE	int
;	O
}	O
static	O
int	O
tty_extract_key	()->(int)
(	O
)	O
{	O
int	O
key	int
=	O
keybuf	array(char)
[	O
keyindex	int
]	O
;	O
if	O
(	O
key	int
&	O
0x80	int
)	O
{	O
keybuf	array(char)
[	O
keyindex	int
]	O
&=	O
0x7F	int
;	O
return	O
key_ESC	int
;	O
}	O
keyno	int
--	O
;	O
keyindex	int
++	O
;	O
return	O
key	int
;	O
}	O
int	O
tty_getc	()->(int)
(	O
)	O
{	O
service_pending_signals	()->(void)
(	O
)	O
;	O
if	O
(	O
keyno	int
)	O
return	O
tty_extract_key	()->(int)
(	O
)	O
;	O
tty_set_interrupt_char	(int)->(void)
(	O
-	O
1	int
)	O
;	O
signals	(int)->(void)
(	O
ON	int
)	O
;	O
keyindex	int
=	O
0	int
;	O
while	O
(	O
(	O
keyno	int
=	O
tty_read	(*(char),int)->(int)
(	O
keybuf	array(char)
,	O
1024	int
)	O
)	O
<	O
0	int
)	O
;	O
signals	(int)->(void)
(	O
OFF	int
)	O
;	O
tty_set_interrupt_char	(int)->(void)
(	O
key_INTERRUPT	O
)	O
;	O
return	O
keyno	int
?	O
tty_extract_key	()->(int)
(	O
)	O
:	O
-	O
1	int
;	O
}	O
void	O
tty_key_list_insert_sequence	(*(*(struct(*(char),*(struct`),*(void)))),*(char),*(void))->(void)
(	O
key	int
,	O
key_seq	*(char)
,	O
aux_data	*(void)
)	O
tty_key_t	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
*	O
*	O
key	int
;	O
unsigned	O
char	O
*	O
key_seq	*(char)
;	O
void	O
*	O
aux_data	*(void)
;	O
{	O
tty_key_t	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
*	O
new_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
;	O
new_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
=	O
(	O
tty_key_t	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
tty_key_t	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
)	O
)	O
;	O
new_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
->	O
key_seq	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
xstrdup	(*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
key_seq	*(char)
)	O
;	O
new_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
->	O
aux_data	*(void)
=	O
aux_data	*(void)
;	O
new_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
=	O
*	O
key	int
;	O
*	O
key	int
=	O
new_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
;	O
}	O
void	O
tty_key_list_insert	(*(char),*(void))->(void)
(	O
key_seq	*(char)
,	O
aux_data	*(void)
)	O
unsigned	O
char	O
*	O
key_seq	*(char)
;	O
void	O
*	O
aux_data	*(void)
;	O
{	O
static	O
tty_key_t	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
*	O
*	O
key	int
=	O
NULL	O
;	O
if	O
(	O
*	O
key_seq	*(char)
==	O
0	int
)	O
return	O
;	O
if	O
(	O
key	int
==	O
NULL	O
||	O
strcmp	(*(char),*(char))->(int)
(	O
(	O
char	O
*	O
)	O
key_seq	*(char)
,	O
(	O
char	O
*	O
)	O
(	O
*	O
key	int
)	O
->	O
key_seq	*(char)
)	O
<=	O
0	int
)	O
key	int
=	O
&	O
key_list_head	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
;	O
for	O
(	O
;	O
*	O
key	int
;	O
key	int
=	O
&	O
(	O
*	O
key	int
)	O
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
(	O
char	O
*	O
)	O
key_seq	*(char)
,	O
(	O
char	O
*	O
)	O
(	O
*	O
key	int
)	O
->	O
key_seq	*(char)
)	O
<=	O
0	int
)	O
{	O
tty_key_list_insert_sequence	(*(*(struct(*(char),*(struct`),*(void)))),*(char),*(void))->(void)
(	O
key	int
,	O
key_seq	*(char)
,	O
aux_data	*(void)
)	O
;	O
return	O
;	O
}	O
tty_key_list_insert_sequence	(*(*(struct(*(char),*(struct`),*(void)))),*(char),*(void))->(void)
(	O
key	int
,	O
key_seq	*(char)
,	O
aux_data	*(void)
)	O
;	O
}	O
void	O
tty_key_search_restart	()->(void)
(	O
)	O
{	O
current_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
=	O
key_list_head	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
;	O
}	O
tty_key_t	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
*	O
tty_key_search	(*(char))->(*(struct(*(char),*(struct(*`,*`,*`)),*(void))))
(	O
key_seq	*(char)
)	O
char	O
*	O
key_seq	*(char)
;	O
{	O
int	O
cmp	int
;	O
if	O
(	O
current_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
;	O
current_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
;	O
current_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
=	O
current_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
)	O
{	O
cmp	int
=	O
strcmp	(*(char),*(char))->(int)
(	O
key_seq	*(char)
,	O
(	O
char	O
*	O
)	O
current_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
->	O
key_seq	*(char)
)	O
;	O
if	O
(	O
cmp	int
==	O
0	int
)	O
return	O
current_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
;	O
if	O
(	O
cmp	int
<	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
current_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
==	O
NULL	O
||	O
strncmp	(*(char),*(char),long)->(int)
(	O
key_seq	*(char)
,	O
(	O
char	O
*	O
)	O
current_key	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
->	O
key_seq	*(char)
,	O
strlen	(*(char))->(long)
(	O
key_seq	*(char)
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
tty_key_t	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
*	O
)	O
-	O
1	int
;	O
else	O
return	O
NULL	O
;	O
}	O
void	O
tty_key_print	(*(char))->(void)
(	O
key_seq	*(char)
)	O
char	O
*	O
key_seq	*(char)
;	O
{	O
tty_status_t	char
tty_status	char
;	O
char	O
*	O
typed	*(char)
=	O
"Keys typed so far: "	*(char)
;	O
char	O
*	O
incomplete	*(char)
=	O
" "	*(char)
;	O
char	O
*	O
spaces	*(char)
;	O
tty_save	(*(char))->(void)
(	O
&	O
tty_status	char
)	O
;	O
tty_goto	(int,int)->(void)
(	O
tty_lines	int
-	O
1	int
,	O
0	int
)	O
;	O
tty_background	(int)->(void)
(	O
WHITE	int
)	O
;	O
tty_foreground	(int)->(void)
(	O
BLACK	int
)	O
;	O
spaces	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
tty_columns	int
+	O
1	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
spaces	*(char)
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
spaces	*(char)
[	O
tty_columns	int
]	O
=	O
'\0'	O
;	O
tty_puts	(*(char),int)->(int)
(	O
spaces	*(char)
,	O
tty_columns	int
)	O
;	O
xfree	(*(void))->(void)
(	O
spaces	*(char)
)	O
;	O
tty_goto	(int,int)->(void)
(	O
tty_lines	int
-	O
1	int
,	O
0	int
)	O
;	O
tty_key_machine2human	(*(char))->(*(char))
(	O
key_seq	*(char)
)	O
;	O
tty_puts	(*(char),int)->(int)
(	O
typed	*(char)
,	O
strlen	(*(char))->(long)
(	O
typed	*(char)
)	O
)	O
;	O
tty_puts	(*(char),int)->(int)
(	O
(	O
char	O
*	O
)	O
keystr	array(char)
,	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
keystr	array(char)
)	O
)	O
;	O
tty_puts	(*(char),int)->(int)
(	O
incomplete	*(char)
,	O
strlen	(*(char))->(long)
(	O
incomplete	*(char)
)	O
)	O
;	O
tty_update	()->(void)
(	O
)	O
;	O
tty_restore	(*(char))->(void)
(	O
&	O
tty_status	char
)	O
;	O
}	O
tty_key_t	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
*	O
tty_get_key	(*(int))->(*(struct(*(char),*(struct(*`,*`,*`)),*(void))))
(	O
repeat_count	*(int)
)	O
int	O
*	O
repeat_count	*(int)
;	O
{	O
int	O
i	int
,	O
c	int
;	O
tty_key_t	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
*	O
key	int
=	O
NULL	O
;	O
while	O
(	O
(	O
c	int
=	O
tty_getc	()->(int)
(	O
)	O
)	O
==	O
-	O
1	int
)	O
;	O
if	O
(	O
repeat_count	*(int)
)	O
*	O
repeat_count	*(int)
=	O
1	int
;	O
if	O
(	O
c	int
==	O
0	int
)	O
c	int
=	O
0xff	int
;	O
if	O
(	O
tty_kbdmode	int
==	O
TTY_RESTRICTED_INPUT	int
)	O
{	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
'\r'	O
)	O
c	int
=	O
key_ENTER	int
;	O
if	O
(	O
isprint	(int)->(int)
(	O
c	int
)	O
||	O
c	int
==	O
key_INTERRUPT	O
)	O
{	O
default_key	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
.	O
key_seq	*(char)
[	O
0	int
]	O
=	O
c	int
;	O
default_key	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
.	O
key_seq	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
&	O
default_key	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
;	O
}	O
}	O
partial	int
=	O
0	int
;	O
key_on_display	int
=	O
0	int
;	O
tty_key_search_restart	()->(void)
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAX_KEY_LENGTH	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
c	int
==	O
0	int
)	O
c	int
=	O
0xff	int
;	O
tty_key_seq	*(char)
[	O
i	int
]	O
=	O
c	int
;	O
tty_key_seq	*(char)
[	O
i	int
+	O
1	int
]	O
=	O
0	int
;	O
key	int
=	O
tty_key_search	(*(char))->(*(struct(*(char),*(struct(*`,*`,*`)),*(void))))
(	O
(	O
char	O
*	O
)	O
tty_key_seq	*(char)
)	O
;	O
if	O
(	O
key	int
==	O
(	O
tty_key_t	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
*	O
)	O
-	O
1	int
)	O
{	O
alarm	(int)->(int)
(	O
1	int
)	O
;	O
partial	int
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
key	int
)	O
{	O
if	O
(	O
partial	int
)	O
{	O
}	O
break	O
;	O
}	O
if	O
(	O
keyno	int
==	O
0	int
)	O
{	O
if	O
(	O
key_on_display	int
)	O
tty_key_print	(*(char))->(void)
(	O
(	O
char	O
*	O
)	O
tty_key_seq	*(char)
)	O
;	O
else	O
alarm	(int)->(int)
(	O
1	int
)	O
;	O
partial	int
=	O
1	int
;	O
}	O
while	O
(	O
(	O
c	int
=	O
tty_getc	()->(int)
(	O
)	O
)	O
==	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
i	int
==	O
MAX_KEY_LENGTH	int
)	O
{	O
alarm	(int)->(int)
(	O
1	int
)	O
;	O
partial	int
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
repeat_count	*(int)
)	O
while	O
(	O
keyno	int
>	O
i	int
&&	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
tty_key_seq	*(char)
,	O
&	O
keybuf	array(char)
[	O
keyindex	int
]	O
,	O
i	int
+	O
1	int
)	O
==	O
0	int
)	O
)	O
{	O
keyindex	int
+=	O
i	int
+	O
1	int
;	O
keyno	int
-=	O
i	int
+	O
1	int
;	O
(	O
*	O
repeat_count	*(int)
)	O
++	O
;	O
}	O
alarm	(int)->(int)
(	O
1	int
)	O
;	O
partial	int
=	O
0	int
;	O
return	O
key	int
;	O
}	O
void	O
tty_key_print_async	()->(void)
(	O
)	O
{	O
if	O
(	O
partial	int
)	O
{	O
tty_key_print	(*(char))->(void)
(	O
(	O
char	O
*	O
)	O
tty_key_seq	*(char)
)	O
;	O
key_on_display	int
=	O
1	int
;	O
}	O
}	O
char	O
*	O
tty_get_previous_key_seq	()->(*(char))
(	O
)	O
{	O
return	O
(	O
char	O
*	O
)	O
tty_key_seq	*(char)
;	O
}	O
void	O
tty_resize	()->(void)
(	O
)	O
{	O
char	O
*	O
env	*(char)
;	O
char	O
buf	*(char)
[	O
32	int
]	O
;	O
int	O
shell_lines	int
=	O
0	int
,	O
shell_columns	int
=	O
0	int
;	O
int	O
termcap_lines	int
=	O
0	int
,	O
termcap_columns	int
=	O
0	int
;	O
struct	O
winsize	struct(short,short,short,short)
winsz	struct(short,short,short,short)
;	O
int	O
winsz_lines	int
=	O
0	int
,	O
winsz_columns	int
=	O
0	int
;	O
if	O
(	O
ioctl	(int,long)->(int)
(	O
TTY_OUTPUT	int
,	O
TIOCGWINSZ	int
,	O
&	O
winsz	struct(short,short,short,short)
)	O
==	O
0	int
)	O
if	O
(	O
winsz	struct(short,short,short,short)
.	O
ws_col	short
&&	O
winsz	struct(short,short,short,short)
.	O
ws_row	short
)	O
{	O
winsz_columns	int
=	O
winsz	struct(short,short,short,short)
.	O
ws_col	short
;	O
winsz_lines	int
=	O
winsz	struct(short,short,short,short)
.	O
ws_row	short
;	O
}	O
if	O
(	O
(	O
env	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"COLUMNS"	*(char)
)	O
)	O
)	O
sscanf	(*(char),*(char))->(int)
(	O
env	*(char)
,	O
"%d"	*(char)
,	O
&	O
shell_columns	int
)	O
;	O
if	O
(	O
(	O
env	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"LINES"	*(char)
)	O
)	O
)	O
sscanf	(*(char),*(char))->(int)
(	O
env	*(char)
,	O
"%d"	*(char)
,	O
&	O
shell_lines	int
)	O
;	O
termcap_columns	int
=	O
TTY_COLUMNS	O
;	O
termcap_lines	int
=	O
TTY_LINES	O
;	O
if	O
(	O
columns_ok	O
(	O
winsz_columns	int
)	O
)	O
tty_columns	int
=	O
winsz_columns	int
;	O
else	O
{	O
if	O
(	O
columns_ok	O
(	O
shell_columns	int
)	O
)	O
tty_columns	int
=	O
shell_columns	int
;	O
else	O
if	O
(	O
columns_ok	O
(	O
termcap_columns	int
)	O
)	O
tty_columns	int
=	O
termcap_columns	int
;	O
else	O
tty_columns	int
=	O
80	int
;	O
}	O
if	O
(	O
lines_ok	O
(	O
winsz_lines	int
)	O
)	O
tty_lines	int
=	O
winsz_lines	int
;	O
else	O
{	O
if	O
(	O
lines_ok	O
(	O
shell_lines	int
)	O
)	O
tty_lines	int
=	O
shell_lines	int
;	O
else	O
if	O
(	O
lines_ok	O
(	O
termcap_lines	int
)	O
)	O
tty_lines	int
=	O
termcap_lines	int
;	O
else	O
tty_lines	int
=	O
24	int
;	O
}	O
assert	O
(	O
tty_lines	int
!=	O
0	int
)	O
;	O
assert	O
(	O
tty_columns	int
!=	O
0	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d"	*(char)
,	O
tty_lines	int
)	O
;	O
xsetenv	(*(char),*(char))->(int)
(	O
"LINES"	*(char)
,	O
buf	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d"	*(char)
,	O
tty_columns	int
)	O
;	O
xsetenv	(*(char),*(char))->(int)
(	O
"COLUMNS"	*(char)
,	O
buf	*(char)
)	O
;	O
if	O
(	O
tty_scr	*(char)
)	O
xfree	(*(void))->(void)
(	O
tty_scr	*(char)
)	O
;	O
if	O
(	O
tty_atr	*(char)
)	O
xfree	(*(void))->(void)
(	O
tty_atr	*(char)
)	O
;	O
if	O
(	O
tty_prev_scr	*(char)
)	O
xfree	(*(void))->(void)
(	O
tty_prev_scr	*(char)
)	O
;	O
if	O
(	O
tty_prev_atr	*(char)
)	O
xfree	(*(void))->(void)
(	O
tty_prev_atr	*(char)
)	O
;	O
tty_scr	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
tty_columns	int
*	O
tty_lines	int
,	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
tty_atr	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
tty_columns	int
*	O
tty_lines	int
,	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
tty_prev_scr	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
tty_columns	int
*	O
tty_lines	int
,	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
tty_prev_atr	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
tty_columns	int
*	O
tty_lines	int
,	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
}	O
int	O
vcs_io	(*(char),int)->(int)
(	O
buf	*(char)
,	O
op	int
)	O
char	O
*	O
buf	*(char)
;	O
int	O
op	int
;	O
{	O
ssize_t	long
(	O
*	O
fn	*(()->(long))
)	O
(	O
)	O
;	O
int	O
vcsfd	int
,	O
flag	int
;	O
char	O
vcs_name	array(char)
[	O
16	int
]	O
;	O
char	O
vcsa_name	array(char)
[	O
16	int
]	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
vcs_name	array(char)
,	O
"/dev/vcsXX"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
vcsa_name	array(char)
,	O
"/dev/vcsaXX"	*(char)
)	O
;	O
if	O
(	O
op	int
==	O
VCS_READ	int
)	O
{	O
flag	int
=	O
O_RDONLY	int
;	O
fn	*(()->(long))
=	O
read	*((*(void),*(char),long)->(long))
;	O
}	O
else	O
{	O
flag	int
=	O
O_WRONLY	int
;	O
fn	*(()->(long))
=	O
write	*((*(void),*(char),long)->(long))
;	O
if	O
(	O
vcs_is_monochrome	int
)	O
goto	O
monochrome	O
;	O
}	O
vcs_is_monochrome	int
=	O
0	int
;	O
vcsa_name	array(char)
[	O
9	int
]	O
=	O
tty_device	*(char)
[	O
8	int
]	O
;	O
vcsa_name	array(char)
[	O
10	int
]	O
=	O
tty_device	*(char)
[	O
9	int
]	O
;	O
vcsfd	int
=	O
open	(*(char),int)->(int)
(	O
vcsa_name	array(char)
,	O
flag	int
)	O
;	O
if	O
(	O
vcsfd	int
!=	O
-	O
1	int
)	O
{	O
vcsa_label	O
:	O
(	O
*	O
fn	*(()->(long))
)	O
(	O
vcsfd	int
,	O
buf	*(char)
,	O
4	int
+	O
tty_lines	int
*	O
tty_columns	int
*	O
2	int
)	O
;	O
close	*((*(void))->(int))
(	O
vcsfd	int
)	O
;	O
if	O
(	O
op	int
==	O
VCS_WRITE	int
)	O
{	O
tty_io_goto	(int,int)->(void)
(	O
buf	*(char)
[	O
3	int
]	O
,	O
buf	*(char)
[	O
2	int
]	O
)	O
;	O
tty_flush	()->(void)
(	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
vcsa_name	array(char)
[	O
9	int
]	O
=	O
'0'	O
;	O
vcsa_name	array(char)
[	O
10	int
]	O
=	O
'\0'	O
;	O
vcsfd	int
=	O
open	(*(char),int)->(int)
(	O
vcsa_name	array(char)
,	O
flag	int
)	O
;	O
if	O
(	O
vcsfd	int
!=	O
-	O
1	int
)	O
goto	O
vcsa_label	O
;	O
monochrome	O
:	O
vcs_is_monochrome	int
=	O
1	int
;	O
if	O
(	O
op	int
==	O
VCS_WRITE	int
)	O
tty_clear	()->(void)
(	O
)	O
;	O
vcs_name	array(char)
[	O
8	int
]	O
=	O
tty_device	*(char)
[	O
8	int
]	O
;	O
vcs_name	array(char)
[	O
9	int
]	O
=	O
tty_device	*(char)
[	O
9	int
]	O
;	O
vcsfd	int
=	O
open	(*(char),int)->(int)
(	O
vcs_name	array(char)
,	O
flag	int
)	O
;	O
if	O
(	O
vcsfd	int
!=	O
-	O
1	int
)	O
{	O
vcs_label	O
:	O
(	O
*	O
fn	*(()->(long))
)	O
(	O
vcsfd	int
,	O
buf	*(char)
,	O
4	int
+	O
tty_lines	int
*	O
tty_columns	int
)	O
;	O
close	*((*(void))->(int))
(	O
vcsfd	int
)	O
;	O
if	O
(	O
op	int
==	O
VCS_WRITE	int
)	O
{	O
tty_io_goto	(int,int)->(void)
(	O
tty_lines	int
-	O
1	int
,	O
0	int
)	O
;	O
tty_flush	()->(void)
(	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
vcs_name	array(char)
[	O
8	int
]	O
=	O
'0'	O
;	O
vcs_name	array(char)
[	O
9	int
]	O
=	O
'\0'	O
;	O
vcsfd	int
=	O
open	(*(char),int)->(int)
(	O
vcs_name	array(char)
,	O
flag	int
)	O
;	O
if	O
(	O
vcsfd	int
!=	O
-	O
1	int
)	O
goto	O
vcs_label	O
;	O
return	O
0	int
;	O
}	O
void	O
tty_get_screen	(*(char))->(void)
(	O
buf	*(char)
)	O
char	O
*	O
buf	*(char)
;	O
{	O
if	O
(	O
LinuxConsole	int
)	O
vcs_read_ok	int
=	O
vcs_io	(*(char),int)->(int)
(	O
buf	*(char)
,	O
VCS_READ	int
)	O
;	O
}	O
void	O
tty_put_screen	(*(char))->(void)
(	O
buf	*(char)
)	O
char	O
*	O
buf	*(char)
;	O
{	O
tty_defaults	()->(void)
(	O
)	O
;	O
if	O
(	O
LinuxConsole	int
)	O
{	O
if	O
(	O
vcs_read_ok	int
)	O
{	O
tty_touch	()->(void)
(	O
)	O
;	O
if	O
(	O
vcs_io	(*(char),int)->(int)
(	O
buf	*(char)
,	O
VCS_WRITE	int
)	O
==	O
0	int
)	O
tty_clear	()->(void)
(	O
)	O
;	O
else	O
memset	(*(void),int,long)->(*(void))
(	O
tty_scr	*(char)
,	O
'\0'	O
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
}	O
else	O
tty_clear	()->(void)
(	O
)	O
;	O
}	O
else	O
tty_clear	()->(void)
(	O
)	O
;	O
}	O
int	O
tty_get_color_index	(*(char))->(int)
(	O
colorname	*(char)
)	O
char	O
*	O
colorname	*(char)
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
10	int
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
colors	array(*(char))
[	O
i	int
]	O
,	O
colorname	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
i	int
<	O
8	int
)	O
?	O
i	int
:	O
(	O
i	int
-	O
8	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
char	O
*	O
tty_get_symbol_key_seq	(*(char))->(*(char))
(	O
symbol	*(char)
)	O
char	O
*	O
symbol	*(char)
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
TTY_FIRST_SYMBOL_KEY	int
;	O
i	int
<	O
TTY_CAPABILITIES_USED	int
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tty_capability	array(struct(*(char),*(char),int,int,*(char)))
[	O
i	int
]	O
.	O
symbol	*(char)
,	O
symbol	*(char)
)	O
==	O
0	int
)	O
return	O
tty_capability	array(struct(*(char),*(char),int,int,*(char)))
[	O
i	int
]	O
.	O
string	*(char)
;	O
return	O
NULL	O
;	O
}	O
void	O
tty_get_capabilities	()->(void)
(	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
char	O
*	O
capability_buf	*(char)
,	O
*	O
tmp	*(char)
;	O
int	O
err	long
,	O
i	int
,	O
term_errors	int
=	O
0	int
;	O
char	O
*	O
termtype	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"TERM"	*(char)
)	O
;	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
TTY_OUTPUT	int
,	O
&	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
(	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_rdev	long
>>	O
8	int
)	O
==	O
LINUX_VC_MAJOR	int
)	O
LinuxConsole	int
=	O
1	int
;	O
else	O
LinuxConsole	int
=	O
0	int
;	O
if	O
(	O
termtype	*(char)
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: can't find the TERM environment variable, "	*(char)
,	O
g_program	*(char)
)	O
;	O
goto	O
switch_to_vt100	O
;	O
}	O
if	O
(	O
strlen	(*(char))->(long)
(	O
termtype	*(char)
)	O
>	O
63	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the TERM environment variable is too long, "	*(char)
,	O
g_program	*(char)
)	O
;	O
switch_to_vt100	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"trying vt100 ...\n"	*(char)
)	O
;	O
termtype	*(char)
=	O
vt100	array(char)
;	O
}	O
retry	O
:	O
err	long
=	O
tgetent	(*(void),*(char))->(int)
(	O
NULL	O
,	O
termtype	*(char)
)	O
;	O
if	O
(	O
err	long
==	O
-	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: can't find the %s database.\n"	*(char)
,	O
g_program	*(char)
,	O
term_database	array(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: check your %s environment variable ...\n"	*(char)
,	O
g_program	*(char)
,	O
term_env	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
err	long
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: can't find the terminal type %s in the %s database.\n"	*(char)
,	O
g_program	*(char)
,	O
termtype	*(char)
,	O
term_database	array(char)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
termtype	*(char)
,	O
"iris-ansi"	*(char)
)	O
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: trying ansi...\n"	*(char)
,	O
g_program	*(char)
)	O
;	O
termtype	*(char)
=	O
"ansi"	*(char)
;	O
goto	O
retry	O
;	O
}	O
if	O
(	O
tty_is_xterm	(*(char))->(int)
(	O
termtype	*(char)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: trying xterm...\n"	*(char)
,	O
g_program	*(char)
)	O
;	O
termtype	*(char)
=	O
"xterm"	*(char)
;	O
goto	O
retry	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
termtype	*(char)
,	O
"vt220"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
termtype	*(char)
,	O
"vt320"	*(char)
)	O
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: trying vt100...\n"	*(char)
,	O
g_program	*(char)
)	O
;	O
termtype	*(char)
=	O
"ansi"	*(char)
;	O
goto	O
retry	O
;	O
}	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
tty_type	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
termtype	*(char)
)	O
;	O
capability_buf	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
2048	int
)	O
;	O
tmp	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
TTY_PAD_CHAR_NAME	O
,	O
&	O
capability_buf	*(char)
)	O
;	O
PC	char
=	O
tmp	*(char)
?	O
*	O
tmp	*(char)
:	O
0	int
;	O
BC	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
TTY_LEFT_ONE_SPACE_NAME	O
,	O
&	O
capability_buf	*(char)
)	O
;	O
UP	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
TTY_UP_ONE_LINE_NAME	O
,	O
&	O
capability_buf	*(char)
)	O
;	O
if	O
(	O
BC	*(char)
==	O
NULL	O
||	O
UP	*(char)
==	O
NULL	O
)	O
BC	*(char)
=	O
UP	*(char)
=	O
NULL	O
;	O
TTY_ATTRIBUTES_OFF	O
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
TTY_ATTRIBUTES_OFF_NAME	O
,	O
&	O
capability_buf	*(char)
)	O
;	O
TTY_BRIGHT_ON	O
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
TTY_BRIGHT_ON_NAME	O
,	O
&	O
capability_buf	*(char)
)	O
;	O
TTY_REVERSE_ON	O
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
TTY_REVERSE_ON_NAME	O
,	O
&	O
capability_buf	*(char)
)	O
;	O
if	O
(	O
TTY_ATTRIBUTES_OFF	O
==	O
NULL	O
)	O
TTY_REVERSE_ON	O
=	O
TTY_BRIGHT_ON	O
=	O
NULL	O
;	O
TTY_STANDOUT_ON	O
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
TTY_STANDOUT_ON_NAME	O
,	O
&	O
capability_buf	*(char)
)	O
;	O
if	O
(	O
TTY_STANDOUT_ON	O
==	O
NULL	O
)	O
{	O
TTY_STANDOUT_ON	O
=	O
NULL	O
;	O
TTY_MS_FLAG	O
=	O
0	int
;	O
}	O
else	O
{	O
TTY_REVERSE_ON	O
=	O
TTY_STANDOUT_ON	O
;	O
TTY_MS_FLAG	O
=	O
tgetflag	(*(char))->(int)
(	O
TTY_MS_FLAG_NAME	O
)	O
;	O
}	O
TTY_MAGIC_COOKIE	O
=	O
tgetnum	(*(char))->(int)
(	O
TTY_MAGIC_COOKIE_NAME	O
)	O
;	O
if	O
(	O
TTY_MAGIC_COOKIE	O
>=	O
0	int
)	O
TTY_ATTRIBUTES_OFF	O
=	O
TTY_REVERSE_ON	O
=	O
TTY_BRIGHT_ON	O
=	O
NULL	O
;	O
TTY_COLUMNS	O
=	O
tgetnum	(*(char))->(int)
(	O
TTY_COLUMNS_NAME	O
)	O
;	O
TTY_LINES	O
=	O
tgetnum	(*(char))->(int)
(	O
TTY_LINES_NAME	O
)	O
;	O
TTY_CURSOR_OFF	O
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
TTY_CURSOR_OFF_NAME	O
,	O
&	O
capability_buf	*(char)
)	O
;	O
TTY_CURSOR_ON	O
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
TTY_CURSOR_ON_NAME	O
,	O
&	O
capability_buf	*(char)
)	O
;	O
if	O
(	O
TTY_CURSOR_OFF	O
==	O
NULL	O
||	O
TTY_CURSOR_ON	O
==	O
NULL	O
)	O
TTY_CURSOR_ON	O
=	O
TTY_CURSOR_OFF	O
=	O
NULL	O
;	O
TTY_CLEAR_SCREEN	O
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
TTY_CLEAR_SCREEN_NAME	O
,	O
&	O
capability_buf	*(char)
)	O
;	O
TTY_CURSOR_MOVE	O
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
TTY_CURSOR_MOVE_NAME	O
,	O
&	O
capability_buf	*(char)
)	O
;	O
TTY_START_CURSORAPP	O
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
TTY_START_CURSORAPP_NAME	O
,	O
&	O
capability_buf	*(char)
)	O
;	O
TTY_END_CURSORAPP	O
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
TTY_END_CURSORAPP_NAME	O
,	O
&	O
capability_buf	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
TTY_FIRST_SYMBOL_KEY	int
;	O
i	int
<	O
TTY_CAPABILITIES_USED	int
;	O
i	int
++	O
)	O
tty_capability	array(struct(*(char),*(char),int,int,*(char)))
[	O
i	int
]	O
.	O
string	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
tty_capability	array(struct(*(char),*(char),int,int,*(char)))
[	O
i	int
]	O
.	O
name	*(char)
,	O
&	O
capability_buf	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
TTY_CAPABILITIES_USED	int
;	O
i	int
++	O
)	O
if	O
(	O
tty_capability	array(struct(*(char),*(char),int,int,*(char)))
[	O
i	int
]	O
.	O
string	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
tty_capability	array(struct(*(char),*(char),int,int,*(char)))
[	O
i	int
]	O
.	O
required	int
)	O
{	O
term_errors	int
++	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: can't find the '%s' terminal capability.\n"	*(char)
,	O
g_program	*(char)
,	O
tty_capability	array(struct(*(char),*(char),int,int,*(char)))
[	O
i	int
]	O
.	O
name	*(char)
)	O
;	O
}	O
else	O
{	O
tty_capability	array(struct(*(char),*(char),int,int,*(char)))
[	O
i	int
]	O
.	O
string	*(char)
=	O
""	*(char)
;	O
}	O
}	O
if	O
(	O
term_errors	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %d errors. Your terminal is too dumb :-< .\n"	*(char)
,	O
g_program	*(char)
,	O
term_errors	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
void	O
tty_init	(int)->(void)
(	O
kbd_mode	int
)	O
int	O
kbd_mode	int
;	O
{	O
if	O
(	O
!	O
isatty	(int)->(int)
(	O
TTY_INPUT	int
)	O
||	O
!	O
isatty	(int)->(int)
(	O
TTY_OUTPUT	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: only stderr can be redirected.\n"	*(char)
,	O
g_program	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
tty_device	*(char)
=	O
ttyname	(int)->(*(char))
(	O
1	int
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: can't get terminal name.\n"	*(char)
,	O
g_program	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
tcgetattr	(int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
TTY_OUTPUT	int
,	O
&	O
old_term	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
default_key	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
.	O
key_seq	*(char)
=	O
tty_key_seq	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
64	int
)	O
;	O
default_key	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
.	O
aux_data	*(void)
=	O
NULL	O
;	O
default_key	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
.	O
next	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
=	O
NULL	O
;	O
tty_kbdmode	int
=	O
kbd_mode	int
;	O
tty_device_length	int
=	O
strlen	(*(char))->(long)
(	O
tty_device	*(char)
)	O
;	O
tty_get_capabilities	()->(void)
(	O
)	O
;	O
}	O
void	O
tty_update_title	(*(char))->(void)
(	O
string	*(char)
)	O
char	O
*	O
string	*(char)
;	O
{	O
if	O
(	O
tty_is_xterm	(*(char))->(int)
(	O
tty_type	*(char)
)	O
)	O
{	O
size_t	long
len	int
=	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
;	O
char	O
*	O
temp	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
128	int
+	O
len	int
+	O
1	int
)	O
;	O
char	O
*	O
printable_string	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
string	*(char)
)	O
;	O
toprintable	(*(char),long)->(void)
(	O
printable_string	*(char)
,	O
len	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
temp	*(char)
,	O
"%c]2;%s - %s%c"	*(char)
,	O
0x1b	int
,	O
PRODUCT	*(char)
,	O
printable_string	*(char)
,	O
0x07	int
)	O
;	O
if	O
(	O
128	int
+	O
(	O
int	O
)	O
len	int
>	O
2	int
*	O
tty_columns	int
)	O
{	O
temp	*(char)
[	O
2	int
*	O
tty_columns	int
]	O
=	O
0x07	int
;	O
temp	*(char)
[	O
2	int
*	O
tty_columns	int
+	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
xwrite	(int,*(char),long)->(int)
(	O
TTY_OUTPUT	int
,	O
temp	*(char)
,	O
strlen	(*(char))->(long)
(	O
temp	*(char)
)	O
)	O
;	O
xfree	(*(void))->(void)
(	O
printable_string	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
temp	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
static	O
int	O
tty_is_xterm	(*(char))->(int)
(	O
term	*(char)
)	O
char	O
*	O
term	*(char)
;	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
term	*(char)
,	O
"xterm"	*(char)
,	O
5	int
)	O
==	O
0	int
||	O
strncmp	(*(char),*(char),long)->(int)
(	O
term	*(char)
,	O
"rxvt"	*(char)
,	O
4	int
)	O
==	O
0	int
||	O
strncmp	(*(char),*(char),long)->(int)
(	O
term	*(char)
,	O
"iris-ansi"	*(char)
,	O
9	int
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
term	*(char)
,	O
"aixterm"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
term	*(char)
,	O
"Eterm"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
term	*(char)
,	O
"dtterm"	*(char)
)	O
==	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
