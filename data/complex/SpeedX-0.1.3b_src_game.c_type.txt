extern	O
World	O
*	O
world	*(int)
;	O
extern	O
int	O
factor	short
;	O
extern	O
int	O
bpp	int
;	O
extern	O
void	O
load_sprites	(*(int),*(int))->(void)
(	O
int	O
*	O
,	O
int	O
*	O
)	O
;	O
extern	O
int	O
CompletionType	int
;	O
extern	O
int	O
drawing	int
;	O
extern	O
int	O
player	int
;	O
void	O
refresh	(*(char),*(char),int,int)->(void)
(	O
char	O
*	O
buffer	*(char)
,	O
char	O
*	O
sky	*(char)
,	O
int	O
inv_radius	int
,	O
int	O
view	int
)	O
{	O
int	O
j	int
;	O
static	O
int	O
boo	int
=	O
1	int
;	O
static	O
int	O
road_dx	int
;	O
static	O
int	O
road_dy	int
;	O
static	O
int	O
depart_dx	int
;	O
static	O
int	O
depart_dy	int
;	O
static	O
int	O
angle	array(int)
[	O
2	int
]	O
=	O
{	O
256	int
,	O
256	int
}	O
;	O
if	O
(	O
boo	int
==	O
1	int
)	O
{	O
boo	int
=	O
0	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Sprites and Road Loading ..\n"	*(char)
)	O
;	O
load_sprites	(*(int),*(int))->(void)
(	O
&	O
dx	int
,	O
&	O
dy	int
)	O
;	O
Read_PNG	(*(*(char)),*(char),int,*(int),*(int))->(int)
(	O
&	O
depart	*(char)
,	O
"./road/depart.png"	*(char)
,	O
depth	int
,	O
&	O
depart_dx	int
,	O
&	O
depart_dy	int
)	O
;	O
Read_PNG	(*(*(char)),*(char),int,*(int),*(int))->(int)
(	O
&	O
border	*(char)
,	O
"./road/border.png"	*(char)
,	O
depth	int
,	O
&	O
road_dx	int
,	O
&	O
road_dy	int
)	O
;	O
switch	O
(	O
Road_type	int
)	O
{	O
case	O
0	int
:	O
Read_PNG	(*(*(char)),*(char),int,*(int),*(int))->(int)
(	O
&	O
road	*(char)
,	O
"./road/road1.png"	*(char)
,	O
depth	int
,	O
&	O
road_dx	int
,	O
&	O
road_dy	int
)	O
;	O
break	O
;	O
case	O
1	int
:	O
Read_PNG	(*(*(char)),*(char),int,*(int),*(int))->(int)
(	O
&	O
road	*(char)
,	O
"./road/road2.png"	*(char)
,	O
depth	int
,	O
&	O
road_dx	int
,	O
&	O
road_dy	int
)	O
;	O
world	*(int)
->	O
omega	O
[	O
0	int
]	O
--	O
;	O
world	*(int)
->	O
omega	O
[	O
1	int
]	O
--	O
;	O
world	*(int)
->	O
omega	O
[	O
2	int
]	O
--	O
;	O
world	*(int)
->	O
vrmax	O
[	O
0	int
]	O
+=	O
5	int
;	O
world	*(int)
->	O
vrmax	O
[	O
1	int
]	O
+=	O
5	int
;	O
world	*(int)
->	O
vrmax	O
[	O
2	int
]	O
+=	O
5	int
;	O
break	O
;	O
case	O
2	int
:	O
Read_PNG	(*(*(char)),*(char),int,*(int),*(int))->(int)
(	O
&	O
road	*(char)
,	O
"./road/road3.png"	*(char)
,	O
depth	int
,	O
&	O
road_dx	int
,	O
&	O
road_dy	int
)	O
;	O
dep_alea	int
=	O
1	int
;	O
world	*(int)
->	O
accel	O
[	O
0	int
]	O
++	O
;	O
world	*(int)
->	O
accel	O
[	O
1	int
]	O
++	O
;	O
world	*(int)
->	O
accel	O
[	O
2	int
]	O
++	O
;	O
break	O
;	O
}	O
}	O
angle	array(int)
[	O
view	int
]	O
+=	O
(	O
inv_radius	int
*	O
world	*(int)
->	O
Sorting	O
[	O
view	int
]	O
.	O
yvit	int
>>	O
(	O
SKY_TURN	int
+	O
ACCEL	int
)	O
)	O
;	O
while	O
(	O
angle	array(int)
[	O
view	int
]	O
<	O
0	int
)	O
{	O
angle	array(int)
[	O
view	int
]	O
+=	O
3	int
*	O
WIDTH	int
;	O
}	O
while	O
(	O
angle	array(int)
[	O
view	int
]	O
>=	O
3	int
*	O
WIDTH	int
)	O
{	O
angle	array(int)
[	O
view	int
]	O
-=	O
3	int
*	O
WIDTH	int
;	O
}	O
{	O
char	O
*	O
_buffer	*(char)
;	O
char	O
*	O
_sky	*(char)
;	O
_buffer	*(char)
=	O
buffer	*(char)
;	O
_sky	*(char)
=	O
sky	*(char)
;	O
_sky	*(char)
+=	O
angle	array(int)
[	O
view	int
]	O
*	O
factor	short
;	O
{	O
int	O
derive	int
=	O
0	int
;	O
derive	int
=	O
(	O
world	*(int)
->	O
Sorting	O
[	O
view	int
]	O
.	O
ypos	int
>>	O
6	int
)	O
;	O
derive	int
=	O
derive	int
%	O
(	O
64	int
*	O
LENGTH	int
)	O
;	O
derive	int
=	O
world	*(int)
->	O
curve	O
[	O
derive	int
]	O
;	O
_sky	*(char)
+=	O
6	int
*	O
(	O
HVISION	int
/	O
2	int
+	O
derive	int
)	O
*	O
factor	short
*	O
WIDTH	int
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
HEIGHT	int
-	O
HVISION	int
+	O
1	int
;	O
j	int
++	O
)	O
{	O
memcpy	O
(	O
(	O
char	O
*	O
)	O
_buffer	*(char)
,	O
(	O
char	O
*	O
)	O
(	O
_sky	*(char)
)	O
,	O
factor	short
*	O
WIDTH	int
)	O
;	O
_buffer	*(char)
+=	O
factor	short
*	O
WIDTH	int
;	O
_sky	*(char)
+=	O
6	int
*	O
factor	short
*	O
WIDTH	int
;	O
}	O
}	O
Draw_road	(*(char),int,int)->(void)
(	O
buffer	*(char)
,	O
view	int
,	O
world	*(int)
->	O
Sorting	O
[	O
view	int
]	O
.	O
xpos	int
>>	O
2	int
)	O
;	O
{	O
int	O
ii	int
,	O
jj	int
;	O
char	O
*	O
_im_	*(char)
;	O
{	O
unsigned	O
int	O
color	int
;	O
unsigned	O
ofs1	int
,	O
ofs2	int
,	O
ofs3	int
,	O
ofs4	int
;	O
color	int
=	O
rgb	()->(int)
(	O
255	int
,	O
0	int
,	O
0	int
)	O
;	O
ofs1	int
=	O
factor	short
*	O
(	O
1	int
+	O
WIDTH	int
)	O
;	O
ofs2	int
=	O
ofs1	int
+	O
factor	short
*	O
WIDTH	int
;	O
ofs3	int
=	O
ofs2	int
+	O
factor	short
*	O
WIDTH	int
;	O
ofs4	int
=	O
ofs3	int
+	O
factor	short
*	O
WIDTH	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
(	O
world	*(int)
->	O
Sorting	O
[	O
view	int
]	O
.	O
yvit	int
>>	O
(	O
ACCEL	int
)	O
)	O
+	O
20	int
;	O
ii	int
++	O
)	O
{	O
memcpy	O
(	O
&	O
buffer	*(char)
[	O
ofs1	int
]	O
,	O
&	O
color	int
,	O
factor	short
)	O
;	O
memcpy	O
(	O
&	O
buffer	*(char)
[	O
ofs2	int
]	O
,	O
&	O
color	int
,	O
factor	short
)	O
;	O
memcpy	O
(	O
&	O
buffer	*(char)
[	O
ofs3	int
]	O
,	O
&	O
color	int
,	O
factor	short
)	O
;	O
memcpy	O
(	O
&	O
buffer	*(char)
[	O
ofs4	int
]	O
,	O
&	O
color	int
,	O
factor	short
)	O
;	O
ofs1	int
+=	O
factor	short
;	O
ofs2	int
+=	O
factor	short
;	O
ofs3	int
+=	O
factor	short
;	O
ofs4	int
+=	O
factor	short
;	O
}	O
color	int
=	O
rgb	()->(int)
(	O
192	int
+	O
world	*(int)
->	O
Sorting	O
[	O
view	int
]	O
.	O
turn	int
*	O
8	int
,	O
0	int
,	O
0	int
)	O
;	O
ofs1	int
=	O
factor	short
*	O
(	O
1	int
+	O
5	int
*	O
WIDTH	int
)	O
;	O
ofs2	int
=	O
ofs1	int
+	O
factor	short
*	O
WIDTH	int
;	O
ofs3	int
=	O
ofs2	int
+	O
factor	short
*	O
WIDTH	int
;	O
ofs4	int
=	O
ofs3	int
+	O
factor	short
*	O
WIDTH	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
(	O
world	*(int)
->	O
Sorting	O
[	O
view	int
]	O
.	O
ypos	int
>>	O
10	int
)	O
%	O
(	O
64	int
*	O
LENGTH	int
)	O
;	O
ii	int
++	O
)	O
{	O
memcpy	O
(	O
&	O
buffer	*(char)
[	O
ofs1	int
]	O
,	O
&	O
color	int
,	O
factor	short
)	O
;	O
memcpy	O
(	O
&	O
buffer	*(char)
[	O
ofs2	int
]	O
,	O
&	O
color	int
,	O
factor	short
)	O
;	O
memcpy	O
(	O
&	O
buffer	*(char)
[	O
ofs3	int
]	O
,	O
&	O
color	int
,	O
factor	short
)	O
;	O
memcpy	O
(	O
&	O
buffer	*(char)
[	O
ofs4	int
]	O
,	O
&	O
color	int
,	O
factor	short
)	O
;	O
ofs1	int
+=	O
factor	short
;	O
ofs2	int
+=	O
factor	short
;	O
ofs3	int
+=	O
factor	short
;	O
ofs4	int
+=	O
factor	short
;	O
}	O
color	int
=	O
rgb	()->(int)
(	O
128	int
,	O
0	int
,	O
0	int
)	O
;	O
ofs1	int
=	O
factor	short
*	O
(	O
1	int
+	O
9	int
*	O
WIDTH	int
)	O
;	O
ofs2	int
=	O
ofs1	int
+	O
factor	short
*	O
WIDTH	int
;	O
ofs3	int
=	O
ofs2	int
+	O
factor	short
*	O
WIDTH	int
;	O
ofs4	int
=	O
ofs3	int
+	O
factor	short
*	O
WIDTH	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
(	O
world	*(int)
->	O
Sorting	O
[	O
1	int
]	O
.	O
ypos	int
>>	O
10	int
)	O
%	O
(	O
64	int
*	O
LENGTH	int
)	O
;	O
ii	int
++	O
)	O
{	O
memcpy	O
(	O
&	O
buffer	*(char)
[	O
ofs1	int
]	O
,	O
&	O
color	int
,	O
factor	short
)	O
;	O
memcpy	O
(	O
&	O
buffer	*(char)
[	O
ofs2	int
]	O
,	O
&	O
color	int
,	O
factor	short
)	O
;	O
memcpy	O
(	O
&	O
buffer	*(char)
[	O
ofs3	int
]	O
,	O
&	O
color	int
,	O
factor	short
)	O
;	O
memcpy	O
(	O
&	O
buffer	*(char)
[	O
ofs4	int
]	O
,	O
&	O
color	int
,	O
factor	short
)	O
;	O
ofs1	int
+=	O
factor	short
;	O
ofs2	int
+=	O
factor	short
;	O
ofs3	int
+=	O
factor	short
;	O
ofs4	int
+=	O
factor	short
;	O
}	O
}	O
_im_	*(char)
=	O
number	int
[	O
(	O
world	*(int)
->	O
Sorting	O
[	O
view	int
]	O
.	O
position	short
+	O
1	int
)	O
%	O
10	int
]	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
num_l	int
;	O
ii	int
++	O
)	O
{	O
for	O
(	O
jj	int
=	O
0	int
;	O
jj	int
<	O
num_v	int
;	O
jj	int
++	O
)	O
{	O
unsigned	O
int	O
color	int
=	O
0	int
;	O
unsigned	O
int	O
alpha	int
;	O
memcpy	O
(	O
&	O
color	int
,	O
&	O
_im_	*(char)
[	O
factor	short
*	O
(	O
jj	int
+	O
ii	int
*	O
num_v	int
)	O
]	O
,	O
factor	short
)	O
;	O
alpha	int
=	O
grey	()->(int)
(	O
color	int
)	O
;	O
if	O
(	O
alpha	int
>	O
64	int
)	O
memcpy	O
(	O
&	O
buffer	*(char)
[	O
factor	short
*	O
(	O
jj	int
+	O
(	O
3	int
*	O
WIDTH	int
)	O
/	O
4	int
+	O
ii	int
*	O
WIDTH	int
)	O
]	O
,	O
&	O
color	int
,	O
factor	short
)	O
;	O
}	O
}	O
if	O
(	O
world	*(int)
->	O
Sorting	O
[	O
player	int
]	O
.	O
position	short
+	O
1	int
>=	O
10	int
)	O
{	O
_im_	*(char)
=	O
number	int
[	O
(	O
world	*(int)
->	O
Sorting	O
[	O
player	int
]	O
.	O
position	short
+	O
1	int
)	O
/	O
10	int
]	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
num_l	int
;	O
ii	int
++	O
)	O
{	O
for	O
(	O
jj	int
=	O
0	int
;	O
jj	int
<	O
num_v	int
;	O
jj	int
++	O
)	O
{	O
unsigned	O
int	O
color	int
=	O
0	int
;	O
unsigned	O
int	O
alpha	int
;	O
memcpy	O
(	O
&	O
color	int
,	O
&	O
_im_	*(char)
[	O
factor	short
*	O
(	O
jj	int
+	O
ii	int
*	O
num_v	int
)	O
]	O
,	O
factor	short
)	O
;	O
alpha	int
=	O
grey	()->(int)
(	O
color	int
)	O
;	O
if	O
(	O
alpha	int
>	O
64	int
)	O
memcpy	O
(	O
&	O
buffer	*(char)
[	O
factor	short
*	O
(	O
jj	int
+	O
WIDTH	int
/	O
2	int
+	O
WIDTH	int
/	O
10	int
+	O
ii	int
*	O
WIDTH	int
)	O
]	O
,	O
&	O
color	int
,	O
factor	short
)	O
;	O
}	O
}	O
}	O
}	O
}	O
int	O
event_x	(*(union(int,struct(int,long,int,*(struct`),long),struct(int,long,int,*(struct`),long,long,long,long,int,int,int,int,int,int,int),struct(int,long,int,*(struct`),long,long,long,long,int,int,int,int,int,int,int),struct(int,long,int,*(struct`),long,long,long,long,int,int,int,int,int,char,int),struct(int,long,int,*(struct`),long,long,long,long,int,int,int,int,int,int,int,int,int),struct(int,long,int,*(struct`),long,int,int),struct(int,long,int,*(struct`),long,int,int,int,int,int),struct(int,long,int,*(struct`),long,int,int,int,int,int,int,int),struct(int,long,int,*(struct`),long,int,int),struct(int,long,int,*(struct`),long,int),struct(int,long,int,*(struct`),long,long,int,int,int,int,int,int),struct(int,long,int,*(struct`),long,long),struct(int,long,int,*(struct`),long,long,int),struct(int,long,int,*(struct`),long,long,int),struct(int,long,int,*(struct`),long,long),struct(int,long,int,*(struct`),long,long,long,int,int,int),struct(int,long,int,*(struct`),long,long,int,int,int,int,int,long,int),struct(int,long,int,*(struct`),long,long,int,int),struct(int,long,int,*(struct`),long,int,int),struct(int,long,int,*(struct`),long,long,int,int,int,int,int,long,int,long),struct(int,long,int,*(struct`),long,long,int),struct(int,long,int,*(struct`),long,long,int),struct(int,long,int,*(struct`),long,long,long,int),struct(int,long,int,*(struct`),long,long,long),struct(int,long,int,*(struct`),long,long,long,long,long,long),struct(int,long,int,*(struct`),long,long,long,long,long),struct(int,long,int,*(struct`),long,long,int,int),struct(int,long,int,*(struct`),long,long,int,union(array(char),array(short),array(long))),struct(int,long,int,*(struct`),long,int,int,int),struct(int,*(struct`),long,long,char,char,char),struct(int,long,int,*(struct`),long,array(char)),struct(int,long,int,*(struct`),int,int),struct(int,long,int,*(struct`),int,int,int,*(void)),array(long))))->(int)
(	O
XEvent	union(int,struct(int,long,int,*(struct),long),struct(int,long,int,*(struct),long,long,long,long,int,int,int,int,int,int,int),struct(int,long,int,*(struct),long,long,long,long,int,int,int,int,int,int,int),struct(int,long,int,*(struct),long,long,long,long,int,int,int,int,int,char,int),struct(int,long,int,*(struct),long,long,long,long,int,int,int,int,int,int,int,int,int),struct(int,long,int,*(struct),long,int,int),struct(int,long,int,*(struct),long,int,int,int,int,int),struct(int,long,int,*(struct),long,int,int,int,int,int,int,int),struct(int,long,int,*(struct),long,int,int),struct(int,long,int,*(struct),long,int),struct(int,long,int,*(struct),long,long,int,int,int,int,int,int),struct(int,long,int,*(struct),long,long),struct(int,long,int,*(struct),long,long,int),struct(int,long,int,*(struct),long,long,int),struct(int,long,int,*(struct),long,long),struct(int,long,int,*(struct),long,long,long,int,int,int),struct(int,long,int,*(struct),long,long,int,int,int,int,int,long,int),struct(int,long,int,*(struct),long,long,int,int),struct(int,long,int,*(struct),long,int,int),struct(int,long,int,*(struct),long,long,int,int,int,int,int,long,int,long),struct(int,long,int,*(struct),long,long,int),struct(int,long,int,*(struct),long,long,int),struct(int,long,int,*(struct),long,long,long,int),struct(int,long,int,*(struct),long,long,long),struct(int,long,int,*(struct),long,long,long,long,long,long),struct(int,long,int,*(struct),long,long,long,long,long),struct(int,long,int,*(struct),long,long,int,int),struct(int,long,int,*(struct),long,long,int,union(array(char),array(short),array(long))),struct(int,long,int,*(struct),long,int,int,int),struct(int,*(struct),long,long,char,char,char),struct(int,long,int,*(struct),long,array(char)),struct(int,long,int,*(struct),int,int),struct(int,long,int,*(struct),int,int,int,*(void)),array(long))
*	O
XEv	*(union(int,struct(int,long,int,*(struct),long),struct(int,long,int,*(struct),long,long,long,long,int,int,int,int,int,int,int),struct(int,long,int,*(struct),long,long,long,long,int,int,int,int,int,int,int),struct(int,long,int,*(struct),long,long,long,long,int,int,int,int,int,char,int),struct(int,long,int,*(struct),long,long,long,long,int,int,int,int,int,int,int,int,int),struct(int,long,int,*(struct),long,int,int),struct(int,long,int,*(struct),long,int,int,int,int,int),struct(int,long,int,*(struct),long,int,int,int,int,int,int,int),struct(int,long,int,*(struct),long,int,int),struct(int,long,int,*(struct),long,int),struct(int,long,int,*(struct),long,long,int,int,int,int,int,int),struct(int,long,int,*(struct),long,long),struct(int,long,int,*(struct),long,long,int),struct(int,long,int,*(struct),long,long,int),struct(int,long,int,*(struct),long,long),struct(int,long,int,*(struct),long,long,long,int,int,int),struct(int,long,int,*(struct),long,long,int,int,int,int,int,long,int),struct(int,long,int,*(struct),long,long,int,int),struct(int,long,int,*(struct),long,int,int),struct(int,long,int,*(struct),long,long,int,int,int,int,int,long,int,long),struct(int,long,int,*(struct),long,long,int),struct(int,long,int,*(struct),long,long,int),struct(int,long,int,*(struct),long,long,long,int),struct(int,long,int,*(struct),long,long,long),struct(int,long,int,*(struct),long,long,long,long,long,long),struct(int,long,int,*(struct),long,long,long,long,long),struct(int,long,int,*(struct),long,long,int,int),struct(int,long,int,*(struct),long,long,int,union(array(char),array(short),array(long))),struct(int,long,int,*(struct),long,int,int,int),struct(int,*(struct),long,long,char,char,char),struct(int,long,int,*(struct),long,array(char)),struct(int,long,int,*(struct),int,int),struct(int,long,int,*(struct),int,int,int,*(void)),array(long)))
)	O
{	O
int	O
pressure	int
=	O
0	int
;	O
while	O
(	O
XPending	(*(struct))->(int)
(	O
display	*(struct)
)	O
)	O
XNextEvent	(*(struct),*(union(int,struct(int,long,int,*(struct`),long),struct(int,long,int,*(struct`),long,long,long,long,int,int,int,int,int,int,int),struct(int,long,int,*(struct`),long,long,long,long,int,int,int,int,int,int,int),struct(int,long,int,*(struct`),long,long,long,long,int,int,int,int,int,char,int),struct(int,long,int,*(struct`),long,long,long,long,int,int,int,int,int,int,int,int,int),struct(int,long,int,*(struct`),long,int,int),struct(int,long,int,*(struct`),long,int,int,int,int,int),struct(int,long,int,*(struct`),long,int,int,int,int,int,int,int),struct(int,long,int,*(struct`),long,int,int),struct(int,long,int,*(struct`),long,int),struct(int,long,int,*(struct`),long,long,int,int,int,int,int,int),struct(int,long,int,*(struct`),long,long),struct(int,long,int,*(struct`),long,long,int),struct(int,long,int,*(struct`),long,long,int),struct(int,long,int,*(struct`),long,long),struct(int,long,int,*(struct`),long,long,long,int,int,int),struct(int,long,int,*(struct`),long,long,int,int,int,int,int,long,int),struct(int,long,int,*(struct`),long,long,int,int),struct(int,long,int,*(struct`),long,int,int),struct(int,long,int,*(struct`),long,long,int,int,int,int,int,long,int,long),struct(int,long,int,*(struct`),long,long,int),struct(int,long,int,*(struct`),long,long,int),struct(int,long,int,*(struct`),long,long,long,int),struct(int,long,int,*(struct`),long,long,long),struct(int,long,int,*(struct`),long,long,long,long,long,long),struct(int,long,int,*(struct`),long,long,long,long,long),struct(int,long,int,*(struct`),long,long,int,int),struct(int,long,int,*(struct`),long,long,int,union(array(char),array(short),array(long))),struct(int,long,int,*(struct`),long,int,int,int),struct(int,*(struct`),long,long,char,char,char),struct(int,long,int,*(struct`),long,array(char)),struct(int,long,int,*(struct`),int,int),struct(int,long,int,*(struct`),int,int,int,*(void)),array(long))))->(int)
(	O
display	*(struct)
,	O
XEv	*(union(int,struct(int,long,int,*(struct),long),struct(int,long,int,*(struct),long,long,long,long,int,int,int,int,int,int,int),struct(int,long,int,*(struct),long,long,long,long,int,int,int,int,int,int,int),struct(int,long,int,*(struct),long,long,long,long,int,int,int,int,int,char,int),struct(int,long,int,*(struct),long,long,long,long,int,int,int,int,int,int,int,int,int),struct(int,long,int,*(struct),long,int,int),struct(int,long,int,*(struct),long,int,int,int,int,int),struct(int,long,int,*(struct),long,int,int,int,int,int,int,int),struct(int,long,int,*(struct),long,int,int),struct(int,long,int,*(struct),long,int),struct(int,long,int,*(struct),long,long,int,int,int,int,int,int),struct(int,long,int,*(struct),long,long),struct(int,long,int,*(struct),long,long,int),struct(int,long,int,*(struct),long,long,int),struct(int,long,int,*(struct),long,long),struct(int,long,int,*(struct),long,long,long,int,int,int),struct(int,long,int,*(struct),long,long,int,int,int,int,int,long,int),struct(int,long,int,*(struct),long,long,int,int),struct(int,long,int,*(struct),long,int,int),struct(int,long,int,*(struct),long,long,int,int,int,int,int,long,int,long),struct(int,long,int,*(struct),long,long,int),struct(int,long,int,*(struct),long,long,int),struct(int,long,int,*(struct),long,long,long,int),struct(int,long,int,*(struct),long,long,long),struct(int,long,int,*(struct),long,long,long,long,long,long),struct(int,long,int,*(struct),long,long,long,long,long),struct(int,long,int,*(struct),long,long,int,int),struct(int,long,int,*(struct),long,long,int,union(array(char),array(short),array(long))),struct(int,long,int,*(struct),long,int,int,int),struct(int,*(struct),long,long,char,char,char),struct(int,long,int,*(struct),long,array(char)),struct(int,long,int,*(struct),int,int),struct(int,long,int,*(struct),int,int,int,*(void)),array(long)))
)	O
;	O
pressure	int
=	O
1	int
;	O
return	O
pressure	int
;	O
}	O
void	O
aff	(long)->(void)
(	O
Window	long
w	long
)	O
{	O
if	O
(	O
xim	*(struct(int,int,int,int,*(char),int,int,int,int,int,int,int,long,long,long,*(char),struct(*((*`,*`,int,int,int,*`,int,int,int,int)->(*`)),*((*`)->(int)),*((*`,int,int)->(long)),*((*`,int,int,long)->(int)),*((*`,int,int,int,int)->(*`)),*((*`,long)->(int)))))
!=	O
NULL	O
)	O
{	O
if	O
(	O
mit_shm	int
)	O
XShmPutImage	(*(struct),long,*(struct),*(struct(int,int,int,int,*(char),int,int,int,int,int,int,int,long,long,long,*(char),struct(*((*`,*`,int,int,int,*`,int,int,int,int)->(*`)),*((*`)->(int)),*((*`,int,int)->(long)),*((*`,int,int,long)->(int)),*((*`,int,int,int,int)->(*`)),*((*`,long)->(int))))),int,int,int,int,int,int,int)->(int)
(	O
display	*(struct)
,	O
w	long
,	O
gc	*(struct)
,	O
xim	*(struct(int,int,int,int,*(char),int,int,int,int,int,int,int,long,long,long,*(char),struct(*((*`,*`,int,int,int,*`,int,int,int,int)->(*`)),*((*`)->(int)),*((*`,int,int)->(long)),*((*`,int,int,long)->(int)),*((*`,int,int,int,int)->(*`)),*((*`,long)->(int)))))
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
WIDTH	int
,	O
HEIGHT	int
,	O
True	int
)	O
;	O
else	O
XPutImage	(*(struct),long,*(struct),*(struct(int,int,int,int,*(char),int,int,int,int,int,int,int,long,long,long,*(char),struct(*((*`,*`,int,int,int,*`,int,int,int,int)->(*`)),*((*`)->(int)),*((*`,int,int)->(long)),*((*`,int,int,long)->(int)),*((*`,int,int,int,int)->(*`)),*((*`,long)->(int))))),int,int,int,int,int,int)->(int)
(	O
display	*(struct)
,	O
w	long
,	O
gc	*(struct)
,	O
xim	*(struct(int,int,int,int,*(char),int,int,int,int,int,int,int,long,long,long,*(char),struct(*((*`,*`,int,int,int,*`,int,int,int,int)->(*`)),*((*`)->(int)),*((*`,int,int)->(long)),*((*`,int,int,long)->(int)),*((*`,int,int,int,int)->(*`)),*((*`,long)->(int)))))
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
WIDTH	int
,	O
HEIGHT	int
)	O
;	O
}	O
else	O
{	O
}	O
}	O
void	O
aff2	(long)->(void)
(	O
Window	long
w	long
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
tmp	int
,	O
tmp1	int
,	O
tmp2	int
,	O
tmp3	int
,	O
tmp4	int
;	O
tmp	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
HEIGHT	int
;	O
j	int
++	O
)	O
{	O
tmp1	int
=	O
factor	short
*	O
(	O
j	int
<<	O
1	int
)	O
*	O
(	O
WIDTH	int
*	O
2	int
)	O
;	O
tmp2	int
=	O
tmp1	int
+	O
factor	short
;	O
tmp3	int
=	O
tmp1	int
+	O
(	O
factor	short
*	O
(	O
WIDTH	int
*	O
2	int
)	O
)	O
;	O
tmp4	int
=	O
tmp3	int
+	O
factor	short
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
WIDTH	int
;	O
i	int
++	O
)	O
{	O
S_memcpy	()->(int)
(	O
&	O
screen_buffer2	*(char)
[	O
tmp1	int
]	O
,	O
&	O
screen_buffer	*(char)
[	O
tmp	int
]	O
,	O
factor	short
)	O
;	O
S_memcpy	()->(int)
(	O
&	O
screen_buffer2	*(char)
[	O
tmp2	int
]	O
,	O
&	O
screen_buffer	*(char)
[	O
tmp	int
]	O
,	O
factor	short
)	O
;	O
S_memcpy	()->(int)
(	O
&	O
screen_buffer2	*(char)
[	O
tmp3	int
]	O
,	O
&	O
screen_buffer	*(char)
[	O
tmp	int
]	O
,	O
factor	short
)	O
;	O
S_memcpy	()->(int)
(	O
&	O
screen_buffer2	*(char)
[	O
tmp4	int
]	O
,	O
&	O
screen_buffer	*(char)
[	O
tmp	int
]	O
,	O
factor	short
)	O
;	O
tmp	int
+=	O
factor	short
;	O
tmp1	int
+=	O
2	int
*	O
factor	short
;	O
tmp2	int
+=	O
2	int
*	O
factor	short
;	O
tmp3	int
+=	O
2	int
*	O
factor	short
;	O
tmp4	int
+=	O
2	int
*	O
factor	short
;	O
}	O
}	O
if	O
(	O
1	int
)	O
{	O
if	O
(	O
xim	*(struct(int,int,int,int,*(char),int,int,int,int,int,int,int,long,long,long,*(char),struct(*((*`,*`,int,int,int,*`,int,int,int,int)->(*`)),*((*`)->(int)),*((*`,int,int)->(long)),*((*`,int,int,long)->(int)),*((*`,int,int,int,int)->(*`)),*((*`,long)->(int)))))
!=	O
NULL	O
)	O
{	O
if	O
(	O
mit_shm	int
)	O
{	O
XShmPutImage	(*(struct),long,*(struct),*(struct(int,int,int,int,*(char),int,int,int,int,int,int,int,long,long,long,*(char),struct(*((*`,*`,int,int,int,*`,int,int,int,int)->(*`)),*((*`)->(int)),*((*`,int,int)->(long)),*((*`,int,int,long)->(int)),*((*`,int,int,int,int)->(*`)),*((*`,long)->(int))))),int,int,int,int,int,int,int)->(int)
(	O
display	*(struct)
,	O
w	long
,	O
gc	*(struct)
,	O
xim	*(struct(int,int,int,int,*(char),int,int,int,int,int,int,int,long,long,long,*(char),struct(*((*`,*`,int,int,int,*`,int,int,int,int)->(*`)),*((*`)->(int)),*((*`,int,int)->(long)),*((*`,int,int,long)->(int)),*((*`,int,int,int,int)->(*`)),*((*`,long)->(int)))))
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
WIDTH	int
*	O
2	int
,	O
HEIGHT	int
*	O
2	int
,	O
True	int
)	O
;	O
}	O
else	O
XPutImage	(*(struct),long,*(struct),*(struct(int,int,int,int,*(char),int,int,int,int,int,int,int,long,long,long,*(char),struct(*((*`,*`,int,int,int,*`,int,int,int,int)->(*`)),*((*`)->(int)),*((*`,int,int)->(long)),*((*`,int,int,long)->(int)),*((*`,int,int,int,int)->(*`)),*((*`,long)->(int))))),int,int,int,int,int,int)->(int)
(	O
display	*(struct)
,	O
w	long
,	O
gc	*(struct)
,	O
xim	*(struct(int,int,int,int,*(char),int,int,int,int,int,int,int,long,long,long,*(char),struct(*((*`,*`,int,int,int,*`,int,int,int,int)->(*`)),*((*`)->(int)),*((*`,int,int)->(long)),*((*`,int,int,long)->(int)),*((*`,int,int,int,int)->(*`)),*((*`,long)->(int)))))
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
WIDTH	int
*	O
2	int
,	O
HEIGHT	int
*	O
2	int
)	O
;	O
}	O
}	O
}	O
void	O
liberation	()->(void)
(	O
void	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
10	int
;	O
i	int
++	O
)	O
free	(*(void))->(void)
(	O
number	int
[	O
i	int
]	O
)	O
;	O
}	O
