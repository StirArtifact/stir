static	O
int	O
readPackageHeaders	(*(struct),*(struct(array(char),char,char,short,short,array(char),short,short,array(char))),*(*(struct)),*(*(struct)))->(int)
(	O
FD_t	*(struct)
fd	*(struct)
,	O
struct	O
rpmlead	struct(array(char),char,char,short,short,array(char),short,short,array(char))
*	O
leadPtr	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
,	O
Header	*(struct)
*	O
sigs	*(*(struct))
,	O
Header	*(struct)
*	O
hdrPtr	*(*(struct))
)	O
{	O
Header	*(struct)
hdrBlock	*(struct)
;	O
struct	O
rpmlead	struct(array(char),char,char,short,short,array(char),short,short,array(char))
leadBlock	struct(array(char),char,char,short,short,array(char),short,short,array(char))
;	O
Header	*(struct)
*	O
hdr	*(*(struct))
=	O
NULL	O
;	O
struct	O
rpmlead	struct(array(char),char,char,short,short,array(char),short,short,array(char))
*	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
;	O
char	O
*	O
defaultPrefix	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int_32	int
true	int
=	O
1	int
;	O
hdr	*(*(struct))
=	O
hdrPtr	*(*(struct))
?	O
hdrPtr	*(*(struct))
:	O
&	O
hdrBlock	*(struct)
;	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
=	O
leadPtr	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
?	O
leadPtr	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
:	O
&	O
leadBlock	struct(array(char),char,char,short,short,array(char),short,short,array(char))
;	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
Fileno	(*(struct))->(int)
(	O
fd	*(struct)
)	O
,	O
&	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
S_ISREG	O
(	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
&&	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
<	O
sizeof	O
(	O
*	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
)	O
)	O
return	O
1	int
;	O
if	O
(	O
readLead	(*(struct),*(struct(array(char),char,char,short,short,array(char),short,short,array(char))))->(int)
(	O
fd	*(struct)
,	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
)	O
)	O
{	O
return	O
2	int
;	O
}	O
if	O
(	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
->	O
magic	array(char)
[	O
0	int
]	O
!=	O
RPMLEAD_MAGIC0	int
||	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
->	O
magic	array(char)
[	O
1	int
]	O
!=	O
RPMLEAD_MAGIC1	int
||	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
->	O
magic	array(char)
[	O
2	int
]	O
!=	O
RPMLEAD_MAGIC2	int
||	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
->	O
magic	array(char)
[	O
3	int
]	O
!=	O
RPMLEAD_MAGIC3	int
)	O
{	O
return	O
1	int
;	O
}	O
switch	O
(	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
->	O
major	*(int)
)	O
{	O
case	O
1	int
:	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_NEWPACKAGE	O
,	O
_	O
(	O
"packaging version 1 is not"	*(char)
" supported by this version of RPM"	*(char)
)	O
)	O
;	O
return	O
2	int
;	O
break	O
;	O
case	O
2	int
:	O
case	O
3	int
:	O
case	O
4	int
:	O
if	O
(	O
rpmReadSignature	(*(struct),*(*(struct)),short)->(int)
(	O
fd	*(struct)
,	O
sigs	*(*(struct))
,	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
->	O
signature_type	short
)	O
)	O
{	O
return	O
2	int
;	O
}	O
*	O
hdr	*(*(struct))
=	O
headerRead	(*(struct),int)->(*(struct))
(	O
fd	*(struct)
,	O
(	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
->	O
major	*(int)
>=	O
3	int
)	O
?	O
HEADER_MAGIC_YES	int
:	O
HEADER_MAGIC_NO	int
)	O
;	O
if	O
(	O
*	O
hdr	*(*(struct))
==	O
NULL	O
)	O
{	O
if	O
(	O
sigs	*(*(struct))
!=	O
NULL	O
)	O
{	O
headerFree	(*(struct))->(void)
(	O
*	O
sigs	*(*(struct))
)	O
;	O
}	O
return	O
2	int
;	O
}	O
if	O
(	O
headerIsEntry	(*(struct),int)->(int)
(	O
*	O
hdr	*(*(struct))
,	O
RPMTAG_FILEUSERNAME	int
)	O
)	O
headerRemoveEntry	(*(struct),int)->(int)
(	O
*	O
hdr	*(*(struct))
,	O
RPMTAG_FILEUIDS	int
)	O
;	O
if	O
(	O
headerIsEntry	(*(struct),int)->(int)
(	O
*	O
hdr	*(*(struct))
,	O
RPMTAG_FILEGROUPNAME	int
)	O
)	O
headerRemoveEntry	(*(struct),int)->(int)
(	O
*	O
hdr	*(*(struct))
,	O
RPMTAG_FILEGIDS	int
)	O
;	O
if	O
(	O
headerGetEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
*	O
hdr	*(*(struct))
,	O
RPMTAG_DEFAULTPREFIX	int
,	O
NULL	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
defaultPrefix	*(char)
,	O
NULL	O
)	O
)	O
{	O
defaultPrefix	*(char)
=	O
strcpy	(*(char),*(char))->(*(char))
(	O
alloca	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
defaultPrefix	*(char)
)	O
+	O
1	int
)	O
,	O
defaultPrefix	*(char)
)	O
;	O
stripTrailingSlashes	(*(char))->(void)
(	O
defaultPrefix	*(char)
)	O
;	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
*	O
hdr	*(*(struct))
,	O
RPMTAG_PREFIXES	int
,	O
RPM_STRING_ARRAY_TYPE	int
,	O
&	O
defaultPrefix	*(char)
,	O
1	int
)	O
;	O
}	O
compressFilelist	(*(struct))->(void)
(	O
*	O
hdr	*(*(struct))
)	O
;	O
if	O
(	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
->	O
type	enum(int,int,int,int)
==	O
RPMLEAD_SOURCE	int
)	O
{	O
if	O
(	O
!	O
headerIsEntry	(*(struct),int)->(int)
(	O
*	O
hdr	*(*(struct))
,	O
RPMTAG_SOURCEPACKAGE	int
)	O
)	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
*	O
hdr	*(*(struct))
,	O
RPMTAG_SOURCEPACKAGE	int
,	O
RPM_INT32_TYPE	int
,	O
&	O
true	int
,	O
1	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_NEWPACKAGE	O
,	O
_	O
(	O
"only packages with major numbers <= 4 "	*(char)
"are supported by this version of RPM"	*(char)
)	O
)	O
;	O
return	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
hdrPtr	*(*(struct))
==	O
NULL	O
)	O
{	O
headerFree	(*(struct))->(void)
(	O
*	O
hdr	*(*(struct))
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rpmReadPackageInfo	(*(struct),*(*(struct)),*(*(struct)))->(int)
(	O
FD_t	*(struct)
fd	*(struct)
,	O
Header	*(struct)
*	O
signatures	*(*(struct))
,	O
Header	*(struct)
*	O
hdr	*(*(struct))
)	O
{	O
return	O
readPackageHeaders	(*(struct),*(struct(array(char),char,char,short,short,array(char),short,short,array(char))),*(*(struct)),*(*(struct)))->(int)
(	O
fd	*(struct)
,	O
NULL	O
,	O
signatures	*(*(struct))
,	O
hdr	*(*(struct))
)	O
;	O
}	O
int	O
rpmReadPackageHeader	(*(struct),*(*(struct)),*(int),*(int),*(int))->(int)
(	O
FD_t	*(struct)
fd	*(struct)
,	O
Header	*(struct)
*	O
hdr	*(*(struct))
,	O
int	O
*	O
isSource	*(int)
,	O
int	O
*	O
major	*(int)
,	O
int	O
*	O
minor	*(int)
)	O
{	O
int	O
rc	int
;	O
struct	O
rpmlead	struct(array(char),char,char,short,short,array(char),short,short,array(char))
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
;	O
rc	int
=	O
readPackageHeaders	(*(struct),*(struct(array(char),char,char,short,short,array(char),short,short,array(char))),*(*(struct)),*(*(struct)))->(int)
(	O
fd	*(struct)
,	O
&	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
,	O
NULL	O
,	O
hdr	*(*(struct))
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
isSource	*(int)
)	O
*	O
isSource	*(int)
=	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
.	O
type	enum(int,int,int,int)
==	O
RPMLEAD_SOURCE	int
;	O
if	O
(	O
major	*(int)
)	O
*	O
major	*(int)
=	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
.	O
major	*(int)
;	O
if	O
(	O
minor	*(int)
)	O
*	O
minor	*(int)
=	O
lead	*(struct(array(char),char,char,short,short,array(char),short,short,array(char)))
.	O
minor	*(int)
;	O
return	O
0	int
;	O
}	O
