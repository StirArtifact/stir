object	(*(int))->(()->(int))
MakeAfun	((*(int))->(()->(int)),int,int)->(int)
(	O
object	(*(int))->(()->(int))
(	O
*	O
addr	*(int)
)	O
(	O
object	(*(int))->(()->(int))
,	O
object	(*(int))->(()->(int))
)	O
,	O
unsigned	O
int	O
argd	int
,	O
object	(*(int))->(()->(int))
data	int
)	O
{	O
int	O
type	int
=	O
(	O
F_ARG_FLAGS_P	()->(int)
(	O
argd	int
,	O
F_requires_fun_passed	O
)	O
?	O
t_closure	O
:	O
t_afun	O
)	O
;	O
object	(*(int))->(()->(int))
x	int
=	O
alloc_object	O
(	O
type	int
)	O
;	O
x	int
->	O
sfn	O
.	O
sfn_name	O
=	O
Cnil	O
;	O
x	int
->	O
sfn	O
.	O
sfn_self	O
=	O
addr	*(int)
;	O
x	int
->	O
sfn	O
.	O
sfn_argd	O
=	O
argd	int
;	O
if	O
(	O
type	int
==	O
t_closure	O
)	O
{	O
x	int
->	O
cl	O
.	O
cl_env	O
=	O
0	int
;	O
x	int
->	O
cl	O
.	O
cl_envdim	O
=	O
0	int
;	O
}	O
x	int
->	O
sfn	O
.	O
sfn_data	O
=	O
data	int
;	O
return	O
x	int
;	O
}	O
static	O
object	(*(int))->(()->(int))
fSmakefun	(int,(*(int))->(int),int)->(int)
(	O
object	(*(int))->(()->(int))
sym	int
,	O
object	(*(int))->(()->(int))
(	O
*	O
addr	*(int)
)	O
(	O
)	O
,	O
unsigned	O
int	O
argd	int
)	O
{	O
object	(*(int))->(()->(int))
ans	O
=	O
MakeAfun	((*(int))->(()->(int)),int,int)->(int)
(	O
addr	*(int)
,	O
argd	int
,	O
(	O
sSPmemory	O
&&	O
sSPmemory	O
->	O
s	O
.	O
s_dbind	O
&&	O
type_of	()->(int)
(	O
sSPmemory	O
->	O
s	O
.	O
s_dbind	O
)	O
==	O
t_cfdata	O
)	O
?	O
sSPmemory	O
->	O
s	O
.	O
s_dbind	O
:	O
0	int
)	O
;	O
ans	O
->	O
sfn	O
.	O
sfn_name	O
=	O
sym	int
;	O
return	O
ans	O
;	O
}	O
static	O
void	O
IsetClosure	(int,int,int)->(void)
(	O
object	(*(int))->(()->(int))
x	int
,	O
int	O
n	int
,	O
va_list	O
ap	int
)	O
{	O
object	(*(int))->(()->(int))
*	O
p	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_closure	O
)	O
{	O
FEerror	()->(int)
(	O
"Not a closure"	*(char)
,	O
0	int
)	O
;	O
}	O
if	O
(	O
x	int
->	O
cl	O
.	O
cl_envdim	O
<	O
n	int
)	O
{	O
BEGIN_NO_INTERRUPT	O
;	O
x	int
->	O
cl	O
.	O
cl_env	O
=	O
(	O
object	(*(int))->(()->(int))
*	O
)	O
alloc_relblock	O
(	O
n	int
)	O
;	O
x	int
->	O
cl	O
.	O
cl_envdim	O
=	O
n	int
;	O
END_NO_INTERRUPT	O
;	O
}	O
p	O
=	O
x	int
->	O
cl	O
.	O
cl_env	O
;	O
while	O
(	O
--	O
n	int
>=	O
0	int
)	O
{	O
*	O
p	O
++	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	(*(int))->(()->(int))
)	O
;	O
}	O
}	O
DEFUN_NEW	()->(int)
(	O
"INITFUN"	*(char)
,	O
object	(*(int))->(()->(int))
,	O
fSinitfun	O
,	O
SI	O
,	O
3	int
,	O
ARG_LIMIT	O
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	(*(int))->(()->(int))
sym	int
,	O
object	(*(int))->(()->(int))
addr_ind	O
,	O
object	(*(int))->(()->(int))
argd	int
,	O
...	O
)	O
,	O
"Store a compiled function on SYMBOL whose body is in the VV array at INDEX, and whose argd descriptor is ARGD.  If more arguments IND1, IND2,.. are supplied these are indices in the VV array for the environment of this closure."	*(char)
)	O
{	O
int	O
nargs	int
=	O
F_NARGS	()->(int)
(	O
VFUN_NARGS	O
)	O
-	O
3	int
;	O
va_list	O
ap	int
;	O
object	(*(int))->(()->(int))
fun	O
=	O
fSmakefun	(int,(*(int))->(int),int)->(int)
(	O
IisSymbol	O
(	O
sym	int
)	O
,	O
PADDR	O
(	O
addr_ind	O
)	O
,	O
Mfix	()->(int)
(	O
argd	int
)	O
)	O
;	O
if	O
(	O
nargs	int
>	O
0	int
)	O
{	O
va_start	O
(	O
ap	int
,	O
argd	int
)	O
;	O
IsetClosure	(int,int,int)->(void)
(	O
fun	O
,	O
nargs	int
,	O
ap	int
)	O
;	O
while	O
(	O
--	O
nargs	int
>=	O
0	int
)	O
{	O
fun	O
->	O
cl	O
.	O
cl_env	O
[	O
nargs	int
]	O
=	O
(	O
object	(*(int))->(()->(int))
)	O
PADDR	O
(	O
fun	O
->	O
cl	O
.	O
cl_env	O
[	O
nargs	int
]	O
)	O
;	O
}	O
va_end	O
(	O
ap	int
)	O
;	O
}	O
fSfset	()->(int)
(	O
sym	int
,	O
fun	O
)	O
;	O
return	O
sym	int
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"INITMACRO"	*(char)
,	O
object	(*(int))->(()->(int))
,	O
fSinitmacro	O
,	O
SI	O
,	O
4	int
,	O
ARG_LIMIT	O
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	(*(int))->(()->(int))
first	O
,	O
...	O
)	O
,	O
"Like INITFUN, but makes then sets the 'macro' flag on this symbol"	*(char)
)	O
{	O
va_list	O
ap	int
;	O
object	(*(int))->(()->(int))
res	O
;	O
int	O
n	int
=	O
VFUN_NARGS	O
;	O
object	(*(int))->(()->(int))
*	O
new	O
;	O
va_start	O
(	O
ap	int
,	O
first	O
)	O
;	O
COERCE_VA_LIST_NEW	()->(int)
(	O
new	O
,	O
first	O
,	O
ap	int
,	O
n	int
)	O
;	O
res	O
=	O
c_apply_n_f	()->(int)
(	O
(	O
void	O
*	O
)	O
FFN	()->(int)
(	O
fSinitfun	O
)	O
,	O
n	int
,	O
new	O
,	O
3	int
,	O
ARG_LIMIT	O
)	O
;	O
va_end	O
(	O
ap	int
)	O
;	O
res	O
->	O
s	O
.	O
s_mflag	O
=	O
1	int
;	O
return	O
res	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"SET-KEY-STRUCT"	*(char)
,	O
object	(*(int))->(()->(int))
,	O
fSset_key_struct	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	(*(int))->(()->(int))
key_struct_ind	O
)	O
,	O
"Called inside the loader.  The keystruct is set up in the file with    indexes rather than the actual entries.  We change these indices to    the objects"	*(char)
)	O
{	O
set_key_struct	()->(int)
(	O
PADDR	O
(	O
key_struct_ind	O
)	O
,	O
sSPmemory	O
->	O
s	O
.	O
s_dbind	O
)	O
;	O
return	O
Cnil	O
;	O
}	O
static	O
void	O
put_fn_procls	(int,int,int,int,int)->(void)
(	O
object	(*(int))->(()->(int))
sym	int
,	O
fixnum	O
argd	int
,	O
fixnum	O
oneval	int
,	O
object	(*(int))->(()->(int))
def	int
,	O
object	(*(int))->(()->(int))
rdef	int
)	O
{	O
unsigned	O
int	O
atypes	int
=	O
F_TYPES	()->(int)
(	O
argd	int
)	O
>>	O
F_TYPE_WIDTH	O
;	O
unsigned	O
int	O
minargs	int
=	O
F_MIN_ARGS	()->(int)
(	O
argd	int
)	O
;	O
unsigned	O
int	O
maxargs	int
=	O
F_MAX_ARGS	()->(int)
(	O
argd	int
)	O
;	O
unsigned	O
int	O
rettype	int
=	O
F_RESULT_TYPE	()->(int)
(	O
argd	int
)	O
;	O
unsigned	O
int	O
i	int
;	O
object	(*(int))->(()->(int))
ta	O
=	O
Cnil	O
,	O
na	O
=	O
Cnil	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
minargs	int
;	O
i	int
++	O
,	O
atypes	int
>>=	O
F_TYPE_WIDTH	O
)	O
switch	O
(	O
maxargs	int
!=	O
minargs	int
?	O
F_object	O
:	O
atypes	int
&	O
MASK_RANGE	()->(int)
(	O
0	int
,	O
F_TYPE_WIDTH	O
)	O
)	O
{	O
case	O
F_object	O
:	O
collect	O
(	O
ta	O
,	O
na	O
,	O
def	int
)	O
;	O
break	O
;	O
case	O
F_int	O
:	O
collect	O
(	O
ta	O
,	O
na	O
,	O
sLfixnum	O
)	O
;	O
break	O
;	O
case	O
F_shortfloat	O
:	O
collect	O
(	O
ta	O
,	O
na	O
,	O
sLshort_float	O
)	O
;	O
break	O
;	O
case	O
F_double_ptr	O
:	O
collect	O
(	O
ta	O
,	O
na	O
,	O
sLlong_float	O
)	O
;	O
break	O
;	O
default	O
:	O
FEerror	()->(int)
(	O
"Bad sfn declaration"	*(char)
,	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
maxargs	int
!=	O
minargs	int
)	O
collect	O
(	O
ta	O
,	O
na	O
,	O
sLA	O
)	O
;	O
putprop	()->(int)
(	O
sym	int
,	O
ta	O
,	O
sSproclaimed_arg_types	O
)	O
;	O
ta	O
=	O
na	O
=	O
Cnil	O
;	O
if	O
(	O
oneval	int
)	O
switch	O
(	O
rettype	int
)	O
{	O
case	O
F_object	O
:	O
ta	O
=	O
rdef	int
;	O
break	O
;	O
case	O
F_int	O
:	O
ta	O
=	O
sLfixnum	O
;	O
break	O
;	O
case	O
F_shortfloat	O
:	O
ta	O
=	O
sLshort_float	O
;	O
break	O
;	O
case	O
F_double_ptr	O
:	O
ta	O
=	O
sLlong_float	O
;	O
break	O
;	O
default	O
:	O
FEerror	()->(int)
(	O
"Bad sfn declaration"	*(char)
,	O
0	int
)	O
;	O
break	O
;	O
}	O
else	O
ta	O
=	O
sLA	O
;	O
putprop	()->(int)
(	O
sym	int
,	O
ta	O
,	O
sSproclaimed_return_type	O
)	O
;	O
if	O
(	O
oneval	int
)	O
putprop	()->(int)
(	O
sym	int
,	O
Ct	O
,	O
sSproclaimed_function	O
)	O
;	O
}	O
void	O
SI_makefun	(*(char),*(void),int)->(void)
(	O
char	O
*	O
strg	*(char)
,	O
void	O
*	O
fn	*(void)
,	O
unsigned	O
int	O
argd	int
)	O
{	O
object	(*(int))->(()->(int))
sym	int
=	O
make_si_ordinary	O
(	O
strg	*(char)
)	O
;	O
fSfset	()->(int)
(	O
sym	int
,	O
fSmakefun	(int,(*(int))->(int),int)->(int)
(	O
sym	int
,	O
fn	*(void)
,	O
argd	int
)	O
)	O
;	O
put_fn_procls	(int,int,int,int,int)->(void)
(	O
sym	int
,	O
argd	int
,	O
1	int
,	O
Ct	O
,	O
Ct	O
)	O
;	O
}	O
void	O
LISP_makefun	(*(char),*(void),int)->(void)
(	O
char	O
*	O
strg	*(char)
,	O
void	O
*	O
fn	*(void)
,	O
unsigned	O
int	O
argd	int
)	O
{	O
object	(*(int))->(()->(int))
sym	int
=	O
make_ordinary	O
(	O
strg	*(char)
)	O
;	O
fSfset	()->(int)
(	O
sym	int
,	O
fSmakefun	(int,(*(int))->(int),int)->(int)
(	O
sym	int
,	O
fn	*(void)
,	O
argd	int
)	O
)	O
;	O
put_fn_procls	(int,int,int,int,int)->(void)
(	O
sym	int
,	O
argd	int
,	O
1	int
,	O
Ct	O
,	O
Ct	O
)	O
;	O
}	O
void	O
SI_makefunm	(*(char),*(void),int)->(void)
(	O
char	O
*	O
strg	*(char)
,	O
void	O
*	O
fn	*(void)
,	O
unsigned	O
int	O
argd	int
)	O
{	O
object	(*(int))->(()->(int))
sym	int
=	O
make_si_ordinary	O
(	O
strg	*(char)
)	O
;	O
fSfset	()->(int)
(	O
sym	int
,	O
fSmakefun	(int,(*(int))->(int),int)->(int)
(	O
sym	int
,	O
fn	*(void)
,	O
argd	int
)	O
)	O
;	O
put_fn_procls	(int,int,int,int,int)->(void)
(	O
sym	int
,	O
argd	int
,	O
0	int
,	O
Ct	O
,	O
Ct	O
)	O
;	O
}	O
void	O
LISP_makefunm	(*(char),*(void),int)->(void)
(	O
char	O
*	O
strg	*(char)
,	O
void	O
*	O
fn	*(void)
,	O
unsigned	O
int	O
argd	int
)	O
{	O
object	(*(int))->(()->(int))
sym	int
=	O
make_ordinary	O
(	O
strg	*(char)
)	O
;	O
fSfset	()->(int)
(	O
sym	int
,	O
fSmakefun	(int,(*(int))->(int),int)->(int)
(	O
sym	int
,	O
fn	*(void)
,	O
argd	int
)	O
)	O
;	O
put_fn_procls	(int,int,int,int,int)->(void)
(	O
sym	int
,	O
argd	int
,	O
0	int
,	O
Ct	O
,	O
Ct	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"INVOKE"	*(char)
,	O
object	(*(int))->(()->(int))
,	O
fSinvoke	O
,	O
SI	O
,	O
1	int
,	O
ARG_LIMIT	O
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	(*(int))->(()->(int))
x	int
)	O
,	O
"Invoke a C function whose body is at INDEX in the VV array"	*(char)
)	O
{	O
int	O
(	O
*	O
fn	*(void)
)	O
(	O
)	O
;	O
fn	*(void)
=	O
(	O
void	O
*	O
)	O
PADDR	O
(	O
x	int
)	O
;	O
(	O
*	O
fn	*(void)
)	O
(	O
)	O
;	O
return	O
Cnil	O
;	O
}	O
