struct	O
_mu_fsfolder	struct(*(char),*(struct))
{	O
char	O
*	O
dirname	*(char)
;	O
mu_property_t	*(struct)
subscription	*(struct)
;	O
}	O
;	O
static	O
int	O
open_subscription	(*(struct(*(char),*(struct))))->(int)
(	O
struct	O
_mu_fsfolder	struct(*(char),*(struct))
*	O
folder	*(struct)
)	O
{	O
int	O
rc	int
;	O
mu_property_t	*(struct)
prop	*(struct)
;	O
mu_stream_t	*(struct)
str	*(struct)
;	O
char	O
*	O
filename	*(char)
=	O
mu_make_file_name	O
(	O
folder	*(struct)
->	O
dirname	*(char)
,	O
".mu-subscr"	*(char)
)	O
;	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
str	*(struct)
,	O
filename	*(char)
,	O
MU_STREAM_RDWR	O
|	O
MU_STREAM_CREAT	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
mu_property_create_init	(*(*(struct)),*((*(struct))->(int)),*(void))->(int)
(	O
&	O
prop	*(struct)
,	O
mu_assoc_property_init	(*(struct))->(int)
,	O
str	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
folder	*(struct)
->	O
subscription	*(struct)
=	O
prop	*(struct)
;	O
return	O
rc	int
;	O
}	O
static	O
char	O
*	O
get_pathname	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
dirname	*(char)
,	O
const	O
char	O
*	O
basename	(*(char))->(*(char))
)	O
{	O
char	O
*	O
pathname	*(char)
=	O
NULL	O
,	O
*	O
p	*(char)
;	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
dirname	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
p	*(char)
&&	O
p	*(char)
[	O
1	int
]	O
==	O
'/'	O
&&	O
p	*(char)
[	O
2	int
]	O
==	O
'/'	O
)	O
dirname	*(char)
=	O
p	*(char)
+	O
3	int
;	O
if	O
(	O
basename	(*(char))->(*(char))
==	O
NULL	O
)	O
pathname	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
dirname	*(char)
?	O
dirname	*(char)
:	O
"."	*(char)
)	O
;	O
else	O
if	O
(	O
basename	(*(char))->(*(char))
[	O
0	int
]	O
==	O
'/'	O
)	O
pathname	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
basename	(*(char))->(*(char))
)	O
;	O
else	O
{	O
size_t	long
baselen	long
=	O
strlen	(*(char))->(long)
(	O
basename	(*(char))->(*(char))
)	O
;	O
size_t	long
dirlen	long
=	O
strlen	(*(char))->(long)
(	O
dirname	*(char)
)	O
;	O
while	O
(	O
dirlen	long
>	O
0	int
&&	O
dirname	*(char)
[	O
dirlen	long
-	O
1	int
]	O
==	O
'/'	O
)	O
dirlen	long
--	O
;	O
pathname	*(char)
=	O
calloc	(long,long)->(*(void))
(	O
dirlen	long
+	O
baselen	long
+	O
2	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
if	O
(	O
pathname	*(char)
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
pathname	*(char)
,	O
dirname	*(char)
,	O
dirlen	long
)	O
;	O
pathname	*(char)
[	O
dirlen	long
]	O
=	O
'/'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
pathname	*(char)
+	O
dirlen	long
+	O
1	int
,	O
basename	(*(char))->(*(char))
)	O
;	O
}	O
}	O
return	O
pathname	*(char)
;	O
}	O
static	O
void	O
_fsfolder_destroy	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(void)
(	O
mu_folder_t	*(struct)
folder	*(struct)
)	O
{	O
if	O
(	O
folder	*(struct)
->	O
data	*(void)
)	O
{	O
struct	O
_mu_fsfolder	struct(*(char),*(struct))
*	O
fsfolder	*(struct(*(char),*(struct)))
=	O
folder	*(struct)
->	O
data	*(void)
;	O
free	(*(void))->(void)
(	O
fsfolder	*(struct(*(char),*(struct)))
->	O
dirname	*(char)
)	O
;	O
mu_property_destroy	(*(*(struct)))->(void)
(	O
&	O
fsfolder	*(struct(*(char),*(struct)))
->	O
subscription	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
folder	*(struct)
->	O
data	*(void)
)	O
;	O
folder	*(struct)
->	O
data	*(void)
=	O
NULL	O
;	O
}	O
}	O
static	O
int	O
_fsfolder_open	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),int)->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
,	O
int	O
flags	int
MU_ARG_UNUSED	O
)	O
{	O
struct	O
_mu_fsfolder	struct(*(char),*(struct))
*	O
fsfolder	*(struct(*(char),*(struct)))
=	O
folder	*(struct)
->	O
data	*(void)
;	O
if	O
(	O
flags	int
&	O
MU_STREAM_CREAT	int
)	O
{	O
return	O
(	O
mkdir	(*(char),int)->(int)
(	O
fsfolder	*(struct(*(char),*(struct)))
->	O
dirname	*(char)
,	O
S_IRWXU	O
)	O
==	O
0	int
)	O
?	O
0	int
:	O
errno	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_fsfolder_close	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
MU_ARG_UNUSED	O
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
struct	O
_mu_fsfolder	struct(*(char),*(struct))
*	O
fsfolder	*(struct(*(char),*(struct)))
=	O
folder	*(struct)
->	O
data	*(void)
;	O
if	O
(	O
fsfolder	*(struct(*(char),*(struct)))
->	O
subscription	*(struct)
)	O
rc	int
=	O
mu_property_save	(*(struct))->(int)
(	O
fsfolder	*(struct(*(char),*(struct)))
->	O
subscription	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
_fsfolder_rename	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
,	O
const	O
char	O
*	O
oldpath	*(char)
,	O
const	O
char	O
*	O
newpath	*(char)
)	O
{	O
struct	O
_mu_fsfolder	struct(*(char),*(struct))
*	O
fsfolder	*(struct(*(char),*(struct)))
=	O
folder	*(struct)
->	O
data	*(void)
;	O
if	O
(	O
oldpath	*(char)
&&	O
newpath	*(char)
)	O
{	O
int	O
status	int
=	O
0	int
;	O
char	O
*	O
pathold	*(char)
=	O
get_pathname	(*(char),*(char))->(*(char))
(	O
fsfolder	*(struct(*(char),*(struct)))
->	O
dirname	*(char)
,	O
oldpath	*(char)
)	O
;	O
if	O
(	O
pathold	*(char)
)	O
{	O
char	O
*	O
pathnew	*(char)
=	O
get_pathname	(*(char),*(char))->(*(char))
(	O
fsfolder	*(struct(*(char),*(struct)))
->	O
dirname	*(char)
,	O
newpath	*(char)
)	O
;	O
if	O
(	O
pathnew	*(char)
)	O
{	O
if	O
(	O
access	(*(char),int)->(int)
(	O
pathnew	*(char)
,	O
F_OK	int
)	O
==	O
0	int
)	O
status	int
=	O
EEXIST	int
;	O
else	O
if	O
(	O
rename	(*(char),*(char))->(int)
(	O
pathold	*(char)
,	O
pathnew	*(char)
)	O
!=	O
0	int
)	O
status	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
pathnew	*(char)
)	O
;	O
}	O
else	O
status	int
=	O
ENOMEM	int
;	O
free	(*(void))->(void)
(	O
pathold	*(char)
)	O
;	O
}	O
else	O
status	int
=	O
ENOMEM	int
;	O
return	O
status	int
;	O
}	O
return	O
EINVAL	int
;	O
}	O
struct	O
inode_list	struct(*(struct(*(struct(*(struct`),long,long)),long,long)),long,long)
{	O
struct	O
inode_list	struct(*(struct(*(struct(*(struct`),long,long)),long,long)),long,long)
*	O
next	*((*(void))->(int))
;	O
ino_t	long
inode	long
;	O
dev_t	long
dev	long
;	O
}	O
;	O
struct	O
folder_scan_data	struct(*(struct(*(struct),*(struct),*(struct),*(struct(*(void),*(void),int,int)),*(struct),int,int,long,*(void),*((*(struct`))->(void)),*((*(struct`),int)->(int)),*((*(struct`))->(int)),*((*(struct`),*(struct`))->(int)),*((*(struct`),*(char),*(char),*(struct`))->(int)),*((*(char),*(void),int)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(char),*(char))->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(*`))->(int)))),*(char),long,long)
{	O
mu_folder_t	*(struct)
folder	*(struct)
;	O
char	O
*	O
dirname	*(char)
;	O
size_t	long
dirlen	long
;	O
size_t	long
errcnt	long
;	O
}	O
;	O
static	O
int	O
inode_list_lookup	(*(struct(*(struct(*`,long,long)),long,long)),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
struct	O
inode_list	struct(*(struct(*(struct(*(struct`),long,long)),long,long)),long,long)
*	O
list	*(struct)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
st	*(struct(long,long,long))
)	O
{	O
for	O
(	O
;	O
list	*(struct)
;	O
list	*(struct)
=	O
list	*(struct)
->	O
next	*((*(void))->(int))
)	O
if	O
(	O
list	*(struct)
->	O
inode	long
==	O
st	*(struct(long,long,long))
->	O
st_ino	long
&&	O
list	*(struct)
->	O
dev	long
==	O
st	*(struct(long,long,long))
->	O
st_dev	long
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
fold_record_match	(*(void),*(void),*(void),*(*(void)))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
,	O
void	O
*	O
prev	*(void)
,	O
void	O
*	O
*	O
ret	*(*(struct))
)	O
{	O
struct	O
mu_record_match	struct(*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int)))),int)
*	O
cur_match	*(struct(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),int))
=	O
item	*(void)
;	O
struct	O
mu_record_match	struct(*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int)))),int)
*	O
prev_match	*(struct(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),int))
=	O
prev	*(void)
;	O
if	O
(	O
prev	*(void)
==	O
NULL	O
||	O
cur_match	*(struct(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),int))
->	O
flags	int
>=	O
prev_match	*(struct(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),int))
->	O
flags	int
)	O
*	O
ret	*(*(struct))
=	O
cur_match	*(struct(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),int))
;	O
else	O
*	O
ret	*(*(struct))
=	O
prev_match	*(struct(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),int))
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mcomp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(struct(*(char),int,int))
,	O
const	O
void	O
*	O
b	*(struct(*(char),int,int))
)	O
{	O
struct	O
_mu_record	struct(int,*(char),int,int,int,*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)),*(void),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(struct),int)->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(char),int)->(int)))
const	O
*	O
r	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
=	O
a	*(struct(*(char),int,int))
;	O
struct	O
mu_record_match	struct(*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int)))),int)
const	O
*	O
m	*(struct(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),int))
=	O
b	*(struct(*(char),int,int))
;	O
return	O
!	O
(	O
m	*(struct(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),int))
->	O
record	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
==	O
r	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
)	O
;	O
}	O
static	O
int	O
best_match	(*(struct),*(char),*(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))),*(int))->(int)
(	O
mu_list_t	*(struct)
records	*(struct)
,	O
char	O
const	O
*	O
refname	*(char)
,	O
mu_record_t	*(struct)
*	O
prec	*(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))))
,	O
int	O
*	O
pflags	*(int)
)	O
{	O
int	O
rc	int
;	O
mu_list_t	*(struct)
mlist	*(struct)
,	O
isect	*(struct)
;	O
mu_list_comparator_t	*((*(void),*(void))->(int))
prev	*(void)
;	O
struct	O
mu_record_match	struct(*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int)))),int)
*	O
m	*(struct(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),int))
;	O
rc	int
=	O
mu_registrar_match_records	(*(char),int,*(*(struct)))->(int)
(	O
refname	*(char)
,	O
MU_FOLDER_ATTRIBUTE_ALL	O
,	O
&	O
mlist	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s():%s: %s"	*(char)
,	O
__func__	O
,	O
"mu_registrar_match_records"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
prev	*(void)
=	O
mu_list_set_comparator	(*(struct),*((*(void),*(void))->(int)))->(*((*(void),*(void))->(int)))
(	O
records	*(struct)
,	O
mcomp	(*(void),*(void))->(int)
)	O
;	O
rc	int
=	O
mu_list_intersect	(*(*(struct)),*(struct),*(struct))->(int)
(	O
&	O
isect	*(struct)
,	O
mlist	*(struct)
,	O
records	*(struct)
)	O
;	O
mu_list_set_comparator	(*(struct),*((*(void),*(void))->(int)))->(*((*(void),*(void))->(int)))
(	O
records	*(struct)
,	O
prev	*(void)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s():%s: %s"	*(char)
,	O
__func__	O
,	O
"mu_list_intersect"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
mlist	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_list_fold	(*(struct),*((*(void),*(void),*(void),*(*(void)))->(int)),*(void),*(void),*(void))->(int)
(	O
isect	*(struct)
,	O
fold_record_match	(*(void),*(void),*(void),*(*(void)))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
&	O
m	*(struct(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),int))
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
m	*(struct(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),int))
==	O
NULL	O
)	O
rc	int
=	O
MU_ERR_NOENT	O
;	O
else	O
{	O
*	O
prec	*(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))))
=	O
m	*(struct(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),int))
->	O
record	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
;	O
*	O
pflags	*(int)
=	O
m	*(struct(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),int))
->	O
flags	int
;	O
}	O
}	O
else	O
{	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s():%s: %s"	*(char)
,	O
__func__	O
,	O
"mu_list_fold"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
mlist	*(struct)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
isect	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
list_helper	(*(struct(*(char),*(void),int,long,*((*`,*`,*`)->(int)),*(void),*(struct),*(struct))),*(struct(*(struct(*`,*`,*`,*`,*`,int,int,long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),long,long)),*(struct(*(struct(*`,long,long)),long,long)),*(char),long)->(int)
(	O
struct	O
mu_folder_scanner	struct(*(char),*(void),int,long,*((*(struct),*(struct(int,int,int,*(char),*(struct`))),*(void))->(int)),*(void),*(struct),*(struct))
*	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
,	O
struct	O
folder_scan_data	struct(*(struct(*(struct),*(struct),*(struct),*(struct(*(void),*(void),int,int)),*(struct),int,int,long,*(void),*((*(struct`))->(void)),*((*(struct`),int)->(int)),*((*(struct`))->(int)),*((*(struct`),*(struct`))->(int)),*((*(struct`),*(char),*(char),*(struct`))->(int)),*((*(char),*(void),int)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(char),*(char))->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(*`))->(int)))),*(char),long,long)
*	O
data	*(void)
,	O
struct	O
inode_list	struct(*(struct(*(struct(*(struct`),long,long)),long,long)),long,long)
*	O
ilist	*(struct(*(struct(*(struct`),long,long)),long,long))
,	O
const	O
char	O
*	O
dirname	*(char)
,	O
size_t	long
depth	int
)	O
{	O
DIR	struct
*	O
dirp	*(struct)
;	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dp	*(struct(long,long,short,char,array(char)))
;	O
int	O
stop	int
=	O
0	int
;	O
if	O
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
max_depth	long
&&	O
depth	int
>=	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
max_depth	long
)	O
return	O
0	int
;	O
dirp	*(struct)
=	O
opendir	(*(char))->(*(struct))
(	O
dirname	*(char)
)	O
;	O
if	O
(	O
dirp	*(struct)
==	O
NULL	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s: %s(%s): %s"	*(char)
,	O
__func__	O
,	O
"opendir"	*(char)
,	O
dirname	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
data	*(void)
->	O
errcnt	long
++	O
;	O
return	O
1	int
;	O
}	O
while	O
(	O
(	O
dp	*(struct(long,long,short,char,array(char)))
=	O
readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
dirp	*(struct)
)	O
)	O
)	O
{	O
char	O
const	O
*	O
ename	*(char)
=	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
;	O
char	O
*	O
fname	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long))
;	O
if	O
(	O
ename	*(char)
[	O
ename	*(char)
[	O
0	int
]	O
!=	O
'.'	O
?	O
0	int
:	O
ename	*(char)
[	O
1	int
]	O
!=	O
'.'	O
?	O
1	int
:	O
2	int
]	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
ename	*(char)
,	O
".mu-"	*(char)
,	O
4	int
)	O
==	O
0	int
)	O
continue	O
;	O
fname	*(char)
=	O
get_pathname	(*(char),*(char))->(*(char))
(	O
dirname	*(char)
,	O
ename	*(char)
)	O
;	O
if	O
(	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fname	*(char)
,	O
&	O
st	*(struct(long,long,long))
)	O
==	O
0	int
)	O
{	O
int	O
f	int
;	O
if	O
(	O
S_ISDIR	O
(	O
st	*(struct(long,long,long))
.	O
st_mode	int
)	O
)	O
f	int
=	O
MU_FOLDER_ATTRIBUTE_DIRECTORY	int
;	O
else	O
if	O
(	O
S_ISREG	O
(	O
st	*(struct(long,long,long))
.	O
st_mode	int
)	O
)	O
f	int
=	O
MU_FOLDER_ATTRIBUTE_FILE	int
;	O
else	O
if	O
(	O
S_ISLNK	O
(	O
st	*(struct(long,long,long))
.	O
st_mode	int
)	O
)	O
f	int
=	O
MU_FOLDER_ATTRIBUTE_LINK	int
;	O
else	O
f	int
=	O
0	int
;	O
if	O
(	O
mu_registrar_list_p	(*(struct),*(char),int)->(int)
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
records	*(struct)
,	O
ename	*(char)
,	O
f	int
)	O
)	O
{	O
if	O
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
pattern	*(void)
==	O
NULL	O
||	O
data	*(void)
->	O
folder	*(struct)
->	O
_match	*((*(char),*(void),int)->(int))
==	O
NULL	O
||	O
data	*(void)
->	O
folder	*(struct)
->	O
_match	*((*(char),*(void),int)->(int))
(	O
fname	*(char)
+	O
data	*(void)
->	O
dirlen	long
+	O
(	O
(	O
data	*(void)
->	O
dirlen	long
>	O
1	int
&&	O
data	*(void)
->	O
dirname	*(char)
[	O
data	*(void)
->	O
dirlen	long
-	O
1	int
]	O
!=	O
'/'	O
)	O
?	O
1	int
:	O
0	int
)	O
,	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
pattern	*(void)
,	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
match_flags	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
refname	*(char)
=	O
fname	*(char)
;	O
int	O
type	enum(int,int,int,int)
=	O
0	int
;	O
struct	O
mu_list_response	struct(int,int,int,*(char),*(struct))
*	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
;	O
mu_record_t	*(struct)
rec	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
=	O
NULL	O
;	O
int	O
rc	int
;	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
)	O
)	O
;	O
if	O
(	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
==	O
NULL	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s: %s"	*(char)
,	O
__func__	O
,	O
mu_strerror	(int)->(*(char))
(	O
ENOMEM	int
)	O
)	O
)	O
;	O
data	*(void)
->	O
errcnt	long
++	O
;	O
free	(*(void))->(void)
(	O
fname	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
records	*(struct)
)	O
rc	int
=	O
best_match	(*(struct),*(char),*(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))),*(int))->(int)
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
records	*(struct)
,	O
refname	*(char)
,	O
&	O
rec	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
,	O
&	O
type	enum(int,int,int,int)
)	O
;	O
else	O
rc	int
=	O
mu_registrar_lookup	(*(char),int,*(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))),*(int))->(int)
(	O
refname	*(char)
,	O
MU_FOLDER_ATTRIBUTE_ALL	O
,	O
&	O
rec	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
,	O
&	O
type	enum(int,int,int,int)
)	O
;	O
if	O
(	O
rc	int
||	O
type	enum(int,int,int,int)
==	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
)	O
;	O
if	O
(	O
f	int
==	O
MU_FOLDER_ATTRIBUTE_DIRECTORY	int
)	O
type	enum(int,int,int,int)
=	O
f	int
;	O
}	O
else	O
{	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
name	*(char)
=	O
fname	*(char)
;	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
depth	int
=	O
depth	int
;	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
separator	int
=	O
'/'	O
;	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
format	*(struct)
=	O
rec	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
;	O
if	O
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
enumfun	*((*(struct),*(struct(int,int,int,*(char),*(struct`))),*(void))->(int))
)	O
{	O
if	O
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
enumfun	*((*(struct),*(struct(int,int,int,*(char),*(struct`))),*(void))->(int))
(	O
data	*(void)
->	O
folder	*(struct)
,	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
,	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
enumdata	*(void)
)	O
)	O
{	O
free	(*(void))->(void)
(	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
)	O
;	O
stop	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
result	*(struct)
)	O
{	O
int	O
rc	int
;	O
rc	int
=	O
mu_list_append	(*(struct),*(void))->(int)
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
result	*(struct)
,	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
)	O
;	O
if	O
(	O
rc	int
)	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s(%s):%s: %s"	*(char)
,	O
__func__	O
,	O
dirname	*(char)
,	O
"mu_list_append"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
fname	*(char)
=	O
NULL	O
;	O
}	O
else	O
free	(*(void))->(void)
(	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
)	O
;	O
}	O
if	O
(	O
(	O
type	enum(int,int,int,int)
&	O
MU_FOLDER_ATTRIBUTE_DIRECTORY	int
)	O
&&	O
!	O
inode_list_lookup	(*(struct(*(struct(*`,long,long)),long,long)),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
ilist	*(struct(*(struct(*(struct`),long,long)),long,long))
,	O
&	O
st	*(struct(long,long,long))
)	O
)	O
{	O
struct	O
inode_list	struct(*(struct(*(struct(*(struct`),long,long)),long,long)),long,long)
idata	struct(*(struct(*(struct(*`,long,long)),long,long)),long,long)
;	O
idata	struct(*(struct(*(struct(*`,long,long)),long,long)),long,long)
.	O
inode	long
=	O
st	*(struct(long,long,long))
.	O
st_ino	long
;	O
idata	struct(*(struct(*(struct(*`,long,long)),long,long)),long,long)
.	O
dev	long
=	O
st	*(struct(long,long,long))
.	O
st_dev	long
;	O
idata	struct(*(struct(*(struct(*`,long,long)),long,long)),long,long)
.	O
next	*((*(void))->(int))
=	O
ilist	*(struct(*(struct(*(struct`),long,long)),long,long))
;	O
stop	int
=	O
list_helper	(*(struct(*(char),*(void),int,long,*((*`,*`,*`)->(int)),*(void),*(struct),*(struct))),*(struct(*(struct(*`,*`,*`,*`,*`,int,int,long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),long,long)),*(struct(*(struct(*`,long,long)),long,long)),*(char),long)->(int)
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
,	O
data	*(void)
,	O
&	O
idata	struct(*(struct(*(struct(*`,long,long)),long,long)),long,long)
,	O
refname	*(char)
,	O
depth	int
+	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
S_ISDIR	O
(	O
st	*(struct(long,long,long))
.	O
st_mode	int
)	O
)	O
{	O
struct	O
inode_list	struct(*(struct(*(struct(*(struct`),long,long)),long,long)),long,long)
idata	struct(*(struct(*(struct(*`,long,long)),long,long)),long,long)
;	O
idata	struct(*(struct(*(struct(*`,long,long)),long,long)),long,long)
.	O
inode	long
=	O
st	*(struct(long,long,long))
.	O
st_ino	long
;	O
idata	struct(*(struct(*(struct(*`,long,long)),long,long)),long,long)
.	O
dev	long
=	O
st	*(struct(long,long,long))
.	O
st_dev	long
;	O
idata	struct(*(struct(*(struct(*`,long,long)),long,long)),long,long)
.	O
next	*((*(void))->(int))
=	O
ilist	*(struct(*(struct(*(struct`),long,long)),long,long))
;	O
stop	int
=	O
list_helper	(*(struct(*(char),*(void),int,long,*((*`,*`,*`)->(int)),*(void),*(struct),*(struct))),*(struct(*(struct(*`,*`,*`,*`,*`,int,int,long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),long,long)),*(struct(*(struct(*`,long,long)),long,long)),*(char),long)->(int)
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
,	O
data	*(void)
,	O
&	O
idata	struct(*(struct(*(struct(*`,long,long)),long,long)),long,long)
,	O
fname	*(char)
,	O
depth	int
+	O
1	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s: lstat(%s): %s"	*(char)
,	O
__func__	O
,	O
fname	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
fname	*(char)
)	O
;	O
}	O
closedir	(*(struct))->(int)
(	O
dirp	*(struct)
)	O
;	O
return	O
stop	int
;	O
}	O
static	O
int	O
_fsfolder_list	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(struct(*(char),*(void),int,long,*((*`,*`,*`)->(int)),*(void),*(struct),*(struct))))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
,	O
struct	O
mu_folder_scanner	struct(*(char),*(void),int,long,*((*(struct),*(struct(int,int,int,*(char),*(struct`))),*(void))->(int)),*(void),*(struct),*(struct))
*	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
)	O
{	O
struct	O
_mu_fsfolder	struct(*(char),*(struct))
*	O
fsfolder	*(struct(*(char),*(struct)))
=	O
folder	*(struct)
->	O
data	*(void)
;	O
struct	O
inode_list	struct(*(struct(*(struct(*(struct`),long,long)),long,long)),long,long)
iroot	struct(*(struct(*(struct(*`,long,long)),long,long)),long,long)
;	O
struct	O
folder_scan_data	struct(*(struct(*(struct),*(struct),*(struct),*(struct(*(void),*(void),int,int)),*(struct),int,int,long,*(void),*((*(struct`))->(void)),*((*(struct`),int)->(int)),*((*(struct`))->(int)),*((*(struct`),*(struct`))->(int)),*((*(struct`),*(char),*(char),*(struct`))->(int)),*((*(char),*(void),int)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(char),*(char))->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(*`))->(int)))),*(char),long,long)
sdata	struct(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),long,long)
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
iroot	struct(*(struct(*(struct(*`,long,long)),long,long)),long,long)
,	O
0	int
,	O
sizeof	O
iroot	struct(*(struct(*(struct(*`,long,long)),long,long)),long,long)
)	O
;	O
sdata	struct(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),long,long)
.	O
folder	*(struct)
=	O
folder	*(struct)
;	O
sdata	struct(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),long,long)
.	O
dirname	*(char)
=	O
get_pathname	(*(char),*(char))->(*(char))
(	O
fsfolder	*(struct(*(char),*(struct)))
->	O
dirname	*(char)
,	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
refname	*(char)
)	O
;	O
sdata	struct(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),long,long)
.	O
dirlen	long
=	O
strlen	(*(char))->(long)
(	O
sdata	struct(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),long,long)
.	O
dirname	*(char)
)	O
;	O
sdata	struct(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),long,long)
.	O
errcnt	long
=	O
0	int
;	O
list_helper	(*(struct(*(char),*(void),int,long,*((*`,*`,*`)->(int)),*(void),*(struct),*(struct))),*(struct(*(struct(*`,*`,*`,*`,*`,int,int,long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),long,long)),*(struct(*(struct(*`,long,long)),long,long)),*(char),long)->(int)
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
,	O
&	O
sdata	struct(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),long,long)
,	O
&	O
iroot	struct(*(struct(*(struct(*`,long,long)),long,long)),long,long)
,	O
sdata	struct(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),long,long)
.	O
dirname	*(char)
,	O
0	int
)	O
;	O
free	(*(void))->(void)
(	O
sdata	struct(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),long,long)
.	O
dirname	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_fsfolder_lsub	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(struct))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
,	O
const	O
char	O
*	O
ref	int
,	O
const	O
char	O
*	O
name	*(char)
,	O
mu_list_t	*(struct)
flist	*(struct)
)	O
{	O
struct	O
_mu_fsfolder	struct(*(char),*(struct))
*	O
fsfolder	*(struct(*(char),*(struct)))
=	O
folder	*(struct)
->	O
data	*(void)
;	O
int	O
rc	int
;	O
char	O
*	O
pattern	*(void)
;	O
mu_iterator_t	*(struct)
itr	*(*(struct))
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
||	O
*	O
name	*(char)
==	O
'\0'	O
)	O
name	*(char)
=	O
"*"	*(char)
;	O
if	O
(	O
!	O
fsfolder	*(struct(*(char),*(struct)))
->	O
subscription	*(struct)
&&	O
(	O
rc	int
=	O
open_subscription	(*(struct(*(char),*(struct))))->(int)
(	O
fsfolder	*(struct(*(char),*(struct)))
)	O
)	O
)	O
return	O
rc	int
;	O
pattern	*(void)
=	O
mu_make_file_name	O
(	O
ref	int
,	O
name	*(char)
)	O
;	O
rc	int
=	O
mu_property_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
fsfolder	*(struct(*(char),*(struct)))
->	O
subscription	*(struct)
,	O
&	O
itr	*(*(struct))
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(*(struct))
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(*(struct))
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(*(struct))
)	O
)	O
{	O
const	O
char	O
*	O
key	*(char)
,	O
*	O
val	array(int)
;	O
mu_iterator_current_kv	(*(struct),*(*(void)),*(*(void)))->(int)
(	O
itr	*(*(struct))
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
key	*(char)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
val	array(int)
)	O
;	O
if	O
(	O
fnmatch	(*(char),*(char),int)->(int)
(	O
pattern	*(void)
,	O
key	*(char)
,	O
0	int
)	O
==	O
0	int
)	O
{	O
struct	O
mu_list_response	struct(int,int,int,*(char),*(struct))
*	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
;	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
)	O
)	O
;	O
if	O
(	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
==	O
NULL	O
)	O
{	O
rc	int
=	O
ENOMEM	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
(	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
key	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
)	O
;	O
rc	int
=	O
ENOMEM	int
;	O
break	O
;	O
}	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
type	enum(int,int,int,int)
=	O
MU_FOLDER_ATTRIBUTE_FILE	int
;	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
depth	int
=	O
0	int
;	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
separator	int
=	O
'/'	O
;	O
rc	int
=	O
mu_list_append	(*(struct),*(void))->(int)
(	O
flist	*(struct)
,	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
free	(*(void))->(void)
(	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
)	O
;	O
break	O
;	O
}	O
}	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(*(struct))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
pattern	*(void)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
_fsfolder_subscribe	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
_mu_fsfolder	struct(*(char),*(struct))
*	O
fsfolder	*(struct(*(char),*(struct)))
=	O
folder	*(struct)
->	O
data	*(void)
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
fsfolder	*(struct(*(char),*(struct)))
->	O
subscription	*(struct)
&&	O
(	O
rc	int
=	O
open_subscription	(*(struct(*(char),*(struct))))->(int)
(	O
fsfolder	*(struct(*(char),*(struct)))
)	O
)	O
)	O
return	O
rc	int
;	O
return	O
mu_property_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
fsfolder	*(struct(*(char),*(struct)))
->	O
subscription	*(struct)
,	O
name	*(char)
,	O
""	*(char)
,	O
1	int
)	O
;	O
}	O
static	O
int	O
_fsfolder_unsubscribe	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
_mu_fsfolder	struct(*(char),*(struct))
*	O
fsfolder	*(struct(*(char),*(struct)))
=	O
folder	*(struct)
->	O
data	*(void)
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
fsfolder	*(struct(*(char),*(struct)))
->	O
subscription	*(struct)
&&	O
(	O
rc	int
=	O
open_subscription	(*(struct(*(char),*(struct))))->(int)
(	O
fsfolder	*(struct(*(char),*(struct)))
)	O
)	O
)	O
return	O
rc	int
;	O
return	O
mu_property_unset	(*(struct),*(char))->(int)
(	O
fsfolder	*(struct(*(char),*(struct)))
->	O
subscription	*(struct)
,	O
name	*(char)
)	O
;	O
}	O
static	O
int	O
_fsfolder_get_authority	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(*(struct)))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
,	O
mu_authority_t	*(struct)
*	O
pauth	*(*(struct))
)	O
{	O
int	O
status	int
=	O
0	int
;	O
if	O
(	O
folder	*(struct)
->	O
authority	*(struct)
==	O
NULL	O
)	O
status	int
=	O
mu_authority_create_null	(*(*(struct)),*(void))->(int)
(	O
&	O
folder	*(struct)
->	O
authority	*(struct)
,	O
folder	*(struct)
)	O
;	O
if	O
(	O
!	O
status	int
&&	O
pauth	*(*(struct))
)	O
*	O
pauth	*(*(struct))
=	O
folder	*(struct)
->	O
authority	*(struct)
;	O
return	O
status	int
;	O
}	O
int	O
_mu_fsfolder_init	(*(struct))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
)	O
{	O
struct	O
_mu_fsfolder	struct(*(char),*(struct))
*	O
dfolder	*(struct(*(char),*(struct)))
;	O
int	O
status	int
=	O
0	int
;	O
status	int
=	O
_fsfolder_get_authority	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(*(struct)))->(int)
(	O
folder	*(struct)
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
dfolder	*(struct(*(char),*(struct)))
=	O
folder	*(struct)
->	O
data	*(void)
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
dfolder	*(struct(*(char),*(struct)))
)	O
)	O
;	O
if	O
(	O
dfolder	*(struct(*(char),*(struct)))
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
status	int
=	O
mu_url_aget_path	(*(struct),*(*(char)))->(int)
(	O
folder	*(struct)
->	O
url	*(struct)
,	O
&	O
dfolder	*(struct(*(char),*(struct)))
->	O
dirname	*(char)
)	O
;	O
if	O
(	O
status	int
==	O
MU_ERR_NOENT	O
)	O
{	O
dfolder	*(struct(*(char),*(struct)))
->	O
dirname	*(char)
=	O
malloc	(long)->(*(void))
(	O
2	int
)	O
;	O
if	O
(	O
dfolder	*(struct(*(char),*(struct)))
->	O
dirname	*(char)
==	O
NULL	O
)	O
status	int
=	O
ENOMEM	int
;	O
else	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dfolder	*(struct(*(char),*(struct)))
->	O
dirname	*(char)
,	O
"."	*(char)
)	O
;	O
status	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
status	int
)	O
{	O
free	(*(void))->(void)
(	O
dfolder	*(struct(*(char),*(struct)))
)	O
;	O
folder	*(struct)
->	O
data	*(void)
=	O
NULL	O
;	O
return	O
status	int
;	O
}	O
folder	*(struct)
->	O
_destroy	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(void))
=	O
_fsfolder_destroy	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(void)
;	O
folder	*(struct)
->	O
_open	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),int)->(int))
=	O
_fsfolder_open	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),int)->(int)
;	O
folder	*(struct)
->	O
_close	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int))
=	O
_fsfolder_close	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
;	O
folder	*(struct)
->	O
_list	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(struct(*(char),*(void),int,long,*((*`,*`,*`)->(int)),*(void),*(struct`),*(struct`))))->(int))
=	O
_fsfolder_list	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(struct(*(char),*(void),int,long,*((*`,*`,*`)->(int)),*(void),*(struct),*(struct))))->(int)
;	O
folder	*(struct)
->	O
_lsub	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(struct))->(int))
=	O
_fsfolder_lsub	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(struct))->(int)
;	O
folder	*(struct)
->	O
_subscribe	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int))
=	O
_fsfolder_subscribe	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int)
;	O
folder	*(struct)
->	O
_unsubscribe	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int))
=	O
_fsfolder_unsubscribe	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int)
;	O
folder	*(struct)
->	O
_delete	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int))
=	O
NULL	O
;	O
folder	*(struct)
->	O
_rename	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char))->(int))
=	O
_fsfolder_rename	(*(struct(*(struct),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char))->(int)
;	O
return	O
0	int
;	O
}	O
