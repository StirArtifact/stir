typedef	O
int	O
(	O
*	O
md5func	*((*(char),*(char))->(int))
)	O
(	O
const	O
char	O
*	O
fn	*(char)
,	O
unsigned	O
char	O
*	O
digest	array(char)
)	O
;	O
int	O
rpmLookupSignatureType	(int)->(int)
(	O
int	O
action	int
)	O
{	O
static	O
int	O
disabled	int
=	O
0	int
;	O
int	O
rc	int
=	O
0	int
;	O
switch	O
(	O
action	int
)	O
{	O
case	O
RPMLOOKUPSIG_DISABLE	int
:	O
disabled	int
=	O
-	O
2	int
;	O
break	O
;	O
case	O
RPMLOOKUPSIG_ENABLE	int
:	O
disabled	int
=	O
0	int
;	O
case	O
RPMLOOKUPSIG_QUERY	int
:	O
if	O
(	O
disabled	int
)	O
break	O
;	O
{	O
const	O
char	O
*	O
name	*(char)
=	O
rpmExpand	(*(char))->(*(char))
(	O
"%{_signature}"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
name	*(char)
&&	O
*	O
name	*(char)
!=	O
'%'	O
)	O
)	O
rc	int
=	O
0	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"none"	*(char)
)	O
)	O
rc	int
=	O
0	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"pgp"	*(char)
)	O
)	O
rc	int
=	O
RPMSIGTAG_PGP	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"pgp5"	*(char)
)	O
)	O
rc	int
=	O
RPMSIGTAG_PGP	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"gpg"	*(char)
)	O
)	O
rc	int
=	O
RPMSIGTAG_GPG	int
;	O
else	O
rc	int
=	O
-	O
1	int
;	O
xfree	O
(	O
name	*(char)
)	O
;	O
}	O
break	O
;	O
}	O
return	O
rc	int
;	O
}	O
const	O
char	O
*	O
rpmDetectPGPVersion	(*(enum(int,int,int,int)))->(*(char))
(	O
pgpVersion	enum(int,int,int,int)
*	O
pgpVer	*(enum(int,int,int,int))
)	O
{	O
static	O
pgpVersion	enum(int,int,int,int)
saved_pgp_version	enum(int,int,int,int)
=	O
PGP_UNKNOWN	int
;	O
const	O
char	O
*	O
pgpbin	*(char)
=	O
rpmGetPath	(*(char))->(*(char))
(	O
"%{_pgpbin}"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
saved_pgp_version	enum(int,int,int,int)
==	O
PGP_UNKNOWN	int
)	O
{	O
char	O
*	O
pgpvbin	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
!	O
(	O
pgpbin	*(char)
&&	O
pgpbin	*(char)
[	O
0	int
]	O
!=	O
'%'	O
)	O
||	O
!	O
(	O
pgpvbin	*(char)
=	O
(	O
char	O
*	O
)	O
alloca	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
pgpbin	*(char)
)	O
+	O
2	int
)	O
)	O
)	O
{	O
if	O
(	O
pgpbin	*(char)
)	O
xfree	O
(	O
pgpbin	*(char)
)	O
;	O
saved_pgp_version	enum(int,int,int,int)
=	O
-	O
1	int
;	O
return	O
NULL	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
pgpvbin	*(char)
,	O
"%sv"	*(char)
,	O
pgpbin	*(char)
)	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
pgpvbin	*(char)
,	O
&	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
)	O
saved_pgp_version	enum(int,int,int,int)
=	O
PGP_5	int
;	O
else	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
pgpbin	*(char)
,	O
&	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
)	O
saved_pgp_version	enum(int,int,int,int)
=	O
PGP_2	int
;	O
else	O
saved_pgp_version	enum(int,int,int,int)
=	O
PGP_NOTDETECTED	int
;	O
}	O
if	O
(	O
pgpbin	*(char)
&&	O
pgpVer	*(enum(int,int,int,int))
)	O
*	O
pgpVer	*(enum(int,int,int,int))
=	O
saved_pgp_version	enum(int,int,int,int)
;	O
return	O
pgpbin	*(char)
;	O
}	O
static	O
int	O
checkSize	(*(struct),int,int)->(int)
(	O
FD_t	*(struct)
fd	*(struct)
,	O
int	O
size	long
,	O
int	O
sigsize	int
)	O
{	O
int	O
headerArchiveSize	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
Fileno	(*(struct))->(int)
(	O
fd	*(struct)
)	O
,	O
&	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
S_ISREG	O
(	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
headerArchiveSize	int
=	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
-	O
sizeof	O
(	O
struct	O
rpmlead	struct(array(char),char,char,short,short,array(char),short,short,array(char))
)	O
-	O
sigsize	int
;	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"sigsize         : %d\n"	*(char)
)	O
,	O
sigsize	int
)	O
;	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Header + Archive: %d\n"	*(char)
)	O
,	O
headerArchiveSize	int
)	O
;	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"expected size   : %d\n"	*(char)
)	O
,	O
size	long
)	O
;	O
return	O
size	long
-	O
headerArchiveSize	int
;	O
}	O
else	O
{	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"file is not regular -- skipping size check\n"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
int	O
rpmReadSignature	(*(struct),*(*(struct)),short)->(int)
(	O
FD_t	*(struct)
fd	*(struct)
,	O
Header	*(struct)
*	O
headerp	*(*(struct))
,	O
short	O
sig_type	short
)	O
{	O
unsigned	O
char	O
buf	*(char)
[	O
2048	int
]	O
;	O
int	O
sigSize	int
,	O
pad	int
;	O
int_32	int
type	enum(int,int,int,int)
,	O
count	long
;	O
int_32	int
*	O
archSize	*(int)
;	O
Header	*(struct)
h	*(struct)
;	O
if	O
(	O
headerp	*(*(struct))
)	O
*	O
headerp	*(*(struct))
=	O
NULL	O
;	O
switch	O
(	O
sig_type	short
)	O
{	O
case	O
RPMSIG_NONE	int
:	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"No signature\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
RPMSIG_PGP262_1024	int
:	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Old PGP signature\n"	*(char)
)	O
)	O
;	O
if	O
(	O
timedRead	(*(struct),*(void),int)->(int)
(	O
fd	*(struct)
,	O
buf	*(char)
,	O
256	int
)	O
!=	O
256	int
)	O
return	O
1	int
;	O
if	O
(	O
headerp	*(*(struct))
)	O
{	O
*	O
headerp	*(*(struct))
=	O
headerNew	()->(*(struct))
(	O
)	O
;	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
*	O
headerp	*(*(struct))
,	O
RPMSIGTAG_PGP	int
,	O
RPM_BIN_TYPE	int
,	O
buf	*(char)
,	O
152	int
)	O
;	O
}	O
break	O
;	O
case	O
RPMSIG_MD5	int
:	O
case	O
RPMSIG_MD5_PGP	int
:	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_BADSIGTYPE	O
,	O
_	O
(	O
"Old (internal-only) signature!  How did you get that!?"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
break	O
;	O
case	O
RPMSIG_HEADERSIG	int
:	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"New Header signature\n"	*(char)
)	O
)	O
;	O
h	*(struct)
=	O
headerRead	(*(struct),int)->(*(struct))
(	O
fd	*(struct)
,	O
HEADER_MAGIC_YES	int
)	O
;	O
if	O
(	O
h	*(struct)
==	O
NULL	O
)	O
return	O
1	int
;	O
sigSize	int
=	O
headerSizeof	(*(struct),int)->(int)
(	O
h	*(struct)
,	O
HEADER_MAGIC_YES	int
)	O
;	O
pad	int
=	O
(	O
8	int
-	O
(	O
sigSize	int
%	O
8	int
)	O
)	O
%	O
8	int
;	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Signature size: %d\n"	*(char)
)	O
,	O
sigSize	int
)	O
;	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Signature pad : %d\n"	*(char)
)	O
,	O
pad	int
)	O
;	O
if	O
(	O
!	O
headerGetEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
h	*(struct)
,	O
RPMSIGTAG_SIZE	int
,	O
&	O
type	enum(int,int,int,int)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
archSize	*(int)
,	O
&	O
count	long
)	O
)	O
{	O
headerFree	(*(struct))->(void)
(	O
h	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
checkSize	(*(struct),int,int)->(int)
(	O
fd	*(struct)
,	O
*	O
archSize	*(int)
,	O
sigSize	int
+	O
pad	int
)	O
)	O
{	O
headerFree	(*(struct))->(void)
(	O
h	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
pad	int
)	O
{	O
if	O
(	O
timedRead	(*(struct),*(void),int)->(int)
(	O
fd	*(struct)
,	O
buf	*(char)
,	O
pad	int
)	O
!=	O
pad	int
)	O
{	O
headerFree	(*(struct))->(void)
(	O
h	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
headerp	*(*(struct))
)	O
{	O
*	O
headerp	*(*(struct))
=	O
h	*(struct)
;	O
}	O
else	O
{	O
headerFree	(*(struct))->(void)
(	O
h	*(struct)
)	O
;	O
}	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rpmWriteSignature	(*(struct),*(struct))->(int)
(	O
FD_t	*(struct)
fd	*(struct)
,	O
Header	*(struct)
header	*(*(struct))
)	O
{	O
int	O
sigSize	int
,	O
pad	int
;	O
unsigned	O
char	O
buf	*(char)
[	O
8	int
]	O
;	O
int	O
rc	int
=	O
0	int
;	O
rc	int
=	O
headerWrite	(*(struct),*(struct),int)->(int)
(	O
fd	*(struct)
,	O
header	*(*(struct))
,	O
HEADER_MAGIC_YES	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
sigSize	int
=	O
headerSizeof	(*(struct),int)->(int)
(	O
header	*(*(struct))
,	O
HEADER_MAGIC_YES	int
)	O
;	O
pad	int
=	O
(	O
8	int
-	O
(	O
sigSize	int
%	O
8	int
)	O
)	O
%	O
8	int
;	O
if	O
(	O
pad	int
)	O
{	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Signature size: %d\n"	*(char)
)	O
,	O
sigSize	int
)	O
;	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Signature pad : %d\n"	*(char)
)	O
,	O
pad	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
buf	*(char)
,	O
0	int
,	O
pad	int
)	O
;	O
if	O
(	O
Fwrite	(*(void),long,long,*(struct))->(long)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
[	O
0	int
]	O
)	O
,	O
pad	int
,	O
fd	*(struct)
)	O
!=	O
pad	int
)	O
rc	int
=	O
1	int
;	O
}	O
return	O
rc	int
;	O
}	O
Header	*(struct)
rpmNewSignature	()->(*(struct))
(	O
void	O
)	O
{	O
Header	*(struct)
h	*(struct)
=	O
headerNew	()->(*(struct))
(	O
)	O
;	O
return	O
h	*(struct)
;	O
}	O
void	O
rpmFreeSignature	(*(struct))->(void)
(	O
Header	*(struct)
h	*(struct)
)	O
{	O
headerFree	(*(struct))->(void)
(	O
h	*(struct)
)	O
;	O
}	O
static	O
int	O
makePGPSignature	(*(char),*(*(void)),*(int),*(char))->(int)
(	O
const	O
char	O
*	O
file	*(char)
,	O
void	O
*	O
*	O
sig	*(void)
,	O
int_32	int
*	O
size	long
,	O
const	O
char	O
*	O
passPhrase	*(char)
)	O
{	O
char	O
sigfile	array(char)
[	O
1024	int
]	O
;	O
int	O
pid	int
,	O
status	int
;	O
int	O
inpipe	array(int)
[	O
2	int
]	O
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
sprintf	(*(char),*(char))->(int)
(	O
sigfile	array(char)
,	O
"%s.sig"	*(char)
,	O
file	*(char)
)	O
;	O
inpipe	array(int)
[	O
0	int
]	O
=	O
inpipe	array(int)
[	O
1	int
]	O
=	O
0	int
;	O
pipe	(array(int))->(int)
(	O
inpipe	array(int)
)	O
;	O
if	O
(	O
!	O
(	O
pid	int
=	O
fork	()->(int)
(	O
)	O
)	O
)	O
{	O
const	O
char	O
*	O
pgp_path	*(char)
=	O
rpmExpand	(*(char))->(*(char))
(	O
"%{_pgp_path}"	*(char)
,	O
NULL	O
)	O
;	O
const	O
char	O
*	O
name	*(char)
=	O
rpmExpand	(*(char))->(*(char))
(	O
"+myname=\"%{_pgp_name}\""	*(char)
,	O
NULL	O
)	O
;	O
const	O
char	O
*	O
path	*(char)
;	O
pgpVersion	enum(int,int,int,int)
pgpVer	*(enum(int,int,int,int))
;	O
close	*((*(void))->(int))
(	O
STDIN_FILENO	int
)	O
;	O
dup2	(int,int)->(int)
(	O
inpipe	array(int)
[	O
0	int
]	O
,	O
3	int
)	O
;	O
close	*((*(void))->(int))
(	O
inpipe	array(int)
[	O
1	int
]	O
)	O
;	O
dosetenv	(*(char),*(char),int)->(int)
(	O
"PGPPASSFD"	*(char)
,	O
"3"	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
pgp_path	*(char)
&&	O
*	O
pgp_path	*(char)
!=	O
'%'	O
)	O
dosetenv	(*(char),*(char),int)->(int)
(	O
"PGPPATH"	*(char)
,	O
pgp_path	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
(	O
path	*(char)
=	O
rpmDetectPGPVersion	(*(enum(int,int,int,int)))->(*(char))
(	O
&	O
pgpVer	*(enum(int,int,int,int))
)	O
)	O
!=	O
NULL	O
)	O
{	O
switch	O
(	O
pgpVer	*(enum(int,int,int,int))
)	O
{	O
case	O
PGP_2	int
:	O
execlp	(*(char),*(char))->(int)
(	O
path	*(char)
,	O
"pgp"	*(char)
,	O
"+batchmode=on"	*(char)
,	O
"+verbose=0"	*(char)
,	O
"+armor=off"	*(char)
,	O
name	*(char)
,	O
"-sb"	*(char)
,	O
file	*(char)
,	O
sigfile	array(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
PGP_5	int
:	O
execlp	(*(char),*(char))->(int)
(	O
path	*(char)
,	O
"pgps"	*(char)
,	O
"+batchmode=on"	*(char)
,	O
"+verbose=0"	*(char)
,	O
"+armor=off"	*(char)
,	O
name	*(char)
,	O
"-b"	*(char)
,	O
file	*(char)
,	O
"-o"	*(char)
,	O
sigfile	array(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
PGP_UNKNOWN	int
:	O
case	O
PGP_NOTDETECTED	int
:	O
break	O
;	O
}	O
}	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_EXEC	O
,	O
_	O
(	O
"Couldn't exec pgp (%s)"	*(char)
)	O
,	O
path	*(char)
)	O
;	O
_exit	(int)->(void)
(	O
RPMERR_EXEC	O
)	O
;	O
}	O
close	*((*(void))->(int))
(	O
inpipe	array(int)
[	O
0	int
]	O
)	O
;	O
(	O
void	O
)	O
write	*((*(void),*(char),long)->(long))
(	O
inpipe	array(int)
[	O
1	int
]	O
,	O
passPhrase	*(char)
,	O
strlen	(*(char))->(long)
(	O
passPhrase	*(char)
)	O
)	O
;	O
(	O
void	O
)	O
write	*((*(void),*(char),long)->(long))
(	O
inpipe	array(int)
[	O
1	int
]	O
,	O
"\n"	*(char)
,	O
1	int
)	O
;	O
close	*((*(void))->(int))
(	O
inpipe	array(int)
[	O
1	int
]	O
)	O
;	O
(	O
void	O
)	O
waitpid	(int,*(int),int)->(int)
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
WIFEXITED	O
(	O
status	int
)	O
||	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"pgp failed"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
sigfile	array(char)
,	O
&	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
{	O
unlink	(*(char))->(int)
(	O
sigfile	array(char)
)	O
;	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"pgp failed to write signature"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
*	O
size	long
=	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
;	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"PGP sig size: %d\n"	*(char)
)	O
,	O
*	O
size	long
)	O
;	O
*	O
sig	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
*	O
size	long
)	O
;	O
{	O
FD_t	*(struct)
fd	*(struct)
;	O
int	O
rc	int
;	O
fd	*(struct)
=	O
Fopen	(*(char),*(char))->(*(struct))
(	O
sigfile	array(char)
,	O
"r.fdio"	*(char)
)	O
;	O
rc	int
=	O
timedRead	(*(struct),*(void),int)->(int)
(	O
fd	*(struct)
,	O
*	O
sig	*(void)
,	O
*	O
size	long
)	O
;	O
unlink	(*(char))->(int)
(	O
sigfile	array(char)
)	O
;	O
Fclose	(*(struct))->(int)
(	O
fd	*(struct)
)	O
;	O
if	O
(	O
rc	int
!=	O
*	O
size	long
)	O
{	O
free	(*(void))->(void)
(	O
*	O
sig	*(void)
)	O
;	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"unable to read the signature"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Got %d bytes of PGP sig\n"	*(char)
)	O
,	O
*	O
size	long
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
makeGPGSignature	(*(char),*(*(void)),*(int),*(char))->(int)
(	O
const	O
char	O
*	O
file	*(char)
,	O
void	O
*	O
*	O
sig	*(void)
,	O
int_32	int
*	O
size	long
,	O
const	O
char	O
*	O
passPhrase	*(char)
)	O
{	O
char	O
sigfile	array(char)
[	O
1024	int
]	O
;	O
int	O
pid	int
,	O
status	int
;	O
int	O
inpipe	array(int)
[	O
2	int
]	O
;	O
FILE	struct
*	O
fpipe	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
sprintf	(*(char),*(char))->(int)
(	O
sigfile	array(char)
,	O
"%s.sig"	*(char)
,	O
file	*(char)
)	O
;	O
inpipe	array(int)
[	O
0	int
]	O
=	O
inpipe	array(int)
[	O
1	int
]	O
=	O
0	int
;	O
pipe	(array(int))->(int)
(	O
inpipe	array(int)
)	O
;	O
if	O
(	O
!	O
(	O
pid	int
=	O
fork	()->(int)
(	O
)	O
)	O
)	O
{	O
const	O
char	O
*	O
gpg_path	*(char)
=	O
rpmExpand	(*(char))->(*(char))
(	O
"%{_gpg_path}"	*(char)
,	O
NULL	O
)	O
;	O
const	O
char	O
*	O
name	*(char)
=	O
rpmExpand	(*(char))->(*(char))
(	O
"%{_gpg_name}"	*(char)
,	O
NULL	O
)	O
;	O
close	*((*(void))->(int))
(	O
STDIN_FILENO	int
)	O
;	O
dup2	(int,int)->(int)
(	O
inpipe	array(int)
[	O
0	int
]	O
,	O
3	int
)	O
;	O
close	*((*(void))->(int))
(	O
inpipe	array(int)
[	O
1	int
]	O
)	O
;	O
if	O
(	O
gpg_path	*(char)
&&	O
*	O
gpg_path	*(char)
!=	O
'%'	O
)	O
dosetenv	(*(char),*(char),int)->(int)
(	O
"GNUPGHOME"	*(char)
,	O
gpg_path	*(char)
,	O
1	int
)	O
;	O
execlp	(*(char),*(char))->(int)
(	O
"gpg"	*(char)
,	O
"gpg"	*(char)
,	O
"--batch"	*(char)
,	O
"--no-verbose"	*(char)
,	O
"--no-armor"	*(char)
,	O
"--passphrase-fd"	*(char)
,	O
"3"	*(char)
,	O
"-u"	*(char)
,	O
name	*(char)
,	O
"-sbo"	*(char)
,	O
sigfile	array(char)
,	O
file	*(char)
,	O
NULL	O
)	O
;	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_EXEC	O
,	O
_	O
(	O
"Couldn't exec gpg"	*(char)
)	O
)	O
;	O
_exit	(int)->(void)
(	O
RPMERR_EXEC	O
)	O
;	O
}	O
fpipe	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
inpipe	array(int)
[	O
1	int
]	O
,	O
"w"	*(char)
)	O
;	O
close	*((*(void))->(int))
(	O
inpipe	array(int)
[	O
0	int
]	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fpipe	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
passPhrase	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fpipe	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
(	O
void	O
)	O
waitpid	(int,*(int),int)->(int)
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
WIFEXITED	O
(	O
status	int
)	O
||	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"gpg failed"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
sigfile	array(char)
,	O
&	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
{	O
unlink	(*(char))->(int)
(	O
sigfile	array(char)
)	O
;	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"gpg failed to write signature"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
*	O
size	long
=	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
;	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"GPG sig size: %d\n"	*(char)
)	O
,	O
*	O
size	long
)	O
;	O
*	O
sig	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
*	O
size	long
)	O
;	O
{	O
FD_t	*(struct)
fd	*(struct)
;	O
int	O
rc	int
;	O
fd	*(struct)
=	O
Fopen	(*(char),*(char))->(*(struct))
(	O
sigfile	array(char)
,	O
"r.fdio"	*(char)
)	O
;	O
rc	int
=	O
timedRead	(*(struct),*(void),int)->(int)
(	O
fd	*(struct)
,	O
*	O
sig	*(void)
,	O
*	O
size	long
)	O
;	O
unlink	(*(char))->(int)
(	O
sigfile	array(char)
)	O
;	O
Fclose	(*(struct))->(int)
(	O
fd	*(struct)
)	O
;	O
if	O
(	O
rc	int
!=	O
*	O
size	long
)	O
{	O
free	(*(void))->(void)
(	O
*	O
sig	*(void)
)	O
;	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"unable to read the signature"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Got %d bytes of GPG sig\n"	*(char)
)	O
,	O
*	O
size	long
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rpmAddSignature	(*(struct),*(char),int,*(char))->(int)
(	O
Header	*(struct)
header	*(*(struct))
,	O
const	O
char	O
*	O
file	*(char)
,	O
int_32	int
sigTag	int
,	O
const	O
char	O
*	O
passPhrase	*(char)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int_32	int
size	long
;	O
unsigned	O
char	O
buf	*(char)
[	O
16	int
]	O
;	O
void	O
*	O
sig	*(void)
;	O
int	O
ret	int
=	O
-	O
1	int
;	O
switch	O
(	O
sigTag	int
)	O
{	O
case	O
RPMSIGTAG_SIZE	int
:	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
file	*(char)
,	O
&	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
size	long
=	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
;	O
ret	int
=	O
0	int
;	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
header	*(*(struct))
,	O
RPMSIGTAG_SIZE	int
,	O
RPM_INT32_TYPE	int
,	O
&	O
size	long
,	O
1	int
)	O
;	O
break	O
;	O
case	O
RPMSIGTAG_MD5	int
:	O
ret	int
=	O
mdbinfile	(*(char),*(char))->(int)
(	O
file	*(char)
,	O
buf	*(char)
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
header	*(*(struct))
,	O
sigTag	int
,	O
RPM_BIN_TYPE	int
,	O
buf	*(char)
,	O
16	int
)	O
;	O
break	O
;	O
case	O
RPMSIGTAG_PGP5	int
:	O
case	O
RPMSIGTAG_PGP	int
:	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_VERBOSE	int
,	O
_	O
(	O
"Generating signature using PGP.\n"	*(char)
)	O
)	O
;	O
ret	int
=	O
makePGPSignature	(*(char),*(*(void)),*(int),*(char))->(int)
(	O
file	*(char)
,	O
&	O
sig	*(void)
,	O
&	O
size	long
,	O
passPhrase	*(char)
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
header	*(*(struct))
,	O
sigTag	int
,	O
RPM_BIN_TYPE	int
,	O
sig	*(void)
,	O
size	long
)	O
;	O
break	O
;	O
case	O
RPMSIGTAG_GPG	int
:	O
rpmMessage	(int,*(char))->(void)
(	O
RPMMESS_VERBOSE	int
,	O
_	O
(	O
"Generating signature using GPG.\n"	*(char)
)	O
)	O
;	O
ret	int
=	O
makeGPGSignature	(*(char),*(*(void)),*(int),*(char))->(int)
(	O
file	*(char)
,	O
&	O
sig	*(void)
,	O
&	O
size	long
,	O
passPhrase	*(char)
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
header	*(*(struct))
,	O
sigTag	int
,	O
RPM_BIN_TYPE	int
,	O
sig	*(void)
,	O
size	long
)	O
;	O
break	O
;	O
}	O
return	O
ret	int
;	O
}	O
static	O
int	O
verifySizeSignature	(*(char),int,*(char))->(int)
(	O
const	O
char	O
*	O
datafile	*(char)
,	O
int_32	int
size	long
,	O
char	O
*	O
result	*(int)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
datafile	*(char)
,	O
&	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
size	long
!=	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
result	*(int)
,	O
"Header+Archive size mismatch.\n"	*(char)
"Expected %d, saw %d.\n"	*(char)
,	O
size	long
,	O
(	O
int	O
)	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
;	O
return	O
1	int
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
result	*(int)
,	O
"Header+Archive size OK: %d bytes\n"	*(char)
,	O
size	long
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
verifyMD5Signature	(*(char),*(char),*(char),*((*(char),*(char))->(int)))->(int)
(	O
const	O
char	O
*	O
datafile	*(char)
,	O
unsigned	O
char	O
*	O
sig	*(void)
,	O
char	O
*	O
result	*(int)
,	O
md5func	*((*(char),*(char))->(int))
fn	*(char)
)	O
{	O
unsigned	O
char	O
md5sum	array(char)
[	O
16	int
]	O
;	O
fn	*(char)
(	O
datafile	*(char)
,	O
md5sum	array(char)
)	O
;	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
md5sum	array(char)
,	O
sig	*(void)
,	O
16	int
)	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
result	*(int)
,	O
"MD5 sum mismatch\n"	*(char)
"Expected: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"	*(char)
"%02x%02x%02x%02x%02x\n"	*(char)
"Saw     : %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"	*(char)
"%02x%02x%02x%02x%02x\n"	*(char)
,	O
X	O
(	O
sig	*(void)
[	O
0	int
]	O
)	O
,	O
X	O
(	O
sig	*(void)
[	O
1	int
]	O
)	O
,	O
X	O
(	O
sig	*(void)
[	O
2	int
]	O
)	O
,	O
X	O
(	O
sig	*(void)
[	O
3	int
]	O
)	O
,	O
X	O
(	O
sig	*(void)
[	O
4	int
]	O
)	O
,	O
X	O
(	O
sig	*(void)
[	O
5	int
]	O
)	O
,	O
X	O
(	O
sig	*(void)
[	O
6	int
]	O
)	O
,	O
X	O
(	O
sig	*(void)
[	O
7	int
]	O
)	O
,	O
X	O
(	O
sig	*(void)
[	O
8	int
]	O
)	O
,	O
X	O
(	O
sig	*(void)
[	O
9	int
]	O
)	O
,	O
X	O
(	O
sig	*(void)
[	O
10	int
]	O
)	O
,	O
X	O
(	O
sig	*(void)
[	O
11	int
]	O
)	O
,	O
X	O
(	O
sig	*(void)
[	O
12	int
]	O
)	O
,	O
X	O
(	O
sig	*(void)
[	O
13	int
]	O
)	O
,	O
X	O
(	O
sig	*(void)
[	O
14	int
]	O
)	O
,	O
X	O
(	O
sig	*(void)
[	O
15	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
0	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
1	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
2	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
3	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
4	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
5	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
6	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
7	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
8	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
9	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
10	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
11	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
12	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
13	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
14	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
15	int
]	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
result	*(int)
,	O
"MD5 sum OK: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"	*(char)
"%02x%02x%02x%02x%02x\n"	*(char)
,	O
X	O
(	O
md5sum	array(char)
[	O
0	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
1	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
2	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
3	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
4	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
5	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
6	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
7	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
8	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
9	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
10	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
11	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
12	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
13	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
14	int
]	O
)	O
,	O
X	O
(	O
md5sum	array(char)
[	O
15	int
]	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
verifyPGPSignature	(*(char),*(void),int,*(char))->(int)
(	O
const	O
char	O
*	O
datafile	*(char)
,	O
void	O
*	O
sig	*(void)
,	O
int	O
count	long
,	O
char	O
*	O
result	*(int)
)	O
{	O
int	O
pid	int
,	O
status	int
,	O
outpipe	array(int)
[	O
2	int
]	O
;	O
FD_t	*(struct)
sfd	*(struct)
;	O
char	O
*	O
sigfile	array(char)
;	O
unsigned	O
char	O
buf	*(char)
[	O
BUFSIZ	int
]	O
;	O
FILE	struct
*	O
file	*(char)
;	O
int	O
res	int
=	O
RPMSIG_OK	int
;	O
const	O
char	O
*	O
path	*(char)
;	O
pgpVersion	enum(int,int,int,int)
pgpVer	*(enum(int,int,int,int))
;	O
if	O
(	O
(	O
path	*(char)
=	O
rpmDetectPGPVersion	(*(enum(int,int,int,int)))->(*(char))
(	O
&	O
pgpVer	*(enum(int,int,int,int))
)	O
)	O
==	O
NULL	O
)	O
{	O
errno	O
=	O
ENOENT	int
;	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_EXEC	O
,	O
_	O
(	O
"Could not run pgp.  Use --nopgp to skip PGP checks."	*(char)
)	O
)	O
;	O
_exit	(int)->(void)
(	O
RPMERR_EXEC	O
)	O
;	O
}	O
if	O
(	O
pgpVer	*(enum(int,int,int,int))
==	O
PGP_5	int
)	O
res	int
=	O
RPMSIG_BAD	int
;	O
{	O
const	O
char	O
*	O
tmppath	*(char)
=	O
rpmGetPath	(*(char))->(*(char))
(	O
"%{_tmppath}"	*(char)
,	O
NULL	O
)	O
;	O
sigfile	array(char)
=	O
tempnam	(*(char),*(char))->(*(char))
(	O
tmppath	*(char)
,	O
"rpmsig"	*(char)
)	O
;	O
xfree	O
(	O
tmppath	*(char)
)	O
;	O
}	O
sfd	*(struct)
=	O
Fopen	(*(char),*(char))->(*(struct))
(	O
sigfile	array(char)
,	O
"w.fdio"	*(char)
)	O
;	O
(	O
void	O
)	O
Fwrite	(*(void),long,long,*(struct))->(long)
(	O
sig	*(void)
,	O
sizeof	O
(	O
char	O
)	O
,	O
count	long
,	O
sfd	*(struct)
)	O
;	O
Fclose	(*(struct))->(int)
(	O
sfd	*(struct)
)	O
;	O
outpipe	array(int)
[	O
0	int
]	O
=	O
outpipe	array(int)
[	O
1	int
]	O
=	O
0	int
;	O
pipe	(array(int))->(int)
(	O
outpipe	array(int)
)	O
;	O
if	O
(	O
!	O
(	O
pid	int
=	O
fork	()->(int)
(	O
)	O
)	O
)	O
{	O
const	O
char	O
*	O
pgp_path	*(char)
=	O
rpmExpand	(*(char))->(*(char))
(	O
"%{_pgp_path}"	*(char)
,	O
NULL	O
)	O
;	O
close	*((*(void))->(int))
(	O
outpipe	array(int)
[	O
0	int
]	O
)	O
;	O
close	*((*(void))->(int))
(	O
STDOUT_FILENO	int
)	O
;	O
dup2	(int,int)->(int)
(	O
outpipe	array(int)
[	O
1	int
]	O
,	O
STDOUT_FILENO	int
)	O
;	O
if	O
(	O
pgp_path	*(char)
&&	O
*	O
pgp_path	*(char)
!=	O
'%'	O
)	O
dosetenv	(*(char),*(char),int)->(int)
(	O
"PGPPATH"	*(char)
,	O
pgp_path	*(char)
,	O
1	int
)	O
;	O
switch	O
(	O
pgpVer	*(enum(int,int,int,int))
)	O
{	O
case	O
PGP_5	int
:	O
{	O
int	O
save_stderr	int
=	O
dup	(int)->(int)
(	O
2	int
)	O
;	O
dup2	(int,int)->(int)
(	O
1	int
,	O
2	int
)	O
;	O
execlp	(*(char),*(char))->(int)
(	O
path	*(char)
,	O
"pgpv"	*(char)
,	O
"+batchmode=on"	*(char)
,	O
"+verbose=0"	*(char)
,	O
"+OutputInformationFD=1"	*(char)
,	O
"+OutputWarningFD=1"	*(char)
,	O
sigfile	array(char)
,	O
"-o"	*(char)
,	O
datafile	*(char)
,	O
NULL	O
)	O
;	O
dup2	(int,int)->(int)
(	O
save_stderr	int
,	O
2	int
)	O
;	O
close	*((*(void))->(int))
(	O
save_stderr	int
)	O
;	O
}	O
break	O
;	O
case	O
PGP_2	int
:	O
execlp	(*(char),*(char))->(int)
(	O
path	*(char)
,	O
"pgp"	*(char)
,	O
"+batchmode=on"	*(char)
,	O
"+verbose=0"	*(char)
,	O
sigfile	array(char)
,	O
datafile	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
PGP_UNKNOWN	int
:	O
case	O
PGP_NOTDETECTED	int
:	O
break	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"exec failed!\n"	*(char)
)	O
)	O
;	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_EXEC	O
,	O
_	O
(	O
"Could not run pgp.  Use --nopgp to skip PGP checks."	*(char)
)	O
)	O
;	O
_exit	(int)->(void)
(	O
RPMERR_EXEC	O
)	O
;	O
}	O
close	*((*(void))->(int))
(	O
outpipe	array(int)
[	O
1	int
]	O
)	O
;	O
file	*(char)
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
outpipe	array(int)
[	O
0	int
]	O
,	O
"r"	*(char)
)	O
;	O
result	*(int)
[	O
0	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
1024	int
,	O
file	*(char)
)	O
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
"File '"	*(char)
,	O
buf	*(char)
,	O
6	int
)	O
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
"Text is assu"	*(char)
,	O
buf	*(char)
,	O
12	int
)	O
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
"This signature applies to another message"	*(char)
,	O
buf	*(char)
,	O
41	int
)	O
&&	O
buf	*(char)
[	O
0	int
]	O
!=	O
'\n'	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
result	*(int)
,	O
buf	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
"WARNING: Can't find the right public key"	*(char)
,	O
buf	*(char)
,	O
40	int
)	O
)	O
res	int
=	O
RPMSIG_NOKEY	int
;	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
"Signature by unknown keyid:"	*(char)
,	O
buf	*(char)
,	O
27	int
)	O
)	O
res	int
=	O
RPMSIG_NOKEY	int
;	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
"WARNING: The signing key is not trusted"	*(char)
,	O
buf	*(char)
,	O
39	int
)	O
)	O
res	int
=	O
RPMSIG_NOTTRUSTED	int
;	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
"Good signature"	*(char)
,	O
buf	*(char)
,	O
14	int
)	O
)	O
res	int
=	O
RPMSIG_OK	int
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(char)
)	O
;	O
(	O
void	O
)	O
waitpid	(int,*(int),int)->(int)
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
unlink	(*(char))->(int)
(	O
sigfile	array(char)
)	O
;	O
if	O
(	O
!	O
res	int
&&	O
(	O
!	O
WIFEXITED	O
(	O
status	int
)	O
||	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
)	O
{	O
res	int
=	O
RPMSIG_BAD	int
;	O
}	O
return	O
res	int
;	O
}	O
static	O
int	O
verifyGPGSignature	(*(char),*(void),int,*(char))->(int)
(	O
const	O
char	O
*	O
datafile	*(char)
,	O
void	O
*	O
sig	*(void)
,	O
int	O
count	long
,	O
char	O
*	O
result	*(int)
)	O
{	O
int	O
pid	int
,	O
status	int
,	O
outpipe	array(int)
[	O
2	int
]	O
;	O
FD_t	*(struct)
sfd	*(struct)
;	O
char	O
*	O
sigfile	array(char)
;	O
unsigned	O
char	O
buf	*(char)
[	O
8192	int
]	O
;	O
FILE	struct
*	O
file	*(char)
;	O
int	O
res	int
=	O
RPMSIG_OK	int
;	O
{	O
const	O
char	O
*	O
tmppath	*(char)
=	O
rpmGetPath	(*(char))->(*(char))
(	O
"%{_tmppath}"	*(char)
,	O
NULL	O
)	O
;	O
sigfile	array(char)
=	O
tempnam	(*(char),*(char))->(*(char))
(	O
tmppath	*(char)
,	O
"rpmsig"	*(char)
)	O
;	O
xfree	O
(	O
tmppath	*(char)
)	O
;	O
}	O
sfd	*(struct)
=	O
Fopen	(*(char),*(char))->(*(struct))
(	O
sigfile	array(char)
,	O
"w.fdio"	*(char)
)	O
;	O
(	O
void	O
)	O
Fwrite	(*(void),long,long,*(struct))->(long)
(	O
sig	*(void)
,	O
sizeof	O
(	O
char	O
)	O
,	O
count	long
,	O
sfd	*(struct)
)	O
;	O
Fclose	(*(struct))->(int)
(	O
sfd	*(struct)
)	O
;	O
outpipe	array(int)
[	O
0	int
]	O
=	O
outpipe	array(int)
[	O
1	int
]	O
=	O
0	int
;	O
pipe	(array(int))->(int)
(	O
outpipe	array(int)
)	O
;	O
if	O
(	O
!	O
(	O
pid	int
=	O
fork	()->(int)
(	O
)	O
)	O
)	O
{	O
const	O
char	O
*	O
gpg_path	*(char)
=	O
rpmExpand	(*(char))->(*(char))
(	O
"%{_gpg_path}"	*(char)
,	O
NULL	O
)	O
;	O
close	*((*(void))->(int))
(	O
outpipe	array(int)
[	O
0	int
]	O
)	O
;	O
dup2	(int,int)->(int)
(	O
outpipe	array(int)
[	O
1	int
]	O
,	O
STDERR_FILENO	int
)	O
;	O
if	O
(	O
gpg_path	*(char)
&&	O
*	O
gpg_path	*(char)
!=	O
'%'	O
)	O
dosetenv	(*(char),*(char),int)->(int)
(	O
"GNUPGHOME"	*(char)
,	O
gpg_path	*(char)
,	O
1	int
)	O
;	O
execlp	(*(char),*(char))->(int)
(	O
"gpg"	*(char)
,	O
"gpg"	*(char)
,	O
"--batch"	*(char)
,	O
"--no-verbose"	*(char)
,	O
"--verify"	*(char)
,	O
sigfile	array(char)
,	O
datafile	*(char)
,	O
NULL	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"exec failed!\n"	*(char)
)	O
)	O
;	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_EXEC	O
,	O
_	O
(	O
"Could not run gpg.  Use --nogpg to skip GPG checks."	*(char)
)	O
)	O
;	O
_exit	(int)->(void)
(	O
RPMERR_EXEC	O
)	O
;	O
}	O
close	*((*(void))->(int))
(	O
outpipe	array(int)
[	O
1	int
]	O
)	O
;	O
file	*(char)
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
outpipe	array(int)
[	O
0	int
]	O
,	O
"r"	*(char)
)	O
;	O
result	*(int)
[	O
0	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
1024	int
,	O
file	*(char)
)	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
result	*(int)
,	O
buf	*(char)
)	O
;	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
"gpg: Can't check signature: Public key not found"	*(char)
,	O
buf	*(char)
,	O
48	int
)	O
)	O
{	O
res	int
=	O
RPMSIG_NOKEY	int
;	O
}	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(char)
)	O
;	O
(	O
void	O
)	O
waitpid	(int,*(int),int)->(int)
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
unlink	(*(char))->(int)
(	O
sigfile	array(char)
)	O
;	O
if	O
(	O
!	O
res	int
&&	O
(	O
!	O
WIFEXITED	O
(	O
status	int
)	O
||	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
)	O
{	O
res	int
=	O
RPMSIG_BAD	int
;	O
}	O
return	O
res	int
;	O
}	O
static	O
int	O
checkPassPhrase	(*(char),int)->(int)
(	O
const	O
char	O
*	O
passPhrase	*(char)
,	O
const	O
int	O
sigTag	int
)	O
{	O
int	O
passPhrasePipe	array(int)
[	O
2	int
]	O
;	O
int	O
pid	int
,	O
status	int
;	O
int	O
fd	*(struct)
;	O
passPhrasePipe	array(int)
[	O
0	int
]	O
=	O
passPhrasePipe	array(int)
[	O
1	int
]	O
=	O
0	int
;	O
pipe	(array(int))->(int)
(	O
passPhrasePipe	array(int)
)	O
;	O
if	O
(	O
!	O
(	O
pid	int
=	O
fork	()->(int)
(	O
)	O
)	O
)	O
{	O
close	*((*(void))->(int))
(	O
STDIN_FILENO	int
)	O
;	O
close	*((*(void))->(int))
(	O
STDOUT_FILENO	int
)	O
;	O
close	*((*(void))->(int))
(	O
passPhrasePipe	array(int)
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
rpmIsVerbose	()->(int)
(	O
)	O
)	O
{	O
close	*((*(void))->(int))
(	O
STDERR_FILENO	int
)	O
;	O
}	O
if	O
(	O
(	O
fd	*(struct)
=	O
open	(*(char),int)->(int)
(	O
"/dev/null"	*(char)
,	O
O_RDONLY	int
)	O
)	O
!=	O
STDIN_FILENO	int
)	O
{	O
dup2	(int,int)->(int)
(	O
fd	*(struct)
,	O
STDIN_FILENO	int
)	O
;	O
close	*((*(void))->(int))
(	O
fd	*(struct)
)	O
;	O
}	O
if	O
(	O
(	O
fd	*(struct)
=	O
open	(*(char),int)->(int)
(	O
"/dev/null"	*(char)
,	O
O_WRONLY	int
)	O
)	O
!=	O
STDOUT_FILENO	int
)	O
{	O
dup2	(int,int)->(int)
(	O
fd	*(struct)
,	O
STDOUT_FILENO	int
)	O
;	O
close	*((*(void))->(int))
(	O
fd	*(struct)
)	O
;	O
}	O
dup2	(int,int)->(int)
(	O
passPhrasePipe	array(int)
[	O
0	int
]	O
,	O
3	int
)	O
;	O
switch	O
(	O
sigTag	int
)	O
{	O
case	O
RPMSIGTAG_GPG	int
:	O
{	O
const	O
char	O
*	O
gpg_path	*(char)
=	O
rpmExpand	(*(char))->(*(char))
(	O
"%{_gpg_path}"	*(char)
,	O
NULL	O
)	O
;	O
const	O
char	O
*	O
name	*(char)
=	O
rpmExpand	(*(char))->(*(char))
(	O
"%{_gpg_name}"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
gpg_path	*(char)
&&	O
*	O
gpg_path	*(char)
!=	O
'%'	O
)	O
dosetenv	(*(char),*(char),int)->(int)
(	O
"GNUPGHOME"	*(char)
,	O
gpg_path	*(char)
,	O
1	int
)	O
;	O
execlp	(*(char),*(char))->(int)
(	O
"gpg"	*(char)
,	O
"gpg"	*(char)
,	O
"--batch"	*(char)
,	O
"--no-verbose"	*(char)
,	O
"--passphrase-fd"	*(char)
,	O
"3"	*(char)
,	O
"-u"	*(char)
,	O
name	*(char)
,	O
"-so"	*(char)
,	O
"-"	*(char)
,	O
NULL	O
)	O
;	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_EXEC	O
,	O
_	O
(	O
"Couldn't exec gpg"	*(char)
)	O
)	O
;	O
_exit	(int)->(void)
(	O
RPMERR_EXEC	O
)	O
;	O
}	O
break	O
;	O
case	O
RPMSIGTAG_PGP5	int
:	O
case	O
RPMSIGTAG_PGP	int
:	O
{	O
const	O
char	O
*	O
pgp_path	*(char)
=	O
rpmExpand	(*(char))->(*(char))
(	O
"%{_pgp_path}"	*(char)
,	O
NULL	O
)	O
;	O
const	O
char	O
*	O
name	*(char)
=	O
rpmExpand	(*(char))->(*(char))
(	O
"+myname=\"%{_pgp_name}\""	*(char)
,	O
NULL	O
)	O
;	O
const	O
char	O
*	O
path	*(char)
;	O
pgpVersion	enum(int,int,int,int)
pgpVer	*(enum(int,int,int,int))
;	O
dosetenv	(*(char),*(char),int)->(int)
(	O
"PGPPASSFD"	*(char)
,	O
"3"	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
pgp_path	*(char)
&&	O
*	O
pgp_path	*(char)
!=	O
'%'	O
)	O
dosetenv	(*(char),*(char),int)->(int)
(	O
"PGPPATH"	*(char)
,	O
pgp_path	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
(	O
path	*(char)
=	O
rpmDetectPGPVersion	(*(enum(int,int,int,int)))->(*(char))
(	O
&	O
pgpVer	*(enum(int,int,int,int))
)	O
)	O
!=	O
NULL	O
)	O
{	O
switch	O
(	O
pgpVer	*(enum(int,int,int,int))
)	O
{	O
case	O
PGP_2	int
:	O
execlp	(*(char),*(char))->(int)
(	O
path	*(char)
,	O
"pgp"	*(char)
,	O
"+batchmode=on"	*(char)
,	O
"+verbose=0"	*(char)
,	O
name	*(char)
,	O
"-sf"	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
PGP_5	int
:	O
execlp	(*(char),*(char))->(int)
(	O
path	*(char)
,	O
"pgps"	*(char)
,	O
"+batchmode=on"	*(char)
,	O
"+verbose=0"	*(char)
,	O
name	*(char)
,	O
"-f"	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
PGP_UNKNOWN	int
:	O
case	O
PGP_NOTDETECTED	int
:	O
break	O
;	O
}	O
}	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_EXEC	O
,	O
_	O
(	O
"Couldn't exec pgp"	*(char)
)	O
)	O
;	O
_exit	(int)->(void)
(	O
RPMERR_EXEC	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"Invalid %%_signature spec in macro file"	*(char)
)	O
)	O
;	O
_exit	(int)->(void)
(	O
RPMERR_SIGGEN	O
)	O
;	O
break	O
;	O
}	O
}	O
close	*((*(void))->(int))
(	O
passPhrasePipe	array(int)
[	O
0	int
]	O
)	O
;	O
(	O
void	O
)	O
write	*((*(void),*(char),long)->(long))
(	O
passPhrasePipe	array(int)
[	O
1	int
]	O
,	O
passPhrase	*(char)
,	O
strlen	(*(char))->(long)
(	O
passPhrase	*(char)
)	O
)	O
;	O
(	O
void	O
)	O
write	*((*(void),*(char),long)->(long))
(	O
passPhrasePipe	array(int)
[	O
1	int
]	O
,	O
"\n"	*(char)
,	O
1	int
)	O
;	O
close	*((*(void))->(int))
(	O
passPhrasePipe	array(int)
[	O
1	int
]	O
)	O
;	O
(	O
void	O
)	O
waitpid	(int,*(int),int)->(int)
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
WIFEXITED	O
(	O
status	int
)	O
||	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
{	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
char	O
*	O
rpmGetPassPhrase	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
prompt	*(char)
,	O
const	O
int	O
sigTag	int
)	O
{	O
char	O
*	O
pass	*(char)
;	O
int	O
aok	int
;	O
switch	O
(	O
sigTag	int
)	O
{	O
case	O
RPMSIGTAG_GPG	int
:	O
{	O
const	O
char	O
*	O
name	*(char)
=	O
rpmExpand	(*(char))->(*(char))
(	O
"%{_gpg_name}"	*(char)
,	O
NULL	O
)	O
;	O
aok	int
=	O
(	O
name	*(char)
&&	O
*	O
name	*(char)
!=	O
'%'	O
)	O
;	O
xfree	O
(	O
name	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
aok	int
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"You must set \"%%_gpg_name\" in your macro file"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
break	O
;	O
case	O
RPMSIGTAG_PGP5	int
:	O
case	O
RPMSIGTAG_PGP	int
:	O
{	O
const	O
char	O
*	O
name	*(char)
=	O
rpmExpand	(*(char))->(*(char))
(	O
"%{_pgp_name}"	*(char)
,	O
NULL	O
)	O
;	O
aok	int
=	O
(	O
name	*(char)
&&	O
*	O
name	*(char)
!=	O
'%'	O
)	O
;	O
xfree	O
(	O
name	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
aok	int
)	O
{	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"You must set \"%%_pgp_name\" in your macro file"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
break	O
;	O
default	O
:	O
rpmError	(int,*(char))->(void)
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"Invalid %%_signature spec in macro file"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
break	O
;	O
}	O
pass	*(char)
=	O
getpass	(*(char))->(*(char))
(	O
(	O
prompt	*(char)
?	O
prompt	*(char)
:	O
""	*(char)
)	O
)	O
;	O
if	O
(	O
checkPassPhrase	(*(char),int)->(int)
(	O
pass	*(char)
,	O
sigTag	int
)	O
)	O
return	O
NULL	O
;	O
return	O
pass	*(char)
;	O
}	O
int	O
rpmVerifySignature	(*(char),int,*(void),int,*(char))->(int)
(	O
const	O
char	O
*	O
file	*(char)
,	O
int_32	int
sigTag	int
,	O
void	O
*	O
sig	*(void)
,	O
int	O
count	long
,	O
char	O
*	O
result	*(int)
)	O
{	O
switch	O
(	O
sigTag	int
)	O
{	O
case	O
RPMSIGTAG_SIZE	int
:	O
if	O
(	O
verifySizeSignature	(*(char),int,*(char))->(int)
(	O
file	*(char)
,	O
*	O
(	O
int_32	int
*	O
)	O
sig	*(void)
,	O
result	*(int)
)	O
)	O
{	O
return	O
RPMSIG_BAD	int
;	O
}	O
break	O
;	O
case	O
RPMSIGTAG_MD5	int
:	O
if	O
(	O
verifyMD5Signature	(*(char),*(char),*(char),*((*(char),*(char))->(int)))->(int)
(	O
file	*(char)
,	O
sig	*(void)
,	O
result	*(int)
,	O
mdbinfile	(*(char),*(char))->(int)
)	O
)	O
{	O
return	O
1	int
;	O
}	O
break	O
;	O
case	O
RPMSIGTAG_LEMD5_1	int
:	O
case	O
RPMSIGTAG_LEMD5_2	int
:	O
if	O
(	O
verifyMD5Signature	(*(char),*(char),*(char),*((*(char),*(char))->(int)))->(int)
(	O
file	*(char)
,	O
sig	*(void)
,	O
result	*(int)
,	O
mdbinfileBroken	(*(char),*(char))->(int)
)	O
)	O
{	O
return	O
1	int
;	O
}	O
break	O
;	O
case	O
RPMSIGTAG_PGP5	int
:	O
case	O
RPMSIGTAG_PGP	int
:	O
return	O
verifyPGPSignature	(*(char),*(void),int,*(char))->(int)
(	O
file	*(char)
,	O
sig	*(void)
,	O
count	long
,	O
result	*(int)
)	O
;	O
break	O
;	O
case	O
RPMSIGTAG_GPG	int
:	O
return	O
verifyGPGSignature	(*(char),*(void),int,*(char))->(int)
(	O
file	*(char)
,	O
sig	*(void)
,	O
count	long
,	O
result	*(int)
)	O
;	O
break	O
;	O
default	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
result	*(int)
,	O
"Do not know how to verify sig type %d\n"	*(char)
,	O
sigTag	int
)	O
;	O
return	O
RPMSIG_UNKNOWN	int
;	O
}	O
return	O
RPMSIG_OK	int
;	O
}	O
