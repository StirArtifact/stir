struct	O
port_bucket	O
*	O
sock_port_bucket	*(struct)
;	O
static	O
int	O
sock_server_active	int
=	O
0	int
;	O
static	O
pthread_spinlock_t	int
sock_server_active_lock	int
=	O
PTHREAD_SPINLOCK_INITIALIZER	O
;	O
static	O
int	O
sock_demuxer	(*(int),*(int))->(int)
(	O
mach_msg_header_t	O
*	O
inp	*(int)
,	O
mach_msg_header_t	O
*	O
outp	*(int)
)	O
{	O
mig_routine_t	O
routine	O
;	O
if	O
(	O
(	O
routine	O
=	O
io_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
fs_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
socket_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
ports_interrupt_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
ports_notify_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
)	O
{	O
(	O
*	O
routine	O
)	O
(	O
inp	*(int)
,	O
outp	*(int)
)	O
;	O
return	O
TRUE	O
;	O
}	O
else	O
return	O
FALSE	O
;	O
}	O
static	O
void	O
*	O
handle_sock_requests	(*(void))->(*(void))
(	O
void	O
*	O
unused	*(void)
)	O
{	O
while	O
(	O
ports_count_bucket	()->(int)
(	O
sock_port_bucket	*(struct)
)	O
>	O
0	int
)	O
{	O
ports_enable_bucket	()->(int)
(	O
sock_port_bucket	*(struct)
)	O
;	O
ports_manage_port_operations_multithread	()->(int)
(	O
sock_port_bucket	*(struct)
,	O
sock_demuxer	(*(int),*(int))->(int)
,	O
30	int
*	O
1000	int
,	O
2	int
*	O
60	int
*	O
1000	int
,	O
0	int
)	O
;	O
}	O
pthread_spin_lock	(*(int))->(int)
(	O
&	O
sock_server_active_lock	int
)	O
;	O
sock_server_active	int
=	O
0	int
;	O
pthread_spin_unlock	(*(int))->(int)
(	O
&	O
sock_server_active_lock	int
)	O
;	O
ports_enable_bucket	()->(int)
(	O
sock_port_bucket	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
ensure_sock_server	()->(void)
(	O
)	O
{	O
pthread_t	long
thread	long
;	O
error_t	O
err	O
;	O
pthread_spin_lock	(*(int))->(int)
(	O
&	O
sock_server_active_lock	int
)	O
;	O
if	O
(	O
sock_server_active	int
)	O
pthread_spin_unlock	(*(int))->(int)
(	O
&	O
sock_server_active_lock	int
)	O
;	O
else	O
{	O
sock_server_active	int
=	O
1	int
;	O
pthread_spin_unlock	(*(int))->(int)
(	O
&	O
sock_server_active_lock	int
)	O
;	O
err	O
=	O
pthread_create	(*(long),*(union(array(char),long)),*((*(void))->(*(void))),*(void))->(int)
(	O
&	O
thread	long
,	O
NULL	O
,	O
handle_sock_requests	(*(void))->(*(void))
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
pthread_detach	(long)->(int)
(	O
thread	long
)	O
;	O
else	O
{	O
errno	O
=	O
err	O
;	O
perror	(*(char))->(void)
(	O
"pthread_create"	*(char)
)	O
;	O
}	O
}	O
}	O
