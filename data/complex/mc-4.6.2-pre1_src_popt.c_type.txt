void	O
poptSetExecPath	(*(struct),*(char),int)->(void)
(	O
poptContext	*(struct)
con	*(struct)
,	O
const	O
char	O
*	O
path	*(char)
,	O
int	O
allowAbsolute	int
)	O
{	O
if	O
(	O
con	*(struct)
->	O
execPath	*(char)
)	O
free	(*(void))->(void)
(	O
con	*(struct)
->	O
execPath	*(char)
)	O
;	O
con	*(struct)
->	O
execPath	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
path	*(char)
)	O
;	O
con	*(struct)
->	O
execAbsolute	int
=	O
allowAbsolute	int
;	O
}	O
static	O
void	O
invokeCallbacks	(*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct(int,*`,int,*`,*`,*`,int)),*(*(char)),int,int,*(struct(*`,char,int,*`,int,*`,*`)),int,*(char),*(struct(*`,char,int,*`)),int,int,*(struct(*`,char,*`)),int,*(*(char)),int,int,*(struct(*`,char,*`)),*(char),int,*(char))),*(struct(*(char),char,int,*(void),int,*(char),*(char))),int)->(void)
(	O
poptContext	*(struct)
con	*(struct)
,	O
const	O
struct	O
poptOption	struct(*(char),char,int,*(void),int,*(char),*(char))
*	O
table	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
,	O
int	O
post	int
)	O
{	O
const	O
struct	O
poptOption	struct(*(char),char,int,*(void),int,*(char),*(char))
*	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
=	O
table	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
;	O
poptCallbackType	*((*(struct),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
cb	*((*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct`),*(*`),int,int,*(struct`),int,*(char),*(struct`),int,int,*(struct`),int,*(*`),int,int,*(struct`),*(char),int,*(char))),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
;	O
while	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
longName	*(char)
||	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
shortName	char
||	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
arg	*(void)
)	O
{	O
if	O
(	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_ARG_MASK	int
)	O
==	O
POPT_ARG_INCLUDE_TABLE	int
)	O
{	O
invokeCallbacks	(*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct(int,*`,int,*`,*`,*`,int)),*(*(char)),int,int,*(struct(*`,char,int,*`,int,*`,*`)),int,*(char),*(struct(*`,char,int,*`)),int,int,*(struct(*`,char,*`)),int,*(*(char)),int,int,*(struct(*`,char,*`)),*(char),int,*(char))),*(struct(*(char),char,int,*(void),int,*(char),*(char))),int)->(void)
(	O
con	*(struct)
,	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
arg	*(void)
,	O
post	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_ARG_MASK	int
)	O
==	O
POPT_ARG_CALLBACK	int
)	O
&&	O
(	O
(	O
!	O
post	int
&&	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_CBFLAG_PRE	int
)	O
)	O
||	O
(	O
post	int
&&	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_CBFLAG_POST	int
)	O
)	O
)	O
)	O
{	O
cb	*((*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct`),*(*`),int,int,*(struct`),int,*(char),*(struct`),int,int,*(struct`),int,*(*`),int,int,*(struct`),*(char),int,*(char))),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
=	O
(	O
poptCallbackType	*((*(struct),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
)	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
arg	*(void)
;	O
cb	*((*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct`),*(*`),int,int,*(struct`),int,*(char),*(struct`),int,int,*(struct`),int,*(*`),int,int,*(struct`),*(char),int,*(char))),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
(	O
con	*(struct)
,	O
post	int
?	O
POPT_CALLBACK_REASON_POST	int
:	O
POPT_CALLBACK_REASON_PRE	int
,	O
NULL	O
,	O
NULL	O
,	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
descrip	*(char)
)	O
;	O
}	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
++	O
;	O
}	O
}	O
poptContext	*(struct)
poptGetContext	(*(char),int,*(*(char)),*(struct(*(char),char,int,*(void),int,*(char),*(char))),int)->(*(struct))
(	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
argc	*(int)
,	O
char	O
*	O
*	O
argv	*(*(*(char)))
,	O
const	O
struct	O
poptOption	struct(*(char),char,int,*(void),int,*(char),*(char))
*	O
options	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
,	O
int	O
flags	enum(int,int,int,int)
)	O
{	O
poptContext	*(struct)
con	*(struct)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
con	*(struct)
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
con	*(struct)
,	O
0	int
,	O
sizeof	O
(	O
*	O
con	*(struct)
)	O
)	O
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
=	O
con	*(struct)
->	O
optionStack	array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int))
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
argc	*(int)
=	O
argc	*(int)
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
argv	*(*(*(char)))
=	O
argv	*(*(*(char)))
;	O
if	O
(	O
!	O
(	O
flags	enum(int,int,int,int)
&	O
POPT_CONTEXT_KEEP_FIRST	O
)	O
)	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
1	int
;	O
con	*(struct)
->	O
leftovers	*(*(char))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
argc	*(int)
+	O
1	int
)	O
)	O
;	O
con	*(struct)
->	O
options	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
=	O
options	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
;	O
con	*(struct)
->	O
finalArgv	*(*(char))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
con	*(struct)
->	O
finalArgv	*(*(char))
)	O
*	O
(	O
argc	*(int)
*	O
2	int
)	O
)	O
;	O
con	*(struct)
->	O
finalArgvAlloced	int
=	O
argc	*(int)
*	O
2	int
;	O
con	*(struct)
->	O
flags	enum(int,int,int,int)
=	O
flags	enum(int,int,int,int)
;	O
con	*(struct)
->	O
execAbsolute	int
=	O
1	int
;	O
if	O
(	O
getenv	(*(char))->(*(char))
(	O
"POSIXLY_CORRECT"	*(char)
)	O
||	O
getenv	(*(char))->(*(char))
(	O
"POSIX_ME_HARDER"	*(char)
)	O
)	O
con	*(struct)
->	O
flags	enum(int,int,int,int)
|=	O
POPT_CONTEXT_POSIXMEHARDER	O
;	O
if	O
(	O
name	*(char)
)	O
con	*(struct)
->	O
appName	*(char)
=	O
strcpy	(*(char),*(char))->(*(char))
(	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
+	O
1	int
)	O
,	O
name	*(char)
)	O
;	O
invokeCallbacks	(*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct(int,*`,int,*`,*`,*`,int)),*(*(char)),int,int,*(struct(*`,char,int,*`,int,*`,*`)),int,*(char),*(struct(*`,char,int,*`)),int,int,*(struct(*`,char,*`)),int,*(*(char)),int,int,*(struct(*`,char,*`)),*(char),int,*(char))),*(struct(*(char),char,int,*(void),int,*(char),*(char))),int)->(void)
(	O
con	*(struct)
,	O
con	*(struct)
->	O
options	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
,	O
0	int
)	O
;	O
return	O
con	*(struct)
;	O
}	O
void	O
poptResetContext	(*(struct))->(void)
(	O
poptContext	*(struct)
con	*(struct)
)	O
{	O
int	O
i	array(int)
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
=	O
con	*(struct)
->	O
optionStack	array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int))
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
currAlias	*(struct(*(char),char,int,*(*(char))))
=	O
NULL	O
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextCharArg	*(char)
=	O
NULL	O
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextArg	*(char)
=	O
NULL	O
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
1	int
;	O
con	*(struct)
->	O
numLeftovers	int
=	O
0	int
;	O
con	*(struct)
->	O
nextLeftover	int
=	O
0	int
;	O
con	*(struct)
->	O
restLeftover	int
=	O
0	int
;	O
con	*(struct)
->	O
doExec	*(struct(*(char),char,*(char)))
=	O
NULL	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
con	*(struct)
->	O
finalArgvCount	int
;	O
i	array(int)
++	O
)	O
free	(*(void))->(void)
(	O
con	*(struct)
->	O
finalArgv	*(*(char))
[	O
i	array(int)
]	O
)	O
;	O
con	*(struct)
->	O
finalArgvCount	int
=	O
0	int
;	O
}	O
static	O
int	O
handleExec	(*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct(int,*`,int,*`,*`,*`,int)),*(*(char)),int,int,*(struct(*`,char,int,*`,int,*`,*`)),int,*(char),*(struct(*`,char,int,*`)),int,int,*(struct(*`,char,*`)),int,*(*(char)),int,int,*(struct(*`,char,*`)),*(char),int,*(char))),*(char),char)->(int)
(	O
poptContext	*(struct)
con	*(struct)
,	O
char	O
*	O
longName	*(char)
,	O
char	O
shortName	char
)	O
{	O
int	O
i	array(int)
;	O
i	array(int)
=	O
con	*(struct)
->	O
numExecs	int
-	O
1	int
;	O
if	O
(	O
longName	*(char)
)	O
{	O
while	O
(	O
i	array(int)
>=	O
0	int
&&	O
(	O
!	O
con	*(struct)
->	O
execs	*(struct(*(char),char,*(char)))
[	O
i	array(int)
]	O
.	O
longName	*(char)
||	O
strcmp	(*(char),*(char))->(int)
(	O
con	*(struct)
->	O
execs	*(struct(*(char),char,*(char)))
[	O
i	array(int)
]	O
.	O
longName	*(char)
,	O
longName	*(char)
)	O
)	O
)	O
i	array(int)
--	O
;	O
}	O
else	O
{	O
while	O
(	O
i	array(int)
>=	O
0	int
&&	O
con	*(struct)
->	O
execs	*(struct(*(char),char,*(char)))
[	O
i	array(int)
]	O
.	O
shortName	char
!=	O
shortName	char
)	O
i	array(int)
--	O
;	O
}	O
if	O
(	O
i	array(int)
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
con	*(struct)
->	O
flags	enum(int,int,int,int)
&	O
POPT_CONTEXT_NO_EXEC	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
con	*(struct)
->	O
doExec	*(struct(*(char),char,*(char)))
)	O
{	O
con	*(struct)
->	O
doExec	*(struct(*(char),char,*(char)))
=	O
con	*(struct)
->	O
execs	*(struct(*(char),char,*(char)))
+	O
i	array(int)
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
con	*(struct)
->	O
finalArgvCount	int
+	O
1	int
)	O
>=	O
(	O
con	*(struct)
->	O
finalArgvAlloced	int
)	O
)	O
{	O
con	*(struct)
->	O
finalArgvAlloced	int
+=	O
10	int
;	O
con	*(struct)
->	O
finalArgv	*(*(char))
=	O
realloc	(*(void),long)->(*(void))
(	O
con	*(struct)
->	O
finalArgv	*(*(char))
,	O
sizeof	O
(	O
*	O
con	*(struct)
->	O
finalArgv	*(*(char))
)	O
*	O
con	*(struct)
->	O
finalArgvAlloced	int
)	O
;	O
}	O
i	array(int)
=	O
con	*(struct)
->	O
finalArgvCount	int
++	O
;	O
con	*(struct)
->	O
finalArgv	*(*(char))
[	O
i	array(int)
]	O
=	O
malloc	(long)->(*(void))
(	O
(	O
longName	*(char)
?	O
strlen	(*(char))->(long)
(	O
longName	*(char)
)	O
:	O
0	int
)	O
+	O
3	int
)	O
;	O
if	O
(	O
longName	*(char)
)	O
sprintf	(*(char),*(char))->(int)
(	O
con	*(struct)
->	O
finalArgv	*(*(char))
[	O
i	array(int)
]	O
,	O
"--%s"	*(char)
,	O
longName	*(char)
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
con	*(struct)
->	O
finalArgv	*(*(char))
[	O
i	array(int)
]	O
,	O
"-%c"	*(char)
,	O
shortName	char
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
handleAlias	(*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct(int,*`,int,*`,*`,*`,int)),*(*(char)),int,int,*(struct(*`,char,int,*`,int,*`,*`)),int,*(char),*(struct(*`,char,int,*`)),int,int,*(struct(*`,char,*`)),int,*(*(char)),int,int,*(struct(*`,char,*`)),*(char),int,*(char))),*(char),char,*(char))->(int)
(	O
poptContext	*(struct)
con	*(struct)
,	O
char	O
*	O
longName	*(char)
,	O
char	O
shortName	char
,	O
char	O
*	O
nextCharArg	*(char)
)	O
{	O
int	O
i	array(int)
;	O
if	O
(	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
currAlias	*(struct(*(char),char,int,*(*(char))))
&&	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
currAlias	*(struct(*(char),char,int,*(*(char))))
->	O
longName	*(char)
&&	O
longName	*(char)
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
currAlias	*(struct(*(char),char,int,*(*(char))))
->	O
longName	*(char)
,	O
longName	*(char)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
currAlias	*(struct(*(char),char,int,*(*(char))))
&&	O
shortName	char
&&	O
shortName	char
==	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
currAlias	*(struct(*(char),char,int,*(*(char))))
->	O
shortName	char
)	O
return	O
0	int
;	O
i	array(int)
=	O
con	*(struct)
->	O
numAliases	int
-	O
1	int
;	O
if	O
(	O
longName	*(char)
)	O
{	O
while	O
(	O
i	array(int)
>=	O
0	int
&&	O
(	O
!	O
con	*(struct)
->	O
aliases	*(struct(*(char),char,int,*(*(char))))
[	O
i	array(int)
]	O
.	O
longName	*(char)
||	O
strcmp	(*(char),*(char))->(int)
(	O
con	*(struct)
->	O
aliases	*(struct(*(char),char,int,*(*(char))))
[	O
i	array(int)
]	O
.	O
longName	*(char)
,	O
longName	*(char)
)	O
)	O
)	O
i	array(int)
--	O
;	O
}	O
else	O
{	O
while	O
(	O
i	array(int)
>=	O
0	int
&&	O
con	*(struct)
->	O
aliases	*(struct(*(char),char,int,*(*(char))))
[	O
i	array(int)
]	O
.	O
shortName	char
!=	O
shortName	char
)	O
i	array(int)
--	O
;	O
}	O
if	O
(	O
i	array(int)
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
(	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
-	O
con	*(struct)
->	O
optionStack	array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int))
+	O
1	int
)	O
==	O
POPT_OPTION_DEPTH	int
)	O
return	O
POPT_ERROR_OPTSTOODEEP	O
;	O
if	O
(	O
nextCharArg	*(char)
&&	O
*	O
nextCharArg	*(char)
)	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextCharArg	*(char)
=	O
nextCharArg	*(char)
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
++	O
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
0	int
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
stuffed	int
=	O
0	int
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextArg	*(char)
=	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextCharArg	*(char)
=	O
NULL	O
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
currAlias	*(struct(*(char),char,int,*(*(char))))
=	O
con	*(struct)
->	O
aliases	*(struct(*(char),char,int,*(*(char))))
+	O
i	array(int)
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
argc	*(int)
=	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
currAlias	*(struct(*(char),char,int,*(*(char))))
->	O
argc	*(int)
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
argv	*(*(*(char)))
=	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
currAlias	*(struct(*(char),char,int,*(*(char))))
->	O
argv	*(*(*(char)))
;	O
return	O
1	int
;	O
}	O
static	O
void	O
execCommand	(*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct(int,*`,int,*`,*`,*`,int)),*(*(char)),int,int,*(struct(*`,char,int,*`,int,*`,*`)),int,*(char),*(struct(*`,char,int,*`)),int,int,*(struct(*`,char,*`)),int,*(*(char)),int,int,*(struct(*`,char,*`)),*(char),int,*(char))))->(void)
(	O
poptContext	*(struct)
con	*(struct)
)	O
{	O
(	O
void	O
)	O
con	*(struct)
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
static	O
const	O
struct	O
poptOption	struct(*(char),char,int,*(void),int,*(char),*(char))
*	O
findOption	(*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),char,*(*((*(struct`),enum(int,int,int),*(struct`),*(char),*(void))->(void))),*(*(void)),int)->(*(struct(*(char),char,int,*(void),int,*(char),*(char))))
(	O
const	O
struct	O
poptOption	struct(*(char),char,int,*(void),int,*(char),*(char))
*	O
table	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
,	O
const	O
char	O
*	O
longName	*(char)
,	O
char	O
shortName	char
,	O
poptCallbackType	*((*(struct),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
*	O
callback	*((*(void))->(int))
,	O
void	O
*	O
*	O
callbackData	*(*(void))
,	O
int	O
singleDash	int
)	O
{	O
const	O
struct	O
poptOption	struct(*(char),char,int,*(void),int,*(char),*(char))
*	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
=	O
table	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
;	O
const	O
struct	O
poptOption	struct(*(char),char,int,*(void),int,*(char),*(char))
*	O
opt2	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
;	O
const	O
struct	O
poptOption	struct(*(char),char,int,*(void),int,*(char),*(char))
*	O
cb	*((*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct`),*(*`),int,int,*(struct`),int,*(char),*(struct`),int,int,*(struct`),int,*(*`),int,int,*(struct`),*(char),int,*(char))),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
=	O
NULL	O
;	O
if	O
(	O
singleDash	int
&&	O
!	O
shortName	char
&&	O
!	O
*	O
longName	*(char)
)	O
shortName	char
=	O
'-'	O
;	O
while	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
longName	*(char)
||	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
shortName	char
||	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
arg	*(void)
)	O
{	O
if	O
(	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_ARG_MASK	int
)	O
==	O
POPT_ARG_INCLUDE_TABLE	int
)	O
{	O
opt2	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
=	O
findOption	(*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),char,*(*((*(struct`),enum(int,int,int),*(struct`),*(char),*(void))->(void))),*(*(void)),int)->(*(struct(*(char),char,int,*(void),int,*(char),*(char))))
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
arg	*(void)
,	O
longName	*(char)
,	O
shortName	char
,	O
callback	*((*(void))->(int))
,	O
callbackData	*(*(void))
,	O
singleDash	int
)	O
;	O
if	O
(	O
opt2	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
)	O
{	O
if	O
(	O
*	O
callback	*((*(void))->(int))
&&	O
!	O
*	O
callbackData	*(*(void))
)	O
*	O
callbackData	*(*(void))
=	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
descrip	*(char)
;	O
return	O
opt2	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
;	O
}	O
}	O
else	O
if	O
(	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_ARG_MASK	int
)	O
==	O
POPT_ARG_CALLBACK	int
)	O
{	O
cb	*((*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct`),*(*`),int,int,*(struct`),int,*(char),*(struct`),int,int,*(struct`),int,*(*`),int,int,*(struct`),*(char),int,*(char))),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
=	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
;	O
}	O
else	O
if	O
(	O
longName	*(char)
&&	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
longName	*(char)
&&	O
(	O
!	O
singleDash	int
||	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_ARGFLAG_ONEDASH	int
)	O
)	O
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
longName	*(char)
,	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
longName	*(char)
)	O
)	O
{	O
break	O
;	O
}	O
else	O
if	O
(	O
shortName	char
&&	O
shortName	char
==	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
shortName	char
)	O
{	O
break	O
;	O
}	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
++	O
;	O
}	O
if	O
(	O
!	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
longName	*(char)
&&	O
!	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
shortName	char
)	O
return	O
NULL	O
;	O
*	O
callbackData	*(*(void))
=	O
NULL	O
;	O
*	O
callback	*((*(void))->(int))
=	O
NULL	O
;	O
if	O
(	O
cb	*((*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct`),*(*`),int,int,*(struct`),int,*(char),*(struct`),int,int,*(struct`),int,*(*`),int,int,*(struct`),*(char),int,*(char))),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
)	O
{	O
*	O
callback	*((*(void))->(int))
=	O
(	O
poptCallbackType	*((*(struct),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
)	O
cb	*((*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct`),*(*`),int,int,*(struct`),int,*(char),*(struct`),int,int,*(struct`),int,*(*`),int,int,*(struct`),*(char),int,*(char))),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
->	O
arg	*(void)
;	O
if	O
(	O
!	O
(	O
cb	*((*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct`),*(*`),int,int,*(struct`),int,*(char),*(struct`),int,int,*(struct`),int,*(*`),int,int,*(struct`),*(char),int,*(char))),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
->	O
argInfo	int
&	O
POPT_CBFLAG_INC_DATA	int
)	O
)	O
*	O
callbackData	*(*(void))
=	O
cb	*((*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct`),*(*`),int,int,*(struct`),int,*(char),*(struct`),int,int,*(struct`),int,*(*`),int,int,*(struct`),*(char),int,*(char))),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
->	O
descrip	*(char)
;	O
}	O
return	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
;	O
}	O
int	O
poptGetNextOpt	(*(struct))->(int)
(	O
poptContext	*(struct)
con	*(struct)
)	O
{	O
char	O
*	O
optString	*(char)
,	O
*	O
chptr	*(char)
,	O
*	O
localOptString	*(char)
;	O
char	O
*	O
longArg	*(char)
=	O
NULL	O
;	O
char	O
*	O
origOptString	*(char)
;	O
long	O
aLong	long
;	O
char	O
*	O
end	*(struct)
;	O
const	O
struct	O
poptOption	struct(*(char),char,int,*(void),int,*(char),*(char))
*	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
=	O
NULL	O
;	O
int	O
done	int
=	O
0	int
;	O
int	O
i	array(int)
;	O
poptCallbackType	*((*(struct),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
cb	*((*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct`),*(*`),int,int,*(struct`),int,*(char),*(struct`),int,int,*(struct`),int,*(*`),int,int,*(struct`),*(char),int,*(char))),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
;	O
void	O
*	O
cbData	*(void)
;	O
int	O
singleDash	int
;	O
while	O
(	O
!	O
done	int
)	O
{	O
while	O
(	O
!	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextCharArg	*(char)
&&	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
==	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
argc	*(int)
&&	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
>	O
con	*(struct)
->	O
optionStack	array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int))
)	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
--	O
;	O
if	O
(	O
!	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextCharArg	*(char)
&&	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
==	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
argc	*(int)
)	O
{	O
invokeCallbacks	(*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct(int,*`,int,*`,*`,*`,int)),*(*(char)),int,int,*(struct(*`,char,int,*`,int,*`,*`)),int,*(char),*(struct(*`,char,int,*`)),int,int,*(struct(*`,char,*`)),int,*(*(char)),int,int,*(struct(*`,char,*`)),*(char),int,*(char))),*(struct(*(char),char,int,*(void),int,*(char),*(char))),int)->(void)
(	O
con	*(struct)
,	O
con	*(struct)
->	O
options	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
,	O
1	int
)	O
;	O
if	O
(	O
con	*(struct)
->	O
doExec	*(struct(*(char),char,*(char)))
)	O
execCommand	(*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct(int,*`,int,*`,*`,*`,int)),*(*(char)),int,int,*(struct(*`,char,int,*`,int,*`,*`)),int,*(char),*(struct(*`,char,int,*`)),int,int,*(struct(*`,char,*`)),int,*(*(char)),int,int,*(struct(*`,char,*`)),*(char),int,*(char))))->(void)
(	O
con	*(struct)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextCharArg	*(char)
)	O
{	O
origOptString	*(char)
=	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
argv	*(*(*(char)))
[	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
++	O
]	O
;	O
if	O
(	O
con	*(struct)
->	O
restLeftover	int
||	O
*	O
origOptString	*(char)
!=	O
'-'	O
)	O
{	O
con	*(struct)
->	O
leftovers	*(*(char))
[	O
con	*(struct)
->	O
numLeftovers	int
++	O
]	O
=	O
origOptString	*(char)
;	O
if	O
(	O
con	*(struct)
->	O
flags	enum(int,int,int,int)
&	O
POPT_CONTEXT_POSIXMEHARDER	O
)	O
con	*(struct)
->	O
restLeftover	int
=	O
1	int
;	O
continue	O
;	O
}	O
localOptString	*(char)
=	O
optString	*(char)
=	O
strcpy	(*(char),*(char))->(*(char))
(	O
alloca	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
origOptString	*(char)
)	O
+	O
1	int
)	O
,	O
origOptString	*(char)
)	O
;	O
if	O
(	O
!	O
optString	*(char)
[	O
0	int
]	O
)	O
return	O
POPT_ERROR_BADOPT	O
;	O
if	O
(	O
optString	*(char)
[	O
1	int
]	O
==	O
'-'	O
&&	O
!	O
optString	*(char)
[	O
2	int
]	O
)	O
{	O
con	*(struct)
->	O
restLeftover	int
=	O
1	int
;	O
continue	O
;	O
}	O
else	O
{	O
optString	*(char)
++	O
;	O
if	O
(	O
*	O
optString	*(char)
==	O
'-'	O
)	O
singleDash	int
=	O
0	int
,	O
optString	*(char)
++	O
;	O
else	O
singleDash	int
=	O
1	int
;	O
if	O
(	O
handleAlias	(*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct(int,*`,int,*`,*`,*`,int)),*(*(char)),int,int,*(struct(*`,char,int,*`,int,*`,*`)),int,*(char),*(struct(*`,char,int,*`)),int,int,*(struct(*`,char,*`)),int,*(*(char)),int,int,*(struct(*`,char,*`)),*(char),int,*(char))),*(char),char,*(char))->(int)
(	O
con	*(struct)
,	O
optString	*(char)
,	O
'\0'	O
,	O
NULL	O
)	O
)	O
continue	O
;	O
if	O
(	O
handleExec	(*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct(int,*`,int,*`,*`,*`,int)),*(*(char)),int,int,*(struct(*`,char,int,*`,int,*`,*`)),int,*(char),*(struct(*`,char,int,*`)),int,int,*(struct(*`,char,*`)),int,*(*(char)),int,int,*(struct(*`,char,*`)),*(char),int,*(char))),*(char),char)->(int)
(	O
con	*(struct)
,	O
optString	*(char)
,	O
'\0'	O
)	O
)	O
continue	O
;	O
chptr	*(char)
=	O
optString	*(char)
;	O
while	O
(	O
*	O
chptr	*(char)
&&	O
*	O
chptr	*(char)
!=	O
'='	O
)	O
chptr	*(char)
++	O
;	O
if	O
(	O
*	O
chptr	*(char)
==	O
'='	O
)	O
{	O
longArg	*(char)
=	O
origOptString	*(char)
+	O
(	O
chptr	*(char)
-	O
localOptString	*(char)
)	O
+	O
1	int
;	O
*	O
chptr	*(char)
=	O
'\0'	O
;	O
}	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
=	O
findOption	(*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),char,*(*((*(struct`),enum(int,int,int),*(struct`),*(char),*(void))->(void))),*(*(void)),int)->(*(struct(*(char),char,int,*(void),int,*(char),*(char))))
(	O
con	*(struct)
->	O
options	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
,	O
optString	*(char)
,	O
'\0'	O
,	O
&	O
cb	*((*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct`),*(*`),int,int,*(struct`),int,*(char),*(struct`),int,int,*(struct`),int,*(*`),int,int,*(struct`),*(char),int,*(char))),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
,	O
&	O
cbData	*(void)
,	O
singleDash	int
)	O
;	O
if	O
(	O
!	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
&&	O
!	O
singleDash	int
)	O
return	O
POPT_ERROR_BADOPT	O
;	O
}	O
if	O
(	O
!	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
)	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextCharArg	*(char)
=	O
origOptString	*(char)
+	O
1	int
;	O
}	O
if	O
(	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextCharArg	*(char)
)	O
{	O
origOptString	*(char)
=	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextCharArg	*(char)
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextCharArg	*(char)
=	O
NULL	O
;	O
if	O
(	O
handleAlias	(*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct(int,*`,int,*`,*`,*`,int)),*(*(char)),int,int,*(struct(*`,char,int,*`,int,*`,*`)),int,*(char),*(struct(*`,char,int,*`)),int,int,*(struct(*`,char,*`)),int,*(*(char)),int,int,*(struct(*`,char,*`)),*(char),int,*(char))),*(char),char,*(char))->(int)
(	O
con	*(struct)
,	O
NULL	O
,	O
*	O
origOptString	*(char)
,	O
origOptString	*(char)
+	O
1	int
)	O
)	O
{	O
origOptString	*(char)
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
handleExec	(*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct(int,*`,int,*`,*`,*`,int)),*(*(char)),int,int,*(struct(*`,char,int,*`,int,*`,*`)),int,*(char),*(struct(*`,char,int,*`)),int,int,*(struct(*`,char,*`)),int,*(*(char)),int,int,*(struct(*`,char,*`)),*(char),int,*(char))),*(char),char)->(int)
(	O
con	*(struct)
,	O
NULL	O
,	O
*	O
origOptString	*(char)
)	O
)	O
continue	O
;	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
=	O
findOption	(*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),char,*(*((*(struct`),enum(int,int,int),*(struct`),*(char),*(void))->(void))),*(*(void)),int)->(*(struct(*(char),char,int,*(void),int,*(char),*(char))))
(	O
con	*(struct)
->	O
options	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
,	O
NULL	O
,	O
*	O
origOptString	*(char)
,	O
&	O
cb	*((*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct`),*(*`),int,int,*(struct`),int,*(char),*(struct`),int,int,*(struct`),int,*(*`),int,int,*(struct`),*(char),int,*(char))),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
,	O
&	O
cbData	*(void)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
)	O
return	O
POPT_ERROR_BADOPT	O
;	O
origOptString	*(char)
++	O
;	O
if	O
(	O
*	O
origOptString	*(char)
)	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextCharArg	*(char)
=	O
origOptString	*(char)
;	O
}	O
if	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
arg	*(void)
&&	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_ARG_MASK	int
)	O
==	O
POPT_ARG_NONE	int
)	O
{	O
*	O
(	O
(	O
int	O
*	O
)	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
arg	*(void)
)	O
=	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_ARG_MASK	int
)	O
==	O
POPT_ARG_VAL	int
)	O
{	O
if	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
arg	*(void)
)	O
*	O
(	O
(	O
int	O
*	O
)	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
arg	*(void)
)	O
=	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
val	int
;	O
}	O
else	O
if	O
(	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_ARG_MASK	int
)	O
!=	O
POPT_ARG_NONE	int
)	O
{	O
if	O
(	O
longArg	*(char)
)	O
{	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextArg	*(char)
=	O
longArg	*(char)
;	O
}	O
else	O
if	O
(	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextCharArg	*(char)
)	O
{	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextArg	*(char)
=	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextCharArg	*(char)
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextCharArg	*(char)
=	O
NULL	O
;	O
}	O
else	O
{	O
while	O
(	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
==	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
argc	*(int)
&&	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
>	O
con	*(struct)
->	O
optionStack	array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int))
)	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
--	O
;	O
if	O
(	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
==	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
argc	*(int)
)	O
return	O
POPT_ERROR_NOARG	O
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextArg	*(char)
=	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
argv	*(*(*(char)))
[	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
++	O
]	O
;	O
}	O
if	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
arg	*(void)
)	O
{	O
switch	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_ARG_MASK	int
)	O
{	O
case	O
POPT_ARG_STRING	int
:	O
*	O
(	O
(	O
char	O
*	O
*	O
)	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
arg	*(void)
)	O
=	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextArg	*(char)
;	O
break	O
;	O
case	O
POPT_ARG_INT	int
:	O
case	O
POPT_ARG_LONG	int
:	O
aLong	long
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextArg	*(char)
,	O
&	O
end	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
end	*(struct)
&&	O
*	O
end	*(struct)
==	O
'\0'	O
)	O
)	O
return	O
POPT_ERROR_BADNUMBER	O
;	O
if	O
(	O
aLong	long
==	O
LONG_MIN	O
||	O
aLong	long
==	O
LONG_MAX	O
)	O
return	O
POPT_ERROR_OVERFLOW	O
;	O
if	O
(	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_ARG_MASK	int
)	O
==	O
POPT_ARG_LONG	int
)	O
{	O
*	O
(	O
(	O
long	O
*	O
)	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
arg	*(void)
)	O
=	O
aLong	long
;	O
}	O
else	O
{	O
if	O
(	O
aLong	long
>	O
INT_MAX	O
||	O
aLong	long
<	O
INT_MIN	O
)	O
return	O
POPT_ERROR_OVERFLOW	O
;	O
*	O
(	O
(	O
int	O
*	O
)	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
arg	*(void)
)	O
=	O
aLong	long
;	O
}	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
POPT_	O
(	O
"option type (%d) not implemented in popt\n"	*(char)
)	O
,	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_ARG_MASK	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
cb	*((*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct`),*(*`),int,int,*(struct`),int,*(char),*(struct`),int,int,*(struct`),int,*(*`),int,int,*(struct`),*(char),int,*(char))),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
)	O
cb	*((*(struct(array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)),*(struct`),*(*`),int,int,*(struct`),int,*(char),*(struct`),int,int,*(struct`),int,*(*`),int,int,*(struct`),*(char),int,*(char))),enum(int,int,int),*(struct(*(char),char,int,*(void),int,*(char),*(char))),*(char),*(void))->(void))
(	O
con	*(struct)
,	O
POPT_CALLBACK_REASON_OPTION	int
,	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
,	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextArg	*(char)
,	O
cbData	*(void)
)	O
;	O
else	O
if	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
val	int
&&	O
(	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_ARG_MASK	int
)	O
!=	O
POPT_ARG_VAL	int
)	O
)	O
done	int
=	O
1	int
;	O
if	O
(	O
(	O
con	*(struct)
->	O
finalArgvCount	int
+	O
2	int
)	O
>=	O
(	O
con	*(struct)
->	O
finalArgvAlloced	int
)	O
)	O
{	O
con	*(struct)
->	O
finalArgvAlloced	int
+=	O
10	int
;	O
con	*(struct)
->	O
finalArgv	*(*(char))
=	O
realloc	(*(void),long)->(*(void))
(	O
con	*(struct)
->	O
finalArgv	*(*(char))
,	O
sizeof	O
(	O
*	O
con	*(struct)
->	O
finalArgv	*(*(char))
)	O
*	O
con	*(struct)
->	O
finalArgvAlloced	int
)	O
;	O
}	O
i	array(int)
=	O
con	*(struct)
->	O
finalArgvCount	int
++	O
;	O
con	*(struct)
->	O
finalArgv	*(*(char))
[	O
i	array(int)
]	O
=	O
malloc	(long)->(*(void))
(	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
longName	*(char)
?	O
strlen	(*(char))->(long)
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
longName	*(char)
)	O
:	O
0	int
)	O
+	O
3	int
)	O
;	O
if	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
longName	*(char)
)	O
sprintf	(*(char),*(char))->(int)
(	O
con	*(struct)
->	O
finalArgv	*(*(char))
[	O
i	array(int)
]	O
,	O
"--%s"	*(char)
,	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
longName	*(char)
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
con	*(struct)
->	O
finalArgv	*(*(char))
[	O
i	array(int)
]	O
,	O
"-%c"	*(char)
,	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
shortName	char
)	O
;	O
if	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
arg	*(void)
&&	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_ARG_MASK	int
)	O
!=	O
POPT_ARG_NONE	int
&&	O
(	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
argInfo	int
&	O
POPT_ARG_MASK	int
)	O
!=	O
POPT_ARG_VAL	int
)	O
con	*(struct)
->	O
finalArgv	*(*(char))
[	O
con	*(struct)
->	O
finalArgvCount	int
++	O
]	O
=	O
strdup	(*(char))->(*(char))
(	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextArg	*(char)
)	O
;	O
}	O
return	O
opt	*(struct(*(char),char,int,*(void),int,*(char),*(char)))
->	O
val	int
;	O
}	O
char	O
*	O
poptGetOptArg	(*(struct))->(*(char))
(	O
poptContext	*(struct)
con	*(struct)
)	O
{	O
char	O
*	O
ret	*(char)
=	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextArg	*(char)
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextArg	*(char)
=	O
NULL	O
;	O
return	O
ret	*(char)
;	O
}	O
char	O
*	O
poptGetArg	(*(struct))->(*(char))
(	O
poptContext	*(struct)
con	*(struct)
)	O
{	O
if	O
(	O
con	*(struct)
->	O
numLeftovers	int
==	O
con	*(struct)
->	O
nextLeftover	int
)	O
return	O
NULL	O
;	O
return	O
(	O
con	*(struct)
->	O
leftovers	*(*(char))
[	O
con	*(struct)
->	O
nextLeftover	int
++	O
]	O
)	O
;	O
}	O
char	O
*	O
poptPeekArg	(*(struct))->(*(char))
(	O
poptContext	*(struct)
con	*(struct)
)	O
{	O
if	O
(	O
con	*(struct)
->	O
numLeftovers	int
==	O
con	*(struct)
->	O
nextLeftover	int
)	O
return	O
NULL	O
;	O
return	O
(	O
con	*(struct)
->	O
leftovers	*(*(char))
[	O
con	*(struct)
->	O
nextLeftover	int
]	O
)	O
;	O
}	O
char	O
*	O
*	O
poptGetArgs	(*(struct))->(*(*(char)))
(	O
poptContext	*(struct)
con	*(struct)
)	O
{	O
if	O
(	O
con	*(struct)
->	O
numLeftovers	int
==	O
con	*(struct)
->	O
nextLeftover	int
)	O
return	O
NULL	O
;	O
con	*(struct)
->	O
leftovers	*(*(char))
[	O
con	*(struct)
->	O
numLeftovers	int
]	O
=	O
NULL	O
;	O
return	O
(	O
con	*(struct)
->	O
leftovers	*(*(char))
+	O
con	*(struct)
->	O
nextLeftover	int
)	O
;	O
}	O
void	O
poptFreeContext	(*(struct))->(void)
(	O
poptContext	*(struct)
con	*(struct)
)	O
{	O
int	O
i	array(int)
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
con	*(struct)
->	O
numAliases	int
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
con	*(struct)
->	O
aliases	*(struct(*(char),char,int,*(*(char))))
[	O
i	array(int)
]	O
.	O
longName	*(char)
)	O
free	(*(void))->(void)
(	O
con	*(struct)
->	O
aliases	*(struct(*(char),char,int,*(*(char))))
[	O
i	array(int)
]	O
.	O
longName	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
con	*(struct)
->	O
aliases	*(struct(*(char),char,int,*(*(char))))
[	O
i	array(int)
]	O
.	O
argv	*(*(*(char)))
)	O
;	O
}	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
con	*(struct)
->	O
numExecs	int
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
con	*(struct)
->	O
execs	*(struct(*(char),char,*(char)))
[	O
i	array(int)
]	O
.	O
longName	*(char)
)	O
free	(*(void))->(void)
(	O
con	*(struct)
->	O
execs	*(struct(*(char),char,*(char)))
[	O
i	array(int)
]	O
.	O
longName	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
con	*(struct)
->	O
execs	*(struct(*(char),char,*(char)))
[	O
i	array(int)
]	O
.	O
script	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
}	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
con	*(struct)
->	O
finalArgvCount	int
;	O
i	array(int)
++	O
)	O
free	(*(void))->(void)
(	O
con	*(struct)
->	O
finalArgv	*(*(char))
[	O
i	array(int)
]	O
)	O
;	O
free	(*(void))->(void)
(	O
con	*(struct)
->	O
leftovers	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
con	*(struct)
->	O
finalArgv	*(*(char))
)	O
;	O
if	O
(	O
con	*(struct)
->	O
appName	*(char)
)	O
free	(*(void))->(void)
(	O
con	*(struct)
->	O
appName	*(char)
)	O
;	O
if	O
(	O
con	*(struct)
->	O
aliases	*(struct(*(char),char,int,*(*(char))))
)	O
free	(*(void))->(void)
(	O
con	*(struct)
->	O
aliases	*(struct(*(char),char,int,*(*(char))))
)	O
;	O
if	O
(	O
con	*(struct)
->	O
otherHelp	*(char)
)	O
free	(*(void))->(void)
(	O
con	*(struct)
->	O
otherHelp	*(char)
)	O
;	O
if	O
(	O
con	*(struct)
->	O
execPath	*(char)
)	O
free	(*(void))->(void)
(	O
con	*(struct)
->	O
execPath	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
con	*(struct)
)	O
;	O
}	O
int	O
poptAddAlias	(*(struct),struct(*(char),char,int,*(*(char))),int)->(int)
(	O
poptContext	*(struct)
con	*(struct)
,	O
struct	O
poptAlias	struct(*(char),char,int,*(*(char)))
newAlias	struct(*(char),char,int,*(*(char)))
,	O
int	O
flags	enum(int,int,int,int)
)	O
{	O
int	O
aliasNum	int
=	O
con	*(struct)
->	O
numAliases	int
++	O
;	O
struct	O
poptAlias	struct(*(char),char,int,*(*(char)))
*	O
alias	struct(*(char),char,int,*(*(char)))
;	O
(	O
void	O
)	O
flags	enum(int,int,int,int)
;	O
if	O
(	O
!	O
con	*(struct)
->	O
aliases	*(struct(*(char),char,int,*(*(char))))
)	O
con	*(struct)
->	O
aliases	*(struct(*(char),char,int,*(*(char))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
newAlias	struct(*(char),char,int,*(*(char)))
)	O
*	O
con	*(struct)
->	O
numAliases	int
)	O
;	O
else	O
con	*(struct)
->	O
aliases	*(struct(*(char),char,int,*(*(char))))
=	O
realloc	(*(void),long)->(*(void))
(	O
con	*(struct)
->	O
aliases	*(struct(*(char),char,int,*(*(char))))
,	O
sizeof	O
(	O
newAlias	struct(*(char),char,int,*(*(char)))
)	O
*	O
con	*(struct)
->	O
numAliases	int
)	O
;	O
alias	struct(*(char),char,int,*(*(char)))
=	O
con	*(struct)
->	O
aliases	*(struct(*(char),char,int,*(*(char))))
+	O
aliasNum	int
;	O
*	O
alias	struct(*(char),char,int,*(*(char)))
=	O
newAlias	struct(*(char),char,int,*(*(char)))
;	O
if	O
(	O
alias	struct(*(char),char,int,*(*(char)))
->	O
longName	*(char)
)	O
alias	struct(*(char),char,int,*(*(char)))
->	O
longName	*(char)
=	O
strcpy	(*(char),*(char))->(*(char))
(	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
alias	struct(*(char),char,int,*(*(char)))
->	O
longName	*(char)
)	O
+	O
1	int
)	O
,	O
alias	struct(*(char),char,int,*(*(char)))
->	O
longName	*(char)
)	O
;	O
else	O
alias	struct(*(char),char,int,*(*(char)))
->	O
longName	*(char)
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
poptBadOption	(*(struct),int)->(*(char))
(	O
poptContext	*(struct)
con	*(struct)
,	O
int	O
flags	enum(int,int,int,int)
)	O
{	O
struct	O
optionStackEntry	struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int)
*	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
;	O
if	O
(	O
flags	enum(int,int,int,int)
&	O
POPT_BADOPTION_NOALIAS	O
)	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
=	O
con	*(struct)
->	O
optionStack	array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int))
;	O
else	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
=	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
;	O
return	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
argv	*(*(*(char)))
[	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
-	O
1	int
]	O
;	O
}	O
const	O
char	O
*	O
poptStrerror	(int)->(*(char))
(	O
const	O
int	O
error	*(struct(int,int,*(char)))
)	O
{	O
switch	O
(	O
error	*(struct(int,int,*(char)))
)	O
{	O
case	O
POPT_ERROR_NOARG	O
:	O
return	O
_	O
(	O
"missing argument"	*(char)
)	O
;	O
case	O
POPT_ERROR_BADOPT	O
:	O
return	O
_	O
(	O
"unknown option"	*(char)
)	O
;	O
case	O
POPT_ERROR_OPTSTOODEEP	O
:	O
return	O
POPT_	O
(	O
"aliases nested too deeply"	*(char)
)	O
;	O
case	O
POPT_ERROR_BADQUOTE	O
:	O
return	O
POPT_	O
(	O
"error in parameter quoting"	*(char)
)	O
;	O
case	O
POPT_ERROR_BADNUMBER	O
:	O
return	O
_	O
(	O
"invalid numeric value"	*(char)
)	O
;	O
case	O
POPT_ERROR_OVERFLOW	O
:	O
return	O
POPT_	O
(	O
"number too large or too small"	*(char)
)	O
;	O
case	O
POPT_ERROR_ERRNO	O
:	O
return	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
;	O
default	O
:	O
return	O
POPT_	O
(	O
"unknown error"	*(char)
)	O
;	O
}	O
}	O
int	O
poptStuffArgs	(*(struct),*(*(char)))->(int)
(	O
poptContext	*(struct)
con	*(struct)
,	O
char	O
*	O
*	O
argv	*(*(*(char)))
)	O
{	O
int	O
i	array(int)
;	O
if	O
(	O
(	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
-	O
con	*(struct)
->	O
optionStack	array(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*(char)))),int))
)	O
==	O
POPT_OPTION_DEPTH	int
)	O
return	O
POPT_ERROR_OPTSTOODEEP	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
argv	*(*(*(char)))
[	O
i	array(int)
]	O
;	O
i	array(int)
++	O
)	O
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
++	O
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
0	int
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextArg	*(char)
=	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
nextCharArg	*(char)
=	O
NULL	O
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
currAlias	*(struct(*(char),char,int,*(*(char))))
=	O
NULL	O
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
argc	*(int)
=	O
i	array(int)
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
argv	*(*(*(char)))
=	O
argv	*(*(*(char)))
;	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
stuffed	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
poptGetInvocationName	(*(struct))->(*(char))
(	O
poptContext	*(struct)
con	*(struct)
)	O
{	O
return	O
con	*(struct)
->	O
os	*(struct(int,*(*(char)),int,*(char),*(char),*(struct(*(char),char,int,*(*`))),int))
->	O
argv	*(*(*(char)))
[	O
0	int
]	O
;	O
}	O
