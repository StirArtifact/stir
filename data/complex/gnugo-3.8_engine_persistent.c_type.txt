struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
{	O
int	O
boardsize	int
;	O
int	O
movenum	int
;	O
Intersection	char
board	*(char)
[	O
BOARDMAX	O
]	O
;	O
int	O
stack	array(int)
[	O
MAX_CACHE_DEPTH	int
]	O
;	O
int	O
move_color	array(int)
[	O
MAX_CACHE_DEPTH	int
]	O
;	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
int	O
apos	int
;	O
int	O
bpos	int
;	O
int	O
cpos	int
;	O
int	O
color	int
;	O
Hash_data	struct(array(long))
goal_hash	*(struct(array(long)))
;	O
int	O
result	int
;	O
int	O
result2	int
;	O
int	O
result_certain	int
;	O
int	O
remaining_depth	int
;	O
int	O
node_limit	int
;	O
int	O
move	*(int)
;	O
int	O
move2	*(int)
;	O
int	O
cost	int
;	O
int	O
score	float
;	O
}	O
;	O
typedef	O
void	O
(	O
*	O
compute_active_area_fn	*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void))
)	O
(	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
,	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
goal_color	int
)	O
;	O
struct	O
persistent_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
{	O
const	O
int	O
max_size	int
;	O
const	O
int	O
max_stackp	int
;	O
const	O
float	O
age_factor	float
;	O
const	O
char	O
*	O
name	short
;	O
const	O
compute_active_area_fn	*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void))
compute_active_area	*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void))
;	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
;	O
int	O
current_size	int
;	O
int	O
last_purge_position_number	int
;	O
}	O
;	O
static	O
void	O
compute_active_owl_area	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)
(	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
,	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
goal_color	int
)	O
;	O
static	O
void	O
compute_active_semeai_area	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)
(	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
,	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
dummy	int
)	O
;	O
static	O
void	O
compute_active_reading_area	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)
(	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
,	O
const	O
signed	O
char	O
reading_shadow	array(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
dummy	int
)	O
;	O
static	O
void	O
compute_active_connection_area	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)
(	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
,	O
const	O
signed	O
char	O
connection_shadow	array(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
goal_color	int
)	O
;	O
static	O
void	O
compute_active_breakin_area	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)
(	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
,	O
const	O
signed	O
char	O
breakin_shadow	array(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
dummy	int
)	O
;	O
static	O
struct	O
persistent_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
reading_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
=	O
{	O
MAX_READING_CACHE_SIZE	int
,	O
MAX_READING_CACHE_DEPTH	int
,	O
1.0	int
,	O
"reading cache"	*(char)
,	O
compute_active_reading_area	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)
,	O
NULL	O
,	O
0	int
,	O
-	O
1	int
}	O
;	O
static	O
struct	O
persistent_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
connection_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
=	O
{	O
MAX_CONNECTION_CACHE_SIZE	int
,	O
MAX_CONNECTION_CACHE_DEPTH	int
,	O
1.0	int
,	O
"connection cache"	*(char)
,	O
compute_active_connection_area	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)
,	O
NULL	O
,	O
0	int
,	O
-	O
1	int
}	O
;	O
static	O
struct	O
persistent_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
breakin_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
=	O
{	O
MAX_BREAKIN_CACHE_SIZE	int
,	O
MAX_BREAKIN_CACHE_DEPTH	int
,	O
0.75	int
,	O
"breakin cache"	*(char)
,	O
compute_active_breakin_area	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)
,	O
NULL	O
,	O
0	int
,	O
-	O
1	int
}	O
;	O
static	O
struct	O
persistent_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
owl_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
=	O
{	O
MAX_OWL_CACHE_SIZE	int
,	O
MAX_OWL_CACHE_DEPTH	int
,	O
1.0	int
,	O
"owl cache"	*(char)
,	O
compute_active_owl_area	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)
,	O
NULL	O
,	O
0	int
,	O
-	O
1	int
}	O
;	O
static	O
struct	O
persistent_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
semeai_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
=	O
{	O
MAX_SEMEAI_CACHE_SIZE	int
,	O
MAX_SEMEAI_CACHE_DEPTH	int
,	O
0.75	int
,	O
"semeai cache"	*(char)
,	O
compute_active_semeai_area	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)
,	O
NULL	O
,	O
0	int
,	O
-	O
1	int
}	O
;	O
static	O
void	O
draw_active_area	(array(char),int)->(void)
(	O
Intersection	char
board	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
apos	int
)	O
{	O
int	O
i	int
,	O
j	int
,	O
ii	int
;	O
int	O
c	char
=	O
' '	O
;	O
int	O
cw	int
=	O
(	O
apos	int
==	O
NO_MOVE	O
)	O
?	O
'O'	O
:	O
'o'	O
;	O
int	O
cb	int
=	O
(	O
apos	int
==	O
NO_MOVE	O
)	O
?	O
'X'	O
:	O
'x'	O
;	O
start_draw_board	()->(void)
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
{	O
ii	int
=	O
board_size	int
-	O
i	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n%2d"	*(char)
,	O
ii	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
int	O
pos	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
c	char
=	O
'.'	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
WHITE	int
)	O
c	char
=	O
cw	int
;	O
else	O
if	O
(	O
(	O
board	*(char)
[	O
pos	int
]	O
&	O
3	int
)	O
==	O
WHITE	int
)	O
c	char
=	O
'O'	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
BLACK	int
)	O
c	char
=	O
cb	int
;	O
else	O
if	O
(	O
(	O
board	*(char)
[	O
pos	int
]	O
&	O
3	int
)	O
==	O
BLACK	int
)	O
c	char
=	O
'X'	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
GRAY	int
)	O
c	char
=	O
'?'	O
;	O
if	O
(	O
pos	int
==	O
apos	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"[%c"	*(char)
,	O
c	char
)	O
;	O
else	O
if	O
(	O
j	int
>	O
0	int
&&	O
POS	O
(	O
i	int
,	O
j	int
-	O
1	int
)	O
==	O
apos	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"]%c"	*(char)
,	O
c	char
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %c"	*(char)
,	O
c	char
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %d"	*(char)
,	O
ii	int
)	O
;	O
}	O
end_draw_board	()->(void)
(	O
)	O
;	O
}	O
static	O
int	O
verify_stored_board	(array(char))->(int)
(	O
Intersection	char
p	array(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
else	O
if	O
(	O
p	array(char)
[	O
pos	int
]	O
==	O
GRAY	int
)	O
continue	O
;	O
else	O
if	O
(	O
(	O
p	array(char)
[	O
pos	int
]	O
&	O
3	int
)	O
!=	O
board	*(char)
[	O
pos	int
]	O
)	O
return	O
0	int
;	O
else	O
if	O
(	O
!	O
(	O
p	array(char)
[	O
pos	int
]	O
&	O
(	O
HIGH_LIBERTY_BIT	int
|	O
HIGH_LIBERTY_BIT2	int
)	O
)	O
)	O
continue	O
;	O
else	O
if	O
(	O
(	O
(	O
p	array(char)
[	O
pos	int
]	O
&	O
HIGH_LIBERTY_BIT	int
)	O
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
<=	O
4	int
)	O
||	O
(	O
p	array(char)
[	O
pos	int
]	O
&	O
HIGH_LIBERTY_BIT2	int
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
<=	O
3	int
)	O
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
print_persistent_cache_entry	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)))->(void)
(	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
)	O
{	O
int	O
r	int
;	O
gprintf	(*(char))->(int)
(	O
"%omovenum         = %d\n"	*(char)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
movenum	int
)	O
;	O
gprintf	(*(char))->(int)
(	O
"%oscore	     = %d\n"	*(char)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
score	float
)	O
;	O
gprintf	(*(char))->(int)
(	O
"%ocost	     = %d\n"	*(char)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
cost	int
)	O
;	O
gprintf	(*(char))->(int)
(	O
"%oroutine         = %s\n"	*(char)
,	O
routine_id_to_string	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"%oapos            = %1m\n"	*(char)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
)	O
;	O
if	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
bpos	int
!=	O
NO_MOVE	O
)	O
gprintf	(*(char))->(int)
(	O
"%obpos          = %1m\n"	*(char)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
bpos	int
)	O
;	O
if	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
cpos	int
!=	O
NO_MOVE	O
)	O
gprintf	(*(char))->(int)
(	O
"%ocpos            = %1m\n"	*(char)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
cpos	int
)	O
;	O
gprintf	(*(char))->(int)
(	O
"%oresult          = %s\n"	*(char)
,	O
result_to_string	(int)->(*(char))
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result	int
)	O
)	O
;	O
if	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result2	int
!=	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%oresult2         = %s\n"	*(char)
,	O
result_to_string	(int)->(*(char))
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result2	int
)	O
)	O
;	O
if	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result_certain	int
!=	O
-	O
1	int
)	O
gprintf	(*(char))->(int)
(	O
"%oresult_certain  = %d\n"	*(char)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result_certain	int
)	O
;	O
if	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
node_limit	int
!=	O
-	O
1	int
)	O
gprintf	(*(char))->(int)
(	O
"%onode_limit      = %d\n"	*(char)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
node_limit	int
)	O
;	O
if	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
!=	O
NO_MOVE	O
)	O
gprintf	(*(char))->(int)
(	O
"%omove            = %1m\n"	*(char)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
)	O
;	O
if	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move2	*(int)
!=	O
NO_MOVE	O
)	O
gprintf	(*(char))->(int)
(	O
"%omove2           = %1m\n"	*(char)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move2	*(int)
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
MAX_CACHE_DEPTH	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
stack	array(int)
[	O
r	int
]	O
==	O
0	int
)	O
break	O
;	O
gprintf	(*(char))->(int)
(	O
"%ostack[%d]      = %C %1m\n"	*(char)
,	O
r	int
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move_color	array(int)
[	O
r	int
]	O
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
stack	array(int)
[	O
r	int
]	O
)	O
;	O
}	O
draw_active_area	(array(char),int)->(void)
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
board	*(char)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
)	O
;	O
}	O
void	O
print_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)))->(void)
(	O
struct	O
persistent_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
*	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
)	O
;	O
void	O
print_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)))->(void)
(	O
struct	O
persistent_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
*	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
)	O
{	O
int	O
k	int
;	O
gprintf	(*(char))->(int)
(	O
"Entire content of %s:\n"	*(char)
,	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
name	short
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
current_size	int
;	O
k	int
++	O
)	O
print_persistent_cache_entry	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)))->(void)
(	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
+	O
k	int
)	O
;	O
}	O
static	O
void	O
purge_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)))->(void)
(	O
struct	O
persistent_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
*	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
)	O
{	O
int	O
k	int
;	O
int	O
r	int
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
last_purge_position_number	int
==	O
position_number	int
)	O
return	O
;	O
else	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
last_purge_position_number	int
=	O
position_number	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
current_size	int
;	O
k	int
++	O
)	O
{	O
int	O
played_moves	int
=	O
0	int
;	O
int	O
entry_ok	int
=	O
1	int
;	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
=	O
&	O
(	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
[	O
k	int
]	O
)	O
;	O
if	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
boardsize	int
!=	O
board_size	int
)	O
entry_ok	int
=	O
0	int
;	O
else	O
{	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
MAX_CACHE_DEPTH	int
;	O
r	int
++	O
)	O
{	O
int	O
apos	int
=	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
stack	array(int)
[	O
r	int
]	O
;	O
int	O
color	int
=	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move_color	array(int)
[	O
r	int
]	O
;	O
if	O
(	O
apos	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
apos	int
,	O
color	int
,	O
"purge_persistent_cache"	*(char)
,	O
0	int
)	O
)	O
played_moves	int
++	O
;	O
else	O
{	O
entry_ok	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
entry_ok	int
||	O
!	O
verify_stored_board	(array(char))->(int)
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
board	*(char)
)	O
)	O
{	O
if	O
(	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"Purging entry %d from cache.\n"	*(char)
,	O
k	int
)	O
;	O
if	O
(	O
k	int
<	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
current_size	int
-	O
1	int
)	O
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
=	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
[	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
current_size	int
-	O
1	int
]	O
;	O
k	int
--	O
;	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
current_size	int
--	O
;	O
}	O
else	O
{	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
score	float
*=	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
age_factor	float
;	O
}	O
while	O
(	O
played_moves	int
>	O
0	int
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
played_moves	int
--	O
;	O
}	O
}	O
}	O
static	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
find_persistent_cache_entry	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int)->(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)))
(	O
struct	O
persistent_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
*	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
,	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
color	int
,	O
Hash_data	struct(array(long))
*	O
goal_hash	*(struct(array(long)))
,	O
int	O
node_limit	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
current_size	int
;	O
k	int
++	O
)	O
{	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
=	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
+	O
k	int
;	O
if	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
&&	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
==	O
apos	int
&&	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
bpos	int
==	O
bpos	int
&&	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
cpos	int
==	O
cpos	int
&&	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
color	int
==	O
color	int
&&	O
depth	int
-	O
stackp	int
<=	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
remaining_depth	int
&&	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
node_limit	int
>=	O
node_limit	int
||	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result_certain	int
)	O
&&	O
(	O
goal_hash	*(struct(array(long)))
==	O
NULL	O
||	O
hashdata_is_equal	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
goal_hash	*(struct(array(long)))
,	O
*	O
goal_hash	*(struct(array(long)))
)	O
)	O
&&	O
verify_stored_board	(array(char))->(int)
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
board	*(char)
)	O
)	O
return	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
search_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int,*(int),*(int),*(int),*(int),*(int))->(int)
(	O
struct	O
persistent_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
*	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
,	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
color	int
,	O
Hash_data	struct(array(long))
*	O
goal_hash	*(struct(array(long)))
,	O
int	O
node_limit	int
,	O
int	O
*	O
result	int
,	O
int	O
*	O
result2	int
,	O
int	O
*	O
move	*(int)
,	O
int	O
*	O
move2	*(int)
,	O
int	O
*	O
certain	*(int)
)	O
{	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
=	O
find_persistent_cache_entry	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int)->(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)))
(	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
,	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
color	int
,	O
goal_hash	*(struct(array(long)))
,	O
node_limit	int
)	O
;	O
if	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
==	O
NULL	O
)	O
return	O
0	int
;	O
*	O
result	int
=	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result	int
;	O
if	O
(	O
result2	int
)	O
*	O
result2	int
=	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result2	int
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
;	O
if	O
(	O
move2	*(int)
)	O
*	O
move2	*(int)
=	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move2	*(int)
;	O
if	O
(	O
certain	*(int)
)	O
*	O
certain	*(int)
=	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result_certain	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
score	float
+=	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
cost	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_PERSISTENT_CACHE	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%oRetrieved position from %s:\n"	*(char)
,	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
name	short
)	O
;	O
print_persistent_cache_entry	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)))->(void)
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
)	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
name	short
,	O
"reading cache"	*(char)
)	O
==	O
0	int
&&	O
(	O
debug	int
&	O
DEBUG_READING_PERFORMANCE	int
)	O
&&	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
cost	int
>=	O
MIN_READING_NODES_TO_REPORT	int
)	O
{	O
if	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result	int
!=	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o%s %1m = %d %1m, cached (%d nodes) "	*(char)
,	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ATTACK	int
?	O
"attack"	*(char)
:	O
"defend"	*(char)
,	O
apos	int
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result	int
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
cost	int
)	O
;	O
else	O
gprintf	(*(char))->(int)
(	O
"%o%s %1m = %d, cached (%d nodes) "	*(char)
,	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ATTACK	int
?	O
"attack"	*(char)
:	O
"defend"	*(char)
,	O
apos	int
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result	int
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
cost	int
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
store_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int,int,int,int,int,int,int,array(char),int)->(void)
(	O
struct	O
persistent_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
*	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
,	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
color	int
,	O
Hash_data	struct(array(long))
*	O
goal_hash	*(struct(array(long)))
,	O
int	O
result	int
,	O
int	O
result2	int
,	O
int	O
move	*(int)
,	O
int	O
move2	*(int)
,	O
int	O
certain	*(int)
,	O
int	O
node_limit	int
,	O
int	O
cost	int
,	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
goal_color	int
)	O
{	O
int	O
r	int
;	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
;	O
if	O
(	O
stackp	int
>	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
max_stackp	int
)	O
return	O
;	O
if	O
(	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
current_size	int
==	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
max_size	int
)	O
{	O
int	O
worst_entry	int
=	O
-	O
1	int
;	O
int	O
worst_score	int
=	O
cost	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
current_size	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
[	O
k	int
]	O
.	O
score	float
<	O
worst_score	int
)	O
{	O
worst_score	int
=	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
[	O
k	int
]	O
.	O
score	float
;	O
worst_entry	int
=	O
k	int
;	O
}	O
}	O
if	O
(	O
worst_entry	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
worst_entry	int
<	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
current_size	int
-	O
1	int
)	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
[	O
worst_entry	int
]	O
=	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
[	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
current_size	int
-	O
1	int
]	O
;	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
current_size	int
--	O
;	O
}	O
else	O
return	O
;	O
}	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
=	O
&	O
(	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
[	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
current_size	int
]	O
)	O
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
boardsize	int
=	O
board_size	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
=	O
apos	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
bpos	int
=	O
bpos	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
cpos	int
=	O
cpos	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
color	int
=	O
color	int
;	O
if	O
(	O
goal_hash	*(struct(array(long)))
)	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
goal_hash	*(struct(array(long)))
=	O
*	O
goal_hash	*(struct(array(long)))
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result	int
=	O
result	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result2	int
=	O
result2	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result_certain	int
=	O
certain	*(int)
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
node_limit	int
=	O
node_limit	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
remaining_depth	int
=	O
depth	int
-	O
stackp	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
=	O
move	*(int)
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move2	*(int)
=	O
move2	*(int)
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
score	float
=	O
cost	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
cost	int
=	O
cost	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
movenum	int
=	O
movenum	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
MAX_CACHE_DEPTH	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
r	int
<	O
stackp	int
)	O
get_move_from_stack	(int,*(int),*(int))->(void)
(	O
r	int
,	O
&	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
stack	array(int)
[	O
r	int
]	O
)	O
,	O
&	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move_color	array(int)
[	O
r	int
]	O
)	O
)	O
;	O
else	O
{	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
stack	array(int)
[	O
r	int
]	O
=	O
0	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move_color	array(int)
[	O
r	int
]	O
=	O
EMPTY	int
;	O
}	O
}	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
compute_active_area	*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void))
(	O
&	O
(	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
[	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
current_size	int
]	O
)	O
,	O
goal	*(char)
,	O
goal_color	int
)	O
;	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
current_size	int
++	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_PERSISTENT_CACHE	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%oEntered position in %s:\n"	*(char)
,	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
name	short
)	O
;	O
print_persistent_cache_entry	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)))->(void)
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
)	O
;	O
gprintf	(*(char))->(int)
(	O
"%oCurrent size: %d\n"	*(char)
,	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
current_size	int
)	O
;	O
}	O
}	O
static	O
void	O
init_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)))->(void)
(	O
struct	O
persistent_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
*	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
)	O
{	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
=	O
malloc	(long)->(*(void))
(	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
max_size	int
*	O
sizeof	O
(	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
)	O
)	O
;	O
gg_assert	O
(	O
cache	*(struct(int,int,float,*(char),*((*(struct`),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int))
->	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
)	O
;	O
}	O
void	O
persistent_cache_init	()->(void)
(	O
)	O
{	O
init_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)))->(void)
(	O
&	O
reading_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
)	O
;	O
init_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)))->(void)
(	O
&	O
breakin_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
)	O
;	O
init_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)))->(void)
(	O
&	O
connection_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
)	O
;	O
init_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)))->(void)
(	O
&	O
owl_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
)	O
;	O
init_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)))->(void)
(	O
&	O
semeai_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
)	O
;	O
}	O
void	O
clear_persistent_caches	()->(void)
(	O
)	O
{	O
reading_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
.	O
current_size	int
=	O
0	int
;	O
connection_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
.	O
current_size	int
=	O
0	int
;	O
breakin_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
.	O
current_size	int
=	O
0	int
;	O
owl_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
.	O
current_size	int
=	O
0	int
;	O
semeai_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
.	O
current_size	int
=	O
0	int
;	O
}	O
void	O
purge_persistent_caches	()->(void)
(	O
)	O
{	O
purge_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)))->(void)
(	O
&	O
reading_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
)	O
;	O
purge_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)))->(void)
(	O
&	O
connection_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
)	O
;	O
purge_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)))->(void)
(	O
&	O
breakin_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
)	O
;	O
purge_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)))->(void)
(	O
&	O
owl_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
)	O
;	O
purge_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)))->(void)
(	O
&	O
semeai_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
)	O
;	O
}	O
int	O
search_persistent_reading_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(int),*(int))->(int)
(	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
str	int
,	O
int	O
*	O
result	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
return	O
search_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int,*(int),*(int),*(int),*(int),*(int))->(int)
(	O
&	O
reading_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
,	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
str	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
EMPTY	int
,	O
NULL	O
,	O
-	O
1	int
,	O
result	int
,	O
NULL	O
,	O
move	*(int)
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
void	O
store_persistent_reading_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int)->(void)
(	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
str	int
,	O
int	O
result	int
,	O
int	O
move	*(int)
,	O
int	O
nodes	int
)	O
{	O
store_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int,int,int,int,int,int,int,array(char),int)->(void)
(	O
&	O
reading_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
,	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
str	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
EMPTY	int
,	O
NULL	O
,	O
result	int
,	O
NO_MOVE	O
,	O
move	*(int)
,	O
NO_MOVE	O
,	O
-	O
1	int
,	O
-	O
1	int
,	O
nodes	int
,	O
shadow	array(char)
,	O
EMPTY	int
)	O
;	O
}	O
static	O
void	O
compute_active_reading_area	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)
(	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
,	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
dummy	int
)	O
{	O
signed	O
char	O
active	array(char)
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
,	O
r	int
;	O
UNUSED	O
(	O
dummy	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
active	array(char)
[	O
pos	int
]	O
=	O
goal	*(char)
[	O
pos	int
]	O
;	O
mark_string	(int,array(char),char)->(void)
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
,	O
active	array(char)
,	O
1	int
)	O
;	O
if	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result	int
!=	O
0	int
&&	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
!=	O
0	int
)	O
active	array(char)
[	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
]	O
=	O
1	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
active	array(char)
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
1	int
)	O
||	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
1	int
)	O
||	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
1	int
)	O
||	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
1	int
)	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
)	O
mark_string	(int,array(char),char)->(void)
(	O
pos	int
,	O
active	array(char)
,	O
2	int
)	O
;	O
else	O
active	array(char)
[	O
pos	int
]	O
=	O
2	int
;	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
invincible	int
)	O
active	array(char)
[	O
pos	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
||	O
active	array(char)
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
&&	O
active	array(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
2	int
)	O
||	O
(	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
&&	O
active	array(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
2	int
)	O
||	O
(	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
&&	O
active	array(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
2	int
)	O
||	O
(	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
&&	O
active	array(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
2	int
)	O
)	O
active	array(char)
[	O
pos	int
]	O
=	O
3	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
active	array(char)
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
>	O
0	int
&&	O
active	array(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
<	O
4	int
)	O
||	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
>	O
0	int
&&	O
active	array(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
<	O
4	int
)	O
||	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
>	O
0	int
&&	O
active	array(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
<	O
4	int
)	O
||	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
>	O
0	int
&&	O
active	array(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
<	O
4	int
)	O
)	O
active	array(char)
[	O
pos	int
]	O
=	O
4	int
;	O
}	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
stackp	int
;	O
r	int
++	O
)	O
active	array(char)
[	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
stack	array(int)
[	O
r	int
]	O
]	O
=	O
5	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
board	*(char)
[	O
pos	int
]	O
=	O
active	array(char)
[	O
pos	int
]	O
!=	O
0	int
?	O
board	*(char)
[	O
pos	int
]	O
:	O
GRAY	int
;	O
}	O
}	O
static	O
void	O
mark_string_hotspot_values	(array(float),int,int,float)->(void)
(	O
float	O
values	array(float)
[	O
BOARDMAX	O
]	O
,	O
int	O
m	int
,	O
int	O
n	int
,	O
float	O
contribution	float
)	O
{	O
int	O
i	int
,	O
j	int
,	O
k	int
;	O
if	O
(	O
BOARD	O
(	O
m	int
,	O
n	int
)	O
==	O
EMPTY	int
)	O
{	O
for	O
(	O
i	int
=	O
-	O
1	int
;	O
i	int
<=	O
1	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
-	O
1	int
;	O
j	int
<=	O
1	int
;	O
j	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
m	int
+	O
i	int
,	O
n	int
+	O
j	int
)	O
==	O
EMPTY	int
)	O
values	array(float)
[	O
POS	O
(	O
m	int
+	O
i	int
,	O
n	int
+	O
j	int
)	O
]	O
+=	O
contribution	float
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
!=	O
EMPTY	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
di	int
=	O
deltai	array(int)
[	O
k	int
]	O
;	O
int	O
dj	int
=	O
deltaj	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
IS_STONE	O
(	O
BOARD	O
(	O
i	int
+	O
di	int
,	O
j	int
+	O
dj	int
)	O
)	O
&&	O
same_string	(int,int)->(int)
(	O
POS	O
(	O
i	int
+	O
di	int
,	O
j	int
+	O
dj	int
)	O
,	O
POS	O
(	O
m	int
,	O
n	int
)	O
)	O
)	O
{	O
if	O
(	O
k	int
<	O
4	int
)	O
{	O
values	array(float)
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
+=	O
contribution	float
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
BOARD	O
(	O
i	int
+	O
di	int
,	O
j	int
)	O
==	O
EMPTY	int
||	O
countlib	(int)->(int)
(	O
POS	O
(	O
i	int
+	O
di	int
,	O
j	int
)	O
)	O
<=	O
2	int
||	O
BOARD	O
(	O
i	int
,	O
j	int
+	O
dj	int
)	O
==	O
EMPTY	int
||	O
countlib	(int)->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
+	O
dj	int
)	O
)	O
<=	O
2	int
)	O
values	array(float)
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
+=	O
contribution	float
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
void	O
reading_hotspots	(array(float))->(void)
(	O
float	O
values	array(float)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
sum_nodes	int
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
values	array(float)
[	O
pos	int
]	O
=	O
0.0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
reading_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
.	O
current_size	int
;	O
k	int
++	O
)	O
sum_nodes	int
+=	O
reading_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
.	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
[	O
k	int
]	O
.	O
cost	int
;	O
if	O
(	O
sum_nodes	int
<=	O
100	int
)	O
return	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
reading_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
.	O
current_size	int
;	O
k	int
++	O
)	O
{	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
=	O
&	O
(	O
reading_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
.	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
[	O
k	int
]	O
)	O
;	O
float	O
contribution	float
=	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
cost	int
/	O
(	O
float	O
)	O
sum_nodes	int
;	O
if	O
(	O
0	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"Reading hotspots: %d %1m %f\n"	*(char)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
,	O
contribution	float
)	O
;	O
}	O
switch	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
ATTACK	int
:	O
case	O
FIND_DEFENSE	int
:	O
mark_string_hotspot_values	(array(float),int,int,float)->(void)
(	O
values	array(float)
,	O
I	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
)	O
,	O
J	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
)	O
,	O
contribution	float
)	O
;	O
break	O
;	O
default	O
:	O
gg_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
int	O
search_persistent_connection_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,*(int),*(int))->(int)
(	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
result	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
return	O
search_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int,*(int),*(int),*(int),*(int),*(int))->(int)
(	O
&	O
connection_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
,	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
str1	int
,	O
str2	int
,	O
NO_MOVE	O
,	O
EMPTY	int
,	O
NULL	O
,	O
connection_node_limit	int
,	O
result	int
,	O
NULL	O
,	O
move	*(int)
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
void	O
store_persistent_connection_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,array(char))->(void)
(	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
result	int
,	O
int	O
move	*(int)
,	O
int	O
tactical_nodes	int
,	O
signed	O
char	O
connection_shadow	array(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
store_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int,int,int,int,int,int,int,array(char),int)->(void)
(	O
&	O
connection_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
,	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
str1	int
,	O
str2	int
,	O
NO_MOVE	O
,	O
EMPTY	int
,	O
NULL	O
,	O
result	int
,	O
NO_MOVE	O
,	O
move	*(int)
,	O
NO_MOVE	O
,	O
-	O
1	int
,	O
connection_node_limit	int
,	O
tactical_nodes	int
,	O
connection_shadow	array(char)
,	O
EMPTY	int
)	O
;	O
}	O
static	O
void	O
compute_active_connection_area	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)
(	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
,	O
const	O
signed	O
char	O
connection_shadow	array(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
dummy	int
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
,	O
r	int
;	O
signed	O
char	O
active	array(char)
[	O
BOARDMAX	O
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
]	O
)	O
;	O
UNUSED	O
(	O
dummy	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
active	array(char)
[	O
pos	int
]	O
=	O
connection_shadow	array(char)
[	O
pos	int
]	O
;	O
mark_string	(int,array(char),char)->(void)
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
,	O
active	array(char)
,	O
1	int
)	O
;	O
mark_string	(int,array(char),char)->(void)
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
bpos	int
,	O
active	array(char)
,	O
1	int
)	O
;	O
if	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result	int
!=	O
0	int
&&	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
!=	O
0	int
)	O
active	array(char)
[	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
]	O
=	O
1	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
3	int
;	O
k	int
++	O
)	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
board	*(char)
[	O
pos	int
]	O
==	O
other	int
||	O
active	array(char)
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
active	array(char)
[	O
pos	int
]	O
=	O
k	int
+	O
1	int
;	O
else	O
mark_string	(int,array(char),char)->(void)
(	O
pos	int
,	O
active	array(char)
,	O
(	O
signed	O
char	O
)	O
(	O
k	int
+	O
1	int
)	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
!=	O
other	int
||	O
active	array(char)
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
r	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
board	*(char)
[	O
pos2	int
]	O
!=	O
other	int
&&	O
active	array(char)
[	O
pos2	int
]	O
!=	O
0	int
)	O
{	O
mark_string	(int,array(char),char)->(void)
(	O
pos	int
,	O
active	array(char)
,	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
other	int
&&	O
active	array(char)
[	O
pos	int
]	O
>	O
0	int
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
<	O
5	int
)	O
{	O
int	O
libs	*(int)
[	O
4	int
]	O
;	O
int	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
pos	int
,	O
4	int
,	O
libs	*(int)
)	O
;	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj	array(int)
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	*(int)
;	O
r	int
++	O
)	O
active	array(char)
[	O
libs	*(int)
[	O
r	int
]	O
]	O
=	O
1	int
;	O
adj	array(int)
=	O
chainlinks	(int,array(int))->(int)
(	O
pos	int
,	O
adjs	array(int)
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
mark_string	(int,array(char),char)->(void)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
active	array(char)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
countlib	(int)->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
)	O
<=	O
3	int
)	O
{	O
int	O
s	int
;	O
int	O
adjs2	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj2	int
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
3	int
,	O
libs	*(int)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	*(int)
;	O
s	int
++	O
)	O
active	array(char)
[	O
libs	*(int)
[	O
s	int
]	O
]	O
=	O
1	int
;	O
adj2	int
=	O
chainlinks	(int,array(int))->(int)
(	O
pos	int
,	O
adjs2	array(int)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj2	int
;	O
s	int
++	O
)	O
mark_string	(int,array(char),char)->(void)
(	O
adjs2	array(int)
[	O
s	int
]	O
,	O
active	array(char)
,	O
-	O
1	int
)	O
;	O
}	O
}	O
}	O
}	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
stackp	int
;	O
r	int
++	O
)	O
active	array(char)
[	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
stack	array(int)
[	O
r	int
]	O
]	O
=	O
1	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
value	*(char)
=	O
board	*(char)
[	O
pos	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
active	array(char)
[	O
pos	int
]	O
)	O
value	*(char)
=	O
GRAY	int
;	O
else	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
>	O
4	int
&&	O
active	array(char)
[	O
pos	int
]	O
>	O
0	int
)	O
value	*(char)
|=	O
HIGH_LIBERTY_BIT	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
board	*(char)
[	O
pos	int
]	O
=	O
value	*(char)
;	O
}	O
}	O
int	O
search_persistent_breakin_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(struct(array(long))),int,*(int),*(int))->(int)
(	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
str	int
,	O
Hash_data	struct(array(long))
*	O
goal_hash	*(struct(array(long)))
,	O
int	O
node_limit	int
,	O
int	O
*	O
result	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
return	O
search_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int,*(int),*(int),*(int),*(int),*(int))->(int)
(	O
&	O
breakin_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
,	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
str	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
EMPTY	int
,	O
goal_hash	*(struct(array(long)))
,	O
node_limit	int
,	O
result	int
,	O
NULL	O
,	O
move	*(int)
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
void	O
store_persistent_breakin_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(struct(array(long))),int,int,int,int,array(char))->(void)
(	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
str	int
,	O
Hash_data	struct(array(long))
*	O
goal_hash	*(struct(array(long)))
,	O
int	O
result	int
,	O
int	O
move	*(int)
,	O
int	O
tactical_nodes	int
,	O
int	O
breakin_node_limit	int
,	O
signed	O
char	O
breakin_shadow	array(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
store_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int,int,int,int,int,int,int,array(char),int)->(void)
(	O
&	O
breakin_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
,	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
str	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
EMPTY	int
,	O
goal_hash	*(struct(array(long)))
,	O
result	int
,	O
NO_MOVE	O
,	O
move	*(int)
,	O
NO_MOVE	O
,	O
-	O
1	int
,	O
breakin_node_limit	int
,	O
tactical_nodes	int
,	O
breakin_shadow	array(char)
,	O
EMPTY	int
)	O
;	O
}	O
static	O
void	O
compute_active_breakin_area	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)
(	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
,	O
const	O
signed	O
char	O
breakin_shadow	array(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
dummy	int
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
,	O
r	int
;	O
signed	O
char	O
active	array(char)
[	O
BOARDMAX	O
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
]	O
)	O
;	O
UNUSED	O
(	O
dummy	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
active	array(char)
[	O
pos	int
]	O
=	O
breakin_shadow	array(char)
[	O
pos	int
]	O
;	O
mark_string	(int,array(char),char)->(void)
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
,	O
active	array(char)
,	O
1	int
)	O
;	O
if	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
result	int
!=	O
0	int
&&	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
!=	O
0	int
)	O
active	array(char)
[	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
]	O
=	O
1	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
3	int
;	O
k	int
++	O
)	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
board	*(char)
[	O
pos	int
]	O
==	O
other	int
||	O
active	array(char)
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
active	array(char)
[	O
pos	int
]	O
=	O
k	int
+	O
1	int
;	O
else	O
mark_string	(int,array(char),char)->(void)
(	O
pos	int
,	O
active	array(char)
,	O
(	O
signed	O
char	O
)	O
(	O
k	int
+	O
1	int
)	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
!=	O
other	int
||	O
active	array(char)
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
r	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
board	*(char)
[	O
pos2	int
]	O
!=	O
other	int
&&	O
active	array(char)
[	O
pos2	int
]	O
&&	O
active	array(char)
[	O
pos2	int
]	O
<=	O
2	int
)	O
{	O
mark_string	(int,array(char),char)->(void)
(	O
pos	int
,	O
active	array(char)
,	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
other	int
&&	O
active	array(char)
[	O
pos	int
]	O
>	O
0	int
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
<	O
4	int
)	O
{	O
int	O
libs	*(int)
[	O
4	int
]	O
;	O
int	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
pos	int
,	O
3	int
,	O
libs	*(int)
)	O
;	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj	array(int)
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	*(int)
;	O
r	int
++	O
)	O
active	array(char)
[	O
libs	*(int)
[	O
r	int
]	O
]	O
=	O
1	int
;	O
adj	array(int)
=	O
chainlinks	(int,array(int))->(int)
(	O
pos	int
,	O
adjs	array(int)
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
mark_string	(int,array(char),char)->(void)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
active	array(char)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
countlib	(int)->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
)	O
<=	O
3	int
)	O
{	O
int	O
s	int
;	O
int	O
adjs2	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj2	int
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
3	int
,	O
libs	*(int)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	*(int)
;	O
s	int
++	O
)	O
active	array(char)
[	O
libs	*(int)
[	O
s	int
]	O
]	O
=	O
1	int
;	O
adj2	int
=	O
chainlinks	(int,array(int))->(int)
(	O
pos	int
,	O
adjs2	array(int)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj2	int
;	O
s	int
++	O
)	O
mark_string	(int,array(char),char)->(void)
(	O
adjs2	array(int)
[	O
s	int
]	O
,	O
active	array(char)
,	O
-	O
1	int
)	O
;	O
}	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
Intersection	char
value	*(char)
=	O
board	*(char)
[	O
pos	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
active	array(char)
[	O
pos	int
]	O
)	O
value	*(char)
=	O
GRAY	int
;	O
else	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
>	O
3	int
&&	O
active	array(char)
[	O
pos	int
]	O
>	O
0	int
)	O
value	*(char)
|=	O
HIGH_LIBERTY_BIT2	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
board	*(char)
[	O
pos	int
]	O
=	O
value	*(char)
;	O
}	O
}	O
int	O
search_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(int),*(int),*(int),*(int))->(int)
(	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
*	O
result	int
,	O
int	O
*	O
move	*(int)
,	O
int	O
*	O
move2	*(int)
,	O
int	O
*	O
certain	*(int)
)	O
{	O
return	O
search_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int,*(int),*(int),*(int),*(int),*(int))->(int)
(	O
&	O
owl_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
,	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
EMPTY	int
,	O
NULL	O
,	O
owl_node_limit	int
,	O
result	int
,	O
NULL	O
,	O
move	*(int)
,	O
move2	*(int)
,	O
certain	*(int)
)	O
;	O
}	O
void	O
store_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,array(char),int)->(void)
(	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
result	int
,	O
int	O
move	*(int)
,	O
int	O
move2	*(int)
,	O
int	O
certain	*(int)
,	O
int	O
tactical_nodes	int
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
goal_color	int
)	O
{	O
store_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int,int,int,int,int,int,int,array(char),int)->(void)
(	O
&	O
owl_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
,	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
EMPTY	int
,	O
NULL	O
,	O
result	int
,	O
NO_MOVE	O
,	O
move	*(int)
,	O
move2	*(int)
,	O
certain	*(int)
,	O
owl_node_limit	int
,	O
tactical_nodes	int
,	O
goal	*(char)
,	O
goal_color	int
)	O
;	O
}	O
static	O
void	O
compute_active_owl_type_area	(array(char),int,array(char))->(void)
(	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
goal_color	int
,	O
signed	O
char	O
active	array(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
k	int
,	O
r	int
;	O
int	O
pos	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
goal_color	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
goal	*(char)
[	O
pos	int
]	O
)	O
active	array(char)
[	O
pos	int
]	O
=	O
1	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
5	int
;	O
k	int
++	O
)	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
board	*(char)
[	O
pos	int
]	O
==	O
other	int
||	O
active	array(char)
[	O
pos	int
]	O
>	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
active	array(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
active	array(char)
[	O
pos	int
]	O
=	O
k	int
+	O
1	int
;	O
else	O
mark_string	(int,array(char),char)->(void)
(	O
pos	int
,	O
active	array(char)
,	O
(	O
signed	O
char	O
)	O
(	O
k	int
+	O
1	int
)	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
!=	O
other	int
||	O
active	array(char)
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
r	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
board	*(char)
[	O
pos2	int
]	O
!=	O
other	int
&&	O
active	array(char)
[	O
pos2	int
]	O
!=	O
0	int
)	O
{	O
mark_string	(int,array(char),char)->(void)
(	O
pos	int
,	O
active	array(char)
,	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
other	int
&&	O
active	array(char)
[	O
pos	int
]	O
>	O
0	int
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
<	O
5	int
)	O
{	O
int	O
libs	*(int)
[	O
4	int
]	O
;	O
int	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
pos	int
,	O
4	int
,	O
libs	*(int)
)	O
;	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj	array(int)
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	*(int)
;	O
r	int
++	O
)	O
active	array(char)
[	O
libs	*(int)
[	O
r	int
]	O
]	O
=	O
1	int
;	O
adj	array(int)
=	O
chainlinks	(int,array(int))->(int)
(	O
pos	int
,	O
adjs	array(int)
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
mark_string	(int,array(char),char)->(void)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
active	array(char)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
countlib	(int)->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
)	O
<=	O
3	int
)	O
{	O
int	O
s	int
;	O
int	O
adjs2	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj2	int
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
3	int
,	O
libs	*(int)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	*(int)
;	O
s	int
++	O
)	O
active	array(char)
[	O
libs	*(int)
[	O
s	int
]	O
]	O
=	O
1	int
;	O
adj2	int
=	O
chainlinks	(int,array(int))->(int)
(	O
pos	int
,	O
adjs2	array(int)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj2	int
;	O
s	int
++	O
)	O
mark_string	(int,array(char),char)->(void)
(	O
adjs2	array(int)
[	O
s	int
]	O
,	O
active	array(char)
,	O
-	O
1	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
compute_active_owl_area	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)
(	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
,	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
goal_color	int
)	O
{	O
int	O
pos	int
;	O
signed	O
char	O
active	array(char)
[	O
BOARDMAX	O
]	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
active	array(char)
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
if	O
(	O
ON_BOARD1	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
)	O
)	O
active	array(char)
[	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
]	O
=	O
1	int
;	O
if	O
(	O
ON_BOARD1	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move2	*(int)
)	O
)	O
active	array(char)
[	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move2	*(int)
]	O
=	O
1	int
;	O
compute_active_owl_type_area	(array(char),int,array(char))->(void)
(	O
goal	*(char)
,	O
goal_color	int
,	O
active	array(char)
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
value	*(char)
=	O
board	*(char)
[	O
pos	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
active	array(char)
[	O
pos	int
]	O
)	O
value	*(char)
=	O
GRAY	int
;	O
else	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
>	O
4	int
&&	O
active	array(char)
[	O
pos	int
]	O
>	O
0	int
)	O
value	*(char)
|=	O
HIGH_LIBERTY_BIT	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
board	*(char)
[	O
pos	int
]	O
=	O
value	*(char)
;	O
}	O
}	O
int	O
search_persistent_semeai_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),*(int),*(int),*(int),*(int))->(int)
(	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
color	int
,	O
Hash_data	struct(array(long))
*	O
goal_hash	*(struct(array(long)))
,	O
int	O
*	O
resulta	*(int)
,	O
int	O
*	O
resultb	*(int)
,	O
int	O
*	O
move	*(int)
,	O
int	O
*	O
certain	*(int)
)	O
{	O
return	O
search_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int,*(int),*(int),*(int),*(int),*(int))->(int)
(	O
&	O
semeai_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
,	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
color	int
,	O
goal_hash	*(struct(array(long)))
,	O
semeai_node_limit	int
,	O
resulta	*(int)
,	O
resultb	*(int)
,	O
move	*(int)
,	O
NULL	O
,	O
certain	*(int)
)	O
;	O
}	O
void	O
store_persistent_semeai_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int,int,int,int,int,array(char),array(char))->(void)
(	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
color	int
,	O
Hash_data	struct(array(long))
*	O
goal_hash	*(struct(array(long)))
,	O
int	O
resulta	*(int)
,	O
int	O
resultb	*(int)
,	O
int	O
move	*(int)
,	O
int	O
certain	*(int)
,	O
int	O
tactical_nodes	int
,	O
signed	O
char	O
goala	array(char)
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
goalb	array(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
goal	*(char)
[	O
pos	int
]	O
=	O
goala	array(char)
[	O
pos	int
]	O
||	O
goalb	array(char)
[	O
pos	int
]	O
;	O
store_persistent_cache	(*(struct(int,int,float,*(char),*((*`,array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),int,int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int,int,int,int,int,int,int,array(char),int)->(void)
(	O
&	O
semeai_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
,	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
color	int
,	O
goal_hash	*(struct(array(long)))
,	O
resulta	*(int)
,	O
resultb	*(int)
,	O
move	*(int)
,	O
NO_MOVE	O
,	O
certain	*(int)
,	O
semeai_node_limit	int
,	O
tactical_nodes	int
,	O
goal	*(char)
,	O
EMPTY	int
)	O
;	O
}	O
static	O
void	O
compute_active_semeai_area	(*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),array(char),int)->(void)
(	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
,	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
dummy	int
)	O
{	O
int	O
pos	int
;	O
signed	O
char	O
active_b	array(char)
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
active_w	array(char)
[	O
BOARDMAX	O
]	O
;	O
UNUSED	O
(	O
dummy	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
active_b	array(char)
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
active_w	array(char)
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
if	O
(	O
ON_BOARD1	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
)	O
)	O
{	O
active_b	array(char)
[	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
]	O
=	O
1	int
;	O
active_w	array(char)
[	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
move	*(int)
]	O
=	O
1	int
;	O
}	O
if	O
(	O
ON_BOARD1	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
cpos	int
)	O
)	O
{	O
active_b	array(char)
[	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
cpos	int
]	O
=	O
1	int
;	O
active_w	array(char)
[	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
cpos	int
]	O
=	O
1	int
;	O
}	O
compute_active_owl_type_area	(array(char),int,array(char))->(void)
(	O
goal	*(char)
,	O
BLACK	int
,	O
active_b	array(char)
)	O
;	O
compute_active_owl_type_area	(array(char),int,array(char))->(void)
(	O
goal	*(char)
,	O
WHITE	int
,	O
active_w	array(char)
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
value	*(char)
=	O
board	*(char)
[	O
pos	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
active_b	array(char)
[	O
pos	int
]	O
&&	O
!	O
active_w	array(char)
[	O
pos	int
]	O
)	O
value	*(char)
=	O
GRAY	int
;	O
else	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
>	O
4	int
&&	O
(	O
active_b	array(char)
[	O
pos	int
]	O
>	O
0	int
||	O
active_w	array(char)
[	O
pos	int
]	O
>	O
0	int
)	O
)	O
value	*(char)
|=	O
HIGH_LIBERTY_BIT	int
;	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
board	*(char)
[	O
pos	int
]	O
=	O
value	*(char)
;	O
}	O
}	O
static	O
void	O
mark_dragon_hotspot_values	(array(float),int,float,array(char))->(void)
(	O
float	O
values	array(float)
[	O
BOARDMAX	O
]	O
,	O
int	O
dr	int
,	O
float	O
contribution	float
,	O
Intersection	char
active_board	array(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
if	O
(	O
!	O
IS_STONE	O
(	O
board	*(char)
[	O
dr	int
]	O
)	O
)	O
return	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos2	int
]	O
)	O
&&	O
(	O
is_same_dragon	(int,int)->(int)
(	O
pos2	int
,	O
dr	int
)	O
||	O
(	O
are_neighbor_dragons	(int,int)->(int)
(	O
pos2	int
,	O
dr	int
)	O
&&	O
board	*(char)
[	O
pos2	int
]	O
==	O
board	*(char)
[	O
dr	int
]	O
)	O
)	O
&&	O
(	O
countlib	(int)->(int)
(	O
pos2	int
)	O
<=	O
4	int
||	O
is_edge_vertex	(int)->(int)
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
k	int
<	O
4	int
)	O
{	O
if	O
(	O
is_same_dragon	(int,int)->(int)
(	O
pos2	int
,	O
dr	int
)	O
)	O
values	array(float)
[	O
pos	int
]	O
+=	O
contribution	float
;	O
else	O
values	array(float)
[	O
pos	int
]	O
+=	O
0.5	int
*	O
contribution	float
;	O
break	O
;	O
}	O
else	O
{	O
int	O
pos3	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
%	O
4	int
]	O
;	O
int	O
pos4	int
=	O
pos	int
+	O
delta	array(int)
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos3	int
]	O
==	O
EMPTY	int
||	O
countlib	(int)->(int)
(	O
pos3	int
)	O
<=	O
2	int
||	O
board	*(char)
[	O
pos4	int
]	O
==	O
EMPTY	int
||	O
countlib	(int)->(int)
(	O
pos4	int
)	O
<=	O
2	int
)	O
values	array(float)
[	O
pos	int
]	O
+=	O
0.5	int
*	O
contribution	float
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
k	int
==	O
8	int
&&	O
active_board	array(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
values	array(float)
[	O
pos	int
]	O
-=	O
0.5	int
*	O
contribution	float
;	O
}	O
}	O
}	O
void	O
owl_hotspots	(array(float))->(void)
(	O
float	O
values	array(float)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
,	O
r	int
;	O
int	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties	*(int)
;	O
int	O
sum_tactical_nodes	int
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
values	array(float)
[	O
pos	int
]	O
=	O
0.0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
owl_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
.	O
current_size	int
;	O
k	int
++	O
)	O
sum_tactical_nodes	int
+=	O
owl_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
.	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
[	O
k	int
]	O
.	O
score	float
;	O
if	O
(	O
sum_tactical_nodes	int
<=	O
100	int
)	O
return	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
owl_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
.	O
current_size	int
;	O
k	int
++	O
)	O
{	O
struct	O
persistent_cache_entry	struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)
*	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
=	O
&	O
(	O
owl_cache	struct(int,int,float,*(char),*((*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct`,int,int,int,int,int,int,int,int,int)),array(char),int)->(void)),*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int)),int,int)
.	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
[	O
k	int
]	O
)	O
;	O
float	O
contribution	float
=	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
score	float
/	O
(	O
float	O
)	O
sum_tactical_nodes	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_PERSISTENT_CACHE	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"Owl hotspots: %d %1m %f\n"	*(char)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
,	O
contribution	float
)	O
;	O
}	O
switch	O
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
OWL_ATTACK	int
:	O
case	O
OWL_THREATEN_ATTACK	int
:	O
case	O
OWL_DEFEND	int
:	O
case	O
OWL_THREATEN_DEFENSE	int
:	O
mark_dragon_hotspot_values	(array(float),int,float,array(char))->(void)
(	O
values	array(float)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
,	O
contribution	float
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
board	*(char)
)	O
;	O
break	O
;	O
case	O
OWL_DOES_DEFEND	int
:	O
case	O
OWL_DOES_ATTACK	int
:	O
case	O
OWL_CONFIRM_SAFETY	int
:	O
mark_dragon_hotspot_values	(array(float),int,float,array(char))->(void)
(	O
values	array(float)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
bpos	int
,	O
contribution	float
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
board	*(char)
)	O
;	O
break	O
;	O
case	O
OWL_CONNECTION_DEFENDS	int
:	O
mark_dragon_hotspot_values	(array(float),int,float,array(char))->(void)
(	O
values	array(float)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
bpos	int
,	O
contribution	float
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
board	*(char)
)	O
;	O
mark_dragon_hotspot_values	(array(float),int,float,array(char))->(void)
(	O
values	array(float)
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
cpos	int
,	O
contribution	float
,	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
board	*(char)
)	O
;	O
break	O
;	O
case	O
OWL_SUBSTANTIAL	int
:	O
if	O
(	O
!	O
IS_STONE	O
(	O
board	*(char)
[	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
]	O
)	O
)	O
continue	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
entry	*(struct(int,int,array(char),array(int),array(int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,struct(array(long)),int,int,int,int,int,int,int,int,int))
->	O
apos	int
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	*(int)
;	O
r	int
++	O
)	O
values	array(float)
[	O
libs	*(int)
[	O
r	int
]	O
]	O
+=	O
contribution	float
;	O
break	O
;	O
default	O
:	O
gg_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
