static	O
void	O
gcm_gf_add	(*(union(array(char),array(long),array(long))),*(union(array(char),array(long),array(long))),*(union(array(char),array(long),array(long))))->(void)
(	O
union	O
nettle_block16	union(array(char),array(long),array(long))
*	O
r	*(union(array(char),array(long),array(long)))
,	O
const	O
union	O
nettle_block16	union(array(char),array(long),array(long))
*	O
x	union(array(char),array(long),array(long))
,	O
const	O
union	O
nettle_block16	union(array(char),array(long),array(long))
*	O
y	*(union(array(char),array(long),array(long)))
)	O
{	O
r	*(union(array(char),array(long),array(long)))
->	O
w	array(long)
[	O
0	int
]	O
=	O
x	union(array(char),array(long),array(long))
->	O
w	array(long)
[	O
0	int
]	O
^	O
y	*(union(array(char),array(long),array(long)))
->	O
w	array(long)
[	O
0	int
]	O
;	O
r	*(union(array(char),array(long),array(long)))
->	O
w	array(long)
[	O
1	int
]	O
=	O
x	union(array(char),array(long),array(long))
->	O
w	array(long)
[	O
1	int
]	O
^	O
y	*(union(array(char),array(long),array(long)))
->	O
w	array(long)
[	O
1	int
]	O
;	O
}	O
static	O
void	O
gcm_gf_shift	(*(union(array(char),array(long),array(long))),*(union(array(char),array(long),array(long))))->(void)
(	O
union	O
nettle_block16	union(array(char),array(long),array(long))
*	O
r	*(union(array(char),array(long),array(long)))
,	O
const	O
union	O
nettle_block16	union(array(char),array(long),array(long))
*	O
x	union(array(char),array(long),array(long))
)	O
{	O
long	O
mask	long
;	O
mask	long
=	O
-	O
(	O
(	O
x	union(array(char),array(long),array(long))
->	O
w	array(long)
[	O
1	int
]	O
>>	O
56	int
)	O
&	O
1	int
)	O
;	O
r	*(union(array(char),array(long),array(long)))
->	O
w	array(long)
[	O
1	int
]	O
=	O
RSHIFT_WORD	O
(	O
x	union(array(char),array(long),array(long))
->	O
w	array(long)
[	O
1	int
]	O
)	O
|	O
(	O
(	O
x	union(array(char),array(long),array(long))
->	O
w	array(long)
[	O
0	int
]	O
>>	O
49	int
)	O
&	O
0x80	int
)	O
;	O
r	*(union(array(char),array(long),array(long)))
->	O
w	array(long)
[	O
0	int
]	O
=	O
RSHIFT_WORD	O
(	O
x	union(array(char),array(long),array(long))
->	O
w	array(long)
[	O
0	int
]	O
)	O
^	O
(	O
mask	long
&	O
GHASH_POLYNOMIAL	int
)	O
;	O
}	O
void	O
_nettle_gcm_hash8	(*(struct(array(union(array(char),array(long),array(long))))),*(union(array(char),array(long),array(long))),long,*(char))->(void)
(	O
const	O
struct	O
gcm_key	struct(array(union(array(char),array(long),array(long))))
*	O
key	*(char)
,	O
union	O
nettle_block16	union(array(char),array(long),array(long))
*	O
x	union(array(char),array(long),array(long))
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
data	*(char)
)	O
;	O
void	O
gcm_set_key	O
(	O
struct	O
gcm_key	struct(array(union(array(char),array(long),array(long))))
*	O
key	*(char)
,	O
const	O
void	O
*	O
cipher	*(void)
,	O
nettle_cipher_func	(*(void),long,*(char),*(char))->(void)
*	O
f	*((*(void),long,*(char),*(char))->(void))
)	O
{	O
unsigned	O
i	int
=	O
(	O
1	int
<<	O
GCM_TABLE_BITS	int
)	O
/	O
2	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
key	*(char)
->	O
h	array(union(array(char),array(long),array(long)))
[	O
0	int
]	O
.	O
b	array(char)
,	O
0	int
,	O
GCM_BLOCK_SIZE	int
)	O
;	O
f	*((*(void),long,*(char),*(char))->(void))
(	O
cipher	*(void)
,	O
GCM_BLOCK_SIZE	int
,	O
key	*(char)
->	O
h	array(union(array(char),array(long),array(long)))
[	O
i	int
]	O
.	O
b	array(char)
,	O
key	*(char)
->	O
h	array(union(array(char),array(long),array(long)))
[	O
0	int
]	O
.	O
b	array(char)
)	O
;	O
while	O
(	O
i	int
/=	O
2	int
)	O
gcm_gf_shift	(*(union(array(char),array(long),array(long))),*(union(array(char),array(long),array(long))))->(void)
(	O
&	O
key	*(char)
->	O
h	array(union(array(char),array(long),array(long)))
[	O
i	int
]	O
,	O
&	O
key	*(char)
->	O
h	array(union(array(char),array(long),array(long)))
[	O
2	int
*	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
1	int
<<	O
GCM_TABLE_BITS	int
;	O
i	int
*=	O
2	int
)	O
{	O
unsigned	O
j	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
i	int
;	O
j	int
++	O
)	O
gcm_gf_add	(*(union(array(char),array(long),array(long))),*(union(array(char),array(long),array(long))),*(union(array(char),array(long),array(long))))->(void)
(	O
&	O
key	*(char)
->	O
h	array(union(array(char),array(long),array(long)))
[	O
i	int
+	O
j	int
]	O
,	O
&	O
key	*(char)
->	O
h	array(union(array(char),array(long),array(long)))
[	O
i	int
]	O
,	O
&	O
key	*(char)
->	O
h	array(union(array(char),array(long),array(long)))
[	O
j	int
]	O
)	O
;	O
}	O
}	O
static	O
void	O
gcm_hash_sizes	(*(struct(array(union(array(char),array(long),array(long))))),*(union(array(char),array(long),array(long))),long,long)->(void)
(	O
const	O
struct	O
gcm_key	struct(array(union(array(char),array(long),array(long))))
*	O
key	*(char)
,	O
union	O
nettle_block16	union(array(char),array(long),array(long))
*	O
x	union(array(char),array(long),array(long))
,	O
uint64_t	long
auth_size	long
,	O
uint64_t	long
data_size	long
)	O
{	O
uint8_t	char
buffer	*(union(array(char),array(long),array(long)))
[	O
GCM_BLOCK_SIZE	int
]	O
;	O
data_size	long
*=	O
8	int
;	O
auth_size	long
*=	O
8	int
;	O
WRITE_UINT64	O
(	O
buffer	*(union(array(char),array(long),array(long)))
,	O
auth_size	long
)	O
;	O
WRITE_UINT64	O
(	O
buffer	*(union(array(char),array(long),array(long)))
+	O
8	int
,	O
data_size	long
)	O
;	O
gcm_hash	O
(	O
key	*(char)
,	O
x	union(array(char),array(long),array(long))
,	O
GCM_BLOCK_SIZE	int
,	O
buffer	*(union(array(char),array(long),array(long)))
)	O
;	O
}	O
void	O
gcm_set_iv	O
(	O
struct	O
gcm_ctx	struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),long,long)
*	O
ctx	*(void)
,	O
const	O
struct	O
gcm_key	struct(array(union(array(char),array(long),array(long))))
*	O
key	*(char)
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
iv	union(array(char),array(long),array(long))
)	O
{	O
if	O
(	O
length	long
==	O
GCM_IV_SIZE	O
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
ctx	*(void)
->	O
iv	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
iv	union(array(char),array(long),array(long))
,	O
GCM_BLOCK_SIZE	int
-	O
4	int
)	O
;	O
ctx	*(void)
->	O
iv	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
GCM_BLOCK_SIZE	int
-	O
4	int
]	O
=	O
0	int
;	O
ctx	*(void)
->	O
iv	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
GCM_BLOCK_SIZE	int
-	O
3	int
]	O
=	O
0	int
;	O
ctx	*(void)
->	O
iv	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
GCM_BLOCK_SIZE	int
-	O
2	int
]	O
=	O
0	int
;	O
ctx	*(void)
->	O
iv	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
GCM_BLOCK_SIZE	int
-	O
1	int
]	O
=	O
1	int
;	O
}	O
else	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
ctx	*(void)
->	O
iv	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
0	int
,	O
GCM_BLOCK_SIZE	int
)	O
;	O
gcm_hash	O
(	O
key	*(char)
,	O
&	O
ctx	*(void)
->	O
iv	union(array(char),array(long),array(long))
,	O
length	long
,	O
iv	union(array(char),array(long),array(long))
)	O
;	O
gcm_hash_sizes	(*(struct(array(union(array(char),array(long),array(long))))),*(union(array(char),array(long),array(long))),long,long)->(void)
(	O
key	*(char)
,	O
&	O
ctx	*(void)
->	O
iv	union(array(char),array(long),array(long))
,	O
0	int
,	O
length	long
)	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
ctx	*(void)
->	O
ctr	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
ctx	*(void)
->	O
iv	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
GCM_BLOCK_SIZE	int
)	O
;	O
INC32	O
(	O
ctx	*(void)
->	O
ctr	union(array(char),array(long),array(long))
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
ctx	*(void)
->	O
x	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
0	int
,	O
sizeof	O
(	O
ctx	*(void)
->	O
x	union(array(char),array(long),array(long))
)	O
)	O
;	O
ctx	*(void)
->	O
auth_size	long
=	O
ctx	*(void)
->	O
data_size	long
=	O
0	int
;	O
}	O
void	O
gcm_update	O
(	O
struct	O
gcm_ctx	struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),long,long)
*	O
ctx	*(void)
,	O
const	O
struct	O
gcm_key	struct(array(union(array(char),array(long),array(long))))
*	O
key	*(char)
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
data	*(char)
)	O
{	O
assert	O
(	O
ctx	*(void)
->	O
auth_size	long
%	O
GCM_BLOCK_SIZE	int
==	O
0	int
)	O
;	O
assert	O
(	O
ctx	*(void)
->	O
data_size	long
==	O
0	int
)	O
;	O
gcm_hash	O
(	O
key	*(char)
,	O
&	O
ctx	*(void)
->	O
x	union(array(char),array(long),array(long))
,	O
length	long
,	O
data	*(char)
)	O
;	O
ctx	*(void)
->	O
auth_size	long
+=	O
length	long
;	O
}	O
static	O
nettle_fill16_func	(*(char),long,*(union(array(char),array(long),array(long))))->(void)
gcm_fill	(*(char),long,*(union(array(char),array(long),array(long))))->(void)
;	O
static	O
void	O
gcm_fill	(*(char),long,*(union(array(char),array(long),array(long))))->(void)
(	O
uint8_t	char
*	O
ctr	union(array(char),array(long),array(long))
,	O
size_t	long
blocks	long
,	O
union	O
nettle_block16	union(array(char),array(long),array(long))
*	O
buffer	*(union(array(char),array(long),array(long)))
)	O
{	O
uint32_t	int
c	int
;	O
c	int
=	O
READ_UINT32	O
(	O
ctr	union(array(char),array(long),array(long))
+	O
GCM_BLOCK_SIZE	int
-	O
4	int
)	O
;	O
for	O
(	O
;	O
blocks	long
--	O
>	O
0	int
;	O
buffer	*(union(array(char),array(long),array(long)))
++	O
,	O
c	int
++	O
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buffer	*(union(array(char),array(long),array(long)))
->	O
b	array(char)
,	O
ctr	union(array(char),array(long),array(long))
,	O
GCM_BLOCK_SIZE	int
-	O
4	int
)	O
;	O
WRITE_UINT32	O
(	O
buffer	*(union(array(char),array(long),array(long)))
->	O
b	array(char)
+	O
GCM_BLOCK_SIZE	int
-	O
4	int
,	O
c	int
)	O
;	O
}	O
WRITE_UINT32	O
(	O
ctr	union(array(char),array(long),array(long))
+	O
GCM_BLOCK_SIZE	int
-	O
4	int
,	O
c	int
)	O
;	O
}	O
void	O
gcm_encrypt	O
(	O
struct	O
gcm_ctx	struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),long,long)
*	O
ctx	*(void)
,	O
const	O
struct	O
gcm_key	struct(array(union(array(char),array(long),array(long))))
*	O
key	*(char)
,	O
const	O
void	O
*	O
cipher	*(void)
,	O
nettle_cipher_func	(*(void),long,*(char),*(char))->(void)
*	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
dst	*(char)
,	O
const	O
uint8_t	char
*	O
src	*(char)
)	O
{	O
assert	O
(	O
ctx	*(void)
->	O
data_size	long
%	O
GCM_BLOCK_SIZE	int
==	O
0	int
)	O
;	O
_ctr_crypt16	O
(	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
gcm_fill	(*(char),long,*(union(array(char),array(long),array(long))))->(void)
,	O
ctx	*(void)
->	O
ctr	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
length	long
,	O
dst	*(char)
,	O
src	*(char)
)	O
;	O
gcm_hash	O
(	O
key	*(char)
,	O
&	O
ctx	*(void)
->	O
x	union(array(char),array(long),array(long))
,	O
length	long
,	O
dst	*(char)
)	O
;	O
ctx	*(void)
->	O
data_size	long
+=	O
length	long
;	O
}	O
void	O
gcm_decrypt	O
(	O
struct	O
gcm_ctx	struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),long,long)
*	O
ctx	*(void)
,	O
const	O
struct	O
gcm_key	struct(array(union(array(char),array(long),array(long))))
*	O
key	*(char)
,	O
const	O
void	O
*	O
cipher	*(void)
,	O
nettle_cipher_func	(*(void),long,*(char),*(char))->(void)
*	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
dst	*(char)
,	O
const	O
uint8_t	char
*	O
src	*(char)
)	O
{	O
assert	O
(	O
ctx	*(void)
->	O
data_size	long
%	O
GCM_BLOCK_SIZE	int
==	O
0	int
)	O
;	O
gcm_hash	O
(	O
key	*(char)
,	O
&	O
ctx	*(void)
->	O
x	union(array(char),array(long),array(long))
,	O
length	long
,	O
src	*(char)
)	O
;	O
_ctr_crypt16	O
(	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
gcm_fill	(*(char),long,*(union(array(char),array(long),array(long))))->(void)
,	O
ctx	*(void)
->	O
ctr	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
length	long
,	O
dst	*(char)
,	O
src	*(char)
)	O
;	O
ctx	*(void)
->	O
data_size	long
+=	O
length	long
;	O
}	O
void	O
gcm_digest	O
(	O
struct	O
gcm_ctx	struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),long,long)
*	O
ctx	*(void)
,	O
const	O
struct	O
gcm_key	struct(array(union(array(char),array(long),array(long))))
*	O
key	*(char)
,	O
const	O
void	O
*	O
cipher	*(void)
,	O
nettle_cipher_func	(*(void),long,*(char),*(char))->(void)
*	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
digest	*(char)
)	O
{	O
uint8_t	char
buffer	*(union(array(char),array(long),array(long)))
[	O
GCM_BLOCK_SIZE	int
]	O
;	O
assert	O
(	O
length	long
<=	O
GCM_BLOCK_SIZE	int
)	O
;	O
gcm_hash_sizes	(*(struct(array(union(array(char),array(long),array(long))))),*(union(array(char),array(long),array(long))),long,long)->(void)
(	O
key	*(char)
,	O
&	O
ctx	*(void)
->	O
x	union(array(char),array(long),array(long))
,	O
ctx	*(void)
->	O
auth_size	long
,	O
ctx	*(void)
->	O
data_size	long
)	O
;	O
f	*((*(void),long,*(char),*(char))->(void))
(	O
cipher	*(void)
,	O
GCM_BLOCK_SIZE	int
,	O
buffer	*(union(array(char),array(long),array(long)))
,	O
ctx	*(void)
->	O
iv	union(array(char),array(long),array(long))
.	O
b	array(char)
)	O
;	O
memxor3	O
(	O
digest	*(char)
,	O
ctx	*(void)
->	O
x	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
buffer	*(union(array(char),array(long),array(long)))
,	O
length	long
)	O
;	O
return	O
;	O
}	O
