POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
EDMAPROC	O
edma_get_obj_pobj	(long)->(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
(	O
OBJID	long
IdObj	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"GetPObj"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
return	O
(	O
gObj	O
[	O
IdObj	long
]	O
)	O
;	O
}	O
OBJID	long
EDMAPROC	O
edma_get_obj_father_id	(long)->(long)
(	O
OBJID	long
IdObj	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_get_obj_father_id"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gObj	O
[	O
IdObj	long
]	O
->	O
Father	long
;	O
}	O
OBJID	long
EDMAPROC	O
edma_get_obj_pseudofather_id	(long)->(long)
(	O
OBJID	long
IdObj	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_get_obj_pseudofather_id"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gObj	O
[	O
IdObj	long
]	O
->	O
PseudiFather	long
;	O
}	O
EPChar	*(char)
EDMAPROC	O
edma_get_obj_class_name	(long,*(*(char)))->(*(char))
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
*	O
name	*(*(char))
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_get_obj_class_name"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
name	*(*(char))
==	O
NULL	O
)	O
||	O
(	O
*	O
name	*(*(char))
==	O
NULL	O
)	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_get_obj_class_name] Invalid target buffer "	*(char)
"(NULL)"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
*	O
name	*(*(char))
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
,	O
EDMA_CLASS_NAME_LEN	int
)	O
;	O
return	O
*	O
name	*(*(char))
;	O
}	O
CLASSID	long
EDMAPROC	O
edma_get_obj_class_id	(long)->(long)
(	O
OBJID	long
IdObj	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_get_obj_class_id"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_obj_status	(long)->(long)
(	O
OBJID	long
Id	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
Id	long
,	O
"edma_get_obj_status"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gObj	O
[	O
Id	long
]	O
->	O
Flag	char
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_num_objects	()->(long)
(	O
void	O
)	O
{	O
return	O
nObj	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_obj_num_superobjects	(long)->(long)
(	O
OBJID	long
Id	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
Id	long
,	O
"edma_get_obj_num_superobjects"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gObj	O
[	O
Id	long
]	O
->	O
nUpTable	long
;	O
}	O
OBJID	long
EDMAPROC	O
edma_get_obj_superobject	(long,long)->(long)
(	O
OBJID	long
Id	long
,	O
ESint32	long
i	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
Id	long
,	O
"edma_get_obj_superobject"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
i	long
<	O
0	int
)	O
&&	O
(	O
i	long
>	O
gObj	O
[	O
Id	long
]	O
->	O
nUpTable	long
)	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[GetObjSC] Invalid superobject index: "	*(char)
"%d of %d in object %d"	*(char)
,	O
i	long
,	O
gObj	O
[	O
Id	long
]	O
->	O
nUpTable	long
,	O
Id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
(	O
gObj	O
[	O
Id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
)	O
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_obj_superobject_ap	(long,long,*(char))->(long)
(	O
OBJID	long
Id	long
,	O
ESint32	long
i	long
,	O
EPChar	*(char)
ap	*(char)
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
Id	long
,	O
"edma_get_obj_superobject"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ap	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_get_obj_superobject_ap] Invalid "	*(char)
"Anchor Point (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
i	long
<	O
0	int
)	O
&&	O
(	O
i	long
>	O
gObj	O
[	O
Id	long
]	O
->	O
nUpTable	long
)	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[GetObjSC] Invalid superobject index: "	*(char)
"%d of %d in object %d"	*(char)
,	O
i	long
,	O
gObj	O
[	O
Id	long
]	O
->	O
nUpTable	long
,	O
Id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
ap	*(char)
,	O
gObj	O
[	O
Id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	long
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_obj_num_subobjects	(long)->(long)
(	O
OBJID	long
Id	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
Id	long
,	O
"edma_get_obj_num_subobjects"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gObj	O
[	O
Id	long
]	O
->	O
nDownTable	long
;	O
}	O
OBJID	long
EDMAPROC	O
edma_get_obj_subobject	(long,long)->(long)
(	O
OBJID	long
Id	long
,	O
ESint32	long
i	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
Id	long
,	O
"edma_get_obj_subobject"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
i	long
<	O
0	int
)	O
&&	O
(	O
i	long
>	O
gObj	O
[	O
Id	long
]	O
->	O
nDownTable	long
)	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[GetObjSC] Invalid superobject index: "	*(char)
"%d of %d in object %d"	*(char)
,	O
i	long
,	O
gObj	O
[	O
Id	long
]	O
->	O
nDownTable	long
,	O
Id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
(	O
gObj	O
[	O
Id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
)	O
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_obj_subobject_ap	(long,long,*(char))->(long)
(	O
OBJID	long
Id	long
,	O
ESint32	long
i	long
,	O
EPChar	*(char)
ap	*(char)
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
Id	long
,	O
"edma_get_obj_subobject"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ap	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_get_obj_subobject_ap] Invalid "	*(char)
"Anchor Point (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
i	long
<	O
0	int
)	O
&&	O
(	O
i	long
>	O
gObj	O
[	O
Id	long
]	O
->	O
nDownTable	long
)	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[GetObjSC] Invalid superobject index: "	*(char)
"%d of %d in object %d"	*(char)
,	O
i	long
,	O
gObj	O
[	O
Id	long
]	O
->	O
nDownTable	long
,	O
Id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
ap	*(char)
,	O
gObj	O
[	O
Id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	long
)	O
;	O
return	O
0	int
;	O
}	O
OBJID	long
EDMAPROC	O
edma_get_obj_app	(long)->(long)
(	O
OBJID	long
Id	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
Id	long
,	O
"edma_get_obj_app"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gObj	O
[	O
Id	long
]	O
->	O
IdApp	long
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_app_id	()->(long)
(	O
void	O
)	O
{	O
return	O
AppId	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_obj_report	(long)->(long)
(	O
OBJID	long
IdObj	long
)	O
{	O
EUint32	long
i	long
;	O
OBJID	long
Padre	long
,	O
siu_obj	long
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_obj_report"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
edma_printf	(*(char))->(long)
(	O
"==OBJECT REPORT=============================================="	*(char)
)	O
;	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
==	O
NULL	O
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"Object is free"	*(char)
)	O
;	O
edma_printf	(*(char))->(long)
(	O
"==END OBJECT REPORT======================================"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
Flag	char
==	O
VIRTUAL_OBJECT	int
)	O
edma_printf	(*(char))->(long)
(	O
"Object is virtual"	*(char)
)	O
;	O
edma_printf	(*(char))->(long)
(	O
"Object (%d) of class (%s)"	*(char)
,	O
IdObj	long
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
Padre	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
Father	long
;	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdSIU	long
!=	O
-	O
1	int
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"Object is a SIU Proxy object (%s)"	*(char)
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdSIU	long
]	O
->	O
ClassName	array(char)
)	O
;	O
edma_rprop3	()->(int)
(	O
IdObj	long
,	O
"obj"	*(char)
,	O
&	O
siu_obj	long
)	O
;	O
if	O
(	O
siu_obj	long
!=	O
-	O
1	int
)	O
edma_printf	(*(char))->(long)
(	O
"   Representing object %d (%s)"	*(char)
,	O
siu_obj	long
,	O
gClass	O
[	O
gObj	O
[	O
siu_obj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
}	O
if	O
(	O
Padre	long
==	O
-	O
1	int
)	O
edma_printf	(*(char))->(long)
(	O
"Top Level Object. Object haven't father"	*(char)
)	O
;	O
else	O
edma_printf	(*(char))->(long)
(	O
"Object Father (%d) of class (%s)"	*(char)
,	O
Padre	long
,	O
gClass	O
[	O
gObj	O
[	O
Padre	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
Padre	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
PseudiFather	long
;	O
if	O
(	O
Padre	long
==	O
-	O
1	int
)	O
edma_printf	(*(char))->(long)
(	O
"No PseudoFather information"	*(char)
)	O
;	O
else	O
edma_printf	(*(char))->(long)
(	O
"Object PseudoFather (%d) of class (%s)"	*(char)
,	O
Padre	long
,	O
gClass	O
[	O
gObj	O
[	O
Padre	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
edma_printf	(*(char))->(long)
(	O
"Object has %d superobjects"	*(char)
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
nUpTable	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gObj	O
[	O
IdObj	long
]	O
->	O
nUpTable	long
;	O
i	long
++	O
)	O
edma_printf	(*(char))->(long)
(	O
"    Id : (%s) Class : (%s) Class attached Object: (%s)"	*(char)
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	long
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
IdClass	long
]	O
->	O
ClassName	array(char)
,	O
gClass	O
[	O
gObj	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
edma_printf	(*(char))->(long)
(	O
"Object has %d subobjects"	*(char)
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
nDownTable	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gObj	O
[	O
IdObj	long
]	O
->	O
nDownTable	long
;	O
i	long
++	O
)	O
edma_printf	(*(char))->(long)
(	O
"    Id : (%s) Class : (%s) Class attached Object: (%s)"	*(char)
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	long
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
IdClass	long
]	O
->	O
ClassName	array(char)
,	O
gClass	O
[	O
gObj	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
edma_printf	(*(char))->(long)
(	O
"Virtual Methods in object"	*(char)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
nMetVir	long
;	O
i	long
++	O
)	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Flag	char
)	O
{	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Flag	char
==	O
1	int
)	O
edma_printf	(*(char))->(long)
(	O
"    Object [%03d] of Class [%s] overrides "	*(char)
"Method [%s] with Method [%s]"	*(char)
,	O
(	O
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
gObj	O
[	O
IdObj	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Obj	long
)	O
->	O
IdObj	long
,	O
gClass	O
[	O
(	O
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
gObj	O
[	O
IdObj	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Obj	long
)	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Ind	long
]	O
.	O
IdMet	array(char)
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Id	long
)	O
;	O
else	O
edma_printf	(*(char))->(long)
(	O
"    Main Application overrides Method [%s]"	*(char)
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Id	long
)	O
;	O
}	O
else	O
edma_printf	(*(char))->(long)
(	O
"    Nobody overrides Method [%s]"	*(char)
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Id	long
)	O
;	O
edma_printf	(*(char))->(long)
(	O
"==END OBJECT REPORT=========================================="	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_show_subobjects_up	(long,*(char),long)->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id	long
,	O
ESint32	long
level	long
)	O
{	O
ESint32	long
i	long
;	O
EChar	char
sep	array(char)
[	O
40	int
]	O
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_show_subobjects_up"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
Id	long
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_show_subobjects_up] Invalid "	*(char)
"Root Identifier (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
memset	(*(void),int,int)->(*(void))
(	O
sep	array(char)
,	O
0	int
,	O
40	int
)	O
;	O
memset	(*(void),int,int)->(*(void))
(	O
sep	array(char)
,	O
' '	O
,	O
2	int
*	O
level	long
)	O
;	O
edma_printf	(*(char))->(long)
(	O
"%s%s ==> %s [%d]"	*(char)
,	O
sep	array(char)
,	O
Id	long
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
,	O
IdObj	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gObj	O
[	O
IdObj	long
]	O
->	O
nUpTable	long
;	O
i	long
++	O
)	O
{	O
edma_show_subobjects_up	(long,*(char),long)->(long)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	long
,	O
level	long
+	O
1	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_show_subobjects_down	(long,*(char),long)->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id	long
,	O
ESint32	long
level	long
)	O
{	O
ESint32	long
i	long
;	O
EChar	char
sep	array(char)
[	O
40	int
]	O
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_show_subobjects_down"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
Id	long
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_show_subobjects_up] Invalid "	*(char)
"Root Identifier (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
memset	(*(void),int,int)->(*(void))
(	O
sep	array(char)
,	O
0	int
,	O
40	int
)	O
;	O
memset	(*(void),int,int)->(*(void))
(	O
sep	array(char)
,	O
' '	O
,	O
2	int
*	O
level	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gObj	O
[	O
IdObj	long
]	O
->	O
nDownTable	long
;	O
i	long
++	O
)	O
{	O
edma_show_subobjects_down	(long,*(char),long)->(long)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	long
,	O
level	long
+	O
1	int
)	O
;	O
}	O
edma_printf	(*(char))->(long)
(	O
"%s%s ==> %s [%d]"	*(char)
,	O
sep	array(char)
,	O
Id	long
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
,	O
IdObj	long
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_show_object_interface	(long)->(long)
(	O
OBJID	long
IdObj	long
)	O
{	O
ESint32	long
i	long
,	O
n	long
;	O
CLASSID	long
idc	long
;	O
EChar	char
modifiers	array(char)
[	O
80	int
]	O
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_show_subobjects_down"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
idc	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
;	O
n	long
=	O
gClass	O
[	O
idc	long
]	O
->	O
nProp	short
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
edma_printf	(*(char))->(long)
(	O
"%s \t\t %s::%s"	*(char)
,	O
tipo	array(struct(array(char),long,long,array(char)))
[	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
idc	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
i	long
]	O
.	O
Tipo	long
]	O
.	O
Id	long
,	O
gClass	O
[	O
idc	long
]	O
->	O
ClassName	array(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
idc	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
i	long
]	O
.	O
IdProp	array(char)
)	O
;	O
n	long
=	O
gClass	O
[	O
idc	long
]	O
->	O
nMet	short
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
memset	(*(void),int,int)->(*(void))
(	O
modifiers	array(char)
,	O
0	int
,	O
80	int
)	O
;	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
idc	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
Virtual	char
)	O
strcat	(*(char),*(char))->(*(char))
(	O
modifiers	array(char)
,	O
"virtual "	*(char)
)	O
;	O
else	O
strcat	(*(char),*(char))->(*(char))
(	O
modifiers	array(char)
,	O
"\t"	*(char)
)	O
;	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
idc	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
Abstract	char
)	O
strcat	(*(char),*(char))->(*(char))
(	O
modifiers	array(char)
,	O
"abstract "	*(char)
)	O
;	O
else	O
strcat	(*(char),*(char))->(*(char))
(	O
modifiers	array(char)
,	O
"\t"	*(char)
)	O
;	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
idc	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
Static	char
)	O
strcat	(*(char),*(char))->(*(char))
(	O
modifiers	array(char)
,	O
"static "	*(char)
)	O
;	O
else	O
strcat	(*(char),*(char))->(*(char))
(	O
modifiers	array(char)
,	O
"\t"	*(char)
)	O
;	O
edma_printf	(*(char))->(long)
(	O
"%s %s::%s (%s)"	*(char)
,	O
modifiers	array(char)
,	O
gClass	O
[	O
idc	long
]	O
->	O
ClassName	array(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
idc	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
IdMet	array(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
idc	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
Sign	array(char)
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gObj	O
[	O
IdObj	long
]	O
->	O
nUpTable	long
;	O
i	long
++	O
)	O
{	O
edma_show_object_interface	(long)->(long)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
)	O
;	O
}	O
return	O
0	int
;	O
}	O
