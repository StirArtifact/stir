static	O
void	O
add_menu_to_node	(*(char),long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(void)
(	O
char	O
*	O
contents	*(char)
,	O
size_t	long
size	long
,	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
;	O
static	O
void	O
insert_text_into_node	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),long,*(char),int)->(void)
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
long	O
start	int
,	O
char	O
*	O
text	*(char)
,	O
int	O
textlen	int
)	O
;	O
static	O
char	O
*	O
dirs_to_add	array(*(char))
[	O
]	O
=	O
{	O
"dir"	*(char)
,	O
"localdir"	*(char)
,	O
NULL	O
}	O
;	O
static	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
dir_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
0	int
;	O
static	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
build_dir_node	()->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
void	O
)	O
;	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
get_dir_node	()->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
void	O
)	O
{	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
if	O
(	O
!	O
dir_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
dir_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
build_dir_node	()->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
)	O
)	O
;	O
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
*	O
dir_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
return	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
}	O
static	O
char	O
*	O
dir_contents	*(char)
;	O
static	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
build_dir_node	()->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
void	O
)	O
{	O
int	O
path_index	int
;	O
char	O
*	O
this_dir	*(char)
;	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
info_create_node	()->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"Top"	*(char)
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"dir"	*(char)
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"File: dir,	Node: Top,	This is the top of the INFO tree.\n"	*(char)
"\n"	*(char)
"This is the Info main menu (aka directory node).\n"	*(char)
"A few useful Info commands:\n"	*(char)
"\n"	*(char)
"  'q' quits;\n"	*(char)
"  'H' lists all Info commands;\n"	*(char)
"  'h' starts the Info tutorial;\n"	*(char)
"  'mTexinfo RET' visits the Texinfo manual, etc.\n"	*(char)
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
=	O
strlen	(*(char))->(long)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
)	O
;	O
for	O
(	O
this_dir	*(char)
=	O
infopath_first	(*(int))->(*(char))
(	O
&	O
path_index	int
)	O
;	O
this_dir	*(char)
;	O
this_dir	*(char)
=	O
infopath_next	(*(int))->(*(char))
(	O
&	O
path_index	int
)	O
)	O
{	O
register	O
int	O
da_index	int
;	O
char	O
*	O
from_file	*(char)
;	O
if	O
(	O
*	O
this_dir	*(char)
==	O
'~'	O
)	O
{	O
char	O
*	O
tilde_expanded_dirname	*(char)
;	O
tilde_expanded_dirname	*(char)
=	O
tilde_expand_word	(*(char))->(*(char))
(	O
this_dir	*(char)
)	O
;	O
if	O
(	O
tilde_expanded_dirname	*(char)
!=	O
this_dir	*(char)
)	O
{	O
this_dir	*(char)
=	O
tilde_expanded_dirname	*(char)
;	O
}	O
}	O
for	O
(	O
da_index	int
=	O
0	int
;	O
(	O
from_file	*(char)
=	O
dirs_to_add	array(*(char))
[	O
da_index	int
]	O
)	O
;	O
da_index	int
++	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
statable	int
;	O
int	O
namelen	int
=	O
strlen	(*(char))->(long)
(	O
from_file	*(char)
)	O
;	O
char	O
*	O
fullpath	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
3	int
+	O
strlen	(*(char))->(long)
(	O
this_dir	*(char)
)	O
+	O
namelen	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
fullpath	*(char)
,	O
this_dir	*(char)
)	O
;	O
if	O
(	O
!	O
IS_SLASH	O
(	O
fullpath	*(char)
[	O
strlen	(*(char))->(long)
(	O
fullpath	*(char)
)	O
-	O
1	int
]	O
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
fullpath	*(char)
,	O
"/"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
fullpath	*(char)
,	O
from_file	*(char)
)	O
;	O
statable	int
=	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
fullpath	*(char)
,	O
&	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
)	O
;	O
if	O
(	O
statable	int
&&	O
S_ISREG	O
(	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
size_t	long
filesize	long
;	O
int	O
compressed	int
;	O
char	O
*	O
contents	*(char)
=	O
filesys_read_info_file	(*(char),*(long),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(int))->(*(char))
(	O
fullpath	*(char)
,	O
&	O
filesize	long
,	O
&	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
&	O
compressed	int
)	O
;	O
if	O
(	O
contents	*(char)
)	O
{	O
add_menu_to_node	(*(char),long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(void)
(	O
contents	*(char)
,	O
filesize	long
,	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
;	O
free	(*(void))->(void)
(	O
contents	*(char)
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
fullpath	*(char)
)	O
;	O
}	O
}	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
flags	int
|=	O
N_IsDir	int
;	O
dir_contents	*(char)
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
;	O
scan_node_contents	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))))->(void)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
0	int
,	O
0	int
)	O
;	O
return	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
}	O
static	O
void	O
add_menu_to_node	(*(char),long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(void)
(	O
char	O
*	O
contents	*(char)
,	O
size_t	long
size	long
,	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
{	O
SEARCH_BINDING	struct(*(char),long,long,int)
contents_binding	struct(*(char),long,long,int)
,	O
fb_binding	struct(*(char),long,long,int)
;	O
long	O
contents_offset	long
,	O
fb_offset	long
;	O
contents_binding	struct(*(char),long,long,int)
.	O
buffer	*(struct)
=	O
contents	*(char)
;	O
contents_binding	struct(*(char),long,long,int)
.	O
start	int
=	O
0	int
;	O
contents_binding	struct(*(char),long,long,int)
.	O
end	int
=	O
size	long
;	O
contents_binding	struct(*(char),long,long,int)
.	O
flags	int
=	O
S_FoldCase	int
|	O
S_SkipDest	int
;	O
fb_binding	struct(*(char),long,long,int)
.	O
buffer	*(struct)
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
;	O
fb_binding	struct(*(char),long,long,int)
.	O
start	int
=	O
0	int
;	O
fb_binding	struct(*(char),long,long,int)
.	O
end	int
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
;	O
fb_binding	struct(*(char),long,long,int)
.	O
flags	int
=	O
S_FoldCase	int
|	O
S_SkipDest	int
;	O
if	O
(	O
search_forward	(*(char),*(struct(*(char),long,long,int)),*(long))->(enum(int,int,int))
(	O
INFO_MENU_LABEL	*(char)
,	O
&	O
contents_binding	struct(*(char),long,long,int)
,	O
&	O
contents_offset	long
)	O
!=	O
search_success	int
)	O
return	O
;	O
contents_offset	long
+=	O
skip_whitespace_and_newlines	(*(char))->(int)
(	O
contents	*(char)
+	O
contents_offset	long
)	O
;	O
if	O
(	O
search_forward	(*(char),*(struct(*(char),long,long,int)),*(long))->(enum(int,int,int))
(	O
INFO_MENU_LABEL	*(char)
,	O
&	O
fb_binding	struct(*(char),long,long,int)
,	O
&	O
fb_offset	long
)	O
!=	O
search_success	int
)	O
{	O
fb_binding	struct(*(char),long,long,int)
.	O
start	int
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
;	O
insert_text_into_node	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),long,*(char),int)->(void)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
fb_binding	struct(*(char),long,long,int)
.	O
start	int
,	O
INFO_MENU_LABEL	*(char)
,	O
strlen	(*(char))->(long)
(	O
INFO_MENU_LABEL	*(char)
)	O
)	O
;	O
fb_binding	struct(*(char),long,long,int)
.	O
buffer	*(struct)
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
;	O
fb_binding	struct(*(char),long,long,int)
.	O
start	int
=	O
0	int
;	O
fb_binding	struct(*(char),long,long,int)
.	O
end	int
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
;	O
if	O
(	O
search_forward	(*(char),*(struct(*(char),long,long,int)),*(long))->(enum(int,int,int))
(	O
INFO_MENU_LABEL	*(char)
,	O
&	O
fb_binding	struct(*(char),long,long,int)
,	O
&	O
fb_offset	long
)	O
!=	O
search_success	int
)	O
abort	()->(void)
(	O
)	O
;	O
}	O
fb_binding	struct(*(char),long,long,int)
.	O
start	int
=	O
fb_offset	long
;	O
fb_offset	long
=	O
find_node_separator	(*(struct(*(char),long,long,int)))->(long)
(	O
&	O
fb_binding	struct(*(char),long,long,int)
)	O
;	O
if	O
(	O
fb_offset	long
!=	O
-	O
1	int
)	O
fb_binding	struct(*(char),long,long,int)
.	O
start	int
=	O
fb_offset	long
;	O
else	O
fb_binding	struct(*(char),long,long,int)
.	O
start	int
=	O
fb_binding	struct(*(char),long,long,int)
.	O
end	int
;	O
{	O
int	O
num_found	int
=	O
0	int
;	O
while	O
(	O
(	O
fb_binding	struct(*(char),long,long,int)
.	O
start	int
>	O
0	int
)	O
&&	O
(	O
whitespace_or_newline	O
(	O
fb_binding	struct(*(char),long,long,int)
.	O
buffer	*(struct)
[	O
fb_binding	struct(*(char),long,long,int)
.	O
start	int
-	O
1	int
]	O
)	O
)	O
)	O
{	O
num_found	int
++	O
;	O
fb_binding	struct(*(char),long,long,int)
.	O
start	int
--	O
;	O
}	O
if	O
(	O
num_found	int
>=	O
2	int
)	O
{	O
fb_binding	struct(*(char),long,long,int)
.	O
buffer	*(struct)
[	O
fb_binding	struct(*(char),long,long,int)
.	O
start	int
++	O
]	O
=	O
'\n'	O
;	O
fb_binding	struct(*(char),long,long,int)
.	O
buffer	*(struct)
[	O
fb_binding	struct(*(char),long,long,int)
.	O
start	int
++	O
]	O
=	O
'\n'	O
;	O
}	O
else	O
{	O
insert_text_into_node	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),long,*(char),int)->(void)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
fb_binding	struct(*(char),long,long,int)
.	O
start	int
,	O
"\n\n"	*(char)
,	O
2	int
)	O
;	O
fb_binding	struct(*(char),long,long,int)
.	O
start	int
+=	O
2	int
;	O
}	O
}	O
insert_text_into_node	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),long,*(char),int)->(void)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
fb_binding	struct(*(char),long,long,int)
.	O
start	int
,	O
contents	*(char)
+	O
contents_offset	long
,	O
size	long
-	O
contents_offset	long
)	O
;	O
}	O
static	O
void	O
insert_text_into_node	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),long,*(char),int)->(void)
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
long	O
start	int
,	O
char	O
*	O
text	*(char)
,	O
int	O
textlen	int
)	O
{	O
char	O
*	O
contents	*(char)
;	O
long	O
end	int
;	O
end	int
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
;	O
contents	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
+	O
textlen	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
contents	*(char)
,	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
,	O
start	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
contents	*(char)
+	O
start	int
,	O
text	*(char)
,	O
textlen	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
contents	*(char)
+	O
start	int
+	O
textlen	int
,	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
+	O
start	int
,	O
end	int
-	O
start	int
+	O
1	int
)	O
;	O
free	(*(void))->(void)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
=	O
contents	*(char)
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
+=	O
textlen	int
;	O
}	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
lookup_dir_entry	(*(char),int)->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
char	O
*	O
label	*(char)
,	O
int	O
sloppy	int
)	O
{	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
if	O
(	O
!	O
dir_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
dir_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
build_dir_node	()->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
info_get_menu_entry_by_label	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),*(char),int)->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
dir_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
label	*(char)
,	O
sloppy	int
)	O
;	O
return	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
}	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
dir_entry_of_infodir	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
char	O
*	O
label	*(char)
,	O
char	O
*	O
searchdir	*(char)
)	O
{	O
int	O
da_index	int
;	O
char	O
*	O
dir_filename	*(char)
;	O
char	O
*	O
dir_fullpath	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
dummy	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
char	O
*	O
entry_fullpath	*(char)
;	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
dir_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
for	O
(	O
da_index	int
=	O
0	int
;	O
(	O
dir_filename	*(char)
=	O
dirs_to_add	array(*(char))
[	O
da_index	int
]	O
)	O
;	O
da_index	int
++	O
)	O
{	O
dir_fullpath	*(char)
=	O
info_add_extension	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
searchdir	*(char)
,	O
dir_filename	*(char)
,	O
&	O
dummy	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
!	O
dir_fullpath	*(char)
)	O
continue	O
;	O
if	O
(	O
!	O
IS_ABSOLUTE	O
(	O
dir_fullpath	*(char)
)	O
)	O
{	O
char	O
*	O
tmp	*(char)
;	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
tmp	*(char)
,	O
"./%s"	*(char)
,	O
dir_fullpath	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
dir_fullpath	*(char)
)	O
;	O
dir_fullpath	*(char)
=	O
tmp	*(char)
;	O
}	O
dir_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
info_get_node	(*(char),*(char))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
dir_fullpath	*(char)
,	O
"Top"	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
dir_fullpath	*(char)
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
info_get_menu_entry_by_label	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),*(char),int)->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
dir_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
label	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
!	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
||	O
!	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
)	O
{	O
free_history_node	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(void)
(	O
dir_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
;	O
continue	O
;	O
}	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
info_copy_reference	(*(struct(*(char),*(char),*(char),int,int,long,int)))->(*(struct(*(char),*(char),*(char),int,int,long,int)))
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
)	O
;	O
entry_fullpath	*(char)
=	O
info_add_extension	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
searchdir	*(char)
,	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
,	O
&	O
dummy	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
entry_fullpath	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
=	O
entry_fullpath	*(char)
;	O
}	O
free_history_node	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(void)
(	O
dir_node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
;	O
return	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
}	O
return	O
0	int
;	O
}	O
