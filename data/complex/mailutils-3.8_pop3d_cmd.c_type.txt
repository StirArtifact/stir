struct	O
mu_tls_config	struct(*(char),*(char),*(char),*(char))
global_tls_conf	struct(*(char),*(char),*(char),*(char))
;	O
int	O
global_tls_mode	int
;	O
int	O
global_conf_status	int
=	O
-	O
1	int
;	O
static	O
struct	O
pop3d_command	struct(*(char),*((*(char),*(struct(*(struct`),enum(int,int,int,int,int),*(struct`))))->(int)))
command_table	array(struct(*(char),*((*(char),*(struct(*`,enum(int,int,int,int,int),*`)))->(int))))
[	O
]	O
=	O
{	O
{	O
"STLS"	*(char)
,	O
pop3d_stls	(*(char),*(struct(*(struct),enum(int,int,int,int,int),*(struct(*`,*`,*`,*`)))))->(int)
}	O
,	O
{	O
"RETR"	*(char)
,	O
pop3d_retr	(*(char),*(struct(*(struct),enum(int,int,int,int,int),*(struct(*`,*`,*`,*`)))))->(int)
}	O
,	O
{	O
"DELE"	*(char)
,	O
pop3d_dele	(*(char),*(struct(*(struct),enum(int,int,int,int,int),*(struct(*`,*`,*`,*`)))))->(int)
}	O
,	O
{	O
"USER"	*(char)
,	O
pop3d_user	(*(char),*(struct(*(struct),enum(int,int,int,int,int),*(struct(*`,*`,*`,*`)))))->(int)
}	O
,	O
{	O
"QUIT"	*(char)
,	O
pop3d_quit	(*(char),*(struct(*(struct),enum(int,int,int,int,int),*(struct(*`,*`,*`,*`)))))->(int)
}	O
,	O
{	O
"APOP"	*(char)
,	O
pop3d_apop	(*(char),*(struct(*(struct),enum(int,int,int,int,int),*(struct(*`,*`,*`,*`)))))->(int)
}	O
,	O
{	O
"AUTH"	*(char)
,	O
pop3d_auth	(*(char),*(struct(*(struct),enum(int,int,int,int,int),*(struct(*`,*`,*`,*`)))))->(int)
}	O
,	O
{	O
"STAT"	*(char)
,	O
pop3d_stat	(*(char),*(struct(*(struct),enum(int,int,int,int,int),*(struct(*`,*`,*`,*`)))))->(int)
}	O
,	O
{	O
"LIST"	*(char)
,	O
pop3d_list	(*(char),*(struct(*(struct),enum(int,int,int,int,int),*(struct(*`,*`,*`,*`)))))->(int)
}	O
,	O
{	O
"NOOP"	*(char)
,	O
pop3d_noop	(*(char),*(struct(*(struct),enum(int,int,int,int,int),*(struct(*`,*`,*`,*`)))))->(int)
}	O
,	O
{	O
"RSET"	*(char)
,	O
pop3d_rset	(*(char),*(struct(*(struct),enum(int,int,int,int,int),*(struct(*`,*`,*`,*`)))))->(int)
}	O
,	O
{	O
"TOP"	*(char)
,	O
pop3d_top	(*(char),*(struct(*(struct),enum(int,int,int,int,int),*(struct(*`,*`,*`,*`)))))->(int)
}	O
,	O
{	O
"UIDL"	*(char)
,	O
pop3d_uidl	(*(char),*(struct(*(struct),enum(int,int,int,int,int),*(struct(*`,*`,*`,*`)))))->(int)
}	O
,	O
{	O
"CAPA"	*(char)
,	O
pop3d_capa	struct(enum(int,int),*(char),union(*(char),*((*(char),*(struct))->(void))))
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
pop3d_command_handler_t	*((*(char),*(struct(*(struct`),enum(int,int,int,int,int),*(struct`))))->(int))
pop3d_find_command	(*(char))->(*((*(char),*(struct(*`,enum(int,int,int,int,int),*`)))->(int)))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
pop3d_command	struct(*(char),*((*(char),*(struct(*(struct`),enum(int,int,int,int,int),*(struct`))))->(int)))
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
command_table	array(struct(*(char),*((*(char),*(struct(*`,enum(int,int,int,int,int),*`)))->(int))))
;	O
p	*(char)
->	O
name	*(char)
;	O
p	*(char)
++	O
)	O
{	O
if	O
(	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
p	*(char)
->	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
p	*(char)
->	O
handler	*((int)->(void))
;	O
}	O
return	O
p	*(char)
->	O
handler	*((int)->(void))
;	O
}	O
int	O
stls_server_check	(*(struct(struct(*(struct`),*(struct`),*(struct`),int,int,long),enum(int,int,int,int,int),struct(*(char),*(char),*(char),*(char)))),*(char))->(int)
(	O
struct	O
pop3d_srv_config	struct(struct(*(struct),*(struct),*(struct),int,int,long),enum(int,int,int,int,int),struct(*(char),*(char),*(char),*(char)))
*	O
cfg	*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char)))
,	O
char	O
const	O
*	O
srvid	*(char)
)	O
{	O
int	O
result	int
;	O
switch	O
(	O
cfg	*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char)))
->	O
tls_mode	enum(int,int,int,int,int)
)	O
{	O
case	O
tls_unspecified	int
:	O
if	O
(	O
global_tls_mode	int
!=	O
tls_unspecified	int
)	O
cfg	*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char)))
->	O
tls_mode	enum(int,int,int,int,int)
=	O
global_tls_mode	int
;	O
else	O
if	O
(	O
cfg	*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char)))
->	O
tls_conf	*(struct(*(char),*(char),*(char),*(char)))
.	O
cert_file	*(char)
)	O
cfg	*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char)))
->	O
tls_mode	enum(int,int,int,int,int)
=	O
tls_ondemand	int
;	O
else	O
{	O
cfg	*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char)))
->	O
tls_mode	enum(int,int,int,int,int)
=	O
tls_no	int
;	O
return	O
MU_TLS_CONFIG_NULL	int
;	O
}	O
break	O
;	O
case	O
tls_no	int
:	O
return	O
MU_TLS_CONFIG_NULL	int
;	O
default	O
:	O
break	O
;	O
}	O
result	int
=	O
mu_tls_config_check	(*(struct(*(char),*(char),*(char),*(char))),int)->(int)
(	O
&	O
cfg	*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char)))
->	O
tls_conf	*(struct(*(char),*(char),*(char),*(char)))
,	O
1	int
)	O
;	O
switch	O
(	O
result	int
)	O
{	O
case	O
MU_TLS_CONFIG_OK	int
:	O
if	O
(	O
!	O
cfg	*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char)))
->	O
tls_conf	*(struct(*(char),*(char),*(char),*(char)))
.	O
cert_file	*(char)
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"server %s: no certificate set"	*(char)
)	O
,	O
srvid	*(char)
)	O
;	O
result	int
=	O
MU_TLS_CONFIG_FAIL	int
;	O
}	O
break	O
;	O
case	O
MU_TLS_CONFIG_NULL	int
:	O
if	O
(	O
global_conf_status	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
global_tls_conf	struct(*(char),*(char),*(char),*(char))
.	O
cert_file	*(char)
)	O
global_conf_status	int
=	O
mu_tls_config_check	(*(struct(*(char),*(char),*(char),*(char))),int)->(int)
(	O
&	O
global_tls_conf	struct(*(char),*(char),*(char),*(char))
,	O
1	int
)	O
;	O
else	O
global_conf_status	int
=	O
MU_TLS_CONFIG_NULL	int
;	O
}	O
if	O
(	O
global_conf_status	int
!=	O
MU_TLS_CONFIG_NULL	int
)	O
{	O
cfg	*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char)))
->	O
tls_conf	*(struct(*(char),*(char),*(char),*(char)))
=	O
global_tls_conf	struct(*(char),*(char),*(char),*(char))
;	O
result	int
=	O
MU_TLS_CONFIG_OK	int
;	O
}	O
else	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"server %s: no certificate set"	*(char)
)	O
,	O
srvid	*(char)
)	O
;	O
result	int
=	O
MU_TLS_CONFIG_FAIL	int
;	O
}	O
break	O
;	O
default	O
:	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"server %s: TLS configuration failed"	*(char)
)	O
,	O
srvid	*(char)
)	O
;	O
}	O
return	O
result	int
;	O
}	O
int	O
stls_preflight	(*(struct))->(int)
(	O
mu_m_server_t	*(struct)
msrv	*(struct)
)	O
{	O
mu_list_t	*(struct)
srvlist	*(struct)
;	O
mu_iterator_t	*(struct)
itr	*(*(struct))
;	O
int	O
errors	int
=	O
0	int
;	O
int	O
tls_ok	int
=	O
mu_init_tls_libs	()->(int)
(	O
)	O
;	O
int	O
tls_requested	int
=	O
0	int
;	O
mu_m_server_get_srvlist	(*(struct),*(*(struct)))->(int)
(	O
msrv	*(struct)
,	O
&	O
srvlist	*(struct)
)	O
;	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
srvlist	*(struct)
,	O
&	O
itr	*(*(struct))
)	O
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(*(struct))
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(*(struct))
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(*(struct))
)	O
)	O
{	O
mu_ip_server_t	*(struct)
ipsrv	*(struct)
;	O
struct	O
pop3d_srv_config	struct(struct(*(struct),*(struct),*(struct),int,int,long),enum(int,int,int,int,int),struct(*(char),*(char),*(char),*(char)))
*	O
cfg	*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char)))
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(*(struct))
,	O
(	O
void	O
*	O
*	O
)	O
&	O
ipsrv	*(struct)
)	O
;	O
cfg	*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char)))
=	O
mu_ip_server_get_data	(*(struct))->(*(void))
(	O
ipsrv	*(struct)
)	O
;	O
switch	O
(	O
stls_server_check	(*(struct(struct(*(struct`),*(struct`),*(struct`),int,int,long),enum(int,int,int,int,int),struct(*(char),*(char),*(char),*(char)))),*(char))->(int)
(	O
cfg	*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char)))
,	O
mu_ip_server_addrstr	(*(struct))->(*(char))
(	O
ipsrv	*(struct)
)	O
)	O
)	O
{	O
case	O
MU_TLS_CONFIG_NULL	int
:	O
continue	O
;	O
case	O
MU_TLS_CONFIG_OK	int
:	O
break	O
;	O
default	O
:	O
errors	int
=	O
1	int
;	O
}	O
tls_requested	int
=	O
1	int
;	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(*(struct))
)	O
;	O
if	O
(	O
global_tls_mode	int
==	O
tls_unspecified	int
)	O
global_tls_mode	int
=	O
tls_no	int
;	O
if	O
(	O
tls_requested	int
&&	O
!	O
tls_ok	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"TLS is not configured, but requested in the "	*(char)
"configuration"	*(char)
)	O
)	O
;	O
errors	int
=	O
1	int
;	O
}	O
if	O
(	O
errors	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
error_table	array(*(char))
[	O
]	O
=	O
{	O
[	O
ERR_WRONG_STATE	int
]	O
=	O
"Incorrect state"	*(char)
,	O
[	O
ERR_BAD_ARGS	int
]	O
=	O
"Invalid arguments"	*(char)
,	O
[	O
ERR_BAD_LOGIN	int
]	O
=	O
"[AUTH] Bad login"	*(char)
,	O
[	O
ERR_NO_MESG	int
]	O
=	O
"No such message"	*(char)
,	O
[	O
ERR_MESG_DELE	int
]	O
=	O
"Message has been deleted"	*(char)
,	O
[	O
ERR_NOT_IMPL	int
]	O
=	O
"Not implemented"	*(char)
,	O
[	O
ERR_BAD_CMD	int
]	O
=	O
"Invalid command"	*(char)
,	O
[	O
ERR_MBOX_LOCK	int
]	O
=	O
"[IN-USE] Mailbox in use"	*(char)
,	O
[	O
ERR_TOO_LONG	int
]	O
=	O
"Argument too long"	*(char)
,	O
[	O
ERR_NO_MEM	int
]	O
=	O
"Out of memory] =quitting"	*(char)
,	O
[	O
ERR_SIGNAL	int
]	O
=	O
"Quitting on signal"	*(char)
,	O
[	O
ERR_FILE	int
]	O
=	O
"Some deleted messages not removed"	*(char)
,	O
[	O
ERR_NO_IFILE	int
]	O
=	O
"No input stream"	*(char)
,	O
[	O
ERR_NO_OFILE	int
]	O
=	O
"No output stream"	*(char)
,	O
[	O
ERR_IO	int
]	O
=	O
"I/O error"	*(char)
,	O
[	O
ERR_PROTO	int
]	O
=	O
"Remote protocol error"	*(char)
,	O
[	O
ERR_TIMEOUT	int
]	O
=	O
"Session timed out"	*(char)
,	O
[	O
ERR_UNKNOWN	int
]	O
=	O
"Unknown error"	*(char)
,	O
[	O
ERR_MBOX_SYNC	int
]	O
=	O
"Mailbox was updated by other process"	*(char)
,	O
[	O
ERR_TLS_IO	int
]	O
=	O
"TLS I/O error"	*(char)
,	O
[	O
ERR_LOGIN_DELAY	int
]	O
=	O
"[LOGIN-DELAY] Attempt to log in within the minimum login delay interval"	*(char)
,	O
[	O
ERR_TERMINATE	int
]	O
=	O
"Terminating on request"	*(char)
,	O
[	O
ERR_SYS_LOGIN	int
]	O
=	O
"[SYS/PERM] Cannot authenticate"	*(char)
,	O
}	O
;	O
const	O
char	O
*	O
pop3d_error_string	(int)->(*(char))
(	O
int	O
code	int
)	O
{	O
if	O
(	O
code	int
>=	O
0	int
&&	O
code	int
<	O
MU_ARRAY_SIZE	O
(	O
error_table	array(*(char))
)	O
&&	O
error_table	array(*(char))
[	O
code	int
]	O
)	O
return	O
error_table	array(*(char))
[	O
code	int
]	O
;	O
return	O
"unknown error"	*(char)
;	O
}	O
