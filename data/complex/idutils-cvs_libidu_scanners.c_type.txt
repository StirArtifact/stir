struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
lang_args_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
;	O
struct	O
lang_args	struct(*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))))))
*	O
lang_args_default	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
=	O
0	int
;	O
struct	O
lang_args	struct(*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))))))
*	O
lang_args_list	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
=	O
0	int
;	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
;	O
int	O
log_8_member_files	int
=	O
0	int
;	O
extern	O
void	O
usage	()->(void)
(	O
void	O
)	O
;	O
extern	O
char	O
*	O
program_name	*(char)
;	O
struct	O
lang_args	struct(*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))))))
*	O
*	O
parse_language_map_file	(*(char),*(*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))->(*(*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
(	O
char	O
const	O
*	O
file_name	*(char)
,	O
struct	O
lang_args	struct(*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))))))
*	O
*	O
next_ptr	*(*(struct(*(struct(*`,*`,*`,*`,int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*`,*`,*`,*`,int,*`)))))
)	O
;	O
char	O
*	O
read_language_map_file	(*(char))->(*(char))
(	O
char	O
const	O
*	O
file_name	*(char)
)	O
;	O
void	O
tokenize_args_string	(*(char),*(int),*(*(*(char))))->(void)
(	O
char	O
*	O
args_string	*(char)
,	O
int	O
*	O
argcp	*(int)
,	O
char	O
*	O
*	O
*	O
argvp	*(*(*(char)))
)	O
;	O
static	O
struct	O
token	struct(short,char,array(char))
*	O
get_token_c	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
(	O
FILE	struct
*	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
void	O
const	O
*	O
args	*(void)
,	O
int	O
*	O
flags	*(int)
)	O
;	O
static	O
void	O
*	O
parse_args_c	(*(*(char)),int)->(*(void))
(	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
argc	int
)	O
;	O
static	O
void	O
help_me_c	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
help_me_cpp	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
help_me_java	()->(void)
(	O
void	O
)	O
;	O
static	O
struct	O
token	struct(short,char,array(char))
*	O
get_token_asm	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
(	O
FILE	struct
*	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
void	O
const	O
*	O
args	*(void)
,	O
int	O
*	O
flags	*(int)
)	O
;	O
static	O
void	O
*	O
parse_args_asm	(*(*(char)),int)->(*(void))
(	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
argc	int
)	O
;	O
static	O
void	O
help_me_asm	()->(void)
(	O
void	O
)	O
;	O
static	O
struct	O
token	struct(short,char,array(char))
*	O
get_token_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
(	O
FILE	struct
*	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
void	O
const	O
*	O
args	*(void)
,	O
int	O
*	O
flags	*(int)
)	O
;	O
static	O
void	O
*	O
parse_args_text	(*(*(char)),int)->(*(void))
(	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
argc	int
)	O
;	O
static	O
void	O
help_me_text	()->(void)
(	O
void	O
)	O
;	O
static	O
struct	O
token	struct(short,char,array(char))
*	O
get_token_perl	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
(	O
FILE	struct
*	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
void	O
const	O
*	O
args	*(void)
,	O
int	O
*	O
flags	*(int)
)	O
;	O
static	O
void	O
*	O
parse_args_perl	(*(*(char)),int)->(*(void))
(	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
argc	int
)	O
;	O
static	O
void	O
help_me_perl	()->(void)
(	O
void	O
)	O
;	O
static	O
struct	O
token	struct(short,char,array(char))
*	O
get_token_lisp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
(	O
FILE	struct
*	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
void	O
const	O
*	O
args	*(void)
,	O
int	O
*	O
flags	*(int)
)	O
;	O
static	O
void	O
*	O
parse_args_lisp	(*(*(char)),int)->(*(void))
(	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
argc	int
)	O
;	O
static	O
void	O
help_me_lisp	()->(void)
(	O
void	O
)	O
;	O
struct	O
language	struct(*(char),*((*(*(char)),int)->(*(void))),*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))),*(()->(void)),int,array(*(char)))
languages_0	array(struct(*(char),*((*(*(char)),int)->(*(void))),*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))),*(()->(void)),int,array(*(char))))
[	O
]	O
=	O
{	O
{	O
"C"	*(char)
,	O
parse_args_c	(*(*(char)),int)->(*(void))
,	O
get_token_c	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
,	O
help_me_c	()->(void)
}	O
,	O
{	O
"C++"	*(char)
,	O
parse_args_c	(*(*(char)),int)->(*(void))
,	O
get_token_c	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
,	O
help_me_cpp	()->(void)
}	O
,	O
{	O
"Java"	*(char)
,	O
parse_args_c	(*(*(char)),int)->(*(void))
,	O
get_token_c	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
,	O
help_me_java	()->(void)
}	O
,	O
{	O
"asm"	*(char)
,	O
parse_args_asm	(*(*(char)),int)->(*(void))
,	O
get_token_asm	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
,	O
help_me_asm	()->(void)
}	O
,	O
{	O
"text"	*(char)
,	O
parse_args_text	(*(*(char)),int)->(*(void))
,	O
get_token_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
,	O
help_me_text	()->(void)
}	O
,	O
{	O
"perl"	*(char)
,	O
parse_args_perl	(*(*(char)),int)->(*(void))
,	O
get_token_perl	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
,	O
help_me_perl	()->(void)
}	O
,	O
{	O
"lisp"	*(char)
,	O
parse_args_lisp	(*(*(char)),int)->(*(void))
,	O
get_token_lisp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
,	O
help_me_lisp	()->(void)
}	O
}	O
;	O
struct	O
language	struct(*(char),*((*(*(char)),int)->(*(void))),*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))),*(()->(void)),int,array(*(char)))
const	O
*	O
languages_N	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
=	O
&	O
languages_0	array(struct(*(char),*((*(*(char)),int)->(*(void))),*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))),*(()->(void)),int,array(*(char))))
[	O
cardinalityof	O
(	O
languages_0	array(struct(*(char),*((*(*(char)),int)->(*(void))),*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))),*(()->(void)),int,array(*(char))))
)	O
]	O
;	O
void	O
language_help_me	()->(void)
(	O
void	O
)	O
{	O
struct	O
language	struct(*(char),*((*(*(char)),int)->(*(void))),*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))),*(()->(void)),int,array(*(char)))
*	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
;	O
for	O
(	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
=	O
languages_0	array(struct(*(char),*((*(*(char)),int)->(*(void))),*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))),*(()->(void)),int,array(*(char))))
;	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
<	O
languages_N	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
;	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
++	O
)	O
{	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
(	O
*	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
->	O
lg_help_me	*(()->(void))
)	O
(	O
)	O
;	O
}	O
}	O
void	O
language_save_arg	(*(char))->(void)
(	O
char	O
*	O
arg	*(char)
)	O
{	O
static	O
char	O
horizontal_space	array(char)
[	O
]	O
=	O
" \t"	*(char)
;	O
char	O
*	O
lang_name	*(char)
=	O
strsep	(*(*(char)),*(char))->(*(char))
(	O
&	O
arg	*(char)
,	O
":"	*(char)
)	O
;	O
struct	O
language	struct(*(char),*((*(*(char)),int)->(*(void))),*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))),*(()->(void)),int,array(*(char)))
*	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
=	O
get_language	(*(char))->(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))))
(	O
lang_name	*(char)
)	O
;	O
if	O
(	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
==	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"unrecognized language: `%s'"	*(char)
)	O
,	O
lang_name	*(char)
)	O
;	O
usage	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
->	O
lg_argc	int
==	O
0	int
)	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
->	O
lg_argv	array(*(char))
[	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
->	O
lg_argc	int
++	O
]	O
=	O
program_name	*(char)
;	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
->	O
lg_argv	array(*(char))
[	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
->	O
lg_argc	int
++	O
]	O
=	O
strsep	(*(*(char)),*(char))->(*(char))
(	O
&	O
arg	*(char)
,	O
horizontal_space	array(char)
)	O
;	O
}	O
void	O
language_getopt	()->(void)
(	O
void	O
)	O
{	O
struct	O
language	struct(*(char),*((*(*(char)),int)->(*(void))),*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))),*(()->(void)),int,array(*(char)))
*	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
;	O
for	O
(	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
=	O
languages_0	array(struct(*(char),*((*(*(char)),int)->(*(void))),*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))),*(()->(void)),int,array(*(char))))
;	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
<	O
languages_N	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
;	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
++	O
)	O
if	O
(	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
->	O
lg_argc	int
)	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
->	O
lg_parse_args	*((*(*(char)),int)->(*(void)))
(	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
->	O
lg_argv	array(*(char))
,	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
->	O
lg_argc	int
)	O
;	O
}	O
struct	O
language	struct(*(char),*((*(*(char)),int)->(*(void))),*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))),*(()->(void)),int,array(*(char)))
*	O
get_language	(*(char))->(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))))
(	O
char	O
const	O
*	O
lang_name	*(char)
)	O
{	O
struct	O
language	struct(*(char),*((*(*(char)),int)->(*(void))),*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))),*(()->(void)),int,array(*(char)))
*	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
;	O
for	O
(	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
=	O
languages_0	array(struct(*(char),*((*(*(char)),int)->(*(void))),*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))),*(()->(void)),int,array(*(char))))
;	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
<	O
languages_N	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
;	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
++	O
)	O
if	O
(	O
strequ	O
(	O
lang_name	*(char)
,	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
->	O
lg_name	*(char)
)	O
)	O
{	O
DEBUG	O
(	O
(	O
"lang=%s"	*(char)
,	O
lang_name	*(char)
)	O
)	O
;	O
return	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
;	O
}	O
DEBUG	O
(	O
(	O
"!lang=%s"	*(char)
,	O
lang_name	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
lang_args_index	int
=	O
0	int
;	O
void	O
set_default_language	(*(char))->(void)
(	O
char	O
const	O
*	O
lang_name	*(char)
)	O
{	O
}	O
void	O
parse_language_map	(*(char))->(void)
(	O
char	O
const	O
*	O
file_name	*(char)
)	O
{	O
if	O
(	O
obstack_init	O
(	O
&	O
lang_args_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
==	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
0	int
,	O
_	O
(	O
"can't allocate language args obstack: memory exhausted"	*(char)
)	O
)	O
;	O
if	O
(	O
file_name	*(char)
==	O
0	int
)	O
file_name	*(char)
=	O
LANGUAGE_MAP_FILE	O
;	O
parse_language_map_file	(*(char),*(*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))->(*(*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
(	O
file_name	*(char)
,	O
&	O
lang_args_list	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
)	O
;	O
}	O
struct	O
lang_args	struct(*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))))))
*	O
*	O
parse_language_map_file	(*(char),*(*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))->(*(*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
(	O
char	O
const	O
*	O
file_name	*(char)
,	O
struct	O
lang_args	struct(*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))))))
*	O
*	O
next_ptr	*(*(struct(*(struct(*`,*`,*`,*`,int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*`,*`,*`,*`,int,*`)))))
)	O
{	O
static	O
char	O
white_space	array(char)
[	O
]	O
=	O
" \t\r\n\v\f"	*(char)
;	O
static	O
char	O
horizontal_space	array(char)
[	O
]	O
=	O
" \t"	*(char)
;	O
static	O
char	O
vertical_space	array(char)
[	O
]	O
=	O
"\r\n\v\f"	*(char)
;	O
char	O
*	O
lang_map_buffer	*(char)
;	O
char	O
*	O
lmp	*(char)
;	O
lmp	*(char)
=	O
lang_map_buffer	*(char)
=	O
read_language_map_file	(*(char))->(*(char))
(	O
file_name	*(char)
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
lang_args	struct(*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))))))
*	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
;	O
struct	O
language	struct(*(char),*((*(*(char)),int)->(*(void))),*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))),*(()->(void)),int,array(*(char)))
const	O
*	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
;	O
int	O
pattern_size	int
;	O
char	O
*	O
lang_name	*(char)
;	O
int	O
space	int
;	O
while	O
(	O
*	O
lmp	*(char)
)	O
{	O
lmp	*(char)
+=	O
strspn	(*(char),*(char))->(long)
(	O
lmp	*(char)
,	O
white_space	array(char)
)	O
;	O
if	O
(	O
*	O
lmp	*(char)
!=	O
'#'	O
)	O
break	O
;	O
lmp	*(char)
+=	O
strcspn	(*(char),*(char))->(long)
(	O
lmp	*(char)
,	O
vertical_space	array(char)
)	O
;	O
}	O
if	O
(	O
*	O
lmp	*(char)
==	O
'\0'	O
)	O
break	O
;	O
pattern_size	int
=	O
strcspn	(*(char),*(char))->(long)
(	O
lmp	*(char)
,	O
white_space	array(char)
)	O
;	O
if	O
(	O
pattern_size	int
==	O
3	int
&&	O
strnequ	O
(	O
lmp	*(char)
,	O
"***"	*(char)
,	O
3	int
)	O
)	O
{	O
lmp	*(char)
+=	O
pattern_size	int
;	O
lmp	*(char)
+=	O
strspn	(*(char),*(char))->(long)
(	O
lmp	*(char)
,	O
horizontal_space	array(char)
)	O
;	O
if	O
(	O
isspace	(int)->(int)
(	O
*	O
lmp	*(char)
)	O
)	O
next_ptr	*(*(struct(*(struct(*`,*`,*`,*`,int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*`,*`,*`,*`,int,*`)))))
=	O
parse_language_map_file	(*(char),*(*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))->(*(*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
(	O
LANGUAGE_MAP_FILE	O
,	O
next_ptr	*(*(struct(*(struct(*`,*`,*`,*`,int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*`,*`,*`,*`,int,*`)))))
)	O
;	O
else	O
{	O
char	O
*	O
end	*(char)
=	O
lmp	*(char)
+	O
strcspn	(*(char),*(char))->(long)
(	O
lmp	*(char)
,	O
white_space	array(char)
)	O
;	O
*	O
end	*(char)
=	O
'\0'	O
;	O
next_ptr	*(*(struct(*(struct(*`,*`,*`,*`,int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*`,*`,*`,*`,int,*`)))))
=	O
parse_language_map_file	(*(char),*(*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))->(*(*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
(	O
lmp	*(char)
,	O
next_ptr	*(*(struct(*(struct(*`,*`,*`,*`,int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*`,*`,*`,*`,int,*`)))))
)	O
;	O
lmp	*(char)
=	O
end	*(char)
+	O
1	int
;	O
}	O
continue	O
;	O
}	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
=	O
obstack_alloc	O
(	O
&	O
lang_args_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
sizeof	O
(	O
struct	O
lang_args	struct(*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))))))
)	O
*	O
1	int
)	O
;	O
if	O
(	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
==	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
0	int
,	O
_	O
(	O
"can't allocate language args: memory exhausted"	*(char)
)	O
)	O
;	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
->	O
la_pattern	*(char)
=	O
obstack_copy0	O
(	O
&	O
lang_args_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
lmp	*(char)
,	O
pattern_size	int
)	O
;	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
->	O
la_args_string	*(char)
=	O
0	int
;	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
->	O
la_next	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
=	O
0	int
;	O
lmp	*(char)
+=	O
pattern_size	int
;	O
lmp	*(char)
+=	O
strspn	(*(char),*(char))->(long)
(	O
lmp	*(char)
,	O
horizontal_space	array(char)
)	O
;	O
if	O
(	O
isspace	(int)->(int)
(	O
*	O
lmp	*(char)
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"language name expected following `%s' in file `%s'"	*(char)
)	O
,	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
->	O
la_pattern	*(char)
,	O
file_name	*(char)
)	O
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
lang_args_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
)	O
;	O
continue	O
;	O
}	O
lang_name	*(char)
=	O
lmp	*(char)
;	O
lmp	*(char)
+=	O
strcspn	(*(char),*(char))->(long)
(	O
lmp	*(char)
,	O
white_space	array(char)
)	O
;	O
space	int
=	O
*	O
lmp	*(char)
;	O
*	O
lmp	*(char)
++	O
=	O
'\0'	O
;	O
lmp	*(char)
+=	O
strspn	(*(char),*(char))->(long)
(	O
lmp	*(char)
,	O
horizontal_space	array(char)
)	O
;	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
=	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
->	O
la_language	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
=	O
get_language	(*(char))->(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))))
(	O
lang_name	*(char)
)	O
;	O
if	O
(	O
*	O
lmp	*(char)
==	O
'#'	O
)	O
lmp	*(char)
+=	O
strcspn	(*(char),*(char))->(long)
(	O
lmp	*(char)
,	O
vertical_space	array(char)
)	O
;	O
else	O
if	O
(	O
!	O
isspace	(int)->(int)
(	O
*	O
lmp	*(char)
)	O
&&	O
(	O
space	int
==	O
' '	O
||	O
space	int
==	O
'\t'	O
)	O
)	O
{	O
int	O
args_size	int
=	O
strcspn	(*(char),*(char))->(long)
(	O
lmp	*(char)
,	O
vertical_space	array(char)
)	O
;	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
->	O
la_args_string	*(char)
=	O
obstack_copy0	O
(	O
&	O
lang_args_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
lmp	*(char)
,	O
args_size	int
)	O
;	O
lmp	*(char)
+=	O
args_size	int
;	O
}	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
->	O
la_args_digested	*(void)
=	O
(	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
?	O
lang	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
->	O
lg_parse_args	*((*(*(char)),int)->(*(void)))
(	O
&	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
->	O
la_args_string	*(char)
,	O
0	int
)	O
:	O
0	int
)	O
;	O
if	O
(	O
pattern_size	int
==	O
2	int
&&	O
strnequ	O
(	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
->	O
la_pattern	*(char)
,	O
"**"	*(char)
,	O
2	int
)	O
)	O
{	O
if	O
(	O
lang_args_default	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
)	O
{	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
lang_args_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
)	O
;	O
continue	O
;	O
}	O
lang_args_default	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
=	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
;	O
DEBUG	O
(	O
(	O
", <default>"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
->	O
la_index	int
=	O
lang_args_index	int
++	O
;	O
*	O
next_ptr	*(*(struct(*(struct(*`,*`,*`,*`,int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*`,*`,*`,*`,int,*`)))))
=	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
;	O
next_ptr	*(*(struct(*(struct(*`,*`,*`,*`,int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*`,*`,*`,*`,int,*`)))))
=	O
&	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
->	O
la_next	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
;	O
}	O
DEBUG	O
(	O
(	O
", pat=%s\n"	*(char)
,	O
new_args	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
->	O
la_pattern	*(char)
)	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
lang_map_buffer	*(char)
)	O
;	O
return	O
next_ptr	*(*(struct(*(struct(*`,*`,*`,*`,int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*`,*`,*`,*`,int,*`)))))
;	O
}	O
char	O
*	O
read_language_map_file	(*(char))->(*(char))
(	O
char	O
const	O
*	O
file_name	*(char)
)	O
{	O
int	O
map_fd	int
;	O
char	O
*	O
lang_map_buffer	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
bytes	int
;	O
map_fd	int
=	O
open	(*(char),int)->(int)
(	O
file_name	*(char)
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
map_fd	int
<	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't open language map file `%s'"	*(char)
)	O
,	O
file_name	*(char)
)	O
;	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
map_fd	int
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't get size of map file `%s'"	*(char)
)	O
,	O
file_name	*(char)
)	O
;	O
lang_map_buffer	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
)	O
*	O
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
+	O
2	int
)	O
)	O
;	O
if	O
(	O
lang_map_buffer	*(char)
==	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
0	int
,	O
_	O
(	O
"can't allocate language args: memory exhausted"	*(char)
)	O
)	O
;	O
lang_map_buffer	*(char)
[	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
]	O
=	O
'\n'	O
;	O
lang_map_buffer	*(char)
[	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
+	O
1	int
]	O
=	O
'\0'	O
;	O
bytes	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
map_fd	int
,	O
lang_map_buffer	*(char)
,	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
;	O
if	O
(	O
bytes	int
<	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't read language map file `%s'"	*(char)
)	O
,	O
file_name	*(char)
)	O
;	O
if	O
(	O
bytes	int
!=	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't read entire language map file `%s'"	*(char)
)	O
,	O
file_name	*(char)
)	O
;	O
close	*((*(void))->(int))
(	O
map_fd	int
)	O
;	O
return	O
lang_map_buffer	*(char)
;	O
}	O
void	O
tokenize_args_string	(*(char),*(int),*(*(*(char))))->(void)
(	O
char	O
*	O
args_string	*(char)
,	O
int	O
*	O
argcp	*(int)
,	O
char	O
*	O
*	O
*	O
argvp	*(*(*(char)))
)	O
{	O
static	O
char	O
horizontal_space	array(char)
[	O
]	O
=	O
" \t"	*(char)
;	O
char	O
*	O
*	O
argv_0	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
strlen	(*(char))->(long)
(	O
args_string	*(char)
)	O
/	O
2	int
)	O
;	O
char	O
*	O
*	O
argv	*(*(char))
=	O
argv_0	*(*(char))
;	O
char	O
*	O
arg	*(char)
;	O
*	O
argv	*(*(char))
++	O
=	O
program_name	*(char)
;	O
arg	*(char)
=	O
strsep	(*(*(char)),*(char))->(*(char))
(	O
&	O
args_string	*(char)
,	O
horizontal_space	array(char)
)	O
;	O
while	O
(	O
arg	*(char)
)	O
{	O
*	O
argv	*(*(char))
++	O
=	O
arg	*(char)
;	O
arg	*(char)
=	O
strsep	(*(*(char)),*(char))->(*(char))
(	O
&	O
args_string	*(char)
,	O
horizontal_space	array(char)
)	O
;	O
}	O
*	O
argcp	*(int)
=	O
argv	*(*(char))
-	O
argv_0	*(*(char))
;	O
*	O
argvp	*(*(*(char)))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
argv_0	*(*(char))
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
*	O
argcp	*(int)
)	O
)	O
;	O
}	O
static	O
void	O
set_ushort_ctype	(*(short),*(char),int)->(void)
(	O
unsigned	O
short	O
*	O
ctype	*(short)
,	O
char	O
const	O
*	O
chars	*(char)
,	O
int	O
type	enum(int,int,int,int)
)	O
{	O
unsigned	O
short	O
*	O
rct	*(short)
=	O
&	O
ctype	*(short)
[	O
1	int
]	O
;	O
unsigned	O
char	O
const	O
*	O
uc	*(char)
=	O
(	O
unsigned	O
char	O
const	O
*	O
)	O
chars	*(char)
;	O
while	O
(	O
*	O
uc	*(char)
)	O
rct	*(short)
[	O
*	O
uc	*(char)
++	O
]	O
|=	O
type	enum(int,int,int,int)
;	O
}	O
static	O
void	O
clear_ushort_ctype	(*(short),*(char),int)->(void)
(	O
unsigned	O
short	O
*	O
ctype	*(short)
,	O
char	O
const	O
*	O
chars	*(char)
,	O
int	O
type	enum(int,int,int,int)
)	O
{	O
unsigned	O
short	O
*	O
rct	*(short)
=	O
&	O
ctype	*(short)
[	O
1	int
]	O
;	O
unsigned	O
char	O
const	O
*	O
uc	*(char)
=	O
(	O
unsigned	O
char	O
const	O
*	O
)	O
chars	*(char)
;	O
while	O
(	O
*	O
uc	*(char)
)	O
rct	*(short)
[	O
*	O
uc	*(char)
++	O
]	O
&=	O
~	O
type	enum(int,int,int,int)
;	O
}	O
static	O
void	O
set_uchar_ctype	(*(char),*(char),int)->(void)
(	O
unsigned	O
char	O
*	O
ctype	*(short)
,	O
char	O
const	O
*	O
chars	*(char)
,	O
int	O
type	enum(int,int,int,int)
)	O
{	O
unsigned	O
char	O
*	O
rct	*(short)
;	O
unsigned	O
char	O
const	O
*	O
uc	*(char)
;	O
rct	*(short)
=	O
&	O
ctype	*(short)
[	O
1	int
]	O
;	O
uc	*(char)
=	O
(	O
unsigned	O
char	O
const	O
*	O
)	O
chars	*(char)
;	O
while	O
(	O
*	O
uc	*(char)
)	O
rct	*(short)
[	O
*	O
uc	*(char)
++	O
]	O
|=	O
type	enum(int,int,int,int)
;	O
}	O
static	O
void	O
clear_uchar_ctype	(*(char),*(char),int)->(void)
(	O
unsigned	O
char	O
*	O
ctype	*(short)
,	O
char	O
const	O
*	O
chars	*(char)
,	O
int	O
type	enum(int,int,int,int)
)	O
{	O
unsigned	O
char	O
*	O
rct	*(short)
;	O
unsigned	O
char	O
const	O
*	O
uc	*(char)
;	O
rct	*(short)
=	O
&	O
ctype	*(short)
[	O
1	int
]	O
;	O
uc	*(char)
=	O
(	O
unsigned	O
char	O
const	O
*	O
)	O
chars	*(char)
;	O
while	O
(	O
*	O
uc	*(char)
)	O
rct	*(short)
[	O
*	O
uc	*(char)
++	O
]	O
&=	O
~	O
type	enum(int,int,int,int)
;	O
}	O
static	O
unsigned	O
short	O
ctype_c	array(short)
[	O
257	int
]	O
=	O
{	O
EF	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NL	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
Q2	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
Q1	int
,	O
0	int
,	O
0	int
,	O
C2	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NM	int
,	O
C1	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
ES	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
}	O
;	O
struct	O
args_c	struct(int,*(short))
{	O
int	O
strip_underscore	int
;	O
unsigned	O
short	O
*	O
ctype	*(short)
;	O
}	O
;	O
static	O
struct	O
args_c	struct(int,*(short))
args_c	struct(int,*(short))
=	O
{	O
0	int
,	O
ctype_c	array(short)
}	O
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
const	O
long_options_c	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"keep"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"ignore"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"strip-underscore"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'u'	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
void	O
help_me_c	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"C language:\n  -k,--keep=CHARS        Allow CHARS in single-token strings, keep the result\n  -i,--ignore=CHARS      Allow CHARS in single-token strings, toss the result\n  -u,--strip-underscore  Strip a leading underscore from single-token strings\n"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
help_me_cpp	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"C++ language:\n  -k,--keep=CHARS        Allow CHARS in single-token strings, keep the result\n  -i,--ignore=CHARS      Allow CHARS in single-token strings, toss the result\n  -u,--strip-underscore  Strip a leading underscore from single-token strings\n"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
help_me_java	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Java language:\n  -k,--keep=CHARS        Allow CHARS in single-token strings, keep the result\n  -i,--ignore=CHARS      Allow CHARS in single-token strings, toss the result\n  -u,--strip-underscore  Strip a leading underscore from single-token strings\n"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
*	O
parse_args_c	(*(*(char)),int)->(*(void))
(	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
argc	int
)	O
{	O
char	O
*	O
tmp_string	*(char)
=	O
0	int
;	O
struct	O
args_c	struct(int,*(short))
*	O
args	*(void)
;	O
if	O
(	O
argv	*(*(char))
==	O
0	int
||	O
*	O
argv	*(*(char))
==	O
0	int
)	O
return	O
&	O
args_c	struct(int,*(short))
;	O
if	O
(	O
argc	int
)	O
args	*(void)
=	O
&	O
args_c	struct(int,*(short))
;	O
else	O
{	O
tmp_string	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
*	O
argv	*(*(char))
)	O
;	O
tokenize_args_string	(*(char),*(int),*(*(*(char))))->(void)
(	O
tmp_string	*(char)
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
args	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
args_c	struct(int,*(short))
)	O
*	O
1	int
)	O
;	O
args	*(void)
->	O
strip_underscore	int
=	O
0	int
;	O
args	*(void)
->	O
ctype	*(short)
=	O
ctype_c	array(short)
;	O
}	O
optind	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
optc	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"k:i:u"	*(char)
,	O
long_options_c	array(struct(*(char),int,*(int),int))
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
optc	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
optc	int
==	O
'k'	O
||	O
optc	int
==	O
'i'	O
)	O
&&	O
args	*(void)
->	O
ctype	*(short)
==	O
ctype_c	array(short)
)	O
args	*(void)
->	O
ctype	*(short)
=	O
CLONE	O
(	O
ctype_c	array(short)
,	O
unsigned	O
short	O
,	O
cardinalityof	O
(	O
ctype_c	array(short)
)	O
)	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'k'	O
:	O
set_ushort_ctype	(*(short),*(char),int)->(void)
(	O
args	*(void)
->	O
ctype	*(short)
,	O
optarg	*(char)
,	O
SK	int
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
clear_ushort_ctype	(*(short),*(char),int)->(void)
(	O
args	*(void)
->	O
ctype	*(short)
,	O
optarg	*(char)
,	O
SK	int
)	O
;	O
break	O
;	O
case	O
'u'	O
:	O
args	*(void)
->	O
strip_underscore	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
usage	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
tmp_string	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
argv	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
tmp_string	*(char)
)	O
;	O
}	O
return	O
args	*(void)
;	O
}	O
unsigned	O
char	O
*	O
scanner_buffer	*(char)
;	O
static	O
struct	O
token	struct(short,char,array(char))
*	O
get_token_c	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
(	O
FILE	struct
*	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
void	O
const	O
*	O
args	*(void)
,	O
int	O
*	O
flags	*(int)
)	O
{	O
static	O
int	O
new_line	int
=	O
1	int
;	O
unsigned	O
short	O
const	O
*	O
rct	*(short)
=	O
&	O
ARGS	O
->	O
ctype	*(short)
[	O
1	int
]	O
;	O
unsigned	O
char	O
*	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
int	O
c	int
;	O
int	O
d	int
;	O
obstack_blank	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
OFFSETOF_TOKEN_NAME	O
)	O
;	O
top	O
:	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
new_line	int
)	O
SCAN_CPP_DIRECTIVE	O
;	O
next	O
:	O
while	O
(	O
ISBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'"'	O
:	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
*	O
id	*(char)
++	O
=	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
ISQ2BORING	O
(	O
c	int
)	O
)	O
*	O
id	*(char)
++	O
=	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
*	O
id	*(char)
++	O
=	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
c	int
!=	O
'"'	O
)	O
goto	O
next	O
;	O
break	O
;	O
}	O
*	O
--	O
id	*(char)
=	O
'\0'	O
;	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
while	O
(	O
ISSTRKEEP	O
(	O
d	int
=	O
*	O
id	*(char)
)	O
)	O
id	*(char)
++	O
;	O
if	O
(	O
*	O
id	*(char)
||	O
id	*(char)
==	O
scanner_buffer	*(char)
)	O
{	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
goto	O
next	O
;	O
}	O
*	O
flags	*(int)
=	O
TOK_STRING	int
;	O
if	O
(	O
ARGS	O
->	O
strip_underscore	int
&&	O
scanner_buffer	*(char)
[	O
0	int
]	O
==	O
'_'	O
&&	O
scanner_buffer	*(char)
[	O
1	int
]	O
)	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
scanner_buffer	*(char)
+	O
1	int
,	O
id	*(char)
-	O
scanner_buffer	*(char)
-	O
1	int
)	O
;	O
else	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
scanner_buffer	*(char)
,	O
id	*(char)
-	O
scanner_buffer	*(char)
)	O
;	O
return	O
(	O
struct	O
token	struct(short,char,array(char))
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
case	O
'\''	O
:	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
ISQ1BORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\''	O
)	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
goto	O
next	O
;	O
}	O
case	O
'/'	O
:	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
'/'	O
)	O
{	O
while	O
(	O
ISCCBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
new_line	int
=	O
1	int
;	O
goto	O
top	O
;	O
}	O
else	O
if	O
(	O
c	int
!=	O
'*'	O
)	O
goto	O
next	O
;	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
ISCBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
'/'	O
)	O
{	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
goto	O
next	O
;	O
}	O
else	O
if	O
(	O
ISEOF	O
(	O
c	int
)	O
)	O
{	O
new_line	int
=	O
1	int
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
case	O
'\n'	O
:	O
new_line	int
=	O
1	int
;	O
goto	O
top	O
;	O
default	O
:	O
if	O
(	O
ISEOF	O
(	O
c	int
)	O
)	O
{	O
new_line	int
=	O
1	int
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
if	O
(	O
ISID1ST	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	*(int)
=	O
TOK_NAME	int
;	O
while	O
(	O
ISIDREST	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
}	O
else	O
if	O
(	O
ISDIGIT	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	*(int)
=	O
TOK_NUMBER	int
;	O
while	O
(	O
ISNUMBER	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
}	O
else	O
{	O
if	O
(	O
isprint	(int)->(int)
(	O
c	int
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"junk: `%c'"	*(char)
)	O
,	O
c	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"junk: `\\%03o'"	*(char)
)	O
,	O
c	int
)	O
;	O
}	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
*	O
flags	*(int)
|=	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
scanner_buffer	*(char)
,	O
id	*(char)
-	O
scanner_buffer	*(char)
)	O
;	O
return	O
(	O
struct	O
token	struct(short,char,array(char))
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
}	O
}	O
static	O
unsigned	O
char	O
ctype_asm	array(char)
[	O
257	int
]	O
=	O
{	O
EF	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NL	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
C2	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
C1	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
}	O
;	O
struct	O
args_asm	struct(int,int,*(char))
{	O
int	O
handle_cpp	int
;	O
int	O
strip_underscore	int
;	O
unsigned	O
char	O
*	O
ctype	*(short)
;	O
}	O
;	O
static	O
struct	O
args_asm	struct(int,int,*(char))
args_asm	struct(int,int,*(char))
=	O
{	O
1	int
,	O
0	int
,	O
ctype_asm	array(char)
}	O
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
const	O
long_options_asm	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"comment"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"keep"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"ignore"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"strip-underscore"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'u'	O
}	O
,	O
{	O
"no-cpp"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
void	O
help_me_asm	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Assembly language:\n  -c,--comment=CHARS     Any of CHARS starts a comment until end-of-line\n  -k,--keep=CHARS        Allow CHARS in tokens, and keep the result\n  -i,--ignore=CHARS      Allow CHARS in tokens, and toss the result\n  -u,--strip-underscore  Strip a leading underscore from tokens\n  -n,--no-cpp            Don't handle C pre-processor directives\n"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
*	O
parse_args_asm	(*(*(char)),int)->(*(void))
(	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
argc	int
)	O
{	O
char	O
*	O
tmp_string	*(char)
=	O
0	int
;	O
struct	O
args_asm	struct(int,int,*(char))
*	O
args	*(void)
;	O
if	O
(	O
argv	*(*(char))
==	O
0	int
||	O
*	O
argv	*(*(char))
==	O
0	int
)	O
return	O
&	O
args_asm	struct(int,int,*(char))
;	O
if	O
(	O
argc	int
)	O
args	*(void)
=	O
&	O
args_asm	struct(int,int,*(char))
;	O
else	O
{	O
tmp_string	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
*	O
argv	*(*(char))
)	O
;	O
tokenize_args_string	(*(char),*(int),*(*(*(char))))->(void)
(	O
tmp_string	*(char)
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
args	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
args_asm	struct(int,int,*(char))
)	O
*	O
1	int
)	O
;	O
args	*(void)
->	O
strip_underscore	int
=	O
0	int
;	O
args	*(void)
->	O
ctype	*(short)
=	O
ctype_asm	array(char)
;	O
args	*(void)
->	O
handle_cpp	int
=	O
1	int
;	O
}	O
optind	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
optc	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"c:k:i:un"	*(char)
,	O
long_options_asm	array(struct(*(char),int,*(int),int))
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
optc	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
optc	int
==	O
'k'	O
||	O
optc	int
==	O
'i'	O
||	O
optc	int
==	O
'c'	O
)	O
&&	O
args	*(void)
->	O
ctype	*(short)
==	O
ctype_asm	array(char)
)	O
args	*(void)
->	O
ctype	*(short)
=	O
CLONE	O
(	O
ctype_asm	array(char)
,	O
unsigned	O
char	O
,	O
cardinalityof	O
(	O
ctype_asm	array(char)
)	O
)	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'c'	O
:	O
set_uchar_ctype	(*(char),*(char),int)->(void)
(	O
args	*(void)
->	O
ctype	*(short)
,	O
optarg	*(char)
,	O
CM	int
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
set_uchar_ctype	(*(char),*(char),int)->(void)
(	O
args	*(void)
->	O
ctype	*(short)
,	O
optarg	*(char)
,	O
I1	int
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
set_uchar_ctype	(*(char),*(char),int)->(void)
(	O
args	*(void)
->	O
ctype	*(short)
,	O
optarg	*(char)
,	O
I1	int
|	O
IG	int
)	O
;	O
break	O
;	O
case	O
'u'	O
:	O
args	*(void)
->	O
strip_underscore	int
=	O
1	int
;	O
break	O
;	O
case	O
'n'	O
:	O
args	*(void)
->	O
handle_cpp	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
usage	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
tmp_string	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
argv	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
tmp_string	*(char)
)	O
;	O
}	O
return	O
args	*(void)
;	O
}	O
static	O
struct	O
token	struct(short,char,array(char))
*	O
get_token_asm	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
(	O
FILE	struct
*	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
void	O
const	O
*	O
args	*(void)
,	O
int	O
*	O
flags	*(int)
)	O
{	O
static	O
int	O
new_line	int
=	O
1	int
;	O
unsigned	O
char	O
const	O
*	O
rct	*(short)
=	O
&	O
ARGS	O
->	O
ctype	*(short)
[	O
1	int
]	O
;	O
unsigned	O
char	O
*	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
int	O
c	int
,	O
d	int
;	O
obstack_blank	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
OFFSETOF_TOKEN_NAME	O
)	O
;	O
top	O
:	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ARGS	O
->	O
handle_cpp	int
>	O
0	int
&&	O
new_line	int
)	O
SCAN_CPP_DIRECTIVE	O
;	O
next	O
:	O
while	O
(	O
ISBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ISCOMMENT	O
(	O
c	int
)	O
)	O
{	O
while	O
(	O
ISCBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
new_line	int
=	O
1	int
;	O
}	O
if	O
(	O
ISEOF	O
(	O
c	int
)	O
)	O
{	O
new_line	int
=	O
1	int
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
new_line	int
=	O
1	int
;	O
goto	O
top	O
;	O
}	O
if	O
(	O
c	int
==	O
'/'	O
)	O
{	O
if	O
(	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
'*'	O
)	O
goto	O
next	O
;	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
ISCCBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
'/'	O
)	O
{	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
ISEOF	O
(	O
c	int
)	O
)	O
{	O
new_line	int
=	O
1	int
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
goto	O
next	O
;	O
}	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
if	O
(	O
ARGS	O
->	O
strip_underscore	int
&&	O
c	int
==	O
'_'	O
&&	O
!	O
ISID1ST	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
{	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
"_"	*(char)
,	O
1	int
)	O
;	O
return	O
(	O
struct	O
token	struct(short,char,array(char))
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
}	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
if	O
(	O
ISID1ST	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	*(int)
=	O
TOK_NAME	int
;	O
while	O
(	O
ISIDREST	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
}	O
else	O
if	O
(	O
ISNUMBER	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	*(int)
=	O
TOK_NUMBER	int
;	O
while	O
(	O
ISNUMBER	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
}	O
else	O
{	O
if	O
(	O
isprint	(int)->(int)
(	O
c	int
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"junk: `%c'"	*(char)
)	O
,	O
c	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"junk: `\\%03o'"	*(char)
)	O
,	O
c	int
)	O
;	O
goto	O
next	O
;	O
}	O
*	O
id	*(char)
=	O
'\0'	O
;	O
for	O
(	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
*	O
id	*(char)
;	O
id	*(char)
++	O
)	O
if	O
(	O
ISIGNORE	O
(	O
d	int
=	O
*	O
id	*(char)
)	O
)	O
goto	O
next	O
;	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
*	O
flags	*(int)
|=	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
scanner_buffer	*(char)
,	O
id	*(char)
-	O
scanner_buffer	*(char)
)	O
;	O
return	O
(	O
struct	O
token	struct(short,char,array(char))
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
}	O
static	O
unsigned	O
char	O
ctype_text	array(char)
[	O
257	int
]	O
=	O
{	O
EF	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
}	O
;	O
struct	O
args_text	struct(*(char))
{	O
unsigned	O
char	O
*	O
ctype	*(short)
;	O
}	O
;	O
static	O
struct	O
args_text	struct(*(char))
args_text	struct(*(char))
=	O
{	O
ctype_text	array(char)
}	O
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
const	O
long_options_text	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"include"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"exclude"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
void	O
help_me_text	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Text language:\n  -i,--include=CHAR-CLASS  Treat characters of CHAR-CLASS as token constituents\n  -x,--exclude=CHAR-CLASS  Treat characters of CHAR-CLASS as token delimiters\n"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
*	O
parse_args_text	(*(*(char)),int)->(*(void))
(	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
argc	int
)	O
{	O
char	O
*	O
tmp_string	*(char)
=	O
0	int
;	O
struct	O
args_text	struct(*(char))
*	O
args	*(void)
;	O
if	O
(	O
argv	*(*(char))
==	O
0	int
||	O
*	O
argv	*(*(char))
==	O
0	int
)	O
return	O
&	O
args_text	struct(*(char))
;	O
if	O
(	O
argc	int
)	O
args	*(void)
=	O
&	O
args_text	struct(*(char))
;	O
else	O
{	O
tmp_string	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
*	O
argv	*(*(char))
)	O
;	O
tokenize_args_string	(*(char),*(int),*(*(*(char))))->(void)
(	O
tmp_string	*(char)
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
args	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
args_text	struct(*(char))
)	O
*	O
1	int
)	O
;	O
args	*(void)
->	O
ctype	*(short)
=	O
ctype_text	array(char)
;	O
}	O
optind	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
optc	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"i:x:"	*(char)
,	O
long_options_text	array(struct(*(char),int,*(int),int))
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
optc	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
optc	int
==	O
'x'	O
||	O
optc	int
==	O
'i'	O
)	O
&&	O
args	*(void)
->	O
ctype	*(short)
==	O
ctype_text	array(char)
)	O
args	*(void)
->	O
ctype	*(short)
=	O
CLONE	O
(	O
ctype_text	array(char)
,	O
unsigned	O
char	O
,	O
cardinalityof	O
(	O
ctype_text	array(char)
)	O
)	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'i'	O
:	O
set_uchar_ctype	(*(char),*(char),int)->(void)
(	O
args	*(void)
->	O
ctype	*(short)
,	O
optarg	*(char)
,	O
I1	int
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
clear_uchar_ctype	(*(char),*(char),int)->(void)
(	O
args	*(void)
->	O
ctype	*(short)
,	O
optarg	*(char)
,	O
I1	int
)	O
;	O
break	O
;	O
default	O
:	O
usage	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
tmp_string	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
argv	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
tmp_string	*(char)
)	O
;	O
}	O
return	O
args	*(void)
;	O
}	O
static	O
struct	O
token	struct(short,char,array(char))
*	O
get_token_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
(	O
FILE	struct
*	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
void	O
const	O
*	O
args	*(void)
,	O
int	O
*	O
flags	*(int)
)	O
{	O
unsigned	O
char	O
const	O
*	O
rct	*(short)
=	O
&	O
ARGS	O
->	O
ctype	*(short)
[	O
1	int
]	O
;	O
int	O
c	int
;	O
unsigned	O
char	O
*	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
obstack_blank	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
OFFSETOF_TOKEN_NAME	O
)	O
;	O
top	O
:	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
ISBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ISEOF	O
(	O
c	int
)	O
)	O
{	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
if	O
(	O
ISID1ST	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	*(int)
=	O
TOK_NAME	int
;	O
while	O
(	O
ISIDREST	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
if	O
(	O
!	O
ISIDSQUEEZE	O
(	O
c	int
)	O
)	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
}	O
else	O
if	O
(	O
ISNUMBER	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	*(int)
=	O
TOK_NUMBER	int
;	O
while	O
(	O
ISNUMBER	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
}	O
else	O
{	O
if	O
(	O
isprint	(int)->(int)
(	O
c	int
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"junk: `%c'"	*(char)
)	O
,	O
c	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"junk: `\\%03o'"	*(char)
)	O
,	O
c	int
)	O
;	O
goto	O
top	O
;	O
}	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
*	O
flags	*(int)
|=	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
scanner_buffer	*(char)
,	O
id	*(char)
-	O
scanner_buffer	*(char)
)	O
;	O
return	O
(	O
struct	O
token	struct(short,char,array(char))
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
}	O
static	O
unsigned	O
short	O
ctype_perl	array(short)
[	O
257	int
]	O
=	O
{	O
EF	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NL	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
Q2	int
,	O
CM	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
Q1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
EQ	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
ES	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
}	O
;	O
struct	O
args_perl	struct(int,*(short))
{	O
int	O
exclude_dtags	int
;	O
unsigned	O
short	O
*	O
ctype	*(short)
;	O
}	O
;	O
static	O
struct	O
args_perl	struct(int,*(short))
args_perl	struct(int,*(short))
=	O
{	O
1	int
,	O
ctype_perl	array(short)
}	O
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
const	O
long_options_perl	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"include"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"exclude"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"dtags"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
void	O
help_me_perl	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Perl language:\n  -i,--include=CHAR-CLASS  Treat characters of CHAR-CLASS as token constituents\n  -x,--exclude=CHAR-CLASS  Treat characters of CHAR-CLASS as token delimiters\n  -d,--dtags  Include documentation tags\n"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
*	O
parse_args_perl	(*(*(char)),int)->(*(void))
(	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
argc	int
)	O
{	O
char	O
*	O
tmp_string	*(char)
=	O
0	int
;	O
struct	O
args_perl	struct(int,*(short))
*	O
args	*(void)
;	O
if	O
(	O
argv	*(*(char))
==	O
0	int
||	O
*	O
argv	*(*(char))
==	O
0	int
)	O
return	O
&	O
args_perl	struct(int,*(short))
;	O
if	O
(	O
argc	int
)	O
args	*(void)
=	O
&	O
args_perl	struct(int,*(short))
;	O
else	O
{	O
tmp_string	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
*	O
argv	*(*(char))
)	O
;	O
tokenize_args_string	(*(char),*(int),*(*(*(char))))->(void)
(	O
tmp_string	*(char)
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
args	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
args_perl	struct(int,*(short))
)	O
)	O
;	O
args	*(void)
->	O
exclude_dtags	int
=	O
1	int
;	O
args	*(void)
->	O
ctype	*(short)
=	O
ctype_perl	array(short)
;	O
}	O
optind	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
optc	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"i:x:d"	*(char)
,	O
long_options_perl	array(struct(*(char),int,*(int),int))
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
optc	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
optc	int
==	O
'x'	O
||	O
optc	int
==	O
'i'	O
)	O
&&	O
args	*(void)
->	O
ctype	*(short)
==	O
ctype_perl	array(short)
)	O
args	*(void)
->	O
ctype	*(short)
=	O
CLONE	O
(	O
ctype_perl	array(short)
,	O
unsigned	O
short	O
,	O
cardinalityof	O
(	O
ctype_perl	array(short)
)	O
)	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'd'	O
:	O
args	*(void)
->	O
exclude_dtags	int
=	O
0	int
;	O
break	O
;	O
case	O
'i'	O
:	O
set_ushort_ctype	(*(short),*(char),int)->(void)
(	O
args	*(void)
->	O
ctype	*(short)
,	O
optarg	*(char)
,	O
I1	int
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
clear_ushort_ctype	(*(short),*(char),int)->(void)
(	O
args	*(void)
->	O
ctype	*(short)
,	O
optarg	*(char)
,	O
I1	int
)	O
;	O
break	O
;	O
default	O
:	O
usage	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
tmp_string	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
argv	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
tmp_string	*(char)
)	O
;	O
}	O
return	O
args	*(void)
;	O
}	O
static	O
struct	O
token	struct(short,char,array(char))
*	O
get_token_perl	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
(	O
FILE	struct
*	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
void	O
const	O
*	O
args	*(void)
,	O
int	O
*	O
flags	*(int)
)	O
{	O
static	O
int	O
new_line	int
=	O
1	int
;	O
unsigned	O
short	O
const	O
*	O
rct	*(short)
=	O
&	O
ARGS	O
->	O
ctype	*(short)
[	O
1	int
]	O
;	O
int	O
c	int
,	O
state	*(int)
=	O
0	int
,	O
skip_doc	int
=	O
0	int
;	O
unsigned	O
char	O
*	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
obstack_blank	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
OFFSETOF_TOKEN_NAME	O
)	O
;	O
top	O
:	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
ISBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\n'	O
:	O
state	*(int)
&=	O
~	O
CM	int
;	O
new_line	int
=	O
1	int
;	O
goto	O
top	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
new_line	int
=	O
0	int
;	O
goto	O
top	O
;	O
break	O
;	O
case	O
'#'	O
:	O
if	O
(	O
!	O
(	O
state	*(int)
&	O
Q1	int
)	O
&&	O
!	O
(	O
state	*(int)
&	O
Q2	int
)	O
)	O
state	*(int)
|=	O
CM	int
;	O
break	O
;	O
case	O
'\''	O
:	O
if	O
(	O
!	O
skip_doc	int
)	O
if	O
(	O
!	O
(	O
state	*(int)
&	O
CM	int
)	O
&&	O
!	O
(	O
state	*(int)
&	O
Q2	int
)	O
)	O
state	*(int)
^=	O
Q1	int
;	O
break	O
;	O
case	O
'\"'	O
:	O
if	O
(	O
!	O
skip_doc	int
)	O
if	O
(	O
!	O
(	O
state	*(int)
&	O
CM	int
)	O
&&	O
!	O
(	O
state	*(int)
&	O
Q1	int
)	O
)	O
state	*(int)
^=	O
Q2	int
;	O
break	O
;	O
case	O
'='	O
:	O
if	O
(	O
new_line	int
&&	O
ARGS	O
->	O
exclude_dtags	int
)	O
{	O
skip_doc	int
=	O
1	int
;	O
state	*(int)
&=	O
~	O
EQ	int
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
ISEOF	O
(	O
c	int
)	O
)	O
{	O
new_line	int
=	O
1	int
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
break	O
;	O
}	O
new_line	int
=	O
0	int
;	O
if	O
(	O
ISCOMMENT	O
(	O
c	int
)	O
||	O
ISQUOTE1	O
(	O
c	int
)	O
||	O
ISQUOTE2	O
(	O
c	int
)	O
||	O
ISNEWLINE	O
(	O
c	int
)	O
||	O
ISEQUALS	O
(	O
c	int
)	O
||	O
state	*(int)
)	O
goto	O
top	O
;	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
if	O
(	O
ISID1ST	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	*(int)
=	O
TOK_NAME	int
;	O
while	O
(	O
ISIDREST	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
if	O
(	O
!	O
ISIDSQUEEZE	O
(	O
c	int
)	O
)	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
}	O
else	O
if	O
(	O
ISNUMBER	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	*(int)
=	O
TOK_NUMBER	int
;	O
while	O
(	O
ISNUMBER	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
goto	O
top	O
;	O
}	O
else	O
{	O
if	O
(	O
isprint	(int)->(int)
(	O
c	int
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"junk: `%c'"	*(char)
)	O
,	O
c	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"junk: `\\%03o'"	*(char)
)	O
,	O
c	int
)	O
;	O
goto	O
top	O
;	O
}	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
*	O
id	*(char)
=	O
'\0'	O
;	O
if	O
(	O
skip_doc	int
)	O
{	O
if	O
(	O
strequ	O
(	O
scanner_buffer	*(char)
,	O
"cut"	*(char)
)	O
)	O
{	O
skip_doc	int
=	O
0	int
;	O
}	O
else	O
{	O
state	*(int)
|=	O
EQ	int
;	O
}	O
goto	O
top	O
;	O
}	O
if	O
(	O
strequ	O
(	O
scanner_buffer	*(char)
,	O
"_"	*(char)
)	O
)	O
{	O
goto	O
top	O
;	O
}	O
*	O
flags	*(int)
|=	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
scanner_buffer	*(char)
,	O
id	*(char)
-	O
scanner_buffer	*(char)
)	O
;	O
return	O
(	O
struct	O
token	struct(short,char,array(char))
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
}	O
static	O
unsigned	O
char	O
ctype_lisp	array(char)
[	O
257	int
]	O
=	O
{	O
EF	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
0	int
,	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
Id	int
,	O
0	int
,	O
Id	int
|	O
NM	int
,	O
Id	int
|	O
NM	int
,	O
I1	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
I1	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
Id	int
|	O
NM	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
,	O
LT	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
,	O
LT	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
0	int
}	O
;	O
static	O
void	O
help_me_lisp	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Lisp language:\n"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
*	O
parse_args_lisp	(*(*(char)),int)->(*(void))
(	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
argc	int
)	O
{	O
return	O
NULL	O
;	O
}	O
static	O
struct	O
token	struct(short,char,array(char))
*	O
get_token_lisp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*(int))->(*(struct(short,char,array(char))))
(	O
FILE	struct
*	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
void	O
const	O
*	O
args	*(void)
,	O
int	O
*	O
flags	*(int)
)	O
{	O
unsigned	O
char	O
const	O
*	O
rct	*(short)
=	O
&	O
ctype_lisp	array(char)
[	O
1	int
]	O
;	O
unsigned	O
char	O
*	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
int	O
c	int
;	O
obstack_blank	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
OFFSETOF_TOKEN_NAME	O
)	O
;	O
top	O
:	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
recheck	O
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
EOF	O
:	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
)	O
;	O
return	O
0	int
;	O
case	O
'('	O
:	O
case	O
')'	O
:	O
case	O
'\''	O
:	O
case	O
'`'	O
:	O
goto	O
top	O
;	O
case	O
','	O
:	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
'@'	O
)	O
goto	O
top	O
;	O
goto	O
recheck	O
;	O
case	O
';'	O
:	O
do	O
{	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
while	O
(	O
(	O
c	int
!=	O
EOF	O
)	O
&&	O
(	O
c	int
!=	O
'\n'	O
)	O
)	O
;	O
goto	O
top	O
;	O
case	O
'"'	O
:	O
string	O
:	O
do	O
{	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
goto	O
string	O
;	O
}	O
}	O
while	O
(	O
(	O
c	int
!=	O
EOF	O
)	O
&&	O
(	O
c	int
!=	O
'"'	O
)	O
)	O
;	O
goto	O
top	O
;	O
case	O
'?'	O
:	O
cconstant	O
:	O
do	O
{	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
goto	O
cconstant	O
;	O
}	O
}	O
while	O
(	O
c	int
!=	O
EOF	O
&&	O
is_IDENT	O
(	O
c	int
)	O
)	O
;	O
goto	O
top	O
;	O
case	O
'.'	O
:	O
case	O
'+'	O
:	O
case	O
'-'	O
:	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
is_DIGIT	O
(	O
c	int
)	O
||	O
(	O
scanner_buffer	*(char)
[	O
0	int
]	O
!=	O
'.'	O
&&	O
(	O
c	int
==	O
'.'	O
||	O
c	int
==	O
'i'	O
||	O
c	int
==	O
'I'	O
)	O
)	O
)	O
goto	O
number	O
;	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
goto	O
ident	O
;	O
case	O
'#'	O
:	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
goto	O
top	O
;	O
else	O
if	O
(	O
is_RADIX	O
(	O
c	int
)	O
)	O
goto	O
number	O
;	O
else	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
if	O
(	O
is_LETTER	O
(	O
c	int
)	O
)	O
{	O
while	O
(	O
is_LETTER	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
*	O
flags	*(int)
=	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
scanner_buffer	*(char)
,	O
id	*(char)
-	O
scanner_buffer	*(char)
)	O
;	O
return	O
(	O
struct	O
token	struct(short,char,array(char))
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'('	O
)	O
goto	O
top	O
;	O
else	O
if	O
(	O
c	int
==	O
'"'	O
)	O
goto	O
string	O
;	O
else	O
if	O
(	O
c	int
==	O
'!'	O
)	O
{	O
while	O
(	O
is_LETTER	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
*	O
flags	*(int)
=	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
scanner_buffer	*(char)
,	O
id	*(char)
-	O
scanner_buffer	*(char)
)	O
;	O
return	O
(	O
struct	O
token	struct(short,char,array(char))
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'|'	O
)	O
{	O
do	O
{	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
'|'	O
)	O
{	O
while	O
(	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
==	O
'|'	O
)	O
;	O
if	O
(	O
c	int
==	O
'#'	O
)	O
break	O
;	O
}	O
}	O
while	O
(	O
c	int
!=	O
EOF	O
)	O
;	O
goto	O
top	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'@'	O
)	O
{	O
do	O
{	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
while	O
(	O
(	O
c	int
!=	O
EOF	O
)	O
&&	O
(	O
c	int
!=	O
'\037'	O
)	O
)	O
;	O
goto	O
top	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'['	O
)	O
goto	O
top	O
;	O
goto	O
top	O
;	O
case	O
'['	O
:	O
case	O
']'	O
:	O
goto	O
top	O
;	O
default	O
:	O
if	O
(	O
is_IDENT1	O
(	O
c	int
)	O
)	O
{	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
ident	O
:	O
while	O
(	O
is_IDENT	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
if	O
(	O
c	int
==	O
'['	O
)	O
{	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
']'	O
)	O
{	O
*	O
id	*(char)
++	O
=	O
'['	O
;	O
*	O
id	*(char)
++	O
=	O
']'	O
;	O
goto	O
ident	O
;	O
}	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'['	O
,	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
*	O
flags	*(int)
=	O
TOK_NAME	int
|	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
scanner_buffer	*(char)
,	O
id	*(char)
-	O
scanner_buffer	*(char)
)	O
;	O
return	O
(	O
struct	O
token	struct(short,char,array(char))
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
}	O
else	O
if	O
(	O
is_DIGIT	O
(	O
c	int
)	O
)	O
{	O
id	*(char)
=	O
scanner_buffer	*(char)
;	O
number	O
:	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
while	O
(	O
is_NUMBER	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
*	O
id	*(char)
++	O
=	O
c	int
;	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
in_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
*	O
flags	*(int)
=	O
TOK_NUMBER	int
|	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
scanner_buffer	*(char)
,	O
id	*(char)
-	O
scanner_buffer	*(char)
)	O
;	O
return	O
(	O
struct	O
token	struct(short,char,array(char))
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
}	O
}	O
goto	O
top	O
;	O
}	O
