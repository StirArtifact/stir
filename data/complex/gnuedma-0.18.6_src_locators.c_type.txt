ESint32	long
EDMAPROC	O
_edma_look4_met_single	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
IdObj	long
,	O
EPChar	*(char)
MetName	*(char)
,	O
EPChar	*(char)
Signature	*(char)
)	O
;	O
ESint32	long
EDMAPROC	O
_edma_look4_met_ext_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
Obj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
ObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
MetName	*(char)
,	O
EPChar	*(char)
Signature	*(char)
)	O
;	O
ESint32	long
EDMAPROC	O
_edma_look4_closer_met_up	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char),long)->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
Obj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
ObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
MetName	*(char)
,	O
EPChar	*(char)
Signature	*(char)
,	O
ESint32	long
down	long
)	O
;	O
ESint32	long
EDMAPROC	O
_edma_look4_closer_met_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
Obj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
ObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
MetName	*(char)
,	O
EPChar	*(char)
Signature	*(char)
)	O
;	O
ESint32	long
EDMAPROC	O
_edma_look4_prop_single	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
IdObj	long
,	O
EPChar	*(char)
PropName	*(char)
)	O
;	O
ESint32	long
EDMAPROC	O
_edma_look4_prop_ext_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
Obj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
ObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
MetName	*(char)
)	O
;	O
ESint32	long
EDMAPROC	O
_edma_look4_closer_prop_up	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),long)->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
Obj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
ObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
MetName	*(char)
,	O
ESint32	long
down	long
)	O
;	O
ESint32	long
EDMAPROC	O
_edma_look4_closer_prop_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
Obj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
ObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
MetName	*(char)
)	O
;	O
ESint32	long
EDMAPROC	O
_edma_look4_met_single	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
MetName	*(char)
,	O
EPChar	*(char)
Signature	*(char)
)	O
{	O
ESint32	long
indx	long
,	O
key	long
;	O
key	long
=	O
-	O
1	int
;	O
indx	long
=	O
edma_dict_get_next_index	(*(struct(long,long,long,long,long,*(struct(*`,long,long)))),*(char),*(long))->(long)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdClass	long
]	O
->	O
met_dict	*(struct(long,long,long,long,long,*(struct(*(char),long,long))))
,	O
MetName	*(char)
,	O
&	O
key	long
)	O
;	O
if	O
(	O
Signature	*(char)
)	O
do	O
{	O
if	O
(	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdClass	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Sign	array(char)
,	O
Signature	*(char)
,	O
EDMA_MET_SIG_LEN	int
)	O
)	O
==	O
0	int
)	O
break	O
;	O
indx	long
=	O
edma_dict_get_next_index	(*(struct(long,long,long,long,long,*(struct(*`,long,long)))),*(char),*(long))->(long)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdClass	long
]	O
->	O
met_dict	*(struct(long,long,long,long,long,*(struct(*(char),long,long))))
,	O
MetName	*(char)
,	O
&	O
key	long
)	O
;	O
}	O
while	O
(	O
indx	long
>=	O
0	int
)	O
;	O
return	O
indx	long
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_look4_prop_single	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
PropName	*(char)
)	O
{	O
return	O
edma_dict_get_index	(*(struct(long,long,long,long,long,*(struct(*`,long,long)))),*(char))->(long)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdClass	long
]	O
->	O
prop_dict	*(struct(long,long,long,long,long,*(struct(*(char),long,long))))
,	O
PropName	*(char)
)	O
;	O
}	O
ESint32	long
EDMAPROC	O
edma_look4_met	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(char),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
EPChar	*(char)
MetName1	*(char)
,	O
EPChar	*(char)
Signature	*(char)
)	O
{	O
EPChar	*(char)
MetName	*(char)
;	O
ESint32	long
indx	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
orig	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
if	O
(	O
MetName1	*(char)
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
MetName	*(char)
=	O
MetName1	*(char)
+	O
1	int
;	O
indx	long
=	O
_edma_look4_closer_met_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
NULL	O
,	O
MetName	*(char)
,	O
Signature	*(char)
)	O
;	O
if	O
(	O
indx	long
==	O
-	O
1	int
)	O
{	O
indx	long
=	O
_edma_look4_closer_met_up	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char),long)->(long)
(	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
NULL	O
,	O
MetName	*(char)
,	O
Signature	*(char)
,	O
1	int
)	O
;	O
}	O
return	O
indx	long
;	O
}	O
else	O
{	O
orig	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
;	O
indx	long
=	O
_edma_look4_met_single	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
orig	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
MetName1	*(char)
,	O
Signature	*(char)
)	O
;	O
if	O
(	O
indx	long
==	O
-	O
1	int
)	O
indx	long
=	O
_edma_look4_closer_met_up	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char),long)->(long)
(	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
orig	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
MetName1	*(char)
,	O
Signature	*(char)
,	O
0	int
)	O
;	O
return	O
indx	long
;	O
}	O
}	O
ESint32	long
EDMAPROC	O
edma_look4_met_ext	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(char),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
MetName1	*(char)
,	O
EPChar	*(char)
Signature	*(char)
)	O
{	O
EPChar	*(char)
MetName	*(char)
;	O
ESint32	long
indx	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
orig	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
if	O
(	O
MetName1	*(char)
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
MetName	*(char)
=	O
MetName1	*(char)
+	O
1	int
;	O
indx	long
=	O
_edma_look4_closer_met_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
NULL	O
,	O
MetName	*(char)
,	O
Signature	*(char)
)	O
;	O
if	O
(	O
indx	long
==	O
-	O
1	int
)	O
{	O
indx	long
=	O
_edma_look4_closer_met_up	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char),long)->(long)
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
NULL	O
,	O
MetName	*(char)
,	O
Signature	*(char)
,	O
1	int
)	O
;	O
}	O
return	O
indx	long
;	O
}	O
else	O
{	O
orig	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
*	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
indx	long
=	O
_edma_look4_met_ext_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
NULL	O
,	O
MetName1	*(char)
,	O
Signature	*(char)
)	O
;	O
if	O
(	O
indx	long
==	O
-	O
1	int
)	O
{	O
indx	long
=	O
_edma_look4_closer_met_up	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char),long)->(long)
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
orig	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
MetName1	*(char)
,	O
Signature	*(char)
,	O
1	int
)	O
;	O
}	O
return	O
indx	long
;	O
}	O
}	O
ESint32	long
EDMAPROC	O
_edma_look4_met_ext_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
MetName	*(char)
,	O
EPChar	*(char)
Signature	*(char)
)	O
{	O
EUint32	long
j	long
,	O
n	long
;	O
ESint32	long
Flag	char
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
pObj_temp	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
SC_ID	struct(long,array(char),long,long)
*	O
down	long
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
;	O
n	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
;	O
if	O
(	O
n	long
)	O
{	O
down	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n	long
;	O
j	long
++	O
)	O
{	O
pObj_temp	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
down	long
[	O
j	long
]	O
.	O
Obj	long
]	O
;	O
if	O
(	O
pObj_temp	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
==	O
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
continue	O
;	O
Flag	char
=	O
_edma_look4_met_ext_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
&	O
pObj_temp	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
MetName	*(char)
,	O
Signature	*(char)
)	O
;	O
if	O
(	O
Flag	char
!=	O
-	O
1	int
)	O
{	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
=	O
pObj_temp	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
return	O
Flag	char
;	O
}	O
}	O
}	O
return	O
_edma_look4_met_single	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
MetName	*(char)
,	O
Signature	*(char)
)	O
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_look4_closer_met_up	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char),long)->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
MetName	*(char)
,	O
EPChar	*(char)
Signature	*(char)
,	O
ESint32	long
down	long
)	O
{	O
EUint32	long
j	long
,	O
n	long
;	O
ESint32	long
indx	long
=	O
-	O
1	int
;	O
ESint32	long
Flag	char
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
SC_ID	struct(long,array(char),long,long)
*	O
up	*(struct(long,array(char),long,long))
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
;	O
n	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nUpTable	long
;	O
if	O
(	O
n	long
)	O
{	O
up	*(struct(long,array(char),long,long))
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
;	O
indx	long
=	O
-	O
1	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n	long
;	O
j	long
++	O
)	O
{	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
=	O
gObj	O
[	O
up	*(struct(long,array(char),long,long))
[	O
j	long
]	O
.	O
Obj	long
]	O
;	O
if	O
(	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
==	O
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
continue	O
;	O
indx	long
=	O
_edma_look4_met_single	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
MetName	*(char)
,	O
Signature	*(char)
)	O
;	O
if	O
(	O
indx	long
!=	O
-	O
1	int
)	O
return	O
indx	long
;	O
Flag	char
=	O
_edma_look4_closer_met_up	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char),long)->(long)
(	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
MetName	*(char)
,	O
Signature	*(char)
,	O
down	long
)	O
;	O
if	O
(	O
Flag	char
!=	O
-	O
1	int
)	O
{	O
return	O
Flag	char
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
down	long
==	O
1	int
)	O
return	O
_edma_look4_met_ext_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
MetName	*(char)
,	O
Signature	*(char)
)	O
;	O
}	O
return	O
indx	long
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_look4_closer_met_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
MetName	*(char)
,	O
EPChar	*(char)
Signature	*(char)
)	O
{	O
EUint32	long
j	long
,	O
n	long
;	O
ESint32	long
Flag	char
,	O
indx	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
SC_ID	struct(long,array(char),long,long)
*	O
down	long
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
;	O
indx	long
=	O
_edma_look4_met_single	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
MetName	*(char)
,	O
Signature	*(char)
)	O
;	O
if	O
(	O
indx	long
==	O
-	O
1	int
)	O
{	O
n	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
;	O
down	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n	long
;	O
j	long
++	O
)	O
{	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
=	O
gObj	O
[	O
down	long
[	O
j	long
]	O
.	O
Obj	long
]	O
;	O
if	O
(	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
==	O
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
continue	O
;	O
Flag	char
=	O
_edma_look4_closer_met_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),*(char))->(long)
(	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
MetName	*(char)
,	O
Signature	*(char)
)	O
;	O
if	O
(	O
Flag	char
!=	O
-	O
1	int
)	O
{	O
return	O
Flag	char
;	O
}	O
}	O
}	O
return	O
indx	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_look4_prop	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
EPChar	*(char)
PropName1	*(char)
)	O
{	O
EPChar	*(char)
PropName	*(char)
;	O
ESint32	long
indx	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
orig	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
if	O
(	O
PropName1	*(char)
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
PropName	*(char)
=	O
PropName1	*(char)
+	O
1	int
;	O
indx	long
=	O
_edma_look4_closer_prop_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
NULL	O
,	O
PropName	*(char)
)	O
;	O
if	O
(	O
indx	long
==	O
-	O
1	int
)	O
{	O
indx	long
=	O
_edma_look4_closer_prop_up	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),long)->(long)
(	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
NULL	O
,	O
PropName	*(char)
,	O
1	int
)	O
;	O
}	O
return	O
indx	long
;	O
}	O
else	O
{	O
orig	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
;	O
indx	long
=	O
_edma_look4_prop_single	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
orig	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
PropName1	*(char)
)	O
;	O
if	O
(	O
indx	long
==	O
-	O
1	int
)	O
indx	long
=	O
_edma_look4_closer_prop_up	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),long)->(long)
(	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
orig	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
PropName1	*(char)
,	O
0	int
)	O
;	O
return	O
indx	long
;	O
}	O
}	O
ESint32	long
EDMAPROC	O
edma_look4_prop_ext	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
PropName1	*(char)
)	O
{	O
EPChar	*(char)
PropName	*(char)
;	O
ESint32	long
indx	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
orig	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
if	O
(	O
PropName1	*(char)
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
PropName	*(char)
=	O
PropName1	*(char)
+	O
1	int
;	O
indx	long
=	O
_edma_look4_closer_prop_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
NULL	O
,	O
PropName	*(char)
)	O
;	O
if	O
(	O
indx	long
==	O
-	O
1	int
)	O
{	O
indx	long
=	O
_edma_look4_closer_prop_up	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),long)->(long)
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
NULL	O
,	O
PropName	*(char)
,	O
1	int
)	O
;	O
}	O
return	O
indx	long
;	O
}	O
else	O
{	O
orig	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
*	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
indx	long
=	O
_edma_look4_prop_ext_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
NULL	O
,	O
PropName1	*(char)
)	O
;	O
if	O
(	O
indx	long
==	O
-	O
1	int
)	O
{	O
indx	long
=	O
_edma_look4_closer_prop_up	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),long)->(long)
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
orig	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
PropName1	*(char)
,	O
1	int
)	O
;	O
}	O
return	O
indx	long
;	O
}	O
}	O
ESint32	long
EDMAPROC	O
_edma_look4_prop_ext_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
PropName	*(char)
)	O
{	O
EUint32	long
j	long
,	O
n	long
;	O
ESint32	long
Flag	char
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
pObj_temp	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
SC_ID	struct(long,array(char),long,long)
*	O
down	long
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
;	O
n	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
;	O
if	O
(	O
n	long
)	O
{	O
down	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n	long
;	O
j	long
++	O
)	O
{	O
pObj_temp	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
down	long
[	O
j	long
]	O
.	O
Obj	long
]	O
;	O
if	O
(	O
pObj_temp	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
==	O
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
continue	O
;	O
Flag	char
=	O
_edma_look4_prop_ext_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
&	O
pObj_temp	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
PropName	*(char)
)	O
;	O
if	O
(	O
Flag	char
!=	O
-	O
1	int
)	O
{	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
=	O
pObj_temp	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
return	O
Flag	char
;	O
}	O
}	O
}	O
return	O
_edma_look4_prop_single	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
PropName	*(char)
)	O
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_look4_closer_prop_up	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),long)->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
PropName	*(char)
,	O
ESint32	long
down	long
)	O
{	O
EUint32	long
j	long
,	O
n	long
;	O
ESint32	long
indx	long
=	O
-	O
1	int
;	O
ESint32	long
Flag	char
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
SC_ID	struct(long,array(char),long,long)
*	O
up	*(struct(long,array(char),long,long))
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
;	O
n	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nUpTable	long
;	O
if	O
(	O
n	long
)	O
{	O
up	*(struct(long,array(char),long,long))
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
;	O
indx	long
=	O
-	O
1	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n	long
;	O
j	long
++	O
)	O
{	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
=	O
gObj	O
[	O
up	*(struct(long,array(char),long,long))
[	O
j	long
]	O
.	O
Obj	long
]	O
;	O
if	O
(	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
==	O
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
continue	O
;	O
indx	long
=	O
_edma_look4_prop_single	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
PropName	*(char)
)	O
;	O
if	O
(	O
indx	long
!=	O
-	O
1	int
)	O
return	O
indx	long
;	O
Flag	char
=	O
_edma_look4_closer_prop_up	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char),long)->(long)
(	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
PropName	*(char)
,	O
down	long
)	O
;	O
if	O
(	O
Flag	char
!=	O
-	O
1	int
)	O
{	O
return	O
Flag	char
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
down	long
==	O
1	int
)	O
return	O
_edma_look4_prop_ext_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
PropName	*(char)
)	O
;	O
}	O
return	O
indx	long
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_look4_closer_prop_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
EPChar	*(char)
PropName	*(char)
)	O
{	O
EUint32	long
j	long
,	O
n	long
;	O
ESint32	long
Flag	char
,	O
indx	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
SC_ID	struct(long,array(char),long,long)
*	O
down	long
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
;	O
indx	long
=	O
_edma_look4_prop_single	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
PropName	*(char)
)	O
;	O
if	O
(	O
indx	long
==	O
-	O
1	int
)	O
{	O
n	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
;	O
down	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n	long
;	O
j	long
++	O
)	O
{	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
=	O
gObj	O
[	O
down	long
[	O
j	long
]	O
.	O
Obj	long
]	O
;	O
if	O
(	O
*	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
==	O
pObjFrom	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
continue	O
;	O
Flag	char
=	O
_edma_look4_closer_prop_down	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(char))->(long)
(	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
PropName	*(char)
)	O
;	O
if	O
(	O
Flag	char
!=	O
-	O
1	int
)	O
{	O
return	O
Flag	char
;	O
}	O
}	O
}	O
return	O
indx	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_locate_method	(long,*(char),*(char),*(long),*(long))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
EPChar	*(char)
Signature	*(char)
,	O
EPSint32	*(long)
has_cp	*(long)
,	O
EPSint32	*(long)
met_indx	*(long)
)	O
{	O
EPChar	*(char)
MetName	*(char)
;	O
OBJID	long
aux_obj	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
ESint32	long
pos	long
;	O
pos	long
=	O
strlen	(*(char))->(int)
(	O
Id1	*(char)
)	O
;	O
while	O
(	O
(	O
Id1	*(char)
[	O
pos	long
]	O
!=	O
'>'	O
)	O
&&	O
(	O
Id1	*(char)
[	O
pos	long
]	O
!=	O
'<'	O
)	O
&&	O
(	O
pos	long
>	O
0	int
)	O
)	O
--	O
pos	long
;	O
if	O
(	O
pos	long
!=	O
0	int
)	O
{	O
MetName	*(char)
=	O
Id1	*(char)
+	O
pos	long
+	O
1	int
;	O
aux_obj	long
=	O
edma_parse_classpath	(long,*(char),long,long)->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
pos	long
,	O
1	int
)	O
;	O
if	O
(	O
aux_obj	long
!=	O
-	O
1	int
)	O
{	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
aux_obj	long
]	O
;	O
if	O
(	O
(	O
*	O
met_indx	*(long)
=	O
edma_look4_met	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(char),*(char))->(long)
(	O
&	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
MetName	*(char)
,	O
Signature	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[%s] Method '%s' not Found from classpath '%s'"	*(char)
,	O
__FUNCTION__	O
,	O
MetName	*(char)
,	O
Id1	*(char)
)	O
;	O
}	O
}	O
else	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
if	O
(	O
(	O
(	O
*	O
met_indx	*(long)
=	O
edma_look4_met_ext	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(char),*(char))->(long)
(	O
&	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
Id1	*(char)
,	O
Signature	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
&&	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdSIU	long
==	O
-	O
1	int
)	O
)	O
{	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[_edma_locate_method] Method '%s' "	*(char)
"not found in object '%ld' "	*(char)
"through classpath: '%s'"	*(char)
,	O
Id1	*(char)
,	O
IdObj	long
,	O
Id1	*(char)
)	O
;	O
}	O
}	O
*	O
has_cp	*(long)
=	O
pos	long
;	O
return	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdObj	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_locate_property	(long,*(char),*(long),*(long))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
EPSint32	*(long)
has_cp	*(long)
,	O
EPSint32	*(long)
prop_indx	*(long)
)	O
{	O
EPChar	*(char)
PropName	*(char)
;	O
OBJID	long
aux_obj	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
ESint32	long
pos	long
;	O
pos	long
=	O
strlen	(*(char))->(int)
(	O
Id1	*(char)
)	O
;	O
while	O
(	O
(	O
Id1	*(char)
[	O
pos	long
]	O
!=	O
'>'	O
)	O
&&	O
(	O
Id1	*(char)
[	O
pos	long
]	O
!=	O
'<'	O
)	O
&&	O
(	O
pos	long
>	O
0	int
)	O
)	O
--	O
pos	long
;	O
if	O
(	O
pos	long
!=	O
0	int
)	O
{	O
PropName	*(char)
=	O
Id1	*(char)
+	O
pos	long
+	O
1	int
;	O
aux_obj	long
=	O
edma_parse_classpath	(long,*(char),long,long)->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
pos	long
,	O
1	int
)	O
;	O
if	O
(	O
aux_obj	long
!=	O
-	O
1	int
)	O
{	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
aux_obj	long
]	O
;	O
if	O
(	O
(	O
*	O
prop_indx	*(long)
=	O
edma_look4_prop	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(char))->(long)
(	O
&	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
PropName	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[%s] Property '%s' not Found from classpath '%s'"	*(char)
,	O
__FUNCTION__	O
,	O
PropName	*(char)
,	O
Id1	*(char)
)	O
;	O
}	O
}	O
else	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
if	O
(	O
(	O
(	O
*	O
prop_indx	*(long)
=	O
edma_look4_prop_ext	(*(*(struct(*(void),*(struct`),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct`),long,*(struct`)))),*(char))->(long)
(	O
&	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
Id1	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
&&	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdSIU	long
==	O
-	O
1	int
)	O
)	O
{	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[_edma_locate_property] "	*(char)
"Property '%s' "	*(char)
"not found in object '%ld' "	*(char)
"through classpath: '%s'"	*(char)
,	O
Id1	*(char)
,	O
IdObj	long
,	O
Id1	*(char)
)	O
;	O
}	O
}	O
*	O
has_cp	*(long)
=	O
pos	long
;	O
return	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdObj	long
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_locate_uplink_by_name	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
anchor_point	*(char)
)	O
{	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
ESint32	long
i	long
,	O
n	long
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
n	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nUpTable	long
;	O
if	O
(	O
n	long
==	O
0	int
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	long
,	O
anchor_point	*(char)
,	O
EDMA_GENERAL_ID_LEN	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
n	long
)	O
return	O
-	O
1	int
;	O
return	O
i	long
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_locate_downlink_by_name	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
anchor_point	*(char)
)	O
{	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
ESint32	long
i	long
,	O
n	long
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
n	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
;	O
if	O
(	O
n	long
==	O
0	int
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	long
,	O
anchor_point	*(char)
,	O
EDMA_GENERAL_ID_LEN	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
n	long
)	O
return	O
-	O
1	int
;	O
return	O
i	long
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_locate_uplink_by_pobj	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
{	O
ESint32	long
i	long
,	O
n	long
;	O
n	long
=	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nUpTable	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
gObj	O
[	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
]	O
==	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
break	O
;	O
if	O
(	O
i	long
==	O
n	long
)	O
return	O
-	O
1	int
;	O
return	O
i	long
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_locate_downlink_by_pobj	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))->(long)
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
{	O
ESint32	long
i	long
,	O
n	long
;	O
n	long
=	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
gObj	O
[	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
]	O
==	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
break	O
;	O
if	O
(	O
i	long
==	O
n	long
)	O
return	O
-	O
1	int
;	O
return	O
i	long
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_locate_uplink_by_obj	(long,long)->(long)
(	O
OBJID	long
id	*(char)
,	O
OBJID	long
Obj	long
)	O
{	O
ESint32	long
i	long
,	O
n	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
id	*(char)
]	O
;	O
n	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nUpTable	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
==	O
Obj	long
)	O
break	O
;	O
if	O
(	O
i	long
==	O
n	long
)	O
return	O
-	O
1	int
;	O
return	O
i	long
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_locate_downlink_by_obj	(long,long)->(long)
(	O
OBJID	long
id	*(char)
,	O
OBJID	long
Obj	long
)	O
{	O
ESint32	long
i	long
,	O
n	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
id	*(char)
]	O
;	O
n	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
==	O
Obj	long
)	O
break	O
;	O
if	O
(	O
i	long
==	O
n	long
)	O
return	O
-	O
1	int
;	O
return	O
i	long
;	O
}	O
