typedef	O
struct	O
{	O
EDMAT_BUFFER	struct(long,long,*(void))
buffer	struct(long,long,*(void))
;	O
EDMAT_BUFFER	struct(long,long,*(void))
vmap	struct(long,long,*(void))
;	O
EUint32	long
cnt	long
;	O
}	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
;	O
typedef	O
struct	O
{	O
ESint32	int
type	long
;	O
ESint32	int
size	int
;	O
unsigned	O
char	O
data	array(char)
[	O
1	int
]	O
;	O
}	O
PROP_RECORD	struct(int,int,array(char))
;	O
typedef	O
struct	O
{	O
OBJID	int
virtual_id	int
;	O
EChar	char
class_name	array(char)
[	O
EDMA_CLASS_NAME_LEN	int
]	O
;	O
ESint32	int
major_version	int
;	O
ESint32	int
minor_version	int
;	O
PROP_RECORD	struct(int,int,array(char))
data	array(char)
[	O
1	int
]	O
;	O
}	O
OBJECT_RECORD	struct(int,array(char),int,int,array(struct(int,int,array(char))))
;	O
typedef	O
struct	O
{	O
OBJID	int
real_id	int
;	O
OBJID	int
virtual_id	int
;	O
}	O
VIRTUAL_ID_MAP	struct(int,int)
;	O
typedef	O
struct	O
{	O
ESint32	int
type	long
;	O
OBJID	int
src	int
;	O
OBJID	int
dst	int
;	O
ESint32	int
size	int
;	O
EChar	char
Id	int
[	O
EDMA_GENERAL_ID_LEN	int
]	O
;	O
}	O
MAPPING_RECORD	struct(int,int,int,int,array(char))
;	O
typedef	O
struct	O
{	O
EChar	char
serializer_class	array(char)
[	O
EDMA_CLASS_NAME_LEN	int
]	O
;	O
ESint32	int
major_version	int
;	O
ESint32	int
minor_version	int
;	O
ESint32	int
n_obj	int
;	O
ESint32	int
n_ap	int
;	O
unsigned	O
char	O
data	array(char)
[	O
1	int
]	O
;	O
}	O
DATA_STREAM	struct(array(char),int,int,int,int,array(char))
;	O
ESint32	int
_marshall_simple_object	(*(struct(long,long,*(void))),int)->(int)
(	O
EDMAT_BUFFER	struct(long,long,*(void))
*	O
buffer	struct(long,long,*(void))
,	O
OBJID	int
id	int
)	O
;	O
ESint32	int
_marshall_compound_object	(int,int,int)->(int)
(	O
OBJID	int
mems	int
,	O
OBJID	int
IdObj	int
,	O
OBJID	int
id	int
)	O
;	O
ESint32	int
_marshall_anchor_points	(int,int)->(int)
(	O
OBJID	int
mems	int
,	O
OBJID	int
IdObj	int
)	O
;	O
ESint32	int
_unmarshall_simple_object	(int,*(int))->(int)
(	O
OBJID	int
ms	int
,	O
OBJID	int
*	O
id	int
)	O
;	O
ESint32	int
_vmap_locate	(int,int)->(int)
(	O
OBJID	int
IdObj	int
,	O
OBJID	int
id	int
)	O
;	O
OBJID	int
_vmap_at	(int,int)->(int)
(	O
OBJID	int
IdObj	int
,	O
ESint32	int
i	int
)	O
;	O
ESint32	int
_vmap_add	(int,int)->(int)
(	O
OBJID	int
IdObj	int
,	O
OBJID	int
id	int
)	O
;	O
ESint32	int
EDMAPROC	O
MULTI_SERIALIZERmarshallOrS32	(int,int)->(int)
(	O
OBJID	int
IdObj	int
,	O
OBJID	int
id	int
)	O
{	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
;	O
CLASSID	int
cid	int
;	O
OBJID	int
ms	int
,	O
n_ap	int
;	O
ESint32	int
len	int
;	O
ESint32	int
size	int
;	O
EDMAT_BUFFER	struct(long,long,*(void))
aux	struct(long,long,*(void))
,	O
aux1	struct(long,long,*(void))
;	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
=	O
(	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
cnt	long
=	O
0	int
;	O
if	O
(	O
(	O
cid	int
=	O
edma_get_obj_class_id	(int)->(int)
(	O
id	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"[Marshall] **ERROR** Can't get class id for object %d"	*(char)
,	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
ms	int
=	O
edma_new_obj	(*(char))->(int)
(	O
"MEMORY_STREAM"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"[Marshall] **ERROR** Can't create MEMORY_STREAM object"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
aux	struct(long,long,*(void))
,	O
sizeof	O
(	O
DATA_STREAM	struct(array(char),int,int,int,int,array(char))
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
(	O
(	O
DATA_STREAM	struct(array(char),int,int,int,int,array(char))
*	O
)	O
aux	struct(long,long,*(void))
.	O
dat	*(void)
)	O
->	O
serializer_class	array(char)
,	O
"MULTI_SERIALIZER"	*(char)
)	O
;	O
(	O
(	O
DATA_STREAM	struct(array(char),int,int,int,int,array(char))
*	O
)	O
aux	struct(long,long,*(void))
.	O
dat	*(void)
)	O
->	O
major_version	int
=	O
0	int
;	O
(	O
(	O
DATA_STREAM	struct(array(char),int,int,int,int,array(char))
*	O
)	O
aux	struct(long,long,*(void))
.	O
dat	*(void)
)	O
->	O
minor_version	int
=	O
0	int
;	O
size	int
=	O
EDMA_CLASS_NAME_LEN	int
+	O
2	int
*	O
sizeof	O
(	O
ESint32	int
)	O
;	O
len	int
=	O
aux	struct(long,long,*(void))
.	O
Size	long
;	O
edma_met3	(int,*(char))->(int)
(	O
ms	int
,	O
"write"	*(char)
,	O
aux	struct(long,long,*(void))
,	O
&	O
len	int
)	O
;	O
edma_buffer_free	(*(struct(long,long,*(void))))->(int)
(	O
&	O
aux	struct(long,long,*(void))
)	O
;	O
_marshall_compound_object	(int,int,int)->(int)
(	O
ms	int
,	O
IdObj	int
,	O
id	int
)	O
;	O
n_ap	int
=	O
_marshall_anchor_points	(int,int)->(int)
(	O
ms	int
,	O
IdObj	int
)	O
;	O
edma_rprop3	(int,*(char))->(int)
(	O
ms	int
,	O
"buf"	*(char)
,	O
&	O
aux1	struct(long,long,*(void))
)	O
;	O
(	O
(	O
DATA_STREAM	struct(array(char),int,int,int,int,array(char))
*	O
)	O
aux1	struct(long,long,*(void))
.	O
dat	*(void)
)	O
->	O
n_obj	int
=	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
cnt	long
;	O
(	O
(	O
DATA_STREAM	struct(array(char),int,int,int,int,array(char))
*	O
)	O
aux1	struct(long,long,*(void))
.	O
dat	*(void)
)	O
->	O
n_ap	int
=	O
n_ap	int
;	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
aux	struct(long,long,*(void))
,	O
aux1	struct(long,long,*(void))
.	O
Size	long
)	O
;	O
memcpy	(*(void),*(void),int)->(*(void))
(	O
aux	struct(long,long,*(void))
.	O
dat	*(void)
,	O
aux1	struct(long,long,*(void))
.	O
dat	*(void)
,	O
aux1	struct(long,long,*(void))
.	O
Size	long
)	O
;	O
edma_wprop3	(int,*(char))->(int)
(	O
IdObj	int
,	O
"buffer"	*(char)
,	O
aux	struct(long,long,*(void))
)	O
;	O
edma_free_obj	(int)->(long)
(	O
ms	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
_marshall_compound_object	(int,int,int)->(int)
(	O
OBJID	int
mems	int
,	O
OBJID	int
IdObj	int
,	O
OBJID	int
id	int
)	O
{	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
;	O
ESint32	int
i	int
,	O
len	int
,	O
n	int
;	O
OBJID	int
temp_id	int
;	O
EDMAT_BUFFER	struct(long,long,*(void))
aux	struct(long,long,*(void))
;	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
=	O
(	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
if	O
(	O
(	O
_vmap_locate	(int,int)->(int)
(	O
IdObj	int
,	O
id	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
len	int
=	O
_marshall_simple_object	(*(struct(long,long,*(void))),int)->(int)
(	O
&	O
aux	struct(long,long,*(void))
,	O
id	int
)	O
;	O
_vmap_add	(int,int)->(int)
(	O
IdObj	int
,	O
id	int
)	O
;	O
edma_met3	(int,*(char))->(int)
(	O
mems	int
,	O
"write"	*(char)
,	O
aux	struct(long,long,*(void))
,	O
&	O
len	int
)	O
;	O
edma_buffer_free	(*(struct(long,long,*(void))))->(int)
(	O
&	O
aux	struct(long,long,*(void))
)	O
;	O
}	O
else	O
return	O
-	O
1	int
;	O
n	int
=	O
edma_get_obj_num_superobjects	(int)->(int)
(	O
id	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
temp_id	int
=	O
edma_get_obj_superobject	(int,int)->(int)
(	O
id	int
,	O
i	int
)	O
;	O
_marshall_compound_object	(int,int,int)->(int)
(	O
mems	int
,	O
IdObj	int
,	O
temp_id	int
)	O
;	O
}	O
n	int
=	O
edma_get_obj_num_subobjects	(int)->(int)
(	O
id	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
temp_id	int
=	O
edma_get_obj_subobject	(int,int)->(int)
(	O
id	int
,	O
i	int
)	O
;	O
_marshall_compound_object	(int,int,int)->(int)
(	O
mems	int
,	O
IdObj	int
,	O
temp_id	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
ESint32	int
_marshall_anchor_points	(int,int)->(int)
(	O
OBJID	int
mems	int
,	O
OBJID	int
IdObj	int
)	O
{	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
;	O
ESint32	int
i	int
,	O
j	int
,	O
k	int
,	O
len	int
,	O
n	int
,	O
n_objs	int
,	O
n_items	int
;	O
OBJID	int
temp_id	int
,	O
temp_id1	int
;	O
EDMAT_BUFFER	struct(long,long,*(void))
aux	struct(long,long,*(void))
;	O
VIRTUAL_ID_MAP	struct(int,int)
*	O
p	*(struct(int,int))
;	O
EChar	char
ap_name	array(char)
[	O
EDMA_GENERAL_ID_LEN	int
]	O
;	O
MAPPING_RECORD	struct(int,int,int,int,array(char))
*	O
mr	*(struct(int,int,int,int,array(char)))
;	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
=	O
(	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
p	*(struct(int,int))
=	O
(	O
VIRTUAL_ID_MAP	struct(int,int)
*	O
)	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
vmap	struct(long,long,*(void))
.	O
dat	*(void)
;	O
n_objs	int
=	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
cnt	long
;	O
n_items	int
=	O
0	int
;	O
aux	struct(long,long,*(void))
.	O
h	long
=	O
(	O
HMEM	long
)	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n_objs	int
;	O
k	int
++	O
)	O
{	O
j	int
=	O
p	*(struct(int,int))
[	O
k	int
]	O
.	O
real_id	int
;	O
n	int
=	O
edma_get_obj_num_superobjects	(int)->(int)
(	O
j	int
)	O
;	O
if	O
(	O
n	int
)	O
{	O
if	O
(	O
(	O
edma_buffer_realloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
aux	struct(long,long,*(void))
,	O
sizeof	O
(	O
MAPPING_RECORD	struct(int,int,int,int,array(char))
)	O
*	O
(	O
n_items	int
+	O
n	int
)	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"[%s] **ERROR** Can't realloc buffer"	*(char)
,	O
__FUNCTION__	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
mr	*(struct(int,int,int,int,array(char)))
=	O
(	O
MAPPING_RECORD	struct(int,int,int,int,array(char))
*	O
)	O
aux	struct(long,long,*(void))
.	O
dat	*(void)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
temp_id	int
=	O
edma_get_obj_superobject	(int,int)->(int)
(	O
j	int
,	O
i	int
)	O
;	O
temp_id1	int
=	O
_vmap_locate	(int,int)->(int)
(	O
IdObj	int
,	O
temp_id	int
)	O
;	O
edma_get_obj_superobject_ap	(int,int,*(char))->(int)
(	O
j	int
,	O
i	int
,	O
ap_name	array(char)
)	O
;	O
mr	*(struct(int,int,int,int,array(char)))
[	O
n_items	int
]	O
.	O
type	long
=	O
SUPER	int
;	O
mr	*(struct(int,int,int,int,array(char)))
[	O
n_items	int
]	O
.	O
src	int
=	O
k	int
;	O
mr	*(struct(int,int,int,int,array(char)))
[	O
n_items	int
]	O
.	O
dst	int
=	O
temp_id1	int
;	O
mr	*(struct(int,int,int,int,array(char)))
[	O
n_items	int
]	O
.	O
size	int
=	O
strlen	(*(char))->(int)
(	O
ap_name	array(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
mr	*(struct(int,int,int,int,array(char)))
[	O
n_items	int
]	O
.	O
Id	int
,	O
ap_name	array(char)
)	O
;	O
n_items	int
++	O
;	O
}	O
n	int
=	O
edma_get_obj_num_subobjects	(int)->(int)
(	O
j	int
)	O
;	O
if	O
(	O
n	int
)	O
{	O
if	O
(	O
(	O
edma_buffer_realloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
aux	struct(long,long,*(void))
,	O
sizeof	O
(	O
MAPPING_RECORD	struct(int,int,int,int,array(char))
)	O
*	O
(	O
n_items	int
+	O
n	int
)	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"[%s] **ERROR** Can't realloc buffer"	*(char)
,	O
__FUNCTION__	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
mr	*(struct(int,int,int,int,array(char)))
=	O
(	O
MAPPING_RECORD	struct(int,int,int,int,array(char))
*	O
)	O
aux	struct(long,long,*(void))
.	O
dat	*(void)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
temp_id	int
=	O
edma_get_obj_subobject	(int,int)->(int)
(	O
j	int
,	O
i	int
)	O
;	O
temp_id1	int
=	O
_vmap_locate	(int,int)->(int)
(	O
IdObj	int
,	O
temp_id	int
)	O
;	O
edma_get_obj_subobject_ap	(int,int,*(char))->(int)
(	O
j	int
,	O
i	int
,	O
ap_name	array(char)
)	O
;	O
mr	*(struct(int,int,int,int,array(char)))
[	O
n_items	int
]	O
.	O
type	long
=	O
SUB	int
;	O
mr	*(struct(int,int,int,int,array(char)))
[	O
n_items	int
]	O
.	O
src	int
=	O
k	int
;	O
mr	*(struct(int,int,int,int,array(char)))
[	O
n_items	int
]	O
.	O
dst	int
=	O
temp_id1	int
;	O
mr	*(struct(int,int,int,int,array(char)))
[	O
n_items	int
]	O
.	O
size	int
=	O
strlen	(*(char))->(int)
(	O
ap_name	array(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
mr	*(struct(int,int,int,int,array(char)))
[	O
n_items	int
]	O
.	O
Id	int
,	O
ap_name	array(char)
)	O
;	O
n_items	int
++	O
;	O
}	O
}	O
len	int
=	O
aux	struct(long,long,*(void))
.	O
Size	long
;	O
edma_met3	(int,*(char))->(int)
(	O
mems	int
,	O
"write"	*(char)
,	O
aux	struct(long,long,*(void))
,	O
&	O
len	int
)	O
;	O
return	O
n_items	int
;	O
}	O
ESint32	int
_marshall_simple_object	(*(struct(long,long,*(void))),int)->(int)
(	O
EDMAT_BUFFER	struct(long,long,*(void))
*	O
buffer	struct(long,long,*(void))
,	O
OBJID	int
id	int
)	O
{	O
CLASSID	int
cid	int
;	O
ESint32	int
n_prop	int
;	O
unsigned	O
char	O
*	O
data	array(char)
;	O
EUint32	long
type	long
,	O
size	int
,	O
new_size	long
,	O
old_size	long
,	O
i	int
;	O
EChar	char
prop_name	array(char)
[	O
EDMA_PROP_NAME_LEN	O
]	O
;	O
EDMAT_BUFFER	struct(long,long,*(void))
aux	struct(long,long,*(void))
;	O
unsigned	O
char	O
base_type	array(char)
[	O
8	int
]	O
;	O
PROP_RECORD	struct(int,int,array(char))
*	O
item	*(struct(int,int,array(char)))
;	O
if	O
(	O
(	O
cid	int
=	O
edma_get_obj_class_id	(int)->(int)
(	O
id	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"[_marshall_simple_object]*ERROR* Can't get class id for object %d"	*(char)
,	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
n_prop	int
=	O
edma_get_prop_num	(int)->(int)
(	O
cid	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"[_marshall_simple_object]*ERROR* Can't get number of properties "	*(char)
"for class id %ld"	*(char)
,	O
cid	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(int)
(	O
buffer	struct(long,long,*(void))
,	O
sizeof	O
(	O
OBJECT_RECORD	struct(int,array(char),int,int,array(struct(int,int,array(char))))
)	O
)	O
;	O
edma_get_class_name	(int,*(char))->(int)
(	O
cid	int
,	O
(	O
(	O
OBJECT_RECORD	struct(int,array(char),int,int,array(struct(int,int,array(char))))
*	O
)	O
buffer	struct(long,long,*(void))
->	O
dat	*(void)
)	O
->	O
class_name	array(char)
)	O
;	O
new_size	long
=	O
0	int
;	O
old_size	long
=	O
EDMA_CLASS_NAME_LEN	int
+	O
2	int
*	O
sizeof	O
(	O
ESint32	int
)	O
+	O
sizeof	O
(	O
OBJID	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_prop	int
;	O
i	int
++	O
)	O
{	O
edma_get_prop_name	(int,long,*(char))->(int)
(	O
cid	int
,	O
i	int
,	O
prop_name	array(char)
)	O
;	O
type	long
=	O
edma_get_prop_type_id	(int,long)->(int)
(	O
cid	int
,	O
i	int
)	O
;	O
size	int
=	O
edma_get_type_size	(long)->(int)
(	O
type	long
)	O
;	O
switch	O
(	O
type	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
edma_rprop1	(int,long)->(*(void))
(	O
id	int
,	O
i	int
,	O
&	O
aux	struct(long,long,*(void))
)	O
;	O
size	int
=	O
aux	struct(long,long,*(void))
.	O
Size	long
;	O
break	O
;	O
case	O
DT_EZSTRING	int
:	O
size	int
=	O
edma_prop1_size	(int,long)->(long)
(	O
id	int
,	O
i	int
)	O
+	O
1	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
new_size	long
=	O
old_size	long
+	O
sizeof	O
(	O
ESint32	int
)	O
*	O
2	int
+	O
size	int
;	O
edma_buffer_realloc	(*(struct(long,long,*(void))),long)->(int)
(	O
buffer	struct(long,long,*(void))
,	O
new_size	long
)	O
;	O
item	*(struct(int,int,array(char)))
=	O
(	O
PROP_RECORD	struct(int,int,array(char))
*	O
)	O
(	O
(	O
EPByte	*(char)
)	O
buffer	struct(long,long,*(void))
->	O
dat	*(void)
+	O
old_size	long
)	O
;	O
item	*(struct(int,int,array(char)))
->	O
type	long
=	O
type	long
;	O
item	*(struct(int,int,array(char)))
->	O
size	int
=	O
size	int
;	O
switch	O
(	O
type	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
data	array(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
aux	struct(long,long,*(void))
.	O
dat	*(void)
;	O
memcpy	(*(void),*(void),int)->(*(void))
(	O
item	*(struct(int,int,array(char)))
->	O
data	array(char)
,	O
data	array(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
DT_EZSTRING	int
:	O
memset	(*(void),int,int)->(*(void))
(	O
item	*(struct(int,int,array(char)))
->	O
data	array(char)
,	O
0	int
,	O
item	*(struct(int,int,array(char)))
->	O
size	int
)	O
;	O
edma_rprop1	(int,long)->(*(void))
(	O
id	int
,	O
i	int
,	O
item	*(struct(int,int,array(char)))
->	O
data	array(char)
)	O
;	O
break	O
;	O
default	O
:	O
edma_rprop1	(int,long)->(*(void))
(	O
id	int
,	O
i	int
,	O
&	O
base_type	array(char)
)	O
;	O
data	array(char)
=	O
base_type	array(char)
;	O
memcpy	(*(void),*(void),int)->(*(void))
(	O
item	*(struct(int,int,array(char)))
->	O
data	array(char)
,	O
data	array(char)
,	O
size	int
)	O
;	O
break	O
;	O
}	O
old_size	long
=	O
new_size	long
;	O
}	O
printf	(*(char))->(int)
(	O
"Total size is: %d\n"	*(char)
,	O
old_size	long
)	O
;	O
return	O
old_size	long
;	O
}	O
ESint32	int
EDMAPROC	O
MULTI_SERIALIZERunmarshallsOrS32	(int,*(int))->(int)
(	O
OBJID	int
IdObj	int
,	O
OBJID	int
*	O
id	int
)	O
{	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
;	O
DATA_STREAM	struct(array(char),int,int,int,int,array(char))
*	O
header	*(struct(array(char),int,int,int,int,array(char)))
;	O
ESint32	int
i	int
,	O
len	int
;	O
OBJID	int
ms	int
,	O
temp_id	int
;	O
OBJID	int
src_id	int
,	O
dst_id	int
;	O
EDMAT_BUFFER	struct(long,long,*(void))
aux	struct(long,long,*(void))
;	O
MAPPING_RECORD	struct(int,int,int,int,array(char))
*	O
mr	*(struct(int,int,int,int,array(char)))
;	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
=	O
(	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
edma_buffer_free	(*(struct(long,long,*(void))))->(int)
(	O
&	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
vmap	struct(long,long,*(void))
)	O
;	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
cnt	long
=	O
0	int
;	O
if	O
(	O
(	O
ms	int
=	O
edma_new_obj	(*(char))->(int)
(	O
"MEMORY_STREAM"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"[Unmarshall] Can't create memory stream"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_rprop3	(int,*(char))->(int)
(	O
IdObj	int
,	O
"buffer"	*(char)
,	O
&	O
aux	struct(long,long,*(void))
)	O
;	O
edma_wprop3	(int,*(char))->(int)
(	O
ms	int
,	O
"buf"	*(char)
,	O
aux	struct(long,long,*(void))
)	O
;	O
len	int
=	O
sizeof	O
(	O
DATA_STREAM	struct(array(char),int,int,int,int,array(char))
)	O
;	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
aux	struct(long,long,*(void))
,	O
len	int
)	O
;	O
edma_met3	(int,*(char))->(int)
(	O
ms	int
,	O
"read"	*(char)
,	O
&	O
aux	struct(long,long,*(void))
,	O
&	O
len	int
)	O
;	O
header	*(struct(array(char),int,int,int,int,array(char)))
=	O
(	O
DATA_STREAM	struct(array(char),int,int,int,int,array(char))
*	O
)	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
buffer	struct(long,long,*(void))
.	O
dat	*(void)
;	O
edma_log	()->(int)
(	O
IdObj	int
,	O
"Stream serialized using %s v %d.%d"	*(char)
,	O
header	*(struct(array(char),int,int,int,int,array(char)))
->	O
serializer_class	array(char)
,	O
header	*(struct(array(char),int,int,int,int,array(char)))
->	O
major_version	int
,	O
header	*(struct(array(char),int,int,int,int,array(char)))
->	O
minor_version	int
)	O
;	O
edma_log	()->(int)
(	O
IdObj	int
,	O
"Unmarshalling compound object. %d subobjects and %d ap rules"	*(char)
,	O
header	*(struct(array(char),int,int,int,int,array(char)))
->	O
n_obj	int
,	O
header	*(struct(array(char),int,int,int,int,array(char)))
->	O
n_ap	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
header	*(struct(array(char),int,int,int,int,array(char)))
->	O
n_obj	int
;	O
i	int
++	O
)	O
{	O
_unmarshall_simple_object	(int,*(int))->(int)
(	O
ms	int
,	O
&	O
temp_id	int
)	O
;	O
_vmap_add	(int,int)->(int)
(	O
IdObj	int
,	O
temp_id	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
header	*(struct(array(char),int,int,int,int,array(char)))
->	O
n_ap	int
;	O
i	int
++	O
)	O
{	O
len	int
=	O
sizeof	O
(	O
MAPPING_RECORD	struct(int,int,int,int,array(char))
)	O
;	O
edma_met3	(int,*(char))->(int)
(	O
ms	int
,	O
"read"	*(char)
,	O
&	O
aux	struct(long,long,*(void))
,	O
&	O
len	int
)	O
;	O
mr	*(struct(int,int,int,int,array(char)))
=	O
(	O
MAPPING_RECORD	struct(int,int,int,int,array(char))
*	O
)	O
aux	struct(long,long,*(void))
.	O
dat	*(void)
;	O
src_id	int
=	O
_vmap_at	(int,int)->(int)
(	O
IdObj	int
,	O
mr	*(struct(int,int,int,int,array(char)))
->	O
src	int
)	O
;	O
dst_id	int
=	O
_vmap_at	(int,int)->(int)
(	O
IdObj	int
,	O
mr	*(struct(int,int,int,int,array(char)))
->	O
dst	int
)	O
;	O
switch	O
(	O
mr	*(struct(int,int,int,int,array(char)))
->	O
type	long
)	O
{	O
case	O
SUPER	int
:	O
edma_add_superobject	(int,int,*(char))->(int)
(	O
src_id	int
,	O
dst_id	int
,	O
mr	*(struct(int,int,int,int,array(char)))
->	O
Id	int
)	O
;	O
break	O
;	O
case	O
SUB	int
:	O
edma_add_subobject	(int,int,*(char))->(int)
(	O
src_id	int
,	O
dst_id	int
,	O
mr	*(struct(int,int,int,int,array(char)))
->	O
Id	int
)	O
;	O
break	O
;	O
}	O
edma_buffer_free	(*(struct(long,long,*(void))))->(int)
(	O
&	O
aux	struct(long,long,*(void))
)	O
;	O
}	O
*	O
id	int
=	O
_vmap_at	(int,int)->(int)
(	O
IdObj	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
_unmarshall_simple_object	(int,*(int))->(int)
(	O
OBJID	int
ms	int
,	O
OBJID	int
*	O
id	int
)	O
{	O
CLASSID	int
cid	int
;	O
EDMAT_BUFFER	struct(long,long,*(void))
aux	struct(long,long,*(void))
,	O
data	array(char)
;	O
ESint32	int
i	int
,	O
len	int
,	O
n_prop	int
,	O
type	long
;	O
OBJECT_RECORD	struct(int,array(char),int,int,array(struct(int,int,array(char))))
*	O
obj	*(struct(int,array(char),int,int,array(struct(int,int,array(char)))))
;	O
PROP_RECORD	struct(int,int,array(char))
*	O
item	*(struct(int,int,array(char)))
;	O
EChar	char
cname	array(char)
[	O
1024	int
]	O
;	O
len	int
=	O
sizeof	O
(	O
OBJECT_RECORD	struct(int,array(char),int,int,array(struct(int,int,array(char))))
)	O
-	O
sizeof	O
(	O
PROP_RECORD	struct(int,int,array(char))
)	O
;	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
aux	struct(long,long,*(void))
,	O
len	int
)	O
;	O
edma_met3	(int,*(char))->(int)
(	O
ms	int
,	O
"read"	*(char)
,	O
&	O
aux	struct(long,long,*(void))
,	O
&	O
len	int
)	O
;	O
obj	*(struct(int,array(char),int,int,array(struct(int,int,array(char)))))
=	O
(	O
OBJECT_RECORD	struct(int,array(char),int,int,array(struct(int,int,array(char))))
*	O
)	O
aux	struct(long,long,*(void))
.	O
dat	*(void)
;	O
if	O
(	O
(	O
cid	int
=	O
edma_get_class_id	(*(char))->(int)
(	O
obj	*(struct(int,array(char),int,int,array(struct(int,int,array(char)))))
->	O
class_name	array(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"[%s] Class '%s' doesn't exist"	*(char)
,	O
__FUNCTION__	O
,	O
obj	*(struct(int,array(char),int,int,array(struct(int,int,array(char)))))
->	O
class_name	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_load_class_int	(int)->(int)
(	O
cid	int
)	O
;	O
if	O
(	O
(	O
n_prop	int
=	O
edma_get_prop_num	(int)->(int)
(	O
cid	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"[%s] ** ERROR ** Can't get number of properties "	*(char)
"for class id %ld"	*(char)
,	O
__FUNCTION__	O
,	O
cid	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
*	O
id	int
=	O
edma_new_simple_obj	(*(char),*(void))->(int)
(	O
obj	*(struct(int,array(char),int,int,array(struct(int,int,array(char)))))
->	O
class_name	array(char)
,	O
NULL	O
)	O
;	O
edma_printf	(*(char))->(long)
(	O
"Received class id: %d. Creating objecto of class '%s'"	*(char)
,	O
cid	int
,	O
obj	*(struct(int,array(char),int,int,array(struct(int,int,array(char)))))
->	O
class_name	array(char)
)	O
;	O
edma_buffer_free	(*(struct(long,long,*(void))))->(int)
(	O
&	O
aux	struct(long,long,*(void))
)	O
;	O
printf	(*(char))->(int)
(	O
"Unmarshalling object of class %s (%d props)\n"	*(char)
,	O
obj	*(struct(int,array(char),int,int,array(struct(int,int,array(char)))))
->	O
class_name	array(char)
,	O
n_prop	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_prop	int
;	O
i	int
++	O
)	O
{	O
type	long
=	O
edma_get_prop_type_id	(int,long)->(int)
(	O
cid	int
,	O
i	int
)	O
;	O
len	int
=	O
sizeof	O
(	O
ESint32	int
)	O
*	O
2	int
;	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
aux	struct(long,long,*(void))
,	O
len	int
)	O
;	O
edma_met3	(int,*(char))->(int)
(	O
ms	int
,	O
"read"	*(char)
,	O
&	O
aux	struct(long,long,*(void))
,	O
&	O
len	int
)	O
;	O
item	*(struct(int,int,array(char)))
=	O
(	O
PROP_RECORD	struct(int,int,array(char))
*	O
)	O
aux	struct(long,long,*(void))
.	O
dat	*(void)
;	O
printf	(*(char))->(int)
(	O
"++ Property %d %d bytes\n"	*(char)
,	O
i	int
,	O
item	*(struct(int,int,array(char)))
->	O
size	int
)	O
;	O
if	O
(	O
type	long
!=	O
item	*(struct(int,int,array(char)))
->	O
type	long
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"[%s] Type missmatch in property %d (received:%d expected:%d)"	*(char)
,	O
__FUNCTION__	O
,	O
i	int
,	O
item	*(struct(int,int,array(char)))
->	O
type	long
,	O
type	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
len	int
=	O
item	*(struct(int,int,array(char)))
->	O
size	int
;	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
data	array(char)
,	O
len	int
)	O
;	O
edma_met3	(int,*(char))->(int)
(	O
ms	int
,	O
"read"	*(char)
,	O
&	O
data	array(char)
,	O
&	O
len	int
)	O
;	O
switch	O
(	O
type	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
_edma_wprop1_pargs	(int,long,*(void))->(*(void))
(	O
*	O
id	int
,	O
i	int
,	O
&	O
data	array(char)
)	O
;	O
break	O
;	O
case	O
DT_EZSTRING	int
:	O
edma_wprop1	(int,long)->(*(void))
(	O
*	O
id	int
,	O
i	int
,	O
data	array(char)
.	O
dat	*(void)
)	O
;	O
break	O
;	O
default	O
:	O
_edma_wprop1_pargs	(int,long,*(void))->(*(void))
(	O
*	O
id	int
,	O
i	int
,	O
data	array(char)
.	O
dat	*(void)
)	O
;	O
edma_buffer_free	(*(struct(long,long,*(void))))->(int)
(	O
&	O
data	array(char)
)	O
;	O
}	O
edma_buffer_free	(*(struct(long,long,*(void))))->(int)
(	O
&	O
aux	struct(long,long,*(void))
)	O
;	O
}	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
MULTI_SERIALIZERsaveZrS32	(int,*(char))->(int)
(	O
OBJID	int
IdObj	int
,	O
EPChar	*(char)
fname	*(char)
)	O
{	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
;	O
OBJID	int
id	int
;	O
ESint32	int
len	int
;	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
=	O
(	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
if	O
(	O
(	O
id	int
=	O
edma_new_obj	(*(char))->(int)
(	O
"NFILE"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"[ERROR] Can't create 'NFILE' object"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
edma_met3	(int,*(char))->(int)
(	O
id	int
,	O
"open"	*(char)
,	O
fname	*(char)
,	O
"wb"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Can't open %s file to save data"	*(char)
,	O
fname	*(char)
)	O
;	O
edma_free_obj	(int)->(long)
(	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
len	int
=	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
buffer	struct(long,long,*(void))
.	O
Size	long
;	O
if	O
(	O
(	O
edma_met3	(int,*(char))->(int)
(	O
id	int
,	O
"write"	*(char)
,	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
buffer	struct(long,long,*(void))
,	O
&	O
len	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Can't write data to file"	*(char)
)	O
;	O
edma_free_obj	(int)->(long)
(	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_met3	(int,*(char))->(int)
(	O
id	int
,	O
"close"	*(char)
)	O
;	O
edma_free_obj	(int)->(long)
(	O
id	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
MULTI_SERIALIZERloadZrS32	(int,*(char))->(int)
(	O
OBJID	int
IdObj	int
,	O
EPChar	*(char)
fname	*(char)
)	O
{	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
;	O
OBJID	int
id	int
;	O
ESint32	int
len	int
;	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
=	O
(	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
if	O
(	O
(	O
id	int
=	O
edma_new_obj	(*(char))->(int)
(	O
"NFILE"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"[ERROR] Can't create 'NFILE' object"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
edma_met3	(int,*(char))->(int)
(	O
id	int
,	O
"open"	*(char)
,	O
fname	*(char)
,	O
"rb"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Can't open %s file to read data"	*(char)
,	O
fname	*(char)
)	O
;	O
edma_free_obj	(int)->(long)
(	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
len	int
=	O
(	O
ESint32	int
)	O
edma_smet3	(*(char),*(char))->(*(void))
(	O
"FILESYSTEM"	*(char)
,	O
"GetFileSize"	*(char)
,	O
fname	*(char)
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"[INFO] About to read %ld bytes from file %s"	*(char)
,	O
len	int
,	O
fname	*(char)
)	O
;	O
if	O
(	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
buffer	struct(long,long,*(void))
.	O
dat	*(void)
)	O
edma_buffer_free	(*(struct(long,long,*(void))))->(int)
(	O
&	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
buffer	struct(long,long,*(void))
)	O
;	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
buffer	struct(long,long,*(void))
,	O
len	int
)	O
;	O
if	O
(	O
(	O
edma_met3	(int,*(char))->(int)
(	O
id	int
,	O
"read"	*(char)
,	O
&	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
buffer	struct(long,long,*(void))
,	O
&	O
len	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Can't write data to file"	*(char)
)	O
;	O
edma_free_obj	(int)->(long)
(	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_met3	(int,*(char))->(int)
(	O
id	int
,	O
"close"	*(char)
)	O
;	O
edma_free_obj	(int)->(long)
(	O
id	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
_vmap_locate	(int,int)->(int)
(	O
OBJID	int
IdObj	int
,	O
OBJID	int
id	int
)	O
{	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
;	O
ESint32	int
n	int
,	O
i	int
;	O
VIRTUAL_ID_MAP	struct(int,int)
*	O
p	*(struct(int,int))
;	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
=	O
(	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
p	*(struct(int,int))
=	O
(	O
VIRTUAL_ID_MAP	struct(int,int)
*	O
)	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
vmap	struct(long,long,*(void))
.	O
dat	*(void)
;	O
n	int
=	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
cnt	long
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
if	O
(	O
p	*(struct(int,int))
[	O
i	int
]	O
.	O
real_id	int
==	O
id	int
)	O
{	O
return	O
i	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
OBJID	int
_vmap_at	(int,int)->(int)
(	O
OBJID	int
IdObj	int
,	O
ESint32	int
i	int
)	O
{	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
;	O
VIRTUAL_ID_MAP	struct(int,int)
*	O
p	*(struct(int,int))
;	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
=	O
(	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
p	*(struct(int,int))
=	O
(	O
VIRTUAL_ID_MAP	struct(int,int)
*	O
)	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
vmap	struct(long,long,*(void))
.	O
dat	*(void)
;	O
if	O
(	O
i	int
>=	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
cnt	long
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"[%s] Index out of range.... Data may be corrupted"	*(char)
,	O
__FUNCTION__	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
p	*(struct(int,int))
[	O
i	int
]	O
.	O
real_id	int
;	O
}	O
ESint32	int
_vmap_add	(int,int)->(int)
(	O
OBJID	int
IdObj	int
,	O
OBJID	int
id	int
)	O
{	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
;	O
ESint32	int
n	int
;	O
VIRTUAL_ID_MAP	struct(int,int)
*	O
p	*(struct(int,int))
;	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
=	O
(	O
DtMULTI_SERIALIZER	struct(struct(long,long,*(void)),struct(long,long,*(void)),long)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
n	int
=	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
cnt	long
;	O
if	O
(	O
(	O
_vmap_locate	(int,int)->(int)
(	O
IdObj	int
,	O
id	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
edma_buffer_realloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
vmap	struct(long,long,*(void))
,	O
sizeof	O
(	O
VIRTUAL_ID_MAP	struct(int,int)
)	O
*	O
(	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
cnt	long
+	O
1	int
)	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"(_vmap_add) ** ERROR **. Can't alloc memory"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
p	*(struct(int,int))
=	O
(	O
VIRTUAL_ID_MAP	struct(int,int)
*	O
)	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
vmap	struct(long,long,*(void))
.	O
dat	*(void)
;	O
p	*(struct(int,int))
[	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
cnt	long
]	O
.	O
real_id	int
=	O
id	int
;	O
p	*(struct(int,int))
[	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
cnt	long
]	O
.	O
virtual_id	int
=	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
cnt	long
;	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
cnt	long
++	O
;	O
return	O
(	O
m	*(struct(struct(long,long,*(void)),struct(long,long,*(void)),long))
->	O
cnt	long
-	O
1	int
)	O
;	O
}	O
return	O
-	O
1	int
;	O
}	O
