struct	O
hash_entry	O
{	O
struct	O
hash_entry	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
const	O
char	O
*	O
string	*(char)
;	O
unsigned	O
long	O
hash	long
;	O
void	O
*	O
data	*(void)
;	O
}	O
;	O
struct	O
hash_control	O
{	O
struct	O
hash_entry	O
*	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
;	O
unsigned	O
int	O
size	int
;	O
struct	O
obstack	O
memory	*(void)
;	O
}	O
;	O
static	O
unsigned	O
long	O
gas_hash_table_size	O
=	O
65537	int
;	O
void	O
set_gas_hash_table_size	O
(	O
unsigned	O
long	O
size	int
)	O
{	O
gas_hash_table_size	O
=	O
bfd_hash_set_default_size	(long)->(long)
(	O
size	int
)	O
;	O
}	O
struct	O
hash_control	O
*	O
hash_new_sized	O
(	O
unsigned	O
long	O
size	int
)	O
{	O
unsigned	O
long	O
alloc	O
;	O
struct	O
hash_control	O
*	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
XNEW	O
(	O
struct	O
hash_control	O
)	O
;	O
obstack_begin	O
(	O
&	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
->	O
memory	*(void)
,	O
chunksize	O
)	O
;	O
alloc	O
=	O
size	int
*	O
sizeof	O
(	O
struct	O
hash_entry	O
*	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
=	O
(	O
struct	O
hash_entry	O
*	O
*	O
)	O
obstack_alloc	O
(	O
&	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
->	O
memory	*(void)
,	O
alloc	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
0	int
,	O
alloc	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
->	O
size	int
=	O
size	int
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
struct	O
hash_control	O
*	O
hash_new	O
(	O
void	O
)	O
{	O
return	O
hash_new_sized	O
(	O
gas_hash_table_size	O
)	O
;	O
}	O
void	O
hash_die	O
(	O
struct	O
hash_control	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
{	O
obstack_free	O
(	O
&	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
->	O
memory	*(void)
,	O
0	int
)	O
;	O
free	(*(void))->(void)
(	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
;	O
}	O
static	O
struct	O
hash_entry	O
*	O
hash_lookup	O
(	O
struct	O
hash_control	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
const	O
char	O
*	O
key	O
,	O
size_t	long
len	long
,	O
struct	O
hash_entry	O
*	O
*	O
*	O
plist	O
,	O
unsigned	O
long	O
*	O
phash	O
)	O
{	O
unsigned	O
long	O
hash	long
;	O
size_t	long
n	O
;	O
unsigned	O
int	O
c	O
;	O
unsigned	O
int	O
hindex	O
;	O
struct	O
hash_entry	O
*	O
*	O
list	O
;	O
struct	O
hash_entry	O
*	O
p	*(void)
;	O
struct	O
hash_entry	O
*	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
hash	long
=	O
0	int
;	O
for	O
(	O
n	O
=	O
0	int
;	O
n	O
<	O
len	long
;	O
n	O
++	O
)	O
{	O
c	O
=	O
key	O
[	O
n	O
]	O
;	O
hash	long
+=	O
c	O
+	O
(	O
c	O
<<	O
17	int
)	O
;	O
hash	long
^=	O
hash	long
>>	O
2	int
;	O
}	O
hash	long
+=	O
len	long
+	O
(	O
len	long
<<	O
17	int
)	O
;	O
hash	long
^=	O
hash	long
>>	O
2	int
;	O
if	O
(	O
phash	O
!=	O
NULL	O
)	O
*	O
phash	O
=	O
hash	long
;	O
hindex	O
=	O
hash	long
%	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
->	O
size	int
;	O
list	O
=	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
+	O
hindex	O
;	O
if	O
(	O
plist	O
!=	O
NULL	O
)	O
*	O
plist	O
=	O
list	O
;	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
NULL	O
;	O
for	O
(	O
p	*(void)
=	O
*	O
list	O
;	O
p	*(void)
!=	O
NULL	O
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
p	*(void)
->	O
hash	long
==	O
hash	long
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(void)
->	O
string	*(char)
,	O
key	O
,	O
len	long
)	O
==	O
0	int
&&	O
p	*(void)
->	O
string	*(char)
[	O
len	long
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
!=	O
NULL	O
)	O
{	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
*	O
list	O
;	O
*	O
list	O
=	O
p	*(void)
;	O
}	O
return	O
p	*(void)
;	O
}	O
}	O
prev	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
p	*(void)
;	O
}	O
return	O
NULL	O
;	O
}	O
const	O
char	O
*	O
hash_insert	O
(	O
struct	O
hash_control	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
const	O
char	O
*	O
key	O
,	O
void	O
*	O
val	int
)	O
{	O
struct	O
hash_entry	O
*	O
p	*(void)
;	O
struct	O
hash_entry	O
*	O
*	O
list	O
;	O
unsigned	O
long	O
hash	long
;	O
p	*(void)
=	O
hash_lookup	O
(	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
key	O
,	O
strlen	(*(char))->(long)
(	O
key	O
)	O
,	O
&	O
list	O
,	O
&	O
hash	long
)	O
;	O
if	O
(	O
p	*(void)
!=	O
NULL	O
)	O
return	O
"exists"	*(char)
;	O
p	*(void)
=	O
(	O
struct	O
hash_entry	O
*	O
)	O
obstack_alloc	O
(	O
&	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
->	O
memory	*(void)
,	O
sizeof	O
(	O
*	O
p	*(void)
)	O
)	O
;	O
p	*(void)
->	O
string	*(char)
=	O
key	O
;	O
p	*(void)
->	O
hash	long
=	O
hash	long
;	O
p	*(void)
->	O
data	*(void)
=	O
val	int
;	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
*	O
list	O
;	O
*	O
list	O
=	O
p	*(void)
;	O
return	O
NULL	O
;	O
}	O
const	O
char	O
*	O
hash_jam	O
(	O
struct	O
hash_control	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
const	O
char	O
*	O
key	O
,	O
void	O
*	O
val	int
)	O
{	O
struct	O
hash_entry	O
*	O
p	*(void)
;	O
struct	O
hash_entry	O
*	O
*	O
list	O
;	O
unsigned	O
long	O
hash	long
;	O
p	*(void)
=	O
hash_lookup	O
(	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
key	O
,	O
strlen	(*(char))->(long)
(	O
key	O
)	O
,	O
&	O
list	O
,	O
&	O
hash	long
)	O
;	O
if	O
(	O
p	*(void)
!=	O
NULL	O
)	O
{	O
p	*(void)
->	O
data	*(void)
=	O
val	int
;	O
}	O
else	O
{	O
p	*(void)
=	O
(	O
struct	O
hash_entry	O
*	O
)	O
obstack_alloc	O
(	O
&	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
->	O
memory	*(void)
,	O
sizeof	O
(	O
*	O
p	*(void)
)	O
)	O
;	O
p	*(void)
->	O
string	*(char)
=	O
key	O
;	O
p	*(void)
->	O
hash	long
=	O
hash	long
;	O
p	*(void)
->	O
data	*(void)
=	O
val	int
;	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
*	O
list	O
;	O
*	O
list	O
=	O
p	*(void)
;	O
}	O
return	O
NULL	O
;	O
}	O
void	O
*	O
hash_replace	O
(	O
struct	O
hash_control	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
const	O
char	O
*	O
key	O
,	O
void	O
*	O
value	long
)	O
{	O
struct	O
hash_entry	O
*	O
p	*(void)
;	O
void	O
*	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
p	*(void)
=	O
hash_lookup	O
(	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
key	O
,	O
strlen	(*(char))->(long)
(	O
key	O
)	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
p	*(void)
->	O
data	*(void)
;	O
p	*(void)
->	O
data	*(void)
=	O
value	long
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
void	O
*	O
hash_find	O
(	O
struct	O
hash_control	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
const	O
char	O
*	O
key	O
)	O
{	O
struct	O
hash_entry	O
*	O
p	*(void)
;	O
p	*(void)
=	O
hash_lookup	O
(	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
key	O
,	O
strlen	(*(char))->(long)
(	O
key	O
)	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
p	*(void)
->	O
data	*(void)
;	O
}	O
void	O
*	O
hash_find_n	O
(	O
struct	O
hash_control	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
const	O
char	O
*	O
key	O
,	O
size_t	long
len	long
)	O
{	O
struct	O
hash_entry	O
*	O
p	*(void)
;	O
p	*(void)
=	O
hash_lookup	O
(	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
key	O
,	O
len	long
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
p	*(void)
->	O
data	*(void)
;	O
}	O
void	O
*	O
hash_delete	O
(	O
struct	O
hash_control	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
const	O
char	O
*	O
key	O
,	O
int	O
freeme	O
)	O
{	O
struct	O
hash_entry	O
*	O
p	*(void)
;	O
struct	O
hash_entry	O
*	O
*	O
list	O
;	O
p	*(void)
=	O
hash_lookup	O
(	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
key	O
,	O
strlen	(*(char))->(long)
(	O
key	O
)	O
,	O
&	O
list	O
,	O
NULL	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
p	*(void)
!=	O
*	O
list	O
)	O
abort	()->(void)
(	O
)	O
;	O
*	O
list	O
=	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
if	O
(	O
freeme	O
)	O
obstack_free	O
(	O
&	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
->	O
memory	*(void)
,	O
p	*(void)
)	O
;	O
return	O
p	*(void)
->	O
data	*(void)
;	O
}	O
void	O
hash_traverse	O
(	O
struct	O
hash_control	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
void	O
(	O
*	O
pfn	O
)	O
(	O
const	O
char	O
*	O
key	O
,	O
void	O
*	O
value	long
)	O
)	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
->	O
size	int
;	O
++	O
i	*(struct)
)	O
{	O
struct	O
hash_entry	O
*	O
p	*(void)
;	O
for	O
(	O
p	*(void)
=	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
[	O
i	*(struct)
]	O
;	O
p	*(void)
!=	O
NULL	O
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
(	O
*	O
pfn	O
)	O
(	O
p	*(void)
->	O
string	*(char)
,	O
p	*(void)
->	O
data	*(void)
)	O
;	O
}	O
}	O
void	O
hash_print_statistics	O
(	O
FILE	struct
*	O
f	O
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	*(char)
ATTRIBUTE_UNUSED	O
,	O
struct	O
hash_control	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
ATTRIBUTE_UNUSED	O
)	O
{	O
}	O
