static	O
void	O
memory_out	()->(void)
(	O
)	O
{	O
write	()->(int)
(	O
2	int
,	O
"virtual memory exhausted\n"	*(char)
,	O
25	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
static	O
char	O
*	O
xmalloc	(int)->(*(char))
(	O
size	int
)	O
unsigned	O
size	int
;	O
{	O
register	O
char	O
*	O
tem	*(char)
=	O
malloc	(long)->(*(void))
(	O
size	int
)	O
;	O
if	O
(	O
!	O
tem	*(char)
)	O
memory_out	()->(void)
(	O
)	O
;	O
return	O
tem	*(char)
;	O
}	O
static	O
char	O
*	O
xrealloc	(*(char),int)->(*(char))
(	O
ptr	*(char)
,	O
size	int
)	O
char	O
*	O
ptr	*(char)
;	O
unsigned	O
size	int
;	O
{	O
register	O
char	O
*	O
tem	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
ptr	*(char)
,	O
size	int
)	O
;	O
if	O
(	O
!	O
tem	*(char)
)	O
memory_out	()->(void)
(	O
)	O
;	O
return	O
tem	*(char)
;	O
}	O
static	O
char	O
*	O
tparam1	()->(*(char))
(	O
)	O
;	O
char	O
*	O
tparam	(*(char),*(char),int,int,int,int,int)->(*(char))
(	O
string	*(char)
,	O
outstring	*(char)
,	O
len	int
,	O
arg0	int
,	O
arg1	int
,	O
arg2	int
,	O
arg3	int
)	O
char	O
*	O
string	*(char)
;	O
char	O
*	O
outstring	*(char)
;	O
int	O
len	int
;	O
int	O
arg0	int
,	O
arg1	int
,	O
arg2	int
,	O
arg3	int
;	O
{	O
int	O
arg	array(int)
[	O
4	int
]	O
;	O
arg	array(int)
[	O
0	int
]	O
=	O
arg0	int
;	O
arg	array(int)
[	O
1	int
]	O
=	O
arg1	int
;	O
arg	array(int)
[	O
2	int
]	O
=	O
arg2	int
;	O
arg	array(int)
[	O
3	int
]	O
=	O
arg3	int
;	O
return	O
tparam1	()->(*(char))
(	O
string	*(char)
,	O
outstring	*(char)
,	O
len	int
,	O
NULL	O
,	O
NULL	O
,	O
arg	array(int)
)	O
;	O
}	O
char	O
*	O
BC	*(char)
;	O
char	O
*	O
UP	*(char)
;	O
static	O
char	O
tgoto_buf	array(char)
[	O
50	int
]	O
;	O
char	O
*	O
tgoto	(*(char),int,int)->(*(char))
(	O
cm	*(char)
,	O
hpos	int
,	O
vpos	int
)	O
char	O
*	O
cm	*(char)
;	O
int	O
hpos	int
,	O
vpos	int
;	O
{	O
int	O
args	array(int)
[	O
2	int
]	O
;	O
if	O
(	O
!	O
cm	*(char)
)	O
return	O
NULL	O
;	O
args	array(int)
[	O
0	int
]	O
=	O
vpos	int
;	O
args	array(int)
[	O
1	int
]	O
=	O
hpos	int
;	O
return	O
tparam1	()->(*(char))
(	O
cm	*(char)
,	O
tgoto_buf	array(char)
,	O
50	int
,	O
UP	*(char)
,	O
BC	*(char)
,	O
args	array(int)
)	O
;	O
}	O
static	O
char	O
*	O
tparam1	()->(*(char))
(	O
string	*(char)
,	O
outstring	*(char)
,	O
len	int
,	O
up	*(char)
,	O
left	*(char)
,	O
argp	*(int)
)	O
char	O
*	O
string	*(char)
;	O
char	O
*	O
outstring	*(char)
;	O
int	O
len	int
;	O
char	O
*	O
up	*(char)
,	O
*	O
left	*(char)
;	O
register	O
int	O
*	O
argp	*(int)
;	O
{	O
register	O
int	O
c	int
;	O
register	O
char	O
*	O
p	*(char)
=	O
string	*(char)
;	O
register	O
char	O
*	O
op	*(char)
=	O
outstring	*(char)
;	O
char	O
*	O
outend	*(char)
;	O
int	O
outlen	int
=	O
0	int
;	O
register	O
int	O
tem	*(char)
;	O
int	O
*	O
old_argp	*(int)
=	O
argp	*(int)
;	O
int	O
doleft	int
=	O
0	int
;	O
int	O
doup	int
=	O
0	int
;	O
outend	*(char)
=	O
outstring	*(char)
+	O
len	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
op	*(char)
+	O
5	int
>=	O
outend	*(char)
)	O
{	O
register	O
char	O
*	O
new	*(char)
;	O
if	O
(	O
outlen	int
==	O
0	int
)	O
{	O
outlen	int
=	O
len	int
+	O
40	int
;	O
new	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(int)->(*(char))
(	O
outlen	int
)	O
;	O
outend	*(char)
+=	O
40	int
;	O
bcopy	O
(	O
outstring	*(char)
,	O
new	*(char)
,	O
op	*(char)
-	O
outstring	*(char)
)	O
;	O
}	O
else	O
{	O
outend	*(char)
+=	O
outlen	int
;	O
outlen	int
*=	O
2	int
;	O
new	*(char)
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(char),int)->(*(char))
(	O
outstring	*(char)
,	O
outlen	int
)	O
;	O
}	O
op	*(char)
+=	O
new	*(char)
-	O
outstring	*(char)
;	O
outend	*(char)
+=	O
new	*(char)
-	O
outstring	*(char)
;	O
outstring	*(char)
=	O
new	*(char)
;	O
}	O
c	int
=	O
*	O
p	*(char)
++	O
;	O
if	O
(	O
!	O
c	int
)	O
break	O
;	O
if	O
(	O
c	int
==	O
'%'	O
)	O
{	O
c	int
=	O
*	O
p	*(char)
++	O
;	O
tem	*(char)
=	O
*	O
argp	*(int)
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'd'	O
:	O
if	O
(	O
tem	*(char)
<	O
10	int
)	O
goto	O
onedigit	O
;	O
if	O
(	O
tem	*(char)
<	O
100	int
)	O
goto	O
twodigit	O
;	O
case	O
'3'	O
:	O
if	O
(	O
tem	*(char)
>	O
999	int
)	O
{	O
*	O
op	*(char)
++	O
=	O
tem	*(char)
/	O
1000	int
+	O
'0'	O
;	O
tem	*(char)
%=	O
1000	int
;	O
}	O
*	O
op	*(char)
++	O
=	O
tem	*(char)
/	O
100	int
+	O
'0'	O
;	O
case	O
'2'	O
:	O
twodigit	O
:	O
tem	*(char)
%=	O
100	int
;	O
*	O
op	*(char)
++	O
=	O
tem	*(char)
/	O
10	int
+	O
'0'	O
;	O
onedigit	O
:	O
*	O
op	*(char)
++	O
=	O
tem	*(char)
%	O
10	int
+	O
'0'	O
;	O
argp	*(int)
++	O
;	O
break	O
;	O
case	O
'C'	O
:	O
if	O
(	O
tem	*(char)
>=	O
96	int
)	O
{	O
*	O
op	*(char)
++	O
=	O
tem	*(char)
/	O
96	int
;	O
tem	*(char)
%=	O
96	int
;	O
}	O
case	O
'+'	O
:	O
tem	*(char)
+=	O
*	O
p	*(char)
++	O
;	O
case	O
'.'	O
:	O
if	O
(	O
left	*(char)
)	O
{	O
while	O
(	O
tem	*(char)
==	O
0	int
||	O
tem	*(char)
==	O
'\n'	O
||	O
tem	*(char)
==	O
'\t'	O
)	O
{	O
tem	*(char)
++	O
;	O
if	O
(	O
argp	*(int)
==	O
old_argp	*(int)
)	O
doup	int
++	O
,	O
outend	*(char)
-=	O
strlen	(*(char))->(long)
(	O
up	*(char)
)	O
;	O
else	O
doleft	int
++	O
,	O
outend	*(char)
-=	O
strlen	(*(char))->(long)
(	O
left	*(char)
)	O
;	O
}	O
}	O
*	O
op	*(char)
++	O
=	O
tem	*(char)
?	O
tem	*(char)
:	O
0200	int
;	O
case	O
'f'	O
:	O
argp	*(int)
++	O
;	O
break	O
;	O
case	O
'b'	O
:	O
argp	*(int)
--	O
;	O
break	O
;	O
case	O
'r'	O
:	O
argp	*(int)
[	O
0	int
]	O
=	O
argp	*(int)
[	O
1	int
]	O
;	O
argp	*(int)
[	O
1	int
]	O
=	O
tem	*(char)
;	O
old_argp	*(int)
++	O
;	O
break	O
;	O
case	O
'>'	O
:	O
if	O
(	O
argp	*(int)
[	O
0	int
]	O
>	O
*	O
p	*(char)
++	O
)	O
argp	*(int)
[	O
0	int
]	O
+=	O
*	O
p	*(char)
;	O
p	*(char)
++	O
;	O
break	O
;	O
case	O
'a'	O
:	O
tem	*(char)
=	O
p	*(char)
[	O
2	int
]	O
&	O
0177	int
;	O
if	O
(	O
p	*(char)
[	O
1	int
]	O
==	O
'p'	O
)	O
tem	*(char)
=	O
argp	*(int)
[	O
tem	*(char)
-	O
0100	int
]	O
;	O
if	O
(	O
p	*(char)
[	O
0	int
]	O
==	O
'-'	O
)	O
argp	*(int)
[	O
0	int
]	O
-=	O
tem	*(char)
;	O
else	O
if	O
(	O
p	*(char)
[	O
0	int
]	O
==	O
'+'	O
)	O
argp	*(int)
[	O
0	int
]	O
+=	O
tem	*(char)
;	O
else	O
if	O
(	O
p	*(char)
[	O
0	int
]	O
==	O
'*'	O
)	O
argp	*(int)
[	O
0	int
]	O
*=	O
tem	*(char)
;	O
else	O
if	O
(	O
p	*(char)
[	O
0	int
]	O
==	O
'/'	O
)	O
argp	*(int)
[	O
0	int
]	O
/=	O
tem	*(char)
;	O
else	O
argp	*(int)
[	O
0	int
]	O
=	O
tem	*(char)
;	O
p	*(char)
+=	O
3	int
;	O
break	O
;	O
case	O
'i'	O
:	O
argp	*(int)
[	O
0	int
]	O
++	O
;	O
argp	*(int)
[	O
1	int
]	O
++	O
;	O
break	O
;	O
case	O
'%'	O
:	O
goto	O
ordinary	O
;	O
case	O
'n'	O
:	O
argp	*(int)
[	O
0	int
]	O
^=	O
0140	int
;	O
argp	*(int)
[	O
1	int
]	O
^=	O
0140	int
;	O
break	O
;	O
case	O
'm'	O
:	O
argp	*(int)
[	O
0	int
]	O
^=	O
0177	int
;	O
argp	*(int)
[	O
1	int
]	O
^=	O
0177	int
;	O
break	O
;	O
case	O
'B'	O
:	O
argp	*(int)
[	O
0	int
]	O
+=	O
6	int
*	O
(	O
tem	*(char)
/	O
10	int
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
argp	*(int)
[	O
0	int
]	O
-=	O
2	int
*	O
(	O
tem	*(char)
%	O
16	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
ordinary	O
:	O
*	O
op	*(char)
++	O
=	O
c	int
;	O
}	O
*	O
op	*(char)
=	O
0	int
;	O
while	O
(	O
doup	int
--	O
>	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
op	*(char)
,	O
up	*(char)
)	O
;	O
while	O
(	O
doleft	int
--	O
>	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
op	*(char)
,	O
left	*(char)
)	O
;	O
return	O
outstring	*(char)
;	O
}	O
