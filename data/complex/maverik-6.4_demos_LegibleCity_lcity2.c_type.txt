MAV_class	O
*	O
mav_class_lcity	*(int)
;	O
int	O
apply_lod	int
=	O
1	int
;	O
GLfloat	O
fogColour	array(int)
[	O
4	int
]	O
=	O
{	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
1.0	int
}	O
;	O
int	O
white_index	int
;	O
int	O
current_feature	int
=	O
-	O
1	int
;	O
MAV_surfaceParams	O
*	O
sky	*(int)
=	O
NULL	O
;	O
MAV_surfaceParams	O
*	O
lcfloor	*(int)
=	O
NULL	O
;	O
MAV_surfaceParams	O
*	O
tranny	*(int)
=	O
NULL	O
;	O
MAV_surfaceParams	O
*	O
map_white	*(int)
=	O
NULL	O
;	O
MAV_surfaceParams	O
*	O
grass	*(int)
=	O
NULL	O
;	O
MAV_surfaceParams	O
*	O
canal	*(int)
=	O
NULL	O
;	O
MAV_surfaceParams	O
*	O
stone	*(int)
=	O
NULL	O
;	O
float	O
map_scale	float
=	O
0.11	int
;	O
int	O
drawMap	int
=	O
1	int
;	O
MAV_class	O
*	O
mav_class_character	*(int)
;	O
MAV_class	O
*	O
mav_class_feature	*(int)
;	O
MAV_class	O
*	O
mav_class_vector	*(int)
;	O
MAV_BB	O
city_bb	int
;	O
MAV_SMS	O
*	O
city_build	*(int)
;	O
MAV_SMS	O
*	O
city_sms	*(int)
;	O
MAV_SMS	O
*	O
city_map	*(int)
;	O
Alphabet	O
alphabet	array(int)
[	O
255	int
]	O
;	O
static	O
int	O
citycount	int
;	O
static	O
float	O
comx	array(float)
[	O
3	int
]	O
,	O
comy	array(float)
[	O
3	int
]	O
;	O
static	O
char	O
basefilename	array(array(char))
[	O
3	int
]	O
[	O
80	int
]	O
=	O
{	O
"manhattan"	*(char)
,	O
"amsterdam"	*(char)
,	O
"karlsruhe"	*(char)
}	O
;	O
static	O
float	O
cityangle	array(float)
[	O
3	int
]	O
=	O
{	O
0.0	int
,	O
-	O
90.0	int
,	O
-	O
200.0	int
}	O
;	O
static	O
float	O
angle	float
,	O
cangle	float
,	O
sangle	float
;	O
static	O
int	O
num_polygons	int
;	O
static	O
int	O
ascii	array(int)
[	O
NUM_LETTERS	int
]	O
=	O
{	O
33	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
61	int
,	O
63	int
,	O
65	int
,	O
66	int
,	O
67	int
,	O
68	int
,	O
69	int
,	O
70	int
,	O
71	int
,	O
72	int
,	O
73	int
,	O
74	int
,	O
75	int
,	O
76	int
,	O
77	int
,	O
78	int
,	O
79	int
,	O
80	int
,	O
81	int
,	O
82	int
,	O
83	int
,	O
84	int
,	O
85	int
,	O
86	int
,	O
87	int
,	O
88	int
,	O
89	int
,	O
90	int
,	O
96	int
,	O
128	int
,	O
130	int
,	O
131	int
,	O
133	int
,	O
136	int
,	O
138	int
,	O
140	int
,	O
141	int
,	O
142	int
,	O
147	int
,	O
149	int
,	O
150	int
,	O
151	int
,	O
153	int
,	O
154	int
,	O
225	int
}	O
;	O
static	O
float	O
letter_widths	array(array(float))
[	O
NUM_LETTERS	int
+	O
1	int
]	O
[	O
2	int
]	O
=	O
{	O
{	O
32.0	int
,	O
0.8	int
}	O
,	O
{	O
33.0	int
,	O
0.3277	int
}	O
,	O
{	O
38.0	int
,	O
1.0217	int
}	O
,	O
{	O
39.0	int
,	O
0.2121	int
}	O
,	O
{	O
40.0	int
,	O
0.3374	int
}	O
,	O
{	O
41.0	int
,	O
0.3374	int
}	O
,	O
{	O
44.0	int
,	O
0.2313	int
}	O
,	O
{	O
45.0	int
,	O
0.6169	int
}	O
,	O
{	O
46.0	int
,	O
0.2313	int
}	O
,	O
{	O
47.0	int
,	O
0.7615	int
}	O
,	O
{	O
48.0	int
,	O
0.7615	int
}	O
,	O
{	O
49.0	int
,	O
0.5783	int
}	O
,	O
{	O
50.0	int
,	O
0.7615	int
}	O
,	O
{	O
51.0	int
,	O
0.6458	int
}	O
,	O
{	O
52.0	int
,	O
0.9350	int
}	O
,	O
{	O
53.0	int
,	O
0.7711	int
}	O
,	O
{	O
54.0	int
,	O
0.7615	int
}	O
,	O
{	O
55.0	int
,	O
0.6651	int
}	O
,	O
{	O
56.0	int
,	O
0.7615	int
}	O
,	O
{	O
57.0	int
,	O
0.7615	int
}	O
,	O
{	O
58.0	int
,	O
0.2313	int
}	O
,	O
{	O
61.0	int
,	O
0.6169	int
}	O
,	O
{	O
63.0	int
,	O
0.7615	int
}	O
,	O
{	O
65.0	int
,	O
0.8000	int
}	O
,	O
{	O
66.0	int
,	O
0.7615	int
}	O
,	O
{	O
67.0	int
,	O
0.7615	int
}	O
,	O
{	O
68.0	int
,	O
0.7615	int
}	O
,	O
{	O
69.0	int
,	O
0.6169	int
}	O
,	O
{	O
70.0	int
,	O
0.5783	int
}	O
,	O
{	O
71.0	int
,	O
0.7615	int
}	O
,	O
{	O
72.0	int
,	O
0.7615	int
}	O
,	O
{	O
73.0	int
,	O
0.2410	int
}	O
,	O
{	O
74.0	int
,	O
0.7615	int
}	O
,	O
{	O
75.0	int
,	O
0.8000	int
}	O
,	O
{	O
76.0	int
,	O
0.5494	int
}	O
,	O
{	O
77.0	int
,	O
1.0217	int
}	O
,	O
{	O
78.0	int
,	O
0.8000	int
}	O
,	O
{	O
79.0	int
,	O
0.7615	int
}	O
,	O
{	O
80.0	int
,	O
0.7615	int
}	O
,	O
{	O
81.0	int
,	O
0.8771	int
}	O
,	O
{	O
82.0	int
,	O
0.7615	int
}	O
,	O
{	O
83.0	int
,	O
0.7615	int
}	O
,	O
{	O
84.0	int
,	O
0.8675	int
}	O
,	O
{	O
85.0	int
,	O
0.7615	int
}	O
,	O
{	O
86.0	int
,	O
0.8000	int
}	O
,	O
{	O
87.0	int
,	O
1.3302	int
}	O
,	O
{	O
88.0	int
,	O
0.8964	int
}	O
,	O
{	O
89.0	int
,	O
0.7904	int
}	O
,	O
{	O
90.0	int
,	O
0.6651	int
}	O
,	O
{	O
96.0	int
,	O
0.2121	int
}	O
,	O
{	O
128.0	int
,	O
0.7615	int
}	O
,	O
{	O
130.0	int
,	O
0.6169	int
}	O
,	O
{	O
131.0	int
,	O
0.8000	int
}	O
,	O
{	O
133.0	int
,	O
0.8000	int
}	O
,	O
{	O
136.0	int
,	O
0.6169	int
}	O
,	O
{	O
138.0	int
,	O
0.6169	int
}	O
,	O
{	O
140.0	int
,	O
0.6169	int
}	O
,	O
{	O
141.0	int
,	O
0.2410	int
}	O
,	O
{	O
142.0	int
,	O
0.8000	int
}	O
,	O
{	O
147.0	int
,	O
0.7615	int
}	O
,	O
{	O
149.0	int
,	O
0.7615	int
}	O
,	O
{	O
150.0	int
,	O
0.7615	int
}	O
,	O
{	O
151.0	int
,	O
0.7615	int
}	O
,	O
{	O
153.0	int
,	O
0.7615	int
}	O
,	O
{	O
154.0	int
,	O
0.7615	int
}	O
,	O
{	O
225.0	int
,	O
0.7615	int
}	O
}	O
;	O
int	O
pnpoly	(int,*(float),*(float),float,float)->(int)
(	O
int	O
npol	int
,	O
float	O
*	O
xp	*(float)
,	O
float	O
*	O
yp	*(float)
,	O
float	O
x	float
,	O
float	O
y	float
)	O
{	O
int	O
i	int
,	O
j	int
,	O
c	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
npol	int
-	O
1	int
;	O
i	int
<	O
npol	int
;	O
j	int
=	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
(	O
(	O
yp	*(float)
[	O
i	int
]	O
<=	O
y	float
)	O
&&	O
(	O
y	float
<	O
yp	*(float)
[	O
j	int
]	O
)	O
)	O
||	O
(	O
(	O
yp	*(float)
[	O
j	int
]	O
<=	O
y	float
)	O
&&	O
(	O
y	float
<	O
yp	*(float)
[	O
i	int
]	O
)	O
)	O
)	O
&&	O
(	O
x	float
<	O
(	O
xp	*(float)
[	O
j	int
]	O
-	O
xp	*(float)
[	O
i	int
]	O
)	O
*	O
(	O
y	float
-	O
yp	*(float)
[	O
i	int
]	O
)	O
/	O
(	O
yp	*(float)
[	O
j	int
]	O
-	O
yp	*(float)
[	O
i	int
]	O
)	O
+	O
xp	*(float)
[	O
i	int
]	O
)	O
)	O
{	O
c	int
=	O
!	O
c	int
;	O
}	O
}	O
return	O
c	int
;	O
}	O
int	O
testpoly_xy	(int,*(int),int)->(int)
(	O
int	O
npol	int
,	O
MAV_vector	O
*	O
polyverts	*(int)
,	O
MAV_vector	O
testpoint	int
)	O
{	O
int	O
i	int
,	O
j	int
,	O
c	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
npol	int
-	O
1	int
;	O
i	int
<	O
npol	int
;	O
j	int
=	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
(	O
(	O
polyverts	*(int)
[	O
i	int
]	O
.	O
y	float
<=	O
testpoint	int
.	O
y	float
)	O
&&	O
(	O
testpoint	int
.	O
y	float
<	O
polyverts	*(int)
[	O
j	int
]	O
.	O
y	float
)	O
)	O
||	O
(	O
(	O
polyverts	*(int)
[	O
j	int
]	O
.	O
y	float
<=	O
testpoint	int
.	O
y	float
)	O
&&	O
(	O
testpoint	int
.	O
y	float
<	O
polyverts	*(int)
[	O
i	int
]	O
.	O
y	float
)	O
)	O
)	O
&&	O
(	O
testpoint	int
.	O
x	float
<	O
(	O
polyverts	*(int)
[	O
j	int
]	O
.	O
x	float
-	O
polyverts	*(int)
[	O
i	int
]	O
.	O
x	float
)	O
*	O
(	O
testpoint	int
.	O
y	float
-	O
polyverts	*(int)
[	O
i	int
]	O
.	O
y	float
)	O
/	O
(	O
polyverts	*(int)
[	O
j	int
]	O
.	O
y	float
-	O
polyverts	*(int)
[	O
i	int
]	O
.	O
y	float
)	O
+	O
polyverts	*(int)
[	O
i	int
]	O
.	O
x	float
)	O
)	O
{	O
c	int
=	O
!	O
c	int
;	O
}	O
}	O
return	O
c	int
;	O
}	O
int	O
testpoly_xz	(int,*(int),int)->(int)
(	O
int	O
npol	int
,	O
MAV_vector	O
*	O
polyverts	*(int)
,	O
MAV_vector	O
testpoint	int
)	O
{	O
int	O
i	int
,	O
j	int
,	O
c	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
npol	int
-	O
1	int
;	O
i	int
<	O
npol	int
;	O
j	int
=	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
(	O
(	O
polyverts	*(int)
[	O
i	int
]	O
.	O
z	float
<=	O
testpoint	int
.	O
z	float
)	O
&&	O
(	O
testpoint	int
.	O
z	float
<	O
polyverts	*(int)
[	O
j	int
]	O
.	O
z	float
)	O
)	O
||	O
(	O
(	O
polyverts	*(int)
[	O
j	int
]	O
.	O
z	float
<=	O
testpoint	int
.	O
z	float
)	O
&&	O
(	O
testpoint	int
.	O
z	float
<	O
polyverts	*(int)
[	O
i	int
]	O
.	O
z	float
)	O
)	O
)	O
&&	O
(	O
testpoint	int
.	O
x	float
<	O
(	O
polyverts	*(int)
[	O
j	int
]	O
.	O
x	float
-	O
polyverts	*(int)
[	O
i	int
]	O
.	O
x	float
)	O
*	O
(	O
testpoint	int
.	O
z	float
-	O
polyverts	*(int)
[	O
i	int
]	O
.	O
z	float
)	O
/	O
(	O
polyverts	*(int)
[	O
j	int
]	O
.	O
z	float
-	O
polyverts	*(int)
[	O
i	int
]	O
.	O
z	float
)	O
+	O
polyverts	*(int)
[	O
i	int
]	O
.	O
x	float
)	O
)	O
{	O
c	int
=	O
!	O
c	int
;	O
}	O
}	O
return	O
c	int
;	O
}	O
int	O
testpoly_yz	(int,*(int),int)->(int)
(	O
int	O
npol	int
,	O
MAV_vector	O
*	O
polyverts	*(int)
,	O
MAV_vector	O
testpoint	int
)	O
{	O
int	O
i	int
,	O
j	int
,	O
c	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
npol	int
-	O
1	int
;	O
i	int
<	O
npol	int
;	O
j	int
=	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
(	O
(	O
polyverts	*(int)
[	O
i	int
]	O
.	O
z	float
<=	O
testpoint	int
.	O
z	float
)	O
&&	O
(	O
testpoint	int
.	O
z	float
<	O
polyverts	*(int)
[	O
j	int
]	O
.	O
z	float
)	O
)	O
||	O
(	O
(	O
polyverts	*(int)
[	O
j	int
]	O
.	O
z	float
<=	O
testpoint	int
.	O
z	float
)	O
&&	O
(	O
testpoint	int
.	O
z	float
<	O
polyverts	*(int)
[	O
i	int
]	O
.	O
z	float
)	O
)	O
)	O
&&	O
(	O
testpoint	int
.	O
y	float
<	O
(	O
polyverts	*(int)
[	O
j	int
]	O
.	O
y	float
-	O
polyverts	*(int)
[	O
i	int
]	O
.	O
y	float
)	O
*	O
(	O
testpoint	int
.	O
z	float
-	O
polyverts	*(int)
[	O
i	int
]	O
.	O
z	float
)	O
/	O
(	O
polyverts	*(int)
[	O
j	int
]	O
.	O
z	float
-	O
polyverts	*(int)
[	O
i	int
]	O
.	O
z	float
)	O
+	O
polyverts	*(int)
[	O
i	int
]	O
.	O
y	float
)	O
)	O
{	O
c	int
=	O
!	O
c	int
;	O
}	O
}	O
return	O
c	int
;	O
}	O
void	O
LineCircleIntersect	(float,float,float,float,float,*(float),*(float))->(void)
(	O
float	O
xp	*(float)
,	O
float	O
yp	*(float)
,	O
float	O
xc	float
,	O
float	O
yc	float
,	O
float	O
r	float
,	O
float	O
*	O
x	float
,	O
float	O
*	O
y	float
)	O
{	O
float	O
angle	float
;	O
angle	float
=	O
atan2	O
(	O
(	O
yp	*(float)
-	O
yc	float
)	O
,	O
(	O
xp	*(float)
-	O
xc	float
)	O
)	O
;	O
*	O
x	float
=	O
xc	float
+	O
r	float
*	O
cos	O
(	O
angle	float
)	O
;	O
*	O
y	float
=	O
yc	float
+	O
r	float
*	O
sin	O
(	O
angle	float
)	O
;	O
}	O
int	O
keep_inside_bounds	(*(int))->(int)
(	O
MAV_vector	O
*	O
location	*(int)
)	O
{	O
float	O
dx	float
,	O
dz	float
;	O
float	O
radius	float
;	O
float	O
x	float
,	O
z	float
,	O
newx	float
=	O
0	int
,	O
newz	float
=	O
0	int
,	O
d	float
,	O
dmin	float
;	O
dx	float
=	O
location	*(int)
->	O
x	float
;	O
dz	float
=	O
-	O
location	*(int)
->	O
z	float
;	O
radius	float
=	O
RIM	int
*	O
global_city_mre	O
;	O
if	O
(	O
(	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
)	O
<	O
(	O
radius	float
*	O
radius	float
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
dx	float
=	O
location	*(int)
->	O
x	float
-	O
centx	O
[	O
0	int
]	O
;	O
dz	float
=	O
-	O
location	*(int)
->	O
z	float
-	O
centy	O
[	O
0	int
]	O
;	O
radius	float
=	O
RIM	int
*	O
city_mre	O
[	O
0	int
]	O
;	O
if	O
(	O
(	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
)	O
<	O
(	O
radius	float
*	O
radius	float
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
dx	float
=	O
location	*(int)
->	O
x	float
-	O
centx	O
[	O
1	int
]	O
;	O
dz	float
=	O
-	O
location	*(int)
->	O
z	float
-	O
centy	O
[	O
1	int
]	O
;	O
radius	float
=	O
RIM	int
*	O
city_mre	O
[	O
1	int
]	O
;	O
if	O
(	O
(	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
)	O
<	O
(	O
radius	float
*	O
radius	float
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
dx	float
=	O
location	*(int)
->	O
x	float
-	O
centx	O
[	O
2	int
]	O
;	O
dz	float
=	O
-	O
location	*(int)
->	O
z	float
-	O
centy	O
[	O
2	int
]	O
;	O
radius	float
=	O
RIM	int
*	O
city_mre	O
[	O
2	int
]	O
;	O
if	O
(	O
(	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
)	O
<	O
(	O
radius	float
*	O
radius	float
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
dmin	float
=	O
1.0e20	int
;	O
LineCircleIntersect	(float,float,float,float,float,*(float),*(float))->(void)
(	O
location	*(int)
->	O
x	float
,	O
-	O
location	*(int)
->	O
z	float
,	O
0.0	int
,	O
0.0	int
,	O
global_city_mre	O
,	O
&	O
x	float
,	O
&	O
z	float
)	O
;	O
dx	float
=	O
location	*(int)
->	O
x	float
-	O
x	float
;	O
dz	float
=	O
-	O
location	*(int)
->	O
z	float
-	O
z	float
;	O
d	float
=	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
;	O
if	O
(	O
d	float
<	O
dmin	float
)	O
{	O
newx	float
=	O
x	float
;	O
newz	float
=	O
z	float
;	O
dmin	float
=	O
d	float
;	O
}	O
LineCircleIntersect	(float,float,float,float,float,*(float),*(float))->(void)
(	O
location	*(int)
->	O
x	float
,	O
-	O
location	*(int)
->	O
z	float
,	O
centx	O
[	O
0	int
]	O
,	O
centy	O
[	O
0	int
]	O
,	O
city_mre	O
[	O
0	int
]	O
,	O
&	O
x	float
,	O
&	O
z	float
)	O
;	O
dx	float
=	O
location	*(int)
->	O
x	float
-	O
x	float
;	O
dz	float
=	O
-	O
location	*(int)
->	O
z	float
-	O
z	float
;	O
d	float
=	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
;	O
if	O
(	O
d	float
<	O
dmin	float
)	O
{	O
newx	float
=	O
x	float
;	O
newz	float
=	O
z	float
;	O
dmin	float
=	O
d	float
;	O
}	O
LineCircleIntersect	(float,float,float,float,float,*(float),*(float))->(void)
(	O
location	*(int)
->	O
x	float
,	O
-	O
location	*(int)
->	O
z	float
,	O
centx	O
[	O
1	int
]	O
,	O
centy	O
[	O
1	int
]	O
,	O
city_mre	O
[	O
1	int
]	O
,	O
&	O
x	float
,	O
&	O
z	float
)	O
;	O
dx	float
=	O
location	*(int)
->	O
x	float
-	O
x	float
;	O
dz	float
=	O
-	O
location	*(int)
->	O
z	float
-	O
z	float
;	O
d	float
=	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
;	O
if	O
(	O
d	float
<	O
dmin	float
)	O
{	O
newx	float
=	O
x	float
;	O
newz	float
=	O
z	float
;	O
dmin	float
=	O
d	float
;	O
}	O
LineCircleIntersect	(float,float,float,float,float,*(float),*(float))->(void)
(	O
location	*(int)
->	O
x	float
,	O
-	O
location	*(int)
->	O
z	float
,	O
centx	O
[	O
2	int
]	O
,	O
centy	O
[	O
2	int
]	O
,	O
city_mre	O
[	O
2	int
]	O
,	O
&	O
x	float
,	O
&	O
z	float
)	O
;	O
dx	float
=	O
location	*(int)
->	O
x	float
-	O
x	float
;	O
dz	float
=	O
-	O
location	*(int)
->	O
z	float
-	O
z	float
;	O
d	float
=	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
;	O
if	O
(	O
d	float
<	O
dmin	float
)	O
{	O
newx	float
=	O
x	float
;	O
newz	float
=	O
z	float
;	O
}	O
location	*(int)
->	O
x	float
=	O
newx	float
;	O
location	*(int)
->	O
z	float
=	O
-	O
newz	float
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
int	O
mav_characterDraw	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_drawInfo	O
*	O
di	*(int)
)	O
{	O
Character	O
*	O
c	int
=	O
(	O
Character	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	*(int)
)	O
;	O
MAV_vector	O
dr	O
;	O
float	O
dist	float
;	O
int	O
i	int
,	O
j	int
;	O
dr	O
=	O
mav_vectorSub	()->(int)
(	O
c	int
->	O
centre	O
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
)	O
;	O
dist	float
=	O
sqrt	O
(	O
mav_vectorDotProduct	()->(int)
(	O
dr	O
,	O
dr	O
)	O
)	O
;	O
if	O
(	O
apply_lod	int
)	O
{	O
if	O
(	O
dist	float
<	O
fog_distance	int
)	O
{	O
mav_surfaceParamsUse	()->(int)
(	O
c	int
->	O
sp	*(*(int))
)	O
;	O
mav_gfxMatrixPush	()->(int)
(	O
)	O
;	O
mav_gfxMatrixMult	()->(int)
(	O
c	int
->	O
matrix	O
)	O
;	O
if	O
(	O
dist	float
<	O
box_distance	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
c	int
->	O
character	O
->	O
num_polys	O
;	O
i	int
++	O
)	O
{	O
mav_gfxPolygonBegin	()->(int)
(	O
)	O
;	O
mav_gfxNormal	()->(int)
(	O
c	int
->	O
character	O
->	O
polys	O
[	O
i	int
]	O
.	O
normal	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
c	int
->	O
character	O
->	O
polys	O
[	O
i	int
]	O
.	O
num_verts	int
;	O
j	int
++	O
)	O
mav_gfxVertex	()->(int)
(	O
c	int
->	O
character	O
->	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
j	int
]	O
)	O
;	O
mav_gfxPolygonEnd	()->(int)
(	O
)	O
;	O
}	O
}	O
else	O
{	O
mav_BBDrawWithSurfaceParams	()->(int)
(	O
mav_win_current	O
,	O
c	int
->	O
character	O
->	O
bb	*(int)
,	O
c	int
->	O
sp	*(*(int))
)	O
;	O
}	O
mav_gfxMatrixPop	()->(int)
(	O
)	O
;	O
}	O
}	O
else	O
{	O
mav_surfaceParamsUse	()->(int)
(	O
c	int
->	O
sp	*(*(int))
)	O
;	O
mav_gfxMatrixPush	()->(int)
(	O
)	O
;	O
mav_gfxMatrixMult	()->(int)
(	O
c	int
->	O
matrix	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
c	int
->	O
character	O
->	O
num_polys	O
;	O
i	int
++	O
)	O
{	O
mav_gfxPolygonBegin	()->(int)
(	O
)	O
;	O
mav_gfxNormal	()->(int)
(	O
c	int
->	O
character	O
->	O
polys	O
[	O
i	int
]	O
.	O
normal	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
c	int
->	O
character	O
->	O
polys	O
[	O
i	int
]	O
.	O
num_verts	int
;	O
j	int
++	O
)	O
mav_gfxVertex	()->(int)
(	O
c	int
->	O
character	O
->	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
j	int
]	O
)	O
;	O
mav_gfxPolygonEnd	()->(int)
(	O
)	O
;	O
}	O
mav_gfxMatrixPop	()->(int)
(	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
int	O
mav_characterBBox	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_BB	O
*	O
bb	*(int)
)	O
{	O
Character	O
*	O
c	int
=	O
(	O
Character	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	*(int)
)	O
;	O
mav_BBAlign	()->(int)
(	O
c	int
->	O
character	O
->	O
bb	*(int)
,	O
c	int
->	O
matrix	O
,	O
bb	*(int)
)	O
;	O
return	O
1	int
;	O
}	O
void	O
mav_subdivideDraw	(int,int,int)->(void)
(	O
MAV_vector	O
a	int
,	O
MAV_vector	O
b	int
,	O
MAV_vector	O
c	int
)	O
{	O
float	O
l1	float
,	O
l2	float
,	O
l3	float
;	O
l1	float
=	O
fabs	O
(	O
mav_vectorDotProduct	()->(int)
(	O
mav_vectorSub	()->(int)
(	O
b	int
,	O
a	int
)	O
,	O
mav_vectorSub	()->(int)
(	O
b	int
,	O
a	int
)	O
)	O
)	O
;	O
l2	float
=	O
fabs	O
(	O
mav_vectorDotProduct	()->(int)
(	O
mav_vectorSub	()->(int)
(	O
c	int
,	O
a	int
)	O
,	O
mav_vectorSub	()->(int)
(	O
c	int
,	O
a	int
)	O
)	O
)	O
;	O
l3	float
=	O
fabs	O
(	O
mav_vectorDotProduct	()->(int)
(	O
mav_vectorSub	()->(int)
(	O
b	int
,	O
c	int
)	O
,	O
mav_vectorSub	()->(int)
(	O
b	int
,	O
c	int
)	O
)	O
)	O
;	O
if	O
(	O
l1	float
>	O
SQUARE_THING	int
||	O
l2	float
>	O
SQUARE_THING	int
||	O
l3	float
>	O
SQUARE_THING	int
)	O
{	O
MAV_vector	O
ab	O
=	O
mav_vectorScalar	()->(int)
(	O
mav_vectorAdd	()->(int)
(	O
a	int
,	O
b	int
)	O
,	O
0.5	int
)	O
;	O
MAV_vector	O
ac	O
=	O
mav_vectorScalar	()->(int)
(	O
mav_vectorAdd	()->(int)
(	O
a	int
,	O
c	int
)	O
,	O
0.5	int
)	O
;	O
MAV_vector	O
bc	O
=	O
mav_vectorScalar	()->(int)
(	O
mav_vectorAdd	()->(int)
(	O
b	int
,	O
c	int
)	O
,	O
0.5	int
)	O
;	O
mav_subdivideDraw	(int,int,int)->(void)
(	O
a	int
,	O
ab	O
,	O
ac	O
)	O
;	O
mav_subdivideDraw	(int,int,int)->(void)
(	O
ab	O
,	O
bc	O
,	O
ac	O
)	O
;	O
mav_subdivideDraw	(int,int,int)->(void)
(	O
ab	O
,	O
b	int
,	O
bc	O
)	O
;	O
mav_subdivideDraw	(int,int,int)->(void)
(	O
ac	O
,	O
bc	O
,	O
c	int
)	O
;	O
}	O
else	O
{	O
MAV_texCoord	O
t	O
;	O
t	O
.	O
s	O
=	O
a	int
.	O
x	float
/	O
TEX_GRID_SCALE	int
;	O
t	O
.	O
t	O
=	O
a	int
.	O
z	float
/	O
TEX_GRID_SCALE	int
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
a	int
)	O
;	O
t	O
.	O
s	O
=	O
b	int
.	O
x	float
/	O
TEX_GRID_SCALE	int
;	O
t	O
.	O
t	O
=	O
b	int
.	O
z	float
/	O
TEX_GRID_SCALE	int
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
b	int
)	O
;	O
t	O
.	O
s	O
=	O
c	int
.	O
x	float
/	O
TEX_GRID_SCALE	int
;	O
t	O
.	O
t	O
=	O
c	int
.	O
z	float
/	O
TEX_GRID_SCALE	int
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
c	int
)	O
;	O
}	O
}	O
int	O
mav_featureDraw	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_drawInfo	O
*	O
di	*(int)
)	O
{	O
Feature	O
*	O
f	int
=	O
(	O
Feature	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	*(int)
)	O
;	O
int	O
i	int
;	O
MAV_vector	O
dr	O
;	O
float	O
dist	float
;	O
dr	O
=	O
mav_vectorSub	()->(int)
(	O
f	int
->	O
center	O
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
)	O
;	O
dist	float
=	O
sqrt	O
(	O
mav_vectorDotProduct	()->(int)
(	O
dr	O
,	O
dr	O
)	O
)	O
-	O
f	int
->	O
radius	float
;	O
if	O
(	O
dist	float
<	O
fog_distance	int
)	O
{	O
if	O
(	O
testpoly_xz	(int,*(int),int)->(int)
(	O
f	int
->	O
npoints	O
,	O
f	int
->	O
verts	O
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
)	O
)	O
{	O
current_feature	int
=	O
f	int
->	O
type	int
;	O
}	O
mav_surfaceParamsUse	()->(int)
(	O
f	int
->	O
sp	*(*(int))
)	O
;	O
mav_gfxMatrixPush	()->(int)
(	O
)	O
;	O
mav_gfxMatrixMult	()->(int)
(	O
f	int
->	O
matrix	O
)	O
;	O
glBegin	()->(int)
(	O
GL_TRIANGLES	O
)	O
;	O
glNormal3f	()->(int)
(	O
0	int
,	O
1	int
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
f	int
->	O
num_polys	O
;	O
i	int
++	O
)	O
{	O
mav_subdivideDraw	(int,int,int)->(void)
(	O
f	int
->	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
0	int
]	O
,	O
f	int
->	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
1	int
]	O
,	O
f	int
->	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
2	int
]	O
)	O
;	O
}	O
glEnd	()->(int)
(	O
)	O
;	O
mav_gfxMatrixPop	()->(int)
(	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
int	O
mav_featureBBox	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_BB	O
*	O
bb	*(int)
)	O
{	O
Feature	O
*	O
f	int
=	O
(	O
Feature	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	*(int)
)	O
;	O
mav_BBAlign	()->(int)
(	O
f	int
->	O
bb	*(int)
,	O
f	int
->	O
matrix	O
,	O
bb	*(int)
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_vectorDraw	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_drawInfo	O
*	O
di	*(int)
)	O
{	O
Vector	O
*	O
v	*(void)
=	O
(	O
Vector	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	*(int)
)	O
;	O
if	O
(	O
drawMap	int
)	O
{	O
mav_surfaceParamsUse	()->(int)
(	O
map_white	*(int)
)	O
;	O
}	O
else	O
{	O
mav_surfaceParamsUse	()->(int)
(	O
v	*(void)
->	O
sp	*(*(int))
)	O
;	O
}	O
mav_gfxMatrixPush	()->(int)
(	O
)	O
;	O
mav_gfxMatrixMult	()->(int)
(	O
v	*(void)
->	O
matrix	O
)	O
;	O
mav_gfxLineBegin	()->(int)
(	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
v	*(void)
->	O
start	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
v	*(void)
->	O
end	O
)	O
;	O
mav_gfxLineEnd	()->(int)
(	O
)	O
;	O
mav_gfxMatrixPop	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_vectorBBox	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_BB	O
*	O
bb	*(int)
)	O
{	O
Vector	O
*	O
v	*(void)
=	O
(	O
Vector	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	*(int)
)	O
;	O
mav_BBAlign	()->(int)
(	O
v	*(void)
->	O
bb	*(int)
,	O
v	*(void)
->	O
matrix	O
,	O
bb	*(int)
)	O
;	O
return	O
1	int
;	O
}	O
void	O
Make_Font	()->(void)
(	O
void	O
)	O
{	O
MAV_vector	O
r0	O
,	O
r1	O
,	O
*	O
verts	O
;	O
FILE	struct
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
filename	array(char)
[	O
100	int
]	O
;	O
int	O
i	int
,	O
j	int
,	O
l	int
,	O
c	int
,	O
num_verts	int
,	O
index	array(int)
[	O
100	int
]	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
NUM_LETTERS	int
+	O
1	int
;	O
l	int
++	O
)	O
alphabet	array(int)
[	O
(	O
int	O
)	O
(	O
letter_widths	array(array(float))
[	O
l	int
]	O
[	O
0	int
]	O
)	O
]	O
.	O
letter_width	float
=	O
letter_widths	array(array(float))
[	O
l	int
]	O
[	O
1	int
]	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
NUM_LETTERS	int
;	O
l	int
++	O
)	O
{	O
c	int
=	O
ascii	array(int)
[	O
l	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
filename	array(char)
,	O
"./data/font/%d.cdat"	*(char)
,	O
c	int
)	O
;	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	array(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Failed to open font file %s\n"	*(char)
,	O
filename	array(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d"	*(char)
,	O
&	O
num_verts	int
)	O
;	O
verts	O
=	O
mav_malloc	()->(int)
(	O
num_verts	int
*	O
sizeof	O
(	O
MAV_vector	O
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
num_verts	int
;	O
j	int
++	O
)	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%g %g %g"	*(char)
,	O
&	O
verts	O
[	O
j	int
]	O
.	O
x	float
,	O
&	O
verts	O
[	O
j	int
]	O
.	O
y	float
,	O
&	O
verts	O
[	O
j	int
]	O
.	O
z	float
)	O
;	O
mav_BBCompInit	()->(int)
(	O
&	O
alphabet	array(int)
[	O
c	int
]	O
.	O
bb	*(int)
)	O
;	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d"	*(char)
,	O
&	O
alphabet	array(int)
[	O
c	int
]	O
.	O
num_polys	O
)	O
;	O
alphabet	array(int)
[	O
c	int
]	O
.	O
polys	O
=	O
mav_malloc	()->(int)
(	O
alphabet	array(int)
[	O
c	int
]	O
.	O
num_polys	O
*	O
sizeof	O
(	O
LC_Polygon	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
alphabet	array(int)
[	O
c	int
]	O
.	O
num_polys	O
;	O
i	int
++	O
)	O
{	O
num_verts	int
=	O
0	int
;	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d"	*(char)
,	O
&	O
index	array(int)
[	O
num_verts	int
]	O
)	O
;	O
while	O
(	O
index	array(int)
[	O
num_verts	int
]	O
!=	O
-	O
1	int
)	O
{	O
num_verts	int
++	O
;	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d"	*(char)
,	O
&	O
index	array(int)
[	O
num_verts	int
]	O
)	O
;	O
}	O
alphabet	array(int)
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
num_verts	int
=	O
num_verts	int
;	O
alphabet	array(int)
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
verts	O
=	O
mav_malloc	()->(int)
(	O
num_verts	int
*	O
sizeof	O
(	O
MAV_vector	O
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
num_verts	int
;	O
j	int
++	O
)	O
{	O
alphabet	array(int)
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
j	int
]	O
=	O
verts	O
[	O
index	array(int)
[	O
j	int
]	O
]	O
;	O
mav_BBCompPt	()->(int)
(	O
alphabet	array(int)
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
j	int
]	O
,	O
&	O
alphabet	array(int)
[	O
c	int
]	O
.	O
bb	*(int)
)	O
;	O
}	O
r0	O
=	O
mav_vectorNormalize	()->(int)
(	O
mav_vectorSub	()->(int)
(	O
alphabet	array(int)
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
2	int
]	O
,	O
alphabet	array(int)
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
1	int
]	O
)	O
)	O
;	O
r1	O
=	O
mav_vectorNormalize	()->(int)
(	O
mav_vectorSub	()->(int)
(	O
alphabet	array(int)
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
0	int
]	O
,	O
alphabet	array(int)
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
1	int
]	O
)	O
)	O
;	O
alphabet	array(int)
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
normal	O
=	O
mav_vectorNormalize	()->(int)
(	O
mav_vectorCrossProduct	()->(int)
(	O
r0	O
,	O
r1	O
)	O
)	O
;	O
}	O
mav_free	()->(int)
(	O
verts	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
Feature	O
*	O
feature	*(int)
;	O
int	O
feature_vertices	int
;	O
typedef	O
void	O
(	O
CALLBACK	O
*	O
MAVLIB_GLUCB	*(()->(void))
)	O
(	O
)	O
;	O
void	O
CALLBACK	O
my_begin	(int)->(void)
(	O
GLenum	O
mode	int
)	O
{	O
feature	*(int)
->	O
polys	O
[	O
feature	*(int)
->	O
num_polys	O
]	O
.	O
num_verts	int
=	O
3	int
;	O
feature	*(int)
->	O
polys	O
[	O
feature	*(int)
->	O
num_polys	O
]	O
.	O
verts	O
=	O
mav_malloc	()->(int)
(	O
3	int
*	O
sizeof	O
(	O
MAV_vector	O
)	O
)	O
;	O
feature	*(int)
->	O
polys	O
[	O
feature	*(int)
->	O
num_polys	O
]	O
.	O
num_verts	int
=	O
0	int
;	O
}	O
void	O
CALLBACK	O
my_error	(int)->(void)
(	O
GLenum	O
en	int
)	O
{	O
printf	(*(char))->(int)
(	O
"GLU error: %i\n"	*(char)
,	O
en	int
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
void	O
CALLBACK	O
my_vertex	(*(void))->(void)
(	O
void	O
*	O
v	*(void)
)	O
{	O
MAV_vector	O
r0	O
,	O
r1	O
;	O
feature	*(int)
->	O
polys	O
[	O
feature	*(int)
->	O
num_polys	O
]	O
.	O
verts	O
[	O
feature	*(int)
->	O
polys	O
[	O
feature	*(int)
->	O
num_polys	O
]	O
.	O
num_verts	int
]	O
=	O
*	O
(	O
(	O
MAV_vector	O
*	O
)	O
v	*(void)
)	O
;	O
feature	*(int)
->	O
polys	O
[	O
feature	*(int)
->	O
num_polys	O
]	O
.	O
num_verts	int
++	O
;	O
if	O
(	O
feature	*(int)
->	O
polys	O
[	O
feature	*(int)
->	O
num_polys	O
]	O
.	O
num_verts	int
==	O
3	int
)	O
{	O
r0	O
=	O
mav_vectorSub	()->(int)
(	O
feature	*(int)
->	O
polys	O
[	O
feature	*(int)
->	O
num_polys	O
]	O
.	O
verts	O
[	O
1	int
]	O
,	O
feature	*(int)
->	O
polys	O
[	O
feature	*(int)
->	O
num_polys	O
]	O
.	O
verts	O
[	O
0	int
]	O
)	O
;	O
r1	O
=	O
mav_vectorSub	()->(int)
(	O
feature	*(int)
->	O
polys	O
[	O
feature	*(int)
->	O
num_polys	O
]	O
.	O
verts	O
[	O
feature	*(int)
->	O
polys	O
[	O
feature	*(int)
->	O
num_polys	O
]	O
.	O
num_verts	int
-	O
1	int
]	O
,	O
feature	*(int)
->	O
polys	O
[	O
feature	*(int)
->	O
num_polys	O
]	O
.	O
verts	O
[	O
0	int
]	O
)	O
;	O
feature	*(int)
->	O
polys	O
[	O
feature	*(int)
->	O
num_polys	O
]	O
.	O
normal	O
=	O
mav_vectorNormalize	()->(int)
(	O
mav_vectorCrossProduct	()->(int)
(	O
r0	O
,	O
r1	O
)	O
)	O
;	O
feature	*(int)
->	O
num_polys	O
++	O
;	O
}	O
}	O
void	O
CALLBACK	O
dummyedge	(int)->(void)
(	O
GLboolean	O
f	int
)	O
{	O
}	O
void	O
CALLBACK	O
count_polygons	(*(void))->(void)
(	O
void	O
*	O
ignored	*(void)
)	O
{	O
feature_vertices	int
++	O
;	O
if	O
(	O
feature_vertices	int
==	O
3	int
)	O
{	O
feature	*(int)
->	O
num_polys	O
++	O
;	O
feature_vertices	int
=	O
0	int
;	O
}	O
}	O
void	O
CALLBACK	O
dummybegin	(int)->(void)
(	O
GLenum	O
mode	int
)	O
{	O
}	O
void	O
CALLBACK	O
dummyend	()->(void)
(	O
void	O
)	O
{	O
}	O
void	O
Build_Feature	(*(float),*(float),*(float),int,int)->(void)
(	O
float	O
*	O
xp	*(float)
,	O
float	O
*	O
yp	*(float)
,	O
float	O
*	O
zp	*(float)
,	O
int	O
num_verts	int
,	O
int	O
type	int
)	O
{	O
GLdouble	O
data	O
[	O
3	int
]	O
;	O
GLUtesselator	O
*	O
tobj	O
;	O
int	O
i	int
;	O
float	O
x1	float
,	O
y1	float
,	O
x1p	float
,	O
y1p	float
,	O
z1	float
;	O
float	O
dx	float
,	O
dy	float
,	O
dz	float
;	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
cityangle	array(float)
[	O
citycount	int
]	O
;	O
cangle	float
=	O
(	O
float	O
)	O
cos	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
sangle	float
=	O
(	O
float	O
)	O
sin	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
feature	*(int)
=	O
mav_malloc	()->(int)
(	O
sizeof	O
(	O
Feature	O
)	O
)	O
;	O
feature	*(int)
->	O
npoints	O
=	O
num_verts	int
;	O
feature	*(int)
->	O
type	int
=	O
type	int
;	O
feature	*(int)
->	O
verts	O
=	O
mav_malloc	()->(int)
(	O
num_verts	int
*	O
sizeof	O
(	O
MAV_vector	O
)	O
)	O
;	O
mav_BBCompInit	()->(int)
(	O
&	O
feature	*(int)
->	O
bb	*(int)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_verts	int
;	O
i	int
++	O
)	O
{	O
x1	float
=	O
xp	*(float)
[	O
i	int
]	O
;	O
y1	float
=	O
yp	*(float)
[	O
i	int
]	O
;	O
z1	float
=	O
zp	*(float)
[	O
i	int
]	O
;	O
if	O
(	O
(	O
type	int
==	O
CANAL	O
)	O
||	O
(	O
type	int
==	O
GRASS	O
)	O
||	O
(	O
type	int
==	O
PAVEMENT	O
)	O
)	O
{	O
x1	float
-=	O
comx	array(float)
[	O
citycount	int
]	O
;	O
y1	float
-=	O
comy	array(float)
[	O
citycount	int
]	O
;	O
x1p	float
=	O
x1	float
*	O
cangle	float
-	O
y1	float
*	O
sangle	float
;	O
y1p	float
=	O
x1	float
*	O
sangle	float
+	O
y1	float
*	O
cangle	float
;	O
feature	*(int)
->	O
verts	O
[	O
i	int
]	O
.	O
x	float
=	O
-	O
(	O
x1p	float
-	O
centx	O
[	O
citycount	int
]	O
)	O
;	O
feature	*(int)
->	O
verts	O
[	O
i	int
]	O
.	O
y	float
=	O
z1	float
;	O
feature	*(int)
->	O
verts	O
[	O
i	int
]	O
.	O
z	float
=	O
(	O
y1p	float
-	O
centy	O
[	O
citycount	int
]	O
)	O
;	O
}	O
else	O
{	O
feature	*(int)
->	O
verts	O
[	O
i	int
]	O
.	O
x	float
=	O
x1	float
;	O
feature	*(int)
->	O
verts	O
[	O
i	int
]	O
.	O
y	float
=	O
z1	float
;	O
feature	*(int)
->	O
verts	O
[	O
i	int
]	O
.	O
z	float
=	O
y1	float
;	O
}	O
mav_BBCompPt	()->(int)
(	O
feature	*(int)
->	O
verts	O
[	O
i	int
]	O
,	O
&	O
feature	*(int)
->	O
bb	*(int)
)	O
;	O
}	O
feature	*(int)
->	O
center	O
.	O
x	float
=	O
(	O
feature	*(int)
->	O
bb	*(int)
.	O
min	O
.	O
x	float
+	O
feature	*(int)
->	O
bb	*(int)
.	O
max	O
.	O
x	float
)	O
*	O
0.5	int
;	O
feature	*(int)
->	O
center	O
.	O
y	float
=	O
(	O
feature	*(int)
->	O
bb	*(int)
.	O
min	O
.	O
y	float
+	O
feature	*(int)
->	O
bb	*(int)
.	O
max	O
.	O
y	float
)	O
*	O
0.5	int
;	O
feature	*(int)
->	O
center	O
.	O
z	float
=	O
(	O
feature	*(int)
->	O
bb	*(int)
.	O
min	O
.	O
z	float
+	O
feature	*(int)
->	O
bb	*(int)
.	O
max	O
.	O
z	float
)	O
*	O
0.5	int
;	O
dx	float
=	O
feature	*(int)
->	O
bb	*(int)
.	O
min	O
.	O
x	float
-	O
feature	*(int)
->	O
center	O
.	O
x	float
;	O
dy	float
=	O
feature	*(int)
->	O
bb	*(int)
.	O
min	O
.	O
y	float
-	O
feature	*(int)
->	O
center	O
.	O
y	float
;	O
dz	float
=	O
feature	*(int)
->	O
bb	*(int)
.	O
min	O
.	O
z	float
-	O
feature	*(int)
->	O
center	O
.	O
z	float
;	O
feature	*(int)
->	O
radius	float
=	O
sqrt	O
(	O
dx	float
*	O
dx	float
+	O
dy	float
*	O
dy	float
+	O
dz	float
*	O
dz	float
)	O
;	O
tobj	O
=	O
gluNewTess	()->(int)
(	O
)	O
;	O
if	O
(	O
!	O
tobj	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Failed to allocate GLUtesselator\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
feature	*(int)
->	O
num_polys	O
=	O
0	int
;	O
feature_vertices	int
=	O
0	int
;	O
gluTessCallback	()->(int)
(	O
tobj	O
,	O
GLU_TESS_BEGIN	O
,	O
(	O
MAVLIB_GLUCB	*(()->(void))
)	O
dummybegin	(int)->(void)
)	O
;	O
gluTessCallback	()->(int)
(	O
tobj	O
,	O
GLU_TESS_END	O
,	O
(	O
MAVLIB_GLUCB	*(()->(void))
)	O
dummyend	()->(void)
)	O
;	O
gluTessCallback	()->(int)
(	O
tobj	O
,	O
GLU_TESS_ERROR	O
,	O
(	O
MAVLIB_GLUCB	*(()->(void))
)	O
my_error	(int)->(void)
)	O
;	O
gluTessCallback	()->(int)
(	O
tobj	O
,	O
GLU_TESS_VERTEX	O
,	O
(	O
MAVLIB_GLUCB	*(()->(void))
)	O
count_polygons	(*(void))->(void)
)	O
;	O
gluTessCallback	()->(int)
(	O
tobj	O
,	O
GLU_TESS_EDGE_FLAG	O
,	O
(	O
MAVLIB_GLUCB	*(()->(void))
)	O
dummyedge	(int)->(void)
)	O
;	O
gluTessBeginPolygon	O
(	O
tobj	O
,	O
NULL	O
)	O
;	O
gluTessBeginContour	O
(	O
tobj	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_verts	int
;	O
i	int
++	O
)	O
{	O
data	O
[	O
0	int
]	O
=	O
(	O
GLdouble	O
)	O
feature	*(int)
->	O
verts	O
[	O
i	int
]	O
.	O
x	float
;	O
data	O
[	O
1	int
]	O
=	O
(	O
GLdouble	O
)	O
feature	*(int)
->	O
verts	O
[	O
i	int
]	O
.	O
y	float
;	O
data	O
[	O
2	int
]	O
=	O
(	O
GLdouble	O
)	O
feature	*(int)
->	O
verts	O
[	O
i	int
]	O
.	O
z	float
;	O
gluTessVertex	()->(int)
(	O
tobj	O
,	O
data	O
,	O
(	O
GLvoid	O
*	O
)	O
&	O
(	O
feature	*(int)
->	O
verts	O
[	O
i	int
]	O
)	O
)	O
;	O
}	O
gluTessEndContour	O
(	O
tobj	O
)	O
;	O
gluTessEndPolygon	O
(	O
tobj	O
)	O
;	O
gluDeleteTess	()->(int)
(	O
tobj	O
)	O
;	O
feature	*(int)
->	O
polys	O
=	O
mav_malloc	()->(int)
(	O
feature	*(int)
->	O
num_polys	O
*	O
sizeof	O
(	O
LC_Polygon	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
feature	*(int)
->	O
num_polys	O
;	O
i	int
++	O
)	O
{	O
feature	*(int)
->	O
polys	O
[	O
i	int
]	O
.	O
verts	O
=	O
mav_malloc	()->(int)
(	O
3	int
*	O
sizeof	O
(	O
MAV_vector	O
)	O
)	O
;	O
feature	*(int)
->	O
polys	O
[	O
i	int
]	O
.	O
num_verts	int
=	O
0	int
;	O
}	O
num_polygons	int
+=	O
feature	*(int)
->	O
num_polys	O
;	O
tobj	O
=	O
gluNewTess	()->(int)
(	O
)	O
;	O
if	O
(	O
!	O
tobj	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Failed to allocate GLUtesselator\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
feature	*(int)
->	O
num_polys	O
=	O
0	int
;	O
gluTessCallback	()->(int)
(	O
tobj	O
,	O
GLU_TESS_BEGIN	O
,	O
(	O
MAVLIB_GLUCB	*(()->(void))
)	O
my_begin	(int)->(void)
)	O
;	O
gluTessCallback	()->(int)
(	O
tobj	O
,	O
GLU_TESS_END	O
,	O
(	O
MAVLIB_GLUCB	*(()->(void))
)	O
dummyend	()->(void)
)	O
;	O
gluTessCallback	()->(int)
(	O
tobj	O
,	O
GLU_TESS_ERROR	O
,	O
(	O
MAVLIB_GLUCB	*(()->(void))
)	O
my_error	(int)->(void)
)	O
;	O
gluTessCallback	()->(int)
(	O
tobj	O
,	O
GLU_TESS_VERTEX	O
,	O
(	O
MAVLIB_GLUCB	*(()->(void))
)	O
my_vertex	(*(void))->(void)
)	O
;	O
gluTessCallback	()->(int)
(	O
tobj	O
,	O
GLU_TESS_EDGE_FLAG	O
,	O
(	O
MAVLIB_GLUCB	*(()->(void))
)	O
dummyedge	(int)->(void)
)	O
;	O
gluTessBeginPolygon	O
(	O
tobj	O
,	O
NULL	O
)	O
;	O
gluTessBeginContour	O
(	O
tobj	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_verts	int
;	O
i	int
++	O
)	O
{	O
data	O
[	O
0	int
]	O
=	O
(	O
double	O
)	O
feature	*(int)
->	O
verts	O
[	O
i	int
]	O
.	O
x	float
;	O
data	O
[	O
1	int
]	O
=	O
(	O
double	O
)	O
feature	*(int)
->	O
verts	O
[	O
i	int
]	O
.	O
y	float
;	O
data	O
[	O
2	int
]	O
=	O
(	O
double	O
)	O
feature	*(int)
->	O
verts	O
[	O
i	int
]	O
.	O
z	float
;	O
gluTessVertex	()->(int)
(	O
tobj	O
,	O
data	O
,	O
(	O
void	O
*	O
)	O
&	O
(	O
feature	*(int)
->	O
verts	O
[	O
i	int
]	O
)	O
)	O
;	O
}	O
gluTessEndContour	O
(	O
tobj	O
)	O
;	O
gluTessEndPolygon	O
(	O
tobj	O
)	O
;	O
gluDeleteTess	()->(int)
(	O
tobj	O
)	O
;	O
feature	*(int)
->	O
matrix	O
=	O
MAV_ID_MATRIX	O
;	O
feature	*(int)
->	O
sp	*(*(int))
=	O
mav_surfaceParamsNew	()->(int)
(	O
MAV_COLOUR	O
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
CANAL	O
:	O
feature	*(int)
->	O
sp	*(*(int))
=	O
canal	*(int)
;	O
break	O
;	O
case	O
PAVEMENT	O
:	O
feature	*(int)
->	O
sp	*(*(int))
=	O
stone	*(int)
;	O
break	O
;	O
case	O
GRASS	O
:	O
feature	*(int)
->	O
sp	*(*(int))
=	O
grass	*(int)
;	O
break	O
;	O
default	O
:	O
feature	*(int)
->	O
sp	*(*(int))
=	O
grass	*(int)
;	O
break	O
;	O
}	O
mav_SMSCallbackObjectAddExec	()->(int)
(	O
city_build	*(int)
,	O
mav_objectNew	()->(int)
(	O
mav_class_feature	*(int)
,	O
feature	*(int)
)	O
)	O
;	O
}	O
static	O
Vector	O
*	O
vector_list	*(int)
=	O
NULL	O
;	O
static	O
int	O
vectorcount	int
;	O
Vector	O
*	O
Find_Vector	(*(char))->(*(int))
(	O
char	O
*	O
name	*(char)
)	O
{	O
Vector	O
*	O
v	*(void)
;	O
v	*(void)
=	O
vector_list	*(int)
;	O
while	O
(	O
v	*(void)
)	O
{	O
if	O
(	O
strcmp	O
(	O
v	*(void)
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
v	*(void)
;	O
v	*(void)
=	O
v	*(void)
->	O
next	O
;	O
}	O
return	O
NULL	O
;	O
}	O
void	O
AddNewVector	(*(char),float,float,float,float,int)->(void)
(	O
char	O
*	O
vectorname	*(char)
,	O
float	O
x1	float
,	O
float	O
y1	float
,	O
float	O
x2	float
,	O
float	O
y2	float
,	O
int	O
ColorCode	int
)	O
{	O
Vector	O
*	O
v	*(void)
,	O
*	O
newv	O
;	O
MAV_object	O
*	O
obj	*(int)
;	O
vectorcount	int
++	O
;	O
v	*(void)
=	O
mav_malloc	()->(int)
(	O
sizeof	O
(	O
Vector	O
)	O
)	O
;	O
strcpy	O
(	O
v	*(void)
->	O
name	*(char)
,	O
vectorname	*(char)
)	O
;	O
v	*(void)
->	O
start	O
.	O
x	float
=	O
x1	float
;	O
v	*(void)
->	O
start	O
.	O
y	float
=	O
0.0	int
;	O
v	*(void)
->	O
start	O
.	O
z	float
=	O
y1	float
;	O
v	*(void)
->	O
end	O
.	O
x	float
=	O
x2	float
;	O
v	*(void)
->	O
end	O
.	O
y	float
=	O
0.0	int
;	O
v	*(void)
->	O
end	O
.	O
z	float
=	O
y2	float
;	O
v	*(void)
->	O
sp	*(*(int))
=	O
mav_surfaceParamsNew	()->(int)
(	O
MAV_COLOUR	O
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
v	*(void)
->	O
sp	*(*(int))
->	O
colour	O
=	O
ColorCode	int
;	O
v	*(void)
->	O
phrase_length	O
=	O
0.0	int
;	O
v	*(void)
->	O
num_characters	O
=	O
0	int
;	O
v	*(void)
->	O
bb	*(int)
.	O
min	O
.	O
x	float
=	O
(	O
v	*(void)
->	O
start	O
.	O
x	float
<	O
v	*(void)
->	O
end	O
.	O
x	float
)	O
?	O
v	*(void)
->	O
start	O
.	O
x	float
:	O
v	*(void)
->	O
end	O
.	O
x	float
;	O
v	*(void)
->	O
bb	*(int)
.	O
min	O
.	O
y	float
=	O
0.0	int
;	O
v	*(void)
->	O
bb	*(int)
.	O
min	O
.	O
z	float
=	O
(	O
v	*(void)
->	O
start	O
.	O
z	float
<	O
v	*(void)
->	O
end	O
.	O
z	float
)	O
?	O
v	*(void)
->	O
start	O
.	O
z	float
:	O
v	*(void)
->	O
end	O
.	O
z	float
;	O
v	*(void)
->	O
bb	*(int)
.	O
max	O
.	O
x	float
=	O
(	O
v	*(void)
->	O
start	O
.	O
x	float
>	O
v	*(void)
->	O
end	O
.	O
x	float
)	O
?	O
v	*(void)
->	O
start	O
.	O
x	float
:	O
v	*(void)
->	O
end	O
.	O
x	float
;	O
v	*(void)
->	O
bb	*(int)
.	O
max	O
.	O
y	float
=	O
0.0	int
;	O
v	*(void)
->	O
bb	*(int)
.	O
max	O
.	O
z	float
=	O
(	O
v	*(void)
->	O
start	O
.	O
z	float
>	O
v	*(void)
->	O
end	O
.	O
z	float
)	O
?	O
v	*(void)
->	O
start	O
.	O
z	float
:	O
v	*(void)
->	O
end	O
.	O
z	float
;	O
mav_BBCompBB	()->(int)
(	O
v	*(void)
->	O
bb	*(int)
,	O
&	O
city_bb	int
)	O
;	O
v	*(void)
->	O
matrix	O
=	O
MAV_ID_MATRIX	O
;	O
;	O
v	*(void)
->	O
next	O
=	O
vector_list	*(int)
;	O
vector_list	*(int)
=	O
v	*(void)
;	O
newv	O
=	O
mav_malloc	()->(int)
(	O
sizeof	O
(	O
Vector	O
)	O
)	O
;	O
memcpy	O
(	O
newv	O
,	O
v	*(void)
,	O
sizeof	O
(	O
Vector	O
)	O
)	O
;	O
newv	O
->	O
start	O
.	O
z	float
-=	O
MAP_OFFSET	O
;	O
newv	O
->	O
end	O
.	O
z	float
-=	O
MAP_OFFSET	O
;	O
newv	O
->	O
start	O
=	O
mav_vectorScalar	()->(int)
(	O
newv	O
->	O
start	O
,	O
map_scale	float
)	O
;	O
newv	O
->	O
end	O
=	O
mav_vectorScalar	()->(int)
(	O
newv	O
->	O
end	O
,	O
map_scale	float
)	O
;	O
obj	*(int)
=	O
mav_objectNew	()->(int)
(	O
mav_class_vector	*(int)
,	O
newv	O
)	O
;	O
mav_SMSCallbackObjectAddExec	()->(int)
(	O
city_map	*(int)
,	O
obj	*(int)
)	O
;	O
}	O
void	O
MakeAllStreets	()->(void)
(	O
)	O
{	O
int	O
i	int
;	O
FILE	struct
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
strfile	array(char)
[	O
LINE_LEN	int
]	O
;	O
char	O
lstfile	array(char)
[	O
LINE_LEN	int
]	O
;	O
char	O
aline	array(char)
[	O
LINE_LEN	int
]	O
;	O
float	O
x1	float
,	O
y1	float
,	O
x2	float
,	O
y2	float
,	O
x1p	float
,	O
y1p	float
,	O
x2p	float
,	O
y2p	float
;	O
float	O
conradius	array(array(float))
[	O
3	int
]	O
[	O
6	int
]	O
;	O
int	O
count	int
,	O
numpoints	int
;	O
int	O
coordinatecount	int
=	O
0	int
;	O
float	O
xsum	float
=	O
0	int
,	O
ysum	float
=	O
0	int
;	O
float	O
xorigin	float
,	O
yorigin	float
,	O
dx	float
=	O
0	int
,	O
dy	float
=	O
0	int
;	O
float	O
radius	float
,	O
maxradius	float
=	O
0	int
;	O
char	O
streetname	array(char)
[	O
LINE_LEN	int
]	O
;	O
char	O
longstreetname	array(char)
[	O
LINE_LEN	int
]	O
;	O
int	O
ColorCode	int
;	O
MAV_BB	O
bb	*(int)
;	O
MAV_vector	O
newdr	O
;	O
Alphabet	O
*	O
letter	O
;	O
Character	O
*	O
character	O
;	O
Vector	O
*	O
v	*(void)
,	O
*	O
current_vector	O
=	O
NULL	O
;	O
float	O
width	float
,	O
height	float
,	O
depth	float
,	O
spacing	float
,	O
letter_width	float
;	O
float	O
current_spacing_x	float
=	O
0	int
,	O
current_spacing_y	float
=	O
0	int
;	O
float	O
vx1	float
=	O
0	int
,	O
vy1	float
=	O
0	int
,	O
vx2	float
,	O
vy2	float
,	O
dlen	float
,	O
dir	float
=	O
0	int
,	O
newx	float
,	O
newy	float
;	O
float	O
xp	*(float)
[	O
MAX_FEATURE_POINTS	int
]	O
,	O
yp	*(float)
[	O
MAX_FEATURE_POINTS	int
]	O
,	O
zp	*(float)
[	O
MAX_FEATURE_POINTS	int
]	O
;	O
num_polygons	int
=	O
0	int
;	O
global_city_mre	O
=	O
0.0	int
;	O
for	O
(	O
citycount	int
=	O
0	int
;	O
citycount	int
<	O
MAX_CITY	int
;	O
citycount	int
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
strfile	array(char)
,	O
"./data/"	*(char)
)	O
;	O
strcat	O
(	O
strfile	array(char)
,	O
basefilename	array(array(char))
[	O
citycount	int
]	O
)	O
;	O
strcat	O
(	O
strfile	array(char)
,	O
".str"	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
strfile	array(char)
,	O
"r"	*(char)
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Failed to open street file %s\n"	*(char)
,	O
strfile	array(char)
)	O
;	O
}	O
else	O
{	O
coordinatecount	int
=	O
0	int
;	O
xsum	float
=	O
0.0	int
;	O
ysum	float
=	O
0.0	int
;	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
aline	array(char)
,	O
LINE_LEN	int
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
if	O
(	O
aline	array(char)
[	O
0	int
]	O
!=	O
';'	O
)	O
{	O
if	O
(	O
(	O
!	O
strncmp	O
(	O
aline	array(char)
,	O
"grass"	*(char)
,	O
5	int
)	O
)	O
||	O
(	O
!	O
strncmp	O
(	O
aline	array(char)
,	O
"canal"	*(char)
,	O
5	int
)	O
)	O
||	O
(	O
!	O
strncmp	O
(	O
aline	array(char)
,	O
"pavem"	*(char)
,	O
5	int
)	O
)	O
)	O
{	O
sscanf	(*(char),*(char))->(int)
(	O
aline	array(char)
,	O
"%*s %i"	*(char)
,	O
&	O
numpoints	int
)	O
;	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
numpoints	int
;	O
count	int
++	O
)	O
{	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
aline	array(char)
,	O
LINE_LEN	int
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
sscanf	(*(char),*(char))->(int)
(	O
aline	array(char)
,	O
"%*c %f %*c %f %*c %*f %*c"	*(char)
,	O
&	O
x1	float
,	O
&	O
y1	float
)	O
;	O
xsum	float
+=	O
x1	float
;	O
ysum	float
+=	O
y1	float
;	O
coordinatecount	int
++	O
;	O
}	O
}	O
else	O
{	O
sscanf	(*(char),*(char))->(int)
(	O
aline	array(char)
,	O
"%*s %f %f %*f %f %f %*i"	*(char)
,	O
&	O
x1	float
,	O
&	O
y1	float
,	O
&	O
x2	float
,	O
&	O
y2	float
)	O
;	O
xsum	float
+=	O
x1	float
;	O
xsum	float
+=	O
x2	float
;	O
ysum	float
+=	O
y1	float
;	O
ysum	float
+=	O
y2	float
;	O
coordinatecount	int
+=	O
2	int
;	O
}	O
}	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
aline	array(char)
,	O
LINE_LEN	int
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
comx	array(float)
[	O
citycount	int
]	O
=	O
xsum	float
/	O
(	O
float	O
)	O
coordinatecount	int
;	O
comy	array(float)
[	O
citycount	int
]	O
=	O
ysum	float
/	O
(	O
float	O
)	O
coordinatecount	int
;	O
printf	(*(char))->(int)
(	O
"Center of mass of %s = (%8.2f,%8.2f)\n"	*(char)
,	O
basefilename	array(array(char))
[	O
citycount	int
]	O
,	O
comx	array(float)
[	O
citycount	int
]	O
,	O
comy	array(float)
[	O
citycount	int
]	O
)	O
;	O
}	O
global_city_mre	O
=	O
0.0	int
;	O
for	O
(	O
citycount	int
=	O
0	int
;	O
citycount	int
<	O
MAX_CITY	int
;	O
citycount	int
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
strfile	array(char)
,	O
"./data/"	*(char)
)	O
;	O
strcat	O
(	O
strfile	array(char)
,	O
basefilename	array(array(char))
[	O
citycount	int
]	O
)	O
;	O
strcat	O
(	O
strfile	array(char)
,	O
".str"	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
strfile	array(char)
,	O
"r"	*(char)
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Failed to open street file %s\n"	*(char)
,	O
strfile	array(char)
)	O
;	O
}	O
else	O
{	O
maxradius	float
=	O
0.0	int
;	O
xorigin	float
=	O
comx	array(float)
[	O
citycount	int
]	O
;	O
yorigin	float
=	O
comy	array(float)
[	O
citycount	int
]	O
;	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
aline	array(char)
,	O
LINE_LEN	int
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
if	O
(	O
aline	array(char)
[	O
0	int
]	O
!=	O
';'	O
)	O
{	O
if	O
(	O
(	O
!	O
strncmp	O
(	O
aline	array(char)
,	O
"grass"	*(char)
,	O
5	int
)	O
)	O
||	O
(	O
!	O
strncmp	O
(	O
aline	array(char)
,	O
"canal"	*(char)
,	O
5	int
)	O
)	O
||	O
(	O
!	O
strncmp	O
(	O
aline	array(char)
,	O
"pavem"	*(char)
,	O
5	int
)	O
)	O
)	O
{	O
sscanf	(*(char),*(char))->(int)
(	O
aline	array(char)
,	O
"%*s %i"	*(char)
,	O
&	O
numpoints	int
)	O
;	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
numpoints	int
;	O
count	int
++	O
)	O
{	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
aline	array(char)
,	O
LINE_LEN	int
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
sscanf	(*(char),*(char))->(int)
(	O
aline	array(char)
,	O
"%*c %f %*c %f %*c %*f %*c"	*(char)
,	O
&	O
x1	float
,	O
&	O
y1	float
)	O
;	O
dx	float
=	O
x1	float
-	O
xorigin	float
;	O
dy	float
=	O
y1	float
-	O
yorigin	float
;	O
radius	float
=	O
sqrt	O
(	O
dx	float
*	O
dx	float
+	O
dy	float
*	O
dy	float
)	O
;	O
if	O
(	O
radius	float
>	O
maxradius	float
)	O
maxradius	float
=	O
radius	float
;	O
}	O
}	O
else	O
{	O
sscanf	(*(char),*(char))->(int)
(	O
aline	array(char)
,	O
"%*s %f %f %*f %f %f %*i"	*(char)
,	O
&	O
x1	float
,	O
&	O
y1	float
,	O
&	O
x2	float
,	O
&	O
y2	float
)	O
;	O
dx	float
=	O
x1	float
-	O
xorigin	float
;	O
dy	float
=	O
y1	float
-	O
yorigin	float
;	O
radius	float
=	O
sqrt	O
(	O
dx	float
*	O
dx	float
+	O
dy	float
+	O
dy	float
)	O
;	O
if	O
(	O
radius	float
>	O
maxradius	float
)	O
maxradius	float
=	O
radius	float
;	O
dx	float
=	O
x2	float
-	O
xorigin	float
;	O
dy	float
=	O
y2	float
-	O
yorigin	float
;	O
radius	float
=	O
sqrt	O
(	O
dx	float
*	O
dx	float
+	O
dy	float
+	O
dy	float
)	O
;	O
if	O
(	O
radius	float
>	O
maxradius	float
)	O
maxradius	float
=	O
radius	float
;	O
}	O
}	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
aline	array(char)
,	O
LINE_LEN	int
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
city_mre	O
[	O
citycount	int
]	O
=	O
maxradius	float
;	O
printf	(*(char))->(int)
(	O
"Maximum Radial Extent of %s = %8.2f\n"	*(char)
,	O
basefilename	array(array(char))
[	O
citycount	int
]	O
,	O
city_mre	O
[	O
citycount	int
]	O
)	O
;	O
if	O
(	O
maxradius	float
>	O
global_city_mre	O
)	O
global_city_mre	O
=	O
maxradius	float
;	O
}	O
for	O
(	O
citycount	int
=	O
0	int
;	O
citycount	int
<	O
MAX_CITY	int
;	O
citycount	int
++	O
)	O
{	O
angle	float
=	O
MAV_PI	O
*	O
120.0	int
/	O
180.0	int
*	O
(	O
float	O
)	O
citycount	int
;	O
cangle	float
=	O
(	O
float	O
)	O
cos	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
sangle	float
=	O
(	O
float	O
)	O
sin	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
centx	O
[	O
citycount	int
]	O
=	O
STRUCTURE_SCALE	int
*	O
global_city_mre	O
*	O
cangle	float
;	O
centy	O
[	O
citycount	int
]	O
=	O
STRUCTURE_SCALE	int
*	O
global_city_mre	O
*	O
sangle	float
;	O
printf	(*(char))->(int)
(	O
"Citycenter of %s = (%8.2f,%8.2f)\n"	*(char)
,	O
basefilename	array(array(char))
[	O
citycount	int
]	O
,	O
centx	O
[	O
citycount	int
]	O
,	O
centy	O
[	O
citycount	int
]	O
)	O
;	O
}	O
mav_BBCompInit	()->(int)
(	O
&	O
city_bb	int
)	O
;	O
for	O
(	O
citycount	int
=	O
0	int
;	O
citycount	int
<	O
MAX_CITY	int
;	O
citycount	int
++	O
)	O
{	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
cityangle	array(float)
[	O
citycount	int
]	O
;	O
cangle	float
=	O
(	O
float	O
)	O
cos	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
sangle	float
=	O
(	O
float	O
)	O
sin	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
strfile	array(char)
,	O
"./data/"	*(char)
)	O
;	O
strcat	O
(	O
strfile	array(char)
,	O
basefilename	array(array(char))
[	O
citycount	int
]	O
)	O
;	O
strcat	O
(	O
strfile	array(char)
,	O
".str"	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
strfile	array(char)
,	O
"r"	*(char)
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Failed to open street file %s\n"	*(char)
,	O
strfile	array(char)
)	O
;	O
}	O
else	O
{	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
aline	array(char)
,	O
LINE_LEN	int
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
if	O
(	O
aline	array(char)
[	O
0	int
]	O
!=	O
';'	O
)	O
{	O
if	O
(	O
(	O
!	O
strncmp	O
(	O
aline	array(char)
,	O
"grass"	*(char)
,	O
5	int
)	O
)	O
||	O
(	O
!	O
strncmp	O
(	O
aline	array(char)
,	O
"canal"	*(char)
,	O
5	int
)	O
)	O
||	O
(	O
!	O
strncmp	O
(	O
aline	array(char)
,	O
"pavem"	*(char)
,	O
5	int
)	O
)	O
)	O
{	O
sscanf	(*(char),*(char))->(int)
(	O
aline	array(char)
,	O
"%*s %i"	*(char)
,	O
&	O
numpoints	int
)	O
;	O
if	O
(	O
!	O
strncmp	O
(	O
aline	array(char)
,	O
"grass"	*(char)
,	O
5	int
)	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numpoints	int
;	O
i	int
++	O
)	O
{	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(%f,%f,%f)\n"	*(char)
,	O
&	O
xp	*(float)
[	O
i	int
]	O
,	O
&	O
yp	*(float)
[	O
i	int
]	O
,	O
&	O
zp	*(float)
[	O
i	int
]	O
)	O
;	O
}	O
Build_Feature	(*(float),*(float),*(float),int,int)->(void)
(	O
xp	*(float)
,	O
yp	*(float)
,	O
zp	*(float)
,	O
numpoints	int
,	O
GRASS	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
strncmp	O
(	O
aline	array(char)
,	O
"canal"	*(char)
,	O
5	int
)	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numpoints	int
;	O
i	int
++	O
)	O
{	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(%f,%f,%f)\n"	*(char)
,	O
&	O
xp	*(float)
[	O
i	int
]	O
,	O
&	O
yp	*(float)
[	O
i	int
]	O
,	O
&	O
zp	*(float)
[	O
i	int
]	O
)	O
;	O
}	O
Build_Feature	(*(float),*(float),*(float),int,int)->(void)
(	O
xp	*(float)
,	O
yp	*(float)
,	O
zp	*(float)
,	O
numpoints	int
,	O
CANAL	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numpoints	int
;	O
i	int
++	O
)	O
{	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(%f,%f,%f)\n"	*(char)
,	O
&	O
xp	*(float)
[	O
i	int
]	O
,	O
&	O
yp	*(float)
[	O
i	int
]	O
,	O
&	O
zp	*(float)
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
!	O
strncmp	O
(	O
aline	array(char)
,	O
"pavem"	*(char)
,	O
5	int
)	O
)	O
{	O
Build_Feature	(*(float),*(float),*(float),int,int)->(void)
(	O
xp	*(float)
,	O
yp	*(float)
,	O
zp	*(float)
,	O
numpoints	int
,	O
PAVEMENT	O
)	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
sscanf	(*(char),*(char))->(int)
(	O
aline	array(char)
,	O
"%s %f %f %*f %f %f %*f %i"	*(char)
,	O
streetname	array(char)
,	O
&	O
x1	float
,	O
&	O
y1	float
,	O
&	O
x2	float
,	O
&	O
y2	float
,	O
&	O
ColorCode	int
)	O
;	O
x1	float
-=	O
comx	array(float)
[	O
citycount	int
]	O
;	O
y1	float
-=	O
comy	array(float)
[	O
citycount	int
]	O
;	O
x2	float
-=	O
comx	array(float)
[	O
citycount	int
]	O
;	O
y2	float
-=	O
comy	array(float)
[	O
citycount	int
]	O
;	O
x1p	float
=	O
x1	float
*	O
cangle	float
-	O
y1	float
*	O
sangle	float
;	O
y1p	float
=	O
x1	float
*	O
sangle	float
+	O
y1	float
*	O
cangle	float
;	O
x2p	float
=	O
x2	float
*	O
cangle	float
-	O
y2	float
*	O
sangle	float
;	O
y2p	float
=	O
x2	float
*	O
sangle	float
+	O
y2	float
*	O
cangle	float
;	O
strcpy	O
(	O
longstreetname	array(char)
,	O
basefilename	array(array(char))
[	O
citycount	int
]	O
)	O
;	O
strcat	O
(	O
longstreetname	array(char)
,	O
streetname	array(char)
)	O
;	O
AddNewVector	(*(char),float,float,float,float,int)->(void)
(	O
longstreetname	array(char)
,	O
-	O
(	O
x1p	float
-	O
centx	O
[	O
citycount	int
]	O
)	O
,	O
(	O
y1p	float
-	O
centy	O
[	O
citycount	int
]	O
)	O
,	O
-	O
(	O
x2p	float
-	O
centx	O
[	O
citycount	int
]	O
)	O
,	O
(	O
y2p	float
-	O
centy	O
[	O
citycount	int
]	O
)	O
,	O
ColorCode	int
)	O
;	O
}	O
}	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
aline	array(char)
,	O
LINE_LEN	int
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
conradius	array(array(float))
[	O
0	int
]	O
[	O
0	int
]	O
=	O
0.55	int
;	O
conradius	array(array(float))
[	O
0	int
]	O
[	O
1	int
]	O
=	O
0.55	int
;	O
conradius	array(array(float))
[	O
0	int
]	O
[	O
2	int
]	O
=	O
0.45	int
;	O
conradius	array(array(float))
[	O
0	int
]	O
[	O
3	int
]	O
=	O
0.45	int
;	O
conradius	array(array(float))
[	O
0	int
]	O
[	O
4	int
]	O
=	O
0.55	int
;	O
conradius	array(array(float))
[	O
0	int
]	O
[	O
5	int
]	O
=	O
0.55	int
;	O
conradius	array(array(float))
[	O
1	int
]	O
[	O
0	int
]	O
=	O
0.37	int
;	O
conradius	array(array(float))
[	O
1	int
]	O
[	O
1	int
]	O
=	O
0.37	int
;	O
conradius	array(array(float))
[	O
1	int
]	O
[	O
2	int
]	O
=	O
0.47	int
;	O
conradius	array(array(float))
[	O
1	int
]	O
[	O
3	int
]	O
=	O
0.47	int
;	O
conradius	array(array(float))
[	O
1	int
]	O
[	O
4	int
]	O
=	O
0.40	int
;	O
conradius	array(array(float))
[	O
1	int
]	O
[	O
5	int
]	O
=	O
0.40	int
;	O
conradius	array(array(float))
[	O
2	int
]	O
[	O
0	int
]	O
=	O
0.56	int
;	O
conradius	array(array(float))
[	O
2	int
]	O
[	O
1	int
]	O
=	O
0.56	int
;	O
conradius	array(array(float))
[	O
2	int
]	O
[	O
2	int
]	O
=	O
0.57	int
;	O
conradius	array(array(float))
[	O
2	int
]	O
[	O
3	int
]	O
=	O
0.57	int
;	O
conradius	array(array(float))
[	O
2	int
]	O
[	O
4	int
]	O
=	O
0.65	int
;	O
conradius	array(array(float))
[	O
2	int
]	O
[	O
5	int
]	O
=	O
0.65	int
;	O
for	O
(	O
citycount	int
=	O
0	int
;	O
citycount	int
<	O
MAX_CITY	int
;	O
citycount	int
++	O
)	O
{	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
6	int
;	O
count	int
++	O
)	O
{	O
angle	float
=	O
STREET_WIDTH	int
/	O
(	O
global_city_mre	O
*	O
conradius	array(array(float))
[	O
citycount	int
]	O
[	O
count	int
]	O
)	O
;	O
switch	O
(	O
count	int
)	O
{	O
case	O
0	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
-	O
180.0	int
+	O
(	O
120.0	int
*	O
citycount	int
-	O
30.0	int
)	O
)	O
-	O
angle	float
;	O
break	O
;	O
case	O
1	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
-	O
180.0	int
+	O
(	O
120.0	int
*	O
citycount	int
)	O
-	O
30.0	int
)	O
+	O
angle	float
;	O
break	O
;	O
case	O
2	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
-	O
180.0	int
+	O
(	O
120.0	int
*	O
citycount	int
)	O
)	O
-	O
angle	float
;	O
break	O
;	O
case	O
3	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
-	O
180.0	int
+	O
(	O
120.0	int
*	O
citycount	int
)	O
)	O
+	O
angle	float
;	O
break	O
;	O
case	O
4	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
-	O
180.0	int
+	O
(	O
120.0	int
*	O
citycount	int
)	O
+	O
30.0	int
)	O
-	O
angle	float
;	O
break	O
;	O
case	O
5	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
-	O
180.0	int
+	O
(	O
120.0	int
*	O
citycount	int
)	O
+	O
30.0	int
)	O
+	O
angle	float
;	O
break	O
;	O
}	O
cangle	float
=	O
(	O
float	O
)	O
cos	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
sangle	float
=	O
(	O
float	O
)	O
sin	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
}	O
}	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
6	int
;	O
count	int
++	O
)	O
{	O
angle	float
=	O
STREET_WIDTH	int
/	O
(	O
ORIGIN_SCALE	int
*	O
global_city_mre	O
)	O
;	O
switch	O
(	O
count	int
&	O
1	int
)	O
{	O
case	O
0	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
120.0	int
*	O
(	O
count	int
>>	O
1	int
)	O
)	O
+	O
angle	float
;	O
break	O
;	O
case	O
1	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
120.0	int
*	O
(	O
count	int
>>	O
1	int
)	O
)	O
-	O
angle	float
;	O
break	O
;	O
}	O
cangle	float
=	O
(	O
float	O
)	O
cos	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
sangle	float
=	O
(	O
float	O
)	O
sin	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
}	O
global_city_mre	O
*=	O
STRUCTURE_SCALE	int
;	O
for	O
(	O
citycount	int
=	O
0	int
;	O
citycount	int
<	O
MAX_CITY	int
;	O
citycount	int
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
lstfile	array(char)
,	O
"./data/"	*(char)
)	O
;	O
strcat	O
(	O
lstfile	array(char)
,	O
basefilename	array(array(char))
[	O
citycount	int
]	O
)	O
;	O
strcat	O
(	O
lstfile	array(char)
,	O
".lst"	*(char)
)	O
;	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
lstfile	array(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Failed to open letters file %s\n"	*(char)
,	O
lstfile	array(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
aline	array(char)
,	O
LINE_LEN	int
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
if	O
(	O
aline	array(char)
[	O
0	int
]	O
!=	O
';'	O
)	O
{	O
if	O
(	O
strncmp	O
(	O
aline	array(char)
,	O
":"	*(char)
,	O
1	int
)	O
)	O
{	O
sscanf	(*(char),*(char))->(int)
(	O
aline	array(char)
,	O
"%s"	*(char)
,	O
streetname	array(char)
)	O
;	O
strcpy	O
(	O
longstreetname	array(char)
,	O
basefilename	array(array(char))
[	O
citycount	int
]	O
)	O
;	O
strcat	O
(	O
longstreetname	array(char)
,	O
streetname	array(char)
)	O
;	O
current_vector	O
=	O
Find_Vector	(*(char))->(*(int))
(	O
longstreetname	array(char)
)	O
;	O
if	O
(	O
!	O
current_vector	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Unknown vector name %s\n"	*(char)
,	O
longstreetname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
current_spacing_x	float
=	O
0.0	int
;	O
current_spacing_y	float
=	O
0.0	int
;	O
vx1	float
=	O
-	O
current_vector	O
->	O
start	O
.	O
x	float
;	O
vy1	float
=	O
current_vector	O
->	O
start	O
.	O
z	float
;	O
vx2	float
=	O
-	O
current_vector	O
->	O
end	O
.	O
x	float
;	O
vy2	float
=	O
current_vector	O
->	O
end	O
.	O
z	float
;	O
dx	float
=	O
vx2	float
-	O
vx1	float
;	O
dy	float
=	O
vy2	float
-	O
vy1	float
;	O
dlen	float
=	O
1.0	int
/	O
sqrt	O
(	O
dx	float
*	O
dx	float
+	O
dy	float
*	O
dy	float
)	O
;	O
dx	float
*=	O
dlen	float
;	O
dy	float
*=	O
dlen	float
;	O
dir	float
=	O
atan2	O
(	O
dx	float
,	O
dy	float
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
current_vector	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Can't have letters before a street definition \n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
sscanf	(*(char),*(char))->(int)
(	O
&	O
aline	array(char)
[	O
2	int
]	O
,	O
"%f %f %f %f"	*(char)
,	O
&	O
width	float
,	O
&	O
height	float
,	O
&	O
depth	float
,	O
&	O
spacing	float
)	O
;	O
if	O
(	O
strlen	O
(	O
aline	array(char)
)	O
>	O
1	int
)	O
{	O
letter	O
=	O
&	O
alphabet	array(int)
[	O
(	O
unsigned	O
char	O
)	O
aline	array(char)
[	O
1	int
]	O
]	O
;	O
letter_width	float
=	O
letter	O
->	O
letter_width	float
;	O
}	O
else	O
letter_width	float
=	O
0.8	int
;	O
current_spacing_x	float
+=	O
(	O
letter_width	float
+	O
0.2	int
)	O
*	O
width	float
*	O
dx	float
;	O
current_spacing_y	float
+=	O
(	O
letter_width	float
+	O
0.2	int
)	O
*	O
width	float
*	O
dy	float
;	O
current_vector	O
->	O
phrase_length	O
=	O
(	O
letter_width	float
+	O
0.1	int
)	O
*	O
width	float
+	O
sqrt	O
(	O
current_spacing_x	float
*	O
current_spacing_x	float
+	O
current_spacing_y	float
*	O
current_spacing_y	float
)	O
;	O
current_vector	O
->	O
num_characters	O
++	O
;	O
}	O
}	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
aline	array(char)
,	O
LINE_LEN	int
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
v	*(void)
=	O
vector_list	*(int)
;	O
while	O
(	O
v	*(void)
!=	O
NULL	O
)	O
{	O
if	O
(	O
v	*(void)
->	O
phrase_length	O
>	O
0.0	int
)	O
{	O
newdr	O
.	O
x	float
=	O
v	*(void)
->	O
end	O
.	O
x	float
-	O
v	*(void)
->	O
start	O
.	O
x	float
;	O
newdr	O
.	O
z	float
=	O
v	*(void)
->	O
end	O
.	O
z	float
-	O
v	*(void)
->	O
start	O
.	O
z	float
;	O
dlen	float
=	O
sqrt	O
(	O
newdr	O
.	O
x	float
*	O
newdr	O
.	O
x	float
+	O
newdr	O
.	O
z	float
*	O
newdr	O
.	O
z	float
)	O
;	O
v	*(void)
->	O
extra_width	O
=	O
dlen	float
/	O
v	*(void)
->	O
phrase_length	O
;	O
}	O
else	O
v	*(void)
->	O
extra_width	O
=	O
0.0	int
;	O
v	*(void)
=	O
v	*(void)
->	O
next	O
;	O
}	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
lstfile	array(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Failed to open letters file %s\n"	*(char)
,	O
lstfile	array(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
current_vector	O
=	O
NULL	O
;	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
aline	array(char)
,	O
LINE_LEN	int
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
if	O
(	O
aline	array(char)
[	O
0	int
]	O
!=	O
';'	O
)	O
{	O
if	O
(	O
strncmp	O
(	O
aline	array(char)
,	O
":"	*(char)
,	O
1	int
)	O
)	O
{	O
sscanf	(*(char),*(char))->(int)
(	O
aline	array(char)
,	O
"%s"	*(char)
,	O
streetname	array(char)
)	O
;	O
strcpy	O
(	O
longstreetname	array(char)
,	O
basefilename	array(array(char))
[	O
citycount	int
]	O
)	O
;	O
strcat	O
(	O
longstreetname	array(char)
,	O
streetname	array(char)
)	O
;	O
current_vector	O
=	O
Find_Vector	(*(char))->(*(int))
(	O
longstreetname	array(char)
)	O
;	O
if	O
(	O
!	O
current_vector	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Unknown vector name %s\n"	*(char)
,	O
longstreetname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
current_spacing_x	float
=	O
0.0	int
;	O
current_spacing_y	float
=	O
0.0	int
;	O
vx1	float
=	O
-	O
current_vector	O
->	O
start	O
.	O
x	float
;	O
vy1	float
=	O
current_vector	O
->	O
start	O
.	O
z	float
;	O
vx2	float
=	O
-	O
current_vector	O
->	O
end	O
.	O
x	float
;	O
vy2	float
=	O
current_vector	O
->	O
end	O
.	O
z	float
;	O
dx	float
=	O
vx2	float
-	O
vx1	float
;	O
dy	float
=	O
vy2	float
-	O
vy1	float
;	O
dlen	float
=	O
1.0	int
/	O
sqrt	O
(	O
dx	float
*	O
dx	float
+	O
dy	float
*	O
dy	float
)	O
;	O
dx	float
*=	O
dlen	float
;	O
dy	float
*=	O
dlen	float
;	O
dir	float
=	O
atan2	O
(	O
dx	float
,	O
dy	float
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
current_vector	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Can't have letters before a street definition \n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
sscanf	(*(char),*(char))->(int)
(	O
&	O
aline	array(char)
[	O
2	int
]	O
,	O
"%f %f %f %f"	*(char)
,	O
&	O
width	float
,	O
&	O
height	float
,	O
&	O
depth	float
,	O
&	O
spacing	float
)	O
;	O
width	float
*=	O
current_vector	O
->	O
extra_width	O
;	O
if	O
(	O
strlen	O
(	O
aline	array(char)
)	O
>	O
1	int
)	O
{	O
letter	O
=	O
&	O
alphabet	array(int)
[	O
(	O
unsigned	O
char	O
)	O
aline	array(char)
[	O
1	int
]	O
]	O
;	O
letter_width	float
=	O
letter	O
->	O
letter_width	float
;	O
num_polygons	int
+=	O
letter	O
->	O
num_polys	O
;	O
character	O
=	O
mav_malloc	()->(int)
(	O
sizeof	O
(	O
Character	O
)	O
)	O
;	O
character	O
->	O
character	O
=	O
letter	O
;	O
character	O
->	O
sp	*(*(int))
=	O
mav_surfaceParamsNew	()->(int)
(	O
MAV_MATERIAL	O
,	O
MapColorCode	()->(int)
(	O
current_vector	O
->	O
sp	*(*(int))
->	O
colour	O
,	O
citycount	int
)	O
,	O
MapColorCode	()->(int)
(	O
current_vector	O
->	O
sp	*(*(int))
->	O
colour	O
,	O
citycount	int
)	O
,	O
0	int
)	O
;	O
current_spacing_x	float
+=	O
0.1	int
*	O
width	float
*	O
dx	float
;	O
current_spacing_y	float
+=	O
0.1	int
*	O
width	float
*	O
dy	float
;	O
newx	float
=	O
-	O
(	O
vx1	float
+	O
current_spacing_x	float
)	O
;	O
newy	float
=	O
vy1	float
+	O
current_spacing_y	float
;	O
character	O
->	O
matrix	O
=	O
mav_matrixSet	()->(int)
(	O
0.0	int
,	O
0.0	int
,	O
-	O
(	O
180.0	int
*	O
dir	float
/	O
MAV_PI	O
+	O
90.0	int
)	O
,	O
newx	float
,	O
0.0	int
,	O
newy	float
)	O
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
0	int
]	O
[	O
0	int
]	O
*=	O
width	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
1	int
]	O
[	O
0	int
]	O
*=	O
width	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
2	int
]	O
[	O
0	int
]	O
*=	O
width	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
3	int
]	O
[	O
0	int
]	O
*=	O
width	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
0	int
]	O
[	O
1	int
]	O
*=	O
height	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
1	int
]	O
[	O
1	int
]	O
*=	O
height	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
2	int
]	O
[	O
1	int
]	O
*=	O
height	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
3	int
]	O
[	O
1	int
]	O
*=	O
height	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
0	int
]	O
[	O
2	int
]	O
*=	O
depth	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
1	int
]	O
[	O
2	int
]	O
*=	O
depth	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
2	int
]	O
[	O
2	int
]	O
*=	O
depth	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
3	int
]	O
[	O
2	int
]	O
*=	O
depth	float
;	O
mav_SMSCallbackObjectAddExec	()->(int)
(	O
city_build	*(int)
,	O
mav_objectNew	()->(int)
(	O
mav_class_character	*(int)
,	O
character	O
)	O
)	O
;	O
mav_BBAlign	()->(int)
(	O
character	O
->	O
character	O
->	O
bb	*(int)
,	O
character	O
->	O
matrix	O
,	O
&	O
bb	*(int)
)	O
;	O
mav_BBCompBB	()->(int)
(	O
bb	*(int)
,	O
&	O
city_bb	int
)	O
;	O
character	O
->	O
centre	O
=	O
mav_vectorScalar	()->(int)
(	O
mav_vectorAdd	()->(int)
(	O
bb	*(int)
.	O
min	O
,	O
bb	*(int)
.	O
max	O
)	O
,	O
0.5	int
)	O
;	O
}	O
else	O
{	O
letter_width	float
=	O
0.8	int
;	O
current_spacing_x	float
+=	O
0.1	int
*	O
width	float
*	O
dx	float
;	O
current_spacing_y	float
+=	O
0.1	int
*	O
width	float
*	O
dy	float
;	O
}	O
current_spacing_x	float
+=	O
(	O
letter_width	float
+	O
0.1	int
)	O
*	O
width	float
*	O
dx	float
;	O
current_spacing_y	float
+=	O
(	O
letter_width	float
+	O
0.1	int
)	O
*	O
width	float
*	O
dy	float
;	O
}	O
}	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
aline	array(char)
,	O
LINE_LEN	int
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Loaded %i polygons into static scene.\n"	*(char)
,	O
num_polygons	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Loaded %i vectors into static scene.\n"	*(char)
,	O
vectorcount	int
)	O
;	O
}	O
int	O
AmsterdamIndexConversionTable	int
[	O
(	O
AMSTERDAM_MAX_COLOR_INDEX	O
+	O
1	int
)	O
]	O
=	O
{	O
1	int
,	O
6	int
,	O
10	int
,	O
4	int
,	O
3	int
,	O
13	int
,	O
5	int
,	O
1	int
,	O
13	int
,	O
4	int
,	O
8	int
,	O
6	int
,	O
2	int
,	O
9	int
,	O
7	int
,	O
13	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
11	int
,	O
14	int
,	O
13	int
,	O
1	int
,	O
7	int
,	O
8	int
,	O
2	int
,	O
1	int
,	O
5	int
,	O
12	int
,	O
14	int
,	O
1	int
,	O
5	int
,	O
9	int
,	O
11	int
,	O
6	int
,	O
10	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
14	int
,	O
14	int
,	O
11	int
,	O
9	int
,	O
8	int
,	O
10	int
,	O
8	int
,	O
12	int
,	O
4	int
,	O
1	int
,	O
3	int
}	O
;	O
int	O
KarlsruheIndexConversionTable	int
[	O
KARLSRUHE_MAX_COLOR_INDEX	O
+	O
1	int
]	O
=	O
{	O
3	int
,	O
9	int
,	O
6	int
,	O
6	int
,	O
4	int
,	O
2	int
,	O
10	int
,	O
1	int
,	O
2	int
,	O
14	int
,	O
3	int
,	O
3	int
,	O
2	int
,	O
5	int
,	O
17	int
,	O
10	int
,	O
18	int
,	O
15	int
,	O
14	int
,	O
11	int
,	O
12	int
,	O
14	int
,	O
4	int
,	O
15	int
,	O
11	int
,	O
8	int
,	O
9	int
,	O
2	int
,	O
4	int
,	O
6	int
,	O
7	int
,	O
4	int
,	O
7	int
,	O
9	int
,	O
8	int
,	O
18	int
,	O
16	int
,	O
2	int
,	O
6	int
,	O
17	int
,	O
18	int
,	O
14	int
,	O
6	int
,	O
19	int
,	O
6	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
}	O
;	O
int	O
TheColorTable	array(array(int))
[	O
NUM_COLORS	int
]	O
[	O
3	int
]	O
=	O
{	O
{	O
255	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
255	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
128	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
128	int
}	O
,	O
{	O
128	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
128	int
}	O
,	O
{	O
0	int
,	O
128	int
,	O
255	int
}	O
,	O
{	O
7	int
,	O
66	int
,	O
96	int
}	O
,	O
{	O
73	int
,	O
182	int
,	O
30	int
}	O
,	O
{	O
100	int
,	O
100	int
,	O
100	int
}	O
,	O
{	O
255	int
,	O
169	int
,	O
66	int
}	O
,	O
{	O
255	int
,	O
26	int
,	O
23	int
}	O
,	O
{	O
255	int
,	O
45	int
,	O
12	int
}	O
,	O
{	O
255	int
,	O
85	int
,	O
23	int
}	O
,	O
{	O
255	int
,	O
23	int
,	O
6	int
}	O
,	O
{	O
207	int
,	O
132	int
,	O
90	int
}	O
,	O
{	O
252	int
,	O
44	int
,	O
58	int
}	O
,	O
{	O
172	int
,	O
123	int
,	O
123	int
}	O
,	O
{	O
255	int
,	O
130	int
,	O
21	int
}	O
,	O
{	O
255	int
,	O
95	int
,	O
3	int
}	O
,	O
{	O
253	int
,	O
2	int
,	O
2	int
}	O
,	O
{	O
253	int
,	O
107	int
,	O
80	int
}	O
,	O
{	O
242	int
,	O
114	int
,	O
34	int
}	O
,	O
{	O
255	int
,	O
78	int
,	O
54	int
}	O
,	O
{	O
216	int
,	O
155	int
,	O
155	int
}	O
,	O
{	O
254	int
,	O
149	int
,	O
149	int
}	O
,	O
{	O
254	int
,	O
254	int
,	O
113	int
}	O
,	O
{	O
207	int
,	O
132	int
,	O
90	int
}	O
,	O
{	O
255	int
,	O
143	int
,	O
57	int
}	O
,	O
{	O
200	int
,	O
200	int
,	O
200	int
}	O
,	O
{	O
125	int
,	O
219	int
,	O
220	int
}	O
,	O
{	O
68	int
,	O
253	int
,	O
141	int
}	O
,	O
{	O
211	int
,	O
100	int
,	O
30	int
}	O
,	O
{	O
146	int
,	O
129	int
,	O
227	int
}	O
,	O
{	O
189	int
,	O
113	int
,	O
55	int
}	O
,	O
{	O
254	int
,	O
200	int
,	O
37	int
}	O
,	O
{	O
250	int
,	O
133	int
,	O
83	int
}	O
,	O
{	O
177	int
,	O
41	int
,	O
1	int
}	O
,	O
{	O
182	int
,	O
202	int
,	O
68	int
}	O
,	O
{	O
255	int
,	O
201	int
,	O
121	int
}	O
,	O
{	O
255	int
,	O
172	int
,	O
222	int
}	O
,	O
{	O
250	int
,	O
250	int
,	O
191	int
}	O
,	O
{	O
203	int
,	O
254	int
,	O
201	int
}	O
}	O
;	O
void	O
PrintRangeError	(int)->(void)
(	O
int	O
ColorCode	int
)	O
{	O
}	O
void	O
GetLetterColor	(int,int,*(float))->(void)
(	O
int	O
ColorCode	int
,	O
int	O
CityCode	int
,	O
float	O
*	O
RGB	*(float)
)	O
{	O
float	O
rgb	array(float)
[	O
3	int
]	O
;	O
int	O
index	array(int)
;	O
switch	O
(	O
CityCode	int
)	O
{	O
case	O
MANHATTAN_COLOR_CODE	O
:	O
if	O
(	O
ColorCode	int
<	O
0	int
)	O
{	O
PrintRangeError	(int)->(void)
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ColorCode	int
>	O
MANHATTAN_MAX_COLOR_INDEX	O
)	O
{	O
PrintRangeError	(int)->(void)
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
MANHATTAN_MAX_COLOR_INDEX	O
;	O
}	O
rgb	array(float)
[	O
0	int
]	O
=	O
TheColorTable	array(array(int))
[	O
ColorCode	int
]	O
[	O
0	int
]	O
/	O
255.0	int
;	O
rgb	array(float)
[	O
1	int
]	O
=	O
TheColorTable	array(array(int))
[	O
ColorCode	int
]	O
[	O
1	int
]	O
/	O
255.0	int
;	O
rgb	array(float)
[	O
2	int
]	O
=	O
TheColorTable	array(array(int))
[	O
ColorCode	int
]	O
[	O
2	int
]	O
/	O
255.0	int
;	O
break	O
;	O
case	O
AMSTERDAM_COLOR_CODE	O
:	O
if	O
(	O
ColorCode	int
<	O
0	int
)	O
{	O
PrintRangeError	(int)->(void)
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ColorCode	int
>	O
AMSTERDAM_MAX_COLOR_INDEX	O
)	O
{	O
PrintRangeError	(int)->(void)
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
AMSTERDAM_MAX_COLOR_INDEX	O
;	O
}	O
index	array(int)
=	O
AmsterdamIndexConversionTable	int
[	O
ColorCode	int
]	O
+	O
13	int
;	O
rgb	array(float)
[	O
0	int
]	O
=	O
TheColorTable	array(array(int))
[	O
index	array(int)
]	O
[	O
0	int
]	O
/	O
255.0	int
;	O
rgb	array(float)
[	O
1	int
]	O
=	O
TheColorTable	array(array(int))
[	O
index	array(int)
]	O
[	O
1	int
]	O
/	O
255.0	int
;	O
rgb	array(float)
[	O
2	int
]	O
=	O
TheColorTable	array(array(int))
[	O
index	array(int)
]	O
[	O
2	int
]	O
/	O
255.0	int
;	O
break	O
;	O
case	O
KARLSRUHE_COLOR_CODE	O
:	O
if	O
(	O
ColorCode	int
<	O
0	int
)	O
{	O
PrintRangeError	(int)->(void)
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ColorCode	int
>	O
KARLSRUHE_MAX_COLOR_INDEX	O
)	O
{	O
PrintRangeError	(int)->(void)
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
KARLSRUHE_MAX_COLOR_INDEX	O
;	O
}	O
index	array(int)
=	O
KarlsruheIndexConversionTable	int
[	O
ColorCode	int
]	O
+	O
27	int
;	O
rgb	array(float)
[	O
0	int
]	O
=	O
TheColorTable	array(array(int))
[	O
index	array(int)
]	O
[	O
0	int
]	O
/	O
255.0	int
;	O
rgb	array(float)
[	O
1	int
]	O
=	O
TheColorTable	array(array(int))
[	O
index	array(int)
]	O
[	O
1	int
]	O
/	O
255.0	int
;	O
rgb	array(float)
[	O
2	int
]	O
=	O
TheColorTable	array(array(int))
[	O
index	array(int)
]	O
[	O
2	int
]	O
/	O
255.0	int
;	O
break	O
;	O
}	O
memcpy	O
(	O
RGB	*(float)
,	O
rgb	array(float)
,	O
3	int
*	O
sizeof	O
(	O
float	O
)	O
)	O
;	O
}	O
void	O
BuildColorTable	()->(void)
(	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
float	O
RGB	*(float)
[	O
3	int
]	O
;	O
float	O
modulation	float
;	O
int	O
ccount	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Building color table"	*(char)
)	O
;	O
ccount	int
=	O
COL_OFFSET	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
MANHATTAN_MAX_COLOR_INDEX	O
;	O
i	int
++	O
)	O
{	O
GetLetterColor	(int,int,*(float))->(void)
(	O
i	int
,	O
MANHATTAN_COLOR_CODE	O
,	O
RGB	*(float)
)	O
;	O
modulation	float
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
NUM_SHADES	O
;	O
j	int
++	O
)	O
{	O
mav_paletteMaterialSet	()->(int)
(	O
mav_palette_default	O
,	O
ccount	int
,	O
0.3	int
*	O
RGB	*(float)
[	O
0	int
]	O
*	O
modulation	float
,	O
0.3	int
*	O
RGB	*(float)
[	O
1	int
]	O
*	O
modulation	float
,	O
0.3	int
*	O
RGB	*(float)
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
,	O
RGB	*(float)
[	O
0	int
]	O
*	O
modulation	float
,	O
RGB	*(float)
[	O
1	int
]	O
*	O
modulation	float
,	O
RGB	*(float)
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	()->(int)
(	O
mav_palette_default	O
,	O
ccount	int
,	O
RGB	*(float)
[	O
0	int
]	O
*	O
modulation	float
,	O
RGB	*(float)
[	O
1	int
]	O
*	O
modulation	float
,	O
RGB	*(float)
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
)	O
;	O
ccount	int
++	O
;	O
modulation	float
-=	O
SHADE_DIFFERENCE	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
AMSTERDAM_MAX_COLOR_INDEX	O
;	O
i	int
++	O
)	O
{	O
GetLetterColor	(int,int,*(float))->(void)
(	O
i	int
,	O
AMSTERDAM_COLOR_CODE	O
,	O
RGB	*(float)
)	O
;	O
modulation	float
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
NUM_SHADES	O
;	O
j	int
++	O
)	O
{	O
mav_paletteMaterialSet	()->(int)
(	O
mav_palette_default	O
,	O
ccount	int
,	O
0.3	int
*	O
RGB	*(float)
[	O
0	int
]	O
*	O
modulation	float
,	O
0.3	int
*	O
RGB	*(float)
[	O
1	int
]	O
*	O
modulation	float
,	O
0.3	int
*	O
RGB	*(float)
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
,	O
RGB	*(float)
[	O
0	int
]	O
*	O
modulation	float
,	O
RGB	*(float)
[	O
1	int
]	O
*	O
modulation	float
,	O
RGB	*(float)
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	()->(int)
(	O
mav_palette_default	O
,	O
ccount	int
,	O
RGB	*(float)
[	O
0	int
]	O
*	O
modulation	float
,	O
RGB	*(float)
[	O
1	int
]	O
*	O
modulation	float
,	O
RGB	*(float)
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
)	O
;	O
ccount	int
++	O
;	O
modulation	float
-=	O
SHADE_DIFFERENCE	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
KARLSRUHE_MAX_COLOR_INDEX	O
;	O
i	int
++	O
)	O
{	O
GetLetterColor	(int,int,*(float))->(void)
(	O
i	int
,	O
KARLSRUHE_COLOR_CODE	O
,	O
RGB	*(float)
)	O
;	O
modulation	float
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
NUM_SHADES	O
;	O
j	int
++	O
)	O
{	O
mav_paletteMaterialSet	()->(int)
(	O
mav_palette_default	O
,	O
ccount	int
,	O
0.3	int
*	O
RGB	*(float)
[	O
0	int
]	O
*	O
modulation	float
,	O
0.3	int
*	O
RGB	*(float)
[	O
1	int
]	O
*	O
modulation	float
,	O
0.3	int
*	O
RGB	*(float)
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
,	O
RGB	*(float)
[	O
0	int
]	O
*	O
modulation	float
,	O
RGB	*(float)
[	O
1	int
]	O
*	O
modulation	float
,	O
RGB	*(float)
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	()->(int)
(	O
mav_palette_default	O
,	O
ccount	int
,	O
RGB	*(float)
[	O
0	int
]	O
*	O
modulation	float
,	O
RGB	*(float)
[	O
1	int
]	O
*	O
modulation	float
,	O
RGB	*(float)
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
)	O
;	O
ccount	int
++	O
;	O
modulation	float
-=	O
SHADE_DIFFERENCE	O
;	O
}	O
}	O
mav_paletteMaterialSet	()->(int)
(	O
mav_palette_default	O
,	O
ccount	int
,	O
0.3	int
*	O
1.0	int
,	O
0.3	int
*	O
1.0	int
,	O
0.3	int
*	O
1.0	int
,	O
1.0	int
,	O
1.0	int
,	O
1.0	int
,	O
1.0	int
,	O
1.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	()->(int)
(	O
mav_palette_default	O
,	O
ccount	int
,	O
1.0	int
,	O
1.0	int
,	O
1.0	int
,	O
1.0	int
)	O
;	O
white_index	int
=	O
ccount	int
;	O
ccount	int
--	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" (%i entries).\n"	*(char)
,	O
ccount	int
)	O
;	O
}	O
int	O
MapColorCode	()->(int)
(	O
int	O
ColorCode	int
,	O
int	O
CityCode	int
)	O
{	O
int	O
index	array(int)
=	O
0	int
;	O
switch	O
(	O
CityCode	int
)	O
{	O
case	O
MANHATTAN_COLOR_CODE	O
:	O
if	O
(	O
ColorCode	int
<	O
0	int
)	O
{	O
PrintRangeError	(int)->(void)
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ColorCode	int
>	O
MANHATTAN_MAX_COLOR_INDEX	O
)	O
{	O
PrintRangeError	(int)->(void)
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
MANHATTAN_MAX_COLOR_INDEX	O
;	O
}	O
index	array(int)
=	O
ColorCode	int
;	O
break	O
;	O
case	O
AMSTERDAM_COLOR_CODE	O
:	O
if	O
(	O
ColorCode	int
<	O
0	int
)	O
{	O
PrintRangeError	(int)->(void)
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ColorCode	int
>	O
AMSTERDAM_MAX_COLOR_INDEX	O
)	O
{	O
PrintRangeError	(int)->(void)
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
AMSTERDAM_MAX_COLOR_INDEX	O
;	O
}	O
index	array(int)
=	O
AmsterdamIndexConversionTable	int
[	O
ColorCode	int
]	O
+	O
13	int
;	O
break	O
;	O
case	O
KARLSRUHE_COLOR_CODE	O
:	O
if	O
(	O
ColorCode	int
<	O
0	int
)	O
{	O
PrintRangeError	(int)->(void)
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ColorCode	int
>	O
KARLSRUHE_MAX_COLOR_INDEX	O
)	O
{	O
PrintRangeError	(int)->(void)
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
KARLSRUHE_MAX_COLOR_INDEX	O
;	O
}	O
index	array(int)
=	O
KarlsruheIndexConversionTable	int
[	O
ColorCode	int
]	O
+	O
27	int
;	O
break	O
;	O
}	O
return	O
(	O
COL_OFFSET	int
+	O
index	array(int)
*	O
NUM_SHADES	O
+	O
(	O
rand	()->(int)
(	O
)	O
%	O
NUM_SHADES	O
)	O
)	O
;	O
}	O
MAV_LCity	O
*	O
mav_newLCity	(*(*(int)))->(*(int))
(	O
MAV_surfaceParams	O
*	O
*	O
sp	*(*(int))
)	O
{	O
MAV_LCity	O
*	O
lc	O
=	O
(	O
MAV_LCity	O
*	O
)	O
mav_malloc	()->(int)
(	O
sizeof	O
(	O
MAV_LCity	O
)	O
)	O
;	O
lc	O
->	O
matrix	O
=	O
MAV_ID_MATRIX	O
;	O
return	O
lc	O
;	O
}	O
int	O
mav_initLCity	()->(int)
(	O
)	O
{	O
mav_class_character	*(int)
=	O
mav_classNew	()->(int)
(	O
)	O
;	O
mav_callbackDrawSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_character	*(int)
,	O
mav_characterDraw	(*(int),*(int))->(int)
)	O
;	O
mav_callbackBBSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_character	*(int)
,	O
mav_characterBBox	(*(int),*(int))->(int)
)	O
;	O
mav_class_feature	*(int)
=	O
mav_classNew	()->(int)
(	O
)	O
;	O
mav_callbackDrawSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_feature	*(int)
,	O
mav_featureDraw	(*(int),*(int))->(int)
)	O
;	O
mav_callbackBBSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_feature	*(int)
,	O
mav_featureBBox	(*(int),*(int))->(int)
)	O
;	O
mav_class_vector	*(int)
=	O
mav_classNew	()->(int)
(	O
)	O
;	O
mav_callbackDrawSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_vector	*(int)
,	O
mav_vectorDraw	(*(int),*(int))->(int)
)	O
;	O
mav_callbackBBSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_vector	*(int)
,	O
mav_vectorBBox	(*(int),*(int))->(int)
)	O
;	O
city_build	*(int)
=	O
mav_SMSNew	()->(int)
(	O
mav_SMSClass_objList	O
,	O
mav_objListNew	()->(int)
(	O
)	O
)	O
;	O
city_sms	*(int)
=	O
mav_SMSNew	()->(int)
(	O
mav_SMSClass_HBB	O
,	O
mav_HBBNew	()->(int)
(	O
)	O
)	O
;	O
city_map	*(int)
=	O
mav_SMSNew	()->(int)
(	O
mav_SMSClass_objList	O
,	O
mav_objListNew	()->(int)
(	O
)	O
)	O
;	O
BuildColorTable	()->(void)
(	O
)	O
;	O
Make_Font	()->(void)
(	O
)	O
;	O
MakeAllStreets	()->(void)
(	O
)	O
;	O
mav_HBBConstructFromSMS	()->(int)
(	O
city_sms	*(int)
,	O
city_build	*(int)
)	O
;	O
mav_SMSDelete	()->(int)
(	O
city_build	*(int)
,	O
MAV_FALSE	O
)	O
;	O
mav_SMSSelectabilitySet	()->(int)
(	O
city_sms	*(int)
,	O
mav_win_all	O
,	O
MAV_FALSE	O
)	O
;	O
return	O
0	int
;	O
}	O
float	O
phi0	array(float)
[	O
DIVN	int
]	O
,	O
phi1	array(float)
[	O
DIVN	int
]	O
;	O
float	O
t0	array(float)
[	O
4	int
*	O
DIVN	int
]	O
,	O
t1	array(float)
[	O
4	int
*	O
DIVN	int
]	O
;	O
float	O
sint0	array(float)
[	O
4	int
*	O
DIVN	int
]	O
,	O
cost0	array(float)
[	O
4	int
*	O
DIVN	int
]	O
,	O
sint1	array(float)
[	O
4	int
*	O
DIVN	int
]	O
,	O
cost1	array(float)
[	O
4	int
*	O
DIVN	int
]	O
;	O
float	O
sinp0	array(float)
[	O
DIVN	int
]	O
,	O
cosp0	array(float)
[	O
DIVN	int
]	O
,	O
sinp1	array(float)
[	O
DIVN	int
]	O
,	O
cosp1	array(float)
[	O
DIVN	int
]	O
;	O
void	O
initDrawCitySky	()->(void)
(	O
)	O
{	O
int	O
i	int
;	O
float	O
theta0	float
;	O
float	O
theta1	float
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
DIVN	int
;	O
i	int
++	O
)	O
{	O
phi0	array(float)
[	O
i	int
]	O
=	O
i	int
/	O
(	O
float	O
)	O
DIVN	int
;	O
phi1	array(float)
[	O
i	int
]	O
=	O
(	O
i	int
+	O
1	int
)	O
/	O
(	O
float	O
)	O
DIVN	int
;	O
sinp0	array(float)
[	O
i	int
]	O
=	O
sin	O
(	O
MAV_PI_OVER_2	O
*	O
phi0	array(float)
[	O
i	int
]	O
)	O
;	O
sinp1	array(float)
[	O
i	int
]	O
=	O
sin	O
(	O
MAV_PI_OVER_2	O
*	O
phi1	array(float)
[	O
i	int
]	O
)	O
;	O
cosp0	array(float)
[	O
i	int
]	O
=	O
cos	O
(	O
MAV_PI_OVER_2	O
*	O
phi0	array(float)
[	O
i	int
]	O
)	O
;	O
cosp1	array(float)
[	O
i	int
]	O
=	O
cos	O
(	O
MAV_PI_OVER_2	O
*	O
phi1	array(float)
[	O
i	int
]	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
*	O
DIVN	int
;	O
i	int
++	O
)	O
{	O
theta0	float
=	O
0.25	int
*	O
i	int
/	O
(	O
float	O
)	O
DIVN	int
;	O
theta1	float
=	O
0.25	int
*	O
(	O
i	int
+	O
1	int
)	O
/	O
(	O
float	O
)	O
DIVN	int
;	O
sint0	array(float)
[	O
i	int
]	O
=	O
sin	O
(	O
MAV_PI_OVER_2	O
*	O
theta0	float
)	O
;	O
sint1	array(float)
[	O
i	int
]	O
=	O
sin	O
(	O
MAV_PI_OVER_2	O
*	O
theta1	float
)	O
;	O
cost0	array(float)
[	O
i	int
]	O
=	O
cos	O
(	O
MAV_PI_OVER_2	O
*	O
theta0	float
)	O
;	O
cost1	array(float)
[	O
i	int
]	O
=	O
cos	O
(	O
MAV_PI_OVER_2	O
*	O
theta1	float
)	O
;	O
t0	array(float)
[	O
i	int
]	O
=	O
0.01	int
+	O
0.99	int
*	O
fabs	O
(	O
0.99	int
-	O
1.98	int
*	O
theta0	float
)	O
;	O
t1	array(float)
[	O
i	int
]	O
=	O
0.01	int
+	O
0.99	int
*	O
fabs	O
(	O
0.99	int
-	O
1.98	int
*	O
theta1	float
)	O
;	O
}	O
}	O
int	O
drawCitySky	()->(int)
(	O
)	O
{	O
MAV_cylinder	O
cyl	O
;	O
MAV_rectangle	O
r	float
;	O
MAV_object	O
o	*(int)
;	O
MAV_surfaceParams	O
s	O
;	O
cyl	O
.	O
radius	float
=	O
590	int
;	O
cyl	O
.	O
height	float
=	O
450	int
;	O
cyl	O
.	O
endcap	O
=	O
0	int
;	O
cyl	O
.	O
nverts	O
=	O
30	int
;	O
cyl	O
.	O
sp	*(*(int))
=	O
sky	*(int)
;	O
cyl	O
.	O
matrix	O
=	O
mav_matrixSet	()->(int)
(	O
0	int
,	O
-	O
90	int
,	O
0	int
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
+	O
cyl	O
.	O
height	float
/	O
2.0	int
-	O
1.0	int
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
)	O
;	O
r	float
.	O
width	float
=	O
2000	int
;	O
r	float
.	O
height	float
=	O
2000	int
;	O
s	O
.	O
mode	int
=	O
MAV_COLOUR	O
;	O
s	O
.	O
colour	O
=	O
MAV_COLOUR_WHITE	O
;	O
r	float
.	O
sp	*(*(int))
=	O
&	O
s	O
;	O
r	float
.	O
matrix	O
=	O
mav_matrixSet	()->(int)
(	O
0	int
,	O
-	O
90	int
,	O
0	int
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
+	O
450	int
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
)	O
;	O
glDisable	()->(int)
(	O
GL_FOG	O
)	O
;	O
glDisable	()->(int)
(	O
GL_CULL_FACE	O
)	O
;	O
o	*(int)
.	O
the_data	O
=	O
&	O
cyl	O
;	O
o	*(int)
.	O
the_class	O
=	O
mav_class_cylinder	O
;	O
mav_cylinderDraw	()->(int)
(	O
&	O
o	*(int)
,	O
NULL	O
)	O
;	O
o	*(int)
.	O
the_data	O
=	O
&	O
r	float
;	O
o	*(int)
.	O
the_class	O
=	O
mav_class_rectangle	O
;	O
mav_rectangleDraw	()->(int)
(	O
&	O
o	*(int)
,	O
NULL	O
)	O
;	O
glEnable	()->(int)
(	O
GL_CULL_FACE	O
)	O
;	O
glEnable	()->(int)
(	O
GL_FOG	O
)	O
;	O
return	O
0	int
;	O
}	O
float	O
floor_gridsize	float
;	O
void	O
initDrawCityFloor	()->(void)
(	O
)	O
{	O
floor_gridsize	float
=	O
fog_distance	int
/	O
(	O
float	O
)	O
FLOOR_STEPS	int
;	O
}	O
int	O
drawCityFloor	()->(int)
(	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
MAV_vector	O
cent	O
;	O
MAV_vector	O
p	*(int)
;	O
MAV_texCoord	O
t	O
;	O
int	O
iorigx	int
,	O
iorigz	int
;	O
float	O
curx	float
,	O
curxx	float
,	O
curz	float
,	O
curzz	float
;	O
mav_surfaceParamsUse	()->(int)
(	O
lcfloor	*(int)
)	O
;	O
cent	O
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
;	O
iorigx	int
=	O
(	O
int	O
)	O
(	O
cent	O
.	O
x	float
/	O
floor_gridsize	float
)	O
;	O
iorigz	int
=	O
(	O
int	O
)	O
(	O
cent	O
.	O
z	float
/	O
floor_gridsize	float
)	O
;	O
curx	float
=	O
(	O
float	O
)	O
(	O
iorigx	int
-	O
FLOOR_STEPS	int
)	O
*	O
floor_gridsize	float
;	O
curxx	float
=	O
curx	float
+	O
floor_gridsize	float
;	O
for	O
(	O
i	int
=	O
(	O
iorigx	int
-	O
FLOOR_STEPS	int
)	O
;	O
i	int
<=	O
(	O
iorigx	int
+	O
FLOOR_STEPS	int
)	O
;	O
i	int
++	O
)	O
{	O
curz	float
=	O
(	O
float	O
)	O
(	O
iorigz	int
-	O
FLOOR_STEPS	int
)	O
*	O
floor_gridsize	float
;	O
curzz	float
=	O
curz	float
+	O
floor_gridsize	float
;	O
for	O
(	O
j	int
=	O
(	O
iorigz	int
-	O
FLOOR_STEPS	int
)	O
;	O
j	int
<=	O
(	O
iorigz	int
+	O
FLOOR_STEPS	int
)	O
;	O
j	int
++	O
)	O
{	O
mav_gfxPolygonBegin	()->(int)
(	O
)	O
;	O
t	O
.	O
s	O
=	O
0.0	int
;	O
t	O
.	O
t	O
=	O
0.0	int
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	*(int)
.	O
x	float
=	O
curx	float
;	O
p	*(int)
.	O
y	float
=	O
-	O
0.1	int
;	O
p	*(int)
.	O
z	float
=	O
curz	float
;	O
mav_gfxVertex	()->(int)
(	O
p	*(int)
)	O
;	O
t	O
.	O
s	O
=	O
0.0	int
;	O
t	O
.	O
t	O
=	O
1.0	int
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	*(int)
.	O
x	float
=	O
curx	float
;	O
p	*(int)
.	O
y	float
=	O
-	O
0.1	int
;	O
p	*(int)
.	O
z	float
=	O
curzz	float
;	O
mav_gfxVertex	()->(int)
(	O
p	*(int)
)	O
;	O
t	O
.	O
s	O
=	O
1.0	int
;	O
t	O
.	O
t	O
=	O
1.0	int
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	*(int)
.	O
x	float
=	O
curxx	float
;	O
p	*(int)
.	O
y	float
=	O
-	O
0.1	int
;	O
p	*(int)
.	O
z	float
=	O
curzz	float
;	O
mav_gfxVertex	()->(int)
(	O
p	*(int)
)	O
;	O
t	O
.	O
s	O
=	O
1.0	int
;	O
t	O
.	O
t	O
=	O
0.0	int
;	O
mav_gfxTexCoord	()->(int)
(	O
t	O
)	O
;	O
p	*(int)
.	O
x	float
=	O
curxx	float
;	O
p	*(int)
.	O
y	float
=	O
-	O
0.1	int
;	O
p	*(int)
.	O
z	float
=	O
curz	float
;	O
mav_gfxVertex	()->(int)
(	O
p	*(int)
)	O
;	O
mav_gfxPolygonEnd	()->(int)
(	O
)	O
;	O
curz	float
+=	O
floor_gridsize	float
;	O
curzz	float
+=	O
floor_gridsize	float
;	O
}	O
curx	float
+=	O
floor_gridsize	float
;	O
curxx	float
+=	O
floor_gridsize	float
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mav_LCityDraw	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_drawInfo	O
*	O
di	*(int)
)	O
{	O
MAV_LCity	O
*	O
lc	O
=	O
(	O
MAV_LCity	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	*(int)
)	O
;	O
MAV_matrix	O
m	*(*(int))
;	O
MAV_vector	O
right	O
,	O
view	O
,	O
up	O
,	O
eye	O
;	O
MAV_vector	O
p	*(int)
;	O
eye	O
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
;	O
eye	O
.	O
x	float
=	O
0.0	int
;	O
eye	O
.	O
y	float
=	O
MAP_ZOOM	int
;	O
eye	O
.	O
z	float
=	O
0.0	int
;	O
right	O
.	O
x	float
=	O
1	int
;	O
right	O
.	O
y	float
=	O
0	int
;	O
right	O
.	O
z	float
=	O
0	int
;	O
view	O
.	O
x	float
=	O
0	int
;	O
view	O
.	O
y	float
=	O
-	O
1	int
;	O
view	O
.	O
z	float
=	O
0	int
;	O
up	O
=	O
mav_vectorScalar	()->(int)
(	O
mav_vectorCrossProduct	()->(int)
(	O
view	O
,	O
right	O
)	O
,	O
-	O
1	int
)	O
;	O
mav_gfxMatrixPush	()->(int)
(	O
)	O
;	O
mav_gfxMatrixMult	()->(int)
(	O
lc	O
->	O
matrix	O
)	O
;	O
current_feature	int
=	O
-	O
1	int
;	O
mav_SMSDisplay	()->(int)
(	O
mav_win_current	O
,	O
city_sms	*(int)
)	O
;	O
drawCitySky	()->(int)
(	O
)	O
;	O
drawCityFloor	()->(int)
(	O
)	O
;	O
glDisable	()->(int)
(	O
GL_FOG	O
)	O
;	O
if	O
(	O
drawMap	int
)	O
{	O
m	*(*(int))
.	O
mat	O
[	O
0	int
]	O
[	O
0	int
]	O
=	O
right	O
.	O
x	float
;	O
m	*(*(int))
.	O
mat	O
[	O
0	int
]	O
[	O
1	int
]	O
=	O
right	O
.	O
y	float
;	O
m	*(*(int))
.	O
mat	O
[	O
0	int
]	O
[	O
2	int
]	O
=	O
right	O
.	O
z	float
;	O
m	*(*(int))
.	O
mat	O
[	O
0	int
]	O
[	O
3	int
]	O
=	O
0.0	int
;	O
m	*(*(int))
.	O
mat	O
[	O
1	int
]	O
[	O
0	int
]	O
=	O
up	O
.	O
x	float
;	O
m	*(*(int))
.	O
mat	O
[	O
1	int
]	O
[	O
1	int
]	O
=	O
up	O
.	O
y	float
;	O
m	*(*(int))
.	O
mat	O
[	O
1	int
]	O
[	O
2	int
]	O
=	O
up	O
.	O
z	float
;	O
m	*(*(int))
.	O
mat	O
[	O
1	int
]	O
[	O
3	int
]	O
=	O
0.0	int
;	O
m	*(*(int))
.	O
mat	O
[	O
2	int
]	O
[	O
0	int
]	O
=	O
-	O
view	O
.	O
x	float
;	O
m	*(*(int))
.	O
mat	O
[	O
2	int
]	O
[	O
1	int
]	O
=	O
-	O
view	O
.	O
y	float
;	O
m	*(*(int))
.	O
mat	O
[	O
2	int
]	O
[	O
2	int
]	O
=	O
-	O
view	O
.	O
z	float
;	O
m	*(*(int))
.	O
mat	O
[	O
2	int
]	O
[	O
3	int
]	O
=	O
0.0	int
;	O
m	*(*(int))
.	O
mat	O
[	O
3	int
]	O
[	O
0	int
]	O
=	O
0.0	int
;	O
m	*(*(int))
.	O
mat	O
[	O
3	int
]	O
[	O
1	int
]	O
=	O
0.0	int
;	O
m	*(*(int))
.	O
mat	O
[	O
3	int
]	O
[	O
2	int
]	O
=	O
0.0	int
;	O
m	*(*(int))
.	O
mat	O
[	O
3	int
]	O
[	O
3	int
]	O
=	O
1.0	int
;	O
mav_gfxMatrixLoad	()->(int)
(	O
m	*(*(int))
)	O
;	O
mav_gfxMatrixTranslate	()->(int)
(	O
mav_vectorScalar	()->(int)
(	O
eye	O
,	O
-	O
1.0	int
)	O
)	O
;	O
mav_surfaceParamsUse	()->(int)
(	O
tranny	*(int)
)	O
;	O
mav_gfxDepthTestSet	()->(int)
(	O
MAV_FALSE	O
)	O
;	O
mav_SMSDisplayUnCulled	()->(int)
(	O
mav_win_current	O
,	O
city_map	*(int)
)	O
;	O
mav_surfaceParamsUse	()->(int)
(	O
mav_sp_default	O
)	O
;	O
mav_gfxPolygonBegin	()->(int)
(	O
)	O
;	O
p	*(int)
.	O
x	float
=	O
0	int
;	O
p	*(int)
.	O
y	float
=	O
1	int
;	O
p	*(int)
.	O
z	float
=	O
0	int
;	O
mav_gfxNormal	()->(int)
(	O
p	*(int)
)	O
;	O
p	*(int)
=	O
mav_vectorAdd	()->(int)
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
,	O
mav_vectorScalar	()->(int)
(	O
mav_win_current	O
->	O
vp	O
->	O
right	O
,	O
50	int
)	O
)	O
;	O
p	*(int)
.	O
z	float
-=	O
MAP_OFFSET	O
;	O
p	*(int)
=	O
mav_vectorScalar	()->(int)
(	O
p	*(int)
,	O
map_scale	float
)	O
;	O
mav_gfxVertex	()->(int)
(	O
p	*(int)
)	O
;	O
p	*(int)
=	O
mav_vectorAdd	()->(int)
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
,	O
mav_vectorScalar	()->(int)
(	O
mav_win_current	O
->	O
vp	O
->	O
view	O
,	O
150	int
)	O
)	O
;	O
p	*(int)
.	O
z	float
-=	O
MAP_OFFSET	O
;	O
p	*(int)
=	O
mav_vectorScalar	()->(int)
(	O
p	*(int)
,	O
map_scale	float
)	O
;	O
mav_gfxVertex	()->(int)
(	O
p	*(int)
)	O
;	O
p	*(int)
=	O
mav_vectorAdd	()->(int)
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
,	O
mav_vectorScalar	()->(int)
(	O
mav_win_current	O
->	O
vp	O
->	O
right	O
,	O
-	O
50	int
)	O
)	O
;	O
p	*(int)
.	O
z	float
-=	O
MAP_OFFSET	O
;	O
p	*(int)
=	O
mav_vectorScalar	()->(int)
(	O
p	*(int)
,	O
map_scale	float
)	O
;	O
mav_gfxVertex	()->(int)
(	O
p	*(int)
)	O
;	O
mav_gfxPolygonEnd	()->(int)
(	O
)	O
;	O
mav_gfxDepthTestSet	()->(int)
(	O
MAV_TRUE	O
)	O
;	O
}	O
glEnable	()->(int)
(	O
GL_FOG	O
)	O
;	O
mav_gfxMatrixPop	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
mav_LCityBB	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_BB	O
*	O
bb	*(int)
)	O
{	O
MAV_LCity	O
*	O
lc	O
=	O
(	O
MAV_LCity	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	*(int)
)	O
;	O
MAV_BB	O
tmp	O
;	O
tmp	O
.	O
min	O
.	O
x	float
=	O
-	O
1000000	int
;	O
tmp	O
.	O
min	O
.	O
y	float
=	O
-	O
1000000	int
;	O
tmp	O
.	O
min	O
.	O
z	float
=	O
-	O
1000000	int
;	O
tmp	O
.	O
max	O
.	O
x	float
=	O
1000000	int
;	O
tmp	O
.	O
max	O
.	O
y	float
=	O
1000000	int
;	O
tmp	O
.	O
max	O
.	O
z	float
=	O
1000000	int
;	O
mav_BBAlign	()->(int)
(	O
tmp	O
,	O
lc	O
->	O
matrix	O
,	O
bb	*(int)
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_LCityGetMatrix	(*(int),*(*(int)))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_matrix	O
*	O
*	O
m	*(*(int))
)	O
{	O
MAV_LCity	O
*	O
lc	O
=	O
(	O
MAV_LCity	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	*(int)
)	O
;	O
*	O
m	*(*(int))
=	O
&	O
lc	O
->	O
matrix	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_LCityID	(*(int),*(*(char)))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
char	O
*	O
*	O
id	*(*(char))
)	O
{	O
*	O
id	*(*(char))
=	O
"LCity"	*(char)
;	O
return	O
1	int
;	O
}	O
int	O
mav_LCityGetUserdef	(*(int),*(*(*(void))))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
void	O
*	O
*	O
*	O
ud	*(*(*(void)))
)	O
{	O
MAV_LCity	O
*	O
lc	O
=	O
(	O
MAV_LCity	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	*(int)
)	O
;	O
*	O
ud	*(*(*(void)))
=	O
&	O
lc	O
->	O
userdef	O
;	O
return	O
1	int
;	O
}	O
char	O
*	O
mav_LCityModuleID	()->(*(char))
(	O
void	O
)	O
{	O
return	O
"LCity"	*(char)
;	O
}	O
float	O
maxxdiff	float
=	O
0.1	int
;	O
float	O
xscale	float
=	O
10.0	int
;	O
int	O
centercount	int
=	O
0	int
;	O
float	O
centersum	float
=	O
0.0	int
;	O
float	O
maxydiff	float
=	O
0.0	int
;	O
float	O
ycenter	float
=	O
0.0	int
;	O
float	O
yscale	float
=	O
0.0	int
;	O
FILE	struct
*	O
conffile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
saveflag	int
;	O
int	O
firsttime	int
=	O
1	int
;	O
float	O
timediff	float
;	O
void	O
LCjoyMove	(*(void))->(void)
(	O
void	O
*	O
ignored	*(void)
)	O
{	O
}	O
void	O
enfog	()->(void)
(	O
void	O
)	O
{	O
glFogi	()->(int)
(	O
GL_FOG_MODE	O
,	O
GL_LINEAR	O
)	O
;	O
glFogfv	()->(int)
(	O
GL_FOG_COLOR	O
,	O
fogColour	array(int)
)	O
;	O
glFogf	()->(int)
(	O
GL_FOG_START	O
,	O
1.0	int
)	O
;	O
glFogf	()->(int)
(	O
GL_FOG_END	O
,	O
fog_distance	int
)	O
;	O
glEnable	()->(int)
(	O
GL_FOG	O
)	O
;	O
}	O
int	O
mav_paletteTextureSet2	(*(int),int,*(char))->(int)
(	O
MAV_palette	O
*	O
p	*(int)
,	O
int	O
i	int
,	O
char	O
*	O
f	int
)	O
{	O
if	O
(	O
mav_opt_stereo	O
)	O
{	O
mav_windowSet	()->(int)
(	O
mav_win_right	O
)	O
;	O
mav_paletteTextureSet	()->(int)
(	O
p	*(int)
,	O
i	int
,	O
f	int
)	O
;	O
mav_windowSet	()->(int)
(	O
mav_win_left	O
)	O
;	O
}	O
return	O
mav_paletteTextureSet	()->(int)
(	O
p	*(int)
,	O
i	int
,	O
f	int
)	O
;	O
}	O
void	O
mav_LCityModuleInit	()->(void)
(	O
void	O
)	O
{	O
mav_moduleNew	()->(int)
(	O
mav_LCityModuleID	()->(*(char))
)	O
;	O
mav_class_character	*(int)
=	O
mav_classNew	()->(int)
(	O
)	O
;	O
mav_callbackDrawSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_character	*(int)
,	O
mav_characterDraw	(*(int),*(int))->(int)
)	O
;	O
mav_callbackBBSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_character	*(int)
,	O
mav_characterBBox	(*(int),*(int))->(int)
)	O
;	O
mav_class_feature	*(int)
=	O
mav_classNew	()->(int)
(	O
)	O
;	O
mav_callbackDrawSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_feature	*(int)
,	O
mav_featureDraw	(*(int),*(int))->(int)
)	O
;	O
mav_callbackBBSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_feature	*(int)
,	O
mav_featureBBox	(*(int),*(int))->(int)
)	O
;	O
mav_class_vector	*(int)
=	O
mav_classNew	()->(int)
(	O
)	O
;	O
mav_callbackDrawSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_vector	*(int)
,	O
mav_vectorDraw	(*(int),*(int))->(int)
)	O
;	O
mav_callbackBBSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_vector	*(int)
,	O
mav_vectorBBox	(*(int),*(int))->(int)
)	O
;	O
city_build	*(int)
=	O
mav_SMSNew	()->(int)
(	O
mav_SMSClass_objList	O
,	O
mav_objListNew	()->(int)
(	O
)	O
)	O
;	O
city_map	*(int)
=	O
mav_SMSNew	()->(int)
(	O
mav_SMSClass_objList	O
,	O
mav_objListNew	()->(int)
(	O
)	O
)	O
;	O
city_sms	*(int)
=	O
mav_SMSNew	()->(int)
(	O
mav_SMSClass_HBB	O
,	O
mav_HBBNew	()->(int)
(	O
)	O
)	O
;	O
grass	*(int)
=	O
mav_surfaceParamsNew	()->(int)
(	O
MAV_TEXTURE	O
,	O
0	int
,	O
1	int
,	O
TEX_GRASS	int
)	O
;	O
canal	*(int)
=	O
mav_surfaceParamsNew	()->(int)
(	O
MAV_TEXTURE	O
,	O
0	int
,	O
1	int
,	O
TEX_CANAL	int
)	O
;	O
stone	*(int)
=	O
mav_surfaceParamsNew	()->(int)
(	O
MAV_TEXTURE	O
,	O
0	int
,	O
1	int
,	O
TEX_STONE	int
)	O
;	O
mav_paletteTextureSet2	(*(int),int,*(char))->(int)
(	O
mav_palette_default	O
,	O
TEX_GRASS	int
,	O
"./data/textures/grass.ppm"	*(char)
)	O
;	O
mav_paletteTextureSet2	(*(int),int,*(char))->(int)
(	O
mav_palette_default	O
,	O
TEX_CANAL	int
,	O
"./data/textures/water.ppm"	*(char)
)	O
;	O
mav_paletteTextureSet2	(*(int),int,*(char))->(int)
(	O
mav_palette_default	O
,	O
TEX_STONE	int
,	O
"./data/textures/stone.ppm"	*(char)
)	O
;	O
BuildColorTable	()->(void)
(	O
)	O
;	O
Make_Font	()->(void)
(	O
)	O
;	O
MakeAllStreets	()->(void)
(	O
)	O
;	O
initDrawCitySky	()->(void)
(	O
)	O
;	O
initDrawCityFloor	()->(void)
(	O
)	O
;	O
sky	*(int)
=	O
mav_surfaceParamsNew	()->(int)
(	O
MAV_TEXTURE	O
,	O
0	int
,	O
1	int
,	O
TEX_SKY	int
)	O
;	O
lcfloor	*(int)
=	O
mav_surfaceParamsNew	()->(int)
(	O
MAV_TEXTURE	O
,	O
0	int
,	O
1	int
,	O
TEX_FLOOR	int
)	O
;	O
mav_paletteColourSet	()->(int)
(	O
mav_palette_default	O
,	O
TEX_TRANNY	int
,	O
0	int
,	O
0	int
,	O
0.5	int
,	O
0.8	int
)	O
;	O
tranny	*(int)
=	O
mav_surfaceParamsNew	()->(int)
(	O
MAV_COLOUR	O
,	O
TEX_TRANNY	int
,	O
0	int
,	O
0	int
)	O
;	O
mav_paletteTextureSet2	(*(int),int,*(char))->(int)
(	O
mav_palette_default	O
,	O
TEX_FLOOR	int
,	O
"./data/textures/rock5.ppm"	*(char)
)	O
;	O
mav_paletteTextureSet2	(*(int),int,*(char))->(int)
(	O
mav_palette_default	O
,	O
TEX_SKY	int
,	O
"./data/textures/lcsky.ppm"	*(char)
)	O
;	O
mav_paletteColourSet	()->(int)
(	O
mav_palette_default	O
,	O
COL_WHITE	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
)	O
;	O
map_white	*(int)
=	O
mav_surfaceParamsNew	()->(int)
(	O
MAV_COLOUR	O
,	O
COL_WHITE	int
,	O
0	int
,	O
0	int
)	O
;	O
mav_HBBConstructFromSMS	()->(int)
(	O
city_sms	*(int)
,	O
city_build	*(int)
)	O
;	O
mav_SMSDelete	()->(int)
(	O
city_build	*(int)
,	O
MAV_FALSE	O
)	O
;	O
if	O
(	O
mav_opt_stereo	O
)	O
{	O
mav_windowSet	()->(int)
(	O
mav_win_right	O
)	O
;	O
enfog	()->(void)
(	O
)	O
;	O
mav_windowSet	()->(int)
(	O
mav_win_left	O
)	O
;	O
}	O
enfog	()->(void)
(	O
)	O
;	O
mav_SMSSelectabilitySet	()->(int)
(	O
city_sms	*(int)
,	O
mav_win_all	O
,	O
MAV_FALSE	O
)	O
;	O
mav_class_lcity	*(int)
=	O
mav_classNew	()->(int)
(	O
)	O
;	O
mav_callbackDrawSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_lcity	*(int)
,	O
mav_LCityDraw	(*(int),*(int))->(int)
)	O
;	O
mav_callbackBBSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_lcity	*(int)
,	O
mav_LCityBB	(*(int),*(int))->(int)
)	O
;	O
mav_callbackIDSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_lcity	*(int)
,	O
mav_LCityID	(*(int),*(*(char)))->(int)
)	O
;	O
mav_callbackGetUserdefSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_lcity	*(int)
,	O
mav_LCityGetUserdef	(*(int),*(*(*(void))))->(int)
)	O
;	O
mav_callbackGetMatrixSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_lcity	*(int)
,	O
mav_LCityGetMatrix	(*(int),*(*(int)))->(int)
)	O
;	O
}	O
int	O
keyPress	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
o	*(int)
,	O
MAV_keyboardEvent	O
*	O
ke	*(int)
)	O
{	O
if	O
(	O
ke	*(int)
->	O
movement	O
==	O
MAV_PRESSED	O
)	O
{	O
switch	O
(	O
ke	*(int)
->	O
key	O
)	O
{	O
case	O
'm'	O
:	O
mav_vp_default	O
.	O
eye	O
=	O
mav_vectorSet	()->(int)
(	O
1684.35	int
,	O
2	int
,	O
0.00	int
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
mav_vp_default	O
.	O
eye	O
=	O
mav_vectorSet	()->(int)
(	O
-	O
842.17	int
,	O
2	int
,	O
1458.69	int
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
mav_vp_default	O
.	O
eye	O
=	O
mav_vectorSet	()->(int)
(	O
-	O
842.17	int
,	O
2	int
,	O
-	O
1458.69	int
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
drawMap	int
=	O
!	O
drawMap	int
;	O
break	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array(*(char))
[	O
]	O
)	O
{	O
MAV_SMS	O
*	O
sms	O
;	O
MAV_object	O
*	O
o	*(int)
;	O
MAV_LCity	O
*	O
lcity	O
;	O
mav_opt_maxMaterials	O
=	O
750	int
;	O
mav_opt_maxColours	O
=	O
750	int
;	O
if	O
(	O
argc	int
>	O
1	int
)	O
mav_opt_stereo	O
=	O
MAV_STEREO_TWO_WINS	O
;	O
mav_initialise	()->(int)
(	O
&	O
argc	int
,	O
argv	array(*(char))
)	O
;	O
mav_LCityModuleInit	()->(void)
(	O
)	O
;	O
mav_windowBackgroundColourSet	()->(int)
(	O
mav_win_all	O
,	O
fogColour	array(int)
[	O
0	int
]	O
,	O
fogColour	array(int)
[	O
1	int
]	O
,	O
fogColour	array(int)
[	O
2	int
]	O
)	O
;	O
mav_windowBackfaceCullSet	()->(int)
(	O
mav_win_all	O
,	O
MAV_TRUE	O
)	O
;	O
lcity	O
=	O
mav_newLCity	(*(*(int)))->(*(int))
(	O
&	O
mav_sp_default	O
)	O
;	O
mav_navigationMouse	()->(int)
(	O
mav_win_all	O
,	O
mav_navigationMouseDefault	O
)	O
;	O
mav_navigationMouseDefaultParams	()->(int)
(	O
mav_win_all	O
,	O
MAV_LEFT_BUTTON	O
,	O
mav_navigateYawFixedUp	O
,	O
0.01	int
,	O
-	O
0.0005	int
,	O
mav_navigateTransForwardsFixedUp	O
,	O
0.01	int
,	O
0.0005	int
)	O
;	O
mav_navigationMouseDefaultParams	()->(int)
(	O
mav_win_all	O
,	O
MAV_RIGHT_BUTTON	O
,	O
mav_navigateRight	O
,	O
0.01	int
,	O
0.0005	int
,	O
mav_navigateUp	O
,	O
0.01	int
,	O
0.0005	int
)	O
;	O
mav_navigationKeyboard	()->(int)
(	O
mav_win_all	O
,	O
mav_navigationKeyboardDefault	O
)	O
;	O
sms	O
=	O
mav_SMSObjListNew	()->(int)
(	O
)	O
;	O
o	*(int)
=	O
mav_objectNew	()->(int)
(	O
mav_class_lcity	*(int)
,	O
lcity	O
)	O
;	O
mav_SMSObjectAdd	()->(int)
(	O
sms	O
,	O
o	*(int)
)	O
;	O
mav_callbackKeyboardSet	()->(int)
(	O
mav_win_all	O
,	O
mav_class_world	O
,	O
keyPress	(*(int),*(int))->(int)
)	O
;	O
mav_stp_default	O
.	O
offset	O
=	O
2.7	int
;	O
mav_vp_default	O
.	O
eye	O
=	O
mav_vectorSet	()->(int)
(	O
-	O
842.17	int
,	O
2	int
,	O
-	O
1458.69	int
)	O
;	O
while	O
(	O
1	int
)	O
{	O
mav_eventsCheck	()->(int)
(	O
)	O
;	O
mav_frameBegin	()->(int)
(	O
)	O
;	O
mav_SMSDisplay	()->(int)
(	O
mav_win_all	O
,	O
sms	O
)	O
;	O
mav_frameEnd	()->(int)
(	O
)	O
;	O
}	O
}	O
