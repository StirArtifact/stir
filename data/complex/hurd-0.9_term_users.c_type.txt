int	O
nperopens	int
;	O
struct	O
async_req	struct(int,*(struct(int,*(struct(int,*(struct`))))))
{	O
mach_port_t	int
notify	int
;	O
struct	O
async_req	struct(int,*(struct(int,*(struct(int,*(struct`))))))
*	O
next	*(struct(int,*(struct(int,*(struct`)))))
;	O
}	O
;	O
struct	O
async_req	struct(int,*(struct(int,*(struct(int,*(struct`))))))
*	O
async_requests	*(struct(int,*(struct(int,*(struct`)))))
;	O
static	O
int	O
num_icky_async_peropens	int
=	O
0	int
;	O
mach_port_t	int
async_icky_id	int
;	O
mach_port_t	int
async_id	int
;	O
struct	O
port_info	O
*	O
cttyid	*(struct)
;	O
int	O
foreground_id	int
;	O
struct	O
winsize	O
window_size	struct
;	O
static	O
int	O
sigs_in_progress	int
;	O
static	O
pthread_cond_t	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
input_sig_wait	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
=	O
PTHREAD_COND_INITIALIZER	O
;	O
static	O
int	O
input_sig_wakeup	int
;	O
static	O
error_t	int
carrier_error	int
;	O
struct	O
protid_hook	struct(int,int,int,int)
{	O
int	O
refcnt	int
;	O
pid_t	int
pid	int
,	O
pgrp	int
,	O
sid	int
;	O
}	O
;	O
void	O
init_users	()->(void)
(	O
)	O
{	O
error_t	int
err	int
;	O
err	int
=	O
ports_create_port	()->(int)
(	O
cttyid_class	*(struct)
,	O
term_bucket	*(struct)
,	O
sizeof	O
(	O
struct	O
port_info	O
)	O
,	O
&	O
cttyid	*(struct)
)	O
;	O
if	O
(	O
err	int
)	O
error	()->(int)
(	O
1	int
,	O
err	int
,	O
"Allocating cttyid"	*(char)
)	O
;	O
mach_port_allocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
&	O
async_icky_id	int
)	O
;	O
mach_port_insert_right	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
async_icky_id	int
,	O
async_icky_id	int
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
mach_port_allocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
&	O
async_id	int
)	O
;	O
mach_port_insert_right	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
async_id	int
,	O
async_id	int
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
}	O
static	O
error_t	int
check_access_hook	(*(struct),*(struct),int,*(int))->(int)
(	O
struct	O
trivfs_control	O
*	O
cntl	*(struct)
,	O
struct	O
iouser	O
*	O
user	*(struct)
,	O
mach_port_t	int
realnode	int
,	O
int	O
*	O
allowed	*(int)
)	O
{	O
struct	O
stat	O
st	struct
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
st	struct
.	O
st_uid	O
=	O
term_owner	int
;	O
st	struct
.	O
st_gid	O
=	O
term_group	int
;	O
st	struct
.	O
st_mode	O
=	O
term_mode	int
;	O
*	O
allowed	*(int)
=	O
0	int
;	O
if	O
(	O
fshelp_access	()->(int)
(	O
&	O
st	struct
,	O
S_IREAD	O
,	O
user	*(struct)
)	O
==	O
0	int
)	O
*	O
allowed	*(int)
|=	O
O_READ	O
;	O
if	O
(	O
fshelp_access	()->(int)
(	O
&	O
st	struct
,	O
S_IWRITE	O
,	O
user	*(struct)
)	O
==	O
0	int
)	O
*	O
allowed	*(int)
|=	O
O_WRITE	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
(	O
*	O
trivfs_check_access_hook	*((*(struct),*(struct),int,*(int))->(int))
)	O
(	O
struct	O
trivfs_control	O
*	O
,	O
struct	O
iouser	O
*	O
,	O
mach_port_t	int
,	O
int	O
*	O
)	O
=	O
check_access_hook	(*(struct),*(struct),int,*(int))->(int)
;	O
static	O
error_t	int
open_hook	(*(struct),*(struct),int)->(int)
(	O
struct	O
trivfs_control	O
*	O
cntl	*(struct)
,	O
struct	O
iouser	O
*	O
user	*(struct)
,	O
int	O
flags	int
)	O
{	O
static	O
int	O
open_count	int
=	O
0	int
;	O
int	O
cancel	int
=	O
0	int
;	O
error_t	int
err	int
;	O
if	O
(	O
cntl	*(struct)
==	O
ptyctl	*(struct)
)	O
return	O
pty_open_hook	(*(struct),*(struct),int)->(int)
(	O
cntl	*(struct)
,	O
user	*(struct)
,	O
flags	int
)	O
;	O
if	O
(	O
(	O
flags	int
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
==	O
0	int
)	O
return	O
0	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
termflags	long
&	O
TTY_OPEN	int
)	O
)	O
{	O
memset	O
(	O
&	O
termstate	struct
,	O
0	int
,	O
sizeof	O
termstate	struct
)	O
;	O
termstate	struct
.	O
c_iflag	O
|=	O
BRKINT	O
|	O
ICRNL	O
|	O
IMAXBEL	O
|	O
IXON	O
|	O
IXANY	O
;	O
termstate	struct
.	O
c_oflag	O
|=	O
OPOST	O
|	O
ONLCR	O
|	O
OXTABS	O
;	O
termstate	struct
.	O
c_lflag	O
|=	O
(	O
ECHO	O
|	O
ICANON	O
|	O
ISIG	O
|	O
IEXTEN	O
|	O
ECHOE	O
|	O
ECHOKE	O
|	O
ECHOCTL	O
)	O
;	O
termstate	struct
.	O
c_cflag	O
|=	O
CREAD	O
|	O
CS8	O
|	O
HUPCL	O
;	O
memcpy	O
(	O
termstate	struct
.	O
c_cc	O
,	O
ttydefchars	O
,	O
NCCS	O
)	O
;	O
memset	O
(	O
&	O
window_size	struct
,	O
0	int
,	O
sizeof	O
window_size	struct
)	O
;	O
termflags	long
|=	O
NO_OWNER	int
;	O
}	O
else	O
{	O
assert	O
(	O
open_count	int
>	O
0	int
)	O
;	O
if	O
(	O
termflags	long
&	O
EXCL_USE	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EBUSY	int
;	O
}	O
}	O
open_count	int
++	O
;	O
if	O
(	O
termflags	long
&	O
NO_CARRIER	int
)	O
{	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
assert_dtr	*(()->(int))
)	O
(	O
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
}	O
while	O
(	O
(	O
(	O
termflags	long
&	O
NO_CARRIER	int
)	O
&&	O
!	O
(	O
termstate	struct
.	O
c_cflag	O
&	O
CLOCAL	O
)	O
)	O
&&	O
!	O
(	O
flags	int
&	O
O_NONBLOCK	int
)	O
&&	O
!	O
cancel	int
)	O
cancel	int
=	O
pthread_hurd_cond_wait_np	()->(int)
(	O
&	O
carrier_alert	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
,	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
cancel	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EINTR	int
;	O
}	O
err	int
=	O
carrier_error	int
;	O
carrier_error	int
=	O
0	int
;	O
if	O
(	O
!	O
err	int
)	O
{	O
struct	O
termios	O
state	*(struct)
=	O
termstate	struct
;	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
set_bits	*((*(struct))->(int))
)	O
(	O
&	O
state	*(struct)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
termstate	struct
=	O
state	*(struct)
;	O
termflags	long
|=	O
TTY_OPEN	int
;	O
}	O
if	O
(	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
gwinsz	*((*(struct))->(int))
)	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
gwinsz	*((*(struct))->(int))
)	O
(	O
&	O
window_size	struct
)	O
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
(	O
*	O
trivfs_check_open_hook	*((*(struct),*(struct),int)->(int))
)	O
(	O
struct	O
trivfs_control	O
*	O
,	O
struct	O
iouser	O
*	O
,	O
int	O
)	O
=	O
open_hook	(*(struct),*(struct),int)->(int)
;	O
static	O
error_t	int
pi_create_hook	(*(struct))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
)	O
{	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
==	O
pty_class	*(struct)
)	O
return	O
0	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
cred	*(struct)
->	O
hook	*(struct(int,int,int,int))
)	O
(	O
(	O
struct	O
protid_hook	struct(int,int,int,int)
*	O
)	O
cred	*(struct)
->	O
hook	*(struct(int,int,int,int))
)	O
->	O
refcnt	int
++	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
(	O
*	O
trivfs_protid_create_hook	*((*(struct))->(int))
)	O
(	O
struct	O
trivfs_protid	O
*	O
)	O
=	O
pi_create_hook	(*(struct))->(int)
;	O
static	O
void	O
pi_destroy_hook	(*(struct))->(void)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
)	O
{	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
==	O
pty_class	*(struct)
)	O
return	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
cred	*(struct)
->	O
hook	*(struct(int,int,int,int))
)	O
{	O
assert	O
(	O
(	O
(	O
struct	O
protid_hook	struct(int,int,int,int)
*	O
)	O
cred	*(struct)
->	O
hook	*(struct(int,int,int,int))
)	O
->	O
refcnt	int
>	O
0	int
)	O
;	O
if	O
(	O
--	O
(	O
(	O
struct	O
protid_hook	struct(int,int,int,int)
*	O
)	O
cred	*(struct)
->	O
hook	*(struct(int,int,int,int))
)	O
->	O
refcnt	int
==	O
0	int
)	O
free	()->(int)
(	O
cred	*(struct)
->	O
hook	*(struct(int,int,int,int))
)	O
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
}	O
void	O
(	O
*	O
trivfs_protid_destroy_hook	*((*(struct))->(void))
)	O
(	O
struct	O
trivfs_protid	O
*	O
)	O
=	O
pi_destroy_hook	(*(struct))->(void)
;	O
static	O
error_t	int
po_create_hook	(*(struct))->(int)
(	O
struct	O
trivfs_peropen	O
*	O
po	*(struct)
)	O
{	O
if	O
(	O
po	*(struct)
->	O
cntl	*(struct)
==	O
ptyctl	*(struct)
)	O
return	O
pty_po_create_hook	(*(struct))->(int)
(	O
po	*(struct)
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
nperopens	int
++	O
;	O
if	O
(	O
po	*(struct)
->	O
openmodes	O
&	O
O_ASYNC	int
)	O
{	O
termflags	long
|=	O
ICKY_ASYNC	int
;	O
num_icky_async_peropens	int
++	O
;	O
call_asyncs	(int)->(void)
(	O
O_READ	O
|	O
O_WRITE	O
)	O
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
(	O
*	O
trivfs_peropen_create_hook	*((*(struct))->(int))
)	O
(	O
struct	O
trivfs_peropen	O
*	O
)	O
=	O
po_create_hook	(*(struct))->(int)
;	O
static	O
void	O
po_destroy_hook	(*(struct))->(void)
(	O
struct	O
trivfs_peropen	O
*	O
po	*(struct)
)	O
{	O
if	O
(	O
po	*(struct)
->	O
cntl	*(struct)
==	O
ptyctl	*(struct)
)	O
{	O
pty_po_destroy_hook	(*(struct))->(int)
(	O
po	*(struct)
)	O
;	O
return	O
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
(	O
po	*(struct)
->	O
openmodes	O
&	O
O_ASYNC	int
)	O
&&	O
--	O
num_icky_async_peropens	int
==	O
0	int
)	O
termflags	long
&=	O
~	O
ICKY_ASYNC	int
;	O
nperopens	int
--	O
;	O
if	O
(	O
!	O
nperopens	int
&&	O
(	O
termflags	long
&	O
TTY_OPEN	int
)	O
)	O
{	O
clear_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(void)
(	O
inputq	*(struct)
)	O
;	O
clear_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(void)
(	O
rawq	*(struct)
)	O
;	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
notice_input_flushed	*(()->(int))
)	O
(	O
)	O
;	O
drain_output	()->(int)
(	O
)	O
;	O
if	O
(	O
(	O
termstate	struct
.	O
c_cflag	O
&	O
HUPCL	O
)	O
||	O
(	O
termflags	long
&	O
NO_CARRIER	int
)	O
)	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
desert_dtr	*(()->(int))
)	O
(	O
)	O
;	O
termflags	long
&=	O
~	O
TTY_OPEN	int
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
}	O
void	O
(	O
*	O
trivfs_peropen_destroy_hook	*((*(struct))->(void))
)	O
(	O
struct	O
trivfs_peropen	O
*	O
)	O
=	O
po_destroy_hook	(*(struct))->(void)
;	O
static	O
inline	O
int	O
fg_p	(*(struct))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
)	O
{	O
struct	O
protid_hook	struct(int,int,int,int)
*	O
hook	*(struct(int,int,int,int))
=	O
cred	*(struct)
->	O
hook	*(struct(int,int,int,int))
;	O
if	O
(	O
!	O
hook	*(struct(int,int,int,int))
||	O
(	O
termflags	long
&	O
NO_OWNER	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
hook	*(struct(int,int,int,int))
->	O
pid	int
==	O
foreground_id	int
||	O
hook	*(struct(int,int,int,int))
->	O
pgrp	int
==	O
-	O
foreground_id	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
trivfs_modify_stat	(*(struct),*(struct))->(void)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
struct	O
stat	O
*	O
st	struct
)	O
{	O
st	struct
->	O
st_blksize	O
=	O
512	int
;	O
st	struct
->	O
st_fstype	O
=	O
FSTYPE_TERM	O
;	O
st	struct
->	O
st_fsid	O
=	O
getpid	()->(int)
(	O
)	O
;	O
st	struct
->	O
st_ino	O
=	O
0	int
;	O
st	struct
->	O
st_rdev	O
=	O
rdev	long
;	O
st	struct
->	O
st_mode	O
=	O
term_mode	int
;	O
st	struct
->	O
st_uid	O
=	O
term_owner	int
;	O
st	struct
->	O
st_gid	O
=	O
term_group	int
;	O
}	O
kern_return_t	O
S_term_getctty	(*(struct),*(int),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
*	O
id	*(int)
,	O
mach_msg_type_name_t	O
*	O
idtype	*(int)
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
*	O
id	*(int)
=	O
ports_get_right	()->(int)
(	O
cttyid	*(struct)
)	O
;	O
*	O
idtype	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
err	int
=	O
0	int
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_termctty_open_terminal	(*(struct),int,*(int),*(int))->(int)
(	O
struct	O
port_info	O
*	O
pi	*(struct)
,	O
int	O
flags	int
,	O
mach_port_t	int
*	O
result	*(int)
,	O
mach_msg_type_name_t	O
*	O
resulttype	*(int)
)	O
{	O
error_t	int
err	int
;	O
mach_port_t	int
new_realnode	O
;	O
struct	O
iouser	O
*	O
user	*(struct)
;	O
struct	O
trivfs_protid	O
*	O
newcred	*(struct)
;	O
if	O
(	O
!	O
pi	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
assert	O
(	O
pi	*(struct)
==	O
cttyid	*(struct)
)	O
;	O
err	int
=	O
io_restrict_auth	()->(int)
(	O
termctl	*(struct)
->	O
underlying	O
,	O
&	O
new_realnode	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
iohelp_create_empty_iouser	()->(int)
(	O
&	O
user	*(struct)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
err	int
=	O
trivfs_open	()->(int)
(	O
termctl	*(struct)
,	O
user	*(struct)
,	O
flags	int
,	O
new_realnode	O
,	O
&	O
newcred	*(struct)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
*	O
result	*(int)
=	O
ports_get_right	()->(int)
(	O
newcred	*(struct)
)	O
;	O
*	O
resulttype	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
ports_port_deref	()->(int)
(	O
newcred	*(struct)
)	O
;	O
}	O
}	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_term_open_ctty	(*(struct),int,int,*(int),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
pid_t	int
pid	int
,	O
pid_t	int
pgrp	int
,	O
mach_port_t	int
*	O
newpt	*(int)
,	O
mach_msg_type_name_t	O
*	O
newpttype	*(int)
)	O
{	O
error_t	int
err	int
;	O
struct	O
trivfs_protid	O
*	O
newcred	*(struct)
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
pid	int
<=	O
0	int
||	O
pgrp	int
<=	O
0	int
)	O
{	O
return	O
EINVAL	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
err	int
=	O
EBADF	int
;	O
}	O
else	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
err	int
=	O
trivfs_protid_dup	()->(int)
(	O
cred	*(struct)
,	O
&	O
newcred	*(struct)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
struct	O
protid_hook	struct(int,int,int,int)
*	O
hook	*(struct(int,int,int,int))
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
protid_hook	struct(int,int,int,int)
)	O
)	O
;	O
hook	*(struct(int,int,int,int))
->	O
pid	int
=	O
pid	int
;	O
hook	*(struct(int,int,int,int))
->	O
pgrp	int
=	O
pgrp	int
;	O
hook	*(struct(int,int,int,int))
->	O
sid	int
=	O
getsid	()->(int)
(	O
pid	int
)	O
;	O
hook	*(struct(int,int,int,int))
->	O
refcnt	int
=	O
1	int
;	O
if	O
(	O
newcred	*(struct)
->	O
hook	*(struct(int,int,int,int))
)	O
pi_destroy_hook	(*(struct))->(void)
(	O
newcred	*(struct)
)	O
;	O
newcred	*(struct)
->	O
hook	*(struct(int,int,int,int))
=	O
hook	*(struct(int,int,int,int))
;	O
*	O
newpt	*(int)
=	O
ports_get_right	()->(int)
(	O
newcred	*(struct)
)	O
;	O
*	O
newpttype	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
ports_port_deref	()->(int)
(	O
newcred	*(struct)
)	O
;	O
}	O
}	O
return	O
err	int
;	O
}	O
error_t	int
trivfs_S_file_chown	(*(struct),int,int,int,int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
uid_t	int
uid	int
,	O
gid_t	int
gid	int
)	O
{	O
struct	O
stat	O
st	struct
;	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
st	struct
.	O
st_uid	O
=	O
term_owner	int
;	O
st	struct
.	O
st_gid	O
=	O
term_group	int
;	O
if	O
(	O
!	O
cred	*(struct)
->	O
isroot	O
)	O
{	O
err	int
=	O
fshelp_isowner	()->(int)
(	O
&	O
st	struct
,	O
cred	*(struct)
->	O
user	*(struct)
)	O
;	O
if	O
(	O
err	int
)	O
goto	O
out	O
;	O
if	O
(	O
(	O
uid	int
!=	O
(	O
uid_t	int
)	O
-	O
1	int
&&	O
!	O
idvec_contains	()->(int)
(	O
cred	*(struct)
->	O
user	*(struct)
->	O
uids	O
,	O
uid	int
)	O
)	O
||	O
(	O
gid	int
!=	O
(	O
gid_t	int
)	O
-	O
1	int
&&	O
!	O
idvec_contains	()->(int)
(	O
cred	*(struct)
->	O
user	*(struct)
->	O
gids	O
,	O
gid	int
)	O
)	O
)	O
{	O
err	int
=	O
EPERM	int
;	O
goto	O
out	O
;	O
}	O
}	O
if	O
(	O
uid	int
!=	O
(	O
uid_t	int
)	O
-	O
1	int
)	O
term_owner	int
=	O
uid	int
;	O
if	O
(	O
gid	int
!=	O
(	O
gid_t	int
)	O
-	O
1	int
)	O
term_group	int
=	O
gid	int
;	O
err	int
=	O
0	int
;	O
out	O
:	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
trivfs_S_file_chmod	(*(struct),int,int,int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
mode_t	int
mode	int
)	O
{	O
error_t	int
err	int
;	O
struct	O
stat	O
st	struct
;	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
cred	*(struct)
->	O
isroot	O
)	O
{	O
st	struct
.	O
st_uid	O
=	O
term_owner	int
;	O
st	struct
.	O
st_gid	O
=	O
term_group	int
;	O
err	int
=	O
fshelp_isowner	()->(int)
(	O
&	O
st	struct
,	O
cred	*(struct)
->	O
user	*(struct)
)	O
;	O
if	O
(	O
err	int
)	O
goto	O
out	O
;	O
mode	int
&=	O
~	O
S_ISVTX	O
;	O
if	O
(	O
!	O
idvec_contains	()->(int)
(	O
cred	*(struct)
->	O
user	*(struct)
->	O
uids	O
,	O
term_owner	int
)	O
)	O
mode	int
&=	O
~	O
S_ISUID	O
;	O
if	O
(	O
!	O
idvec_contains	()->(int)
(	O
cred	*(struct)
->	O
user	*(struct)
->	O
gids	O
,	O
term_group	int
)	O
)	O
mode	int
&=	O
~	O
S_ISUID	O
;	O
}	O
term_mode	int
=	O
(	O
(	O
mode	int
&	O
~	O
S_IFMT	O
&	O
~	O
S_ITRANS	O
&	O
~	O
S_ISPARE	O
)	O
|	O
S_IFCHR	O
|	O
S_IROOT	O
)	O
;	O
err	int
=	O
0	int
;	O
out	O
:	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
trivfs_S_io_write	(*(struct),int,int,*(char),long,long,*(long))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
replytype	int
,	O
char	O
*	O
data	*(char)
,	O
size_t	long
datalen	long
,	O
loff_t	long
offset	long
,	O
size_t	long
*	O
amt	*(long)
)	O
{	O
int	O
i	int
;	O
int	O
cancel	int
;	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
==	O
pty_class	*(struct)
)	O
return	O
pty_io_write	(*(struct),*(char),int,*(int))->(int)
(	O
cred	*(struct)
,	O
data	*(char)
,	O
datalen	long
,	O
amt	*(long)
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
O_WRITE	O
)	O
==	O
0	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EBADF	int
;	O
}	O
if	O
(	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
TOSTOP	O
)	O
&&	O
!	O
fg_p	(*(struct))->(int)
(	O
cred	*(struct)
)	O
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EBACKGROUND	O
;	O
}	O
if	O
(	O
(	O
termflags	long
&	O
NO_CARRIER	int
)	O
&&	O
!	O
(	O
termstate	struct
.	O
c_cflag	O
&	O
CLOCAL	O
)	O
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EIO	int
;	O
}	O
cancel	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
datalen	long
;	O
i	int
++	O
)	O
{	O
while	O
(	O
!	O
qavail	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
outputq	*(struct)
)	O
&&	O
!	O
cancel	int
)	O
{	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
start_output	*(()->(int))
)	O
(	O
)	O
;	O
if	O
(	O
err	int
)	O
cancel	int
=	O
1	int
;	O
else	O
{	O
if	O
(	O
!	O
qavail	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
outputq	*(struct)
)	O
)	O
cancel	int
=	O
pthread_hurd_cond_wait_np	()->(int)
(	O
outputq	*(struct)
->	O
wait	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
,	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
}	O
}	O
if	O
(	O
cancel	int
)	O
break	O
;	O
write_character	(int)->(void)
(	O
data	*(char)
[	O
i	int
]	O
)	O
;	O
}	O
*	O
amt	*(long)
=	O
i	int
;	O
if	O
(	O
!	O
err	int
&&	O
datalen	long
)	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
start_output	*(()->(int))
)	O
(	O
)	O
;	O
trivfs_set_mtime	()->(int)
(	O
termctl	*(struct)
)	O
;	O
call_asyncs	(int)->(void)
(	O
O_WRITE	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
(	O
(	O
cancel	int
&&	O
datalen	long
&&	O
!	O
*	O
amt	*(long)
)	O
?	O
(	O
err	int
?	O
:	O
EINTR	int
)	O
:	O
0	int
)	O
;	O
}	O
error_t	int
trivfs_S_io_read	(*(struct),int,int,*(*(char)),*(long),long,long)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
replytype	int
,	O
char	O
*	O
*	O
data	*(char)
,	O
size_t	long
*	O
datalen	long
,	O
loff_t	long
offset	long
,	O
size_t	long
amount	long
)	O
{	O
int	O
cancel	int
;	O
int	O
i	int
,	O
max	int
;	O
char	O
*	O
cp	*(char)
;	O
int	O
avail	int
;	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
==	O
pty_class	*(struct)
)	O
return	O
pty_io_read	(*(struct),*(*(char)),*(int),int)->(int)
(	O
cred	*(struct)
,	O
data	*(char)
,	O
datalen	long
,	O
amount	long
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
O_READ	O
)	O
==	O
0	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EBADF	int
;	O
}	O
if	O
(	O
!	O
fg_p	(*(struct))->(int)
(	O
cred	*(struct)
)	O
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EBACKGROUND	O
;	O
}	O
while	O
(	O
!	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
inputq	*(struct)
)	O
)	O
{	O
if	O
(	O
(	O
(	O
termflags	long
&	O
NO_CARRIER	int
)	O
&&	O
!	O
(	O
termstate	struct
.	O
c_cflag	O
&	O
CLOCAL	O
)	O
)	O
||	O
!	O
amount	long
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
*	O
datalen	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
O_NONBLOCK	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EWOULDBLOCK	O
;	O
}	O
if	O
(	O
pthread_hurd_cond_wait_np	()->(int)
(	O
inputq	*(struct)
->	O
wait	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
,	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EINTR	int
;	O
}	O
if	O
(	O
sigs_in_progress	int
)	O
{	O
input_sig_wakeup	int
++	O
;	O
if	O
(	O
pthread_hurd_cond_wait_np	()->(int)
(	O
&	O
input_sig_wait	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
,	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EINTR	int
;	O
}	O
}	O
}	O
avail	int
=	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
inputq	*(struct)
)	O
;	O
if	O
(	O
remote_input_mode	int
)	O
avail	int
--	O
;	O
max	int
=	O
(	O
amount	long
<	O
avail	int
)	O
?	O
amount	long
:	O
avail	int
;	O
if	O
(	O
max	int
>	O
*	O
datalen	long
)	O
*	O
data	*(char)
=	O
mmap	(*(void),long,int,int,int,long)->(*(void))
(	O
0	int
,	O
max	int
,	O
PROT_READ	int
|	O
PROT_WRITE	int
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
cancel	int
=	O
0	int
;	O
cp	*(char)
=	O
*	O
data	*(char)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
max	int
;	O
i	int
++	O
)	O
{	O
char	O
c	short
=	O
dequeue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(char)
(	O
inputq	*(struct)
)	O
;	O
if	O
(	O
remote_input_mode	int
)	O
*	O
cp	*(char)
++	O
=	O
c	short
;	O
else	O
{	O
if	O
(	O
!	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
ICANON	O
)	O
||	O
!	O
CCEQ	()->(int)
(	O
termstate	struct
.	O
c_cc	O
[	O
VEOF	O
]	O
,	O
c	short
)	O
)	O
*	O
cp	*(char)
++	O
=	O
c	short
;	O
if	O
(	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
ICANON	O
)	O
&&	O
(	O
c	short
==	O
'\n'	O
||	O
CCEQ	()->(int)
(	O
termstate	struct
.	O
c_cc	O
[	O
VEOF	O
]	O
,	O
c	short
)	O
||	O
CCEQ	()->(int)
(	O
termstate	struct
.	O
c_cc	O
[	O
VEOL	O
]	O
,	O
c	short
)	O
||	O
CCEQ	()->(int)
(	O
termstate	struct
.	O
c_cc	O
[	O
VEOL2	O
]	O
,	O
c	short
)	O
)	O
)	O
break	O
;	O
if	O
(	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
ISIG	O
)	O
&&	O
CCEQ	()->(int)
(	O
termstate	struct
.	O
c_cc	O
[	O
VDSUSP	O
]	O
,	O
c	short
)	O
)	O
{	O
send_signal	(int)->(void)
(	O
SIGTSTP	O
)	O
;	O
cancel	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
remote_input_mode	int
&&	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
inputq	*(struct)
)	O
==	O
1	int
)	O
dequeue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(char)
(	O
inputq	*(struct)
)	O
;	O
*	O
datalen	long
=	O
cp	*(char)
-	O
*	O
data	*(char)
;	O
if	O
(	O
*	O
datalen	long
||	O
!	O
cancel	int
)	O
trivfs_set_atime	()->(int)
(	O
termctl	*(struct)
)	O
;	O
call_asyncs	(int)->(void)
(	O
O_READ	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
!	O
*	O
datalen	long
&&	O
cancel	int
?	O
EINTR	int
:	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_pathconf	(*(struct),int,int,int,*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
int	O
name	int
,	O
int	O
*	O
val	*(int)
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
switch	O
(	O
name	int
)	O
{	O
case	O
_PC_LINK_MAX	O
:	O
case	O
_PC_NAME_MAX	O
:	O
case	O
_PC_PATH_MAX	O
:	O
case	O
_PC_PIPE_BUF	O
:	O
case	O
_PC_NO_TRUNC	O
:	O
default	O
:	O
return	O
io_pathconf	()->(int)
(	O
cred	*(struct)
->	O
realnode	int
,	O
name	int
,	O
val	*(int)
)	O
;	O
case	O
_PC_MAX_CANON	O
:	O
*	O
val	*(int)
=	O
rawq	*(struct)
->	O
hiwat	int
;	O
return	O
0	int
;	O
case	O
_PC_MAX_INPUT	O
:	O
*	O
val	*(int)
=	O
inputq	*(struct)
->	O
hiwat	int
;	O
return	O
0	int
;	O
case	O
_PC_CHOWN_RESTRICTED	O
:	O
*	O
val	*(int)
=	O
1	int
;	O
return	O
0	int
;	O
case	O
_PC_VDISABLE	O
:	O
*	O
val	*(int)
=	O
_POSIX_VDISABLE	O
;	O
return	O
0	int
;	O
}	O
}	O
error_t	int
trivfs_S_io_readable	(*(struct),int,int,*(long))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
replytype	int
,	O
size_t	long
*	O
amt	*(long)
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
==	O
pty_class	*(struct)
)	O
return	O
pty_io_readable	(*(long))->(int)
(	O
amt	*(long)
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
O_READ	O
)	O
==	O
0	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EBADF	int
;	O
}	O
*	O
amt	*(long)
=	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
inputq	*(struct)
)	O
;	O
if	O
(	O
remote_input_mode	int
&&	O
*	O
amt	*(long)
)	O
--	O
*	O
amt	*(long)
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_revoke	(*(struct),int,int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
replytype	int
)	O
{	O
struct	O
stat	O
st	struct
;	O
error_t	int
iterator_function	O
(	O
void	O
*	O
port	*(void)
)	O
{	O
struct	O
trivfs_protid	O
*	O
user	*(struct)
=	O
port	*(void)
;	O
if	O
(	O
user	*(struct)
!=	O
cred	*(struct)
)	O
ports_destroy_right	O
(	O
user	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
cred	*(struct)
->	O
isroot	O
)	O
{	O
error_t	int
err	int
;	O
st	struct
.	O
st_uid	O
=	O
term_owner	int
;	O
st	struct
.	O
st_gid	O
=	O
term_group	int
;	O
err	int
=	O
fshelp_isowner	()->(int)
(	O
&	O
st	struct
,	O
cred	*(struct)
->	O
user	*(struct)
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
ports_inhibit_bucket_rpcs	()->(int)
(	O
term_bucket	*(struct)
)	O
;	O
ports_class_iterate	()->(int)
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
,	O
iterator_function	O
)	O
;	O
ports_resume_bucket_rpcs	()->(int)
(	O
term_bucket	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocmodg	(*(struct),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
*	O
state	*(struct)
)	O
{	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
mdmstate	*((*(int))->(int))
)	O
(	O
state	*(struct)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocmods	(*(struct),int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
state	*(struct)
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
mdmctl	*((int,int)->(int))
)	O
(	O
MDMCTL_SET	int
,	O
state	*(struct)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocexcl	(*(struct))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
termflags	long
|=	O
EXCL_USE	int
;	O
err	int
=	O
0	int
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocnxcl	(*(struct))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
termflags	long
&=	O
~	O
EXCL_USE	int
;	O
err	int
=	O
0	int
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocflush	(*(struct),int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
flags	int
)	O
{	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
if	O
(	O
flags	int
==	O
0	int
)	O
flags	int
=	O
O_READ	O
|	O
O_WRITE	O
;	O
if	O
(	O
flags	int
&	O
O_READ	O
)	O
{	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
notice_input_flushed	*(()->(int))
)	O
(	O
)	O
;	O
clear_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(void)
(	O
inputq	*(struct)
)	O
;	O
}	O
if	O
(	O
!	O
err	int
&&	O
(	O
flags	int
&	O
O_WRITE	O
)	O
)	O
err	int
=	O
drop_output	()->(int)
(	O
)	O
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocgeta	(*(struct),*(int),*(int),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
tcflag_t	O
*	O
modes	int
,	O
cc_t	O
*	O
ccs	*(int)
,	O
speed_t	O
*	O
speeds	*(int)
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
modes	int
[	O
0	int
]	O
=	O
termstate	struct
.	O
c_iflag	O
;	O
modes	int
[	O
1	int
]	O
=	O
termstate	struct
.	O
c_oflag	O
;	O
modes	int
[	O
2	int
]	O
=	O
termstate	struct
.	O
c_cflag	O
;	O
modes	int
[	O
3	int
]	O
=	O
termstate	struct
.	O
c_lflag	O
;	O
memcpy	O
(	O
ccs	*(int)
,	O
termstate	struct
.	O
c_cc	O
,	O
NCCS	O
)	O
;	O
speeds	*(int)
[	O
0	int
]	O
=	O
termstate	struct
.	O
__ispeed	O
;	O
speeds	*(int)
[	O
1	int
]	O
=	O
termstate	struct
.	O
__ospeed	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	int
set_state	(*(struct),*(int),*(int),*(int),int,int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
tcflag_t	O
*	O
modes	int
,	O
cc_t	O
*	O
ccs	*(int)
,	O
speed_t	O
*	O
speeds	*(int)
,	O
int	O
draino	int
,	O
int	O
flushi	int
)	O
{	O
error_t	int
err	int
;	O
struct	O
termios	O
state	*(struct)
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
if	O
(	O
!	O
fg_p	(*(struct))->(int)
(	O
cred	*(struct)
)	O
)	O
err	int
=	O
EBACKGROUND	O
;	O
else	O
{	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
==	O
pty_class	*(struct)
)	O
{	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
abandon_physical_output	*(()->(int))
)	O
(	O
)	O
;	O
if	O
(	O
err	int
)	O
goto	O
leave	O
;	O
clear_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(void)
(	O
outputq	*(struct)
)	O
;	O
}	O
if	O
(	O
draino	int
)	O
{	O
err	int
=	O
drain_output	()->(int)
(	O
)	O
;	O
if	O
(	O
err	int
)	O
goto	O
leave	O
;	O
}	O
if	O
(	O
flushi	int
)	O
{	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
notice_input_flushed	*(()->(int))
)	O
(	O
)	O
;	O
clear_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(void)
(	O
inputq	*(struct)
)	O
;	O
}	O
state	*(struct)
=	O
termstate	struct
;	O
state	*(struct)
.	O
c_iflag	O
=	O
modes	int
[	O
0	int
]	O
;	O
state	*(struct)
.	O
c_oflag	O
=	O
modes	int
[	O
1	int
]	O
;	O
state	*(struct)
.	O
c_cflag	O
=	O
modes	int
[	O
2	int
]	O
;	O
state	*(struct)
.	O
c_lflag	O
=	O
modes	int
[	O
3	int
]	O
;	O
memcpy	O
(	O
state	*(struct)
.	O
c_cc	O
,	O
ccs	*(int)
,	O
NCCS	O
)	O
;	O
state	*(struct)
.	O
__ispeed	O
=	O
speeds	*(int)
[	O
0	int
]	O
;	O
state	*(struct)
.	O
__ospeed	O
=	O
speeds	*(int)
[	O
1	int
]	O
;	O
if	O
(	O
external_processing	int
)	O
state	*(struct)
.	O
c_lflag	O
|=	O
EXTPROC	O
;	O
else	O
state	*(struct)
.	O
c_lflag	O
&=	O
~	O
EXTPROC	O
;	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
set_bits	*((*(struct))->(int))
)	O
(	O
&	O
state	*(struct)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
int	O
oldlflag	int
=	O
termstate	struct
.	O
c_lflag	O
;	O
termstate	struct
=	O
state	*(struct)
;	O
if	O
(	O
oldlflag	int
&	O
ICANON	O
)	O
{	O
if	O
(	O
!	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
ICANON	O
)	O
)	O
copy_rawq	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
ICANON	O
)	O
rescan_inputq	()->(void)
(	O
)	O
;	O
}	O
}	O
err	int
=	O
0	int
;	O
}	O
leave	O
:	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocseta	(*(struct),*(int),*(int),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
tcflag_t	O
*	O
modes	int
,	O
cc_t	O
*	O
ccs	*(int)
,	O
speed_t	O
*	O
speeds	*(int)
)	O
{	O
return	O
set_state	(*(struct),*(int),*(int),*(int),int,int)->(int)
(	O
cred	*(struct)
,	O
modes	int
,	O
ccs	*(int)
,	O
speeds	*(int)
,	O
0	int
,	O
0	int
)	O
;	O
}	O
kern_return_t	O
S_tioctl_tiocsetaw	(*(struct),*(int),*(int),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
tcflag_t	O
*	O
modes	int
,	O
cc_t	O
*	O
ccs	*(int)
,	O
speed_t	O
*	O
speeds	*(int)
)	O
{	O
return	O
set_state	(*(struct),*(int),*(int),*(int),int,int)->(int)
(	O
cred	*(struct)
,	O
modes	int
,	O
ccs	*(int)
,	O
speeds	*(int)
,	O
1	int
,	O
0	int
)	O
;	O
}	O
kern_return_t	O
S_tioctl_tiocsetaf	(*(struct),*(int),*(int),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
tcflag_t	O
*	O
modes	int
,	O
cc_t	O
*	O
ccs	*(int)
,	O
speed_t	O
*	O
speeds	*(int)
)	O
{	O
return	O
set_state	(*(struct),*(int),*(int),*(int),int,int)->(int)
(	O
cred	*(struct)
,	O
modes	int
,	O
ccs	*(int)
,	O
speeds	*(int)
,	O
1	int
,	O
1	int
)	O
;	O
}	O
kern_return_t	O
S_tioctl_tiocgetd	(*(struct),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
*	O
disc	*(int)
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
*	O
disc	*(int)
=	O
0	int
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocsetd	(*(struct),int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
disc	*(int)
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
disc	*(int)
!=	O
0	int
)	O
err	int
=	O
ENXIO	int
;	O
else	O
err	int
=	O
0	int
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocdrain	(*(struct))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
O_WRITE	O
)	O
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EBADF	int
;	O
}	O
err	int
=	O
drain_output	()->(int)
(	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocswinsz	(*(struct),struct)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
struct	O
winsize	O
size	*(struct)
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
0	int
;	O
if	O
(	O
!	O
err	int
&&	O
(	O
size	*(struct)
.	O
ws_row	O
!=	O
window_size	struct
.	O
ws_row	O
||	O
size	*(struct)
.	O
ws_col	O
!=	O
window_size	struct
.	O
ws_col	O
||	O
size	*(struct)
.	O
ws_xpixel	O
!=	O
window_size	struct
.	O
ws_xpixel	O
||	O
size	*(struct)
.	O
ws_ypixel	O
!=	O
window_size	struct
.	O
ws_ypixel	O
)	O
)	O
{	O
window_size	struct
=	O
size	*(struct)
;	O
send_signal	(int)->(void)
(	O
SIGWINCH	O
)	O
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocgwinsz	(*(struct),*(struct))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
struct	O
winsize	O
*	O
size	*(struct)
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
*	O
size	*(struct)
=	O
window_size	struct
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocmget	(*(struct),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
*	O
bits	int
)	O
{	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
mdmstate	*((*(int))->(int))
)	O
(	O
bits	int
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocmset	(*(struct),int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
bits	int
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
mdmctl	*((int,int)->(int))
)	O
(	O
MDMCTL_SET	int
,	O
bits	int
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocmbic	(*(struct),int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
bits	int
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
mdmctl	*((int,int)->(int))
)	O
(	O
MDMCTL_BIC	int
,	O
bits	int
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocmbis	(*(struct),int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
bits	int
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
mdmctl	*((int,int)->(int))
)	O
(	O
MDMCTL_BIS	int
,	O
bits	int
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocstart	(*(struct))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
int	O
old_termflags	int
=	O
termflags	long
;	O
termflags	long
&=	O
~	O
USER_OUTPUT_SUSP	int
;	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
start_output	*(()->(int))
)	O
(	O
)	O
;	O
if	O
(	O
err	int
)	O
termflags	long
=	O
old_termflags	int
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocstop	(*(struct))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
int	O
old_termflags	int
=	O
termflags	long
;	O
termflags	long
|=	O
USER_OUTPUT_SUSP	int
;	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
suspend_physical_output	*(()->(int))
)	O
(	O
)	O
;	O
if	O
(	O
err	int
)	O
termflags	long
=	O
old_termflags	int
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocsti	(*(struct),char)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
char	O
c	short
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
O_READ	O
)	O
)	O
err	int
=	O
EPERM	int
;	O
else	O
{	O
input_character	(int)->(int)
(	O
c	short
)	O
;	O
err	int
=	O
0	int
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocoutq	(*(struct),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
*	O
queue_size	*(int)
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
*	O
queue_size	*(int)
=	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
outputq	*(struct)
)	O
+	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
pending_output_size	*(()->(int))
)	O
(	O
)	O
;	O
err	int
=	O
0	int
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocspgrp	(*(struct),int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
pgrp	int
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
termflags	long
&=	O
~	O
NO_OWNER	int
;	O
foreground_id	int
=	O
-	O
pgrp	int
;	O
err	int
=	O
0	int
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocgpgrp	(*(struct),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
*	O
pgrp	int
)	O
{	O
error_t	int
ret	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
termflags	long
&	O
NO_OWNER	int
)	O
ret	int
=	O
ENOTTY	int
;	O
else	O
{	O
*	O
pgrp	int
=	O
-	O
foreground_id	int
;	O
ret	int
=	O
0	int
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
ret	int
;	O
}	O
kern_return_t	O
S_tioctl_tioccdtr	(*(struct))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
mdmctl	*((int,int)->(int))
)	O
(	O
MDMCTL_BIC	int
,	O
TIOCM_DTR	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocsdtr	(*(struct))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
mdmctl	*((int,int)->(int))
)	O
(	O
MDMCTL_BIS	int
,	O
TIOCM_DTR	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tioccbrk	(*(struct))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
clear_break	*(()->(int))
)	O
(	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocsbrk	(*(struct))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
set_break	*(()->(int))
)	O
(	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
trivfs_S_file_set_size	(*(struct),int,int,long)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
off_t	long
size	*(struct)
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
else	O
if	O
(	O
size	*(struct)
<	O
0	int
)	O
return	O
EINVAL	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
O_WRITE	O
)	O
==	O
0	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EBADF	int
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_seek	(*(struct),int,int,long,int,*(long))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
off_t	long
off	long
,	O
int	O
whence	int
,	O
off_t	long
*	O
newp	*(long)
)	O
{	O
return	O
ESPIPE	int
;	O
}	O
error_t	int
trivfs_S_io_get_openmodes	(*(struct),int,int,*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
replytype	int
,	O
int	O
*	O
bits	int
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
*	O
bits	int
=	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_set_all_openmodes	(*(struct),int,int,int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
replytype	int
,	O
int	O
bits	int
)	O
{	O
int	O
obits	int
;	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
obits	int
=	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
;	O
if	O
(	O
(	O
obits	int
&	O
O_ASYNC	int
)	O
&&	O
--	O
num_icky_async_peropens	int
==	O
0	int
)	O
termflags	long
&=	O
~	O
ICKY_ASYNC	int
;	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&=	O
~	O
HONORED_STATE_MODES	O
;	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
|=	O
(	O
bits	int
&	O
HONORED_STATE_MODES	O
)	O
;	O
if	O
(	O
(	O
bits	int
&	O
O_ASYNC	int
)	O
&&	O
!	O
(	O
obits	int
&	O
O_ASYNC	int
)	O
)	O
{	O
termflags	long
|=	O
ICKY_ASYNC	int
;	O
num_icky_async_peropens	int
++	O
;	O
call_asyncs	(int)->(void)
(	O
O_READ	O
|	O
O_WRITE	O
)	O
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_set_some_openmodes	(*(struct),int,int,int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
int	O
bits	int
)	O
{	O
int	O
obits	int
;	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
obits	int
=	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
;	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
|=	O
(	O
bits	int
&	O
HONORED_STATE_MODES	O
)	O
;	O
if	O
(	O
(	O
bits	int
&	O
O_ASYNC	int
)	O
&&	O
!	O
(	O
obits	int
&	O
O_ASYNC	int
)	O
)	O
{	O
termflags	long
|=	O
ICKY_ASYNC	int
;	O
num_icky_async_peropens	int
++	O
;	O
call_asyncs	(int)->(void)
(	O
O_READ	O
|	O
O_WRITE	O
)	O
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_clear_some_openmodes	(*(struct),int,int,int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
int	O
bits	int
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
O_ASYNC	int
)	O
&&	O
--	O
num_icky_async_peropens	int
==	O
0	int
)	O
termflags	long
&=	O
~	O
ICKY_ASYNC	int
;	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&=	O
~	O
(	O
bits	int
&	O
HONORED_STATE_MODES	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_mod_owner	(*(struct),int,int,int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
pid_t	int
owner	int
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
termflags	long
&=	O
~	O
NO_OWNER	int
;	O
foreground_id	int
=	O
owner	int
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_get_owner	(*(struct),int,int,*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
erply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
pid_t	int
*	O
owner	int
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
termflags	long
&	O
NO_OWNER	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
ENOTTY	int
;	O
}	O
*	O
owner	int
=	O
foreground_id	int
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_get_icky_async_id	(*(struct),int,int,*(int),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
mach_port_t	int
*	O
id	*(int)
,	O
mach_msg_type_name_t	O
*	O
idtype	*(int)
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EBADF	int
;	O
}	O
*	O
id	*(int)
=	O
async_icky_id	int
;	O
*	O
idtype	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_async	(*(struct),int,int,int,*(int),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
mach_port_t	int
notify	int
,	O
mach_port_t	int
*	O
id	*(int)
,	O
mach_msg_type_name_t	O
*	O
idtype	*(int)
)	O
{	O
struct	O
async_req	struct(int,*(struct(int,*(struct(int,*(struct`))))))
*	O
ar	*(struct(int,*(struct(int,*(struct`)))))
;	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EBADF	int
;	O
}	O
ar	*(struct(int,*(struct(int,*(struct`)))))
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
async_req	struct(int,*(struct(int,*(struct(int,*(struct`))))))
)	O
)	O
;	O
ar	*(struct(int,*(struct(int,*(struct`)))))
->	O
notify	int
=	O
notify	int
;	O
ar	*(struct(int,*(struct(int,*(struct`)))))
->	O
next	*(struct(int,*(struct(int,*(struct`)))))
=	O
async_requests	*(struct(int,*(struct(int,*(struct`)))))
;	O
async_requests	*(struct(int,*(struct(int,*(struct`)))))
=	O
ar	*(struct(int,*(struct(int,*(struct`)))))
;	O
*	O
id	*(int)
=	O
async_id	int
;	O
*	O
idtype	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	int
io_select_common	(*(struct),int,int,*(struct(long,long)),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
struct	O
timespec	struct(long,long)
*	O
tsp	*(struct(long,long))
,	O
int	O
*	O
type	enum(int,int,int,int)
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
==	O
pty_class	*(struct)
)	O
return	O
pty_io_select	(*(struct),int,*(struct(long,long)),*(int))->(int)
(	O
cred	*(struct)
,	O
reply	int
,	O
tsp	*(struct(long,long))
,	O
type	enum(int,int,int,int)
)	O
;	O
if	O
(	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
O_READ	O
)	O
==	O
0	int
)	O
*	O
type	enum(int,int,int,int)
&=	O
~	O
SELECT_READ	O
;	O
if	O
(	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
O_WRITE	O
)	O
==	O
0	int
)	O
*	O
type	enum(int,int,int,int)
&=	O
~	O
SELECT_WRITE	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
available	int
=	O
0	int
;	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
(	O
*	O
type	enum(int,int,int,int)
&	O
SELECT_READ	O
)	O
&&	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
inputq	*(struct)
)	O
)	O
available	int
|=	O
SELECT_READ	O
;	O
if	O
(	O
(	O
*	O
type	enum(int,int,int,int)
&	O
SELECT_WRITE	O
)	O
&&	O
qavail	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
outputq	*(struct)
)	O
)	O
available	int
|=	O
SELECT_WRITE	O
;	O
if	O
(	O
available	int
==	O
0	int
)	O
{	O
ports_interrupt_self_on_port_death	()->(int)
(	O
cred	*(struct)
,	O
reply	int
)	O
;	O
err	int
=	O
pthread_hurd_cond_timedwait_np	()->(int)
(	O
&	O
select_alert	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
,	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
,	O
tsp	*(struct(long,long))
)	O
;	O
if	O
(	O
!	O
err	int
)	O
continue	O
;	O
}	O
*	O
type	enum(int,int,int,int)
=	O
available	int
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
err	int
==	O
ETIMEDOUT	int
)	O
err	int
=	O
0	int
;	O
return	O
err	int
;	O
}	O
}	O
error_t	int
trivfs_S_io_select	(*(struct),int,int,*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
int	O
*	O
type	enum(int,int,int,int)
)	O
{	O
return	O
io_select_common	(*(struct),int,int,*(struct(long,long)),*(int))->(int)
(	O
cred	*(struct)
,	O
reply	int
,	O
reply_type	int
,	O
NULL	O
,	O
type	enum(int,int,int,int)
)	O
;	O
}	O
error_t	int
trivfs_S_io_select_timeout	(*(struct),int,int,struct(long,long),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
struct	O
timespec	struct(long,long)
ts	struct(long,long)
,	O
int	O
*	O
type	enum(int,int,int,int)
)	O
{	O
return	O
io_select_common	(*(struct),int,int,*(struct(long,long)),*(int))->(int)
(	O
cred	*(struct)
,	O
reply	int
,	O
reply_type	int
,	O
&	O
ts	struct(long,long)
,	O
type	enum(int,int,int,int)
)	O
;	O
}	O
kern_return_t	O
trivfs_S_io_map	(*(struct),int,int,*(int),*(int),*(int),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
replyPoly	int
,	O
mach_port_t	int
*	O
rdobj	*(int)
,	O
mach_msg_type_name_t	O
*	O
rdtype	*(int)
,	O
mach_port_t	int
*	O
wrobj	*(int)
,	O
mach_msg_type_name_t	O
*	O
wrtype	*(int)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
static	O
void	O
report_sig_start	()->(void)
(	O
)	O
{	O
sigs_in_progress	int
++	O
;	O
}	O
static	O
void	O
report_sig_end	()->(void)
(	O
)	O
{	O
sigs_in_progress	int
--	O
;	O
if	O
(	O
(	O
sigs_in_progress	int
==	O
0	int
)	O
&&	O
input_sig_wakeup	int
)	O
{	O
input_sig_wakeup	int
=	O
0	int
;	O
pthread_cond_broadcast	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)))->(int)
(	O
&	O
input_sig_wait	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
)	O
;	O
}	O
}	O
void	O
call_asyncs	(int)->(void)
(	O
int	O
dir	int
)	O
{	O
struct	O
async_req	struct(int,*(struct(int,*(struct(int,*(struct`))))))
*	O
ar	*(struct(int,*(struct(int,*(struct`)))))
,	O
*	O
nxt	*(struct(int,*(struct(int,*(struct`)))))
,	O
*	O
*	O
prevp	*(*(struct(int,*(struct(int,*`)))))
;	O
mach_port_t	int
err	int
;	O
if	O
(	O
!	O
(	O
termflags	long
&	O
ICKY_ASYNC	int
)	O
&&	O
!	O
async_requests	*(struct(int,*(struct(int,*(struct`)))))
)	O
return	O
;	O
if	O
(	O
(	O
!	O
(	O
dir	int
&	O
O_READ	O
)	O
||	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
inputq	*(struct)
)	O
==	O
0	int
)	O
&&	O
(	O
!	O
(	O
dir	int
&	O
O_WRITE	O
)	O
&&	O
qavail	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
outputq	*(struct)
)	O
==	O
0	int
)	O
)	O
return	O
;	O
if	O
(	O
(	O
termflags	long
&	O
ICKY_ASYNC	int
)	O
&&	O
!	O
(	O
termflags	long
&	O
NO_OWNER	int
)	O
)	O
{	O
report_sig_start	()->(void)
(	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
hurd_sig_post	()->(int)
(	O
foreground_id	int
,	O
SIGIO	O
,	O
async_icky_id	int
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
report_sig_end	()->(void)
(	O
)	O
;	O
}	O
for	O
(	O
ar	*(struct(int,*(struct(int,*(struct`)))))
=	O
async_requests	*(struct(int,*(struct(int,*(struct`)))))
,	O
prevp	*(*(struct(int,*(struct(int,*`)))))
=	O
&	O
async_requests	*(struct(int,*(struct(int,*(struct`)))))
;	O
ar	*(struct(int,*(struct(int,*(struct`)))))
;	O
ar	*(struct(int,*(struct(int,*(struct`)))))
=	O
nxt	*(struct(int,*(struct(int,*(struct`)))))
)	O
{	O
nxt	*(struct(int,*(struct(int,*(struct`)))))
=	O
ar	*(struct(int,*(struct(int,*(struct`)))))
->	O
next	*(struct(int,*(struct(int,*(struct`)))))
;	O
err	int
=	O
nowait_msg_sig_post	()->(int)
(	O
ar	*(struct(int,*(struct(int,*(struct`)))))
->	O
notify	int
,	O
SIGIO	O
,	O
0	int
,	O
async_id	int
)	O
;	O
if	O
(	O
err	int
==	O
MACH_SEND_INVALID_DEST	O
)	O
{	O
*	O
prevp	*(*(struct(int,*(struct(int,*`)))))
=	O
ar	*(struct(int,*(struct(int,*(struct`)))))
->	O
next	*(struct(int,*(struct(int,*(struct`)))))
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
ar	*(struct(int,*(struct(int,*(struct`)))))
->	O
notify	int
)	O
;	O
free	()->(int)
(	O
ar	*(struct(int,*(struct(int,*(struct`)))))
)	O
;	O
}	O
else	O
prevp	*(*(struct(int,*(struct(int,*`)))))
=	O
&	O
ar	*(struct(int,*(struct(int,*(struct`)))))
->	O
next	*(struct(int,*(struct(int,*(struct`)))))
;	O
}	O
}	O
void	O
send_signal	(int)->(void)
(	O
int	O
signo	int
)	O
{	O
mach_port_t	int
right	O
;	O
if	O
(	O
!	O
(	O
termflags	long
&	O
NO_OWNER	int
)	O
)	O
{	O
right	O
=	O
ports_get_send_right	()->(int)
(	O
cttyid	*(struct)
)	O
;	O
report_sig_start	()->(void)
(	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
hurd_sig_post	()->(int)
(	O
foreground_id	int
,	O
signo	int
,	O
right	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
report_sig_end	()->(void)
(	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
right	O
)	O
;	O
}	O
}	O
void	O
report_carrier_off	()->(void)
(	O
)	O
{	O
clear_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(void)
(	O
inputq	*(struct)
)	O
;	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
notice_input_flushed	*(()->(int))
)	O
(	O
)	O
;	O
drop_output	()->(int)
(	O
)	O
;	O
termflags	long
|=	O
NO_CARRIER	int
;	O
if	O
(	O
!	O
(	O
termstate	struct
.	O
c_cflag	O
&	O
CLOCAL	O
)	O
)	O
send_signal	(int)->(void)
(	O
SIGHUP	O
)	O
;	O
}	O
void	O
report_carrier_on	()->(void)
(	O
)	O
{	O
termflags	long
&=	O
~	O
NO_CARRIER	int
;	O
pthread_cond_broadcast	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)))->(int)
(	O
&	O
carrier_alert	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
)	O
;	O
}	O
void	O
report_carrier_error	(int)->(void)
(	O
error_t	int
err	int
)	O
{	O
carrier_error	int
=	O
err	int
;	O
pthread_cond_broadcast	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)))->(int)
(	O
&	O
carrier_alert	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
)	O
;	O
}	O
kern_return_t	O
S_term_get_nodename	(*(struct),*(char))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
char	O
*	O
name	int
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
!	O
cred	*(struct)
->	O
po	*(struct)
->	O
cntl	*(struct)
->	O
hook	*(struct(int,int,int,int))
)	O
{	O
return	O
ENOENT	int
;	O
}	O
strcpy	O
(	O
name	int
,	O
(	O
char	O
*	O
)	O
cred	*(struct)
->	O
po	*(struct)
->	O
cntl	*(struct)
->	O
hook	*(struct(int,int,int,int))
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_term_set_nodename	(*(struct),*(char))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
char	O
*	O
name	int
)	O
{	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
strcmp	O
(	O
name	int
,	O
(	O
char	O
*	O
)	O
cred	*(struct)
->	O
po	*(struct)
->	O
cntl	*(struct)
->	O
hook	*(struct(int,int,int,int))
)	O
!=	O
0	int
)	O
err	int
=	O
EINVAL	int
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_term_set_filenode	(*(struct),int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
file_t	O
filenode	int
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
return	O
EINVAL	int
;	O
}	O
kern_return_t	O
S_term_get_peername	(*(struct),*(char))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
char	O
*	O
name	int
)	O
{	O
struct	O
trivfs_control	O
*	O
peer	*(struct)
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
&&	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
pty_class	*(struct)
)	O
)	O
{	O
if	O
(	O
cred	*(struct)
)	O
ports_port_deref	()->(int)
(	O
cred	*(struct)
)	O
;	O
return	O
EOPNOTSUPP	int
;	O
}	O
peer	*(struct)
=	O
(	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
==	O
tty_class	*(struct)
)	O
?	O
ptyctl	*(struct)
:	O
termctl	*(struct)
;	O
if	O
(	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
!=	O
&	O
ptyio_bottom	struct(enum,*(()->(int)),*(()->(int)),*((*(struct))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct))->(int)),*((int,int)->(int)),*((*(int))->(int)))
||	O
!	O
peer	*(struct)
->	O
hook	*(struct(int,int,int,int))
)	O
{	O
ports_port_deref	()->(int)
(	O
cred	*(struct)
)	O
;	O
return	O
ENOENT	int
;	O
}	O
strcpy	O
(	O
name	int
,	O
(	O
char	O
*	O
)	O
peer	*(struct)
->	O
hook	*(struct(int,int,int,int))
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_term_get_bottom_type	(*(struct),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
*	O
ttype	*(int)
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
*	O
ttype	*(int)
=	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
type	enum(int,int,int,int)
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_term_on_machdev	(*(struct),int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
device_t	O
machdev	int
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
bucket	O
!=	O
term_bucket	*(struct)
||	O
cred	*(struct)
->	O
pi	*(struct)
.	O
class	O
!=	O
tty_class	*(struct)
)	O
return	O
EOPNOTSUPP	int
;	O
return	O
EINVAL	int
;	O
}	O
kern_return_t	O
S_term_on_hurddev	(*(struct),*(struct))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
struct	O
trivfs_protid	O
*	O
hurddev	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
kern_return_t	O
S_term_on_pty	(*(struct),*(*(struct)))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
struct	O
trivfs_protid	O
*	O
*	O
master	*(*(struct))
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
error_t	int
trivfs_goaway	(*(struct),int)->(int)
(	O
struct	O
trivfs_control	O
*	O
cntl	*(struct)
,	O
int	O
flags	int
)	O
{	O
return	O
EBUSY	int
;	O
}	O
