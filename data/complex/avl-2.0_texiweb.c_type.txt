static	O
char	O
*	O
short_pgm_name	*(char)
;	O
enum	O
operation	enum(int,int,int)
{	O
OP_NONE	int
,	O
OP_WEAVE	int
,	O
OP_TANGLE	int
}	O
operation	enum(int,int,int)
;	O
int	O
opt_line	int
;	O
int	O
filenames_only	int
;	O
int	O
print_unused	int
;	O
int	O
print_catalogues	int
;	O
int	O
print_unanswered	int
;	O
int	O
warn_nonzero_indent	int
;	O
struct	O
input_file	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),int)
{	O
struct	O
input_file	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),int)
*	O
outer	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
;	O
char	O
*	O
name	*(char)
;	O
FILE	struct
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
line	int
;	O
}	O
;	O
static	O
char	O
*	O
in_file_name	*(char)
,	O
*	O
out_file_name	*(char)
,	O
*	O
answer_file_name	*(char)
;	O
static	O
FILE	struct
*	O
out_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
*	O
answer_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
*	O
header_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
static	O
struct	O
input_file	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),int)
*	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
;	O
static	O
void	O
emitf	(*(char))->(void)
(	O
const	O
char	O
*	O
format	*(char)
,	O
...	O
)	O
ATTRIBUTE	O
(	O
(	O
format	*(char)
(	O
printf	(*(char))->(int)
,	O
1	int
,	O
2	int
)	O
)	O
)	O
;	O
static	O
void	O
input_start_pass	()->(void)
(	O
void	O
)	O
;	O
static	O
int	O
input_read_line	(*(*(char)),*(long))->(int)
(	O
char	O
*	O
*	O
line	int
,	O
size_t	long
*	O
line_size	*(long)
)	O
;	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
;	O
static	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
symbol_find	(*(char),long,int)->(*(struct))
(	O
const	O
char	O
*	O
name	*(char)
,	O
size_t	long
len	long
,	O
int	O
add	int
)	O
;	O
static	O
void	O
symbol_init	()->(void)
(	O
void	O
)	O
;	O
enum	O
state	enum(int,int,int,int)
{	O
TEXT	int
,	O
CODE	int
,	O
COMMENT	int
,	O
CONTROL	int
}	O
;	O
static	O
int	O
indent_adjust	int
;	O
enum	O
section_level	enum(int,int,int,int,int,int)
{	O
LEVEL_CHAPTER	int
,	O
LEVEL_SECTION	int
,	O
LEVEL_SUBSECTION	int
,	O
LEVEL_SUBSUBSECTION	int
,	O
LEVEL_EXERCISE	int
,	O
LEVEL_CNT	int
}	O
;	O
struct	O
section	struct(array(short))
{	O
short	O
level	array(short)
[	O
LEVEL_CNT	int
]	O
;	O
}	O
;	O
struct	O
section	struct(array(short))
cur_section	struct(array(short))
;	O
static	O
void	O
state_init	()->(void)
(	O
void	O
)	O
;	O
static	O
int	O
state_cnt	()->(int)
(	O
void	O
)	O
;	O
static	O
int	O
state_is	(enum(int,int,int,int))->(int)
(	O
enum	O
state	enum(int,int,int,int)
)	O
;	O
static	O
int	O
state_was	(enum(int,int,int,int))->(int)
(	O
enum	O
state	enum(int,int,int,int)
)	O
;	O
static	O
void	O
state_push	(enum(int,int,int,int))->(void)
(	O
enum	O
state	enum(int,int,int,int)
)	O
;	O
static	O
void	O
state_pop	()->(void)
(	O
void	O
)	O
;	O
struct	O
segment	*(struct)
;	O
static	O
struct	O
segment	*(struct)
*	O
segment_find	(*(char),int)->(*(struct))
(	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
create	int
)	O
;	O
static	O
void	O
segment_select	(*(struct))->(void)
(	O
struct	O
segment	*(struct)
*	O
segment	*(struct)
)	O
;	O
static	O
int	O
segment_selected_p	()->(int)
(	O
void	O
)	O
;	O
static	O
int	O
segment_piece_cur	()->(int)
(	O
void	O
)	O
;	O
static	O
int	O
segment_piece_cnt	()->(int)
(	O
void	O
)	O
;	O
static	O
int	O
segment_number	()->(int)
(	O
void	O
)	O
;	O
static	O
const	O
char	O
*	O
segment_name	()->(*(char))
(	O
void	O
)	O
;	O
static	O
int	O
segment_first_piece	()->(int)
(	O
void	O
)	O
;	O
static	O
int	O
segment_inside_indentation	(*(struct))->(int)
(	O
struct	O
segment	*(struct)
*	O
segment	*(struct)
)	O
;	O
static	O
void	O
segment_next_piece	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
segment_print_number	(*(struct))->(void)
(	O
struct	O
segment	*(struct)
*	O
segment	*(struct)
)	O
;	O
static	O
void	O
segment_add_line	(*(char))->(void)
(	O
const	O
char	O
*	O
line	int
)	O
;	O
static	O
void	O
piece_create	(*(struct),int)->(void)
(	O
struct	O
segment	*(struct)
*	O
s	*(struct)
,	O
int	O
operation	enum(int,int,int)
)	O
;	O
static	O
void	O
piece_references	(*(struct),int)->(void)
(	O
struct	O
segment	*(struct)
*	O
reference	*(struct)
,	O
int	O
indentation	int
)	O
;	O
static	O
void	O
piece_print_trailer	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
print_filename	(*(char))->(void)
(	O
const	O
char	O
*	O
cp	*(char)
)	O
;	O
static	O
void	O
print_anchor_name	(*(char),int)->(void)
(	O
const	O
char	O
*	O
node	*(char)
,	O
int	O
idx	int
)	O
;	O
static	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
print_identifier	(*(char),int)->(*(struct))
(	O
const	O
char	O
*	O
text	*(char)
,	O
int	O
len	long
)	O
;	O
static	O
void	O
print_piece_header	(*(char),int,int)->(void)
(	O
const	O
char	O
*	O
segment_name	()->(*(char))
,	O
int	O
type	int
,	O
int	O
operation	enum(int,int,int)
)	O
;	O
static	O
void	O
open_header_file	(*(char))->(void)
(	O
char	O
*	O
line	int
)	O
;	O
static	O
void	O
close_header_file	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
exercise_begin	(*(char),int)->(void)
(	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
;	O
static	O
int	O
exercise_end	(*(char),*(char),int)->(int)
(	O
const	O
char	O
*	O
cmd	*(char)
,	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
;	O
static	O
void	O
exercise_answer	(*(char),int)->(void)
(	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
;	O
static	O
void	O
exercise_close_answer_file	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
exercise_open_answer_file	(*(char),int)->(void)
(	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
;	O
static	O
int	O
exercise_process	(*(char),*(char),int)->(int)
(	O
const	O
char	O
*	O
cmd	*(char)
,	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
;	O
static	O
int	O
parse_at_cmd	(*(char),array(char))->(int)
(	O
const	O
char	O
*	O
line	int
,	O
char	O
cmd	*(char)
[	O
CMD_LEN_MAX	int
+	O
1	int
]	O
)	O
;	O
static	O
void	O
add_control	(*(char),long)->(void)
(	O
const	O
char	O
*	O
text	*(char)
,	O
size_t	long
len	long
)	O
;	O
static	O
char	O
*	O
parse_control_text	(*(char),*(*(char)))->(*(char))
(	O
char	O
*	O
start	*(char)
,	O
char	O
*	O
*	O
tail	*(*(char))
)	O
;	O
struct	O
token	*(struct)
;	O
static	O
const	O
char	O
*	O
token_get	(*(char),*(struct))->(*(char))
(	O
const	O
char	O
*	O
s	*(struct)
,	O
struct	O
token	*(struct)
*	O
token	*(struct)
)	O
;	O
static	O
const	O
char	O
*	O
token_parse	(*(char),*(struct))->(*(char))
(	O
const	O
char	O
*	O
cp	*(char)
,	O
struct	O
token	*(struct)
*	O
token	*(struct)
)	O
;	O
static	O
int	O
token_space_p	(*(struct))->(int)
(	O
struct	O
token	*(struct)
*	O
token	*(struct)
)	O
;	O
static	O
void	O
weave_pass_one	()->(void)
(	O
void	O
)	O
;	O
static	O
char	O
*	O
segment_definition_line	(*(char),*(int))->(*(char))
(	O
char	O
*	O
line	int
,	O
int	O
*	O
operation	enum(int,int,int)
)	O
;	O
static	O
void	O
enforce_references_ordering	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
weave_pass_two	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
transition	(enum(int,int,int,int))->(void)
(	O
enum	O
state	enum(int,int,int,int)
)	O
;	O
static	O
int	O
indent_amount	(*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
cp	*(char)
,	O
const	O
char	O
*	O
*	O
const	O
end	*(*(char))
)	O
;	O
static	O
int	O
print_line	(*(char),int)->(int)
(	O
const	O
char	O
*	O
cp	*(char)
,	O
int	O
flags	int
)	O
;	O
static	O
int	O
print	(*(char),int)->(int)
(	O
const	O
char	O
*	O
cp	*(char)
,	O
int	O
flags	int
)	O
;	O
static	O
void	O
tangle	()->(void)
(	O
void	O
)	O
;	O
struct	O
engine_state	struct(enum(int,int,int),*(char),*(char),int,int,*(char),int,enum(int,int,int,int),enum(int,int,int,int),int,array(int))
;	O
static	O
void	O
init_engine_state	(*(struct))->(void)
(	O
struct	O
engine_state	struct(enum(int,int,int),*(char),*(char),int,int,*(char),int,enum(int,int,int,int),enum(int,int,int,int),int,array(int))
*	O
s	*(struct)
)	O
;	O
static	O
int	O
lr_engine	(*(struct),*(struct))->(int)
(	O
struct	O
engine_state	struct(enum(int,int,int),*(char),*(char),int,int,*(char),int,enum(int,int,int,int),enum(int,int,int,int),int,array(int))
*	O
engine	*(struct)
,	O
struct	O
token	*(struct)
*	O
token	*(struct)
)	O
;	O
static	O
void	O
declaration_engine	(*(char),int)->(void)
(	O
const	O
char	O
*	O
cp	*(char)
,	O
int	O
indentation	int
)	O
;	O
static	O
void	O
parse_cmd_line	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
;	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
exit_code	int
)	O
ATTRIBUTE	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
enum	O
{	O
SRC	int
=	O
001	int
,	O
FTL	int
=	O
002	int
}	O
;	O
static	O
void	O
error	(int,*(char))->(void)
(	O
int	O
flags	int
,	O
const	O
char	O
*	O
message	*(char)
,	O
...	O
)	O
ATTRIBUTE	O
(	O
(	O
format	*(char)
(	O
printf	(*(char))->(int)
,	O
2	int
,	O
3	int
)	O
)	O
)	O
;	O
static	O
void	O
*	O
xmalloc	(long)->(*(void))
(	O
size_t	long
amt	long
)	O
;	O
static	O
void	O
*	O
xrealloc	(*(void),long)->(*(void))
(	O
void	O
*	O
ptr	*(void)
,	O
size_t	long
size	long
)	O
;	O
static	O
char	O
*	O
xstrndup	(*(char),long)->(*(char))
(	O
const	O
char	O
*	O
buf	*(char)
,	O
size_t	long
len	long
)	O
;	O
static	O
char	O
*	O
xstrdup	(*(char))->(*(char))
(	O
const	O
char	O
*	O
string	*(char)
)	O
;	O
static	O
int	O
empty_string	(*(char))->(int)
(	O
const	O
char	O
*	O
string	*(char)
)	O
;	O
static	O
void	O
trim_whitespace	(*(*(char)),*(*(char)))->(void)
(	O
char	O
*	O
*	O
bp	*(*(char))
,	O
char	O
*	O
*	O
ep	*(*(char))
)	O
;	O
static	O
int	O
find_argument	(*(char),*(*(char)),*(*(char)))->(int)
(	O
char	O
*	O
line	int
,	O
char	O
*	O
*	O
bp	*(*(char))
,	O
char	O
*	O
*	O
ep	*(*(char))
)	O
;	O
static	O
int	O
find_optional_argument	(*(char),*(*(char)),*(*(char)))->(int)
(	O
char	O
*	O
line	int
,	O
char	O
*	O
*	O
bp	*(*(char))
,	O
char	O
*	O
*	O
ep	*(*(char))
)	O
;	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
parse_cmd_line	(int,*(*(char)))->(void)
(	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
symbol_init	()->(void)
(	O
)	O
;	O
switch	O
(	O
operation	enum(int,int,int)
)	O
{	O
case	O
OP_WEAVE	int
:	O
weave_pass_one	()->(void)
(	O
)	O
;	O
weave_pass_two	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
OP_TANGLE	int
:	O
tangle	()->(void)
(	O
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
static	O
struct	O
dir_directive	struct(enum(int,int,int),*(char),int)
{	O
enum	O
operation	enum(int,int,int)
include	enum(int,int,int)
;	O
char	O
*	O
name	*(char)
;	O
int	O
line	int
;	O
}	O
dir_stack	array(struct(enum(int,int,int),*(char),int))
[	O
DIR_MAX	int
]	O
;	O
static	O
int	O
dir_stack_height	int
;	O
static	O
int	O
dir_ignore	int
;	O
static	O
void	O
dir_push	(enum(int,int,int))->(void)
(	O
enum	O
operation	enum(int,int,int)
include	enum(int,int,int)
)	O
{	O
if	O
(	O
dir_stack_height	int
>=	O
DIR_MAX	int
)	O
error	(int,*(char))->(void)
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"Input directives nested too deeply."	*(char)
)	O
)	O
;	O
dir_stack	array(struct(enum(int,int,int),*(char),int))
[	O
dir_stack_height	int
]	O
.	O
include	enum(int,int,int)
=	O
include	enum(int,int,int)
;	O
dir_stack	array(struct(enum(int,int,int),*(char),int))
[	O
dir_stack_height	int
]	O
.	O
name	*(char)
=	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
name	*(char)
;	O
dir_stack	array(struct(enum(int,int,int),*(char),int))
[	O
dir_stack_height	int
]	O
.	O
line	int
=	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
line	int
;	O
dir_stack_height	int
++	O
;	O
if	O
(	O
include	enum(int,int,int)
!=	O
operation	enum(int,int,int)
)	O
dir_ignore	int
++	O
;	O
}	O
static	O
void	O
dir_pop	(enum(int,int,int))->(void)
(	O
enum	O
operation	enum(int,int,int)
include	enum(int,int,int)
)	O
{	O
if	O
(	O
dir_stack_height	int
<=	O
0	int
)	O
{	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"`@end' pairs with nonexistent input directive."	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
dir_stack_height	int
--	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
dir_stack	array(struct(enum(int,int,int),*(char),int))
[	O
dir_stack_height	int
]	O
.	O
name	*(char)
,	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
name	*(char)
)	O
)	O
{	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"`@end' not in same file as corresponding `@if'."	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: Here is the corresponding `@if'.\n"	*(char)
)	O
,	O
dir_stack	array(struct(enum(int,int,int),*(char),int))
[	O
dir_stack_height	int
]	O
.	O
name	*(char)
,	O
dir_stack	array(struct(enum(int,int,int),*(char),int))
[	O
dir_stack_height	int
]	O
.	O
line	int
)	O
;	O
}	O
else	O
if	O
(	O
dir_stack	array(struct(enum(int,int,int),*(char),int))
[	O
dir_stack_height	int
]	O
.	O
include	enum(int,int,int)
!=	O
include	enum(int,int,int)
)	O
{	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"`@end' does not match corresponding `@if'."	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: Here is the corresponding `@if'.\n"	*(char)
)	O
,	O
dir_stack	array(struct(enum(int,int,int),*(char),int))
[	O
dir_stack_height	int
]	O
.	O
name	*(char)
,	O
dir_stack	array(struct(enum(int,int,int),*(char),int))
[	O
dir_stack_height	int
]	O
.	O
line	int
)	O
;	O
}	O
if	O
(	O
dir_stack	array(struct(enum(int,int,int),*(char),int))
[	O
dir_stack_height	int
]	O
.	O
include	enum(int,int,int)
!=	O
operation	enum(int,int,int)
)	O
dir_ignore	int
--	O
;	O
}	O
static	O
int	O
dir_parse_ifx	(*(char))->(int)
(	O
char	O
*	O
line	int
)	O
{	O
char	O
cmd	*(char)
[	O
CMD_LEN_MAX	int
+	O
1	int
]	O
;	O
if	O
(	O
!	O
parse_at_cmd	(*(char),array(char))->(int)
(	O
line	int
,	O
cmd	*(char)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"ifweave"	*(char)
)	O
)	O
dir_push	(enum(int,int,int))->(void)
(	O
OP_WEAVE	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"iftangle"	*(char)
)	O
)	O
dir_push	(enum(int,int,int))->(void)
(	O
OP_TANGLE	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"end"	*(char)
)	O
)	O
{	O
char	O
*	O
bp	*(*(char))
,	O
*	O
ep	*(*(char))
;	O
if	O
(	O
!	O
find_argument	(*(char),*(*(char)),*(*(char)))->(int)
(	O
line	int
,	O
&	O
bp	*(*(char))
,	O
&	O
ep	*(*(char))
)	O
)	O
return	O
0	int
;	O
if	O
(	O
(	O
size_t	long
)	O
(	O
ep	*(*(char))
-	O
bp	*(*(char))
)	O
==	O
strlen	(*(char))->(long)
(	O
"ifweave"	*(char)
)	O
&&	O
!	O
memcmp	(*(void),*(void),long)->(int)
(	O
bp	*(*(char))
,	O
"ifweave"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"ifweave"	*(char)
)	O
)	O
)	O
dir_pop	(enum(int,int,int))->(void)
(	O
OP_WEAVE	int
)	O
;	O
else	O
if	O
(	O
(	O
size_t	long
)	O
(	O
ep	*(*(char))
-	O
bp	*(*(char))
)	O
==	O
strlen	(*(char))->(long)
(	O
"iftangle"	*(char)
)	O
&&	O
!	O
memcmp	(*(void),*(void),long)->(int)
(	O
bp	*(*(char))
,	O
"iftangle"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"iftangle"	*(char)
)	O
)	O
)	O
dir_pop	(enum(int,int,int))->(void)
(	O
OP_TANGLE	int
)	O
;	O
else	O
return	O
0	int
;	O
}	O
else	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
dir_close	()->(void)
(	O
void	O
)	O
{	O
while	O
(	O
dir_stack_height	int
>	O
0	int
)	O
{	O
dir_stack_height	int
--	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: `@if' opened here but never closed.\n"	*(char)
)	O
,	O
dir_stack	array(struct(enum(int,int,int),*(char),int))
[	O
dir_stack_height	int
]	O
.	O
name	*(char)
,	O
dir_stack	array(struct(enum(int,int,int),*(char),int))
[	O
dir_stack_height	int
]	O
.	O
line	int
)	O
;	O
}	O
dir_ignore	int
=	O
0	int
;	O
}	O
static	O
void	O
emitf	(*(char))->(void)
(	O
const	O
char	O
*	O
format	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
;	O
assert	O
(	O
out_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
&&	O
format	*(char)
!=	O
NULL	O
)	O
;	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
format	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
out_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
format	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
static	O
void	O
input_push	(*(char))->(void)
(	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
struct	O
input_file	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),int)
*	O
f	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
f	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
)	O
;	O
f	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
outer	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
=	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
;	O
f	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
f	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
f	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
error	(int,*(char))->(void)
(	O
FTL	int
,	O
_	O
(	O
"Opening %s for reading: %s"	*(char)
)	O
,	O
filename	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
f	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
line	int
=	O
0	int
;	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
=	O
f	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
;	O
}	O
static	O
void	O
input_pop	()->(void)
(	O
void	O
)	O
{	O
struct	O
input_file	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),int)
*	O
outer	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
;	O
assert	O
(	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
!=	O
NULL	O
)	O
;	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
error	(int,*(char))->(void)
(	O
FTL	int
,	O
_	O
(	O
"Closing %s: %s"	*(char)
)	O
,	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
name	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
outer	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
=	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
outer	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
;	O
free	(*(void))->(void)
(	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
)	O
;	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
=	O
outer	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
;	O
}	O
static	O
void	O
input_start_pass	()->(void)
(	O
void	O
)	O
{	O
input_push	(*(char))->(void)
(	O
in_file_name	*(char)
)	O
;	O
}	O
static	O
void	O
input_end_pass	()->(void)
(	O
void	O
)	O
{	O
dir_close	()->(void)
(	O
)	O
;	O
}	O
static	O
int	O
input_get_line	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
char	O
*	O
*	O
lineptr	*(*(char))
,	O
size_t	long
*	O
n	*(long)
,	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
size_t	long
len	long
;	O
int	O
c	int
;	O
if	O
(	O
*	O
lineptr	*(*(char))
==	O
NULL	O
||	O
*	O
n	*(long)
<	O
2	int
)	O
{	O
*	O
lineptr	*(*(char))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
*	O
lineptr	*(*(char))
,	O
128	int
)	O
;	O
*	O
n	*(long)
=	O
128	int
;	O
}	O
assert	O
(	O
*	O
n	*(long)
>	O
0	int
)	O
;	O
len	long
=	O
0	int
;	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
len	long
+	O
1	int
>=	O
*	O
n	*(long)
)	O
{	O
*	O
n	*(long)
*=	O
2	int
;	O
*	O
lineptr	*(*(char))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
*	O
lineptr	*(*(char))
,	O
*	O
n	*(long)
)	O
;	O
}	O
(	O
*	O
lineptr	*(*(char))
)	O
[	O
len	long
++	O
]	O
=	O
c	int
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
break	O
;	O
}	O
(	O
*	O
lineptr	*(*(char))
)	O
[	O
len	long
]	O
=	O
'\0'	O
;	O
return	O
len	long
;	O
}	O
static	O
int	O
input_parse_include	(*(char))->(int)
(	O
char	O
*	O
line	int
)	O
{	O
static	O
const	O
char	O
include	enum(int,int,int)
[	O
]	O
=	O
"@include"	*(char)
;	O
char	O
*	O
bp	*(*(char))
,	O
*	O
ep	*(*(char))
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
line	int
,	O
include	enum(int,int,int)
,	O
strlen	(*(char))->(long)
(	O
include	enum(int,int,int)
)	O
)	O
||	O
!	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
line	int
[	O
strlen	(*(char))->(long)
(	O
include	enum(int,int,int)
)	O
]	O
)	O
)	O
return	O
0	int
;	O
find_argument	(*(char),*(*(char)),*(*(char)))->(int)
(	O
line	int
,	O
&	O
bp	*(*(char))
,	O
&	O
ep	*(*(char))
)	O
;	O
*	O
ep	*(*(char))
=	O
'\0'	O
;	O
if	O
(	O
answer_file_name	*(char)
!=	O
NULL	O
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
bp	*(*(char))
,	O
answer_file_name	*(char)
)	O
)	O
{	O
exercise_close_answer_file	()->(void)
(	O
)	O
;	O
input_push	(*(char))->(void)
(	O
bp	*(*(char))
)	O
;	O
}	O
else	O
if	O
(	O
ep	*(*(char))
-	O
bp	*(*(char))
>	O
2	int
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
ep	*(*(char))
-	O
2	int
,	O
".w"	*(char)
)	O
)	O
input_push	(*(char))->(void)
(	O
bp	*(*(char))
)	O
;	O
else	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
input_read_line	(*(*(char)),*(long))->(int)
(	O
char	O
*	O
*	O
line	int
,	O
size_t	long
*	O
line_size	*(long)
)	O
{	O
while	O
(	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
!=	O
NULL	O
)	O
{	O
int	O
line_len	int
=	O
input_get_line	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
line	int
,	O
line_size	*(long)
,	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
line	int
++	O
;	O
if	O
(	O
line_len	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
dir_parse_ifx	(*(char))->(int)
(	O
*	O
line	int
)	O
||	O
dir_ignore	int
)	O
continue	O
;	O
if	O
(	O
input_parse_include	(*(char))->(int)
(	O
*	O
line	int
)	O
)	O
continue	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
error	(int,*(char))->(void)
(	O
FTL	int
,	O
_	O
(	O
"Error reading %s: %s"	*(char)
)	O
,	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
name	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
input_pop	()->(void)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
enum	O
{	O
KW_AUTO	int
,	O
KW_BREAK	int
,	O
KW_CASE	int
,	O
KW_CHAR	int
,	O
KW_COMPLEX	int
,	O
KW_CONST	int
,	O
KW_CONTINUE	int
,	O
KW_DEFAULT	int
,	O
KW_DEFINED	int
,	O
KW_DO	int
,	O
KW_DOUBLE	int
,	O
KW_ELSE	int
,	O
KW_ENUM	int
,	O
KW_EXTERN	int
,	O
KW_FLOAT	int
,	O
KW_FOR	int
,	O
KW_GOTO	int
,	O
KW_IF	int
,	O
KW_IMAGINARY	int
,	O
KW_INLINE	int
,	O
KW_INT	int
,	O
KW_LONG	int
,	O
KW_REGISTER	int
,	O
KW_RESTRICT	int
,	O
KW_RETURN	int
,	O
KW_SHORT	int
,	O
KW_SIGNED	int
,	O
KW_SIZEOF	int
,	O
KW_STATIC	int
,	O
KW_STRUCT	int
,	O
KW_SWITCH	int
,	O
KW_TYPEDEF	int
,	O
KW_UNION	int
,	O
KW_UNSIGNED	int
,	O
KW_VOID	int
,	O
KW_VOLATILE	int
,	O
KW_WHILE	int
,	O
KW_OTHER	int
,	O
KW_CNT	int
}	O
;	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
{	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
;	O
char	O
*	O
name	*(char)
;	O
struct	O
segment	*(struct)
*	O
segment	*(struct)
;	O
int	O
is_typedef	int
;	O
int	O
kw_idx	int
;	O
struct	O
catalogue	*(struct)
*	O
catalogue	*(struct)
;	O
}	O
;	O
static	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
symbol_table	array(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))))
[	O
SYMBOL_TABLE_SIZE	int
]	O
;	O
static	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
symbol_find	(*(char),long,int)->(*(struct))
(	O
const	O
char	O
*	O
name	*(char)
,	O
size_t	long
len	long
,	O
int	O
add	int
)	O
{	O
unsigned	O
hash	int
;	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
hash	int
=	O
0	int
;	O
for	O
(	O
p	*(char)
=	O
name	*(char)
;	O
p	*(char)
<	O
name	*(char)
+	O
len	long
;	O
p	*(char)
++	O
)	O
hash	int
=	O
hash	int
*	O
33	int
+	O
(	O
unsigned	O
char	O
)	O
*	O
p	*(char)
;	O
hash	int
%=	O
SYMBOL_TABLE_SIZE	int
;	O
}	O
{	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
;	O
for	O
(	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
=	O
symbol_table	array(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))))
+	O
hash	int
;	O
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
;	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
=	O
&	O
(	O
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
)	O
->	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
)	O
if	O
(	O
strlen	(*(char))->(long)
(	O
(	O
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
)	O
->	O
name	*(char)
)	O
==	O
len	long
&&	O
!	O
memcmp	(*(void),*(void),long)->(int)
(	O
name	*(char)
,	O
(	O
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
)	O
->	O
name	*(char)
,	O
len	long
)	O
)	O
return	O
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
;	O
if	O
(	O
add	int
==	O
0	int
)	O
return	O
NULL	O
;	O
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
)	O
;	O
(	O
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
)	O
->	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
=	O
NULL	O
;	O
(	O
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
)	O
->	O
name	*(char)
=	O
xstrndup	(*(char),long)->(*(char))
(	O
name	*(char)
,	O
len	long
)	O
;	O
(	O
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
)	O
->	O
segment	*(struct)
=	O
NULL	O
;	O
(	O
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
)	O
->	O
is_typedef	int
=	O
0	int
;	O
(	O
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
)	O
->	O
kw_idx	int
=	O
-	O
1	int
;	O
(	O
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
)	O
->	O
catalogue	*(struct)
=	O
NULL	O
;	O
return	O
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
;	O
}	O
}	O
static	O
void	O
symbol_foreach	(*((*(struct(*`,*`,*`,int,int,*`)))->(void)))->(void)
(	O
void	O
(	O
*	O
func	*((*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))))->(void))
)	O
(	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
)	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SYMBOL_TABLE_SIZE	int
;	O
i	int
++	O
)	O
{	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
;	O
for	O
(	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
=	O
symbol_table	array(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))))
[	O
i	int
]	O
;	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
!=	O
NULL	O
;	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
=	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
->	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
)	O
func	*((*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))))->(void))
(	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
)	O
;	O
}	O
}	O
static	O
void	O
symbol_init	()->(void)
(	O
void	O
)	O
{	O
static	O
const	O
char	O
*	O
keywords	array(*(char))
[	O
KW_CNT	int
-	O
1	int
]	O
=	O
{	O
"auto"	*(char)
,	O
"break"	*(char)
,	O
"case"	*(char)
,	O
"char"	*(char)
,	O
"complex"	*(char)
,	O
"const"	*(char)
,	O
"continue"	*(char)
,	O
"default"	*(char)
,	O
"defined"	*(char)
,	O
"do"	*(char)
,	O
"double"	*(char)
,	O
"else"	*(char)
,	O
"enum"	*(char)
,	O
"extern"	*(char)
,	O
"float"	*(char)
,	O
"for"	*(char)
,	O
"goto"	*(char)
,	O
"if"	*(char)
,	O
"imaginary"	*(char)
,	O
"inline"	*(char)
,	O
"int"	*(char)
,	O
"long"	*(char)
,	O
"register"	*(char)
,	O
"restrict"	*(char)
,	O
"return"	*(char)
,	O
"short"	*(char)
,	O
"signed"	*(char)
,	O
"sizeof"	*(char)
,	O
"static"	*(char)
,	O
"struct"	*(char)
,	O
"switch"	*(char)
,	O
"typedef"	*(char)
,	O
"union"	*(char)
,	O
"unsigned"	*(char)
,	O
"void"	*(char)
,	O
"volatile"	*(char)
,	O
"while"	*(char)
,	O
}	O
;	O
static	O
const	O
char	O
*	O
types	array(*(char))
[	O
]	O
=	O
{	O
"fenv_t"	*(char)
,	O
"fexcept_t"	*(char)
,	O
"float_t"	*(char)
,	O
"double_t"	*(char)
,	O
"jmp_buf"	*(char)
,	O
"sig_atomic_t"	*(char)
,	O
"va_list"	*(char)
,	O
"bool"	*(char)
,	O
"ptrdiff_t"	*(char)
,	O
"size_t"	*(char)
,	O
"wchar_t"	*(char)
,	O
"int8_t"	*(char)
,	O
"int16_t"	*(char)
,	O
"int32_t"	*(char)
,	O
"int64_t"	*(char)
,	O
"uint8_t"	*(char)
,	O
"uint16_t"	*(char)
,	O
"uint32_t"	*(char)
,	O
"uint64_t"	*(char)
,	O
"int_least8_t"	*(char)
,	O
"int_least16_t"	*(char)
,	O
"int_least32_t"	*(char)
,	O
"int_least64_t"	*(char)
,	O
"uint_least8_t"	*(char)
,	O
"uint_least16_t"	*(char)
,	O
"uint_least32_t"	*(char)
,	O
"uint_least64_t"	*(char)
,	O
"int_fast8_t"	*(char)
,	O
"int_fast16_t"	*(char)
,	O
"int_fast32_t"	*(char)
,	O
"int_fast64_t"	*(char)
,	O
"uint_fast8_t"	*(char)
,	O
"uint_fast16_t"	*(char)
,	O
"uint_fast32_t"	*(char)
,	O
"uint_fast64_t"	*(char)
,	O
"intptr_t"	*(char)
,	O
"uintptr_t"	*(char)
,	O
"intmax_t"	*(char)
,	O
"uintmax_t"	*(char)
,	O
"fpos_t"	*(char)
,	O
"FILE"	*(char)
,	O
"div_t"	*(char)
,	O
"ldiv_t"	*(char)
,	O
"lldiv_t"	*(char)
,	O
"clock_t"	*(char)
,	O
"time_t"	*(char)
,	O
"mbstate_t"	*(char)
,	O
"wint_t"	*(char)
,	O
"wctrans_t"	*(char)
,	O
"wctype_t"	*(char)
,	O
}	O
;	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
keywords	array(*(char))
/	O
sizeof	O
*	O
keywords	array(*(char))
;	O
i	int
++	O
)	O
symbol_find	(*(char),long,int)->(*(struct))
(	O
keywords	array(*(char))
[	O
i	int
]	O
,	O
strlen	(*(char))->(long)
(	O
keywords	array(*(char))
[	O
i	int
]	O
)	O
,	O
1	int
)	O
->	O
kw_idx	int
=	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
types	array(*(char))
/	O
sizeof	O
*	O
types	array(*(char))
;	O
i	int
++	O
)	O
symbol_find	(*(char),long,int)->(*(struct))
(	O
types	array(*(char))
[	O
i	int
]	O
,	O
strlen	(*(char))->(long)
(	O
types	array(*(char))
[	O
i	int
]	O
)	O
,	O
1	int
)	O
->	O
is_typedef	int
=	O
1	int
;	O
}	O
struct	O
cat_entry	struct(int,*(char))
{	O
int	O
idx	int
;	O
char	O
*	O
label	*(char)
;	O
}	O
;	O
struct	O
catalogue	*(struct)
{	O
int	O
entry_cnt	int
;	O
int	O
entry_cap	int
;	O
struct	O
cat_entry	struct(int,*(char))
*	O
entry	*(struct(int,*(char)))
;	O
int	O
idx	int
;	O
int	O
printed	int
;	O
}	O
;	O
static	O
int	O
catalogue_process_one	(*(char),*(char))->(int)
(	O
char	O
*	O
cmd	*(char)
,	O
char	O
*	O
line	int
)	O
{	O
char	O
*	O
bp	*(*(char))
,	O
*	O
ep	*(*(char))
;	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
;	O
struct	O
catalogue	*(struct)
*	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
;	O
struct	O
cat_entry	struct(int,*(char))
*	O
entry	*(struct(int,*(char)))
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"printcatalogue"	*(char)
)	O
)	O
return	O
1	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"cat"	*(char)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
find_argument	(*(char),*(*(char)),*(*(char)))->(int)
(	O
line	int
,	O
&	O
bp	*(*(char))
,	O
&	O
ep	*(*(char))
)	O
)	O
return	O
0	int
;	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
=	O
symbol_find	(*(char),long,int)->(*(struct))
(	O
bp	*(*(char))
,	O
strcspn	(*(char),*(char))->(long)
(	O
bp	*(*(char))
,	O
" \t\r\n"	*(char)
)	O
,	O
1	int
)	O
;	O
if	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
->	O
catalogue	*(struct)
!=	O
NULL	O
)	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
=	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
->	O
catalogue	*(struct)
;	O
else	O
{	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
=	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
->	O
catalogue	*(struct)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
)	O
;	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry_cnt	int
=	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry_cap	int
=	O
0	int
;	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry	*(struct(int,*(char)))
=	O
NULL	O
;	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
idx	int
=	O
0	int
;	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
printed	int
=	O
0	int
;	O
}	O
if	O
(	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry_cnt	int
>=	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry_cap	int
)	O
{	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry_cap	int
=	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry_cap	int
*	O
3	int
/	O
2	int
+	O
8	int
;	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry	*(struct(int,*(char)))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry	*(struct(int,*(char)))
,	O
sizeof	O
*	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry	*(struct(int,*(char)))
*	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry_cap	int
)	O
;	O
}	O
assert	O
(	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry_cnt	int
<	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry_cap	int
)	O
;	O
if	O
(	O
!	O
find_argument	(*(char),*(*(char)),*(*(char)))->(int)
(	O
bp	*(*(char))
,	O
&	O
bp	*(*(char))
,	O
&	O
ep	*(*(char))
)	O
)	O
return	O
0	int
;	O
entry	*(struct(int,*(char)))
=	O
&	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry	*(struct(int,*(char)))
[	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry_cnt	int
]	O
;	O
entry	*(struct(int,*(char)))
->	O
idx	int
=	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry_cnt	int
;	O
entry	*(struct(int,*(char)))
->	O
label	*(char)
=	O
xstrndup	(*(char),long)->(*(char))
(	O
bp	*(*(char))
,	O
ep	*(*(char))
-	O
bp	*(*(char))
)	O
;	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry_cnt	int
++	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
catalogue_compare_entries	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
pa	*(void)
,	O
const	O
void	O
*	O
pb	*(void)
)	O
{	O
const	O
struct	O
cat_entry	struct(int,*(char))
*	O
a	*(struct(int,*(char)))
=	O
pa	*(void)
;	O
const	O
struct	O
cat_entry	struct(int,*(char))
*	O
b	*(struct(int,*(char)))
=	O
pb	*(void)
;	O
const	O
char	O
*	O
sa	*(char)
=	O
a	*(struct(int,*(char)))
->	O
label	*(char)
;	O
const	O
char	O
*	O
sb	*(char)
=	O
b	*(struct(int,*(char)))
->	O
label	*(char)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
ca	char
=	O
tolower	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
sa	*(char)
++	O
)	O
;	O
char	O
cb	char
=	O
tolower	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
sb	*(char)
++	O
)	O
;	O
if	O
(	O
ca	char
!=	O
cb	char
)	O
return	O
ca	char
>	O
cb	char
?	O
1	int
:	O
-	O
1	int
;	O
else	O
if	O
(	O
ca	char
==	O
0	int
)	O
return	O
0	int
;	O
}	O
}	O
static	O
void	O
catalogue_print	(*(char),*(struct(int,int,*(struct(int,*`)),int,int)))->(void)
(	O
const	O
char	O
*	O
name	*(char)
,	O
struct	O
catalogue	*(struct)
*	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
)	O
{	O
int	O
i	int
;	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
printed	int
=	O
1	int
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry	*(struct(int,*(char)))
,	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry_cnt	int
,	O
sizeof	O
*	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry	*(struct(int,*(char)))
,	O
catalogue_compare_entries	(*(void),*(void))->(int)
)	O
;	O
emits	O
(	O
"@iftex\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry_cnt	int
;	O
i	int
++	O
)	O
emitf	(*(char))->(void)
(	O
"@catentry{catalogue-entry-%s-%d}{%s}\n"	*(char)
,	O
name	*(char)
,	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry	*(struct(int,*(char)))
[	O
i	int
]	O
.	O
idx	int
,	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry	*(struct(int,*(char)))
[	O
i	int
]	O
.	O
label	*(char)
)	O
;	O
emits	O
(	O
"@end iftex\n"	*(char)
)	O
;	O
emits	O
(	O
"@ifnottex\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry_cnt	int
;	O
i	int
++	O
)	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
emitf	(*(char))->(void)
(	O
"@catentry{catalogue-entry-%s-%d, "	*(char)
,	O
name	*(char)
,	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry	*(struct(int,*(char)))
[	O
i	int
]	O
.	O
idx	int
)	O
;	O
for	O
(	O
p	*(char)
=	O
cat	*(struct(int,int,*(struct(int,*(char))),int,int))
->	O
entry	*(struct(int,*(char)))
[	O
i	int
]	O
.	O
label	*(char)
;	O
*	O
p	*(char)
!=	O
'\0'	O
;	O
p	*(char)
++	O
)	O
{	O
if	O
(	O
*	O
p	*(char)
==	O
','	O
)	O
emitc	O
(	O
'\\'	O
)	O
;	O
emitc	O
(	O
*	O
p	*(char)
)	O
;	O
}	O
emits	O
(	O
"}\n"	*(char)
)	O
;	O
}	O
emits	O
(	O
"@end ifnottex\n"	*(char)
)	O
;	O
}	O
static	O
int	O
catalogue_process_two	(*(char),*(char))->(int)
(	O
char	O
*	O
cmd	*(char)
,	O
char	O
*	O
line	int
)	O
{	O
char	O
*	O
bp	*(*(char))
,	O
*	O
ep	*(*(char))
;	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"printcatalogue"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"cat"	*(char)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
find_argument	(*(char),*(*(char)),*(*(char)))->(int)
(	O
line	int
,	O
&	O
bp	*(*(char))
,	O
&	O
ep	*(*(char))
)	O
)	O
return	O
0	int
;	O
ep	*(*(char))
=	O
bp	*(*(char))
+	O
strcspn	(*(char),*(char))->(long)
(	O
bp	*(*(char))
,	O
" \t\r\n"	*(char)
)	O
;	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
=	O
symbol_find	(*(char),long,int)->(*(struct))
(	O
bp	*(*(char))
,	O
ep	*(*(char))
-	O
bp	*(*(char))
,	O
0	int
)	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"cat"	*(char)
)	O
)	O
{	O
if	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
==	O
NULL	O
||	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
->	O
catalogue	*(struct)
==	O
NULL	O
)	O
{	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Internal error: no such catalogue `%.*s'."	*(char)
)	O
,	O
(	O
int	O
)	O
(	O
ep	*(*(char))
-	O
bp	*(*(char))
)	O
,	O
bp	*(*(char))
)	O
;	O
return	O
1	int
;	O
}	O
emitf	(*(char))->(void)
(	O
"@anchor{catalogue-entry-%.*s-%d}\n"	*(char)
,	O
(	O
int	O
)	O
(	O
ep	*(*(char))
-	O
bp	*(*(char))
)	O
,	O
bp	*(*(char))
,	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
->	O
catalogue	*(struct)
->	O
idx	int
++	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
!=	O
NULL	O
&&	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
->	O
catalogue	*(struct)
!=	O
NULL	O
)	O
catalogue_print	(*(char),*(struct(int,int,*(struct(int,*`)),int,int)))->(void)
(	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
->	O
name	*(char)
,	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
->	O
catalogue	*(struct)
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
catalogue_check_printed	(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct(int,int,*`,int,int)))))->(void)
(	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
)	O
{	O
if	O
(	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
->	O
catalogue	*(struct)
!=	O
NULL	O
&&	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
->	O
catalogue	*(struct)
->	O
printed	int
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
"%s: Catalogue `%s' never printed.\n"	*(char)
,	O
in_file_name	*(char)
,	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
->	O
name	*(char)
)	O
;	O
}	O
static	O
void	O
catalogue_print_unused	()->(void)
(	O
void	O
)	O
{	O
symbol_foreach	(*((*(struct(*`,*`,*`,int,int,*`)))->(void)))->(void)
(	O
catalogue_check_printed	(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct(int,int,*`,int,int)))))->(void)
)	O
;	O
}	O
static	O
enum	O
state	enum(int,int,int,int)
state_stack	array(enum(int,int,int,int))
[	O
STATE_STACK_SIZE	int
]	O
;	O
static	O
enum	O
state	enum(int,int,int,int)
*	O
state_top	*(enum(int,int,int,int))
;	O
static	O
void	O
state_init	()->(void)
(	O
void	O
)	O
{	O
state_top	*(enum(int,int,int,int))
=	O
state_stack_end	O
;	O
}	O
static	O
int	O
state_cnt	()->(int)
(	O
void	O
)	O
{	O
assert	O
(	O
state_top	*(enum(int,int,int,int))
!=	O
NULL	O
)	O
;	O
return	O
state_stack_end	O
-	O
state_top	*(enum(int,int,int,int))
;	O
}	O
static	O
int	O
state_is	(enum(int,int,int,int))->(int)
(	O
enum	O
state	enum(int,int,int,int)
state	enum(int,int,int,int)
)	O
{	O
assert	O
(	O
state_top	*(enum(int,int,int,int))
!=	O
NULL	O
&&	O
state_top	*(enum(int,int,int,int))
<	O
state_stack_end	O
)	O
;	O
return	O
*	O
state_top	*(enum(int,int,int,int))
==	O
state	enum(int,int,int,int)
;	O
}	O
static	O
int	O
state_was	(enum(int,int,int,int))->(int)
(	O
enum	O
state	enum(int,int,int,int)
state	enum(int,int,int,int)
)	O
{	O
assert	O
(	O
state_top	*(enum(int,int,int,int))
!=	O
NULL	O
)	O
;	O
return	O
state_cnt	()->(int)
(	O
)	O
>	O
1	int
&&	O
state_top	*(enum(int,int,int,int))
[	O
1	int
]	O
==	O
state	enum(int,int,int,int)
;	O
}	O
static	O
int	O
state_bottom	(enum(int,int,int,int))->(int)
(	O
enum	O
state	enum(int,int,int,int)
state	enum(int,int,int,int)
)	O
{	O
assert	O
(	O
state_top	*(enum(int,int,int,int))
<	O
state_stack_end	O
)	O
;	O
return	O
state	enum(int,int,int,int)
==	O
state_stack_end	O
[	O
-	O
1	int
]	O
;	O
}	O
static	O
void	O
state_push	(enum(int,int,int,int))->(void)
(	O
enum	O
state	enum(int,int,int,int)
state	enum(int,int,int,int)
)	O
{	O
assert	O
(	O
state_top	*(enum(int,int,int,int))
!=	O
NULL	O
&&	O
state_top	*(enum(int,int,int,int))
>	O
state_stack	array(enum(int,int,int,int))
)	O
;	O
*	O
--	O
state_top	*(enum(int,int,int,int))
=	O
state	enum(int,int,int,int)
;	O
}	O
static	O
void	O
state_pop	()->(void)
(	O
void	O
)	O
{	O
assert	O
(	O
state_top	*(enum(int,int,int,int))
!=	O
NULL	O
&&	O
state_top	*(enum(int,int,int,int))
<	O
state_stack_end	O
)	O
;	O
state_top	*(enum(int,int,int,int))
++	O
;	O
}	O
struct	O
segment	*(struct)
{	O
char	O
*	O
name	*(char)
;	O
int	O
use	int
;	O
struct	O
segment	*(struct)
*	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
;	O
int	O
piece_cnt	int
;	O
struct	O
piece	*(*(struct))
*	O
*	O
piece	*(*(struct))
;	O
int	O
piece_cur	int
;	O
int	O
ref_cnt	int
;	O
struct	O
piece	*(*(struct))
*	O
*	O
ref	*(*(struct))
;	O
int	O
*	O
indent	*(int)
;	O
struct	O
segment	*(struct)
*	O
c_next	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct)),int,int,*(*(struct)),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct),*(struct)))
;	O
struct	O
line	int
*	O
c_head	*(struct)
;	O
struct	O
line	int
*	O
c_tail	*(struct)
;	O
}	O
;	O
struct	O
piece	*(*(struct))
{	O
struct	O
segment	*(struct)
*	O
segment	*(struct)
;	O
int	O
number	int
;	O
int	O
ref_cnt	int
;	O
struct	O
segment	*(struct)
*	O
*	O
ref	*(*(struct))
;	O
}	O
;	O
struct	O
loc	struct(*(char),int)
{	O
const	O
char	O
*	O
fn	*(char)
;	O
int	O
ln	int
;	O
}	O
;	O
struct	O
line	int
{	O
struct	O
line	int
*	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
;	O
const	O
char	O
*	O
text	*(char)
;	O
struct	O
loc	struct(*(char),int)
loc	struct(*(char),int)
;	O
}	O
;	O
static	O
struct	O
segment	*(struct)
*	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
;	O
static	O
struct	O
segment	*(struct)
*	O
segment_first	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
,	O
*	O
segment_last	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
;	O
static	O
struct	O
segment	*(struct)
*	O
segment_find	(*(char),int)->(*(struct))
(	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
create	int
)	O
{	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
;	O
struct	O
segment	*(struct)
*	O
segment	*(struct)
;	O
size_t	long
len	long
;	O
len	long
=	O
strcspn	(*(char),*(char))->(long)
(	O
name	*(char)
,	O
";"	*(char)
)	O
;	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
=	O
symbol_find	(*(char),long,int)->(*(struct))
(	O
name	*(char)
,	O
len	long
,	O
create	int
)	O
;	O
if	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
segment	*(struct)
=	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
->	O
segment	*(struct)
;	O
if	O
(	O
segment	*(struct)
==	O
NULL	O
&&	O
create	int
)	O
{	O
segment	*(struct)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
segment	*(struct)
)	O
;	O
segment	*(struct)
->	O
name	*(char)
=	O
xstrndup	(*(char),long)->(*(char))
(	O
name	*(char)
,	O
len	long
)	O
;	O
segment	*(struct)
->	O
use	int
=	O
0	int
;	O
segment	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
=	O
NULL	O
;	O
segment	*(struct)
->	O
piece_cnt	int
=	O
0	int
;	O
segment	*(struct)
->	O
piece	*(*(struct))
=	O
NULL	O
;	O
segment	*(struct)
->	O
piece_cur	int
=	O
-	O
1	int
;	O
segment	*(struct)
->	O
ref_cnt	int
=	O
0	int
;	O
segment	*(struct)
->	O
ref	*(*(struct))
=	O
NULL	O
;	O
segment	*(struct)
->	O
indent	*(int)
=	O
NULL	O
;	O
segment	*(struct)
->	O
c_head	*(struct)
=	O
NULL	O
;	O
segment	*(struct)
->	O
c_tail	*(struct)
=	O
NULL	O
;	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
->	O
segment	*(struct)
=	O
segment	*(struct)
;	O
if	O
(	O
segment_first	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
==	O
NULL	O
)	O
segment_first	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
=	O
segment	*(struct)
;	O
else	O
segment_last	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
=	O
segment	*(struct)
;	O
segment_last	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
=	O
segment	*(struct)
;	O
}	O
return	O
segment	*(struct)
;	O
}	O
static	O
void	O
segment_select	(*(struct))->(void)
(	O
struct	O
segment	*(struct)
*	O
segment	*(struct)
)	O
{	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
=	O
segment	*(struct)
;	O
}	O
static	O
int	O
segment_selected_p	()->(int)
(	O
void	O
)	O
{	O
return	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
!=	O
NULL	O
;	O
}	O
static	O
int	O
segment_piece_cur	()->(int)
(	O
void	O
)	O
{	O
assert	O
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
!=	O
NULL	O
)	O
;	O
return	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece_cur	int
;	O
}	O
static	O
int	O
segment_piece_cnt	()->(int)
(	O
void	O
)	O
{	O
assert	O
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
!=	O
NULL	O
)	O
;	O
return	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece_cnt	int
;	O
}	O
static	O
int	O
segment_number	()->(int)
(	O
void	O
)	O
{	O
assert	O
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
!=	O
NULL	O
&&	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece_cnt	int
>	O
0	int
)	O
;	O
return	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece	*(*(struct))
[	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece_cur	int
]	O
->	O
number	int
;	O
}	O
static	O
const	O
char	O
*	O
segment_name	()->(*(char))
(	O
void	O
)	O
{	O
assert	O
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
!=	O
NULL	O
)	O
;	O
return	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
name	*(char)
;	O
}	O
static	O
int	O
segment_first_piece	()->(int)
(	O
void	O
)	O
{	O
assert	O
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
!=	O
NULL	O
&&	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece_cnt	int
>	O
0	int
)	O
;	O
return	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece	*(*(struct))
[	O
0	int
]	O
->	O
number	int
;	O
}	O
static	O
int	O
segment_inside_indentation	(*(struct))->(int)
(	O
struct	O
segment	*(struct)
*	O
segment	*(struct)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
segment	*(struct)
->	O
ref_cnt	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
segment	*(struct)
->	O
indent	*(int)
[	O
i	int
]	O
)	O
return	O
1	int
;	O
if	O
(	O
segment_inside_indentation	(*(struct))->(int)
(	O
segment	*(struct)
->	O
ref	*(*(struct))
[	O
i	int
]	O
->	O
segment	*(struct)
)	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
segment_next_piece	()->(void)
(	O
void	O
)	O
{	O
assert	O
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
!=	O
NULL	O
&&	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece_cur	int
<	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece_cnt	int
-	O
1	int
)	O
;	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece_cur	int
++	O
;	O
}	O
static	O
void	O
segment_print_number	(*(struct))->(void)
(	O
struct	O
segment	*(struct)
*	O
segment	*(struct)
)	O
{	O
if	O
(	O
segment	*(struct)
!=	O
NULL	O
&&	O
segment	*(struct)
->	O
piece_cnt	int
!=	O
0	int
)	O
emitf	(*(char))->(void)
(	O
"%d"	*(char)
,	O
segment	*(struct)
->	O
piece	*(*(struct))
[	O
0	int
]	O
->	O
number	int
)	O
;	O
else	O
emits	O
(	O
_	O
(	O
"UNDEFINED"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
segment_add_line	(*(char))->(void)
(	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
struct	O
line	int
*	O
line	int
;	O
if	O
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
==	O
NULL	O
)	O
return	O
;	O
line	int
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
line	int
)	O
;	O
line	int
->	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
=	O
NULL	O
;	O
line	int
->	O
text	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
text	*(char)
)	O
;	O
line	int
->	O
loc	struct(*(char),int)
.	O
fn	*(char)
=	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
name	*(char)
;	O
line	int
->	O
loc	struct(*(char),int)
.	O
ln	int
=	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
line	int
;	O
if	O
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
c_head	*(struct)
==	O
NULL	O
)	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
c_head	*(struct)
=	O
line	int
;	O
if	O
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
c_tail	*(struct)
!=	O
NULL	O
)	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
c_tail	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
=	O
line	int
;	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
c_tail	*(struct)
=	O
line	int
;	O
}	O
static	O
void	O
piece_create	(*(struct),int)->(void)
(	O
struct	O
segment	*(struct)
*	O
s	*(struct)
,	O
int	O
operation	enum(int,int,int)
)	O
{	O
static	O
int	O
piece_cnt	int
;	O
struct	O
piece	*(*(struct))
*	O
p	*(char)
;	O
assert	O
(	O
operation	enum(int,int,int)
==	O
'='	O
||	O
operation	enum(int,int,int)
==	O
'+'	O
)	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(struct)
->	O
name	*(char)
,	O
"Anonymous"	*(char)
)	O
)	O
{	O
if	O
(	O
operation	enum(int,int,int)
==	O
'+'	O
)	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Anonymous segment should not have +=."	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
s	*(struct)
->	O
piece_cnt	int
==	O
0	int
&&	O
operation	enum(int,int,int)
==	O
'+'	O
)	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"First piece of `%s' should not have +=."	*(char)
)	O
,	O
s	*(struct)
->	O
name	*(char)
)	O
;	O
else	O
if	O
(	O
s	*(struct)
->	O
piece_cnt	int
>	O
0	int
&&	O
operation	enum(int,int,int)
==	O
'='	O
)	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Second or later piece of `%s' should have +=."	*(char)
)	O
,	O
s	*(struct)
->	O
name	*(char)
)	O
;	O
s	*(struct)
->	O
piece	*(*(struct))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
s	*(struct)
->	O
piece	*(*(struct))
,	O
sizeof	O
*	O
s	*(struct)
->	O
piece	*(*(struct))
*	O
(	O
s	*(struct)
->	O
piece_cnt	int
+	O
1	int
)	O
)	O
;	O
p	*(char)
=	O
s	*(struct)
->	O
piece	*(*(struct))
[	O
s	*(struct)
->	O
piece_cnt	int
++	O
]	O
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
*	O
s	*(struct)
->	O
piece	*(*(struct))
)	O
;	O
p	*(char)
->	O
segment	*(struct)
=	O
s	*(struct)
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(struct)
->	O
name	*(char)
,	O
"Anonymous"	*(char)
)	O
)	O
p	*(char)
->	O
number	int
=	O
++	O
piece_cnt	int
;	O
p	*(char)
->	O
ref_cnt	int
=	O
0	int
;	O
p	*(char)
->	O
ref	*(*(struct))
=	O
NULL	O
;	O
}	O
static	O
void	O
piece_references	(*(struct),int)->(void)
(	O
struct	O
segment	*(struct)
*	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
,	O
int	O
indentation	int
)	O
{	O
struct	O
piece	*(*(struct))
*	O
piece	*(*(struct))
;	O
if	O
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
==	O
NULL	O
)	O
return	O
;	O
piece	*(*(struct))
=	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece	*(*(struct))
[	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece_cnt	int
-	O
1	int
]	O
;	O
piece	*(*(struct))
->	O
ref	*(*(struct))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
piece	*(*(struct))
->	O
ref	*(*(struct))
,	O
sizeof	O
*	O
piece	*(*(struct))
->	O
ref	*(*(struct))
*	O
(	O
piece	*(*(struct))
->	O
ref_cnt	int
+	O
1	int
)	O
)	O
;	O
piece	*(*(struct))
->	O
ref	*(*(struct))
[	O
piece	*(*(struct))
->	O
ref_cnt	int
]	O
=	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
;	O
piece	*(*(struct))
->	O
ref_cnt	int
++	O
;	O
if	O
(	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref_cnt	int
==	O
0	int
||	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref	*(*(struct))
[	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref_cnt	int
-	O
1	int
]	O
->	O
segment	*(struct)
!=	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
)	O
{	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref	*(*(struct))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref	*(*(struct))
,	O
sizeof	O
*	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref	*(*(struct))
*	O
(	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref_cnt	int
+	O
1	int
)	O
)	O
;	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
indent	*(int)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
indent	*(int)
,	O
sizeof	O
*	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
indent	*(int)
*	O
(	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref_cnt	int
+	O
1	int
)	O
)	O
;	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref	*(*(struct))
[	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref_cnt	int
]	O
=	O
piece	*(*(struct))
;	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
indent	*(int)
[	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref_cnt	int
]	O
=	O
indentation	int
;	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref_cnt	int
++	O
;	O
}	O
else	O
if	O
(	O
indentation	int
>	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
indent	*(int)
[	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref_cnt	int
-	O
1	int
]	O
)	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
indent	*(int)
[	O
r	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref_cnt	int
-	O
1	int
]	O
=	O
indentation	int
;	O
}	O
static	O
void	O
piece_print_trailer	()->(void)
(	O
void	O
)	O
{	O
int	O
comment_cnt	int
;	O
if	O
(	O
!	O
segment_selected_p	()->(int)
(	O
)	O
)	O
return	O
;	O
if	O
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece_cur	int
!=	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
name	*(char)
,	O
"Anonymous"	*(char)
)	O
)	O
return	O
;	O
comment_cnt	int
=	O
(	O
segment_piece_cnt	()->(int)
(	O
)	O
!=	O
1	int
)	O
+	O
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref_cnt	int
>	O
0	int
)	O
;	O
if	O
(	O
comment_cnt	int
==	O
0	int
)	O
return	O
;	O
emits	O
(	O
"@noindent\n"	*(char)
)	O
;	O
if	O
(	O
segment_piece_cnt	()->(int)
(	O
)	O
!=	O
1	int
)	O
{	O
int	O
i	int
,	O
cnt	int
;	O
cnt	int
=	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece_cnt	int
-	O
1	int
;	O
emitf	(*(char))->(void)
(	O
"@little{%s "	*(char)
,	O
_	O
(	O
"See also"	*(char)
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
cnt	int
;	O
i	int
++	O
)	O
{	O
int	O
idx	int
;	O
if	O
(	O
cnt	int
>	O
2	int
)	O
{	O
if	O
(	O
i	int
>	O
0	int
)	O
emits	O
(	O
", "	*(char)
)	O
;	O
if	O
(	O
i	int
==	O
cnt	int
-	O
1	int
)	O
emitf	(*(char))->(void)
(	O
"%s"	*(char)
,	O
_	O
(	O
"and"	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
cnt	int
==	O
2	int
&&	O
i	int
==	O
1	int
)	O
emitf	(*(char))->(void)
(	O
" %s "	*(char)
,	O
_	O
(	O
"and"	*(char)
)	O
)	O
;	O
idx	int
=	O
i	int
;	O
if	O
(	O
i	int
>=	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece_cur	int
)	O
idx	int
++	O
;	O
emits	O
(	O
"@refalso{"	*(char)
)	O
;	O
print_anchor_name	(*(char),int)->(void)
(	O
segment_name	()->(*(char))
(	O
)	O
,	O
idx	int
)	O
;	O
emitf	(*(char))->(void)
(	O
", , @segno{%d}}"	*(char)
,	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
piece	*(*(struct))
[	O
idx	int
]	O
->	O
number	int
)	O
;	O
}	O
emits	O
(	O
".}"	*(char)
)	O
;	O
}	O
if	O
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref_cnt	int
>	O
0	int
)	O
{	O
int	O
cnt	int
=	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref_cnt	int
;	O
int	O
i	int
;	O
if	O
(	O
comment_cnt	int
>	O
1	int
)	O
emits	O
(	O
"@*\n"	*(char)
)	O
;	O
emitf	(*(char))->(void)
(	O
"@little{%s "	*(char)
,	O
_	O
(	O
"This code is included in"	*(char)
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
cnt	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
cnt	int
>	O
2	int
)	O
{	O
if	O
(	O
i	int
>	O
0	int
)	O
emits	O
(	O
", "	*(char)
)	O
;	O
if	O
(	O
i	int
==	O
cnt	int
-	O
1	int
)	O
emitf	(*(char))->(void)
(	O
"%s "	*(char)
,	O
_	O
(	O
"and"	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
cnt	int
==	O
2	int
&&	O
i	int
==	O
1	int
)	O
emitf	(*(char))->(void)
(	O
" %s "	*(char)
,	O
_	O
(	O
"and"	*(char)
)	O
)	O
;	O
emits	O
(	O
"@refalso{"	*(char)
)	O
;	O
print_anchor_name	(*(char),int)->(void)
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref	*(*(struct))
[	O
i	int
]	O
->	O
segment	*(struct)
->	O
name	*(char)
,	O
0	int
)	O
;	O
emitf	(*(char))->(void)
(	O
", , @segno{%d}}"	*(char)
,	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
ref	*(*(struct))
[	O
i	int
]	O
->	O
number	int
)	O
;	O
}	O
emits	O
(	O
".}"	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
print_filename	(*(char))->(void)
(	O
const	O
char	O
*	O
fn	*(char)
)	O
{	O
emits	O
(	O
"@t{"	*(char)
)	O
;	O
while	O
(	O
*	O
fn	*(char)
)	O
{	O
if	O
(	O
*	O
fn	*(char)
==	O
'@'	O
||	O
*	O
fn	*(char)
==	O
'{'	O
||	O
*	O
fn	*(char)
==	O
'}'	O
)	O
emitc	O
(	O
'@'	O
)	O
;	O
emitc	O
(	O
*	O
fn	*(char)
)	O
;	O
fn	*(char)
++	O
;	O
}	O
emitc	O
(	O
'}'	O
)	O
;	O
}	O
static	O
void	O
print_anchor_name	(*(char),int)->(void)
(	O
const	O
char	O
*	O
s	*(struct)
,	O
int	O
idx	int
)	O
{	O
for	O
(	O
;	O
;	O
)	O
switch	O
(	O
*	O
s	*(struct)
)	O
{	O
case	O
'.'	O
:	O
case	O
','	O
:	O
case	O
':'	O
:	O
case	O
'\''	O
:	O
case	O
'\\'	O
:	O
case	O
'@'	O
:	O
case	O
'{'	O
:	O
case	O
'}'	O
:	O
s	*(struct)
++	O
;	O
break	O
;	O
case	O
' '	O
:	O
case	O
'\t'	O
:	O
case	O
'\r'	O
:	O
case	O
'\n'	O
:	O
case	O
'\v'	O
:	O
while	O
(	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
++	O
s	*(struct)
)	O
)	O
;	O
emitc	O
(	O
' '	O
)	O
;	O
break	O
;	O
case	O
';'	O
:	O
case	O
'\0'	O
:	O
if	O
(	O
idx	int
!=	O
0	int
)	O
emitf	(*(char))->(void)
(	O
"-%d"	*(char)
,	O
idx	int
+	O
1	int
)	O
;	O
return	O
;	O
default	O
:	O
emitc	O
(	O
*	O
s	*(struct)
++	O
)	O
;	O
break	O
;	O
}	O
}	O
static	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
print_identifier	(*(char),int)->(*(struct))
(	O
const	O
char	O
*	O
text	*(char)
,	O
int	O
len	long
)	O
{	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
=	O
symbol_find	(*(char),long,int)->(*(struct))
(	O
text	*(char)
,	O
len	long
,	O
0	int
)	O
;	O
emits	O
(	O
"@w{"	*(char)
)	O
;	O
if	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
==	O
NULL	O
||	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
->	O
kw_idx	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
!=	O
NULL	O
&&	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
->	O
is_typedef	int
)	O
emitf	(*(char))->(void)
(	O
TYPEDEF_STYLE	*(char)
"{%.*s}"	*(char)
,	O
len	long
,	O
text	*(char)
)	O
;	O
else	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
int	O
type	int
;	O
if	O
(	O
len	long
<	O
2	int
)	O
type	int
=	O
'i'	O
;	O
else	O
{	O
type	int
=	O
't'	O
;	O
for	O
(	O
p	*(char)
=	O
text	*(char)
;	O
p	*(char)
<	O
text	*(char)
+	O
len	long
;	O
p	*(char)
++	O
)	O
if	O
(	O
islower	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	*(char)
)	O
)	O
{	O
type	int
=	O
'i'	O
;	O
break	O
;	O
}	O
}	O
emitf	(*(char))->(void)
(	O
"@%c{%.*s}"	*(char)
,	O
type	int
,	O
len	long
,	O
text	*(char)
)	O
;	O
}	O
}	O
else	O
emitf	(*(char))->(void)
(	O
"@b{%.*s}"	*(char)
,	O
len	long
,	O
text	*(char)
)	O
;	O
emitc	O
(	O
'}'	O
)	O
;	O
return	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
;	O
}	O
static	O
void	O
print_piece_header	(*(char),int,int)->(void)
(	O
const	O
char	O
*	O
segment_name	()->(*(char))
,	O
int	O
type	int
,	O
int	O
operation	enum(int,int,int)
)	O
{	O
int	O
anonymous	int
=	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
segment_name	()->(*(char))
,	O
"Anonymous"	*(char)
)	O
;	O
transition	(enum(int,int,int,int))->(void)
(	O
TEXT	int
)	O
;	O
if	O
(	O
!	O
anonymous	int
)	O
{	O
emits	O
(	O
"@cindex "	*(char)
)	O
;	O
if	O
(	O
type	int
==	O
'<'	O
)	O
{	O
if	O
(	O
isupper	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
segment_name	()->(*(char))
[	O
0	int
]	O
)	O
&&	O
!	O
isupper	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
segment_name	()->(*(char))
[	O
1	int
]	O
)	O
)	O
{	O
emitc	O
(	O
tolower	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
segment_name	()->(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
print	(*(char),int)->(int)
(	O
segment_name	()->(*(char))
+	O
1	int
,	O
0	int
)	O
;	O
}	O
else	O
print	(*(char),int)->(int)
(	O
segment_name	()->(*(char))
,	O
0	int
)	O
;	O
}	O
else	O
print_filename	(*(char))->(void)
(	O
segment_name	()->(*(char))
)	O
;	O
emitc	O
(	O
'\n'	O
)	O
;	O
}	O
transition	(enum(int,int,int,int))->(void)
(	O
CODE	int
)	O
;	O
{	O
struct	O
segment	*(struct)
*	O
segment	*(struct)
=	O
segment_find	(*(char),int)->(*(struct))
(	O
segment_name	()->(*(char))
,	O
0	int
)	O
;	O
assert	O
(	O
segment	*(struct)
!=	O
NULL	O
)	O
;	O
segment_select	(*(struct))->(void)
(	O
segment	*(struct)
)	O
;	O
segment_next_piece	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
anonymous	int
)	O
{	O
emitf	(*(char))->(void)
(	O
"@tabalign{}@inleftmargin{@w{@segno{%d} }}@nottex{%d. }@value{LANG}@anchor{"	*(char)
,	O
segment_number	()->(int)
(	O
)	O
,	O
segment_number	()->(int)
(	O
)	O
)	O
;	O
print_anchor_name	(*(char),int)->(void)
(	O
segment_name	()->(*(char))
,	O
segment_piece_cur	()->(int)
(	O
)	O
)	O
;	O
emitc	O
(	O
'}'	O
)	O
;	O
state_push	(enum(int,int,int,int))->(void)
(	O
CONTROL	int
)	O
;	O
if	O
(	O
type	int
==	O
'<'	O
)	O
print	(*(char),int)->(int)
(	O
segment_name	()->(*(char))
,	O
0	int
)	O
;	O
else	O
print_filename	(*(char))->(void)
(	O
segment_name	()->(*(char))
)	O
;	O
state_pop	()->(void)
(	O
)	O
;	O
emitf	(*(char))->(void)
(	O
" @little{%d}@value{RANG} %s@value{IS}@cr\n"	*(char)
,	O
segment_first_piece	()->(int)
(	O
)	O
,	O
operation	enum(int,int,int)
==	O
'+'	O
?	O
"@math{+}"	*(char)
:	O
""	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
open_header_file	(*(char))->(void)
(	O
char	O
*	O
line	int
)	O
{	O
static	O
const	O
char	O
*	O
headers	array(*(char))
[	O
]	O
=	O
{	O
"@set COMMA ,\n"	*(char)
,	O
"\n"	*(char)
,	O
"@iftex\n"	*(char)
,	O
"@set LANG @math{@langle{}@thinspace{}}\n"	*(char)
,	O
"@set RANG @math{@thinspace{}@rangle{}}\n"	*(char)
,	O
"@set LQUOTE ``\n"	*(char)
,	O
"@set RQUOTE ''\n"	*(char)
,	O
"@set NULL @math{@Lambda{}}\n"	*(char)
,	O
"@set EQ @math{@equiv{}}\n"	*(char)
,	O
"@set IS @math{@equiv{}}\n"	*(char)
,	O
"@set NE @math{@ne{}@kern-.3333em}\n"	*(char)
,	O
"@set GE @math{@ge{}@kern-.3333em}\n"	*(char)
,	O
"@set LE @math{@le{}@kern-.3333em}\n"	*(char)
,	O
"@set AST @math{@ast{}}\n"	*(char)
,	O
"@set AND @math{@wedge{}}\n"	*(char)
,	O
"@set OR @math{@vee{}}\n"	*(char)
,	O
"@set TIMES @math{@times{}}\n"	*(char)
,	O
"@set RARR @math{@rightarrow{}@kern-.3333em}\n"	*(char)
,	O
"@set INV @math{@neg{}}\n"	*(char)
,	O
"@set SP {@char`@ }\n"	*(char)
,	O
"@end iftex\n"	*(char)
,	O
"\n"	*(char)
,	O
"@ifnottex\n"	*(char)
,	O
"@set LANG <\n"	*(char)
,	O
"@set RANG >\n"	*(char)
,	O
"@set LQUOTE \"\n"	*(char)
,	O
"@set RQUOTE \"\n"	*(char)
,	O
"@set NULL NULL\n"	*(char)
,	O
"@set EQ ==\n"	*(char)
,	O
"@set IS =\n"	*(char)
,	O
"@set NE !=\n"	*(char)
,	O
"@set LE <=\n"	*(char)
,	O
"@set GE >=\n"	*(char)
,	O
"@set AST *\n"	*(char)
,	O
"@set AND &&\n"	*(char)
,	O
"@set OR ||\n"	*(char)
,	O
"@set TIMES *\n"	*(char)
,	O
"@set RARR ->\n"	*(char)
,	O
"@set INV !\n"	*(char)
,	O
"@set SP @ @c\n"	*(char)
,	O
"@end ifnottex\n"	*(char)
,	O
"\n"	*(char)
,	O
"@ifnottex\n"	*(char)
,	O
"@macro inleftmargin{TEXT}\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro nottex{TEXT}\n"	*(char)
,	O
"\\TEXT\\\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro segno{NUMBER}\n"	*(char)
,	O
"\\NUMBER\\\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro little{TEXT}\n"	*(char)
,	O
"\\TEXT\\\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro tabalign\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro wtab\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro tcr{TEXT}\n"	*(char)
,	O
"@*\\TEXT\\\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro cleartabs\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro IND{AMT}\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro cr\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro begincode\n"	*(char)
,	O
"@format\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro endcode\n"	*(char)
,	O
"@end format\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro blankline\n"	*(char)
,	O
"@tabalign{}@cr\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro exponent{EXP}\n"	*(char)
,	O
"e\\EXP\\\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro unaryminus{}\n"	*(char)
,	O
"-\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro unaryplus{}\n"	*(char)
,	O
"+\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro exerspace{}\n"	*(char)
,	O
"@w{ }\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@end ifnottex\n"	*(char)
,	O
"\n"	*(char)
,	O
"@iftex\n"	*(char)
,	O
"@macro inleftmargin{TEXT}\n"	*(char)
,	O
"@hskip -.4in@hbox to .4in{\\TEXT\\@hskip 0in plus1fil}\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro nottex{TEXT}\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro segno{NUMBER}\n"	*(char)
,	O
"@S\\NUMBER\\\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro little{TEXT}\n"	*(char)
,	O
"{@smallrm{}\\TEXT\\}\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro tcr{TEXT}\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro IND{AMT}\n"	*(char)
,	O
"@hskip\\AMT\\\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro begincode\n"	*(char)
,	O
"@smallskip\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro endcode\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro blankline\n"	*(char)
,	O
"@smallskip\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@alias wtab=tab\n"	*(char)
,	O
"@macro exerspace{}\n"	*(char)
,	O
"@hskip .5em plus0em minus0em\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@end iftex\n"	*(char)
,	O
"\n"	*(char)
,	O
"@ifhtml\n"	*(char)
,	O
"@macro refcode {TITLE, NODE, SEGMENT}\n"	*(char)
,	O
"@value{LANG}@ref{\\NODE\\, , \\TITLE\\ \\SEGMENT\\}@value{RANG}\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@alias refalso=ref\n"	*(char)
,	O
"@end ifhtml\n"	*(char)
,	O
"\n"	*(char)
,	O
"@ifinfo\n"	*(char)
,	O
"@ifclear PLAINTEXT\n"	*(char)
,	O
"@macro refcode {TITLE, NODE, SEGMENT}\n"	*(char)
,	O
"@value{LANG}@ref{\\NODE\\} \\SEGMENT\\@value{RANG}\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@alias refalso=ref\n"	*(char)
,	O
"@end ifclear\n"	*(char)
,	O
"@ifset PLAINTEXT\n"	*(char)
,	O
"@macro refcode {TITLE, NODE, SEGMENT}\n"	*(char)
,	O
"@value{LANG}\\TITLE\\ \\SEGMENT\\@value{RANG}\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@macro refalso {TITLE, NODE, SEGMENT}\n"	*(char)
,	O
"\\SEGMENT\\\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@end ifset\n"	*(char)
,	O
"@end ifinfo\n"	*(char)
,	O
"\n"	*(char)
,	O
"@iftex\n"	*(char)
,	O
"@macro refcode {TITLE, NODE, SEGMENT}\n"	*(char)
,	O
"@value{LANG}\\TITLE\\ {@smallrm{}\\SEGMENT\\}@value{RANG}\n"	*(char)
,	O
"@end macro\n"	*(char)
,	O
"@end iftex\n"	*(char)
,	O
"\n"	*(char)
,	O
"@tex\n"	*(char)
,	O
"\\global\\def\\unaryminus{${}^-$}\n"	*(char)
,	O
"\\global\\def\\unaryplus{${}^+$}\n"	*(char)
,	O
"\\global\\def\\exponent#1{$\\cdot{}10^{#1}$}\n"	*(char)
,	O
"\\global\\def\\refalso#1{\\xrefXalso[#1,,,,,,,]}\n"	*(char)
,	O
"\\global\\def\\xrefXalso[#1,#2,#3,#4,#5,#6]{\\begingroup\n"	*(char)
,	O
"  \\unsepspaces\n"	*(char)
,	O
"  \\def\\printednodename{\\ignorespaces #3}%\n"	*(char)
,	O
"  \\setbox0=\\hbox{\\printednodename}%\n"	*(char)
,	O
"  \\ifpdf\n"	*(char)
,	O
"    \\leavevmode\n"	*(char)
,	O
"    \\getfilename{}%\n"	*(char)
,	O
"    \\ifnum\\filenamelength>0\n"	*(char)
,	O
"      \\startlink attr{/Border [0 0 0]}%\n"	*(char)
,	O
"        goto file{\\the\\filename.pdf} name{#1@@}%\n"	*(char)
,	O
"    \\else\n"	*(char)
,	O
"      \\startlink attr{/Border [0 0 0]}%\n"	*(char)
,	O
"        goto name{#1@@}%\n"	*(char)
,	O
"    \\fi\n"	*(char)
,	O
"    \\linkcolor\n"	*(char)
,	O
"  \\fi\n"	*(char)
,	O
"  {\\normalturnoffactive\n"	*(char)
,	O
"   \\setbox2 = \\hbox{\\ignorespaces \\refx{#1-snt}{}}%\n"	*(char)
,	O
"   \\ifdim \\wd2 > 0pt \\refx{#1-snt}\\space\\fi\n"	*(char)
,	O
"  }%\n"	*(char)
,	O
"  \\printednodename\n"	*(char)
,	O
"  \\turnoffactive% \\tie{(page \\refx{#1-pg}{})}%\n"	*(char)
,	O
"  \\endlink\n"	*(char)
,	O
"\\endgroup}\n"	*(char)
,	O
"@end tex\n\n"	*(char)
,	O
NULL	O
}	O
;	O
char	O
*	O
bp	*(*(char))
,	O
*	O
ep	*(*(char))
;	O
const	O
char	O
*	O
*	O
p	*(char)
;	O
if	O
(	O
!	O
find_argument	(*(char),*(*(char)),*(*(char)))->(int)
(	O
line	int
,	O
&	O
bp	*(*(char))
,	O
&	O
ep	*(*(char))
)	O
)	O
return	O
;	O
*	O
ep	*(*(char))
=	O
'\0'	O
;	O
if	O
(	O
header_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Extra @setheaderfile ignored"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
header_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
bp	*(*(char))
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
header_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
error	(int,*(char))->(void)
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"Opening %s: %s"	*(char)
)	O
,	O
bp	*(*(char))
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
for	O
(	O
p	*(char)
=	O
headers	array(*(char))
;	O
*	O
p	*(char)
!=	O
NULL	O
;	O
p	*(char)
++	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
*	O
p	*(char)
,	O
header_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
close_header_file	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
header_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
error	(int,*(char))->(void)
(	O
0	int
,	O
_	O
(	O
"No `@setheaderfile' in source."	*(char)
)	O
)	O
;	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
header_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
error	(int,*(char))->(void)
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"Closing header file: %s"	*(char)
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
header_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
}	O
static	O
int	O
in_exercise	int
=	O
0	int
;	O
static	O
void	O
section_init	(*(struct(array(short))))->(void)
(	O
struct	O
section	struct(array(short))
*	O
section	struct(array(short))
)	O
{	O
int	O
level	array(short)
;	O
for	O
(	O
level	array(short)
=	O
0	int
;	O
level	array(short)
<	O
LEVEL_CNT	int
;	O
level	array(short)
++	O
)	O
section	struct(array(short))
->	O
level	array(short)
[	O
level	array(short)
]	O
=	O
0	int
;	O
}	O
static	O
void	O
section_advance	(*(struct(array(short))),enum(int,int,int,int,int,int))->(void)
(	O
struct	O
section	struct(array(short))
*	O
section	struct(array(short))
,	O
enum	O
section_level	enum(int,int,int,int,int,int)
level	array(short)
)	O
{	O
if	O
(	O
in_exercise	int
&&	O
level	array(short)
!=	O
LEVEL_EXERCISE	int
)	O
{	O
error	(int,*(char))->(void)
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"Unterminated exercise at section boundary."	*(char)
)	O
)	O
;	O
in_exercise	int
=	O
0	int
;	O
}	O
section	struct(array(short))
->	O
level	array(short)
[	O
level	array(short)
]	O
++	O
;	O
for	O
(	O
level	array(short)
++	O
;	O
level	array(short)
<	O
LEVEL_CNT	int
;	O
level	array(short)
++	O
)	O
section	struct(array(short))
->	O
level	array(short)
[	O
level	array(short)
]	O
=	O
0	int
;	O
}	O
static	O
int	O
section_differs	(*(struct(array(short))),*(struct(array(short))),enum(int,int,int,int,int,int))->(int)
(	O
struct	O
section	struct(array(short))
*	O
a	*(struct(int,*(char)))
,	O
struct	O
section	struct(array(short))
*	O
b	*(struct(int,*(char)))
,	O
enum	O
section_level	enum(int,int,int,int,int,int)
level	array(short)
)	O
{	O
enum	O
section_level	enum(int,int,int,int,int,int)
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
level	array(short)
;	O
i	int
++	O
)	O
if	O
(	O
a	*(struct(int,*(char)))
->	O
level	array(short)
[	O
i	int
]	O
!=	O
b	*(struct(int,*(char)))
->	O
level	array(short)
[	O
i	int
]	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
section_name	(*(struct(array(short))),array(char))->(void)
(	O
struct	O
section	struct(array(short))
*	O
section	struct(array(short))
,	O
char	O
name	*(char)
[	O
64	int
]	O
)	O
{	O
int	O
level	array(short)
;	O
sprintf	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"%d"	*(char)
,	O
section	struct(array(short))
->	O
level	array(short)
[	O
LEVEL_CHAPTER	int
]	O
)	O
;	O
for	O
(	O
level	array(short)
=	O
1	int
;	O
level	array(short)
<	O
LEVEL_EXERCISE	int
;	O
level	array(short)
++	O
)	O
{	O
name	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
name	*(char)
,	O
'\0'	O
)	O
;	O
if	O
(	O
section	struct(array(short))
->	O
level	array(short)
[	O
level	array(short)
]	O
==	O
0	int
)	O
break	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
".%d"	*(char)
,	O
section	struct(array(short))
->	O
level	array(short)
[	O
level	array(short)
]	O
)	O
;	O
}	O
}	O
static	O
int	O
section_recognize	(*(char))->(int)
(	O
const	O
char	O
*	O
cmd	*(char)
)	O
{	O
struct	O
section_cmd	struct(enum(int,int,int,int,int,int),*(char))
{	O
enum	O
section_level	enum(int,int,int,int,int,int)
level	array(short)
;	O
char	O
*	O
name	*(char)
;	O
}	O
;	O
static	O
const	O
struct	O
section_cmd	struct(enum(int,int,int,int,int,int),*(char))
cmds	array(struct(enum(int,int,int,int,int,int),*(char)))
[	O
]	O
=	O
{	O
{	O
LEVEL_CHAPTER	int
,	O
"chapter"	*(char)
}	O
,	O
{	O
LEVEL_CHAPTER	int
,	O
"unnumbered"	*(char)
}	O
,	O
{	O
LEVEL_CHAPTER	int
,	O
"appendix"	*(char)
}	O
,	O
{	O
LEVEL_SECTION	int
,	O
"section"	*(char)
}	O
,	O
{	O
LEVEL_SECTION	int
,	O
"unnumberedsec"	*(char)
}	O
,	O
{	O
LEVEL_SECTION	int
,	O
"appendixsec"	*(char)
}	O
,	O
{	O
LEVEL_SUBSECTION	int
,	O
"subsection"	*(char)
}	O
,	O
{	O
LEVEL_SUBSECTION	int
,	O
"unnumberedsubsec"	*(char)
}	O
,	O
{	O
LEVEL_SUBSECTION	int
,	O
"appendixsubsec"	*(char)
}	O
,	O
{	O
LEVEL_SUBSUBSECTION	int
,	O
"subsubsection"	*(char)
}	O
,	O
{	O
LEVEL_SUBSUBSECTION	int
,	O
"unnumberedsubsubsec"	*(char)
}	O
,	O
{	O
LEVEL_SUBSUBSECTION	int
,	O
"appendixsubsubsec"	*(char)
}	O
,	O
{	O
LEVEL_EXERCISE	int
,	O
"exercise"	*(char)
}	O
,	O
}	O
;	O
const	O
struct	O
section_cmd	struct(enum(int,int,int,int,int,int),*(char))
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
cmds	array(struct(enum(int,int,int,int,int,int),*(char)))
;	O
p	*(char)
<	O
cmds	array(struct(enum(int,int,int,int,int,int),*(char)))
+	O
sizeof	O
cmds	array(struct(enum(int,int,int,int,int,int),*(char)))
/	O
sizeof	O
*	O
cmds	array(struct(enum(int,int,int,int,int,int),*(char)))
;	O
p	*(char)
++	O
)	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
p	*(char)
->	O
name	*(char)
)	O
)	O
{	O
section_advance	(*(struct(array(short))),enum(int,int,int,int,int,int))->(void)
(	O
&	O
cur_section	struct(array(short))
,	O
p	*(char)
->	O
level	array(short)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
exercise_process	(*(char),*(char),int)->(int)
(	O
const	O
char	O
*	O
cmd	*(char)
,	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"setanswerfile"	*(char)
)	O
)	O
exercise_open_answer_file	(*(char),int)->(void)
(	O
line	int
,	O
pass	int
)	O
;	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
cmd	*(char)
,	O
"exercise"	*(char)
,	O
8	int
)	O
)	O
exercise_begin	(*(char),int)->(void)
(	O
line	int
,	O
pass	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"answer"	*(char)
)	O
)	O
exercise_answer	(*(char),int)->(void)
(	O
line	int
,	O
pass	int
)	O
;	O
else	O
return	O
exercise_end	(*(char),*(char),int)->(int)
(	O
cmd	*(char)
,	O
line	int
,	O
pass	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
exercise_begin	(*(char),int)->(void)
(	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
{	O
if	O
(	O
pass	int
==	O
2	int
)	O
{	O
char	O
*	O
bp	*(*(char))
,	O
*	O
ep	*(*(char))
;	O
bp	*(*(char))
=	O
ep	*(*(char))
=	O
line	int
+	O
strlen	(*(char))->(long)
(	O
"@exercise"	*(char)
)	O
;	O
while	O
(	O
!	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
ep	*(*(char))
)	O
)	O
ep	*(*(char))
++	O
;	O
if	O
(	O
cur_section	struct(array(short))
.	O
level	array(short)
[	O
LEVEL_EXERCISE	int
]	O
==	O
1	int
)	O
emitf	(*(char))->(void)
(	O
"@blankline @noindent @b{%s}\n\n"	*(char)
,	O
_	O
(	O
"Exercises:"	*(char)
)	O
)	O
;	O
emitf	(*(char))->(void)
(	O
"@blankline @noindent @b{%.*s%d.}"	*(char)
,	O
(	O
int	O
)	O
(	O
ep	*(*(char))
-	O
bp	*(*(char))
)	O
,	O
bp	*(*(char))
,	O
cur_section	struct(array(short))
.	O
level	array(short)
[	O
LEVEL_EXERCISE	int
]	O
)	O
;	O
if	O
(	O
find_optional_argument	(*(char),*(*(char)),*(*(char)))->(int)
(	O
line	int
,	O
&	O
bp	*(*(char))
,	O
&	O
ep	*(*(char))
)	O
)	O
{	O
char	O
sec_name	array(char)
[	O
64	int
]	O
;	O
section_name	(*(struct(array(short))),array(char))->(void)
(	O
&	O
cur_section	struct(array(short))
,	O
sec_name	array(char)
)	O
;	O
if	O
(	O
header_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
header_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"@set %.*s Exercise %s-%d\n"	*(char)
"@set %.*sbrief Exercise %d\n"	*(char)
,	O
(	O
int	O
)	O
(	O
ep	*(*(char))
-	O
bp	*(*(char))
)	O
,	O
bp	*(*(char))
,	O
sec_name	array(char)
,	O
cur_section	struct(array(short))
.	O
level	array(short)
[	O
LEVEL_EXERCISE	int
]	O
,	O
(	O
int	O
)	O
(	O
ep	*(*(char))
-	O
bp	*(*(char))
)	O
,	O
bp	*(*(char))
,	O
cur_section	struct(array(short))
.	O
level	array(short)
[	O
LEVEL_EXERCISE	int
]	O
)	O
;	O
else	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"No preceding `@setheaderfile'."	*(char)
)	O
)	O
;	O
emitf	(*(char))->(void)
(	O
"@anchor{%.*s}"	*(char)
,	O
(	O
int	O
)	O
(	O
ep	*(*(char))
-	O
bp	*(*(char))
)	O
,	O
bp	*(*(char))
)	O
;	O
}	O
emits	O
(	O
"@exerspace{}"	*(char)
)	O
;	O
}	O
if	O
(	O
in_exercise	int
)	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"`@exercise' within exercise."	*(char)
)	O
)	O
;	O
in_exercise	int
=	O
1	int
;	O
}	O
static	O
int	O
exercise_end	(*(char),*(char),int)->(int)
(	O
const	O
char	O
*	O
cmd	*(char)
,	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
{	O
char	O
*	O
bp	*(*(char))
,	O
*	O
ep	*(*(char))
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"end"	*(char)
)	O
)	O
return	O
0	int
;	O
find_argument	(*(char),*(*(char)),*(*(char)))->(int)
(	O
line	int
,	O
&	O
bp	*(*(char))
,	O
&	O
ep	*(*(char))
)	O
;	O
if	O
(	O
ep	*(*(char))
-	O
bp	*(*(char))
!=	O
8	int
||	O
memcmp	(*(void),*(void),long)->(int)
(	O
bp	*(*(char))
,	O
"exercise"	*(char)
,	O
8	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
in_exercise	int
)	O
{	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"`@end exercise' outside exercise."	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
pass	int
==	O
2	int
&&	O
print_unanswered	int
)	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Exercise missing answer."	*(char)
)	O
)	O
;	O
in_exercise	int
=	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
exercise_answer	(*(char),int)->(void)
(	O
char	O
*	O
pline	*(char)
,	O
int	O
pass	int
)	O
{	O
char	O
*	O
line	int
=	O
xstrdup	(*(char))->(*(char))
(	O
pline	*(char)
)	O
;	O
size_t	long
size	long
=	O
strlen	(*(char))->(long)
(	O
pline	*(char)
)	O
+	O
1	int
;	O
if	O
(	O
pass	int
==	O
1	int
&&	O
answer_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
error	(int,*(char))->(void)
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"@answer: No answer file defined."	*(char)
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
static	O
const	O
char	O
answer	array(char)
[	O
]	O
=	O
"@answer"	*(char)
;	O
static	O
const	O
char	O
exercise	array(char)
[	O
]	O
=	O
"@exercise"	*(char)
;	O
static	O
const	O
char	O
end_exercise	array(char)
[	O
]	O
=	O
"@end exercise"	*(char)
;	O
if	O
(	O
pass	int
==	O
1	int
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
line	int
,	O
answer	array(char)
,	O
(	O
sizeof	O
answer	array(char)
)	O
-	O
1	int
)	O
)	O
{	O
{	O
static	O
struct	O
section	struct(array(short))
last_answer	struct(array(short))
;	O
if	O
(	O
section_differs	(*(struct(array(short))),*(struct(array(short))),enum(int,int,int,int,int,int))->(int)
(	O
&	O
cur_section	struct(array(short))
,	O
&	O
last_answer	struct(array(short))
,	O
LEVEL_CHAPTER	int
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
answer_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"@unnumberedsec %s %d\n\n"	*(char)
,	O
_	O
(	O
"Chapter"	*(char)
)	O
,	O
cur_section	struct(array(short))
.	O
level	array(short)
[	O
0	int
]	O
)	O
;	O
if	O
(	O
section_differs	(*(struct(array(short))),*(struct(array(short))),enum(int,int,int,int,int,int))->(int)
(	O
&	O
cur_section	struct(array(short))
,	O
&	O
last_answer	struct(array(short))
,	O
LEVEL_SUBSUBSECTION	int
)	O
&&	O
cur_section	struct(array(short))
.	O
level	array(short)
[	O
LEVEL_SECTION	int
]	O
!=	O
0	int
)	O
{	O
char	O
sec_name	array(char)
[	O
64	int
]	O
;	O
section_name	(*(struct(array(short))),array(char))->(void)
(	O
&	O
cur_section	struct(array(short))
,	O
sec_name	array(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
answer_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"@subheading %s %s\n\n"	*(char)
,	O
_	O
(	O
"Section"	*(char)
)	O
,	O
sec_name	array(char)
)	O
;	O
}	O
last_answer	struct(array(short))
=	O
cur_section	struct(array(short))
;	O
}	O
{	O
char	O
*	O
bp	*(*(char))
,	O
*	O
ep	*(*(char))
;	O
if	O
(	O
!	O
find_optional_argument	(*(char),*(*(char)),*(*(char)))->(int)
(	O
line	int
,	O
&	O
bp	*(*(char))
,	O
&	O
ep	*(*(char))
)	O
)	O
bp	*(*(char))
=	O
ep	*(*(char))
=	O
""	*(char)
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
answer_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n@blankline @noindent @b{%d%.*s.}\n"	*(char)
,	O
cur_section	struct(array(short))
.	O
level	array(short)
[	O
LEVEL_EXERCISE	int
]	O
,	O
(	O
int	O
)	O
(	O
ep	*(*(char))
-	O
bp	*(*(char))
)	O
,	O
bp	*(*(char))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
line	int
,	O
exercise	array(char)
,	O
(	O
sizeof	O
exercise	array(char)
)	O
-	O
1	int
)	O
)	O
error	(int,*(char))->(void)
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"@exercise seen looking for @end exercise"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
line	int
,	O
end_exercise	array(char)
,	O
(	O
sizeof	O
end_exercise	array(char)
)	O
-	O
1	int
)	O
)	O
break	O
;	O
else	O
if	O
(	O
pass	int
==	O
1	int
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
line	int
,	O
answer_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
input_read_line	(*(*(char)),*(long))->(int)
(	O
&	O
line	int
,	O
&	O
size	long
)	O
)	O
error	(int,*(char))->(void)
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"End-of-file looking for @end exercise"	*(char)
)	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
line	int
)	O
;	O
in_exercise	int
=	O
0	int
;	O
}	O
static	O
void	O
exercise_close_answer_file	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
answer_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
answer_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
error	(int,*(char))->(void)
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"Closing answer file: %s"	*(char)
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
answer_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
}	O
static	O
void	O
exercise_open_answer_file	(*(char),int)->(void)
(	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
{	O
char	O
*	O
bp	*(*(char))
,	O
*	O
ep	*(*(char))
;	O
if	O
(	O
!	O
find_argument	(*(char),*(*(char)),*(*(char)))->(int)
(	O
line	int
,	O
&	O
bp	*(*(char))
,	O
&	O
ep	*(*(char))
)	O
)	O
return	O
;	O
if	O
(	O
pass	int
==	O
1	int
)	O
{	O
exercise_close_answer_file	()->(void)
(	O
)	O
;	O
free	(*(void))->(void)
(	O
answer_file_name	*(char)
)	O
;	O
answer_file_name	*(char)
=	O
xstrndup	(*(char),long)->(*(char))
(	O
bp	*(*(char))
,	O
ep	*(*(char))
-	O
bp	*(*(char))
)	O
;	O
answer_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
answer_file_name	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
answer_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
error	(int,*(char))->(void)
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"Opening %s: %s"	*(char)
)	O
,	O
bp	*(*(char))
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
static	O
int	O
parse_at_cmd	(*(char),array(char))->(int)
(	O
const	O
char	O
*	O
line	int
,	O
char	O
cmd	*(char)
[	O
CMD_LEN_MAX	int
+	O
1	int
]	O
)	O
{	O
if	O
(	O
*	O
line	int
++	O
!=	O
'@'	O
)	O
return	O
0	int
;	O
if	O
(	O
isalpha	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
line	int
)	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
CMD_LEN_MAX	int
;	O
i	int
++	O
)	O
{	O
*	O
cmd	*(char)
++	O
=	O
*	O
line	int
++	O
;	O
if	O
(	O
!	O
isalpha	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
line	int
)	O
)	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
line	int
!=	O
'\0'	O
&&	O
!	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
line	int
)	O
)	O
*	O
cmd	*(char)
++	O
=	O
*	O
line	int
++	O
;	O
*	O
cmd	*(char)
=	O
'\0'	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
in_control	int
;	O
static	O
int	O
control_space	int
;	O
static	O
char	O
*	O
control_buf	*(char)
;	O
static	O
size_t	long
control_len	long
;	O
static	O
size_t	long
control_size	long
;	O
static	O
void	O
add_control	(*(char),long)->(void)
(	O
const	O
char	O
*	O
text	*(char)
,	O
size_t	long
len	long
)	O
{	O
const	O
char	O
*	O
cp	*(char)
;	O
if	O
(	O
control_len	long
+	O
len	long
+	O
8	int
>	O
control_size	long
)	O
{	O
control_size	long
=	O
control_len	long
*	O
2	int
+	O
len	long
+	O
16	int
;	O
control_buf	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
control_buf	*(char)
,	O
control_size	long
)	O
;	O
}	O
for	O
(	O
cp	*(char)
=	O
text	*(char)
;	O
cp	*(char)
<	O
text	*(char)
+	O
len	long
;	O
cp	*(char)
++	O
)	O
{	O
if	O
(	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	*(char)
)	O
)	O
{	O
if	O
(	O
control_len	long
==	O
0	int
)	O
continue	O
;	O
control_space	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
control_space	int
)	O
{	O
control_buf	*(char)
[	O
control_len	long
++	O
]	O
=	O
' '	O
;	O
control_space	int
=	O
0	int
;	O
}	O
control_buf	*(char)
[	O
control_len	long
++	O
]	O
=	O
*	O
cp	*(char)
;	O
}	O
}	O
static	O
char	O
*	O
parse_control_text	(*(char),*(*(char)))->(*(char))
(	O
char	O
*	O
start	*(char)
,	O
char	O
*	O
*	O
tail	*(*(char))
)	O
{	O
char	O
*	O
end	*(*(char))
=	O
strstr	(*(char),*(char))->(*(char))
(	O
start	*(char)
,	O
"@>"	*(char)
)	O
;	O
if	O
(	O
end	*(*(char))
!=	O
NULL	O
)	O
{	O
if	O
(	O
tail	*(*(char))
!=	O
NULL	O
)	O
*	O
tail	*(*(char))
=	O
end	*(*(char))
+	O
2	int
;	O
}	O
else	O
{	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Missing control text end marker @>."	*(char)
)	O
)	O
;	O
end	*(*(char))
=	O
strchr	(*(char),int)->(*(char))
(	O
start	*(char)
,	O
'\0'	O
)	O
;	O
if	O
(	O
tail	*(*(char))
!=	O
NULL	O
)	O
*	O
tail	*(*(char))
=	O
end	*(*(char))
;	O
}	O
{	O
char	O
*	O
buf	*(char)
;	O
control_len	long
=	O
0	int
;	O
control_space	int
=	O
0	int
;	O
add_control	(*(char),long)->(void)
(	O
start	*(char)
,	O
end	*(*(char))
-	O
start	*(char)
)	O
;	O
add_control	(*(char),long)->(void)
(	O
""	*(char)
,	O
1	int
)	O
;	O
buf	*(char)
=	O
control_buf	*(char)
;	O
control_buf	*(char)
=	O
NULL	O
;	O
control_len	long
=	O
0	int
;	O
control_size	long
=	O
0	int
;	O
return	O
buf	*(char)
;	O
}	O
}	O
enum	O
{	O
TOKEN_EOL	int
=	O
0	int
,	O
TOKEN_AT	int
=	O
-	O
256	int
,	O
TOKEN_BEGIN_CONTROL	int
,	O
TOKEN_END_CONTROL	int
,	O
TOKEN_SEMICOLON	int
,	O
TOKEN_PIPE	int
,	O
TOKEN_COND_NEWLINE	int
,	O
TOKEN_INC_INDENT	int
,	O
TOKEN_DEC_INDENT	int
,	O
TOKEN_ID	int
,	O
TOKEN_BEGIN_EMBED_CODE	int
,	O
TOKEN_END_EMBED_CODE	int
,	O
TOKEN_BEGIN_COMMENT	int
,	O
TOKEN_END_COMMENT	int
,	O
TOKEN_REPLACE	int
,	O
TOKEN_PREPROCESSOR	int
,	O
TOKEN_PSTRUCT_ELEM	int
,	O
TOKEN_EQ	int
,	O
TOKEN_NE	int
,	O
TOKEN_LE	int
,	O
TOKEN_GE	int
,	O
TOKEN_AND	int
,	O
TOKEN_OR	int
,	O
TOKEN_TIMES	int
,	O
TOKEN_NEG	int
,	O
TOKEN_POS	int
,	O
TOKEN_PLUSPLUS	int
,	O
TOKEN_MINUSMINUS	int
,	O
TOKEN_QUOTED_STRING	int
,	O
TOKEN_OCT_INT	int
,	O
TOKEN_HEX_INT	int
,	O
TOKEN_SCIENTIFIC	int
,	O
TOKEN_NUMBER	int
}	O
;	O
struct	O
token	*(struct)
{	O
int	O
type	int
;	O
const	O
char	O
*	O
text	*(char)
;	O
size_t	long
len	long
;	O
}	O
;	O
static	O
const	O
char	O
*	O
token_get	(*(char),*(struct))->(*(char))
(	O
const	O
char	O
*	O
s	*(struct)
,	O
struct	O
token	*(struct)
*	O
token	*(struct)
)	O
{	O
const	O
char	O
*	O
cp	*(char)
=	O
s	*(struct)
;	O
token	*(struct)
->	O
text	*(char)
=	O
s	*(struct)
;	O
if	O
(	O
*	O
cp	*(char)
==	O
'@'	O
)	O
{	O
cp	*(char)
++	O
;	O
token	*(struct)
->	O
type	int
=	O
' '	O
;	O
switch	O
(	O
*	O
cp	*(char)
++	O
)	O
{	O
case	O
'\n'	O
:	O
token	*(struct)
->	O
type	int
=	O
TOKEN_COND_NEWLINE	int
;	O
break	O
;	O
case	O
'@'	O
:	O
token	*(struct)
->	O
type	int
=	O
TOKEN_AT	int
;	O
break	O
;	O
case	O
'('	O
:	O
case	O
'<'	O
:	O
if	O
(	O
*	O
cp	*(char)
==	O
'='	O
)	O
{	O
token	*(struct)
->	O
type	int
=	O
TOKEN_LE	int
;	O
cp	*(char)
++	O
;	O
}	O
else	O
token	*(struct)
->	O
type	int
=	O
TOKEN_BEGIN_CONTROL	int
;	O
break	O
;	O
case	O
'>'	O
:	O
if	O
(	O
*	O
cp	*(char)
==	O
'='	O
)	O
{	O
token	*(struct)
->	O
type	int
=	O
TOKEN_GE	int
;	O
cp	*(char)
++	O
;	O
}	O
else	O
token	*(struct)
->	O
type	int
=	O
TOKEN_END_CONTROL	int
;	O
break	O
;	O
case	O
';'	O
:	O
token	*(struct)
->	O
type	int
=	O
TOKEN_SEMICOLON	int
;	O
break	O
;	O
case	O
'|'	O
:	O
token	*(struct)
->	O
type	int
=	O
TOKEN_PIPE	int
;	O
break	O
;	O
case	O
'+'	O
:	O
token	*(struct)
->	O
type	int
=	O
TOKEN_INC_INDENT	int
;	O
break	O
;	O
case	O
'='	O
:	O
token	*(struct)
->	O
type	int
=	O
TOKEN_EQ	int
;	O
break	O
;	O
case	O
'!'	O
:	O
if	O
(	O
*	O
cp	*(char)
==	O
'='	O
)	O
{	O
token	*(struct)
->	O
type	int
=	O
TOKEN_NE	int
;	O
cp	*(char)
++	O
;	O
}	O
else	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Skipped unknown token @!"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
'-'	O
:	O
if	O
(	O
state_is	(enum(int,int,int,int))->(int)
(	O
CODE	int
)	O
)	O
{	O
token	*(struct)
->	O
type	int
=	O
TOKEN_DEC_INDENT	int
;	O
break	O
;	O
}	O
default	O
:	O
cp	*(char)
--	O
;	O
token	*(struct)
->	O
type	int
=	O
'@'	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
cp	*(char)
==	O
'|'	O
&&	O
(	O
state_is	(enum(int,int,int,int))->(int)
(	O
TEXT	int
)	O
||	O
state_is	(enum(int,int,int,int))->(int)
(	O
COMMENT	int
)	O
||	O
state_is	(enum(int,int,int,int))->(int)
(	O
CONTROL	int
)	O
)	O
)	O
{	O
cp	*(char)
++	O
;	O
token	*(struct)
->	O
type	int
=	O
TOKEN_BEGIN_EMBED_CODE	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	*(char)
==	O
'='	O
&&	O
cp	*(char)
[	O
1	int
]	O
==	O
'>'	O
&&	O
state_is	(enum(int,int,int,int))->(int)
(	O
CONTROL	int
)	O
)	O
{	O
cp	*(char)
+=	O
2	int
;	O
token	*(struct)
->	O
type	int
=	O
TOKEN_REPLACE	int
;	O
}	O
else	O
if	O
(	O
isalpha	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	*(char)
)	O
||	O
*	O
cp	*(char)
==	O
'_'	O
)	O
{	O
token	*(struct)
->	O
type	int
=	O
TOKEN_ID	int
;	O
while	O
(	O
isalnum	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	*(char)
)	O
||	O
*	O
cp	*(char)
==	O
'_'	O
)	O
cp	*(char)
++	O
;	O
}	O
else	O
if	O
(	O
state_is	(enum(int,int,int,int))->(int)
(	O
CODE	int
)	O
)	O
{	O
if	O
(	O
*	O
cp	*(char)
==	O
'\''	O
||	O
*	O
cp	*(char)
==	O
'"'	O
)	O
{	O
int	O
quote	int
=	O
*	O
cp	*(char)
++	O
;	O
while	O
(	O
*	O
cp	*(char)
!=	O
quote	int
&&	O
*	O
cp	*(char)
!=	O
'\0'	O
)	O
{	O
if	O
(	O
*	O
cp	*(char)
==	O
'\\'	O
)	O
cp	*(char)
++	O
;	O
cp	*(char)
++	O
;	O
}	O
if	O
(	O
*	O
cp	*(char)
==	O
quote	int
)	O
cp	*(char)
++	O
;	O
token	*(struct)
->	O
type	int
=	O
TOKEN_QUOTED_STRING	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	*(char)
==	O
'0'	O
&&	O
(	O
cp	*(char)
[	O
1	int
]	O
==	O
'x'	O
||	O
cp	*(char)
[	O
1	int
]	O
==	O
'X'	O
)	O
)	O
{	O
cp	*(char)
+=	O
2	int
;	O
while	O
(	O
isxdigit	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	*(char)
)	O
)	O
cp	*(char)
++	O
;	O
token	*(struct)
->	O
type	int
=	O
TOKEN_HEX_INT	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	*(char)
==	O
'0'	O
&&	O
cp	*(char)
[	O
1	int
]	O
>=	O
'0'	O
&&	O
cp	*(char)
[	O
1	int
]	O
<=	O
'7'	O
)	O
{	O
cp	*(char)
++	O
;	O
while	O
(	O
*	O
cp	*(char)
>=	O
'0'	O
&&	O
*	O
cp	*(char)
<=	O
'7'	O
)	O
cp	*(char)
++	O
;	O
token	*(struct)
->	O
type	int
=	O
TOKEN_OCT_INT	int
;	O
}	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	*(char)
)	O
||	O
(	O
*	O
cp	*(char)
==	O
'.'	O
&&	O
isdigit	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	*(char)
)	O
)	O
)	O
{	O
cp	*(char)
++	O
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	*(char)
)	O
||	O
*	O
cp	*(char)
==	O
'.'	O
)	O
cp	*(char)
++	O
;	O
if	O
(	O
*	O
cp	*(char)
==	O
'e'	O
||	O
*	O
cp	*(char)
==	O
'E'	O
)	O
{	O
cp	*(char)
++	O
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	*(char)
)	O
||	O
*	O
cp	*(char)
==	O
'+'	O
||	O
*	O
cp	*(char)
==	O
'-'	O
)	O
cp	*(char)
++	O
;	O
token	*(struct)
->	O
type	int
=	O
TOKEN_SCIENTIFIC	int
;	O
}	O
else	O
token	*(struct)
->	O
type	int
=	O
TOKEN_NUMBER	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	*(char)
==	O
'|'	O
&&	O
cp	*(char)
[	O
1	int
]	O
!=	O
'|'	O
&&	O
(	O
state_was	(enum(int,int,int,int))->(int)
(	O
TEXT	int
)	O
||	O
state_was	(enum(int,int,int,int))->(int)
(	O
COMMENT	int
)	O
||	O
state_was	(enum(int,int,int,int))->(int)
(	O
CONTROL	int
)	O
)	O
)	O
{	O
cp	*(char)
++	O
;	O
token	*(struct)
->	O
type	int
=	O
TOKEN_END_EMBED_CODE	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	*(char)
==	O
'/'	O
&&	O
cp	*(char)
[	O
1	int
]	O
==	O
'*'	O
)	O
{	O
cp	*(char)
+=	O
2	int
;	O
token	*(struct)
->	O
type	int
=	O
TOKEN_BEGIN_COMMENT	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	*(char)
==	O
'#'	O
)	O
{	O
token	*(struct)
->	O
type	int
=	O
TOKEN_PREPROCESSOR	int
;	O
cp	*(char)
++	O
;	O
}	O
else	O
if	O
(	O
*	O
cp	*(char)
==	O
'-'	O
&&	O
cp	*(char)
[	O
1	int
]	O
==	O
'>'	O
)	O
{	O
token	*(struct)
->	O
type	int
=	O
TOKEN_PSTRUCT_ELEM	int
;	O
cp	*(char)
+=	O
2	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	*(char)
==	O
'-'	O
&&	O
cp	*(char)
[	O
1	int
]	O
==	O
'-'	O
)	O
{	O
token	*(struct)
->	O
type	int
=	O
TOKEN_MINUSMINUS	int
;	O
cp	*(char)
+=	O
2	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	*(char)
==	O
'+'	O
&&	O
cp	*(char)
[	O
1	int
]	O
==	O
'+'	O
)	O
{	O
token	*(struct)
->	O
type	int
=	O
TOKEN_PLUSPLUS	int
;	O
cp	*(char)
+=	O
2	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	*(char)
==	O
'-'	O
&&	O
(	O
cp	*(char)
[	O
1	int
]	O
!=	O
'='	O
&&	O
cp	*(char)
[	O
1	int
]	O
!=	O
'|'	O
&&	O
!	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
cp	*(char)
[	O
1	int
]	O
)	O
)	O
)	O
{	O
token	*(struct)
->	O
type	int
=	O
TOKEN_NEG	int
;	O
cp	*(char)
++	O
;	O
}	O
else	O
if	O
(	O
*	O
cp	*(char)
==	O
'+'	O
&&	O
(	O
cp	*(char)
[	O
1	int
]	O
!=	O
'='	O
&&	O
cp	*(char)
[	O
1	int
]	O
!=	O
'|'	O
&&	O
!	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
cp	*(char)
[	O
1	int
]	O
)	O
)	O
)	O
{	O
token	*(struct)
->	O
type	int
=	O
TOKEN_POS	int
;	O
cp	*(char)
++	O
;	O
}	O
else	O
{	O
token	*(struct)
->	O
type	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
cp	*(char)
;	O
cp	*(char)
++	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
cp	*(char)
==	O
'*'	O
&&	O
cp	*(char)
[	O
1	int
]	O
==	O
'/'	O
&&	O
state_is	(enum(int,int,int,int))->(int)
(	O
COMMENT	int
)	O
)	O
{	O
cp	*(char)
+=	O
2	int
;	O
token	*(struct)
->	O
type	int
=	O
TOKEN_END_COMMENT	int
;	O
}	O
else	O
{	O
token	*(struct)
->	O
type	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
cp	*(char)
;	O
if	O
(	O
*	O
cp	*(char)
)	O
cp	*(char)
++	O
;	O
}	O
token	*(struct)
->	O
len	long
=	O
cp	*(char)
-	O
token	*(struct)
->	O
text	*(char)
;	O
return	O
cp	*(char)
;	O
}	O
static	O
const	O
char	O
*	O
token_parse	(*(char),*(struct))->(*(char))
(	O
const	O
char	O
*	O
cp	*(char)
,	O
struct	O
token	*(struct)
*	O
token	*(struct)
)	O
{	O
cp	*(char)
=	O
token_get	(*(char),*(struct))->(*(char))
(	O
cp	*(char)
,	O
token	*(struct)
)	O
;	O
if	O
(	O
in_control	int
&&	O
token	*(struct)
->	O
type	int
!=	O
TOKEN_END_CONTROL	int
)	O
add_control	(*(char),long)->(void)
(	O
token	*(struct)
->	O
text	*(char)
,	O
token	*(struct)
->	O
len	long
)	O
;	O
switch	O
(	O
token	*(struct)
->	O
type	int
)	O
{	O
case	O
TOKEN_BEGIN_CONTROL	int
:	O
if	O
(	O
!	O
in_control	int
)	O
{	O
state_push	(enum(int,int,int,int))->(void)
(	O
CONTROL	int
)	O
;	O
in_control	int
=	O
token	*(struct)
->	O
text	*(char)
[	O
token	*(struct)
->	O
len	long
-	O
1	int
]	O
;	O
control_len	long
=	O
0	int
;	O
control_space	int
=	O
0	int
;	O
}	O
else	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Can't nest control texts."	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
TOKEN_END_CONTROL	int
:	O
if	O
(	O
control_len	long
>	O
0	int
)	O
control_buf	*(char)
[	O
control_len	long
]	O
=	O
'\0'	O
;	O
else	O
{	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Empty control text."	*(char)
)	O
)	O
;	O
token	*(struct)
->	O
type	int
=	O
' '	O
;	O
}	O
if	O
(	O
in_control	int
)	O
{	O
in_control	int
=	O
0	int
;	O
while	O
(	O
!	O
state_is	(enum(int,int,int,int))->(int)
(	O
CONTROL	int
)	O
)	O
{	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Missing closing within control text."	*(char)
)	O
)	O
;	O
state_pop	()->(void)
(	O
)	O
;	O
}	O
state_pop	()->(void)
(	O
)	O
;	O
}	O
else	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"@> not inside control text."	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
TOKEN_BEGIN_EMBED_CODE	int
:	O
state_push	(enum(int,int,int,int))->(void)
(	O
CODE	int
)	O
;	O
break	O
;	O
case	O
TOKEN_END_EMBED_CODE	int
:	O
state_pop	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
TOKEN_BEGIN_COMMENT	int
:	O
state_push	(enum(int,int,int,int))->(void)
(	O
COMMENT	int
)	O
;	O
break	O
;	O
case	O
TOKEN_END_COMMENT	int
:	O
state_pop	()->(void)
(	O
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
cp	*(char)
;	O
}	O
static	O
int	O
token_space_p	(*(struct))->(int)
(	O
struct	O
token	*(struct)
*	O
token	*(struct)
)	O
{	O
return	O
(	O
token	*(struct)
->	O
type	int
>=	O
CHAR_MIN	O
&&	O
token	*(struct)
->	O
type	int
<=	O
CHAR_MAX	O
&&	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
token	*(struct)
->	O
type	int
)	O
)	O
;	O
}	O
static	O
void	O
weave_pass_one	()->(void)
(	O
void	O
)	O
{	O
size_t	long
line_size	*(long)
=	O
0	int
;	O
char	O
*	O
line	int
=	O
NULL	O
;	O
section_init	(*(struct(array(short))))->(void)
(	O
&	O
cur_section	struct(array(short))
)	O
;	O
state_init	()->(void)
(	O
)	O
;	O
state_push	(enum(int,int,int,int))->(void)
(	O
TEXT	int
)	O
;	O
input_start_pass	()->(void)
(	O
)	O
;	O
while	O
(	O
input_read_line	(*(*(char)),*(long))->(int)
(	O
&	O
line	int
,	O
&	O
line_size	*(long)
)	O
)	O
{	O
char	O
cmd	*(char)
[	O
CMD_LEN_MAX	int
+	O
1	int
]	O
;	O
if	O
(	O
parse_at_cmd	(*(char),array(char))->(int)
(	O
line	int
,	O
cmd	*(char)
)	O
)	O
{	O
section_recognize	(*(char))->(int)
(	O
cmd	*(char)
)	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"references"	*(char)
)	O
)	O
enforce_references_ordering	()->(void)
(	O
)	O
;	O
if	O
(	O
cmd	*(char)
[	O
0	int
]	O
==	O
'\0'	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"node"	*(char)
)	O
)	O
{	O
segment_select	(*(struct))->(void)
(	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"bye"	*(char)
)	O
)	O
break	O
;	O
else	O
if	O
(	O
!	O
exercise_process	(*(char),*(char),int)->(int)
(	O
cmd	*(char)
,	O
line	int
,	O
1	int
)	O
&&	O
!	O
catalogue_process_one	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
line	int
)	O
)	O
{	O
int	O
operation	enum(int,int,int)
;	O
char	O
*	O
control_text	*(char)
=	O
segment_definition_line	(*(char),*(int))->(*(char))
(	O
line	int
,	O
&	O
operation	enum(int,int,int)
)	O
;	O
if	O
(	O
control_text	*(char)
!=	O
NULL	O
)	O
{	O
segment_select	(*(struct))->(void)
(	O
segment_find	(*(char),int)->(*(struct))
(	O
control_text	*(char)
,	O
1	int
)	O
)	O
;	O
piece_create	(*(struct),int)->(void)
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
,	O
operation	enum(int,int,int)
)	O
;	O
free	(*(void))->(void)
(	O
control_text	*(char)
)	O
;	O
continue	O
;	O
}	O
}	O
}	O
if	O
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
cp	*(char)
=	O
line	int
;	O
int	O
indentation	int
=	O
indent_amount	(*(char),*(*(char)))->(int)
(	O
line	int
,	O
&	O
cp	*(char)
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
token	*(struct)
token	*(struct)
;	O
cp	*(char)
=	O
token_parse	(*(char),*(struct))->(*(char))
(	O
cp	*(char)
,	O
&	O
token	*(struct)
)	O
;	O
if	O
(	O
token	*(struct)
.	O
type	int
==	O
0	int
)	O
break	O
;	O
else	O
if	O
(	O
token	*(struct)
.	O
type	int
==	O
TOKEN_END_CONTROL	int
)	O
piece_references	(*(struct),int)->(void)
(	O
segment_find	(*(char),int)->(*(struct))
(	O
control_buf	*(char)
,	O
1	int
)	O
,	O
indentation	int
)	O
;	O
}	O
}	O
}	O
input_end_pass	()->(void)
(	O
)	O
;	O
state_pop	()->(void)
(	O
)	O
;	O
free	(*(void))->(void)
(	O
line	int
)	O
;	O
}	O
static	O
char	O
*	O
segment_definition_line	(*(char),*(int))->(*(char))
(	O
char	O
*	O
line	int
,	O
int	O
*	O
operation	enum(int,int,int)
)	O
{	O
char	O
*	O
control_text	*(char)
;	O
char	O
*	O
cp	*(char)
,	O
*	O
ep	*(*(char))
;	O
control_text	*(char)
=	O
NULL	O
;	O
if	O
(	O
*	O
line	int
==	O
'@'	O
&&	O
(	O
line	int
[	O
1	int
]	O
==	O
'<'	O
||	O
line	int
[	O
1	int
]	O
==	O
'('	O
)	O
)	O
{	O
if	O
(	O
in_control	int
)	O
{	O
error	(int,*(char))->(void)
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"Nested control texts."	*(char)
)	O
)	O
;	O
in_control	int
=	O
0	int
;	O
}	O
control_text	*(char)
=	O
parse_control_text	(*(char),*(*(char)))->(*(char))
(	O
line	int
+	O
2	int
,	O
&	O
cp	*(char)
)	O
;	O
ep	*(*(char))
=	O
strchr	(*(char),int)->(*(char))
(	O
cp	*(char)
,	O
'\0'	O
)	O
;	O
trim_whitespace	(*(*(char)),*(*(char)))->(void)
(	O
&	O
cp	*(char)
,	O
&	O
ep	*(*(char))
)	O
;	O
if	O
(	O
ep	*(*(char))
-	O
cp	*(char)
==	O
1	int
&&	O
cp	*(char)
[	O
0	int
]	O
==	O
'='	O
)	O
{	O
if	O
(	O
operation	enum(int,int,int)
!=	O
NULL	O
)	O
*	O
operation	enum(int,int,int)
=	O
'='	O
;	O
}	O
else	O
if	O
(	O
ep	*(*(char))
-	O
cp	*(char)
==	O
2	int
&&	O
cp	*(char)
[	O
0	int
]	O
==	O
'+'	O
&&	O
cp	*(char)
[	O
1	int
]	O
==	O
'='	O
)	O
{	O
if	O
(	O
operation	enum(int,int,int)
!=	O
NULL	O
)	O
*	O
operation	enum(int,int,int)
=	O
'+'	O
;	O
}	O
else	O
{	O
free	(*(void))->(void)
(	O
control_text	*(char)
)	O
;	O
control_text	*(char)
=	O
NULL	O
;	O
}	O
}	O
return	O
control_text	*(char)
;	O
}	O
static	O
void	O
enforce_references_ordering	()->(void)
(	O
void	O
)	O
{	O
static	O
struct	O
section	struct(array(short))
last_error	struct(array(short))
;	O
if	O
(	O
cur_section	struct(array(short))
.	O
level	array(short)
[	O
LEVEL_EXERCISE	int
]	O
>	O
0	int
&&	O
section_differs	(*(struct(array(short))),*(struct(array(short))),enum(int,int,int,int,int,int))->(int)
(	O
&	O
cur_section	struct(array(short))
,	O
&	O
last_error	struct(array(short))
,	O
LEVEL_SUBSUBSECTION	int
)	O
)	O
{	O
last_error	struct(array(short))
=	O
cur_section	struct(array(short))
;	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"References should precede exercises."	*(char)
)	O
)	O
;	O
}	O
}	O
static	O
int	O
blank	int
;	O
static	O
int	O
parens	int
;	O
static	O
int	O
paste	int
;	O
static	O
void	O
weave_pass_two	()->(void)
(	O
void	O
)	O
{	O
size_t	long
line_size	*(long)
=	O
0	int
;	O
char	O
*	O
line	int
=	O
NULL	O
;	O
int	O
print_flags	int
=	O
0	int
;	O
state_init	()->(void)
(	O
)	O
;	O
state_push	(enum(int,int,int,int))->(void)
(	O
TEXT	int
)	O
;	O
section_init	(*(struct(array(short))))->(void)
(	O
&	O
cur_section	struct(array(short))
)	O
;	O
input_start_pass	()->(void)
(	O
)	O
;	O
while	O
(	O
input_read_line	(*(*(char)),*(long))->(int)
(	O
&	O
line	int
,	O
&	O
line_size	*(long)
)	O
)	O
{	O
char	O
cmd	*(char)
[	O
CMD_LEN_MAX	int
+	O
1	int
]	O
;	O
if	O
(	O
!	O
parse_at_cmd	(*(char),array(char))->(int)
(	O
line	int
,	O
cmd	*(char)
)	O
)	O
{	O
print_flags	int
=	O
print_line	(*(char),int)->(int)
(	O
line	int
,	O
print_flags	int
)	O
;	O
continue	O
;	O
}	O
section_recognize	(*(char))->(int)
(	O
cmd	*(char)
)	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"node"	*(char)
)	O
)	O
{	O
transition	(enum(int,int,int,int))->(void)
(	O
TEXT	int
)	O
;	O
print_flags	int
=	O
print_line	(*(char),int)->(int)
(	O
line	int
,	O
print_flags	int
)	O
;	O
}	O
else	O
if	O
(	O
cmd	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
transition	(enum(int,int,int,int))->(void)
(	O
TEXT	int
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"p"	*(char)
)	O
)	O
{	O
transition	(enum(int,int,int,int))->(void)
(	O
CODE	int
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
cmd	*(char)
[	O
0	int
]	O
==	O
'<'	O
||	O
cmd	*(char)
[	O
0	int
]	O
==	O
'('	O
)	O
{	O
char	O
*	O
control_text	*(char)
;	O
int	O
operation	enum(int,int,int)
;	O
control_text	*(char)
=	O
segment_definition_line	(*(char),*(int))->(*(char))
(	O
line	int
,	O
&	O
operation	enum(int,int,int)
)	O
;	O
if	O
(	O
control_text	*(char)
!=	O
NULL	O
)	O
{	O
print_piece_header	(*(char),int,int)->(void)
(	O
control_text	*(char)
,	O
cmd	*(char)
[	O
0	int
]	O
,	O
operation	enum(int,int,int)
)	O
;	O
free	(*(void))->(void)
(	O
control_text	*(char)
)	O
;	O
}	O
else	O
print_flags	int
=	O
print_line	(*(char),int)->(int)
(	O
line	int
,	O
print_flags	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"setheaderfile"	*(char)
)	O
)	O
open_header_file	(*(char))->(void)
(	O
line	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"deftypedef"	*(char)
)	O
)	O
{	O
char	O
*	O
bp	*(*(char))
,	O
*	O
ep	*(*(char))
;	O
if	O
(	O
!	O
find_argument	(*(char),*(*(char)),*(*(char)))->(int)
(	O
line	int
,	O
&	O
bp	*(*(char))
,	O
&	O
ep	*(*(char))
)	O
)	O
continue	O
;	O
*	O
ep	*(*(char))
=	O
'\0'	O
;	O
symbol_find	(*(char),long,int)->(*(struct))
(	O
bp	*(*(char))
,	O
strlen	(*(char))->(long)
(	O
bp	*(*(char))
)	O
,	O
1	int
)	O
->	O
is_typedef	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
exercise_process	(*(char),*(char),int)->(int)
(	O
cmd	*(char)
,	O
line	int
,	O
2	int
)	O
&&	O
!	O
catalogue_process_two	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
line	int
)	O
)	O
{	O
print_flags	int
=	O
print_line	(*(char),int)->(int)
(	O
line	int
,	O
print_flags	int
)	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"bye"	*(char)
)	O
)	O
break	O
;	O
}	O
}	O
input_end_pass	()->(void)
(	O
)	O
;	O
state_pop	()->(void)
(	O
)	O
;	O
exercise_close_answer_file	()->(void)
(	O
)	O
;	O
close_header_file	()->(void)
(	O
)	O
;	O
if	O
(	O
print_catalogues	int
)	O
catalogue_print_unused	()->(void)
(	O
)	O
;	O
free	(*(void))->(void)
(	O
line	int
)	O
;	O
}	O
static	O
void	O
transition	(enum(int,int,int,int))->(void)
(	O
enum	O
state	enum(int,int,int,int)
new_state	enum(int,int,int,int)
)	O
{	O
assert	O
(	O
state_cnt	()->(int)
(	O
)	O
>	O
0	int
)	O
;	O
if	O
(	O
state_cnt	()->(int)
(	O
)	O
>	O
1	int
)	O
{	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Nested state transition."	*(char)
)	O
)	O
;	O
while	O
(	O
state_cnt	()->(int)
(	O
)	O
>	O
1	int
)	O
state_pop	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
warn_nonzero_indent	int
&&	O
indent_adjust	int
!=	O
0	int
)	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Nonzero indent adjustment at state transition."	*(char)
)	O
)	O
;	O
if	O
(	O
state_is	(enum(int,int,int,int))->(int)
(	O
new_state	enum(int,int,int,int)
)	O
)	O
return	O
;	O
if	O
(	O
state_is	(enum(int,int,int,int))->(int)
(	O
TEXT	int
)	O
&&	O
new_state	enum(int,int,int,int)
==	O
CODE	int
)	O
{	O
emits	O
(	O
"@begincode{}"	*(char)
)	O
;	O
parens	int
=	O
0	int
;	O
blank	int
=	O
0	int
;	O
declaration_engine	(*(char),int)->(void)
(	O
NULL	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
assert	O
(	O
state_is	(enum(int,int,int,int))->(int)
(	O
CODE	int
)	O
&&	O
new_state	enum(int,int,int,int)
==	O
TEXT	int
)	O
;	O
emits	O
(	O
"@endcode{}"	*(char)
)	O
;	O
piece_print_trailer	()->(void)
(	O
)	O
;	O
emits	O
(	O
"\n\n"	*(char)
)	O
;	O
segment_select	(*(struct))->(void)
(	O
NULL	O
)	O
;	O
}	O
state_pop	()->(void)
(	O
)	O
;	O
state_push	(enum(int,int,int,int))->(void)
(	O
new_state	enum(int,int,int,int)
)	O
;	O
}	O
static	O
int	O
indent_amount	(*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
cp	*(char)
,	O
const	O
char	O
*	O
*	O
const	O
end	*(*(char))
)	O
{	O
int	O
cnt	int
=	O
0	int
;	O
while	O
(	O
*	O
cp	*(char)
==	O
' '	O
||	O
*	O
cp	*(char)
==	O
'\t'	O
)	O
{	O
if	O
(	O
*	O
cp	*(char)
==	O
'\t'	O
)	O
cnt	int
=	O
(	O
cnt	int
+	O
8	int
)	O
/	O
8	int
*	O
8	int
;	O
else	O
cnt	int
++	O
;	O
cp	*(char)
++	O
;	O
}	O
if	O
(	O
end	*(*(char))
!=	O
NULL	O
)	O
*	O
end	*(*(char))
=	O
(	O
char	O
*	O
)	O
cp	*(char)
;	O
return	O
cnt	int
;	O
}	O
static	O
int	O
print_line	(*(char),int)->(int)
(	O
const	O
char	O
*	O
cp	*(char)
,	O
int	O
flags	int
)	O
{	O
if	O
(	O
state_bottom	(enum(int,int,int,int))->(int)
(	O
CODE	int
)	O
)	O
{	O
int	O
i	int
;	O
int	O
indent	*(int)
=	O
indent_amount	(*(char),*(*(char)))->(int)
(	O
cp	*(char)
,	O
&	O
cp	*(char)
)	O
;	O
if	O
(	O
state_is	(enum(int,int,int,int))->(int)
(	O
CODE	int
)	O
&&	O
state_cnt	()->(int)
(	O
)	O
==	O
1	int
)	O
declaration_engine	(*(char),int)->(void)
(	O
cp	*(char)
,	O
indent	*(int)
)	O
;	O
if	O
(	O
empty_string	(*(char))->(int)
(	O
cp	*(char)
)	O
)	O
{	O
blank	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
blank	int
)	O
{	O
emits	O
(	O
"@blankline\n"	*(char)
)	O
;	O
blank	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
paste	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
indent	*(int)
;	O
i	int
++	O
)	O
emitc	O
(	O
' '	O
)	O
;	O
emits	O
(	O
"@tabalign{}"	*(char)
)	O
;	O
if	O
(	O
parens	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
parens	int
;	O
i	int
++	O
)	O
emits	O
(	O
"@wtab{}"	*(char)
)	O
;	O
else	O
if	O
(	O
indent	*(int)
!=	O
0	int
)	O
{	O
if	O
(	O
indent	*(int)
+	O
indent_adjust	int
<	O
0	int
)	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Negative indentation %d."	*(char)
)	O
,	O
indent	*(int)
+	O
indent_adjust	int
)	O
;	O
else	O
emitf	(*(char))->(void)
(	O
"@IND{%dem}"	*(char)
,	O
indent	*(int)
+	O
indent_adjust	int
)	O
;	O
}	O
}	O
else	O
{	O
emits	O
(	O
"@tcr{"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
indent	*(int)
;	O
i	int
++	O
)	O
emits	O
(	O
"@w{ }"	*(char)
)	O
;	O
emitc	O
(	O
'}'	O
)	O
;	O
paste	int
=	O
0	int
;	O
}	O
}	O
return	O
print	(*(char),int)->(int)
(	O
cp	*(char)
,	O
flags	int
)	O
;	O
}	O
static	O
int	O
print	(*(char),int)->(int)
(	O
const	O
char	O
*	O
cp	*(char)
,	O
int	O
flags	int
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
token	*(struct)
token	*(struct)
;	O
cp	*(char)
=	O
token_parse	(*(char),*(struct))->(*(char))
(	O
cp	*(char)
,	O
&	O
token	*(struct)
)	O
;	O
switch	O
(	O
token	*(struct)
.	O
type	int
)	O
{	O
case	O
TOKEN_BEGIN_CONTROL	int
:	O
emits	O
(	O
"@refcode{"	*(char)
)	O
;	O
if	O
(	O
in_control	int
==	O
'<'	O
)	O
emits	O
(	O
"@asis{"	*(char)
)	O
;	O
else	O
emits	O
(	O
"@t{"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_END_CONTROL	int
:	O
emits	O
(	O
"},"	*(char)
)	O
;	O
print_anchor_name	(*(char),int)->(void)
(	O
control_buf	*(char)
,	O
0	int
)	O
;	O
emitc	O
(	O
','	O
)	O
;	O
segment_print_number	(*(struct))->(void)
(	O
segment_find	(*(char),int)->(*(struct))
(	O
control_buf	*(char)
,	O
0	int
)	O
)	O
;	O
emitc	O
(	O
'}'	O
)	O
;	O
break	O
;	O
case	O
TOKEN_BEGIN_EMBED_CODE	int
:	O
case	O
TOKEN_END_EMBED_CODE	int
:	O
flags	int
=	O
0	int
;	O
break	O
;	O
case	O
TOKEN_REPLACE	int
:	O
emits	O
(	O
"@result{}"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_INC_INDENT	int
:	O
indent_adjust	int
+=	O
2	int
;	O
break	O
;	O
case	O
TOKEN_DEC_INDENT	int
:	O
indent_adjust	int
-=	O
2	int
;	O
break	O
;	O
case	O
TOKEN_AT	int
:	O
emits	O
(	O
"@@"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_SEMICOLON	int
:	O
emitc	O
(	O
';'	O
)	O
;	O
break	O
;	O
case	O
TOKEN_PIPE	int
:	O
emits	O
(	O
"@math{|}"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_COND_NEWLINE	int
:	O
paste	int
=	O
1	int
;	O
break	O
;	O
case	O
TOKEN_BEGIN_COMMENT	int
:	O
emits	O
(	O
"/@value{AST}"	*(char)
)	O
;	O
if	O
(	O
state_bottom	(enum(int,int,int,int))->(int)
(	O
CODE	int
)	O
)	O
{	O
for	O
(	O
;	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	*(char)
)	O
;	O
cp	*(char)
++	O
)	O
emitc	O
(	O
*	O
cp	*(char)
)	O
;	O
emits	O
(	O
"@cleartabs{}@wtab{}"	*(char)
)	O
;	O
parens	int
++	O
;	O
}	O
break	O
;	O
case	O
TOKEN_END_COMMENT	int
:	O
if	O
(	O
state_bottom	(enum(int,int,int,int))->(int)
(	O
CODE	int
)	O
)	O
parens	int
--	O
;	O
emits	O
(	O
"@value{AST}/"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_PREPROCESSOR	int
:	O
{	O
const	O
char	O
*	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
;	O
emitc	O
(	O
'#'	O
)	O
;	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
=	O
token_get	(*(char),*(struct))->(*(char))
(	O
cp	*(char)
,	O
&	O
token	*(struct)
)	O
;	O
while	O
(	O
token_space_p	(*(struct))->(int)
(	O
&	O
token	*(struct)
)	O
)	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
=	O
token_get	(*(char),*(struct))->(*(char))
(	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
,	O
&	O
token	*(struct)
)	O
;	O
if	O
(	O
token	*(struct)
.	O
type	int
!=	O
TOKEN_ID	int
)	O
continue	O
;	O
cp	*(char)
=	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
;	O
emitf	(*(char))->(void)
(	O
"@b{%.*s}"	*(char)
,	O
(	O
int	O
)	O
token	*(struct)
.	O
len	long
,	O
token	*(struct)
.	O
text	*(char)
)	O
;	O
if	O
(	O
token	*(struct)
.	O
len	long
==	O
6	int
&&	O
!	O
memcmp	(*(void),*(void),long)->(int)
(	O
token	*(struct)
.	O
text	*(char)
,	O
"define"	*(char)
,	O
6	int
)	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
=	O
token_get	(*(char),*(struct))->(*(char))
(	O
cp	*(char)
,	O
&	O
token	*(struct)
)	O
;	O
if	O
(	O
!	O
token_space_p	(*(struct))->(int)
(	O
&	O
token	*(struct)
)	O
)	O
break	O
;	O
emitc	O
(	O
token	*(struct)
.	O
type	int
)	O
;	O
cp	*(char)
=	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
;	O
}	O
if	O
(	O
token	*(struct)
.	O
type	int
==	O
TOKEN_ID	int
)	O
{	O
emits	O
(	O
"@cindex "	*(char)
)	O
;	O
print_identifier	(*(char),int)->(*(struct))
(	O
token	*(struct)
.	O
text	*(char)
,	O
token	*(struct)
.	O
len	long
)	O
;	O
emits	O
(	O
" macro@c\n"	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
token	*(struct)
.	O
len	long
==	O
7	int
&&	O
!	O
memcmp	(*(void),*(void),long)->(int)
(	O
token	*(struct)
.	O
text	*(char)
,	O
"include"	*(char)
,	O
7	int
)	O
)	O
{	O
int	O
quote	int
=	O
0	int
;	O
for	O
(	O
;	O
*	O
cp	*(char)
&&	O
*	O
cp	*(char)
!=	O
'\n'	O
&&	O
*	O
cp	*(char)
!=	O
'|'	O
;	O
cp	*(char)
++	O
)	O
switch	O
(	O
*	O
cp	*(char)
)	O
{	O
case	O
'<'	O
:	O
emits	O
(	O
"@value{LANG}"	*(char)
)	O
;	O
break	O
;	O
case	O
'>'	O
:	O
emits	O
(	O
"@value{RANG}"	*(char)
)	O
;	O
break	O
;	O
case	O
'"'	O
:	O
if	O
(	O
quote	int
++	O
)	O
emits	O
(	O
"@value{RQUOTE}"	*(char)
)	O
;	O
else	O
emits	O
(	O
"@value{LQUOTE}"	*(char)
)	O
;	O
break	O
;	O
case	O
'{'	O
:	O
case	O
'}'	O
:	O
emitf	(*(char))->(void)
(	O
"@math{@%c}"	*(char)
,	O
*	O
cp	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
emitc	O
(	O
*	O
cp	*(char)
)	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
TOKEN_PSTRUCT_ELEM	int
:	O
emits	O
(	O
"@value{RARR}"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_EQ	int
:	O
emits	O
(	O
"@value{EQ}"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_NE	int
:	O
emits	O
(	O
"@value{NE}"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_GE	int
:	O
emits	O
(	O
"@value{GE}"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_LE	int
:	O
emits	O
(	O
"@value{LE}"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_AND	int
:	O
emits	O
(	O
"@value{AND}"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_OR	int
:	O
emits	O
(	O
"@value{OR}"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_TIMES	int
:	O
emits	O
(	O
"@value{TIMES}"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_PLUSPLUS	int
:	O
emits	O
(	O
"@math{++}"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_MINUSMINUS	int
:	O
emits	O
(	O
"@math{--}"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_NEG	int
:	O
emits	O
(	O
"@unaryminus{}"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_POS	int
:	O
emits	O
(	O
"@unaryplus{}"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_QUOTED_STRING	int
:	O
{	O
const	O
char	O
*	O
cp	*(char)
;	O
emits	O
(	O
"@t{"	*(char)
)	O
;	O
for	O
(	O
cp	*(char)
=	O
token	*(struct)
.	O
text	*(char)
;	O
cp	*(char)
<	O
token	*(struct)
.	O
text	*(char)
+	O
token	*(struct)
.	O
len	long
;	O
cp	*(char)
++	O
)	O
{	O
if	O
(	O
*	O
cp	*(char)
!=	O
' '	O
)	O
{	O
if	O
(	O
*	O
cp	*(char)
==	O
'@'	O
||	O
*	O
cp	*(char)
==	O
'{'	O
||	O
*	O
cp	*(char)
==	O
'}'	O
)	O
emitc	O
(	O
'@'	O
)	O
;	O
emitc	O
(	O
*	O
cp	*(char)
)	O
;	O
}	O
else	O
emits	O
(	O
"@value{SP}"	*(char)
)	O
;	O
}	O
emitc	O
(	O
'}'	O
)	O
;	O
}	O
break	O
;	O
case	O
TOKEN_HEX_INT	int
:	O
emitf	(*(char))->(void)
(	O
"@t{%.*s}"	*(char)
,	O
(	O
int	O
)	O
token	*(struct)
.	O
len	long
,	O
token	*(struct)
.	O
text	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_OCT_INT	int
:	O
emitf	(*(char))->(void)
(	O
"@i{%.*s}"	*(char)
,	O
(	O
int	O
)	O
token	*(struct)
.	O
len	long
,	O
token	*(struct)
.	O
text	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_NUMBER	int
:	O
emitb	O
(	O
token	*(struct)
.	O
text	*(char)
,	O
token	*(struct)
.	O
len	long
)	O
;	O
break	O
;	O
case	O
TOKEN_SCIENTIFIC	int
:	O
{	O
const	O
char	O
*	O
p	*(char)
=	O
memchr	(*(void),int,long)->(*(void))
(	O
token	*(struct)
.	O
text	*(char)
,	O
'e'	O
,	O
token	*(struct)
.	O
len	long
)	O
;	O
assert	O
(	O
p	*(char)
!=	O
NULL	O
)	O
;	O
emitf	(*(char))->(void)
(	O
"%.*s@exponent{%.*s}"	*(char)
,	O
(	O
int	O
)	O
(	O
p	*(char)
-	O
token	*(struct)
.	O
text	*(char)
)	O
,	O
token	*(struct)
.	O
text	*(char)
,	O
(	O
int	O
)	O
(	O
(	O
token	*(struct)
.	O
text	*(char)
+	O
token	*(struct)
.	O
len	long
)	O
-	O
(	O
p	*(char)
+	O
1	int
)	O
)	O
,	O
p	*(char)
+	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
TOKEN_ID	int
:	O
if	O
(	O
state_is	(enum(int,int,int,int))->(int)
(	O
CODE	int
)	O
)	O
{	O
if	O
(	O
flags	int
)	O
{	O
emitf	(*(char))->(void)
(	O
STRUCT_TAG_STYLE	*(char)
"{%.*s}"	*(char)
,	O
(	O
int	O
)	O
token	*(struct)
.	O
len	long
,	O
token	*(struct)
.	O
text	*(char)
)	O
;	O
flags	int
=	O
0	int
;	O
}	O
else	O
{	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
=	O
print_identifier	(*(char),int)->(*(struct))
(	O
token	*(struct)
.	O
text	*(char)
,	O
token	*(struct)
.	O
len	long
)	O
;	O
if	O
(	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
&&	O
(	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
->	O
kw_idx	int
==	O
KW_ENUM	int
||	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
->	O
kw_idx	int
==	O
KW_STRUCT	int
||	O
sym	*(*(struct(*(struct(*`,*`,*`,int,int,*`)),*(char),*(struct),int,int,*(struct))))
->	O
kw_idx	int
==	O
KW_UNION	int
)	O
)	O
flags	int
=	O
1	int
;	O
}	O
}	O
else	O
emitb	O
(	O
token	*(struct)
.	O
text	*(char)
,	O
token	*(struct)
.	O
len	long
)	O
;	O
break	O
;	O
case	O
0	int
:	O
return	O
flags	int
;	O
default	O
:	O
assert	O
(	O
token	*(struct)
.	O
type	int
>	O
0	int
&&	O
token	*(struct)
.	O
type	int
<=	O
UCHAR_MAX	O
)	O
;	O
if	O
(	O
state_is	(enum(int,int,int,int))->(int)
(	O
CODE	int
)	O
)	O
{	O
switch	O
(	O
token	*(struct)
.	O
type	int
)	O
{	O
case	O
'{'	O
:	O
emits	O
(	O
"@math{@{}"	*(char)
)	O
;	O
flags	int
=	O
0	int
;	O
break	O
;	O
case	O
'}'	O
:	O
emits	O
(	O
"@math{@}}"	*(char)
)	O
;	O
break	O
;	O
case	O
'('	O
:	O
case	O
'['	O
:	O
emitc	O
(	O
token	*(struct)
.	O
type	int
)	O
;	O
if	O
(	O
state_cnt	()->(int)
(	O
)	O
==	O
1	int
)	O
emits	O
(	O
"@cleartabs{}@wtab{}"	*(char)
)	O
;	O
parens	int
++	O
;	O
break	O
;	O
case	O
')'	O
:	O
case	O
']'	O
:	O
emitc	O
(	O
token	*(struct)
.	O
type	int
)	O
;	O
parens	int
--	O
;	O
break	O
;	O
case	O
'*'	O
:	O
emits	O
(	O
"@value{AST}"	*(char)
)	O
;	O
break	O
;	O
case	O
'<'	O
:	O
case	O
'>'	O
:	O
case	O
'+'	O
:	O
case	O
'-'	O
:	O
emitf	(*(char))->(void)
(	O
"@math{%c}"	*(char)
,	O
token	*(struct)
.	O
type	int
)	O
;	O
break	O
;	O
case	O
'|'	O
:	O
emits	O
(	O
"@math{|}"	*(char)
)	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
if	O
(	O
state_cnt	()->(int)
(	O
)	O
==	O
1	int
||	O
state_was	(enum(int,int,int,int))->(int)
(	O
COMMENT	int
)	O
)	O
emits	O
(	O
"@cr\n"	*(char)
)	O
;	O
else	O
emitc	O
(	O
' '	O
)	O
;	O
break	O
;	O
default	O
:	O
emitc	O
(	O
token	*(struct)
.	O
type	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
token	*(struct)
.	O
type	int
==	O
'\n'	O
&&	O
state_is	(enum(int,int,int,int))->(int)
(	O
COMMENT	int
)	O
&&	O
state_bottom	(enum(int,int,int,int))->(int)
(	O
CODE	int
)	O
)	O
emits	O
(	O
"@cr\n"	*(char)
)	O
;	O
else	O
if	O
(	O
state_is	(enum(int,int,int,int))->(int)
(	O
CONTROL	int
)	O
&&	O
token	*(struct)
.	O
type	int
==	O
','	O
)	O
emits	O
(	O
"@value{COMMA}"	*(char)
)	O
;	O
else	O
emitc	O
(	O
token	*(struct)
.	O
type	int
)	O
;	O
}	O
}	O
}	O
struct	O
tangle_subst	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
{	O
struct	O
tangle_subst	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
;	O
char	O
*	O
src	*(char)
;	O
char	O
*	O
dst	*(char)
;	O
}	O
;	O
struct	O
tangle_subst	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
ts_push	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(char),long,*(char),long)->(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))
(	O
struct	O
tangle_subst	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
tos	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
const	O
char	O
*	O
src	*(char)
,	O
size_t	long
src_len	long
,	O
const	O
char	O
*	O
dst	*(char)
,	O
size_t	long
dst_len	long
)	O
{	O
struct	O
tangle_subst	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
new	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
new	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
new	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
src	*(char)
=	O
xstrndup	(*(char),long)->(*(char))
(	O
src	*(char)
,	O
src_len	long
)	O
;	O
new	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
dst	*(char)
=	O
xstrndup	(*(char),long)->(*(char))
(	O
dst	*(char)
,	O
dst_len	long
)	O
;	O
new	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
=	O
tos	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
return	O
new	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
}	O
static	O
void	O
ts_free	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(void)
(	O
struct	O
tangle_subst	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
s	*(struct)
)	O
{	O
free	(*(void))->(void)
(	O
s	*(struct)
->	O
src	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
s	*(struct)
->	O
dst	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
s	*(struct)
)	O
;	O
}	O
struct	O
tangle_subst	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
ts_pop	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))
(	O
struct	O
tangle_subst	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
tos	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
{	O
struct	O
tangle_subst	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
=	O
tos	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
;	O
ts_free	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(void)
(	O
tos	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
return	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
;	O
}	O
static	O
void	O
flush_whitespace	(*(int),*(struct(*(struct(*`,*`,struct`)),*(char),struct(*(char),int))),*(struct(*(char),int)))->(void)
(	O
int	O
*	O
indent	*(int)
,	O
struct	O
line	int
*	O
line	int
,	O
struct	O
loc	struct(*(char),int)
*	O
loc	struct(*(char),int)
)	O
{	O
if	O
(	O
(	O
loc	struct(*(char),int)
->	O
ln	int
!=	O
line	int
->	O
loc	struct(*(char),int)
.	O
ln	int
||	O
loc	struct(*(char),int)
->	O
fn	*(char)
!=	O
line	int
->	O
loc	struct(*(char),int)
.	O
fn	*(char)
)	O
&&	O
opt_line	int
)	O
{	O
if	O
(	O
loc	struct(*(char),int)
->	O
fn	*(char)
!=	O
line	int
->	O
loc	struct(*(char),int)
.	O
fn	*(char)
)	O
emitf	(*(char))->(void)
(	O
"#line %d \"%s\"\n"	*(char)
,	O
line	int
->	O
loc	struct(*(char),int)
.	O
ln	int
,	O
line	int
->	O
loc	struct(*(char),int)
.	O
fn	*(char)
)	O
;	O
else	O
emitf	(*(char))->(void)
(	O
"#line %d\n"	*(char)
,	O
line	int
->	O
loc	struct(*(char),int)
.	O
ln	int
)	O
;	O
*	O
loc	struct(*(char),int)
=	O
line	int
->	O
loc	struct(*(char),int)
;	O
}	O
for	O
(	O
;	O
*	O
indent	*(int)
>	O
0	int
;	O
(	O
*	O
indent	*(int)
)	O
--	O
)	O
emitc	O
(	O
' '	O
)	O
;	O
}	O
static	O
int	O
mem_casecmp	(*(char),*(char),long)->(int)
(	O
const	O
char	O
*	O
a	*(struct(int,*(char)))
,	O
const	O
char	O
*	O
b	*(struct(int,*(char)))
,	O
size_t	long
len	long
)	O
{	O
for	O
(	O
;	O
len	long
;	O
a	*(struct(int,*(char)))
++	O
,	O
b	*(struct(int,*(char)))
++	O
,	O
len	long
--	O
)	O
if	O
(	O
tolower	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
a	*(struct(int,*(char)))
)	O
!=	O
tolower	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
b	*(struct(int,*(char)))
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
no_upper	(*(char),long)->(int)
(	O
const	O
char	O
*	O
s	*(struct)
,	O
size_t	long
len	long
)	O
{	O
while	O
(	O
len	long
--	O
)	O
if	O
(	O
isupper	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	*(struct)
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
no_lower	(*(char),long)->(int)
(	O
const	O
char	O
*	O
s	*(struct)
,	O
size_t	long
len	long
)	O
{	O
while	O
(	O
len	long
--	O
)	O
if	O
(	O
islower	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	*(struct)
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
ts_emit	(*(char),long,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(void)
(	O
const	O
char	O
*	O
text	*(char)
,	O
size_t	long
len	long
,	O
struct	O
tangle_subst	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
s	*(struct)
)	O
{	O
char	O
*	O
cur_text	*(char)
=	O
(	O
char	O
*	O
)	O
text	*(char)
;	O
size_t	long
cur_len	long
=	O
len	long
;	O
for	O
(	O
;	O
s	*(struct)
!=	O
NULL	O
;	O
s	*(struct)
=	O
s	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
)	O
{	O
const	O
size_t	long
src_len	long
=	O
strlen	(*(char))->(long)
(	O
s	*(struct)
->	O
src	*(char)
)	O
;	O
const	O
size_t	long
dst_len	long
=	O
strlen	(*(char))->(long)
(	O
s	*(struct)
->	O
dst	*(char)
)	O
;	O
char	O
*	O
next_text	*(char)
,	O
*	O
d	*(char)
;	O
const	O
char	O
*	O
p	*(char)
;	O
size_t	long
next_len	long
;	O
size_t	long
n_upper	long
;	O
if	O
(	O
cur_len	long
<	O
src_len	long
||	O
mem_casecmp	(*(char),*(char),long)->(int)
(	O
cur_text	*(char)
,	O
s	*(struct)
->	O
src	*(char)
,	O
src_len	long
)	O
)	O
continue	O
;	O
next_len	long
=	O
dst_len	long
+	O
(	O
cur_len	long
-	O
src_len	long
)	O
;	O
d	*(char)
=	O
next_text	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
next_len	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
no_upper	(*(char),long)->(int)
(	O
s	*(struct)
->	O
src	*(char)
,	O
src_len	long
)	O
||	O
!	O
no_upper	(*(char),long)->(int)
(	O
s	*(struct)
->	O
dst	*(char)
,	O
dst_len	long
)	O
||	O
no_upper	(*(char),long)->(int)
(	O
cur_text	*(char)
,	O
cur_len	long
)	O
)	O
n_upper	long
=	O
0	int
;	O
else	O
if	O
(	O
no_lower	(*(char),long)->(int)
(	O
cur_text	*(char)
,	O
cur_len	long
)	O
)	O
n_upper	long
=	O
dst_len	long
;	O
else	O
n_upper	long
=	O
1	int
;	O
for	O
(	O
p	*(char)
=	O
s	*(struct)
->	O
dst	*(char)
;	O
*	O
p	*(char)
;	O
p	*(char)
++	O
)	O
if	O
(	O
n_upper	long
>	O
0	int
)	O
{	O
*	O
d	*(char)
++	O
=	O
toupper	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	*(char)
)	O
;	O
n_upper	long
--	O
;	O
}	O
else	O
*	O
d	*(char)
++	O
=	O
*	O
p	*(char)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
d	*(char)
,	O
cur_text	*(char)
+	O
src_len	long
,	O
cur_len	long
-	O
src_len	long
)	O
;	O
d	*(char)
[	O
cur_len	long
-	O
src_len	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
cur_text	*(char)
!=	O
text	*(char)
)	O
free	(*(void))->(void)
(	O
cur_text	*(char)
)	O
;	O
cur_text	*(char)
=	O
next_text	*(char)
;	O
cur_len	long
=	O
next_len	long
;	O
}	O
emitb	O
(	O
cur_text	*(char)
,	O
cur_len	long
)	O
;	O
if	O
(	O
cur_text	*(char)
!=	O
text	*(char)
)	O
free	(*(void))->(void)
(	O
cur_text	*(char)
)	O
;	O
}	O
static	O
const	O
char	O
*	O
ts_get_token_no_ws	(*(char),*(struct(int,*(char),long)))->(*(char))
(	O
const	O
char	O
*	O
p	*(char)
,	O
struct	O
token	*(struct)
*	O
token	*(struct)
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
p	*(char)
=	O
token_get	(*(char),*(struct))->(*(char))
(	O
p	*(char)
,	O
token	*(struct)
)	O
;	O
if	O
(	O
!	O
token_space_p	(*(struct))->(int)
(	O
token	*(struct)
)	O
)	O
return	O
p	*(char)
;	O
}	O
}	O
static	O
int	O
ts_expect	(*(*(char)),int,*(char),*(struct(*(char),int)))->(int)
(	O
const	O
char	O
*	O
*	O
p	*(char)
,	O
int	O
c	int
,	O
const	O
char	O
*	O
message	*(char)
,	O
struct	O
loc	struct(*(char),int)
*	O
loc	struct(*(char),int)
)	O
{	O
struct	O
token	*(struct)
token	*(struct)
;	O
*	O
p	*(char)
=	O
ts_get_token_no_ws	(*(char),*(struct(int,*(char),long)))->(*(char))
(	O
*	O
p	*(char)
,	O
&	O
token	*(struct)
)	O
;	O
if	O
(	O
token	*(struct)
.	O
type	int
==	O
c	int
)	O
return	O
1	int
;	O
error	(int,*(char))->(void)
(	O
0	int
,	O
message	*(char)
,	O
loc	struct(*(char),int)
->	O
fn	*(char)
,	O
loc	struct(*(char),int)
->	O
fn	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
tangle_subst	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
ts_parse	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(char),*(struct(*(char),int)),*(int))->(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))
(	O
struct	O
tangle_subst	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
s	*(struct)
,	O
const	O
char	O
*	O
text	*(char)
,	O
struct	O
loc	struct(*(char),int)
*	O
loc	struct(*(char),int)
,	O
int	O
*	O
cnt	int
)	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
*	O
cnt	int
=	O
0	int
;	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
text	*(char)
,	O
';'	O
)	O
;	O
if	O
(	O
p	*(char)
==	O
NULL	O
)	O
return	O
s	*(struct)
;	O
while	O
(	O
*	O
p	*(char)
!=	O
'\0'	O
)	O
{	O
struct	O
token	*(struct)
src	*(char)
,	O
dst	*(char)
;	O
if	O
(	O
!	O
ts_expect	(*(*(char)),int,*(char),*(struct(*(char),int)))->(int)
(	O
&	O
p	*(char)
,	O
';'	O
,	O
"%s:%d: `;' or `@>' expected"	*(char)
,	O
loc	struct(*(char),int)
)	O
)	O
goto	O
error	(int,*(char))->(void)
;	O
p	*(char)
=	O
ts_get_token_no_ws	(*(char),*(struct(int,*(char),long)))->(*(char))
(	O
p	*(char)
,	O
&	O
src	*(char)
)	O
;	O
if	O
(	O
src	*(char)
.	O
type	int
!=	O
TOKEN_ID	int
)	O
{	O
error	(int,*(char))->(void)
(	O
0	int
,	O
_	O
(	O
"%s:%d: Identifier expected after `;'"	*(char)
)	O
,	O
loc	struct(*(char),int)
->	O
fn	*(char)
,	O
loc	struct(*(char),int)
->	O
ln	int
)	O
;	O
goto	O
error	(int,*(char))->(void)
;	O
}	O
if	O
(	O
!	O
ts_expect	(*(*(char)),int,*(char),*(struct(*(char),int)))->(int)
(	O
&	O
p	*(char)
,	O
'='	O
,	O
"%s:%d: `=>' expected"	*(char)
,	O
loc	struct(*(char),int)
)	O
||	O
!	O
ts_expect	(*(*(char)),int,*(char),*(struct(*(char),int)))->(int)
(	O
&	O
p	*(char)
,	O
'>'	O
,	O
"%s:%d: `=>' expected"	*(char)
,	O
loc	struct(*(char),int)
)	O
)	O
goto	O
error	(int,*(char))->(void)
;	O
p	*(char)
=	O
ts_get_token_no_ws	(*(char),*(struct(int,*(char),long)))->(*(char))
(	O
p	*(char)
,	O
&	O
dst	*(char)
)	O
;	O
if	O
(	O
dst	*(char)
.	O
type	int
!=	O
TOKEN_ID	int
)	O
{	O
error	(int,*(char))->(void)
(	O
0	int
,	O
_	O
(	O
"%s:%d: Identifier expected after `=>'"	*(char)
)	O
,	O
loc	struct(*(char),int)
->	O
fn	*(char)
,	O
loc	struct(*(char),int)
->	O
ln	int
)	O
;	O
goto	O
error	(int,*(char))->(void)
;	O
}	O
s	*(struct)
=	O
ts_push	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(char),long,*(char),long)->(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))
(	O
s	*(struct)
,	O
src	*(char)
.	O
text	*(char)
,	O
src	*(char)
.	O
len	long
,	O
dst	*(char)
.	O
text	*(char)
,	O
dst	*(char)
.	O
len	long
)	O
;	O
*	O
cnt	int
+=	O
1	int
;	O
}	O
return	O
s	*(struct)
;	O
error	(int,*(char))->(void)
:	O
for	O
(	O
;	O
*	O
cnt	int
>	O
0	int
;	O
*	O
cnt	int
-=	O
1	int
)	O
s	*(struct)
=	O
ts_pop	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))
(	O
s	*(struct)
)	O
;	O
return	O
s	*(struct)
;	O
}	O
static	O
void	O
tangle_print	(*(struct(*(char),int,*(struct(*`,int,*`,int,*`,int,int,*`,*`,*`,*`,*`)),int,*(*(struct`)),int,int,*(*(struct`)),*(int),*(struct(*`,int,*`,int,*`,int,int,*`,*`,*`,*`,*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`,struct`)))),int,*(struct(*(char),int)),*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(void)
(	O
struct	O
segment	*(struct)
*	O
segment	*(struct)
,	O
int	O
indent	*(int)
,	O
struct	O
loc	struct(*(char),int)
*	O
loc	struct(*(char),int)
,	O
struct	O
tangle_subst	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
subst	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
{	O
struct	O
line	int
*	O
line	int
;	O
segment	*(struct)
->	O
use	int
++	O
;	O
for	O
(	O
line	int
=	O
segment	*(struct)
->	O
c_head	*(struct)
;	O
line	int
!=	O
NULL	O
;	O
line	int
=	O
line	int
->	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
)	O
{	O
const	O
char	O
*	O
cp	*(char)
;	O
int	O
indentation	int
=	O
indent_amount	(*(char),*(*(char)))->(int)
(	O
line	int
->	O
text	*(char)
,	O
&	O
cp	*(char)
)	O
+	O
indent	*(int)
;	O
int	O
i	int
=	O
indentation	int
;	O
loc	struct(*(char),int)
->	O
ln	int
++	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
token	*(struct)
token	*(struct)
;	O
cp	*(char)
=	O
token_get	(*(char),*(struct))->(*(char))
(	O
cp	*(char)
,	O
&	O
token	*(struct)
)	O
;	O
if	O
(	O
in_control	int
&&	O
token	*(struct)
.	O
type	int
!=	O
TOKEN_END_CONTROL	int
)	O
{	O
add_control	(*(char),long)->(void)
(	O
token	*(struct)
.	O
text	*(char)
,	O
token	*(struct)
.	O
len	long
)	O
;	O
continue	O
;	O
}	O
switch	O
(	O
token	*(struct)
.	O
type	int
)	O
{	O
case	O
0	int
:	O
goto	O
next_line	O
;	O
case	O
TOKEN_COND_NEWLINE	int
:	O
case	O
'\n'	O
:	O
emitc	O
(	O
'\n'	O
)	O
;	O
break	O
;	O
case	O
TOKEN_BEGIN_CONTROL	int
:	O
if	O
(	O
!	O
in_control	int
)	O
{	O
state_push	(enum(int,int,int,int))->(void)
(	O
CONTROL	int
)	O
;	O
in_control	int
=	O
1	int
;	O
control_len	long
=	O
0	int
;	O
control_space	int
=	O
0	int
;	O
}	O
else	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Can't nest control texts."	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
TOKEN_SEMICOLON	int
:	O
case	O
TOKEN_INC_INDENT	int
:	O
case	O
TOKEN_DEC_INDENT	int
:	O
break	O
;	O
case	O
TOKEN_PIPE	int
:	O
flush_whitespace	(*(int),*(struct(*(struct(*`,*`,struct`)),*(char),struct(*(char),int))),*(struct(*(char),int)))->(void)
(	O
&	O
i	int
,	O
line	int
,	O
loc	struct(*(char),int)
)	O
;	O
emitc	O
(	O
'|'	O
)	O
;	O
break	O
;	O
case	O
TOKEN_AT	int
:	O
flush_whitespace	(*(int),*(struct(*(struct(*`,*`,struct`)),*(char),struct(*(char),int))),*(struct(*(char),int)))->(void)
(	O
&	O
i	int
,	O
line	int
,	O
loc	struct(*(char),int)
)	O
;	O
emitc	O
(	O
'@'	O
)	O
;	O
break	O
;	O
case	O
TOKEN_END_CONTROL	int
:	O
if	O
(	O
control_len	long
>	O
0	int
)	O
control_buf	*(char)
[	O
control_len	long
]	O
=	O
'\0'	O
;	O
else	O
{	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Empty control text."	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
in_control	int
)	O
in_control	int
=	O
0	int
;	O
else	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"@> not inside control text."	*(char)
)	O
)	O
;	O
while	O
(	O
!	O
state_is	(enum(int,int,int,int))->(int)
(	O
CONTROL	int
)	O
)	O
{	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Missing closing within control text."	*(char)
)	O
)	O
;	O
state_pop	()->(void)
(	O
)	O
;	O
}	O
state_pop	()->(void)
(	O
)	O
;	O
{	O
struct	O
segment	*(struct)
*	O
segment	*(struct)
=	O
segment_find	(*(char),int)->(*(struct))
(	O
control_buf	*(char)
,	O
0	int
)	O
;	O
struct	O
tangle_subst	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
s	*(struct)
;	O
int	O
cnt	int
;	O
s	*(struct)
=	O
ts_parse	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(char),*(struct(*(char),int)),*(int))->(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))
(	O
subst	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
control_buf	*(char)
,	O
&	O
line	int
->	O
loc	struct(*(char),int)
,	O
&	O
cnt	int
)	O
;	O
if	O
(	O
segment	*(struct)
!=	O
NULL	O
)	O
tangle_print	(*(struct(*(char),int,*(struct(*`,int,*`,int,*`,int,int,*`,*`,*`,*`,*`)),int,*(*(struct`)),int,int,*(*(struct`)),*(int),*(struct(*`,int,*`,int,*`,int,int,*`,*`,*`,*`,*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`,struct`)))),int,*(struct(*(char),int)),*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(void)
(	O
segment	*(struct)
,	O
indentation	int
,	O
loc	struct(*(char),int)
,	O
s	*(struct)
!=	O
NULL	O
?	O
s	*(struct)
:	O
subst	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
else	O
{	O
emitf	(*(char))->(void)
(	O
"/* Undefined segment: %s. */\n"	*(char)
,	O
control_buf	*(char)
)	O
;	O
error	(int,*(char))->(void)
(	O
0	int
,	O
_	O
(	O
"%s:%d: segment `%s' undefined"	*(char)
)	O
,	O
line	int
->	O
loc	struct(*(char),int)
.	O
fn	*(char)
,	O
line	int
->	O
loc	struct(*(char),int)
.	O
ln	int
,	O
control_buf	*(char)
)	O
;	O
}	O
for	O
(	O
;	O
cnt	int
>	O
0	int
;	O
cnt	int
--	O
)	O
s	*(struct)
=	O
ts_pop	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))
(	O
s	*(struct)
)	O
;	O
assert	O
(	O
s	*(struct)
==	O
subst	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
{	O
const	O
char	O
*	O
p	*(char)
=	O
cp	*(char)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
p	*(char)
=	O
token_get	(*(char),*(struct))->(*(char))
(	O
p	*(char)
,	O
&	O
token	*(struct)
)	O
;	O
if	O
(	O
token	*(struct)
.	O
type	int
==	O
0	int
)	O
goto	O
next_line	O
;	O
else	O
if	O
(	O
token	*(struct)
.	O
type	int
!=	O
TOKEN_COND_NEWLINE	int
&&	O
token	*(struct)
.	O
type	int
!=	O
TOKEN_INC_INDENT	int
&&	O
token	*(struct)
.	O
type	int
!=	O
TOKEN_DEC_INDENT	int
&&	O
!	O
token_space_p	(*(struct))->(int)
(	O
&	O
token	*(struct)
)	O
)	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
TOKEN_ID	int
:	O
flush_whitespace	(*(int),*(struct(*(struct(*`,*`,struct`)),*(char),struct(*(char),int))),*(struct(*(char),int)))->(void)
(	O
&	O
i	int
,	O
line	int
,	O
loc	struct(*(char),int)
)	O
;	O
ts_emit	(*(char),long,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(void)
(	O
token	*(struct)
.	O
text	*(char)
,	O
token	*(struct)
.	O
len	long
,	O
subst	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
break	O
;	O
case	O
' '	O
:	O
i	int
++	O
;	O
break	O
;	O
case	O
'\t'	O
:	O
i	int
=	O
(	O
i	int
+	O
8	int
)	O
/	O
8	int
*	O
8	int
;	O
break	O
;	O
default	O
:	O
flush_whitespace	(*(int),*(struct(*(struct(*`,*`,struct`)),*(char),struct(*(char),int))),*(struct(*(char),int)))->(void)
(	O
&	O
i	int
,	O
line	int
,	O
loc	struct(*(char),int)
)	O
;	O
emitb	O
(	O
token	*(struct)
.	O
text	*(char)
,	O
token	*(struct)
.	O
len	long
)	O
;	O
break	O
;	O
}	O
}	O
next_line	O
:	O
;	O
}	O
}	O
static	O
void	O
tangle	()->(void)
(	O
void	O
)	O
{	O
size_t	long
line_size	*(long)
=	O
0	int
;	O
char	O
*	O
line	int
=	O
NULL	O
;	O
struct	O
segment	*(struct)
*	O
files	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
=	O
NULL	O
;	O
int	O
blank_line	int
=	O
0	int
;	O
state_init	()->(void)
(	O
)	O
;	O
state_push	(enum(int,int,int,int))->(void)
(	O
TEXT	int
)	O
;	O
input_start_pass	()->(void)
(	O
)	O
;	O
while	O
(	O
input_read_line	(*(*(char)),*(long))->(int)
(	O
&	O
line	int
,	O
&	O
line_size	*(long)
)	O
)	O
{	O
char	O
cmd	*(char)
[	O
CMD_LEN_MAX	int
+	O
1	int
]	O
;	O
if	O
(	O
parse_at_cmd	(*(char),array(char))->(int)
(	O
line	int
,	O
cmd	*(char)
)	O
)	O
{	O
if	O
(	O
cmd	*(char)
[	O
0	int
]	O
==	O
'\0'	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"node"	*(char)
)	O
)	O
{	O
segment_select	(*(struct))->(void)
(	O
NULL	O
)	O
;	O
blank_line	int
=	O
0	int
;	O
continue	O
;	O
}	O
else	O
{	O
char	O
*	O
control_text	*(char)
=	O
segment_definition_line	(*(char),*(int))->(*(char))
(	O
line	int
,	O
NULL	O
)	O
;	O
if	O
(	O
control_text	*(char)
!=	O
NULL	O
)	O
{	O
struct	O
segment	*(struct)
*	O
segment	*(struct)
;	O
segment	*(struct)
=	O
segment_find	(*(char),int)->(*(struct))
(	O
control_text	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
segment	*(struct)
==	O
NULL	O
)	O
{	O
segment	*(struct)
=	O
segment_find	(*(char),int)->(*(struct))
(	O
control_text	*(char)
,	O
1	int
)	O
;	O
assert	O
(	O
segment	*(struct)
!=	O
NULL	O
)	O
;	O
if	O
(	O
line	int
[	O
1	int
]	O
==	O
'('	O
)	O
{	O
segment	*(struct)
->	O
c_next	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct)),int,int,*(*(struct)),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct),*(struct)))
=	O
files	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
;	O
files	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
=	O
segment	*(struct)
;	O
}	O
blank_line	int
=	O
0	int
;	O
}	O
else	O
blank_line	int
=	O
0	int
;	O
segment_select	(*(struct))->(void)
(	O
segment	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
control_text	*(char)
)	O
;	O
continue	O
;	O
}	O
}	O
}	O
if	O
(	O
blank_line	int
)	O
{	O
blank_line	int
=	O
0	int
;	O
segment_add_line	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
}	O
segment_add_line	(*(char))->(void)
(	O
line	int
)	O
;	O
}	O
input_end_pass	()->(void)
(	O
)	O
;	O
state_pop	()->(void)
(	O
)	O
;	O
free	(*(void))->(void)
(	O
line	int
)	O
;	O
{	O
time_t	long
t	long
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
struct	O
loc	struct(*(char),int)
loc	struct(*(char),int)
;	O
time	(*(long))->(long)
(	O
&	O
t	long
)	O
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
=	O
*	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
t	long
)	O
;	O
loc	struct(*(char),int)
.	O
fn	*(char)
=	O
NULL	O
;	O
loc	struct(*(char),int)
.	O
ln	int
=	O
0	int
;	O
for	O
(	O
;	O
files	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
!=	O
NULL	O
;	O
files	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
=	O
files	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
c_next	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct)),int,int,*(*(struct)),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct),*(struct)))
)	O
if	O
(	O
filenames_only	int
)	O
puts	(*(char))->(int)
(	O
files	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
name	*(char)
)	O
;	O
else	O
{	O
if	O
(	O
out_file_name	*(char)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
files	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
name	*(char)
,	O
out_file_name	*(char)
)	O
)	O
continue	O
;	O
out_file_name	*(char)
=	O
files	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
->	O
name	*(char)
;	O
out_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
out_file_name	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
out_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
error	(int,*(char))->(void)
(	O
FTL	int
,	O
_	O
(	O
"Opening %s for writing: %s"	*(char)
)	O
,	O
out_file_name	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
time	(*(long))->(long)
(	O
&	O
t	long
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
out_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"/* Produced by texiweb from %s "	*(char)
"on %04d/%02d/%02d at %02d:%02d. */\n\n"	*(char)
,	O
in_file_name	*(char)
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_year	int
+	O
1900	int
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mon	int
+	O
1	int
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mday	int
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_min	int
)	O
;	O
state_init	()->(void)
(	O
)	O
;	O
state_push	(enum(int,int,int,int))->(void)
(	O
CODE	int
)	O
;	O
tangle_print	(*(struct(*(char),int,*(struct(*`,int,*`,int,*`,int,int,*`,*`,*`,*`,*`)),int,*(*(struct`)),int,int,*(*(struct`)),*(int),*(struct(*`,int,*`,int,*`,int,int,*`,*`,*`,*`,*`)),*(struct(*`,*`,struct`)),*(struct(*`,*`,struct`)))),int,*(struct(*(char),int)),*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(void)
(	O
files	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
,	O
0	int
,	O
&	O
loc	struct(*(char),int)
,	O
NULL	O
)	O
;	O
state_pop	()->(void)
(	O
)	O
;	O
out_file_name	*(char)
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
print_unused	int
)	O
{	O
struct	O
segment	*(struct)
*	O
s	*(struct)
;	O
for	O
(	O
s	*(struct)
=	O
segment_first	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
;	O
s	*(struct)
!=	O
NULL	O
;	O
s	*(struct)
=	O
s	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct)))
)	O
if	O
(	O
s	*(struct)
->	O
use	int
==	O
0	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(struct)
->	O
name	*(char)
,	O
"Anonymous"	*(char)
)	O
)	O
{	O
if	O
(	O
s	*(struct)
->	O
c_head	*(struct)
!=	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
"%s:%d: "	*(char)
,	O
s	*(struct)
->	O
c_head	*(struct)
->	O
loc	struct(*(char),int)
.	O
fn	*(char)
,	O
s	*(struct)
->	O
c_head	*(struct)
->	O
loc	struct(*(char),int)
.	O
ln	int
)	O
;	O
printf	(*(char))->(int)
(	O
"segment `%s' not included in any output file\n"	*(char)
,	O
s	*(struct)
->	O
name	*(char)
)	O
;	O
}	O
}	O
}	O
enum	O
state_name	enum(int,int,int)
{	O
STATE_START	int
,	O
STATE_PARSE	int
,	O
STATE_PARSE_ERROR	int
}	O
;	O
enum	O
type	int
{	O
TYPE_BASIC	int
,	O
TYPE_POINTER	int
,	O
TYPE_ARRAY	int
,	O
TYPE_FUNCTION	int
}	O
;	O
struct	O
engine_state	struct(enum(int,int,int),*(char),*(char),int,int,*(char),int,enum(int,int,int,int),enum(int,int,int,int),int,array(int))
{	O
enum	O
state_name	enum(int,int,int)
state	enum(int,int,int,int)
;	O
char	O
*	O
last_id	*(char)
;	O
char	O
*	O
save_id	*(char)
;	O
int	O
last_was_struct	int
;	O
int	O
struct_type	int
;	O
char	O
*	O
tag	*(char)
;	O
int	O
typedefing	int
;	O
enum	O
type	int
type	int
;	O
enum	O
type	int
last_type	enum(int,int,int,int)
;	O
int	O
stack_cnt	int
;	O
int	O
stack	array(int)
[	O
STACK_HEIGHT	int
]	O
;	O
}	O
;	O
static	O
void	O
init_engine_state	(*(struct))->(void)
(	O
struct	O
engine_state	struct(enum(int,int,int),*(char),*(char),int,int,*(char),int,enum(int,int,int,int),enum(int,int,int,int),int,array(int))
*	O
s	*(struct)
)	O
{	O
s	*(struct)
->	O
state	enum(int,int,int,int)
=	O
STATE_START	int
;	O
free	(*(void))->(void)
(	O
s	*(struct)
->	O
last_id	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
s	*(struct)
->	O
save_id	*(char)
)	O
;	O
s	*(struct)
->	O
last_id	*(char)
=	O
s	*(struct)
->	O
save_id	*(char)
=	O
NULL	O
;	O
s	*(struct)
->	O
last_was_struct	int
=	O
0	int
;	O
free	(*(void))->(void)
(	O
s	*(struct)
->	O
tag	*(char)
)	O
;	O
s	*(struct)
->	O
tag	*(char)
=	O
NULL	O
;	O
s	*(struct)
->	O
typedefing	int
=	O
0	int
;	O
s	*(struct)
->	O
type	int
=	O
s	*(struct)
->	O
last_type	enum(int,int,int,int)
=	O
TYPE_BASIC	int
;	O
s	*(struct)
->	O
stack_cnt	int
=	O
1	int
;	O
s	*(struct)
->	O
stack	array(int)
[	O
0	int
]	O
=	O
0	int
;	O
}	O
static	O
int	O
debug_parser	int
=	O
0	int
;	O
static	O
int	O
lr_engine	(*(struct),*(struct))->(int)
(	O
struct	O
engine_state	struct(enum(int,int,int),*(char),*(char),int,int,*(char),int,enum(int,int,int,int),enum(int,int,int,int),int,array(int))
*	O
engine	*(struct)
,	O
struct	O
token	*(struct)
*	O
token	*(struct)
)	O
{	O
enum	O
{	O
err	int
,	O
acc	int
,	O
s0	int
,	O
s1	int
,	O
s2	int
,	O
s3	int
,	O
s4	int
,	O
s5	int
,	O
s6	int
,	O
s7	int
,	O
s8	int
,	O
s9	int
,	O
s10	int
,	O
s11	int
,	O
s12	int
,	O
s13	int
,	O
s14	int
,	O
s15	int
,	O
s16	int
,	O
s17	int
,	O
s18	int
,	O
s19	int
,	O
s20	int
,	O
s21	int
,	O
s22	int
,	O
s23	int
,	O
s24	int
,	O
s25	int
,	O
s26	int
,	O
s27	int
,	O
s28	int
,	O
s29	int
,	O
s30	int
,	O
s31	int
,	O
s32	int
,	O
s33	int
,	O
s34	int
,	O
s35	int
,	O
s36	int
,	O
s37	int
,	O
s38	int
,	O
s39	int
,	O
s40	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
s49	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
s53	int
,	O
s54	int
,	O
s55	int
,	O
s56	int
,	O
s57	int
,	O
s58	int
,	O
s59	int
,	O
s60	int
,	O
s61	int
,	O
s62	int
,	O
r1	int
,	O
r2	int
,	O
r3	int
,	O
r4	int
,	O
r5	int
,	O
r6	int
,	O
r7	int
,	O
r8	int
,	O
r9	int
,	O
r10	int
,	O
r11	int
,	O
r12	int
,	O
r13	int
,	O
r14	int
,	O
r15	int
,	O
r16	int
,	O
r17	int
,	O
r18	int
,	O
r19	int
,	O
r20	int
,	O
r21	int
,	O
r22	int
,	O
r23	int
,	O
r24	int
,	O
r25	int
,	O
r26	int
,	O
r27	int
,	O
r28	int
,	O
r29	int
,	O
r30	int
,	O
r31	int
,	O
r32	int
,	O
r33	int
,	O
r34	int
,	O
r35	int
,	O
r36	int
,	O
r37	int
,	O
r38	int
,	O
r39	int
,	O
r40	int
,	O
n_states	int
=	O
63	int
,	O
n_terminals	int
=	O
16	int
,	O
n_nonterminals	int
=	O
15	int
,	O
n_reductions	int
=	O
40	int
}	O
;	O
enum	O
{	O
lex_lparen	int
,	O
lex_rparen	int
,	O
lex_pointer	int
,	O
lex_comma	int
,	O
lex_typedef	int
,	O
lex_type_name	int
,	O
lex_struct	int
,	O
lex_const	int
,	O
lex_semicolon	int
,	O
lex_lbrack	int
,	O
lex_rbrack	int
,	O
lex_identifier	int
,	O
lex_other	int
,	O
lex_lbrace	int
,	O
lex_rbrace	int
,	O
lex_stop	int
}	O
;	O
static	O
const	O
unsigned	O
char	O
action_table	array(array(char))
[	O
n_states	int
]	O
[	O
n_terminals	int
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s1	int
,	O
s2	int
,	O
s3	int
,	O
s4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r6	int
,	O
0	int
,	O
r6	int
,	O
0	int
,	O
r6	int
,	O
r6	int
,	O
r6	int
,	O
r6	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r6	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r7	int
,	O
0	int
,	O
r7	int
,	O
0	int
,	O
r7	int
,	O
r7	int
,	O
r7	int
,	O
r7	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r7	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r9	int
,	O
0	int
,	O
r9	int
,	O
0	int
,	O
r9	int
,	O
r9	int
,	O
r9	int
,	O
r9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s9	int
,	O
0	int
,	O
s10	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s15	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s1	int
,	O
s2	int
,	O
s3	int
,	O
s4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
acc	int
}	O
,	O
{	O
r5	int
,	O
0	int
,	O
r5	int
,	O
0	int
,	O
s1	int
,	O
s2	int
,	O
s3	int
,	O
s4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r5	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r11	int
,	O
0	int
,	O
r11	int
,	O
0	int
,	O
r11	int
,	O
r11	int
,	O
r11	int
,	O
r11	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r11	int
,	O
0	int
,	O
s20	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s9	int
,	O
0	int
,	O
s10	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s15	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r18	int
,	O
0	int
,	O
r18	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r18	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r18	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s23	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s26	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s27	int
,	O
r16	int
,	O
0	int
,	O
r16	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r16	int
,	O
s28	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r16	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r19	int
,	O
r19	int
,	O
0	int
,	O
r19	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r19	int
,	O
r19	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r19	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
s29	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r14	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r14	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r23	int
,	O
r23	int
,	O
0	int
,	O
r23	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r23	int
,	O
r23	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r23	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s9	int
,	O
0	int
,	O
s10	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s15	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r4	int
,	O
0	int
,	O
r4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r8	int
,	O
0	int
,	O
r8	int
,	O
0	int
,	O
r8	int
,	O
r8	int
,	O
r8	int
,	O
r8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
0	int
}	O
,	O
{	O
r12	int
,	O
0	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
0	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
s32	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s9	int
,	O
0	int
,	O
s10	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s33	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s15	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r38	int
,	O
r38	int
,	O
r38	int
,	O
r38	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r38	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r2	int
,	O
r2	int
,	O
r2	int
,	O
r2	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r2	int
}	O
,	O
{	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
0	int
}	O
,	O
{	O
r40	int
,	O
0	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
0	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
0	int
}	O
,	O
{	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
0	int
}	O
,	O
{	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
0	int
}	O
,	O
{	O
s9	int
,	O
0	int
,	O
s10	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s15	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s23	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s26	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s40	int
,	O
0	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
0	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
s53	int
,	O
0	int
}	O
,	O
{	O
r20	int
,	O
r20	int
,	O
0	int
,	O
r20	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r20	int
,	O
r20	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r20	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r17	int
,	O
0	int
,	O
r17	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r17	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r17	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
r15	int
,	O
0	int
,	O
r15	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r15	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r15	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s40	int
,	O
0	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
0	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
s54	int
,	O
0	int
}	O
,	O
{	O
s40	int
,	O
s55	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
0	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s40	int
,	O
0	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
s56	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r13	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r13	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r3	int
,	O
r3	int
,	O
r3	int
,	O
r3	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r3	int
}	O
,	O
{	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
0	int
}	O
,	O
{	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
0	int
}	O
,	O
{	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
0	int
}	O
,	O
{	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
0	int
}	O
,	O
{	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
0	int
}	O
,	O
{	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
0	int
}	O
,	O
{	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
0	int
}	O
,	O
{	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
0	int
}	O
,	O
{	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
0	int
}	O
,	O
{	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
0	int
}	O
,	O
{	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
0	int
}	O
,	O
{	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
0	int
}	O
,	O
{	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
0	int
}	O
,	O
{	O
r10	int
,	O
0	int
,	O
r10	int
,	O
0	int
,	O
r10	int
,	O
r10	int
,	O
r10	int
,	O
r10	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r10	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r39	int
,	O
r39	int
,	O
r39	int
,	O
r39	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r39	int
}	O
,	O
{	O
r22	int
,	O
r22	int
,	O
0	int
,	O
r22	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r22	int
,	O
r22	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r22	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r21	int
,	O
r21	int
,	O
0	int
,	O
r21	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r21	int
,	O
r21	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r21	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s40	int
,	O
s60	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
0	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s40	int
,	O
0	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
s61	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s40	int
,	O
0	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
0	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
s62	int
,	O
0	int
}	O
,	O
{	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
0	int
}	O
,	O
{	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
0	int
}	O
,	O
{	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
0	int
}	O
,	O
}	O
;	O
static	O
const	O
unsigned	O
char	O
goto_table	array(array(char))
[	O
n_states	int
]	O
[	O
n_nonterminals	int
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
5	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
6	int
,	O
7	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
14	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
16	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
7	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
17	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
7	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
18	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
19	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
12	int
,	O
13	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
21	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
22	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
24	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
25	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
30	int
,	O
12	int
,	O
13	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
14	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
31	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
12	int
,	O
13	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
34	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
35	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
36	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
37	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
38	int
,	O
12	int
,	O
13	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
14	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
39	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
25	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
49	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
49	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
49	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
49	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
57	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
58	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
49	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
49	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
49	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
enum	O
{	O
reduce_null	int
,	O
reduce_array	int
,	O
reduce_declaration	int
,	O
reduce_declarator	int
,	O
reduce_function	int
,	O
reduce_function_definition	int
,	O
reduce_identifier	int
,	O
reduce_pointer	int
,	O
reduce_struct_definition	int
,	O
reduce_typedef	int
}	O
;	O
static	O
const	O
unsigned	O
char	O
reduce_table	array(array(char))
[	O
n_reductions	int
]	O
[	O
3	int
]	O
=	O
{	O
{	O
1	int
,	O
5	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
11	int
,	O
reduce_declaration	int
}	O
,	O
{	O
4	int
,	O
11	int
,	O
reduce_declaration	int
}	O
,	O
{	O
2	int
,	O
6	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
6	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
12	int
,	O
reduce_typedef	int
}	O
,	O
{	O
1	int
,	O
12	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
12	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
12	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
0	int
,	O
reduce_null	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
13	int
,	O
reduce_struct_definition	int
}	O
,	O
{	O
3	int
,	O
1	int
,	O
reduce_declarator	int
}	O
,	O
{	O
1	int
,	O
1	int
,	O
reduce_declarator	int
}	O
,	O
{	O
3	int
,	O
9	int
,	O
reduce_pointer	int
}	O
,	O
{	O
1	int
,	O
9	int
,	O
reduce_null	int
}	O
,	O
{	O
2	int
,	O
4	int
,	O
reduce_null	int
}	O
,	O
{	O
0	int
,	O
4	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
2	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
2	int
,	O
reduce_null	int
}	O
,	O
{	O
4	int
,	O
2	int
,	O
reduce_array	int
}	O
,	O
{	O
4	int
,	O
2	int
,	O
reduce_function	int
}	O
,	O
{	O
1	int
,	O
3	int
,	O
reduce_identifier	int
}	O
,	O
{	O
0	int
,	O
7	int
,	O
reduce_null	int
}	O
,	O
{	O
2	int
,	O
7	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
10	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
10	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
14	int
,	O
reduce_function_definition	int
}	O
,	O
}	O
;	O
int	O
a	*(struct(int,*(char)))
;	O
switch	O
(	O
token	*(struct)
->	O
type	int
)	O
{	O
case	O
'{'	O
:	O
a	*(struct(int,*(char)))
=	O
lex_lbrace	int
;	O
break	O
;	O
case	O
'}'	O
:	O
a	*(struct(int,*(char)))
=	O
lex_rbrace	int
;	O
break	O
;	O
case	O
','	O
:	O
a	*(struct(int,*(char)))
=	O
lex_comma	int
;	O
break	O
;	O
case	O
'*'	O
:	O
a	*(struct(int,*(char)))
=	O
lex_pointer	int
;	O
break	O
;	O
case	O
'('	O
:	O
a	*(struct(int,*(char)))
=	O
lex_lparen	int
;	O
break	O
;	O
case	O
')'	O
:	O
a	*(struct(int,*(char)))
=	O
lex_rparen	int
;	O
break	O
;	O
case	O
'['	O
:	O
a	*(struct(int,*(char)))
=	O
lex_lbrack	int
;	O
break	O
;	O
case	O
']'	O
:	O
a	*(struct(int,*(char)))
=	O
lex_rbrack	int
;	O
break	O
;	O
case	O
';'	O
:	O
a	*(struct(int,*(char)))
=	O
lex_semicolon	int
;	O
break	O
;	O
case	O
TOKEN_ID	int
:	O
{	O
struct	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
*	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
=	O
symbol_find	(*(char),long,int)->(*(struct))
(	O
token	*(struct)
->	O
text	*(char)
,	O
token	*(struct)
->	O
len	long
,	O
0	int
)	O
;	O
switch	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
?	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
->	O
kw_idx	int
:	O
-	O
1	int
)	O
{	O
case	O
KW_TYPEDEF	int
:	O
a	*(struct(int,*(char)))
=	O
lex_typedef	int
;	O
break	O
;	O
case	O
KW_EXTERN	int
:	O
case	O
KW_STATIC	int
:	O
case	O
KW_AUTO	int
:	O
case	O
KW_REGISTER	int
:	O
case	O
KW_VOID	int
:	O
case	O
KW_CHAR	int
:	O
case	O
KW_SHORT	int
:	O
case	O
KW_INT	int
:	O
case	O
KW_LONG	int
:	O
case	O
KW_FLOAT	int
:	O
case	O
KW_DOUBLE	int
:	O
case	O
KW_SIGNED	int
:	O
case	O
KW_UNSIGNED	int
:	O
a	*(struct(int,*(char)))
=	O
lex_type_name	int
;	O
break	O
;	O
case	O
KW_STRUCT	int
:	O
case	O
KW_UNION	int
:	O
case	O
KW_ENUM	int
:	O
a	*(struct(int,*(char)))
=	O
lex_struct	int
;	O
engine	*(struct)
->	O
struct_type	int
=	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
->	O
kw_idx	int
;	O
break	O
;	O
case	O
KW_CONST	int
:	O
case	O
KW_VOLATILE	int
:	O
a	*(struct(int,*(char)))
=	O
lex_const	int
;	O
break	O
;	O
case	O
-	O
1	int
:	O
if	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
!=	O
NULL	O
&&	O
symbol	struct(*(struct(*(struct(*(struct`),*(char),*(struct`),int,int,*(struct`))),*(char),*(struct),int,int,*(struct))),*(char),*(struct),int,int,*(struct))
->	O
is_typedef	int
&&	O
!	O
engine	*(struct)
->	O
last_was_struct	int
)	O
a	*(struct(int,*(char)))
=	O
lex_type_name	int
;	O
else	O
a	*(struct(int,*(char)))
=	O
lex_identifier	int
;	O
if	O
(	O
engine	*(struct)
->	O
last_was_struct	int
)	O
{	O
free	(*(void))->(void)
(	O
engine	*(struct)
->	O
tag	*(char)
)	O
;	O
engine	*(struct)
->	O
tag	*(char)
=	O
xstrndup	(*(char),long)->(*(char))
(	O
token	*(struct)
->	O
text	*(char)
,	O
token	*(struct)
->	O
len	long
)	O
;	O
}	O
else	O
{	O
free	(*(void))->(void)
(	O
engine	*(struct)
->	O
last_id	*(char)
)	O
;	O
engine	*(struct)
->	O
last_id	*(char)
=	O
xstrndup	(*(char),long)->(*(char))
(	O
token	*(struct)
->	O
text	*(char)
,	O
token	*(struct)
->	O
len	long
)	O
;	O
}	O
break	O
;	O
default	O
:	O
a	*(struct(int,*(char)))
=	O
lex_other	int
;	O
break	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
a	*(struct(int,*(char)))
=	O
lex_other	int
;	O
break	O
;	O
}	O
engine	*(struct)
->	O
last_was_struct	int
=	O
(	O
a	*(struct(int,*(char)))
==	O
lex_struct	int
)	O
;	O
assert	O
(	O
engine	*(struct)
->	O
stack_cnt	int
>	O
0	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
s	*(struct)
=	O
engine	*(struct)
->	O
stack	array(int)
[	O
engine	*(struct)
->	O
stack_cnt	int
-	O
1	int
]	O
;	O
int	O
action	int
=	O
action_table	array(array(char))
[	O
s	*(struct)
]	O
[	O
a	*(struct(int,*(char)))
]	O
;	O
if	O
(	O
debug_parser	int
)	O
printf	(*(char))->(int)
(	O
"%d: "	*(char)
,	O
s	*(struct)
)	O
;	O
if	O
(	O
action	int
>=	O
s0	int
&&	O
action	int
<	O
s0	int
+	O
n_states	int
)	O
{	O
if	O
(	O
debug_parser	int
)	O
printf	(*(char))->(int)
(	O
"s%d"	*(char)
,	O
action	int
-	O
s0	int
)	O
;	O
if	O
(	O
engine	*(struct)
->	O
stack_cnt	int
>=	O
STACK_HEIGHT	int
)	O
return	O
0	int
;	O
engine	*(struct)
->	O
stack	array(int)
[	O
engine	*(struct)
->	O
stack_cnt	int
++	O
]	O
=	O
action	int
-	O
s0	int
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
action	int
==	O
acc	int
)	O
{	O
if	O
(	O
debug_parser	int
)	O
printf	(*(char))->(int)
(	O
"accepted!"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
action	int
==	O
err	int
)	O
{	O
if	O
(	O
debug_parser	int
)	O
printf	(*(char))->(int)
(	O
"error!"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
int	O
reduction	int
,	O
n_pop	int
,	O
A	int
;	O
int	O
sprime	int
;	O
reduction	int
=	O
action	int
-	O
r1	int
;	O
assert	O
(	O
reduction	int
>=	O
0	int
&&	O
reduction	int
<	O
n_reductions	int
)	O
;	O
if	O
(	O
debug_parser	int
)	O
printf	(*(char))->(int)
(	O
"r%d,"	*(char)
,	O
reduction	int
)	O
;	O
n_pop	int
=	O
reduce_table	array(array(char))
[	O
reduction	int
]	O
[	O
0	int
]	O
;	O
A	int
=	O
reduce_table	array(array(char))
[	O
reduction	int
]	O
[	O
1	int
]	O
;	O
engine	*(struct)
->	O
stack_cnt	int
-=	O
n_pop	int
;	O
assert	O
(	O
engine	*(struct)
->	O
stack_cnt	int
>	O
0	int
)	O
;	O
sprime	int
=	O
engine	*(struct)
->	O
stack	array(int)
[	O
engine	*(struct)
->	O
stack_cnt	int
-	O
1	int
]	O
;	O
if	O
(	O
debug_parser	int
)	O
printf	(*(char))->(int)
(	O
"g%d "	*(char)
,	O
goto_table	array(array(char))
[	O
sprime	int
]	O
[	O
A	int
]	O
)	O
;	O
engine	*(struct)
->	O
stack	array(int)
[	O
engine	*(struct)
->	O
stack_cnt	int
++	O
]	O
=	O
goto_table	array(array(char))
[	O
sprime	int
]	O
[	O
A	int
]	O
;	O
switch	O
(	O
reduce_table	array(array(char))
[	O
reduction	int
]	O
[	O
2	int
]	O
)	O
{	O
case	O
reduce_array	int
:	O
if	O
(	O
engine	*(struct)
->	O
type	int
==	O
TYPE_BASIC	int
)	O
engine	*(struct)
->	O
type	int
=	O
TYPE_ARRAY	int
;	O
break	O
;	O
case	O
reduce_declaration	int
:	O
engine	*(struct)
->	O
typedefing	int
=	O
0	int
;	O
engine	*(struct)
->	O
type	int
=	O
engine	*(struct)
->	O
last_type	enum(int,int,int,int)
=	O
TYPE_BASIC	int
;	O
break	O
;	O
case	O
reduce_declarator	int
:	O
assert	O
(	O
engine	*(struct)
->	O
save_id	*(char)
!=	O
NULL	O
)	O
;	O
if	O
(	O
engine	*(struct)
->	O
typedefing	int
)	O
{	O
symbol_find	(*(char),long,int)->(*(struct))
(	O
engine	*(struct)
->	O
save_id	*(char)
,	O
strlen	(*(char))->(long)
(	O
engine	*(struct)
->	O
save_id	*(char)
)	O
,	O
1	int
)	O
->	O
is_typedef	int
=	O
1	int
;	O
emitf	(*(char))->(void)
(	O
"@cindex "	*(char)
TYPEDEF_STYLE	*(char)
"{%s} type\n"	*(char)
,	O
engine	*(struct)
->	O
save_id	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
engine	*(struct)
->	O
type	int
==	O
TYPE_BASIC	int
||	O
engine	*(struct)
->	O
type	int
==	O
TYPE_POINTER	int
)	O
emitf	(*(char))->(void)
(	O
"@cindex @i{%s} %s\n"	*(char)
,	O
engine	*(struct)
->	O
save_id	*(char)
,	O
_	O
(	O
"variable"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
engine	*(struct)
->	O
type	int
==	O
TYPE_ARRAY	int
)	O
emitf	(*(char))->(void)
(	O
"@cindex @i{%s} %s\n"	*(char)
,	O
engine	*(struct)
->	O
save_id	*(char)
,	O
_	O
(	O
"array"	*(char)
)	O
)	O
;	O
}	O
engine	*(struct)
->	O
last_type	enum(int,int,int,int)
=	O
engine	*(struct)
->	O
type	int
;	O
engine	*(struct)
->	O
type	int
=	O
TYPE_BASIC	int
;	O
break	O
;	O
case	O
reduce_function	int
:	O
if	O
(	O
engine	*(struct)
->	O
type	int
==	O
TYPE_BASIC	int
)	O
engine	*(struct)
->	O
type	int
=	O
TYPE_FUNCTION	int
;	O
break	O
;	O
case	O
reduce_function_definition	int
:	O
if	O
(	O
debug_parser	int
)	O
printf	(*(char))->(int)
(	O
"Reducing function!\n"	*(char)
)	O
;	O
if	O
(	O
engine	*(struct)
->	O
last_type	enum(int,int,int,int)
==	O
TYPE_FUNCTION	int
)	O
emitf	(*(char))->(void)
(	O
"@cindex @i{%s} %s\n"	*(char)
,	O
engine	*(struct)
->	O
save_id	*(char)
,	O
_	O
(	O
"function"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
reduce_identifier	int
:	O
free	(*(void))->(void)
(	O
engine	*(struct)
->	O
save_id	*(char)
)	O
;	O
engine	*(struct)
->	O
save_id	*(char)
=	O
engine	*(struct)
->	O
last_id	*(char)
;	O
engine	*(struct)
->	O
last_id	*(char)
=	O
NULL	O
;	O
break	O
;	O
case	O
reduce_null	int
:	O
break	O
;	O
case	O
reduce_pointer	int
:	O
if	O
(	O
engine	*(struct)
->	O
type	int
==	O
TYPE_BASIC	int
)	O
engine	*(struct)
->	O
type	int
=	O
TYPE_POINTER	int
;	O
break	O
;	O
case	O
reduce_struct_definition	int
:	O
{	O
const	O
char	O
*	O
struct_name	*(char)
;	O
if	O
(	O
engine	*(struct)
->	O
struct_type	int
==	O
KW_STRUCT	int
)	O
struct_name	*(char)
=	O
"structure"	*(char)
;	O
else	O
if	O
(	O
engine	*(struct)
->	O
struct_type	int
==	O
KW_UNION	int
)	O
struct_name	*(char)
=	O
"union"	*(char)
;	O
else	O
{	O
assert	O
(	O
engine	*(struct)
->	O
struct_type	int
==	O
KW_ENUM	int
)	O
;	O
struct_name	*(char)
=	O
"enumeration"	*(char)
;	O
}	O
assert	O
(	O
engine	*(struct)
->	O
tag	*(char)
!=	O
NULL	O
)	O
;	O
emitf	(*(char))->(void)
(	O
"@cindex @i{%s} %s\n"	*(char)
,	O
engine	*(struct)
->	O
tag	*(char)
,	O
struct_name	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
reduce_typedef	int
:	O
engine	*(struct)
->	O
typedefing	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
declaration_engine	(*(char),int)->(void)
(	O
const	O
char	O
*	O
cp	*(char)
,	O
int	O
indent	*(int)
)	O
{	O
static	O
struct	O
engine_state	struct(enum(int,int,int),*(char),*(char),int,int,*(char),int,enum(int,int,int,int),enum(int,int,int,int),int,array(int))
s	*(struct)
;	O
struct	O
token	*(struct)
token	*(struct)
;	O
if	O
(	O
cp	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
debug_parser	int
)	O
printf	(*(char))->(int)
(	O
"\n\n--%s:%d--\n"	*(char)
,	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
name	*(char)
,	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
line	int
)	O
;	O
init_engine_state	(*(struct))->(void)
(	O
&	O
s	*(struct)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
*	O
cp	*(char)
==	O
'#'	O
)	O
return	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
cp	*(char)
=	O
token_get	(*(char),*(struct))->(*(char))
(	O
cp	*(char)
,	O
&	O
token	*(struct)
)	O
;	O
if	O
(	O
token	*(struct)
.	O
type	int
==	O
'\0'	O
||	O
token	*(struct)
.	O
type	int
==	O
TOKEN_COND_NEWLINE	int
||	O
token	*(struct)
.	O
type	int
==	O
TOKEN_INC_INDENT	int
||	O
token	*(struct)
.	O
type	int
==	O
TOKEN_DEC_INDENT	int
)	O
return	O
;	O
if	O
(	O
token_space_p	(*(struct))->(int)
(	O
&	O
token	*(struct)
)	O
)	O
{	O
if	O
(	O
token	*(struct)
.	O
type	int
==	O
'\n'	O
&&	O
s	*(struct)
.	O
state	enum(int,int,int,int)
==	O
STATE_PARSE_ERROR	int
)	O
init_engine_state	(*(struct))->(void)
(	O
&	O
s	*(struct)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
debug_parser	int
)	O
printf	(*(char))->(int)
(	O
"\n\"%.*s\": "	*(char)
,	O
(	O
int	O
)	O
token	*(struct)
.	O
len	long
,	O
token	*(struct)
.	O
text	*(char)
)	O
;	O
switch	O
(	O
s	*(struct)
.	O
state	enum(int,int,int,int)
)	O
{	O
case	O
STATE_START	int
:	O
assert	O
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
!=	O
NULL	O
)	O
;	O
if	O
(	O
indent	*(int)
!=	O
0	int
||	O
segment_inside_indentation	(*(struct))->(int)
(	O
segment_cur	*(struct(*(char),int,*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),int,*(*(struct(*`,int,int,*`))),int,int,*(*(struct(*`,int,int,*`))),*(int),*(struct(*(char),int,*(struct`),int,*(*`),int,int,*(*`),*(int),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(char),struct(*`,int))),*(struct(*(struct`),*(char),struct(*`,int)))))
)	O
)	O
{	O
s	*(struct)
.	O
state	enum(int,int,int,int)
=	O
STATE_PARSE_ERROR	int
;	O
break	O
;	O
}	O
s	*(struct)
.	O
state	enum(int,int,int,int)
=	O
STATE_PARSE	int
;	O
case	O
STATE_PARSE	int
:	O
if	O
(	O
lr_engine	(*(struct),*(struct))->(int)
(	O
&	O
s	*(struct)
,	O
&	O
token	*(struct)
)	O
==	O
0	int
)	O
s	*(struct)
.	O
state	enum(int,int,int,int)
=	O
STATE_PARSE_ERROR	int
;	O
break	O
;	O
case	O
STATE_PARSE_ERROR	int
:	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
static	O
const	O
char	O
*	O
help	array(*(char))
[	O
]	O
=	O
{	O
N_	O
(	O
"texiweb, a program for translating TexiWEB documents\n"	*(char)
)	O
,	O
N_	O
(	O
"Usage: %s [OPTION]... COMMAND\n"	*(char)
)	O
,	O
N_	O
(	O
"\nCommands:\n"	*(char)
)	O
,	O
N_	O
(	O
"  weave INFILE OUTFILE     translate TexiWEB to Texinfo\n"	*(char)
)	O
,	O
N_	O
(	O
"  tangle INFILE [OUTFILE]  translate TexiWEB to C\n"	*(char)
)	O
,	O
N_	O
(	O
"\nOptions:\n"	*(char)
)	O
,	O
N_	O
(	O
"  -l, --no-line          (tangle) emit #line directives\n"	*(char)
)	O
,	O
N_	O
(	O
"  -d, --debug            enables code for debugging texiweb\n"	*(char)
)	O
,	O
N_	O
(	O
"  -f, --filenames        (tangle) only print list of .c files in .w\n"	*(char)
)	O
,	O
N_	O
(	O
"  -u, --unused           (tangle) also print list of unused sections\n"	*(char)
)	O
,	O
N_	O
(	O
"  -c, --catalogues       (weave) also print unused catalogues\n"	*(char)
)	O
,	O
N_	O
(	O
"  -a, --unanswered       (weave) also list exercises without answers\n"	*(char)
)	O
,	O
N_	O
(	O
"  -n, --nonzero-indent   (weave) warn for indent adjust between blocks\n"	*(char)
)	O
,	O
N_	O
(	O
"  -h, --help             print this help, then exit\n"	*(char)
)	O
,	O
N_	O
(	O
"  -v, --version          show version, then exit\n"	*(char)
)	O
,	O
N_	O
(	O
"\nReport bugs to Ben Pfaff <blp@gnu.org>.\n"	*(char)
)	O
,	O
NULL	O
,	O
}	O
;	O
static	O
const	O
char	O
version	array(char)
[	O
]	O
=	O
N_	O
(	O
"texiweb 0.9.0\n"	*(char)
"Copyright (C) 2000 Free Software Foundation, Inc.\n"	*(char)
"texiweb comes with NO WARRANTY, to the extent permitted by law,\n"	*(char)
"not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"	*(char)
"You may redistribute copies of texiweb under the terms of the GNU\n"	*(char)
"General Public License.  For more information about these\n"	*(char)
"matters, see the file named COPYING.\n"	*(char)
"Written by Ben Pfaff <blp@gnu.org>.\n"	*(char)
)	O
;	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
exit_code	int
)	O
;	O
static	O
void	O
option	(int)->(void)
(	O
int	O
op	int
)	O
;	O
static	O
void	O
parse_cmd_line	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
options_over	int
;	O
short_pgm_name	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
'/'	O
)	O
;	O
if	O
(	O
short_pgm_name	*(char)
!=	O
NULL	O
)	O
short_pgm_name	*(char)
++	O
;	O
else	O
short_pgm_name	*(char)
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
usage	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
options_over	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
argc	int
--	O
;	O
argv	*(*(char))
++	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
{	O
if	O
(	O
operation	enum(int,int,int)
==	O
OP_NONE	int
||	O
(	O
operation	enum(int,int,int)
==	O
OP_TANGLE	int
&&	O
in_file_name	*(char)
==	O
NULL	O
)	O
||	O
(	O
operation	enum(int,int,int)
==	O
OP_WEAVE	int
&&	O
out_file_name	*(char)
==	O
NULL	O
)	O
)	O
usage	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
!	O
options_over	int
&&	O
*	O
*	O
argv	*(*(char))
==	O
'-'	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
argv	*(*(char))
,	O
"--"	*(char)
)	O
)	O
options_over	int
=	O
1	int
;	O
else	O
if	O
(	O
(	O
*	O
argv	*(*(char))
)	O
[	O
1	int
]	O
==	O
'-'	O
)	O
{	O
struct	O
long_option	struct(*(char),int)
{	O
const	O
char	O
*	O
name	*(char)
;	O
int	O
equiv	int
;	O
}	O
;	O
static	O
const	O
struct	O
long_option	struct(*(char),int)
lops	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"debug"	*(char)
,	O
'd'	O
}	O
,	O
{	O
"filenames"	*(char)
,	O
'f'	O
}	O
,	O
{	O
"no-line"	*(char)
,	O
'l'	O
}	O
,	O
{	O
"unused"	*(char)
,	O
'u'	O
}	O
,	O
{	O
"unanswered"	*(char)
,	O
'a'	O
}	O
,	O
{	O
"help"	*(char)
,	O
'h'	O
}	O
,	O
{	O
"version"	*(char)
,	O
'v'	O
}	O
,	O
}	O
;	O
const	O
struct	O
long_option	struct(*(char),int)
*	O
op	int
;	O
for	O
(	O
op	int
=	O
lops	array(struct(*(char),int))
;	O
;	O
op	int
++	O
)	O
if	O
(	O
op	int
>=	O
lops	array(struct(*(char),int))
+	O
sizeof	O
lops	array(struct(*(char),int))
/	O
sizeof	O
*	O
lops	array(struct(*(char),int))
)	O
usage	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
argv	*(*(char))
+	O
2	int
,	O
op	int
->	O
name	*(char)
)	O
)	O
{	O
option	(int)->(void)
(	O
op	int
->	O
equiv	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
(	O
*	O
argv	*(*(char))
)	O
++	O
;	O
*	O
*	O
argv	*(*(char))
;	O
(	O
*	O
argv	*(*(char))
)	O
++	O
)	O
option	(int)->(void)
(	O
*	O
*	O
argv	*(*(char))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
operation	enum(int,int,int)
==	O
OP_NONE	int
)	O
{	O
const	O
char	O
*	O
cmd	*(char)
=	O
*	O
argv	*(*(char))
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"weave"	*(char)
)	O
)	O
operation	enum(int,int,int)
=	O
OP_WEAVE	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
"tangle"	*(char)
)	O
)	O
operation	enum(int,int,int)
=	O
OP_TANGLE	int
;	O
else	O
error	(int,*(char))->(void)
(	O
FTL	int
,	O
_	O
(	O
"Invalid command %s"	*(char)
)	O
,	O
cmd	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
in_file_name	*(char)
==	O
NULL	O
)	O
in_file_name	*(char)
=	O
*	O
argv	*(*(char))
;	O
else	O
if	O
(	O
out_file_name	*(char)
==	O
NULL	O
)	O
out_file_name	*(char)
=	O
*	O
argv	*(*(char))
;	O
else	O
usage	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
operation	enum(int,int,int)
==	O
OP_WEAVE	int
)	O
{	O
out_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
out_file_name	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
out_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
error	(int,*(char))->(void)
(	O
FTL	int
,	O
_	O
(	O
"Opening %s for writing: %s"	*(char)
)	O
,	O
out_file_name	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
exit_code	int
)	O
{	O
const	O
char	O
*	O
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
help	array(*(char))
;	O
*	O
p	*(char)
!=	O
NULL	O
;	O
p	*(char)
++	O
)	O
printf	(*(char))->(int)
(	O
gettext	O
(	O
*	O
p	*(char)
)	O
,	O
short_pgm_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
exit_code	int
)	O
;	O
}	O
static	O
void	O
option	(int)->(void)
(	O
int	O
op	int
)	O
{	O
switch	O
(	O
op	int
)	O
{	O
case	O
'a'	O
:	O
print_unanswered	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
debug_parser	int
=	O
1	int
;	O
break	O
;	O
case	O
'f'	O
:	O
filenames_only	int
=	O
1	int
;	O
break	O
;	O
case	O
'l'	O
:	O
opt_line	int
=	O
1	int
;	O
break	O
;	O
case	O
'u'	O
:	O
print_unused	int
=	O
1	int
;	O
break	O
;	O
case	O
'c'	O
:	O
print_catalogues	int
=	O
1	int
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
version	array(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
break	O
;	O
default	O
:	O
usage	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
trim_whitespace	(*(*(char)),*(*(char)))->(void)
(	O
char	O
*	O
*	O
bp	*(*(char))
,	O
char	O
*	O
*	O
ep	*(*(char))
)	O
{	O
while	O
(	O
*	O
bp	*(*(char))
<	O
*	O
ep	*(*(char))
&&	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
*	O
bp	*(*(char))
)	O
)	O
(	O
*	O
bp	*(*(char))
)	O
++	O
;	O
while	O
(	O
*	O
ep	*(*(char))
>	O
*	O
bp	*(*(char))
&&	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
(	O
*	O
ep	*(*(char))
)	O
[	O
-	O
1	int
]	O
)	O
)	O
(	O
*	O
ep	*(*(char))
)	O
--	O
;	O
}	O
static	O
int	O
find_argument	(*(char),*(*(char)),*(*(char)))->(int)
(	O
char	O
*	O
line	int
,	O
char	O
*	O
*	O
bp	*(*(char))
,	O
char	O
*	O
*	O
ep	*(*(char))
)	O
{	O
*	O
bp	*(*(char))
=	O
line	int
=	O
strpbrk	(*(char),*(char))->(*(char))
(	O
line	int
,	O
" \t\r\n"	*(char)
)	O
;	O
if	O
(	O
line	int
==	O
NULL	O
)	O
goto	O
lossage	O
;	O
*	O
ep	*(*(char))
=	O
strchr	(*(char),int)->(*(char))
(	O
*	O
bp	*(*(char))
,	O
'\0'	O
)	O
;	O
trim_whitespace	(*(*(char)),*(*(char)))->(void)
(	O
bp	*(*(char))
,	O
ep	*(*(char))
)	O
;	O
if	O
(	O
*	O
bp	*(*(char))
!=	O
*	O
ep	*(*(char))
)	O
return	O
1	int
;	O
lossage	O
:	O
error	(int,*(char))->(void)
(	O
SRC	int
,	O
_	O
(	O
"Command missing argument."	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
find_optional_argument	(*(char),*(*(char)),*(*(char)))->(int)
(	O
char	O
*	O
line	int
,	O
char	O
*	O
*	O
bp	*(*(char))
,	O
char	O
*	O
*	O
ep	*(*(char))
)	O
{	O
*	O
bp	*(*(char))
=	O
line	int
=	O
strpbrk	(*(char),*(char))->(*(char))
(	O
line	int
,	O
" \t\r\n"	*(char)
)	O
;	O
if	O
(	O
line	int
==	O
NULL	O
)	O
return	O
0	int
;	O
*	O
ep	*(*(char))
=	O
strchr	(*(char),int)->(*(char))
(	O
*	O
bp	*(*(char))
,	O
'\0'	O
)	O
;	O
trim_whitespace	(*(*(char)),*(*(char)))->(void)
(	O
bp	*(*(char))
,	O
ep	*(*(char))
)	O
;	O
return	O
*	O
bp	*(*(char))
!=	O
*	O
ep	*(*(char))
;	O
}	O
static	O
int	O
empty_string	(*(char))->(int)
(	O
const	O
char	O
*	O
string	*(char)
)	O
{	O
for	O
(	O
;	O
*	O
string	*(char)
;	O
string	*(char)
++	O
)	O
if	O
(	O
!	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
string	*(char)
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
error	(int,*(char))->(void)
(	O
int	O
flags	int
,	O
const	O
char	O
*	O
message	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
;	O
if	O
(	O
flags	int
&	O
SRC	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s:%d: "	*(char)
,	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
name	*(char)
,	O
in_file	*(struct(*(struct(*(struct`),*(char),*(struct`),int)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
line	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: "	*(char)
,	O
short_pgm_name	*(char)
)	O
;	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
message	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
message	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
flags	int
&	O
FTL	int
)	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
static	O
void	O
*	O
xmalloc	(long)->(*(void))
(	O
size_t	long
amt	long
)	O
{	O
void	O
*	O
block	*(void)
;	O
assert	O
(	O
amt	long
!=	O
0	int
)	O
;	O
block	*(void)
=	O
malloc	(long)->(*(void))
(	O
amt	long
)	O
;	O
if	O
(	O
block	*(void)
==	O
NULL	O
)	O
error	(int,*(char))->(void)
(	O
FTL	int
,	O
_	O
(	O
"virtual memory exhausted"	*(char)
)	O
)	O
;	O
return	O
block	*(void)
;	O
}	O
static	O
void	O
*	O
xrealloc	(*(void),long)->(*(void))
(	O
void	O
*	O
block	*(void)
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
size	long
==	O
0	int
)	O
{	O
if	O
(	O
block	*(void)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
block	*(void)
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
block	*(void)
!=	O
NULL	O
)	O
block	*(void)
=	O
realloc	(*(void),long)->(*(void))
(	O
block	*(void)
,	O
size	long
)	O
;	O
else	O
block	*(void)
=	O
malloc	(long)->(*(void))
(	O
size	long
)	O
;	O
if	O
(	O
block	*(void)
==	O
NULL	O
)	O
error	(int,*(char))->(void)
(	O
FTL	int
,	O
_	O
(	O
"virtual memory exhausted"	*(char)
)	O
)	O
;	O
return	O
block	*(void)
;	O
}	O
static	O
char	O
*	O
xstrndup	(*(char),long)->(*(char))
(	O
const	O
char	O
*	O
buf	*(char)
,	O
size_t	long
len	long
)	O
{	O
char	O
*	O
s	*(struct)
=	O
xmalloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
s	*(struct)
,	O
buf	*(char)
,	O
len	long
)	O
;	O
s	*(struct)
[	O
len	long
]	O
=	O
'\0'	O
;	O
return	O
s	*(struct)
;	O
}	O
static	O
char	O
*	O
xstrdup	(*(char))->(*(char))
(	O
const	O
char	O
*	O
string	*(char)
)	O
{	O
char	O
*	O
new	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
new	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
string	*(char)
)	O
;	O
return	O
new	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
}	O
