extern	O
FILE	struct
*	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
double	O
dap_simp	(*(()->(double)),double,double,int)->(double)
(	O
double	O
(	O
*	O
f	*(()->(double))
)	O
(	O
)	O
,	O
double	O
a	double
,	O
double	O
b	double
,	O
int	O
n	int
)	O
{	O
double	O
h	double
;	O
double	O
val	double
;	O
int	O
i	int
;	O
h	double
=	O
(	O
b	double
-	O
a	double
)	O
/	O
(	O
(	O
double	O
)	O
n	int
)	O
;	O
val	double
=	O
0.0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
n	int
-	O
1	int
;	O
i	int
+=	O
2	int
)	O
val	double
+=	O
4.0	int
*	O
(	O
*	O
f	*(()->(double))
)	O
(	O
a	double
+	O
(	O
(	O
double	O
)	O
i	int
)	O
*	O
h	double
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<=	O
n	int
-	O
2	int
;	O
i	int
+=	O
2	int
)	O
val	double
+=	O
2.0	int
*	O
(	O
*	O
f	*(()->(double))
)	O
(	O
a	double
+	O
(	O
(	O
double	O
)	O
i	int
)	O
*	O
h	double
)	O
;	O
val	double
+=	O
(	O
*	O
f	*(()->(double))
)	O
(	O
a	double
)	O
+	O
(	O
*	O
f	*(()->(double))
)	O
(	O
b	double
)	O
;	O
return	O
val	double
*	O
h	double
/	O
3.0	int
;	O
}	O
static	O
double	O
dddi	double
;	O
static	O
double	O
Tfun	(double)->(double)
(	O
double	O
x	double
)	O
{	O
if	O
(	O
dddi	double
==	O
0.0	int
)	O
return	O
1.0	int
;	O
return	O
pow	(double,double)->(double)
(	O
cos	(double)->(double)
(	O
x	double
)	O
,	O
dddi	double
-	O
1.0	int
)	O
;	O
}	O
double	O
probt	(double,int)->(double)
(	O
double	O
t1	double
,	O
int	O
di	int
)	O
{	O
double	O
c	double
;	O
double	O
ddi	double
;	O
if	O
(	O
!	O
finite	(double)->(int)
(	O
t1	double
)	O
)	O
return	O
0.0	int
/	O
0.0	int
;	O
ddi	double
=	O
(	O
double	O
)	O
di	int
;	O
dddi	double
=	O
ddi	double
;	O
for	O
(	O
c	double
=	O
1.0	int
;	O
ddi	double
>	O
2.0	int
;	O
ddi	double
-=	O
2.0	int
)	O
c	double
*=	O
(	O
ddi	double
-	O
1.0	int
)	O
/	O
(	O
ddi	double
-	O
2.0	int
)	O
;	O
if	O
(	O
ddi	double
==	O
2.0	int
)	O
c	double
*=	O
0.5	int
;	O
else	O
c	double
/=	O
PI	int
;	O
return	O
c	double
*	O
dap_simp	(*(()->(double)),double,double,int)->(double)
(	O
&	O
Tfun	(double)->(double)
,	O
atan	(double)->(double)
(	O
t1	double
/	O
sqrt	(double)->(double)
(	O
dddi	double
)	O
)	O
,	O
HALFPI	int
,	O
1024	int
)	O
;	O
}	O
double	O
zpoint	(double)->(double)
(	O
double	O
p	double
)	O
{	O
static	O
double	O
a	double
[	O
4	int
]	O
=	O
{	O
2.5066282	int
,	O
-	O
18.6150006	int
,	O
41.3911977	int
,	O
-	O
25.4410605	int
}	O
;	O
static	O
double	O
b	double
[	O
4	int
]	O
=	O
{	O
-	O
8.4735109	int
,	O
23.0833674	int
,	O
-	O
21.0622410	int
,	O
3.1308291	int
}	O
;	O
static	O
double	O
c	double
[	O
4	int
]	O
=	O
{	O
-	O
2.7871893	int
,	O
-	O
2.2979648	int
,	O
4.8501413	int
,	O
2.3212128	int
}	O
;	O
static	O
double	O
d	array(double)
[	O
2	int
]	O
=	O
{	O
3.5438892	int
,	O
1.6370678	int
}	O
;	O
double	O
q	double
,	O
r	double
,	O
x	double
,	O
x0	double
;	O
q	double
=	O
p	double
-	O
0.5	int
;	O
if	O
(	O
fabs	(double)->(double)
(	O
q	double
)	O
>	O
0.42	int
)	O
{	O
r	double
=	O
p	double
;	O
if	O
(	O
q	double
>	O
0.0	int
)	O
r	double
=	O
1.0	int
-	O
p	double
;	O
if	O
(	O
r	double
<=	O
0.0	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(zpoint) input not between 0 and 1\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
r	double
=	O
sqrt	(double)->(double)
(	O
-	O
log	(double)->(double)
(	O
r	double
)	O
)	O
;	O
x	double
=	O
(	O
(	O
c	double
[	O
3	int
]	O
*	O
r	double
+	O
c	double
[	O
2	int
]	O
)	O
*	O
r	double
+	O
c	double
[	O
1	int
]	O
)	O
*	O
r	double
+	O
c	double
[	O
0	int
]	O
;	O
x0	double
=	O
x	double
/	O
(	O
(	O
d	array(double)
[	O
1	int
]	O
*	O
r	double
+	O
d	array(double)
[	O
0	int
]	O
)	O
*	O
r	double
+	O
1.0	int
)	O
;	O
if	O
(	O
q	double
<	O
0.0	int
)	O
x0	double
=	O
-	O
x0	double
;	O
}	O
else	O
{	O
r	double
=	O
q	double
*	O
q	double
;	O
x	double
=	O
q	double
*	O
(	O
(	O
(	O
a	double
[	O
3	int
]	O
*	O
r	double
+	O
a	double
[	O
2	int
]	O
)	O
*	O
r	double
+	O
a	double
[	O
1	int
]	O
)	O
*	O
r	double
+	O
a	double
[	O
0	int
]	O
)	O
;	O
x0	double
=	O
x	double
/	O
(	O
(	O
(	O
(	O
b	double
[	O
3	int
]	O
*	O
r	double
+	O
b	double
[	O
2	int
]	O
)	O
*	O
r	double
+	O
b	double
[	O
1	int
]	O
)	O
*	O
r	double
+	O
b	double
[	O
0	int
]	O
)	O
*	O
r	double
+	O
1.0	int
)	O
;	O
}	O
return	O
-	O
x0	double
;	O
}	O
double	O
tpoint	(double,int)->(double)
(	O
double	O
p	double
,	O
int	O
df	int
)	O
{	O
double	O
pt0	double
,	O
pr0	double
;	O
double	O
pt1	double
,	O
pr1	double
;	O
double	O
pt2	double
,	O
pr2	double
;	O
pt2	double
=	O
0.0	int
;	O
pt0	double
=	O
zpoint	(double)->(double)
(	O
p	double
)	O
;	O
pr0	double
=	O
probt	(double,int)->(double)
(	O
pt0	double
,	O
df	int
)	O
;	O
pt1	double
=	O
2.0	int
*	O
pt0	double
;	O
pr2	double
=	O
pr0	double
;	O
while	O
(	O
fabs	(double)->(double)
(	O
pr2	double
-	O
p	double
)	O
>	O
dap_prtol	double
)	O
{	O
pr1	double
=	O
probt	(double,int)->(double)
(	O
pt1	double
,	O
df	int
)	O
;	O
pt2	double
=	O
pt0	double
+	O
(	O
pt1	double
-	O
pt0	double
)	O
*	O
(	O
p	double
-	O
pr0	double
)	O
/	O
(	O
pr1	double
-	O
pr0	double
)	O
;	O
if	O
(	O
pt2	double
<	O
0.0	int
)	O
{	O
if	O
(	O
pt0	double
<	O
pt1	double
)	O
pt2	double
=	O
0.5	int
*	O
pt0	double
;	O
else	O
pt2	double
=	O
0.5	int
*	O
pt1	double
;	O
}	O
pr2	double
=	O
probt	(double,int)->(double)
(	O
pt2	double
,	O
df	int
)	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
pr2	double
-	O
pr0	double
)	O
<	O
fabs	(double)->(double)
(	O
pr2	double
-	O
pr1	double
)	O
)	O
{	O
pr1	double
=	O
pr2	double
;	O
pt1	double
=	O
pt2	double
;	O
}	O
else	O
{	O
pr0	double
=	O
pr2	double
;	O
pt0	double
=	O
pt2	double
;	O
}	O
}	O
return	O
pt2	double
;	O
}	O
static	O
double	O
dmpln	double
,	O
drat	double
,	O
dnm1	double
;	O
static	O
double	O
Ffun	(double)->(double)
(	O
double	O
x	double
)	O
{	O
if	O
(	O
dnm1	double
>	O
0.0	int
)	O
return	O
pow	(double,double)->(double)
(	O
x	double
,	O
dnm1	double
)	O
/	O
pow	(double,double)->(double)
(	O
1.0	int
+	O
drat	double
*	O
x	double
,	O
dmpln	double
)	O
;	O
else	O
return	O
1.0	int
/	O
pow	(double,double)->(double)
(	O
1.0	int
+	O
drat	double
*	O
x	double
,	O
dmpln	double
)	O
;	O
}	O
double	O
probf	(double,int,int)->(double)
(	O
double	O
f0	double
,	O
int	O
numdf	int
,	O
int	O
dendf	int
)	O
{	O
double	O
c	double
;	O
double	O
dm	double
,	O
dn	double
,	O
dmpn	double
;	O
double	O
ddn	double
;	O
double	O
b	double
;	O
double	O
s	double
,	O
s0	double
,	O
s1	double
,	O
s2	double
;	O
if	O
(	O
!	O
finite	(double)->(int)
(	O
f0	double
)	O
)	O
return	O
0.0	int
/	O
0.0	int
;	O
if	O
(	O
numdf	int
==	O
1	int
)	O
return	O
2.0	int
*	O
probt	(double,int)->(double)
(	O
sqrt	(double)->(double)
(	O
f0	double
)	O
,	O
dendf	int
)	O
;	O
dn	double
=	O
0.5	int
*	O
(	O
double	O
)	O
numdf	int
;	O
dm	double
=	O
0.5	int
*	O
(	O
double	O
)	O
dendf	int
;	O
dmpn	double
=	O
dn	double
+	O
dm	double
;	O
dmpln	double
=	O
dm	double
+	O
dn	double
;	O
dnm1	double
=	O
dn	double
-	O
1.0	int
;	O
drat	double
=	O
dn	double
/	O
dm	double
;	O
ddn	double
=	O
dn	double
;	O
for	O
(	O
c	double
=	O
1.0	int
;	O
dmpn	double
>=	O
0.5	int
;	O
)	O
{	O
dm	double
-=	O
1.0	int
;	O
dn	double
-=	O
1.0	int
;	O
dmpn	double
-=	O
1.0	int
;	O
if	O
(	O
dm	double
>	O
0.0	int
)	O
c	double
/=	O
dm	double
;	O
else	O
if	O
(	O
dm	double
==	O
-	O
0.5	int
)	O
c	double
/=	O
SQRTPI	int
;	O
if	O
(	O
dn	double
>	O
0.0	int
)	O
c	double
/=	O
dn	double
;	O
else	O
if	O
(	O
dn	double
==	O
-	O
0.5	int
)	O
c	double
/=	O
SQRTPI	int
;	O
if	O
(	O
dmpn	double
>	O
0.0	int
)	O
c	double
*=	O
dmpn	double
;	O
else	O
if	O
(	O
dmpn	double
==	O
-	O
0.5	int
)	O
c	double
*=	O
SQRTPI	int
;	O
}	O
c	double
*=	O
pow	(double,double)->(double)
(	O
drat	double
,	O
ddn	double
)	O
;	O
for	O
(	O
b	double
=	O
1.0	int
;	O
f0	double
>=	O
b	double
;	O
b	double
*=	O
2.0	int
)	O
;	O
s	double
=	O
dap_simp	(*(()->(double)),double,double,int)->(double)
(	O
&	O
Ffun	(double)->(double)
,	O
f0	double
,	O
b	double
,	O
1024	int
)	O
;	O
s0	double
=	O
dap_simp	(*(()->(double)),double,double,int)->(double)
(	O
&	O
Ffun	(double)->(double)
,	O
b	double
,	O
2.0	int
*	O
b	double
,	O
1024	int
)	O
;	O
b	double
*=	O
2.0	int
;	O
s1	double
=	O
dap_simp	(*(()->(double)),double,double,int)->(double)
(	O
&	O
Ffun	(double)->(double)
,	O
b	double
,	O
2.0	int
*	O
b	double
,	O
1024	int
)	O
;	O
b	double
*=	O
2.0	int
;	O
s2	double
=	O
dap_simp	(*(()->(double)),double,double,int)->(double)
(	O
&	O
Ffun	(double)->(double)
,	O
b	double
,	O
2.0	int
*	O
b	double
,	O
1024	int
)	O
;	O
s	double
+=	O
s0	double
+	O
s1	double
+	O
s2	double
;	O
while	O
(	O
s2	double
<	O
s1	double
&&	O
(	O
s2	double
*	O
s2	double
/	O
(	O
s1	double
-	O
s2	double
)	O
>	O
5.0e-11	int
/	O
c	double
)	O
)	O
{	O
b	double
*=	O
2.0	int
;	O
s0	double
=	O
s1	double
;	O
s1	double
=	O
s2	double
;	O
s2	double
=	O
dap_simp	(*(()->(double)),double,double,int)->(double)
(	O
&	O
Ffun	(double)->(double)
,	O
b	double
,	O
2.0	int
*	O
b	double
,	O
1024	int
)	O
;	O
s	double
+=	O
s2	double
;	O
}	O
return	O
c	double
*	O
s	double
;	O
}	O
double	O
fpoint	(double,int,int)->(double)
(	O
double	O
p	double
,	O
int	O
numdf	int
,	O
int	O
dendf	int
)	O
{	O
double	O
pt0	double
,	O
pr0	double
;	O
double	O
pt1	double
,	O
pr1	double
;	O
double	O
pt2	double
,	O
pr2	double
;	O
pt2	double
=	O
0.0	int
;	O
pt0	double
=	O
(	O
(	O
double	O
)	O
numdf	int
)	O
/	O
(	O
(	O
double	O
)	O
dendf	int
)	O
;	O
pr0	double
=	O
probf	(double,int,int)->(double)
(	O
pt0	double
,	O
numdf	int
,	O
dendf	int
)	O
;	O
pt1	double
=	O
2.0	int
*	O
pt0	double
;	O
pr2	double
=	O
1.0	int
;	O
while	O
(	O
fabs	(double)->(double)
(	O
pr2	double
-	O
p	double
)	O
>	O
dap_prtol	double
)	O
{	O
pr1	double
=	O
probf	(double,int,int)->(double)
(	O
pt1	double
,	O
numdf	int
,	O
dendf	int
)	O
;	O
pt2	double
=	O
pt0	double
+	O
(	O
pt1	double
-	O
pt0	double
)	O
*	O
(	O
p	double
-	O
pr0	double
)	O
/	O
(	O
pr1	double
-	O
pr0	double
)	O
;	O
if	O
(	O
pt2	double
<	O
0.0	int
)	O
{	O
if	O
(	O
pt0	double
<	O
pt1	double
)	O
pt2	double
=	O
0.5	int
*	O
pt0	double
;	O
else	O
pt2	double
=	O
0.5	int
*	O
pt1	double
;	O
}	O
pr2	double
=	O
probf	(double,int,int)->(double)
(	O
pt2	double
,	O
numdf	int
,	O
dendf	int
)	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
pr2	double
-	O
pr0	double
)	O
<	O
fabs	(double)->(double)
(	O
pr2	double
-	O
pr1	double
)	O
)	O
{	O
pr1	double
=	O
pr2	double
;	O
pt1	double
=	O
pt2	double
;	O
}	O
else	O
{	O
pr0	double
=	O
pr2	double
;	O
pt0	double
=	O
pt2	double
;	O
}	O
}	O
return	O
pt2	double
;	O
}	O
static	O
double	O
randmax	double
=	O
2147483647.0	int
;	O
double	O
varnorm	()->(double)
(	O
)	O
{	O
double	O
u1	double
,	O
u2	double
,	O
v1	double
,	O
v2	double
,	O
w	double
;	O
do	O
{	O
u1	double
=	O
2.0	int
*	O
(	O
(	O
double	O
)	O
random	()->(long)
(	O
)	O
)	O
/	O
randmax	double
-	O
1.0	int
;	O
v1	double
=	O
u1	double
*	O
u1	double
;	O
u2	double
=	O
2.0	int
*	O
(	O
(	O
double	O
)	O
random	()->(long)
(	O
)	O
)	O
/	O
randmax	double
-	O
1.0	int
;	O
v2	double
=	O
u2	double
*	O
u2	double
;	O
}	O
while	O
(	O
(	O
w	double
=	O
v1	double
+	O
v2	double
)	O
>	O
1.0	int
)	O
;	O
w	double
=	O
sqrt	(double)->(double)
(	O
-	O
2.0	int
*	O
log	(double)->(double)
(	O
w	double
)	O
/	O
w	double
)	O
;	O
return	O
u1	double
*	O
w	double
;	O
}	O
double	O
varunif	()->(double)
(	O
)	O
{	O
return	O
(	O
(	O
double	O
)	O
random	()->(long)
(	O
)	O
)	O
/	O
randmax	double
;	O
}	O
double	O
probz	(double)->(double)
(	O
double	O
z	double
)	O
{	O
if	O
(	O
!	O
finite	(double)->(int)
(	O
z	double
)	O
)	O
return	O
0.0	int
/	O
0.0	int
;	O
z	double
*=	O
SQRTHALF	int
;	O
if	O
(	O
z	double
<	O
-	O
0.58	int
)	O
return	O
0.5	int
*	O
erfc	(double)->(double)
(	O
-	O
z	double
)	O
;	O
if	O
(	O
z	double
<	O
0.0	int
)	O
return	O
0.5	int
*	O
(	O
1.0	int
-	O
erf	(double)->(double)
(	O
-	O
z	double
)	O
)	O
;	O
if	O
(	O
z	double
<	O
0.58	int
)	O
return	O
0.5	int
*	O
(	O
1.0	int
+	O
erf	(double)->(double)
(	O
z	double
)	O
)	O
;	O
return	O
1.0	int
-	O
0.5	int
*	O
erfc	(double)->(double)
(	O
z	double
)	O
;	O
}	O
double	O
probchisq	(double,int)->(double)
(	O
double	O
c	double
,	O
int	O
df	int
)	O
{	O
double	O
ddf	double
;	O
double	O
tmp	double
;	O
if	O
(	O
df	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(probchisq) non-positive df = %d\n"	*(char)
,	O
df	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
finite	(double)->(int)
(	O
c	double
)	O
)	O
return	O
0.0	int
/	O
0.0	int
;	O
switch	O
(	O
df	int
)	O
{	O
case	O
1	int
:	O
return	O
2.0	int
*	O
probz	(double)->(double)
(	O
-	O
sqrt	(double)->(double)
(	O
c	double
)	O
)	O
;	O
case	O
2	int
:	O
return	O
exp	(double)->(double)
(	O
-	O
0.5	int
*	O
c	double
)	O
;	O
default	O
:	O
ddf	double
=	O
(	O
double	O
)	O
df	int
;	O
tmp	double
=	O
(	O
0.5	int
*	O
ddf	double
-	O
1.0	int
)	O
*	O
log	(double)->(double)
(	O
0.5	int
*	O
c	double
)	O
-	O
0.5	int
*	O
c	double
-	O
lgamma	(double)->(double)
(	O
0.5	int
*	O
ddf	double
)	O
;	O
if	O
(	O
finite	(double)->(int)
(	O
tmp	double
)	O
)	O
return	O
exp	(double)->(double)
(	O
tmp	double
)	O
+	O
probchisq	(double,int)->(double)
(	O
c	double
,	O
df	int
-	O
2	int
)	O
;	O
return	O
0.0	int
;	O
break	O
;	O
}	O
}	O
double	O
chisqpoint	(double,int)->(double)
(	O
double	O
p	double
,	O
int	O
df	int
)	O
{	O
double	O
pt0	double
,	O
pr0	double
;	O
double	O
pt1	double
,	O
pr1	double
;	O
double	O
pt2	double
,	O
pr2	double
;	O
pt2	double
=	O
0.0	int
;	O
pt0	double
=	O
(	O
double	O
)	O
df	int
;	O
pr0	double
=	O
probchisq	(double,int)->(double)
(	O
pt0	double
,	O
df	int
)	O
;	O
pt1	double
=	O
2.0	int
*	O
pt0	double
;	O
pr2	double
=	O
1.0	int
;	O
while	O
(	O
fabs	(double)->(double)
(	O
pr2	double
-	O
p	double
)	O
>	O
dap_prtol	double
)	O
{	O
pr1	double
=	O
probchisq	(double,int)->(double)
(	O
pt1	double
,	O
df	int
)	O
;	O
pt2	double
=	O
pt0	double
+	O
(	O
pt1	double
-	O
pt0	double
)	O
*	O
(	O
p	double
-	O
pr0	double
)	O
/	O
(	O
pr1	double
-	O
pr0	double
)	O
;	O
if	O
(	O
pt2	double
<	O
0.0	int
)	O
{	O
if	O
(	O
pt0	double
<	O
pt1	double
)	O
pt2	double
=	O
0.5	int
*	O
pt0	double
;	O
else	O
pt2	double
=	O
0.5	int
*	O
pt1	double
;	O
}	O
pr2	double
=	O
probchisq	(double,int)->(double)
(	O
pt2	double
,	O
df	int
)	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
pr2	double
-	O
pr0	double
)	O
<	O
fabs	(double)->(double)
(	O
pr2	double
-	O
pr1	double
)	O
)	O
{	O
pr1	double
=	O
pr2	double
;	O
pt1	double
=	O
pt2	double
;	O
}	O
else	O
{	O
pr0	double
=	O
pr2	double
;	O
pt0	double
=	O
pt2	double
;	O
}	O
}	O
return	O
pt2	double
;	O
}	O
static	O
double	O
w	double
;	O
static	O
double	O
numdfm1	double
,	O
dendfm1	double
;	O
static	O
double	O
dnumdf	double
,	O
ddendf	double
;	O
static	O
double	O
pt	double
;	O
double	O
rangef1	(double)->(double)
(	O
double	O
x0	double
)	O
{	O
double	O
diff	double
;	O
double	O
x	double
,	O
x1	double
,	O
x2	double
;	O
double	O
tmp	double
;	O
if	O
(	O
x0	double
==	O
-	O
1.0	int
)	O
return	O
0.0	int
;	O
x1	double
=	O
1.0	int
+	O
x0	double
;	O
x	double
=	O
x0	double
/	O
x1	double
;	O
x2	double
=	O
x1	double
*	O
x1	double
;	O
diff	double
=	O
probz	(double)->(double)
(	O
x	double
+	O
w	double
)	O
-	O
probz	(double)->(double)
(	O
x	double
)	O
;	O
if	O
(	O
diff	double
/	O
x2	double
<	O
1.0e-16	int
)	O
return	O
0.0	int
;	O
tmp	double
=	O
-	O
0.5	int
*	O
x	double
*	O
x	double
+	O
numdfm1	double
*	O
log	(double)->(double)
(	O
diff	double
)	O
;	O
if	O
(	O
finite	(double)->(int)
(	O
tmp	double
)	O
)	O
return	O
exp	(double)->(double)
(	O
tmp	double
)	O
/	O
(	O
x1	double
*	O
x1	double
)	O
;	O
return	O
0.0	int
;	O
}	O
double	O
rangef2	(double)->(double)
(	O
double	O
x0	double
)	O
{	O
double	O
diff	double
;	O
double	O
x	double
,	O
x1	double
,	O
x2	double
;	O
double	O
tmp	double
;	O
if	O
(	O
x0	double
==	O
1.0	int
)	O
return	O
0.0	int
;	O
x1	double
=	O
1.0	int
-	O
x0	double
;	O
x	double
=	O
x0	double
/	O
x1	double
;	O
x2	double
=	O
x1	double
*	O
x1	double
;	O
diff	double
=	O
probz	(double)->(double)
(	O
x	double
+	O
w	double
)	O
-	O
probz	(double)->(double)
(	O
x	double
)	O
;	O
if	O
(	O
diff	double
/	O
x2	double
<	O
1.0e-16	int
)	O
return	O
0.0	int
;	O
tmp	double
=	O
-	O
0.5	int
*	O
x	double
*	O
x	double
+	O
numdfm1	double
*	O
log	(double)->(double)
(	O
diff	double
)	O
;	O
if	O
(	O
finite	(double)->(int)
(	O
tmp	double
)	O
)	O
return	O
exp	(double)->(double)
(	O
tmp	double
)	O
/	O
(	O
x1	double
*	O
x1	double
)	O
;	O
return	O
0.0	int
;	O
}	O
static	O
double	O
range	(double)->(double)
(	O
double	O
w0	double
)	O
{	O
w	double
=	O
w0	double
;	O
return	O
1.0	int
-	O
dnumdf	double
*	O
INVSQ2PI	int
*	O
(	O
dap_simp	(*(()->(double)),double,double,int)->(double)
(	O
&	O
rangef1	(double)->(double)
,	O
-	O
1.0	int
,	O
0.0	int
,	O
32	int
)	O
+	O
dap_simp	(*(()->(double)),double,double,int)->(double)
(	O
&	O
rangef2	(double)->(double)
,	O
0.0	int
,	O
1.0	int
,	O
32	int
)	O
)	O
;	O
}	O
static	O
double	O
sturf	(double)->(double)
(	O
double	O
s0	double
)	O
{	O
double	O
s	double
;	O
double	O
s1	double
;	O
double	O
tmp	double
;	O
if	O
(	O
s0	double
==	O
1.0	int
)	O
return	O
0.0	int
;	O
s1	double
=	O
1.0	int
-	O
s0	double
;	O
s	double
=	O
s0	double
/	O
s1	double
;	O
if	O
(	O
dendfm1	double
==	O
0.0	int
)	O
return	O
exp	(double)->(double)
(	O
-	O
0.5	int
*	O
s	double
*	O
s	double
/	O
E	int
)	O
*	O
range	(double)->(double)
(	O
pt	double
*	O
s	double
*	O
INVSQRTE	int
)	O
/	O
(	O
s1	double
*	O
s1	double
)	O
;	O
tmp	double
=	O
dendfm1	double
*	O
log	(double)->(double)
(	O
s	double
)	O
-	O
0.5	int
*	O
ddendf	double
*	O
s	double
*	O
s	double
/	O
E	int
;	O
if	O
(	O
finite	(double)->(int)
(	O
tmp	double
)	O
)	O
return	O
exp	(double)->(double)
(	O
tmp	double
)	O
*	O
range	(double)->(double)
(	O
pt	double
*	O
s	double
*	O
INVSQRTE	int
)	O
/	O
(	O
s1	double
*	O
s1	double
)	O
;	O
return	O
0.0	int
;	O
}	O
double	O
dap_sr	(int,int,double)->(double)
(	O
int	O
numdf	int
,	O
int	O
dendf	int
,	O
double	O
pt0	double
)	O
{	O
double	O
c	double
;	O
double	O
dn	double
,	O
dn1	double
;	O
pt	double
=	O
pt0	double
;	O
dnumdf	double
=	O
(	O
double	O
)	O
numdf	int
;	O
numdfm1	double
=	O
(	O
double	O
)	O
(	O
dnumdf	double
-	O
1	int
)	O
;	O
ddendf	double
=	O
(	O
double	O
)	O
dendf	int
;	O
dendfm1	double
=	O
(	O
double	O
)	O
(	O
dendf	int
-	O
1	int
)	O
;	O
for	O
(	O
dn	double
=	O
0.5	int
*	O
ddendf	double
,	O
dn1	double
=	O
dn	double
*	O
INVE	int
,	O
c	double
=	O
2.0	int
;	O
dn	double
>	O
1.0	int
;	O
dn	double
-=	O
1.0	int
)	O
c	double
*=	O
dn1	double
/	O
(	O
dn	double
-	O
1.0	int
)	O
;	O
if	O
(	O
dn	double
==	O
0.5	int
)	O
c	double
*=	O
sqrt	(double)->(double)
(	O
dn1	double
)	O
/	O
SQRTPI	int
;	O
else	O
c	double
*=	O
dn1	double
;	O
return	O
c	double
*	O
dap_simp	(*(()->(double)),double,double,int)->(double)
(	O
&	O
sturf	(double)->(double)
,	O
0.0	int
,	O
1.0	int
,	O
64	int
)	O
;	O
}	O
double	O
dap_srpt	(int,int,double,double,double)->(double)
(	O
int	O
numdf	int
,	O
int	O
dendf	int
,	O
double	O
pt0	double
,	O
double	O
pr0	double
,	O
double	O
alpha	double
)	O
{	O
double	O
pt1	double
,	O
pr1	double
;	O
double	O
pt2	double
,	O
pr2	double
;	O
pt2	double
=	O
0.0	int
;	O
if	O
(	O
alpha	double
<	O
pr0	double
)	O
pt1	double
=	O
2.0	int
*	O
pt0	double
;	O
else	O
pt1	double
=	O
0.5	int
*	O
pt0	double
;	O
pr2	double
=	O
1.0	int
;	O
while	O
(	O
fabs	(double)->(double)
(	O
pr2	double
-	O
alpha	double
)	O
>	O
dap_prtol	double
)	O
{	O
pr1	double
=	O
dap_sr	(int,int,double)->(double)
(	O
numdf	int
,	O
dendf	int
,	O
pt1	double
)	O
;	O
pt2	double
=	O
pt0	double
+	O
(	O
pt1	double
-	O
pt0	double
)	O
*	O
(	O
alpha	double
-	O
pr0	double
)	O
/	O
(	O
pr1	double
-	O
pr0	double
)	O
;	O
if	O
(	O
pt2	double
<	O
0.0	int
)	O
{	O
if	O
(	O
pt0	double
<	O
pt1	double
)	O
pt2	double
=	O
0.5	int
*	O
pt0	double
;	O
else	O
pt2	double
=	O
0.5	int
*	O
pt1	double
;	O
}	O
pr2	double
=	O
dap_sr	(int,int,double)->(double)
(	O
numdf	int
,	O
dendf	int
,	O
pt2	double
)	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
pr2	double
-	O
pr0	double
)	O
<	O
fabs	(double)->(double)
(	O
pr2	double
-	O
pr1	double
)	O
)	O
{	O
pr1	double
=	O
pr2	double
;	O
pt1	double
=	O
pt2	double
;	O
}	O
else	O
{	O
pr0	double
=	O
pr2	double
;	O
pt0	double
=	O
pt2	double
;	O
}	O
}	O
return	O
pt2	double
;	O
}	O
double	O
maxdf1	(double)->(double)
(	O
double	O
x0	double
)	O
{	O
double	O
diff	double
;	O
double	O
x	double
,	O
x1	double
,	O
x2	double
;	O
if	O
(	O
x0	double
==	O
-	O
1.0	int
)	O
return	O
0.0	int
;	O
x1	double
=	O
1.0	int
+	O
x0	double
;	O
x	double
=	O
x0	double
/	O
x1	double
;	O
x2	double
=	O
x1	double
*	O
x1	double
;	O
diff	double
=	O
probz	(double)->(double)
(	O
x	double
+	O
w	double
)	O
-	O
probz	(double)->(double)
(	O
x	double
-	O
w	double
)	O
;	O
if	O
(	O
diff	double
/	O
x2	double
<	O
1.0e-16	int
)	O
return	O
0.0	int
;	O
return	O
exp	(double)->(double)
(	O
-	O
0.5	int
*	O
x	double
*	O
x	double
+	O
dnumdf	double
*	O
log	(double)->(double)
(	O
diff	double
)	O
)	O
/	O
(	O
x1	double
*	O
x1	double
)	O
;	O
}	O
double	O
maxdf2	(double)->(double)
(	O
double	O
x0	double
)	O
{	O
double	O
diff	double
;	O
double	O
x	double
,	O
x1	double
,	O
x2	double
;	O
if	O
(	O
x0	double
==	O
1.0	int
)	O
return	O
0.0	int
;	O
x1	double
=	O
1.0	int
-	O
x0	double
;	O
x	double
=	O
x0	double
/	O
x1	double
;	O
x2	double
=	O
x1	double
*	O
x1	double
;	O
diff	double
=	O
probz	(double)->(double)
(	O
x	double
+	O
w	double
)	O
-	O
probz	(double)->(double)
(	O
x	double
-	O
w	double
)	O
;	O
if	O
(	O
diff	double
/	O
x2	double
<	O
1.0e-16	int
)	O
return	O
0.0	int
;	O
return	O
exp	(double)->(double)
(	O
-	O
0.5	int
*	O
x	double
*	O
x	double
+	O
dnumdf	double
*	O
log	(double)->(double)
(	O
diff	double
)	O
)	O
/	O
(	O
x1	double
*	O
x1	double
)	O
;	O
}	O
static	O
double	O
maxdf	(double)->(double)
(	O
double	O
w0	double
)	O
{	O
w	double
=	O
w0	double
;	O
return	O
1.0	int
-	O
INVSQ2PI	int
*	O
(	O
dap_simp	(*(()->(double)),double,double,int)->(double)
(	O
&	O
maxdf1	(double)->(double)
,	O
-	O
1.0	int
,	O
0.0	int
,	O
32	int
)	O
+	O
dap_simp	(*(()->(double)),double,double,int)->(double)
(	O
&	O
maxdf2	(double)->(double)
,	O
0.0	int
,	O
1.0	int
,	O
32	int
)	O
)	O
;	O
}	O
static	O
double	O
maxdiff	(double)->(double)
(	O
double	O
s0	double
)	O
{	O
double	O
s	double
;	O
double	O
s1	double
;	O
if	O
(	O
s0	double
==	O
1.0	int
)	O
return	O
0.0	int
;	O
s1	double
=	O
1.0	int
-	O
s0	double
;	O
s	double
=	O
s0	double
/	O
s1	double
;	O
if	O
(	O
dendfm1	double
==	O
0.0	int
)	O
return	O
exp	(double)->(double)
(	O
-	O
0.5	int
*	O
s	double
*	O
s	double
/	O
E	int
)	O
*	O
maxdf	(double)->(double)
(	O
pt	double
*	O
s	double
*	O
INVSQRTE	int
)	O
/	O
(	O
s1	double
*	O
s1	double
)	O
;	O
return	O
exp	(double)->(double)
(	O
dendfm1	double
*	O
log	(double)->(double)
(	O
s	double
)	O
-	O
0.5	int
*	O
ddendf	double
*	O
s	double
*	O
s	double
/	O
E	int
)	O
*	O
maxdf	(double)->(double)
(	O
pt	double
*	O
s	double
*	O
INVSQRTE	int
)	O
/	O
(	O
s1	double
*	O
s1	double
)	O
;	O
}	O
double	O
dap_md	(int,int,double)->(double)
(	O
int	O
numdf	int
,	O
int	O
dendf	int
,	O
double	O
pt0	double
)	O
{	O
double	O
c	double
;	O
double	O
dn	double
,	O
dn1	double
;	O
pt	double
=	O
pt0	double
;	O
dnumdf	double
=	O
(	O
double	O
)	O
numdf	int
;	O
numdfm1	double
=	O
(	O
double	O
)	O
(	O
dnumdf	double
-	O
1	int
)	O
;	O
ddendf	double
=	O
(	O
double	O
)	O
dendf	int
;	O
dendfm1	double
=	O
(	O
double	O
)	O
(	O
dendf	int
-	O
1	int
)	O
;	O
for	O
(	O
dn	double
=	O
0.5	int
*	O
ddendf	double
,	O
dn1	double
=	O
dn	double
*	O
INVE	int
,	O
c	double
=	O
2.0	int
;	O
dn	double
>	O
1.0	int
;	O
dn	double
-=	O
1.0	int
)	O
c	double
*=	O
dn1	double
/	O
(	O
dn	double
-	O
1.0	int
)	O
;	O
if	O
(	O
dn	double
==	O
0.5	int
)	O
c	double
*=	O
sqrt	(double)->(double)
(	O
dn1	double
)	O
/	O
SQRTPI	int
;	O
else	O
c	double
*=	O
dn1	double
;	O
return	O
c	double
*	O
dap_simp	(*(()->(double)),double,double,int)->(double)
(	O
&	O
maxdiff	(double)->(double)
,	O
0.0	int
,	O
1.0	int
,	O
256	int
)	O
;	O
}	O
double	O
dap_mdpt	(int,int,double,double,double)->(double)
(	O
int	O
numdf	int
,	O
int	O
dendf	int
,	O
double	O
pt0	double
,	O
double	O
pr0	double
,	O
double	O
alpha	double
)	O
{	O
double	O
pt1	double
,	O
pr1	double
;	O
double	O
pt2	double
,	O
pr2	double
;	O
pt2	double
=	O
0.0	int
;	O
if	O
(	O
alpha	double
<	O
pr0	double
)	O
pt1	double
=	O
2.0	int
*	O
pt0	double
;	O
else	O
pt1	double
=	O
0.5	int
*	O
pt0	double
;	O
pr2	double
=	O
1.0	int
;	O
while	O
(	O
fabs	(double)->(double)
(	O
pr2	double
-	O
alpha	double
)	O
>	O
dap_prtol	double
)	O
{	O
pr1	double
=	O
dap_md	(int,int,double)->(double)
(	O
numdf	int
,	O
dendf	int
,	O
pt1	double
)	O
;	O
pt2	double
=	O
pt0	double
+	O
(	O
pt1	double
-	O
pt0	double
)	O
*	O
(	O
alpha	double
-	O
pr0	double
)	O
/	O
(	O
pr1	double
-	O
pr0	double
)	O
;	O
if	O
(	O
pt2	double
<	O
0.0	int
)	O
{	O
if	O
(	O
pt0	double
<	O
pt1	double
)	O
pt2	double
=	O
0.5	int
*	O
pt0	double
;	O
else	O
pt2	double
=	O
0.5	int
*	O
pt1	double
;	O
}	O
pr2	double
=	O
dap_md	(int,int,double)->(double)
(	O
numdf	int
,	O
dendf	int
,	O
pt2	double
)	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
pr2	double
-	O
pr0	double
)	O
<	O
fabs	(double)->(double)
(	O
pr2	double
-	O
pr1	double
)	O
)	O
{	O
pr1	double
=	O
pr2	double
;	O
pt1	double
=	O
pt2	double
;	O
}	O
else	O
{	O
pr0	double
=	O
pr2	double
;	O
pt0	double
=	O
pt2	double
;	O
}	O
}	O
return	O
pt2	double
;	O
}	O
