inline	O
static	O
double	O
debye_u1	(*(double))->(double)
(	O
const	O
double	O
*	O
tpow	*(double)
)	O
{	O
return	O
(	O
3.0	int
*	O
tpow	*(double)
[	O
1	int
]	O
-	O
5.0	int
*	O
tpow	*(double)
[	O
3	int
]	O
)	O
/	O
24.0	int
;	O
}	O
inline	O
static	O
double	O
debye_u2	(*(double))->(double)
(	O
const	O
double	O
*	O
tpow	*(double)
)	O
{	O
return	O
(	O
81.0	int
*	O
tpow	*(double)
[	O
2	int
]	O
-	O
462.0	int
*	O
tpow	*(double)
[	O
4	int
]	O
+	O
385.0	int
*	O
tpow	*(double)
[	O
6	int
]	O
)	O
/	O
1152.0	int
;	O
}	O
inline	O
static	O
double	O
debye_u3	(*(double))->(double)
(	O
const	O
double	O
*	O
tpow	*(double)
)	O
{	O
return	O
(	O
30375.0	int
*	O
tpow	*(double)
[	O
3	int
]	O
-	O
369603.0	int
*	O
tpow	*(double)
[	O
5	int
]	O
+	O
765765.0	int
*	O
tpow	*(double)
[	O
7	int
]	O
-	O
425425.0	int
*	O
tpow	*(double)
[	O
9	int
]	O
)	O
/	O
414720.0	int
;	O
}	O
inline	O
static	O
double	O
debye_u4	(*(double))->(double)
(	O
const	O
double	O
*	O
tpow	*(double)
)	O
{	O
return	O
(	O
4465125.0	int
*	O
tpow	*(double)
[	O
4	int
]	O
-	O
94121676.0	int
*	O
tpow	*(double)
[	O
6	int
]	O
+	O
349922430.0	int
*	O
tpow	*(double)
[	O
8	int
]	O
-	O
446185740.0	int
*	O
tpow	*(double)
[	O
10	int
]	O
+	O
185910725.0	int
*	O
tpow	*(double)
[	O
12	int
]	O
)	O
/	O
39813120.0	int
;	O
}	O
inline	O
static	O
double	O
debye_u5	(*(double))->(double)
(	O
const	O
double	O
*	O
tpow	*(double)
)	O
{	O
return	O
(	O
1519035525.0	int
*	O
tpow	*(double)
[	O
5	int
]	O
-	O
49286948607.0	int
*	O
tpow	*(double)
[	O
7	int
]	O
+	O
284499769554.0	int
*	O
tpow	*(double)
[	O
9	int
]	O
-	O
614135872350.0	int
*	O
tpow	*(double)
[	O
11	int
]	O
+	O
566098157625.0	int
*	O
tpow	*(double)
[	O
13	int
]	O
-	O
188699385875.0	int
*	O
tpow	*(double)
[	O
15	int
]	O
)	O
/	O
6688604160.0	int
;	O
}	O
int	O
gsl_sf_bessel_IJ_taylor_e	(double,double,int,int,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
nu	double
,	O
const	O
double	O
x	double
,	O
const	O
int	O
sign	int
,	O
const	O
int	O
kmax	int
,	O
const	O
double	O
threshold	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
nu	double
<	O
0.0	int
||	O
x	double
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
if	O
(	O
nu	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
}	O
else	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
prefactor	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
sum	struct(double,double)
;	O
int	O
stat_pre	int
;	O
int	O
stat_sum	int
;	O
int	O
stat_mul	int
;	O
if	O
(	O
nu	double
==	O
0.0	int
)	O
{	O
prefactor	struct(double,double)
.	O
val	double
=	O
1.0	int
;	O
prefactor	struct(double,double)
.	O
err	double
=	O
0.0	int
;	O
stat_pre	int
=	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
nu	double
<	O
INT_MAX	O
-	O
1	int
)	O
{	O
const	O
int	O
N	int
=	O
(	O
int	O
)	O
floor	(double)->(double)
(	O
nu	double
+	O
0.5	int
)	O
;	O
const	O
double	O
f	*(double)
=	O
nu	double
-	O
N	int
;	O
gsl_sf_result	struct(double,double)
poch_factor	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
tc_factor	struct(double,double)
;	O
const	O
int	O
stat_poch	int
=	O
gsl_sf_poch_e	(double,double,*(struct(double,double)))->(int)
(	O
N	int
+	O
1.0	int
,	O
f	*(double)
,	O
&	O
poch_factor	struct(double,double)
)	O
;	O
const	O
int	O
stat_tc	int
=	O
gsl_sf_taylorcoeff_e	(int,double,*(struct(double,double)))->(int)
(	O
N	int
,	O
0.5	int
*	O
x	double
,	O
&	O
tc_factor	struct(double,double)
)	O
;	O
const	O
double	O
p	double
=	O
pow	(double,double)->(double)
(	O
0.5	int
*	O
x	double
,	O
f	*(double)
)	O
;	O
prefactor	struct(double,double)
.	O
val	double
=	O
tc_factor	struct(double,double)
.	O
val	double
*	O
p	double
/	O
poch_factor	struct(double,double)
.	O
val	double
;	O
prefactor	struct(double,double)
.	O
err	double
=	O
tc_factor	struct(double,double)
.	O
err	double
*	O
p	double
/	O
poch_factor	struct(double,double)
.	O
val	double
;	O
prefactor	struct(double,double)
.	O
err	double
+=	O
fabs	(double)->(double)
(	O
prefactor	struct(double,double)
.	O
val	double
)	O
/	O
poch_factor	struct(double,double)
.	O
val	double
*	O
poch_factor	struct(double,double)
.	O
err	double
;	O
prefactor	struct(double,double)
.	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
prefactor	struct(double,double)
.	O
val	double
)	O
;	O
stat_pre	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_tc	int
,	O
stat_poch	int
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
lg	struct(double,double)
;	O
const	O
int	O
stat_lg	int
=	O
gsl_sf_lngamma_e	(double,*(struct(double,double)))->(int)
(	O
nu	double
+	O
1.0	int
,	O
&	O
lg	struct(double,double)
)	O
;	O
const	O
double	O
term1	double
=	O
nu	double
*	O
log	(double)->(double)
(	O
0.5	int
*	O
x	double
)	O
;	O
const	O
double	O
term2	double
=	O
lg	struct(double,double)
.	O
val	double
;	O
const	O
double	O
ln_pre	double
=	O
term1	double
-	O
term2	double
;	O
const	O
double	O
ln_pre_err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
term1	double
)	O
+	O
fabs	(double)->(double)
(	O
term2	double
)	O
)	O
+	O
lg	struct(double,double)
.	O
err	double
;	O
const	O
int	O
stat_ex	int
=	O
gsl_sf_exp_err_e	(double,double,*(struct(double,double)))->(int)
(	O
ln_pre	double
,	O
ln_pre_err	double
,	O
&	O
prefactor	struct(double,double)
)	O
;	O
stat_pre	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_ex	int
,	O
stat_lg	int
)	O
;	O
}	O
{	O
const	O
double	O
y	double
=	O
sign	int
*	O
0.25	int
*	O
x	double
*	O
x	double
;	O
double	O
sumk	double
=	O
1.0	int
;	O
double	O
term	double
=	O
1.0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
kmax	int
;	O
k	int
++	O
)	O
{	O
term	double
*=	O
y	double
/	O
(	O
(	O
nu	double
+	O
k	int
)	O
*	O
k	int
)	O
;	O
sumk	double
+=	O
term	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
term	double
/	O
sumk	double
)	O
<	O
threshold	double
)	O
break	O
;	O
}	O
sum	struct(double,double)
.	O
val	double
=	O
sumk	double
;	O
sum	struct(double,double)
.	O
err	double
=	O
threshold	double
*	O
fabs	(double)->(double)
(	O
sumk	double
)	O
;	O
stat_sum	int
=	O
(	O
k	int
>=	O
kmax	int
?	O
GSL_EMAXITER	int
:	O
GSL_SUCCESS	int
)	O
;	O
}	O
stat_mul	int
=	O
gsl_sf_multiply_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
prefactor	struct(double,double)
.	O
val	double
,	O
prefactor	struct(double,double)
.	O
err	double
,	O
sum	struct(double,double)
.	O
val	double
,	O
sum	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_mul	int
,	O
stat_pre	int
,	O
stat_sum	int
)	O
;	O
}	O
}	O
int	O
gsl_sf_bessel_Jnu_asympx_e	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
nu	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
mu	double
=	O
4.0	int
*	O
nu	double
*	O
nu	double
;	O
double	O
chi	double
=	O
x	double
-	O
(	O
0.5	int
*	O
nu	double
+	O
0.25	int
)	O
*	O
M_PI	int
;	O
double	O
P	*(double)
=	O
0.0	int
;	O
double	O
Q	*(double)
=	O
0.0	int
;	O
double	O
k	int
=	O
0	int
,	O
t	double
=	O
1	int
;	O
int	O
convP	int
,	O
convQ	int
;	O
do	O
{	O
t	double
*=	O
(	O
k	int
==	O
0	int
)	O
?	O
1	int
:	O
-	O
(	O
mu	double
-	O
(	O
2	int
*	O
k	int
-	O
1	int
)	O
*	O
(	O
2	int
*	O
k	int
-	O
1	int
)	O
)	O
/	O
(	O
k	int
*	O
(	O
8	int
*	O
x	double
)	O
)	O
;	O
convP	int
=	O
fabs	(double)->(double)
(	O
t	double
)	O
<	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
P	*(double)
)	O
;	O
P	*(double)
+=	O
t	double
;	O
k	int
++	O
;	O
t	double
*=	O
(	O
mu	double
-	O
(	O
2	int
*	O
k	int
-	O
1	int
)	O
*	O
(	O
2	int
*	O
k	int
-	O
1	int
)	O
)	O
/	O
(	O
k	int
*	O
(	O
8	int
*	O
x	double
)	O
)	O
;	O
convQ	int
=	O
fabs	(double)->(double)
(	O
t	double
)	O
<	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
Q	*(double)
)	O
;	O
Q	*(double)
+=	O
t	double
;	O
if	O
(	O
convP	int
&&	O
convQ	int
&&	O
k	int
>	O
(	O
nu	double
/	O
2	int
)	O
)	O
break	O
;	O
k	int
++	O
;	O
}	O
while	O
(	O
k	int
<	O
1000	int
)	O
;	O
{	O
double	O
pre	double
=	O
sqrt	(double)->(double)
(	O
2.0	int
/	O
(	O
M_PI	int
*	O
x	double
)	O
)	O
;	O
double	O
c	*(double)
=	O
cos	(double)->(double)
(	O
chi	double
)	O
;	O
double	O
s	int
=	O
sin	(double)->(double)
(	O
chi	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
pre	double
*	O
(	O
c	*(double)
*	O
P	*(double)
-	O
s	int
*	O
Q	*(double)
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
pre	double
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
c	*(double)
*	O
P	*(double)
)	O
+	O
fabs	(double)->(double)
(	O
s	int
*	O
Q	*(double)
)	O
+	O
fabs	(double)->(double)
(	O
t	double
)	O
)	O
*	O
(	O
1	int
+	O
fabs	(double)->(double)
(	O
x	double
)	O
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_bessel_Ynu_asympx_e	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
nu	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
ampl	double
;	O
double	O
theta	double
;	O
double	O
alpha	double
=	O
x	double
;	O
double	O
beta	double
=	O
-	O
0.5	int
*	O
nu	double
*	O
M_PI	int
;	O
int	O
stat_a	int
=	O
gsl_sf_bessel_asymp_Mnu_e	(double,double,*(double))->(int)
(	O
nu	double
,	O
x	double
,	O
&	O
ampl	double
)	O
;	O
int	O
stat_t	int
=	O
gsl_sf_bessel_asymp_thetanu_corr_e	(double,double,*(double))->(int)
(	O
nu	double
,	O
x	double
,	O
&	O
theta	double
)	O
;	O
double	O
sin_alpha	double
=	O
sin	(double)->(double)
(	O
alpha	double
)	O
;	O
double	O
cos_alpha	double
=	O
cos	(double)->(double)
(	O
alpha	double
)	O
;	O
double	O
sin_chi	double
=	O
sin	(double)->(double)
(	O
beta	double
+	O
theta	double
)	O
;	O
double	O
cos_chi	double
=	O
cos	(double)->(double)
(	O
beta	double
+	O
theta	double
)	O
;	O
double	O
sin_term	double
=	O
sin_alpha	double
*	O
cos_chi	double
+	O
sin_chi	double
*	O
cos_alpha	double
;	O
double	O
sin_term_mag	double
=	O
fabs	(double)->(double)
(	O
sin_alpha	double
*	O
cos_chi	double
)	O
+	O
fabs	(double)->(double)
(	O
sin_chi	double
*	O
cos_alpha	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
ampl	double
*	O
sin_term	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
fabs	(double)->(double)
(	O
ampl	double
)	O
*	O
GSL_DBL_EPSILON	int
*	O
sin_term_mag	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
*	O
2.0	int
*	O
GSL_DBL_EPSILON	int
;	O
if	O
(	O
fabs	(double)->(double)
(	O
alpha	double
)	O
>	O
1.0	int
/	O
GSL_DBL_EPSILON	int
)	O
{	O
result	*(struct(double,double))
->	O
err	double
*=	O
0.5	int
*	O
fabs	(double)->(double)
(	O
alpha	double
)	O
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
alpha	double
)	O
>	O
1.0	int
/	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
result	*(struct(double,double))
->	O
err	double
*=	O
256.0	int
*	O
fabs	(double)->(double)
(	O
alpha	double
)	O
*	O
GSL_SQRT_DBL_EPSILON	int
;	O
}	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_t	int
,	O
stat_a	int
)	O
;	O
}	O
int	O
gsl_sf_bessel_Inu_scaled_asympx_e	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
nu	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
mu	double
=	O
4.0	int
*	O
nu	double
*	O
nu	double
;	O
double	O
mum1	double
=	O
mu	double
-	O
1.0	int
;	O
double	O
mum9	double
=	O
mu	double
-	O
9.0	int
;	O
double	O
pre	double
=	O
1.0	int
/	O
sqrt	(double)->(double)
(	O
2.0	int
*	O
M_PI	int
*	O
x	double
)	O
;	O
double	O
r	*(struct(double,double))
=	O
mu	double
/	O
x	double
;	O
result	*(struct(double,double))
->	O
val	double
=	O
pre	double
*	O
(	O
1.0	int
-	O
mum1	double
/	O
(	O
8.0	int
*	O
x	double
)	O
+	O
mum1	double
*	O
mum9	double
/	O
(	O
128.0	int
*	O
x	double
*	O
x	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
+	O
pre	double
*	O
fabs	(double)->(double)
(	O
0.1	int
*	O
r	*(struct(double,double))
*	O
r	*(struct(double,double))
*	O
r	*(struct(double,double))
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_bessel_Knu_scaled_asympx_e	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
nu	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
mu	double
=	O
4.0	int
*	O
nu	double
*	O
nu	double
;	O
double	O
mum1	double
=	O
mu	double
-	O
1.0	int
;	O
double	O
mum9	double
=	O
mu	double
-	O
9.0	int
;	O
double	O
pre	double
=	O
sqrt	(double)->(double)
(	O
M_PI	int
/	O
(	O
2.0	int
*	O
x	double
)	O
)	O
;	O
double	O
r	*(struct(double,double))
=	O
nu	double
/	O
x	double
;	O
result	*(struct(double,double))
->	O
val	double
=	O
pre	double
*	O
(	O
1.0	int
+	O
mum1	double
/	O
(	O
8.0	int
*	O
x	double
)	O
+	O
mum1	double
*	O
mum9	double
/	O
(	O
128.0	int
*	O
x	double
*	O
x	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
+	O
pre	double
*	O
fabs	(double)->(double)
(	O
0.1	int
*	O
r	*(struct(double,double))
*	O
r	*(struct(double,double))
*	O
r	*(struct(double,double))
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_bessel_Inu_scaled_asymp_unif_e	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
nu	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
int	O
i	int
;	O
double	O
z	double
=	O
x	double
/	O
nu	double
;	O
double	O
root_term	double
=	O
hypot	(double,double)->(double)
(	O
1.0	int
,	O
z	double
)	O
;	O
double	O
pre	double
=	O
1.0	int
/	O
sqrt	(double)->(double)
(	O
2.0	int
*	O
M_PI	int
*	O
nu	double
*	O
root_term	double
)	O
;	O
double	O
eta	double
=	O
root_term	double
+	O
log	(double)->(double)
(	O
z	double
/	O
(	O
1.0	int
+	O
root_term	double
)	O
)	O
;	O
double	O
ex_arg	double
=	O
(	O
z	double
<	O
1.0	int
/	O
GSL_ROOT3_DBL_EPSILON	int
?	O
nu	double
*	O
(	O
-	O
z	double
+	O
eta	double
)	O
:	O
-	O
0.5	int
*	O
nu	double
/	O
z	double
*	O
(	O
1.0	int
-	O
1.0	int
/	O
(	O
12.0	int
*	O
z	double
*	O
z	double
)	O
)	O
)	O
;	O
gsl_sf_result	struct(double,double)
ex_result	struct(double,double)
;	O
int	O
stat_ex	int
=	O
gsl_sf_exp_e	(double,*(struct(double,double)))->(int)
(	O
ex_arg	double
,	O
&	O
ex_result	struct(double,double)
)	O
;	O
if	O
(	O
stat_ex	int
==	O
GSL_SUCCESS	int
)	O
{	O
double	O
t	double
=	O
1.0	int
/	O
root_term	double
;	O
double	O
sum	struct(double,double)
;	O
double	O
tpow	*(double)
[	O
16	int
]	O
;	O
tpow	*(double)
[	O
0	int
]	O
=	O
1.0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
16	int
;	O
i	int
++	O
)	O
tpow	*(double)
[	O
i	int
]	O
=	O
t	double
*	O
tpow	*(double)
[	O
i	int
-	O
1	int
]	O
;	O
sum	struct(double,double)
=	O
1.0	int
+	O
debye_u1	(*(double))->(double)
(	O
tpow	*(double)
)	O
/	O
nu	double
+	O
debye_u2	(*(double))->(double)
(	O
tpow	*(double)
)	O
/	O
(	O
nu	double
*	O
nu	double
)	O
+	O
debye_u3	(*(double))->(double)
(	O
tpow	*(double)
)	O
/	O
(	O
nu	double
*	O
nu	double
*	O
nu	double
)	O
+	O
debye_u4	(*(double))->(double)
(	O
tpow	*(double)
)	O
/	O
(	O
nu	double
*	O
nu	double
*	O
nu	double
*	O
nu	double
)	O
+	O
debye_u5	(*(double))->(double)
(	O
tpow	*(double)
)	O
/	O
(	O
nu	double
*	O
nu	double
*	O
nu	double
*	O
nu	double
*	O
nu	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
pre	double
*	O
ex_result	struct(double,double)
.	O
val	double
*	O
sum	struct(double,double)
;	O
result	*(struct(double,double))
->	O
err	double
=	O
pre	double
*	O
ex_result	struct(double,double)
.	O
val	double
/	O
(	O
nu	double
*	O
nu	double
*	O
nu	double
*	O
nu	double
*	O
nu	double
*	O
nu	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
pre	double
*	O
ex_result	struct(double,double)
.	O
err	double
*	O
fabs	(double)->(double)
(	O
sum	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
stat_ex	int
;	O
}	O
}	O
int	O
gsl_sf_bessel_Knu_scaled_asymp_unif_e	(double,double,*(struct(double,double)))->(int)
(	O
const	O
double	O
nu	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
int	O
i	int
;	O
double	O
z	double
=	O
x	double
/	O
nu	double
;	O
double	O
root_term	double
=	O
hypot	(double,double)->(double)
(	O
1.0	int
,	O
z	double
)	O
;	O
double	O
pre	double
=	O
sqrt	(double)->(double)
(	O
M_PI	int
/	O
(	O
2.0	int
*	O
nu	double
*	O
root_term	double
)	O
)	O
;	O
double	O
eta	double
=	O
root_term	double
+	O
log	(double)->(double)
(	O
z	double
/	O
(	O
1.0	int
+	O
root_term	double
)	O
)	O
;	O
double	O
ex_arg	double
=	O
(	O
z	double
<	O
1.0	int
/	O
GSL_ROOT3_DBL_EPSILON	int
?	O
nu	double
*	O
(	O
z	double
-	O
eta	double
)	O
:	O
0.5	int
*	O
nu	double
/	O
z	double
*	O
(	O
1.0	int
+	O
1.0	int
/	O
(	O
12.0	int
*	O
z	double
*	O
z	double
)	O
)	O
)	O
;	O
gsl_sf_result	struct(double,double)
ex_result	struct(double,double)
;	O
int	O
stat_ex	int
=	O
gsl_sf_exp_e	(double,*(struct(double,double)))->(int)
(	O
ex_arg	double
,	O
&	O
ex_result	struct(double,double)
)	O
;	O
if	O
(	O
stat_ex	int
==	O
GSL_SUCCESS	int
)	O
{	O
double	O
t	double
=	O
1.0	int
/	O
root_term	double
;	O
double	O
sum	struct(double,double)
;	O
double	O
tpow	*(double)
[	O
16	int
]	O
;	O
tpow	*(double)
[	O
0	int
]	O
=	O
1.0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
16	int
;	O
i	int
++	O
)	O
tpow	*(double)
[	O
i	int
]	O
=	O
t	double
*	O
tpow	*(double)
[	O
i	int
-	O
1	int
]	O
;	O
sum	struct(double,double)
=	O
1.0	int
-	O
debye_u1	(*(double))->(double)
(	O
tpow	*(double)
)	O
/	O
nu	double
+	O
debye_u2	(*(double))->(double)
(	O
tpow	*(double)
)	O
/	O
(	O
nu	double
*	O
nu	double
)	O
-	O
debye_u3	(*(double))->(double)
(	O
tpow	*(double)
)	O
/	O
(	O
nu	double
*	O
nu	double
*	O
nu	double
)	O
+	O
debye_u4	(*(double))->(double)
(	O
tpow	*(double)
)	O
/	O
(	O
nu	double
*	O
nu	double
*	O
nu	double
*	O
nu	double
)	O
-	O
debye_u5	(*(double))->(double)
(	O
tpow	*(double)
)	O
/	O
(	O
nu	double
*	O
nu	double
*	O
nu	double
*	O
nu	double
*	O
nu	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
pre	double
*	O
ex_result	struct(double,double)
.	O
val	double
*	O
sum	struct(double,double)
;	O
result	*(struct(double,double))
->	O
err	double
=	O
pre	double
*	O
ex_result	struct(double,double)
.	O
err	double
*	O
fabs	(double)->(double)
(	O
sum	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
pre	double
*	O
ex_result	struct(double,double)
.	O
val	double
/	O
(	O
nu	double
*	O
nu	double
*	O
nu	double
*	O
nu	double
*	O
nu	double
*	O
nu	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
stat_ex	int
;	O
}	O
}	O
int	O
gsl_sf_bessel_JY_mu_restricted	(double,double,*(struct(double,double)),*(struct(double,double)),*(struct(double,double)),*(struct(double,double)))->(int)
(	O
const	O
double	O
mu	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
Jmu	*(struct(double,double))
,	O
gsl_sf_result	struct(double,double)
*	O
Jmup1	*(struct(double,double))
,	O
gsl_sf_result	struct(double,double)
*	O
Ymu	*(struct(double,double))
,	O
gsl_sf_result	struct(double,double)
*	O
Ymup1	*(struct(double,double))
)	O
{	O
if	O
(	O
x	double
<	O
0.0	int
||	O
fabs	(double)->(double)
(	O
mu	double
)	O
>	O
0.5	int
)	O
{	O
Jmu	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
Jmu	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
Jmup1	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
Jmup1	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
Ymu	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
Ymu	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
Ymup1	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
Ymup1	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
if	O
(	O
mu	double
==	O
0.0	int
)	O
{	O
Jmu	*(struct(double,double))
->	O
val	double
=	O
1.0	int
;	O
Jmu	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
}	O
else	O
{	O
Jmu	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
Jmu	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
}	O
Jmup1	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
Jmup1	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
Ymu	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
Ymu	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
Ymup1	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
Ymup1	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
{	O
int	O
stat_Y	int
;	O
int	O
stat_J	int
;	O
if	O
(	O
x	double
<	O
2.0	int
)	O
{	O
gsl_sf_result	struct(double,double)
Jmup2	struct(double,double)
;	O
int	O
stat_J1	int
=	O
gsl_sf_bessel_IJ_taylor_e	(double,double,int,int,double,*(struct(double,double)))->(int)
(	O
mu	double
+	O
1.0	int
,	O
x	double
,	O
-	O
1	int
,	O
100	int
,	O
GSL_DBL_EPSILON	int
,	O
Jmup1	*(struct(double,double))
)	O
;	O
int	O
stat_J2	int
=	O
gsl_sf_bessel_IJ_taylor_e	(double,double,int,int,double,*(struct(double,double)))->(int)
(	O
mu	double
+	O
2.0	int
,	O
x	double
,	O
-	O
1	int
,	O
100	int
,	O
GSL_DBL_EPSILON	int
,	O
&	O
Jmup2	struct(double,double)
)	O
;	O
double	O
c	*(double)
=	O
2.0	int
*	O
(	O
mu	double
+	O
1.0	int
)	O
/	O
x	double
;	O
Jmu	*(struct(double,double))
->	O
val	double
=	O
c	*(double)
*	O
Jmup1	*(struct(double,double))
->	O
val	double
-	O
Jmup2	struct(double,double)
.	O
val	double
;	O
Jmu	*(struct(double,double))
->	O
err	double
=	O
c	*(double)
*	O
Jmup1	*(struct(double,double))
->	O
err	double
+	O
Jmup2	struct(double,double)
.	O
err	double
;	O
Jmu	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
Jmu	*(struct(double,double))
->	O
val	double
)	O
;	O
stat_J	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_J1	int
,	O
stat_J2	int
)	O
;	O
stat_Y	int
=	O
gsl_sf_bessel_Y_temme	(double,double,*(struct(double,double)),*(struct(double,double)))->(int)
(	O
mu	double
,	O
x	double
,	O
Ymu	*(struct(double,double))
,	O
Ymup1	*(struct(double,double))
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_J	int
,	O
stat_Y	int
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
1000.0	int
)	O
{	O
double	O
P	*(double)
,	O
Q	*(double)
;	O
double	O
J_ratio	double
;	O
double	O
J_sgn	double
;	O
const	O
int	O
stat_CF1	int
=	O
gsl_sf_bessel_J_CF1	(double,double,*(double),*(double))->(int)
(	O
mu	double
,	O
x	double
,	O
&	O
J_ratio	double
,	O
&	O
J_sgn	double
)	O
;	O
const	O
int	O
stat_CF2	int
=	O
gsl_sf_bessel_JY_steed_CF2	(double,double,*(double),*(double))->(int)
(	O
mu	double
,	O
x	double
,	O
&	O
P	*(double)
,	O
&	O
Q	*(double)
)	O
;	O
double	O
Jprime_J_ratio	double
=	O
mu	double
/	O
x	double
-	O
J_ratio	double
;	O
double	O
gamma	(double)->(double)
=	O
(	O
P	*(double)
-	O
Jprime_J_ratio	double
)	O
/	O
Q	*(double)
;	O
Jmu	*(struct(double,double))
->	O
val	double
=	O
J_sgn	double
*	O
sqrt	(double)->(double)
(	O
2.0	int
/	O
(	O
M_PI	int
*	O
x	double
)	O
/	O
(	O
Q	*(double)
+	O
gamma	(double)->(double)
*	O
(	O
P	*(double)
-	O
Jprime_J_ratio	double
)	O
)	O
)	O
;	O
Jmu	*(struct(double,double))
->	O
err	double
=	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
Jmu	*(struct(double,double))
->	O
val	double
)	O
;	O
Jmup1	*(struct(double,double))
->	O
val	double
=	O
J_ratio	double
*	O
Jmu	*(struct(double,double))
->	O
val	double
;	O
Jmup1	*(struct(double,double))
->	O
err	double
=	O
fabs	(double)->(double)
(	O
J_ratio	double
)	O
*	O
Jmu	*(struct(double,double))
->	O
err	double
;	O
Ymu	*(struct(double,double))
->	O
val	double
=	O
gamma	(double)->(double)
*	O
Jmu	*(struct(double,double))
->	O
val	double
;	O
Ymu	*(struct(double,double))
->	O
err	double
=	O
fabs	(double)->(double)
(	O
gamma	(double)->(double)
)	O
*	O
Jmu	*(struct(double,double))
->	O
err	double
;	O
Ymup1	*(struct(double,double))
->	O
val	double
=	O
Ymu	*(struct(double,double))
->	O
val	double
*	O
(	O
mu	double
/	O
x	double
-	O
P	*(double)
-	O
Q	*(double)
/	O
gamma	(double)->(double)
)	O
;	O
Ymup1	*(struct(double,double))
->	O
err	double
=	O
Ymu	*(struct(double,double))
->	O
err	double
*	O
fabs	(double)->(double)
(	O
mu	double
/	O
x	double
-	O
P	*(double)
-	O
Q	*(double)
/	O
gamma	(double)->(double)
)	O
+	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
Ymup1	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_CF1	int
,	O
stat_CF2	int
)	O
;	O
}	O
else	O
{	O
const	O
int	O
stat_J0	int
=	O
gsl_sf_bessel_Jnu_asympx_e	(double,double,*(struct(double,double)))->(int)
(	O
mu	double
,	O
x	double
,	O
Jmu	*(struct(double,double))
)	O
;	O
const	O
int	O
stat_J1	int
=	O
gsl_sf_bessel_Jnu_asympx_e	(double,double,*(struct(double,double)))->(int)
(	O
mu	double
+	O
1.0	int
,	O
x	double
,	O
Jmup1	*(struct(double,double))
)	O
;	O
const	O
int	O
stat_Y0	int
=	O
gsl_sf_bessel_Ynu_asympx_e	(double,double,*(struct(double,double)))->(int)
(	O
mu	double
,	O
x	double
,	O
Ymu	*(struct(double,double))
)	O
;	O
const	O
int	O
stat_Y1	int
=	O
gsl_sf_bessel_Ynu_asympx_e	(double,double,*(struct(double,double)))->(int)
(	O
mu	double
+	O
1.0	int
,	O
x	double
,	O
Ymup1	*(struct(double,double))
)	O
;	O
stat_J	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_J0	int
,	O
stat_J1	int
)	O
;	O
stat_Y	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_Y0	int
,	O
stat_Y1	int
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_J	int
,	O
stat_Y	int
)	O
;	O
}	O
}	O
}	O
int	O
gsl_sf_bessel_J_CF1	(double,double,*(double),*(double))->(int)
(	O
const	O
double	O
nu	double
,	O
const	O
double	O
x	double
,	O
double	O
*	O
ratio	*(double)
,	O
double	O
*	O
sgn	*(double)
)	O
{	O
const	O
double	O
RECUR_BIG	double
=	O
GSL_SQRT_DBL_MAX	int
;	O
const	O
double	O
RECUR_SMALL	double
=	O
GSL_SQRT_DBL_MIN	int
;	O
const	O
int	O
maxiter	int
=	O
10000	int
;	O
int	O
n	int
=	O
1	int
;	O
double	O
Anm2	double
=	O
1.0	int
;	O
double	O
Bnm2	double
=	O
0.0	int
;	O
double	O
Anm1	double
=	O
0.0	int
;	O
double	O
Bnm1	double
=	O
1.0	int
;	O
double	O
a1	double
=	O
x	double
/	O
(	O
2.0	int
*	O
(	O
nu	double
+	O
1.0	int
)	O
)	O
;	O
double	O
An	double
=	O
Anm1	double
+	O
a1	double
*	O
Anm2	double
;	O
double	O
Bn	double
=	O
Bnm1	double
+	O
a1	double
*	O
Bnm2	double
;	O
double	O
an	double
;	O
double	O
fn	double
=	O
An	double
/	O
Bn	double
;	O
double	O
dn	double
=	O
a1	double
;	O
double	O
s	int
=	O
1.0	int
;	O
while	O
(	O
n	int
<	O
maxiter	int
)	O
{	O
double	O
old_fn	double
;	O
double	O
del	double
;	O
n	int
++	O
;	O
Anm2	double
=	O
Anm1	double
;	O
Bnm2	double
=	O
Bnm1	double
;	O
Anm1	double
=	O
An	double
;	O
Bnm1	double
=	O
Bn	double
;	O
an	double
=	O
-	O
x	double
*	O
x	double
/	O
(	O
4.0	int
*	O
(	O
nu	double
+	O
n	int
-	O
1.0	int
)	O
*	O
(	O
nu	double
+	O
n	int
)	O
)	O
;	O
An	double
=	O
Anm1	double
+	O
an	double
*	O
Anm2	double
;	O
Bn	double
=	O
Bnm1	double
+	O
an	double
*	O
Bnm2	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
An	double
)	O
>	O
RECUR_BIG	double
||	O
fabs	(double)->(double)
(	O
Bn	double
)	O
>	O
RECUR_BIG	double
)	O
{	O
An	double
/=	O
RECUR_BIG	double
;	O
Bn	double
/=	O
RECUR_BIG	double
;	O
Anm1	double
/=	O
RECUR_BIG	double
;	O
Bnm1	double
/=	O
RECUR_BIG	double
;	O
Anm2	double
/=	O
RECUR_BIG	double
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
An	double
)	O
<	O
RECUR_SMALL	double
||	O
fabs	(double)->(double)
(	O
Bn	double
)	O
<	O
RECUR_SMALL	double
)	O
{	O
An	double
/=	O
RECUR_SMALL	double
;	O
Bn	double
/=	O
RECUR_SMALL	double
;	O
Anm1	double
/=	O
RECUR_SMALL	double
;	O
Bnm1	double
/=	O
RECUR_SMALL	double
;	O
Anm2	double
/=	O
RECUR_SMALL	double
;	O
Bnm2	double
/=	O
RECUR_SMALL	double
;	O
}	O
old_fn	double
=	O
fn	double
;	O
fn	double
=	O
An	double
/	O
Bn	double
;	O
del	double
=	O
old_fn	double
/	O
fn	double
;	O
dn	double
=	O
1.0	int
/	O
(	O
2.0	int
*	O
(	O
nu	double
+	O
n	int
)	O
/	O
x	double
-	O
dn	double
)	O
;	O
if	O
(	O
dn	double
<	O
0.0	int
)	O
s	int
=	O
-	O
s	int
;	O
if	O
(	O
fabs	(double)->(double)
(	O
del	double
-	O
1.0	int
)	O
<	O
2.0	int
*	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
*	O
ratio	*(double)
=	O
fn	double
;	O
*	O
sgn	*(double)
=	O
s	int
;	O
if	O
(	O
n	int
>=	O
maxiter	int
)	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_bessel_I_CF1_ser	(double,double,*(double))->(int)
(	O
const	O
double	O
nu	double
,	O
const	O
double	O
x	double
,	O
double	O
*	O
ratio	*(double)
)	O
{	O
const	O
int	O
maxk	int
=	O
20000	int
;	O
double	O
tk	double
=	O
1.0	int
;	O
double	O
sum	struct(double,double)
=	O
1.0	int
;	O
double	O
rhok	double
=	O
0.0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
maxk	int
;	O
k	int
++	O
)	O
{	O
double	O
ak	double
=	O
0.25	int
*	O
(	O
x	double
/	O
(	O
nu	double
+	O
k	int
)	O
)	O
*	O
x	double
/	O
(	O
nu	double
+	O
k	int
+	O
1.0	int
)	O
;	O
rhok	double
=	O
-	O
ak	double
*	O
(	O
1.0	int
+	O
rhok	double
)	O
/	O
(	O
1.0	int
+	O
ak	double
*	O
(	O
1.0	int
+	O
rhok	double
)	O
)	O
;	O
tk	double
*=	O
rhok	double
;	O
sum	struct(double,double)
+=	O
tk	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
tk	double
/	O
sum	struct(double,double)
)	O
<	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
*	O
ratio	*(double)
=	O
x	double
/	O
(	O
2.0	int
*	O
(	O
nu	double
+	O
1.0	int
)	O
)	O
*	O
sum	struct(double,double)
;	O
if	O
(	O
k	int
==	O
maxk	int
)	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_bessel_JY_steed_CF2	(double,double,*(double),*(double))->(int)
(	O
const	O
double	O
nu	double
,	O
const	O
double	O
x	double
,	O
double	O
*	O
P	*(double)
,	O
double	O
*	O
Q	*(double)
)	O
{	O
const	O
int	O
max_iter	int
=	O
10000	int
;	O
const	O
double	O
SMALL	double
=	O
1.0e-100	int
;	O
int	O
i	int
=	O
1	int
;	O
double	O
x_inv	double
=	O
1.0	int
/	O
x	double
;	O
double	O
a	double
=	O
0.25	int
-	O
nu	double
*	O
nu	double
;	O
double	O
p	double
=	O
-	O
0.5	int
*	O
x_inv	double
;	O
double	O
q	double
=	O
1.0	int
;	O
double	O
br	double
=	O
2.0	int
*	O
x	double
;	O
double	O
bi	double
=	O
2.0	int
;	O
double	O
fact	double
=	O
a	double
*	O
x_inv	double
/	O
(	O
p	double
*	O
p	double
+	O
q	double
*	O
q	double
)	O
;	O
double	O
cr	double
=	O
br	double
+	O
q	double
*	O
fact	double
;	O
double	O
ci	double
=	O
bi	double
+	O
p	double
*	O
fact	double
;	O
double	O
den	double
=	O
br	double
*	O
br	double
+	O
bi	double
*	O
bi	double
;	O
double	O
dr	double
=	O
br	double
/	O
den	double
;	O
double	O
di	double
=	O
-	O
bi	double
/	O
den	double
;	O
double	O
dlr	double
=	O
cr	double
*	O
dr	double
-	O
ci	double
*	O
di	double
;	O
double	O
dli	double
=	O
cr	double
*	O
di	double
+	O
ci	double
*	O
dr	double
;	O
double	O
temp	double
=	O
p	double
*	O
dlr	double
-	O
q	double
*	O
dli	double
;	O
q	double
=	O
p	double
*	O
dli	double
+	O
q	double
*	O
dlr	double
;	O
p	double
=	O
temp	double
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<=	O
max_iter	int
;	O
i	int
++	O
)	O
{	O
a	double
+=	O
2	int
*	O
(	O
i	int
-	O
1	int
)	O
;	O
bi	double
+=	O
2.0	int
;	O
dr	double
=	O
a	double
*	O
dr	double
+	O
br	double
;	O
di	double
=	O
a	double
*	O
di	double
+	O
bi	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
dr	double
)	O
+	O
fabs	(double)->(double)
(	O
di	double
)	O
<	O
SMALL	double
)	O
dr	double
=	O
SMALL	double
;	O
fact	double
=	O
a	double
/	O
(	O
cr	double
*	O
cr	double
+	O
ci	double
*	O
ci	double
)	O
;	O
cr	double
=	O
br	double
+	O
cr	double
*	O
fact	double
;	O
ci	double
=	O
bi	double
-	O
ci	double
*	O
fact	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
cr	double
)	O
+	O
fabs	(double)->(double)
(	O
ci	double
)	O
<	O
SMALL	double
)	O
cr	double
=	O
SMALL	double
;	O
den	double
=	O
dr	double
*	O
dr	double
+	O
di	double
*	O
di	double
;	O
dr	double
/=	O
den	double
;	O
di	double
/=	O
-	O
den	double
;	O
dlr	double
=	O
cr	double
*	O
dr	double
-	O
ci	double
*	O
di	double
;	O
dli	double
=	O
cr	double
*	O
di	double
+	O
ci	double
*	O
dr	double
;	O
temp	double
=	O
p	double
*	O
dlr	double
-	O
q	double
*	O
dli	double
;	O
q	double
=	O
p	double
*	O
dli	double
+	O
q	double
*	O
dlr	double
;	O
p	double
=	O
temp	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
dlr	double
-	O
1.0	int
)	O
+	O
fabs	(double)->(double)
(	O
dli	double
)	O
<	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
*	O
P	*(double)
=	O
p	double
;	O
*	O
Q	*(double)
=	O
q	double
;	O
if	O
(	O
i	int
==	O
max_iter	int
)	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_bessel_K_scaled_steed_temme_CF2	(double,double,*(double),*(double),*(double))->(int)
(	O
const	O
double	O
nu	double
,	O
const	O
double	O
x	double
,	O
double	O
*	O
K_nu	*(double)
,	O
double	O
*	O
K_nup1	*(double)
,	O
double	O
*	O
Kp_nu	*(double)
)	O
{	O
const	O
int	O
maxiter	int
=	O
10000	int
;	O
int	O
i	int
=	O
1	int
;	O
double	O
bi	double
=	O
2.0	int
*	O
(	O
1.0	int
+	O
x	double
)	O
;	O
double	O
di	double
=	O
1.0	int
/	O
bi	double
;	O
double	O
delhi	double
=	O
di	double
;	O
double	O
hi	double
=	O
di	double
;	O
double	O
qi	double
=	O
0.0	int
;	O
double	O
qip1	double
=	O
1.0	int
;	O
double	O
ai	double
=	O
-	O
(	O
0.25	int
-	O
nu	double
*	O
nu	double
)	O
;	O
double	O
a1	double
=	O
ai	double
;	O
double	O
ci	double
=	O
-	O
ai	double
;	O
double	O
Qi	double
=	O
-	O
ai	double
;	O
double	O
s	int
=	O
1.0	int
+	O
Qi	double
*	O
delhi	double
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<=	O
maxiter	int
;	O
i	int
++	O
)	O
{	O
double	O
dels	double
;	O
double	O
tmp	double
;	O
ai	double
-=	O
2.0	int
*	O
(	O
i	int
-	O
1	int
)	O
;	O
ci	double
=	O
-	O
ai	double
*	O
ci	double
/	O
i	int
;	O
tmp	double
=	O
(	O
qi	double
-	O
bi	double
*	O
qip1	double
)	O
/	O
ai	double
;	O
qi	double
=	O
qip1	double
;	O
qip1	double
=	O
tmp	double
;	O
Qi	double
+=	O
ci	double
*	O
qip1	double
;	O
bi	double
+=	O
2.0	int
;	O
di	double
=	O
1.0	int
/	O
(	O
bi	double
+	O
ai	double
*	O
di	double
)	O
;	O
delhi	double
=	O
(	O
bi	double
*	O
di	double
-	O
1.0	int
)	O
*	O
delhi	double
;	O
hi	double
+=	O
delhi	double
;	O
dels	double
=	O
Qi	double
*	O
delhi	double
;	O
s	int
+=	O
dels	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
dels	double
/	O
s	int
)	O
<	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
hi	double
*=	O
-	O
a1	double
;	O
*	O
K_nu	*(double)
=	O
sqrt	(double)->(double)
(	O
M_PI	int
/	O
(	O
2.0	int
*	O
x	double
)	O
)	O
/	O
s	int
;	O
*	O
K_nup1	*(double)
=	O
*	O
K_nu	*(double)
*	O
(	O
nu	double
+	O
x	double
+	O
0.5	int
-	O
hi	double
)	O
/	O
x	double
;	O
*	O
Kp_nu	*(double)
=	O
-	O
*	O
K_nup1	*(double)
+	O
nu	double
/	O
x	double
*	O
*	O
K_nu	*(double)
;	O
if	O
(	O
i	int
==	O
maxiter	int
)	O
GSL_ERROR	O
(	O
"error"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_bessel_cos_pi4_e	(double,double,*(struct(double,double)))->(int)
(	O
double	O
y	double
,	O
double	O
eps	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
sy	double
=	O
sin	(double)->(double)
(	O
y	double
)	O
;	O
const	O
double	O
cy	double
=	O
cos	(double)->(double)
(	O
y	double
)	O
;	O
const	O
double	O
s	int
=	O
sy	double
+	O
cy	double
;	O
const	O
double	O
d	double
=	O
sy	double
-	O
cy	double
;	O
const	O
double	O
abs_sum	double
=	O
fabs	(double)->(double)
(	O
cy	double
)	O
+	O
fabs	(double)->(double)
(	O
sy	double
)	O
;	O
double	O
seps	double
;	O
double	O
ceps	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
eps	double
)	O
<	O
GSL_ROOT5_DBL_EPSILON	int
)	O
{	O
const	O
double	O
e2	double
=	O
eps	double
*	O
eps	double
;	O
seps	double
=	O
eps	double
*	O
(	O
1.0	int
-	O
e2	double
/	O
6.0	int
*	O
(	O
1.0	int
-	O
e2	double
/	O
20.0	int
)	O
)	O
;	O
ceps	double
=	O
1.0	int
-	O
e2	double
/	O
2.0	int
*	O
(	O
1.0	int
-	O
e2	double
/	O
12.0	int
)	O
;	O
}	O
else	O
{	O
seps	double
=	O
sin	(double)->(double)
(	O
eps	double
)	O
;	O
ceps	double
=	O
cos	(double)->(double)
(	O
eps	double
)	O
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
(	O
ceps	double
*	O
s	int
-	O
seps	double
*	O
d	double
)	O
/	O
M_SQRT2	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
ceps	double
)	O
+	O
fabs	(double)->(double)
(	O
seps	double
)	O
)	O
*	O
abs_sum	double
/	O
M_SQRT2	int
;	O
if	O
(	O
y	double
>	O
1.0	int
/	O
GSL_DBL_EPSILON	int
)	O
{	O
result	*(struct(double,double))
->	O
err	double
*=	O
0.5	int
*	O
y	double
;	O
}	O
else	O
if	O
(	O
y	double
>	O
1.0	int
/	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
result	*(struct(double,double))
->	O
err	double
*=	O
256.0	int
*	O
y	double
*	O
GSL_SQRT_DBL_EPSILON	int
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_bessel_sin_pi4_e	(double,double,*(struct(double,double)))->(int)
(	O
double	O
y	double
,	O
double	O
eps	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
sy	double
=	O
sin	(double)->(double)
(	O
y	double
)	O
;	O
const	O
double	O
cy	double
=	O
cos	(double)->(double)
(	O
y	double
)	O
;	O
const	O
double	O
s	int
=	O
sy	double
+	O
cy	double
;	O
const	O
double	O
d	double
=	O
sy	double
-	O
cy	double
;	O
const	O
double	O
abs_sum	double
=	O
fabs	(double)->(double)
(	O
cy	double
)	O
+	O
fabs	(double)->(double)
(	O
sy	double
)	O
;	O
double	O
seps	double
;	O
double	O
ceps	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
eps	double
)	O
<	O
GSL_ROOT5_DBL_EPSILON	int
)	O
{	O
const	O
double	O
e2	double
=	O
eps	double
*	O
eps	double
;	O
seps	double
=	O
eps	double
*	O
(	O
1.0	int
-	O
e2	double
/	O
6.0	int
*	O
(	O
1.0	int
-	O
e2	double
/	O
20.0	int
)	O
)	O
;	O
ceps	double
=	O
1.0	int
-	O
e2	double
/	O
2.0	int
*	O
(	O
1.0	int
-	O
e2	double
/	O
12.0	int
)	O
;	O
}	O
else	O
{	O
seps	double
=	O
sin	(double)->(double)
(	O
eps	double
)	O
;	O
ceps	double
=	O
cos	(double)->(double)
(	O
eps	double
)	O
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
(	O
ceps	double
*	O
d	double
+	O
seps	double
*	O
s	int
)	O
/	O
M_SQRT2	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
ceps	double
)	O
+	O
fabs	(double)->(double)
(	O
seps	double
)	O
)	O
*	O
abs_sum	double
/	O
M_SQRT2	int
;	O
if	O
(	O
y	double
>	O
1.0	int
/	O
GSL_DBL_EPSILON	int
)	O
{	O
result	*(struct(double,double))
->	O
err	double
*=	O
0.5	int
*	O
y	double
;	O
}	O
else	O
if	O
(	O
y	double
>	O
1.0	int
/	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
result	*(struct(double,double))
->	O
err	double
*=	O
256.0	int
*	O
y	double
*	O
GSL_SQRT_DBL_EPSILON	int
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
