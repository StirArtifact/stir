typedef	O
struct	O
{	O
unsigned	O
int	O
red	int
:	O
8	int
;	O
unsigned	O
int	O
green	int
:	O
8	int
;	O
unsigned	O
int	O
blue	int
:	O
8	int
;	O
}	O
rgb_t	O
;	O
typedef	O
struct	O
{	O
float	O
hue	float
;	O
float	O
saturation	float
;	O
float	O
brightness	float
;	O
}	O
hsv_t	struct(float,float,float)
;	O
static	O
void	O
rgb_to_hsv	(int,*(struct(float,float,float)))->(void)
(	O
rgb_t	O
c	int
,	O
hsv_t	struct(float,float,float)
*	O
result	*(struct(float,float,float))
)	O
{	O
unsigned	O
int	O
r	int
=	O
c	int
.	O
red	int
;	O
unsigned	O
int	O
g	int
=	O
c	int
.	O
green	int
;	O
unsigned	O
int	O
b	int
=	O
c	int
.	O
blue	int
;	O
if	O
(	O
r	int
>	O
g	int
)	O
{	O
if	O
(	O
b	int
>	O
r	int
)	O
{	O
result	*(struct(float,float,float))
->	O
hue	float
=	O
4.0f	int
+	O
(	O
float	O
)	O
(	O
r	int
-	O
g	int
)	O
/	O
(	O
float	O
)	O
(	O
b	int
-	O
g	int
)	O
;	O
result	*(struct(float,float,float))
->	O
saturation	float
=	O
1.0f	int
-	O
(	O
float	O
)	O
g	int
/	O
(	O
float	O
)	O
b	int
;	O
result	*(struct(float,float,float))
->	O
brightness	float
=	O
(	O
float	O
)	O
b	int
/	O
255.0f	int
;	O
}	O
else	O
if	O
(	O
b	int
<=	O
g	int
)	O
{	O
result	*(struct(float,float,float))
->	O
hue	float
=	O
0.0f	int
+	O
(	O
float	O
)	O
(	O
g	int
-	O
b	int
)	O
/	O
(	O
float	O
)	O
(	O
r	int
-	O
b	int
)	O
;	O
result	*(struct(float,float,float))
->	O
saturation	float
=	O
1.0f	int
-	O
(	O
float	O
)	O
b	int
/	O
(	O
float	O
)	O
r	int
;	O
result	*(struct(float,float,float))
->	O
brightness	float
=	O
(	O
float	O
)	O
r	int
/	O
255.0f	int
;	O
}	O
else	O
{	O
result	*(struct(float,float,float))
->	O
hue	float
=	O
6.0f	int
-	O
(	O
float	O
)	O
(	O
b	int
-	O
g	int
)	O
/	O
(	O
float	O
)	O
(	O
r	int
-	O
g	int
)	O
;	O
result	*(struct(float,float,float))
->	O
saturation	float
=	O
1.0f	int
-	O
(	O
float	O
)	O
g	int
/	O
(	O
float	O
)	O
r	int
;	O
result	*(struct(float,float,float))
->	O
brightness	float
=	O
(	O
float	O
)	O
r	int
/	O
255.0f	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
b	int
>	O
g	int
)	O
{	O
result	*(struct(float,float,float))
->	O
hue	float
=	O
4.0f	int
-	O
(	O
float	O
)	O
(	O
g	int
-	O
r	int
)	O
/	O
(	O
float	O
)	O
(	O
b	int
-	O
r	int
)	O
;	O
result	*(struct(float,float,float))
->	O
saturation	float
=	O
1.0f	int
-	O
(	O
float	O
)	O
r	int
/	O
(	O
float	O
)	O
b	int
;	O
result	*(struct(float,float,float))
->	O
brightness	float
=	O
(	O
float	O
)	O
b	int
/	O
255.0f	int
;	O
}	O
else	O
if	O
(	O
b	int
<	O
r	int
)	O
{	O
result	*(struct(float,float,float))
->	O
hue	float
=	O
2.0f	int
-	O
(	O
float	O
)	O
(	O
r	int
-	O
b	int
)	O
/	O
(	O
float	O
)	O
(	O
g	int
-	O
b	int
)	O
;	O
result	*(struct(float,float,float))
->	O
saturation	float
=	O
1.0f	int
-	O
(	O
float	O
)	O
b	int
/	O
(	O
float	O
)	O
g	int
;	O
result	*(struct(float,float,float))
->	O
brightness	float
=	O
(	O
float	O
)	O
g	int
/	O
255.0f	int
;	O
}	O
else	O
if	O
(	O
g	int
>	O
r	int
)	O
{	O
result	*(struct(float,float,float))
->	O
hue	float
=	O
2.0f	int
+	O
(	O
float	O
)	O
(	O
b	int
-	O
r	int
)	O
/	O
(	O
float	O
)	O
(	O
g	int
-	O
r	int
)	O
;	O
result	*(struct(float,float,float))
->	O
saturation	float
=	O
1.0f	int
-	O
(	O
float	O
)	O
r	int
/	O
(	O
float	O
)	O
g	int
;	O
result	*(struct(float,float,float))
->	O
brightness	float
=	O
(	O
float	O
)	O
g	int
/	O
255.0f	int
;	O
}	O
else	O
{	O
result	*(struct(float,float,float))
->	O
hue	float
=	O
0	int
;	O
result	*(struct(float,float,float))
->	O
saturation	float
=	O
0	int
;	O
result	*(struct(float,float,float))
->	O
brightness	float
=	O
(	O
float	O
)	O
r	int
/	O
255.0f	int
;	O
}	O
}	O
}	O
static	O
float	O
color_distance	(*(struct(float,float,float)),*(struct(float,float,float)))->(float)
(	O
const	O
hsv_t	struct(float,float,float)
*	O
color1	*(struct(float,float,float))
,	O
const	O
hsv_t	struct(float,float,float)
*	O
color2	*(struct(float,float,float))
)	O
{	O
float	O
delta_hue	float
=	O
(	O
color1	*(struct(float,float,float))
->	O
hue	float
>=	O
color2	*(struct(float,float,float))
->	O
hue	float
?	O
(	O
color1	*(struct(float,float,float))
->	O
hue	float
-	O
color2	*(struct(float,float,float))
->	O
hue	float
>=	O
3.0f	int
?	O
6.0f	int
+	O
color2	*(struct(float,float,float))
->	O
hue	float
-	O
color1	*(struct(float,float,float))
->	O
hue	float
:	O
color1	*(struct(float,float,float))
->	O
hue	float
-	O
color2	*(struct(float,float,float))
->	O
hue	float
)	O
:	O
(	O
color2	*(struct(float,float,float))
->	O
hue	float
-	O
color1	*(struct(float,float,float))
->	O
hue	float
>=	O
3.0f	int
?	O
6.0f	int
+	O
color1	*(struct(float,float,float))
->	O
hue	float
-	O
color2	*(struct(float,float,float))
->	O
hue	float
:	O
color2	*(struct(float,float,float))
->	O
hue	float
-	O
color1	*(struct(float,float,float))
->	O
hue	float
)	O
)	O
;	O
float	O
min_saturation	float
=	O
(	O
color1	*(struct(float,float,float))
->	O
saturation	float
<	O
color2	*(struct(float,float,float))
->	O
saturation	float
?	O
color1	*(struct(float,float,float))
->	O
saturation	float
:	O
color2	*(struct(float,float,float))
->	O
saturation	float
)	O
;	O
float	O
delta_saturation	float
=	O
color1	*(struct(float,float,float))
->	O
saturation	float
-	O
color2	*(struct(float,float,float))
->	O
saturation	float
;	O
float	O
delta_brightness	float
=	O
color1	*(struct(float,float,float))
->	O
brightness	float
-	O
color2	*(struct(float,float,float))
->	O
brightness	float
;	O
return	O
delta_hue	float
*	O
delta_hue	float
*	O
min_saturation	float
+	O
delta_saturation	float
*	O
delta_saturation	float
*	O
0.2f	int
+	O
delta_brightness	float
*	O
delta_brightness	float
*	O
0.8f	int
;	O
}	O
static	O
unsigned	O
int	O
nearest_color	(int,*(int),int)->(int)
(	O
rgb_t	O
given	int
,	O
const	O
rgb_t	O
*	O
table	*(int)
,	O
unsigned	O
int	O
table_size	int
)	O
{	O
hsv_t	struct(float,float,float)
given_hsv	struct(float,float,float)
;	O
unsigned	O
int	O
best_index	int
;	O
float	O
best_distance	float
;	O
unsigned	O
int	O
i	int
;	O
assert	()->(int)
(	O
table_size	int
>	O
0	int
)	O
;	O
rgb_to_hsv	(int,*(struct(float,float,float)))->(void)
(	O
given	int
,	O
&	O
given_hsv	struct(float,float,float)
)	O
;	O
best_index	int
=	O
0	int
;	O
best_distance	float
=	O
1000000.0f	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
table_size	int
;	O
i	int
++	O
)	O
{	O
hsv_t	struct(float,float,float)
i_hsv	struct(float,float,float)
;	O
rgb_to_hsv	(int,*(struct(float,float,float)))->(void)
(	O
table	*(int)
[	O
i	int
]	O
,	O
&	O
i_hsv	struct(float,float,float)
)	O
;	O
if	O
(	O
i_hsv	struct(float,float,float)
.	O
saturation	float
>	O
given_hsv	struct(float,float,float)
.	O
saturation	float
*	O
0.5f	int
)	O
{	O
float	O
distance	float
=	O
color_distance	(*(struct(float,float,float)),*(struct(float,float,float)))->(float)
(	O
&	O
given_hsv	struct(float,float,float)
,	O
&	O
i_hsv	struct(float,float,float)
)	O
;	O
if	O
(	O
distance	float
<	O
best_distance	float
)	O
{	O
best_index	int
=	O
i	int
;	O
best_distance	float
=	O
distance	float
;	O
}	O
}	O
}	O
return	O
best_index	int
;	O
}	O
static	O
float	O
color_luminance	(int,int,int)->(float)
(	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
)	O
{	O
return	O
(	O
0.299f	int
*	O
r	int
+	O
0.587f	int
*	O
g	int
+	O
0.114f	int
*	O
b	int
)	O
/	O
255.0f	int
;	O
}	O
typedef	O
enum	O
{	O
cm_monochrome	int
,	O
cm_common8	int
,	O
cm_xterm8	int
,	O
cm_xterm16	int
,	O
cm_xterm88	int
,	O
cm_xterm256	int
,	O
cm_xtermrgb	int
}	O
colormodel_t	enum(int,int,int,int,int,int,int)
;	O
static	O
inline	O
term_color_t	O
rgb_to_color_monochrome	()->(int)
(	O
void	O
)	O
{	O
return	O
COLOR_DEFAULT	O
;	O
}	O
static	O
const	O
rgb_t	O
colors_of_common8	array(int)
[	O
8	int
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
255	int
}	O
}	O
;	O
static	O
inline	O
term_color_t	O
rgb_to_color_common8	(int,int,int)->(int)
(	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
)	O
{	O
rgb_t	O
color	int
;	O
hsv_t	struct(float,float,float)
hsv	struct(float,float,float)
;	O
color	int
.	O
red	int
=	O
r	int
;	O
color	int
.	O
green	int
=	O
g	int
;	O
color	int
.	O
blue	int
=	O
b	int
;	O
rgb_to_hsv	(int,*(struct(float,float,float)))->(void)
(	O
color	int
,	O
&	O
hsv	struct(float,float,float)
)	O
;	O
if	O
(	O
hsv	struct(float,float,float)
.	O
saturation	float
<	O
0.065f	int
)	O
{	O
float	O
luminance	float
=	O
color_luminance	(int,int,int)->(float)
(	O
r	int
,	O
g	int
,	O
b	int
)	O
;	O
if	O
(	O
luminance	float
<	O
0.500f	int
)	O
return	O
0	int
;	O
else	O
return	O
7	int
;	O
}	O
else	O
return	O
nearest_color	(int,*(int),int)->(int)
(	O
color	int
,	O
colors_of_common8	array(int)
,	O
8	int
)	O
;	O
}	O
static	O
_GL_ASYNC_SAFE	O
inline	O
int	O
color_bgr	(int)->(int)
(	O
term_color_t	O
color	int
)	O
{	O
return	O
(	O
(	O
color	int
&	O
4	int
)	O
>>	O
2	int
)	O
|	O
(	O
color	int
&	O
2	int
)	O
|	O
(	O
(	O
color	int
&	O
1	int
)	O
<<	O
2	int
)	O
;	O
}	O
static	O
const	O
rgb_t	O
colors_of_xterm8	array(int)
[	O
8	int
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
255	int
}	O
}	O
;	O
static	O
inline	O
term_color_t	O
rgb_to_color_xterm8	(int,int,int)->(int)
(	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
)	O
{	O
rgb_t	O
color	int
;	O
hsv_t	struct(float,float,float)
hsv	struct(float,float,float)
;	O
color	int
.	O
red	int
=	O
r	int
;	O
color	int
.	O
green	int
=	O
g	int
;	O
color	int
.	O
blue	int
=	O
b	int
;	O
rgb_to_hsv	(int,*(struct(float,float,float)))->(void)
(	O
color	int
,	O
&	O
hsv	struct(float,float,float)
)	O
;	O
if	O
(	O
hsv	struct(float,float,float)
.	O
saturation	float
<	O
0.065f	int
)	O
{	O
float	O
luminance	float
=	O
color_luminance	(int,int,int)->(float)
(	O
r	int
,	O
g	int
,	O
b	int
)	O
;	O
if	O
(	O
luminance	float
<	O
0.500f	int
)	O
return	O
0	int
;	O
else	O
return	O
7	int
;	O
}	O
else	O
return	O
nearest_color	(int,*(int),int)->(int)
(	O
color	int
,	O
colors_of_xterm8	array(int)
,	O
8	int
)	O
;	O
}	O
static	O
const	O
rgb_t	O
colors_of_xterm16	array(int)
[	O
16	int
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
205	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
205	int
,	O
0	int
}	O
,	O
{	O
205	int
,	O
205	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
205	int
}	O
,	O
{	O
205	int
,	O
0	int
,	O
205	int
}	O
,	O
{	O
0	int
,	O
205	int
,	O
205	int
}	O
,	O
{	O
229	int
,	O
229	int
,	O
229	int
}	O
,	O
{	O
77	int
,	O
77	int
,	O
77	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
255	int
}	O
}	O
;	O
static	O
inline	O
term_color_t	O
rgb_to_color_xterm16	(int,int,int)->(int)
(	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
)	O
{	O
rgb_t	O
color	int
;	O
hsv_t	struct(float,float,float)
hsv	struct(float,float,float)
;	O
color	int
.	O
red	int
=	O
r	int
;	O
color	int
.	O
green	int
=	O
g	int
;	O
color	int
.	O
blue	int
=	O
b	int
;	O
rgb_to_hsv	(int,*(struct(float,float,float)))->(void)
(	O
color	int
,	O
&	O
hsv	struct(float,float,float)
)	O
;	O
if	O
(	O
hsv	struct(float,float,float)
.	O
saturation	float
<	O
0.065f	int
)	O
{	O
float	O
luminance	float
=	O
color_luminance	(int,int,int)->(float)
(	O
r	int
,	O
g	int
,	O
b	int
)	O
;	O
if	O
(	O
luminance	float
<	O
0.151f	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.600f	int
)	O
return	O
8	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.949f	int
)	O
return	O
7	int
;	O
else	O
return	O
15	int
;	O
}	O
else	O
return	O
nearest_color	(int,*(int),int)->(int)
(	O
color	int
,	O
colors_of_xterm16	array(int)
,	O
16	int
)	O
;	O
}	O
static	O
const	O
rgb_t	O
colors_of_xterm88	array(int)
[	O
88	int
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
205	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
205	int
,	O
0	int
}	O
,	O
{	O
205	int
,	O
205	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
205	int
}	O
,	O
{	O
205	int
,	O
0	int
,	O
205	int
}	O
,	O
{	O
0	int
,	O
205	int
,	O
205	int
}	O
,	O
{	O
229	int
,	O
229	int
,	O
229	int
}	O
,	O
{	O
77	int
,	O
77	int
,	O
77	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
255	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
139	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
205	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
0	int
,	O
139	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
139	int
,	O
139	int
}	O
,	O
{	O
0	int
,	O
139	int
,	O
205	int
}	O
,	O
{	O
0	int
,	O
139	int
,	O
255	int
}	O
,	O
{	O
0	int
,	O
205	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
205	int
,	O
139	int
}	O
,	O
{	O
0	int
,	O
205	int
,	O
205	int
}	O
,	O
{	O
0	int
,	O
205	int
,	O
255	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
139	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
205	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
255	int
}	O
,	O
{	O
139	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
139	int
,	O
0	int
,	O
139	int
}	O
,	O
{	O
139	int
,	O
0	int
,	O
205	int
}	O
,	O
{	O
139	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
139	int
,	O
139	int
,	O
0	int
}	O
,	O
{	O
139	int
,	O
139	int
,	O
139	int
}	O
,	O
{	O
139	int
,	O
139	int
,	O
205	int
}	O
,	O
{	O
139	int
,	O
139	int
,	O
255	int
}	O
,	O
{	O
139	int
,	O
205	int
,	O
0	int
}	O
,	O
{	O
139	int
,	O
205	int
,	O
139	int
}	O
,	O
{	O
139	int
,	O
205	int
,	O
205	int
}	O
,	O
{	O
139	int
,	O
205	int
,	O
255	int
}	O
,	O
{	O
139	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
139	int
,	O
255	int
,	O
139	int
}	O
,	O
{	O
139	int
,	O
255	int
,	O
205	int
}	O
,	O
{	O
139	int
,	O
255	int
,	O
255	int
}	O
,	O
{	O
205	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
205	int
,	O
0	int
,	O
139	int
}	O
,	O
{	O
205	int
,	O
0	int
,	O
205	int
}	O
,	O
{	O
205	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
205	int
,	O
139	int
,	O
0	int
}	O
,	O
{	O
205	int
,	O
139	int
,	O
139	int
}	O
,	O
{	O
205	int
,	O
139	int
,	O
205	int
}	O
,	O
{	O
205	int
,	O
139	int
,	O
255	int
}	O
,	O
{	O
205	int
,	O
205	int
,	O
0	int
}	O
,	O
{	O
205	int
,	O
205	int
,	O
139	int
}	O
,	O
{	O
205	int
,	O
205	int
,	O
205	int
}	O
,	O
{	O
205	int
,	O
205	int
,	O
255	int
}	O
,	O
{	O
205	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
205	int
,	O
255	int
,	O
139	int
}	O
,	O
{	O
205	int
,	O
255	int
,	O
205	int
}	O
,	O
{	O
205	int
,	O
255	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
139	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
205	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
139	int
,	O
0	int
}	O
,	O
{	O
255	int
,	O
139	int
,	O
139	int
}	O
,	O
{	O
255	int
,	O
139	int
,	O
205	int
}	O
,	O
{	O
255	int
,	O
139	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
205	int
,	O
0	int
}	O
,	O
{	O
255	int
,	O
205	int
,	O
139	int
}	O
,	O
{	O
255	int
,	O
205	int
,	O
205	int
}	O
,	O
{	O
255	int
,	O
205	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
139	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
205	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
255	int
}	O
,	O
{	O
46	int
,	O
46	int
,	O
46	int
}	O
,	O
{	O
92	int
,	O
92	int
,	O
92	int
}	O
,	O
{	O
115	int
,	O
115	int
,	O
115	int
}	O
,	O
{	O
139	int
,	O
139	int
,	O
139	int
}	O
,	O
{	O
162	int
,	O
162	int
,	O
162	int
}	O
,	O
{	O
185	int
,	O
185	int
,	O
185	int
}	O
,	O
{	O
208	int
,	O
208	int
,	O
208	int
}	O
,	O
{	O
231	int
,	O
231	int
,	O
231	int
}	O
}	O
;	O
static	O
inline	O
term_color_t	O
rgb_to_color_xterm88	(int,int,int)->(int)
(	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
)	O
{	O
rgb_t	O
color	int
;	O
hsv_t	struct(float,float,float)
hsv	struct(float,float,float)
;	O
color	int
.	O
red	int
=	O
r	int
;	O
color	int
.	O
green	int
=	O
g	int
;	O
color	int
.	O
blue	int
=	O
b	int
;	O
rgb_to_hsv	(int,*(struct(float,float,float)))->(void)
(	O
color	int
,	O
&	O
hsv	struct(float,float,float)
)	O
;	O
if	O
(	O
hsv	struct(float,float,float)
.	O
saturation	float
<	O
0.065f	int
)	O
{	O
float	O
luminance	float
=	O
color_luminance	(int,int,int)->(float)
(	O
r	int
,	O
g	int
,	O
b	int
)	O
;	O
if	O
(	O
luminance	float
<	O
0.090f	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.241f	int
)	O
return	O
80	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.331f	int
)	O
return	O
8	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.406f	int
)	O
return	O
81	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.498f	int
)	O
return	O
82	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.585f	int
)	O
return	O
37	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.680f	int
)	O
return	O
84	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.764f	int
)	O
return	O
85	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.810f	int
)	O
return	O
58	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.857f	int
)	O
return	O
86	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.902f	int
)	O
return	O
7	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.953f	int
)	O
return	O
87	int
;	O
else	O
return	O
15	int
;	O
}	O
else	O
return	O
nearest_color	(int,*(int),int)->(int)
(	O
color	int
,	O
colors_of_xterm88	array(int)
,	O
88	int
)	O
;	O
}	O
static	O
const	O
rgb_t	O
colors_of_xterm256	array(int)
[	O
256	int
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
205	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
205	int
,	O
0	int
}	O
,	O
{	O
205	int
,	O
205	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
205	int
}	O
,	O
{	O
205	int
,	O
0	int
,	O
205	int
}	O
,	O
{	O
0	int
,	O
205	int
,	O
205	int
}	O
,	O
{	O
229	int
,	O
229	int
,	O
229	int
}	O
,	O
{	O
77	int
,	O
77	int
,	O
77	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
255	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
42	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
85	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
127	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
170	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
212	int
}	O
,	O
{	O
0	int
,	O
42	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
42	int
,	O
42	int
}	O
,	O
{	O
0	int
,	O
42	int
,	O
85	int
}	O
,	O
{	O
0	int
,	O
42	int
,	O
127	int
}	O
,	O
{	O
0	int
,	O
42	int
,	O
170	int
}	O
,	O
{	O
0	int
,	O
42	int
,	O
212	int
}	O
,	O
{	O
0	int
,	O
85	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
85	int
,	O
42	int
}	O
,	O
{	O
0	int
,	O
85	int
,	O
85	int
}	O
,	O
{	O
0	int
,	O
85	int
,	O
127	int
}	O
,	O
{	O
0	int
,	O
85	int
,	O
170	int
}	O
,	O
{	O
0	int
,	O
85	int
,	O
212	int
}	O
,	O
{	O
0	int
,	O
127	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
127	int
,	O
42	int
}	O
,	O
{	O
0	int
,	O
127	int
,	O
85	int
}	O
,	O
{	O
0	int
,	O
127	int
,	O
127	int
}	O
,	O
{	O
0	int
,	O
127	int
,	O
170	int
}	O
,	O
{	O
0	int
,	O
127	int
,	O
212	int
}	O
,	O
{	O
0	int
,	O
170	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
170	int
,	O
42	int
}	O
,	O
{	O
0	int
,	O
170	int
,	O
85	int
}	O
,	O
{	O
0	int
,	O
170	int
,	O
127	int
}	O
,	O
{	O
0	int
,	O
170	int
,	O
170	int
}	O
,	O
{	O
0	int
,	O
170	int
,	O
212	int
}	O
,	O
{	O
0	int
,	O
212	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
212	int
,	O
42	int
}	O
,	O
{	O
0	int
,	O
212	int
,	O
85	int
}	O
,	O
{	O
0	int
,	O
212	int
,	O
127	int
}	O
,	O
{	O
0	int
,	O
212	int
,	O
170	int
}	O
,	O
{	O
0	int
,	O
212	int
,	O
212	int
}	O
,	O
{	O
42	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
42	int
,	O
0	int
,	O
42	int
}	O
,	O
{	O
42	int
,	O
0	int
,	O
85	int
}	O
,	O
{	O
42	int
,	O
0	int
,	O
127	int
}	O
,	O
{	O
42	int
,	O
0	int
,	O
170	int
}	O
,	O
{	O
42	int
,	O
0	int
,	O
212	int
}	O
,	O
{	O
42	int
,	O
42	int
,	O
0	int
}	O
,	O
{	O
42	int
,	O
42	int
,	O
42	int
}	O
,	O
{	O
42	int
,	O
42	int
,	O
85	int
}	O
,	O
{	O
42	int
,	O
42	int
,	O
127	int
}	O
,	O
{	O
42	int
,	O
42	int
,	O
170	int
}	O
,	O
{	O
42	int
,	O
42	int
,	O
212	int
}	O
,	O
{	O
42	int
,	O
85	int
,	O
0	int
}	O
,	O
{	O
42	int
,	O
85	int
,	O
42	int
}	O
,	O
{	O
42	int
,	O
85	int
,	O
85	int
}	O
,	O
{	O
42	int
,	O
85	int
,	O
127	int
}	O
,	O
{	O
42	int
,	O
85	int
,	O
170	int
}	O
,	O
{	O
42	int
,	O
85	int
,	O
212	int
}	O
,	O
{	O
42	int
,	O
127	int
,	O
0	int
}	O
,	O
{	O
42	int
,	O
127	int
,	O
42	int
}	O
,	O
{	O
42	int
,	O
127	int
,	O
85	int
}	O
,	O
{	O
42	int
,	O
127	int
,	O
127	int
}	O
,	O
{	O
42	int
,	O
127	int
,	O
170	int
}	O
,	O
{	O
42	int
,	O
127	int
,	O
212	int
}	O
,	O
{	O
42	int
,	O
170	int
,	O
0	int
}	O
,	O
{	O
42	int
,	O
170	int
,	O
42	int
}	O
,	O
{	O
42	int
,	O
170	int
,	O
85	int
}	O
,	O
{	O
42	int
,	O
170	int
,	O
127	int
}	O
,	O
{	O
42	int
,	O
170	int
,	O
170	int
}	O
,	O
{	O
42	int
,	O
170	int
,	O
212	int
}	O
,	O
{	O
42	int
,	O
212	int
,	O
0	int
}	O
,	O
{	O
42	int
,	O
212	int
,	O
42	int
}	O
,	O
{	O
42	int
,	O
212	int
,	O
85	int
}	O
,	O
{	O
42	int
,	O
212	int
,	O
127	int
}	O
,	O
{	O
42	int
,	O
212	int
,	O
170	int
}	O
,	O
{	O
42	int
,	O
212	int
,	O
212	int
}	O
,	O
{	O
85	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
85	int
,	O
0	int
,	O
42	int
}	O
,	O
{	O
85	int
,	O
0	int
,	O
85	int
}	O
,	O
{	O
85	int
,	O
0	int
,	O
127	int
}	O
,	O
{	O
85	int
,	O
0	int
,	O
170	int
}	O
,	O
{	O
85	int
,	O
0	int
,	O
212	int
}	O
,	O
{	O
85	int
,	O
42	int
,	O
0	int
}	O
,	O
{	O
85	int
,	O
42	int
,	O
42	int
}	O
,	O
{	O
85	int
,	O
42	int
,	O
85	int
}	O
,	O
{	O
85	int
,	O
42	int
,	O
127	int
}	O
,	O
{	O
85	int
,	O
42	int
,	O
170	int
}	O
,	O
{	O
85	int
,	O
42	int
,	O
212	int
}	O
,	O
{	O
85	int
,	O
85	int
,	O
0	int
}	O
,	O
{	O
85	int
,	O
85	int
,	O
42	int
}	O
,	O
{	O
85	int
,	O
85	int
,	O
85	int
}	O
,	O
{	O
85	int
,	O
85	int
,	O
127	int
}	O
,	O
{	O
85	int
,	O
85	int
,	O
170	int
}	O
,	O
{	O
85	int
,	O
85	int
,	O
212	int
}	O
,	O
{	O
85	int
,	O
127	int
,	O
0	int
}	O
,	O
{	O
85	int
,	O
127	int
,	O
42	int
}	O
,	O
{	O
85	int
,	O
127	int
,	O
85	int
}	O
,	O
{	O
85	int
,	O
127	int
,	O
127	int
}	O
,	O
{	O
85	int
,	O
127	int
,	O
170	int
}	O
,	O
{	O
85	int
,	O
127	int
,	O
212	int
}	O
,	O
{	O
85	int
,	O
170	int
,	O
0	int
}	O
,	O
{	O
85	int
,	O
170	int
,	O
42	int
}	O
,	O
{	O
85	int
,	O
170	int
,	O
85	int
}	O
,	O
{	O
85	int
,	O
170	int
,	O
127	int
}	O
,	O
{	O
85	int
,	O
170	int
,	O
170	int
}	O
,	O
{	O
85	int
,	O
170	int
,	O
212	int
}	O
,	O
{	O
85	int
,	O
212	int
,	O
0	int
}	O
,	O
{	O
85	int
,	O
212	int
,	O
42	int
}	O
,	O
{	O
85	int
,	O
212	int
,	O
85	int
}	O
,	O
{	O
85	int
,	O
212	int
,	O
127	int
}	O
,	O
{	O
85	int
,	O
212	int
,	O
170	int
}	O
,	O
{	O
85	int
,	O
212	int
,	O
212	int
}	O
,	O
{	O
127	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
127	int
,	O
0	int
,	O
42	int
}	O
,	O
{	O
127	int
,	O
0	int
,	O
85	int
}	O
,	O
{	O
127	int
,	O
0	int
,	O
127	int
}	O
,	O
{	O
127	int
,	O
0	int
,	O
170	int
}	O
,	O
{	O
127	int
,	O
0	int
,	O
212	int
}	O
,	O
{	O
127	int
,	O
42	int
,	O
0	int
}	O
,	O
{	O
127	int
,	O
42	int
,	O
42	int
}	O
,	O
{	O
127	int
,	O
42	int
,	O
85	int
}	O
,	O
{	O
127	int
,	O
42	int
,	O
127	int
}	O
,	O
{	O
127	int
,	O
42	int
,	O
170	int
}	O
,	O
{	O
127	int
,	O
42	int
,	O
212	int
}	O
,	O
{	O
127	int
,	O
85	int
,	O
0	int
}	O
,	O
{	O
127	int
,	O
85	int
,	O
42	int
}	O
,	O
{	O
127	int
,	O
85	int
,	O
85	int
}	O
,	O
{	O
127	int
,	O
85	int
,	O
127	int
}	O
,	O
{	O
127	int
,	O
85	int
,	O
170	int
}	O
,	O
{	O
127	int
,	O
85	int
,	O
212	int
}	O
,	O
{	O
127	int
,	O
127	int
,	O
0	int
}	O
,	O
{	O
127	int
,	O
127	int
,	O
42	int
}	O
,	O
{	O
127	int
,	O
127	int
,	O
85	int
}	O
,	O
{	O
127	int
,	O
127	int
,	O
127	int
}	O
,	O
{	O
127	int
,	O
127	int
,	O
170	int
}	O
,	O
{	O
127	int
,	O
127	int
,	O
212	int
}	O
,	O
{	O
127	int
,	O
170	int
,	O
0	int
}	O
,	O
{	O
127	int
,	O
170	int
,	O
42	int
}	O
,	O
{	O
127	int
,	O
170	int
,	O
85	int
}	O
,	O
{	O
127	int
,	O
170	int
,	O
127	int
}	O
,	O
{	O
127	int
,	O
170	int
,	O
170	int
}	O
,	O
{	O
127	int
,	O
170	int
,	O
212	int
}	O
,	O
{	O
127	int
,	O
212	int
,	O
0	int
}	O
,	O
{	O
127	int
,	O
212	int
,	O
42	int
}	O
,	O
{	O
127	int
,	O
212	int
,	O
85	int
}	O
,	O
{	O
127	int
,	O
212	int
,	O
127	int
}	O
,	O
{	O
127	int
,	O
212	int
,	O
170	int
}	O
,	O
{	O
127	int
,	O
212	int
,	O
212	int
}	O
,	O
{	O
170	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
170	int
,	O
0	int
,	O
42	int
}	O
,	O
{	O
170	int
,	O
0	int
,	O
85	int
}	O
,	O
{	O
170	int
,	O
0	int
,	O
127	int
}	O
,	O
{	O
170	int
,	O
0	int
,	O
170	int
}	O
,	O
{	O
170	int
,	O
0	int
,	O
212	int
}	O
,	O
{	O
170	int
,	O
42	int
,	O
0	int
}	O
,	O
{	O
170	int
,	O
42	int
,	O
42	int
}	O
,	O
{	O
170	int
,	O
42	int
,	O
85	int
}	O
,	O
{	O
170	int
,	O
42	int
,	O
127	int
}	O
,	O
{	O
170	int
,	O
42	int
,	O
170	int
}	O
,	O
{	O
170	int
,	O
42	int
,	O
212	int
}	O
,	O
{	O
170	int
,	O
85	int
,	O
0	int
}	O
,	O
{	O
170	int
,	O
85	int
,	O
42	int
}	O
,	O
{	O
170	int
,	O
85	int
,	O
85	int
}	O
,	O
{	O
170	int
,	O
85	int
,	O
127	int
}	O
,	O
{	O
170	int
,	O
85	int
,	O
170	int
}	O
,	O
{	O
170	int
,	O
85	int
,	O
212	int
}	O
,	O
{	O
170	int
,	O
127	int
,	O
0	int
}	O
,	O
{	O
170	int
,	O
127	int
,	O
42	int
}	O
,	O
{	O
170	int
,	O
127	int
,	O
85	int
}	O
,	O
{	O
170	int
,	O
127	int
,	O
127	int
}	O
,	O
{	O
170	int
,	O
127	int
,	O
170	int
}	O
,	O
{	O
170	int
,	O
127	int
,	O
212	int
}	O
,	O
{	O
170	int
,	O
170	int
,	O
0	int
}	O
,	O
{	O
170	int
,	O
170	int
,	O
42	int
}	O
,	O
{	O
170	int
,	O
170	int
,	O
85	int
}	O
,	O
{	O
170	int
,	O
170	int
,	O
127	int
}	O
,	O
{	O
170	int
,	O
170	int
,	O
170	int
}	O
,	O
{	O
170	int
,	O
170	int
,	O
212	int
}	O
,	O
{	O
170	int
,	O
212	int
,	O
0	int
}	O
,	O
{	O
170	int
,	O
212	int
,	O
42	int
}	O
,	O
{	O
170	int
,	O
212	int
,	O
85	int
}	O
,	O
{	O
170	int
,	O
212	int
,	O
127	int
}	O
,	O
{	O
170	int
,	O
212	int
,	O
170	int
}	O
,	O
{	O
170	int
,	O
212	int
,	O
212	int
}	O
,	O
{	O
212	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
212	int
,	O
0	int
,	O
42	int
}	O
,	O
{	O
212	int
,	O
0	int
,	O
85	int
}	O
,	O
{	O
212	int
,	O
0	int
,	O
127	int
}	O
,	O
{	O
212	int
,	O
0	int
,	O
170	int
}	O
,	O
{	O
212	int
,	O
0	int
,	O
212	int
}	O
,	O
{	O
212	int
,	O
42	int
,	O
0	int
}	O
,	O
{	O
212	int
,	O
42	int
,	O
42	int
}	O
,	O
{	O
212	int
,	O
42	int
,	O
85	int
}	O
,	O
{	O
212	int
,	O
42	int
,	O
127	int
}	O
,	O
{	O
212	int
,	O
42	int
,	O
170	int
}	O
,	O
{	O
212	int
,	O
42	int
,	O
212	int
}	O
,	O
{	O
212	int
,	O
85	int
,	O
0	int
}	O
,	O
{	O
212	int
,	O
85	int
,	O
42	int
}	O
,	O
{	O
212	int
,	O
85	int
,	O
85	int
}	O
,	O
{	O
212	int
,	O
85	int
,	O
127	int
}	O
,	O
{	O
212	int
,	O
85	int
,	O
170	int
}	O
,	O
{	O
212	int
,	O
85	int
,	O
212	int
}	O
,	O
{	O
212	int
,	O
127	int
,	O
0	int
}	O
,	O
{	O
212	int
,	O
127	int
,	O
42	int
}	O
,	O
{	O
212	int
,	O
127	int
,	O
85	int
}	O
,	O
{	O
212	int
,	O
127	int
,	O
127	int
}	O
,	O
{	O
212	int
,	O
127	int
,	O
170	int
}	O
,	O
{	O
212	int
,	O
127	int
,	O
212	int
}	O
,	O
{	O
212	int
,	O
170	int
,	O
0	int
}	O
,	O
{	O
212	int
,	O
170	int
,	O
42	int
}	O
,	O
{	O
212	int
,	O
170	int
,	O
85	int
}	O
,	O
{	O
212	int
,	O
170	int
,	O
127	int
}	O
,	O
{	O
212	int
,	O
170	int
,	O
170	int
}	O
,	O
{	O
212	int
,	O
170	int
,	O
212	int
}	O
,	O
{	O
212	int
,	O
212	int
,	O
0	int
}	O
,	O
{	O
212	int
,	O
212	int
,	O
42	int
}	O
,	O
{	O
212	int
,	O
212	int
,	O
85	int
}	O
,	O
{	O
212	int
,	O
212	int
,	O
127	int
}	O
,	O
{	O
212	int
,	O
212	int
,	O
170	int
}	O
,	O
{	O
212	int
,	O
212	int
,	O
212	int
}	O
,	O
{	O
8	int
,	O
8	int
,	O
8	int
}	O
,	O
{	O
18	int
,	O
18	int
,	O
18	int
}	O
,	O
{	O
28	int
,	O
28	int
,	O
28	int
}	O
,	O
{	O
38	int
,	O
38	int
,	O
38	int
}	O
,	O
{	O
48	int
,	O
48	int
,	O
48	int
}	O
,	O
{	O
58	int
,	O
58	int
,	O
58	int
}	O
,	O
{	O
68	int
,	O
68	int
,	O
68	int
}	O
,	O
{	O
78	int
,	O
78	int
,	O
78	int
}	O
,	O
{	O
88	int
,	O
88	int
,	O
88	int
}	O
,	O
{	O
98	int
,	O
98	int
,	O
98	int
}	O
,	O
{	O
108	int
,	O
108	int
,	O
108	int
}	O
,	O
{	O
118	int
,	O
118	int
,	O
118	int
}	O
,	O
{	O
128	int
,	O
128	int
,	O
128	int
}	O
,	O
{	O
138	int
,	O
138	int
,	O
138	int
}	O
,	O
{	O
148	int
,	O
148	int
,	O
148	int
}	O
,	O
{	O
158	int
,	O
158	int
,	O
158	int
}	O
,	O
{	O
168	int
,	O
168	int
,	O
168	int
}	O
,	O
{	O
178	int
,	O
178	int
,	O
178	int
}	O
,	O
{	O
188	int
,	O
188	int
,	O
188	int
}	O
,	O
{	O
198	int
,	O
198	int
,	O
198	int
}	O
,	O
{	O
208	int
,	O
208	int
,	O
208	int
}	O
,	O
{	O
218	int
,	O
218	int
,	O
218	int
}	O
,	O
{	O
228	int
,	O
228	int
,	O
228	int
}	O
,	O
{	O
238	int
,	O
238	int
,	O
238	int
}	O
}	O
;	O
static	O
inline	O
term_color_t	O
rgb_to_color_xterm256	(int,int,int)->(int)
(	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
)	O
{	O
rgb_t	O
color	int
;	O
hsv_t	struct(float,float,float)
hsv	struct(float,float,float)
;	O
color	int
.	O
red	int
=	O
r	int
;	O
color	int
.	O
green	int
=	O
g	int
;	O
color	int
.	O
blue	int
=	O
b	int
;	O
rgb_to_hsv	(int,*(struct(float,float,float)))->(void)
(	O
color	int
,	O
&	O
hsv	struct(float,float,float)
)	O
;	O
if	O
(	O
hsv	struct(float,float,float)
.	O
saturation	float
<	O
0.065f	int
)	O
{	O
float	O
luminance	float
=	O
color_luminance	(int,int,int)->(float)
(	O
r	int
,	O
g	int
,	O
b	int
)	O
;	O
if	O
(	O
luminance	float
<	O
0.015f	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.051f	int
)	O
return	O
232	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.090f	int
)	O
return	O
233	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.129f	int
)	O
return	O
234	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.157f	int
)	O
return	O
235	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.177f	int
)	O
return	O
59	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.207f	int
)	O
return	O
236	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.247f	int
)	O
return	O
237	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.284f	int
)	O
return	O
238	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.304f	int
)	O
return	O
8	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.319f	int
)	O
return	O
239	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.339f	int
)	O
return	O
102	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.364f	int
)	O
return	O
240	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.404f	int
)	O
return	O
241	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.443f	int
)	O
return	O
242	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.480f	int
)	O
return	O
243	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.500f	int
)	O
return	O
145	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.521f	int
)	O
return	O
244	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.560f	int
)	O
return	O
245	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.600f	int
)	O
return	O
246	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.639f	int
)	O
return	O
247	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.663f	int
)	O
return	O
248	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.682f	int
)	O
return	O
188	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.717f	int
)	O
return	O
249	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.756f	int
)	O
return	O
250	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.796f	int
)	O
return	O
251	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.823f	int
)	O
return	O
252	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.843f	int
)	O
return	O
231	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.874f	int
)	O
return	O
253	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.896f	int
)	O
return	O
254	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.915f	int
)	O
return	O
7	int
;	O
else	O
if	O
(	O
luminance	float
<	O
0.966f	int
)	O
return	O
255	int
;	O
else	O
return	O
15	int
;	O
}	O
else	O
return	O
nearest_color	(int,*(int),int)->(int)
(	O
color	int
,	O
colors_of_xterm256	array(int)
,	O
256	int
)	O
;	O
}	O
static	O
inline	O
term_color_t	O
rgb_to_color_xtermrgb	(int,int,int)->(int)
(	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
)	O
{	O
return	O
(	O
r	int
<<	O
16	int
)	O
|	O
(	O
g	int
<<	O
8	int
)	O
|	O
(	O
b	int
<<	O
0	int
)	O
;	O
}	O
typedef	O
struct	O
{	O
BITFIELD_TYPE	O
(	O
term_color_t	O
,	O
signed	O
int	O
)	O
color	int
:	O
25	int
;	O
BITFIELD_TYPE	O
(	O
term_color_t	O
,	O
signed	O
int	O
)	O
bgcolor	int
:	O
25	int
;	O
BITFIELD_TYPE	O
(	O
term_weight_t	O
,	O
unsigned	O
int	O
)	O
weight	int
:	O
1	int
;	O
BITFIELD_TYPE	O
(	O
term_posture_t	O
,	O
unsigned	O
int	O
)	O
posture	int
:	O
1	int
;	O
BITFIELD_TYPE	O
(	O
term_underline_t	O
,	O
unsigned	O
int	O
)	O
underline	int
:	O
1	int
;	O
}	O
attributes_t	struct(int,int,int,int,int)
;	O
static	O
inline	O
bool	O
equal_attributes	(struct(int,int,int,int,int),struct(int,int,int,int,int))->(int)
(	O
attributes_t	struct(int,int,int,int,int)
attr1	struct(int,int,int,int,int)
,	O
attributes_t	struct(int,int,int,int,int)
attr2	struct(int,int,int,int,int)
)	O
{	O
return	O
(	O
attr1	struct(int,int,int,int,int)
.	O
color	int
==	O
attr2	struct(int,int,int,int,int)
.	O
color	int
&&	O
attr1	struct(int,int,int,int,int)
.	O
bgcolor	int
==	O
attr2	struct(int,int,int,int,int)
.	O
bgcolor	int
&&	O
attr1	struct(int,int,int,int,int)
.	O
weight	int
==	O
attr2	struct(int,int,int,int,int)
.	O
weight	int
&&	O
attr1	struct(int,int,int,int,int)
.	O
posture	int
==	O
attr2	struct(int,int,int,int,int)
.	O
posture	int
&&	O
attr1	struct(int,int,int,int,int)
.	O
underline	int
==	O
attr2	struct(int,int,int,int,int)
.	O
underline	int
)	O
;	O
}	O
static	O
inline	O
int	O
nonintr_tcdrain	(int)->(int)
(	O
int	O
fd	int
)	O
{	O
int	O
retval	int
;	O
do	O
retval	int
=	O
tcdrain	()->(int)
(	O
fd	int
)	O
;	O
while	O
(	O
retval	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	O
)	O
;	O
return	O
retval	int
;	O
}	O
const	O
typeinfo_t	O
term_ostream_typeinfo	O
=	O
{	O
"term_ostream"	*(char)
}	O
;	O
static	O
const	O
typeinfo_t	O
*	O
const	O
term_ostream_superclasses	array(*(int))
[	O
]	O
=	O
{	O
term_ostream_SUPERCLASSES	O
}	O
;	O
static	O
struct	O
term_style_control_data	O
*	O
get_control_data	(int)->(*(struct))
(	O
term_ostream_t	O
stream	int
)	O
{	O
return	O
&	O
stream	int
->	O
control_data	O
;	O
}	O
static	O
attributes_t	struct(int,int,int,int,int)
simplify_attributes	(int,struct(int,int,int,int,int))->(struct(int,int,int,int,int))
(	O
term_ostream_t	O
stream	int
,	O
attributes_t	struct(int,int,int,int,int)
attr	struct(int,int,int,int,int)
)	O
{	O
if	O
(	O
(	O
attr	struct(int,int,int,int,int)
.	O
color	int
!=	O
COLOR_DEFAULT	O
||	O
attr	struct(int,int,int,int,int)
.	O
bgcolor	int
!=	O
COLOR_DEFAULT	O
)	O
&&	O
stream	int
->	O
no_color_video	O
>	O
0	int
)	O
{	O
if	O
(	O
stream	int
->	O
no_color_video	O
&	O
2	int
)	O
attr	struct(int,int,int,int,int)
.	O
underline	int
=	O
UNDERLINE_OFF	O
;	O
if	O
(	O
stream	int
->	O
no_color_video	O
&	O
32	int
)	O
attr	struct(int,int,int,int,int)
.	O
weight	int
=	O
WEIGHT_NORMAL	O
;	O
}	O
if	O
(	O
!	O
stream	int
->	O
supports_foreground	O
)	O
attr	struct(int,int,int,int,int)
.	O
color	int
=	O
COLOR_DEFAULT	O
;	O
if	O
(	O
!	O
stream	int
->	O
supports_background	O
)	O
attr	struct(int,int,int,int,int)
.	O
bgcolor	int
=	O
COLOR_DEFAULT	O
;	O
if	O
(	O
!	O
stream	int
->	O
supports_weight	O
)	O
attr	struct(int,int,int,int,int)
.	O
weight	int
=	O
WEIGHT_DEFAULT	O
;	O
if	O
(	O
!	O
stream	int
->	O
supports_posture	O
)	O
attr	struct(int,int,int,int,int)
.	O
posture	int
=	O
POSTURE_DEFAULT	O
;	O
if	O
(	O
!	O
stream	int
->	O
supports_underline	O
)	O
attr	struct(int,int,int,int,int)
.	O
underline	int
=	O
UNDERLINE_DEFAULT	O
;	O
return	O
attr	struct(int,int,int,int,int)
;	O
}	O
static	O
term_ostream_t	O
volatile	O
out_stream	O
;	O
static	O
int	O
volatile	O
out_fd	int
=	O
-	O
1	int
;	O
static	O
void	O
out_error	()->(void)
(	O
void	O
)	O
{	O
error	()->(int)
(	O
EXIT_FAILURE	O
,	O
errno	O
,	O
_	O
(	O
"error writing to %s"	*(char)
)	O
,	O
out_stream	O
->	O
filename	*(char)
)	O
;	O
}	O
static	O
int	O
out_char	(int)->(int)
(	O
int	O
c	int
)	O
{	O
char	O
bytes	array(char)
[	O
1	int
]	O
;	O
bytes	array(char)
[	O
0	int
]	O
=	O
(	O
char	O
)	O
c	int
;	O
if	O
(	O
full_write	O
(	O
out_fd	int
,	O
bytes	array(char)
,	O
1	int
)	O
<	O
1	int
)	O
out_error	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
_GL_ASYNC_SAFE	O
int	O
out_char_unchecked	(int)->(int)
(	O
int	O
c	int
)	O
{	O
char	O
bytes	array(char)
[	O
1	int
]	O
;	O
bytes	array(char)
[	O
0	int
]	O
=	O
(	O
char	O
)	O
c	int
;	O
full_write	O
(	O
out_fd	int
,	O
bytes	array(char)
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
out_color_change	(int,int,int)->(void)
(	O
term_ostream_t	O
stream	int
,	O
term_color_t	O
new_color	int
,	O
bool	O
async_safe	int
)	O
{	O
assert	()->(int)
(	O
stream	int
->	O
supports_foreground	O
)	O
;	O
assert	()->(int)
(	O
new_color	int
!=	O
COLOR_DEFAULT	O
)	O
;	O
switch	O
(	O
stream	int
->	O
colormodel	O
)	O
{	O
case	O
cm_common8	int
:	O
assert	()->(int)
(	O
new_color	int
>=	O
0	int
&&	O
new_color	int
<	O
8	int
)	O
;	O
{	O
if	O
(	O
stream	int
->	O
set_a_foreground	O
!=	O
NULL	O
)	O
tputs	()->(int)
(	O
tparm	()->(int)
(	O
stream	int
->	O
set_a_foreground	O
,	O
color_bgr	(int)->(int)
(	O
new_color	int
)	O
)	O
,	O
1	int
,	O
async_safe	int
?	O
out_char_unchecked	(int)->(int)
:	O
out_char	(int)->(int)
)	O
;	O
else	O
tputs	()->(int)
(	O
tparm	()->(int)
(	O
stream	int
->	O
set_foreground	O
,	O
new_color	int
)	O
,	O
1	int
,	O
async_safe	int
?	O
out_char_unchecked	(int)->(int)
:	O
out_char	(int)->(int)
)	O
;	O
}	O
break	O
;	O
case	O
cm_xterm8	int
:	O
assert	()->(int)
(	O
new_color	int
>=	O
0	int
&&	O
new_color	int
<	O
8	int
)	O
;	O
{	O
char	O
bytes	array(char)
[	O
5	int
]	O
;	O
bytes	array(char)
[	O
0	int
]	O
=	O
0x1B	int
;	O
bytes	array(char)
[	O
1	int
]	O
=	O
'['	O
;	O
bytes	array(char)
[	O
2	int
]	O
=	O
'3'	O
;	O
bytes	array(char)
[	O
3	int
]	O
=	O
'0'	O
+	O
new_color	int
;	O
bytes	array(char)
[	O
4	int
]	O
=	O
'm'	O
;	O
if	O
(	O
full_write	O
(	O
out_fd	int
,	O
bytes	array(char)
,	O
5	int
)	O
<	O
5	int
)	O
if	O
(	O
!	O
async_safe	int
)	O
out_error	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
cm_xterm16	int
:	O
assert	()->(int)
(	O
new_color	int
>=	O
0	int
&&	O
new_color	int
<	O
16	int
)	O
;	O
{	O
char	O
bytes	array(char)
[	O
5	int
]	O
;	O
bytes	array(char)
[	O
0	int
]	O
=	O
0x1B	int
;	O
bytes	array(char)
[	O
1	int
]	O
=	O
'['	O
;	O
if	O
(	O
new_color	int
<	O
8	int
)	O
{	O
bytes	array(char)
[	O
2	int
]	O
=	O
'3'	O
;	O
bytes	array(char)
[	O
3	int
]	O
=	O
'0'	O
+	O
new_color	int
;	O
}	O
else	O
{	O
bytes	array(char)
[	O
2	int
]	O
=	O
'9'	O
;	O
bytes	array(char)
[	O
3	int
]	O
=	O
'0'	O
+	O
(	O
new_color	int
-	O
8	int
)	O
;	O
}	O
bytes	array(char)
[	O
4	int
]	O
=	O
'm'	O
;	O
if	O
(	O
full_write	O
(	O
out_fd	int
,	O
bytes	array(char)
,	O
5	int
)	O
<	O
5	int
)	O
if	O
(	O
!	O
async_safe	int
)	O
out_error	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
cm_xterm88	int
:	O
assert	()->(int)
(	O
new_color	int
>=	O
0	int
&&	O
new_color	int
<	O
88	int
)	O
;	O
{	O
char	O
bytes	array(char)
[	O
10	int
]	O
;	O
char	O
*	O
p	*(char)
;	O
bytes	array(char)
[	O
0	int
]	O
=	O
0x1B	int
;	O
bytes	array(char)
[	O
1	int
]	O
=	O
'['	O
;	O
bytes	array(char)
[	O
2	int
]	O
=	O
'3'	O
;	O
bytes	array(char)
[	O
3	int
]	O
=	O
'8'	O
;	O
bytes	array(char)
[	O
4	int
]	O
=	O
';'	O
;	O
bytes	array(char)
[	O
5	int
]	O
=	O
'5'	O
;	O
bytes	array(char)
[	O
6	int
]	O
=	O
';'	O
;	O
p	*(char)
=	O
bytes	array(char)
+	O
7	int
;	O
if	O
(	O
new_color	int
>=	O
10	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
new_color	int
/	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
new_color	int
%	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'm'	O
;	O
if	O
(	O
full_write	O
(	O
out_fd	int
,	O
bytes	array(char)
,	O
p	*(char)
-	O
bytes	array(char)
)	O
<	O
p	*(char)
-	O
bytes	array(char)
)	O
if	O
(	O
!	O
async_safe	int
)	O
out_error	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
cm_xterm256	int
:	O
assert	()->(int)
(	O
new_color	int
>=	O
0	int
&&	O
new_color	int
<	O
256	int
)	O
;	O
{	O
char	O
bytes	array(char)
[	O
11	int
]	O
;	O
char	O
*	O
p	*(char)
;	O
bytes	array(char)
[	O
0	int
]	O
=	O
0x1B	int
;	O
bytes	array(char)
[	O
1	int
]	O
=	O
'['	O
;	O
bytes	array(char)
[	O
2	int
]	O
=	O
'3'	O
;	O
bytes	array(char)
[	O
3	int
]	O
=	O
'8'	O
;	O
bytes	array(char)
[	O
4	int
]	O
=	O
';'	O
;	O
bytes	array(char)
[	O
5	int
]	O
=	O
'5'	O
;	O
bytes	array(char)
[	O
6	int
]	O
=	O
';'	O
;	O
p	*(char)
=	O
bytes	array(char)
+	O
7	int
;	O
if	O
(	O
new_color	int
>=	O
100	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
new_color	int
/	O
100	int
)	O
;	O
if	O
(	O
new_color	int
>=	O
10	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
(	O
new_color	int
%	O
100	int
)	O
/	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
new_color	int
%	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'm'	O
;	O
if	O
(	O
full_write	O
(	O
out_fd	int
,	O
bytes	array(char)
,	O
p	*(char)
-	O
bytes	array(char)
)	O
<	O
p	*(char)
-	O
bytes	array(char)
)	O
if	O
(	O
!	O
async_safe	int
)	O
out_error	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
cm_xtermrgb	int
:	O
assert	()->(int)
(	O
new_color	int
>=	O
0	int
&&	O
new_color	int
<	O
0x1000000	int
)	O
;	O
{	O
char	O
bytes	array(char)
[	O
19	int
]	O
;	O
char	O
*	O
p	*(char)
;	O
unsigned	O
int	O
r	int
=	O
(	O
new_color	int
>>	O
16	int
)	O
&	O
0xff	int
;	O
unsigned	O
int	O
g	int
=	O
(	O
new_color	int
>>	O
8	int
)	O
&	O
0xff	int
;	O
unsigned	O
int	O
b	int
=	O
new_color	int
&	O
0xff	int
;	O
bytes	array(char)
[	O
0	int
]	O
=	O
0x1B	int
;	O
bytes	array(char)
[	O
1	int
]	O
=	O
'['	O
;	O
bytes	array(char)
[	O
2	int
]	O
=	O
'3'	O
;	O
bytes	array(char)
[	O
3	int
]	O
=	O
'8'	O
;	O
bytes	array(char)
[	O
4	int
]	O
=	O
';'	O
;	O
bytes	array(char)
[	O
5	int
]	O
=	O
'2'	O
;	O
bytes	array(char)
[	O
6	int
]	O
=	O
';'	O
;	O
p	*(char)
=	O
bytes	array(char)
+	O
7	int
;	O
if	O
(	O
r	int
>=	O
100	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
r	int
/	O
100	int
)	O
;	O
if	O
(	O
r	int
>=	O
10	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
(	O
r	int
%	O
100	int
)	O
/	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
r	int
%	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
';'	O
;	O
if	O
(	O
g	int
>=	O
100	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
g	int
/	O
100	int
)	O
;	O
if	O
(	O
g	int
>=	O
10	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
(	O
g	int
%	O
100	int
)	O
/	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
g	int
%	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
';'	O
;	O
if	O
(	O
b	int
>=	O
100	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
b	int
/	O
100	int
)	O
;	O
if	O
(	O
b	int
>=	O
10	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
(	O
b	int
%	O
100	int
)	O
/	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
b	int
%	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'm'	O
;	O
if	O
(	O
full_write	O
(	O
out_fd	int
,	O
bytes	array(char)
,	O
p	*(char)
-	O
bytes	array(char)
)	O
<	O
p	*(char)
-	O
bytes	array(char)
)	O
if	O
(	O
!	O
async_safe	int
)	O
out_error	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
abort	O
(	O
)	O
;	O
}	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
out_bgcolor_change	(int,int,int)->(void)
(	O
term_ostream_t	O
stream	int
,	O
term_color_t	O
new_bgcolor	int
,	O
bool	O
async_safe	int
)	O
{	O
assert	()->(int)
(	O
stream	int
->	O
supports_background	O
)	O
;	O
assert	()->(int)
(	O
new_bgcolor	int
!=	O
COLOR_DEFAULT	O
)	O
;	O
switch	O
(	O
stream	int
->	O
colormodel	O
)	O
{	O
case	O
cm_common8	int
:	O
assert	()->(int)
(	O
new_bgcolor	int
>=	O
0	int
&&	O
new_bgcolor	int
<	O
8	int
)	O
;	O
{	O
if	O
(	O
stream	int
->	O
set_a_background	O
!=	O
NULL	O
)	O
tputs	()->(int)
(	O
tparm	()->(int)
(	O
stream	int
->	O
set_a_background	O
,	O
color_bgr	(int)->(int)
(	O
new_bgcolor	int
)	O
)	O
,	O
1	int
,	O
async_safe	int
?	O
out_char_unchecked	(int)->(int)
:	O
out_char	(int)->(int)
)	O
;	O
else	O
tputs	()->(int)
(	O
tparm	()->(int)
(	O
stream	int
->	O
set_background	O
,	O
new_bgcolor	int
)	O
,	O
1	int
,	O
async_safe	int
?	O
out_char_unchecked	(int)->(int)
:	O
out_char	(int)->(int)
)	O
;	O
}	O
break	O
;	O
case	O
cm_xterm8	int
:	O
assert	()->(int)
(	O
new_bgcolor	int
>=	O
0	int
&&	O
new_bgcolor	int
<	O
8	int
)	O
;	O
{	O
char	O
bytes	array(char)
[	O
5	int
]	O
;	O
bytes	array(char)
[	O
0	int
]	O
=	O
0x1B	int
;	O
bytes	array(char)
[	O
1	int
]	O
=	O
'['	O
;	O
bytes	array(char)
[	O
2	int
]	O
=	O
'4'	O
;	O
bytes	array(char)
[	O
3	int
]	O
=	O
'0'	O
+	O
new_bgcolor	int
;	O
bytes	array(char)
[	O
4	int
]	O
=	O
'm'	O
;	O
if	O
(	O
full_write	O
(	O
out_fd	int
,	O
bytes	array(char)
,	O
5	int
)	O
<	O
5	int
)	O
if	O
(	O
!	O
async_safe	int
)	O
out_error	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
cm_xterm16	int
:	O
assert	()->(int)
(	O
new_bgcolor	int
>=	O
0	int
&&	O
new_bgcolor	int
<	O
16	int
)	O
;	O
{	O
char	O
bytes	array(char)
[	O
6	int
]	O
;	O
bytes	array(char)
[	O
0	int
]	O
=	O
0x1B	int
;	O
bytes	array(char)
[	O
1	int
]	O
=	O
'['	O
;	O
if	O
(	O
new_bgcolor	int
<	O
8	int
)	O
{	O
bytes	array(char)
[	O
2	int
]	O
=	O
'4'	O
;	O
bytes	array(char)
[	O
3	int
]	O
=	O
'0'	O
+	O
new_bgcolor	int
;	O
bytes	array(char)
[	O
4	int
]	O
=	O
'm'	O
;	O
if	O
(	O
full_write	O
(	O
out_fd	int
,	O
bytes	array(char)
,	O
5	int
)	O
<	O
5	int
)	O
if	O
(	O
!	O
async_safe	int
)	O
out_error	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
bytes	array(char)
[	O
2	int
]	O
=	O
'1'	O
;	O
bytes	array(char)
[	O
3	int
]	O
=	O
'0'	O
;	O
bytes	array(char)
[	O
4	int
]	O
=	O
'0'	O
+	O
(	O
new_bgcolor	int
-	O
8	int
)	O
;	O
bytes	array(char)
[	O
5	int
]	O
=	O
'm'	O
;	O
if	O
(	O
full_write	O
(	O
out_fd	int
,	O
bytes	array(char)
,	O
6	int
)	O
<	O
6	int
)	O
if	O
(	O
!	O
async_safe	int
)	O
out_error	()->(void)
(	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
cm_xterm88	int
:	O
assert	()->(int)
(	O
new_bgcolor	int
>=	O
0	int
&&	O
new_bgcolor	int
<	O
88	int
)	O
;	O
{	O
char	O
bytes	array(char)
[	O
10	int
]	O
;	O
char	O
*	O
p	*(char)
;	O
bytes	array(char)
[	O
0	int
]	O
=	O
0x1B	int
;	O
bytes	array(char)
[	O
1	int
]	O
=	O
'['	O
;	O
bytes	array(char)
[	O
2	int
]	O
=	O
'4'	O
;	O
bytes	array(char)
[	O
3	int
]	O
=	O
'8'	O
;	O
bytes	array(char)
[	O
4	int
]	O
=	O
';'	O
;	O
bytes	array(char)
[	O
5	int
]	O
=	O
'5'	O
;	O
bytes	array(char)
[	O
6	int
]	O
=	O
';'	O
;	O
p	*(char)
=	O
bytes	array(char)
+	O
7	int
;	O
if	O
(	O
new_bgcolor	int
>=	O
10	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
new_bgcolor	int
/	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
new_bgcolor	int
%	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'm'	O
;	O
if	O
(	O
full_write	O
(	O
out_fd	int
,	O
bytes	array(char)
,	O
p	*(char)
-	O
bytes	array(char)
)	O
<	O
p	*(char)
-	O
bytes	array(char)
)	O
if	O
(	O
!	O
async_safe	int
)	O
out_error	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
cm_xterm256	int
:	O
assert	()->(int)
(	O
new_bgcolor	int
>=	O
0	int
&&	O
new_bgcolor	int
<	O
256	int
)	O
;	O
{	O
char	O
bytes	array(char)
[	O
11	int
]	O
;	O
char	O
*	O
p	*(char)
;	O
bytes	array(char)
[	O
0	int
]	O
=	O
0x1B	int
;	O
bytes	array(char)
[	O
1	int
]	O
=	O
'['	O
;	O
bytes	array(char)
[	O
2	int
]	O
=	O
'4'	O
;	O
bytes	array(char)
[	O
3	int
]	O
=	O
'8'	O
;	O
bytes	array(char)
[	O
4	int
]	O
=	O
';'	O
;	O
bytes	array(char)
[	O
5	int
]	O
=	O
'5'	O
;	O
bytes	array(char)
[	O
6	int
]	O
=	O
';'	O
;	O
p	*(char)
=	O
bytes	array(char)
+	O
7	int
;	O
if	O
(	O
new_bgcolor	int
>=	O
100	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
new_bgcolor	int
/	O
100	int
)	O
;	O
if	O
(	O
new_bgcolor	int
>=	O
10	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
(	O
new_bgcolor	int
%	O
100	int
)	O
/	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
new_bgcolor	int
%	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'm'	O
;	O
if	O
(	O
full_write	O
(	O
out_fd	int
,	O
bytes	array(char)
,	O
p	*(char)
-	O
bytes	array(char)
)	O
<	O
p	*(char)
-	O
bytes	array(char)
)	O
if	O
(	O
!	O
async_safe	int
)	O
out_error	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
cm_xtermrgb	int
:	O
assert	()->(int)
(	O
new_bgcolor	int
>=	O
0	int
&&	O
new_bgcolor	int
<	O
0x1000000	int
)	O
;	O
{	O
char	O
bytes	array(char)
[	O
19	int
]	O
;	O
char	O
*	O
p	*(char)
;	O
unsigned	O
int	O
r	int
=	O
(	O
new_bgcolor	int
>>	O
16	int
)	O
&	O
0xff	int
;	O
unsigned	O
int	O
g	int
=	O
(	O
new_bgcolor	int
>>	O
8	int
)	O
&	O
0xff	int
;	O
unsigned	O
int	O
b	int
=	O
new_bgcolor	int
&	O
0xff	int
;	O
bytes	array(char)
[	O
0	int
]	O
=	O
0x1B	int
;	O
bytes	array(char)
[	O
1	int
]	O
=	O
'['	O
;	O
bytes	array(char)
[	O
2	int
]	O
=	O
'4'	O
;	O
bytes	array(char)
[	O
3	int
]	O
=	O
'8'	O
;	O
bytes	array(char)
[	O
4	int
]	O
=	O
';'	O
;	O
bytes	array(char)
[	O
5	int
]	O
=	O
'2'	O
;	O
bytes	array(char)
[	O
6	int
]	O
=	O
';'	O
;	O
p	*(char)
=	O
bytes	array(char)
+	O
7	int
;	O
if	O
(	O
r	int
>=	O
100	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
r	int
/	O
100	int
)	O
;	O
if	O
(	O
r	int
>=	O
10	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
(	O
r	int
%	O
100	int
)	O
/	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
r	int
%	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
';'	O
;	O
if	O
(	O
g	int
>=	O
100	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
g	int
/	O
100	int
)	O
;	O
if	O
(	O
g	int
>=	O
10	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
(	O
g	int
%	O
100	int
)	O
/	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
g	int
%	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
';'	O
;	O
if	O
(	O
b	int
>=	O
100	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
b	int
/	O
100	int
)	O
;	O
if	O
(	O
b	int
>=	O
10	int
)	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
(	O
b	int
%	O
100	int
)	O
/	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'0'	O
+	O
(	O
b	int
%	O
10	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
'm'	O
;	O
if	O
(	O
full_write	O
(	O
out_fd	int
,	O
bytes	array(char)
,	O
p	*(char)
-	O
bytes	array(char)
)	O
<	O
p	*(char)
-	O
bytes	array(char)
)	O
if	O
(	O
!	O
async_safe	int
)	O
out_error	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
abort	O
(	O
)	O
;	O
}	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
out_weight_change	(int,int,int)->(void)
(	O
term_ostream_t	O
stream	int
,	O
term_weight_t	O
new_weight	int
,	O
bool	O
async_safe	int
)	O
{	O
assert	()->(int)
(	O
stream	int
->	O
supports_weight	O
)	O
;	O
assert	()->(int)
(	O
new_weight	int
!=	O
WEIGHT_DEFAULT	O
)	O
;	O
assert	()->(int)
(	O
new_weight	int
==	O
WEIGHT_BOLD	O
)	O
;	O
tputs	()->(int)
(	O
stream	int
->	O
enter_bold_mode	O
,	O
1	int
,	O
async_safe	int
?	O
out_char_unchecked	(int)->(int)
:	O
out_char	(int)->(int)
)	O
;	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
out_posture_change	(int,int,int)->(void)
(	O
term_ostream_t	O
stream	int
,	O
term_posture_t	O
new_posture	int
,	O
bool	O
async_safe	int
)	O
{	O
assert	()->(int)
(	O
stream	int
->	O
supports_posture	O
)	O
;	O
assert	()->(int)
(	O
new_posture	int
!=	O
POSTURE_DEFAULT	O
)	O
;	O
assert	()->(int)
(	O
new_posture	int
==	O
POSTURE_ITALIC	O
)	O
;	O
tputs	()->(int)
(	O
stream	int
->	O
enter_italics_mode	O
,	O
1	int
,	O
async_safe	int
?	O
out_char_unchecked	(int)->(int)
:	O
out_char	(int)->(int)
)	O
;	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
out_underline_change	(int,int,int)->(void)
(	O
term_ostream_t	O
stream	int
,	O
term_underline_t	O
new_underline	int
,	O
bool	O
async_safe	int
)	O
{	O
assert	()->(int)
(	O
stream	int
->	O
supports_underline	O
)	O
;	O
assert	()->(int)
(	O
new_underline	int
!=	O
UNDERLINE_DEFAULT	O
)	O
;	O
assert	()->(int)
(	O
new_underline	int
==	O
UNDERLINE_ON	O
)	O
;	O
{	O
tputs	()->(int)
(	O
stream	int
->	O
enter_underline_mode	O
,	O
1	int
,	O
async_safe	int
?	O
out_char_unchecked	(int)->(int)
:	O
out_char	(int)->(int)
)	O
;	O
}	O
}	O
static	O
void	O
out_attr_change	(int,struct(int,int,int,int,int))->(void)
(	O
term_ostream_t	O
stream	int
,	O
attributes_t	struct(int,int,int,int,int)
new_attr	struct(int,int,int,int,int)
)	O
{	O
attributes_t	struct(int,int,int,int,int)
old_attr	struct(int,int,int,int,int)
=	O
stream	int
->	O
active_attr	O
;	O
stream	int
->	O
active_attr	O
=	O
new_attr	struct(int,int,int,int,int)
;	O
stream	int
->	O
active_attr_color	O
=	O
new_attr	struct(int,int,int,int,int)
.	O
color	int
;	O
stream	int
->	O
active_attr_bgcolor	O
=	O
new_attr	struct(int,int,int,int,int)
.	O
bgcolor	int
;	O
{	O
bool	O
cleared_attributes	O
;	O
out_stream	O
=	O
stream	int
;	O
out_fd	int
=	O
stream	int
->	O
fd	int
;	O
if	O
(	O
(	O
new_attr	struct(int,int,int,int,int)
.	O
color	int
==	O
COLOR_DEFAULT	O
&&	O
old_attr	struct(int,int,int,int,int)
.	O
color	int
!=	O
COLOR_DEFAULT	O
)	O
||	O
(	O
new_attr	struct(int,int,int,int,int)
.	O
bgcolor	int
==	O
COLOR_DEFAULT	O
&&	O
old_attr	struct(int,int,int,int,int)
.	O
bgcolor	int
!=	O
COLOR_DEFAULT	O
)	O
)	O
{	O
assert	()->(int)
(	O
stream	int
->	O
supports_foreground	O
||	O
stream	int
->	O
supports_background	O
)	O
;	O
tputs	()->(int)
(	O
stream	int
->	O
orig_pair	O
,	O
1	int
,	O
out_char	(int)->(int)
)	O
;	O
old_attr	struct(int,int,int,int,int)
.	O
color	int
=	O
COLOR_DEFAULT	O
;	O
old_attr	struct(int,int,int,int,int)
.	O
bgcolor	int
=	O
COLOR_DEFAULT	O
;	O
}	O
cleared_attributes	O
=	O
false	O
;	O
if	O
(	O
old_attr	struct(int,int,int,int,int)
.	O
posture	int
!=	O
POSTURE_NORMAL	O
&&	O
new_attr	struct(int,int,int,int,int)
.	O
posture	int
==	O
POSTURE_NORMAL	O
&&	O
stream	int
->	O
exit_italics_mode	O
!=	O
NULL	O
)	O
{	O
tputs	()->(int)
(	O
stream	int
->	O
exit_italics_mode	O
,	O
1	int
,	O
out_char	(int)->(int)
)	O
;	O
old_attr	struct(int,int,int,int,int)
.	O
posture	int
=	O
POSTURE_NORMAL	O
;	O
cleared_attributes	O
=	O
true	O
;	O
}	O
if	O
(	O
old_attr	struct(int,int,int,int,int)
.	O
underline	int
!=	O
UNDERLINE_OFF	O
&&	O
new_attr	struct(int,int,int,int,int)
.	O
underline	int
==	O
UNDERLINE_OFF	O
&&	O
stream	int
->	O
exit_underline_mode	O
!=	O
NULL	O
)	O
{	O
tputs	()->(int)
(	O
stream	int
->	O
exit_underline_mode	O
,	O
1	int
,	O
out_char	(int)->(int)
)	O
;	O
old_attr	struct(int,int,int,int,int)
.	O
underline	int
=	O
UNDERLINE_OFF	O
;	O
cleared_attributes	O
=	O
true	O
;	O
}	O
if	O
(	O
(	O
old_attr	struct(int,int,int,int,int)
.	O
weight	int
!=	O
WEIGHT_NORMAL	O
&&	O
new_attr	struct(int,int,int,int,int)
.	O
weight	int
==	O
WEIGHT_NORMAL	O
)	O
||	O
(	O
old_attr	struct(int,int,int,int,int)
.	O
posture	int
!=	O
POSTURE_NORMAL	O
&&	O
new_attr	struct(int,int,int,int,int)
.	O
posture	int
==	O
POSTURE_NORMAL	O
)	O
||	O
(	O
old_attr	struct(int,int,int,int,int)
.	O
underline	int
!=	O
UNDERLINE_OFF	O
&&	O
new_attr	struct(int,int,int,int,int)
.	O
underline	int
==	O
UNDERLINE_OFF	O
)	O
)	O
{	O
tputs	()->(int)
(	O
stream	int
->	O
exit_attribute_mode	O
,	O
1	int
,	O
out_char	(int)->(int)
)	O
;	O
old_attr	struct(int,int,int,int,int)
.	O
weight	int
=	O
WEIGHT_NORMAL	O
;	O
if	O
(	O
stream	int
->	O
exit_italics_mode	O
==	O
NULL	O
)	O
old_attr	struct(int,int,int,int,int)
.	O
posture	int
=	O
POSTURE_NORMAL	O
;	O
if	O
(	O
stream	int
->	O
exit_underline_mode	O
==	O
NULL	O
)	O
old_attr	struct(int,int,int,int,int)
.	O
underline	int
=	O
UNDERLINE_OFF	O
;	O
cleared_attributes	O
=	O
true	O
;	O
}	O
if	O
(	O
new_attr	struct(int,int,int,int,int)
.	O
color	int
!=	O
old_attr	struct(int,int,int,int,int)
.	O
color	int
||	O
(	O
cleared_attributes	O
&&	O
new_attr	struct(int,int,int,int,int)
.	O
color	int
!=	O
COLOR_DEFAULT	O
)	O
)	O
{	O
out_color_change	(int,int,int)->(void)
(	O
stream	int
,	O
new_attr	struct(int,int,int,int,int)
.	O
color	int
,	O
false	O
)	O
;	O
}	O
if	O
(	O
new_attr	struct(int,int,int,int,int)
.	O
bgcolor	int
!=	O
old_attr	struct(int,int,int,int,int)
.	O
bgcolor	int
||	O
(	O
cleared_attributes	O
&&	O
new_attr	struct(int,int,int,int,int)
.	O
bgcolor	int
!=	O
COLOR_DEFAULT	O
)	O
)	O
{	O
out_bgcolor_change	(int,int,int)->(void)
(	O
stream	int
,	O
new_attr	struct(int,int,int,int,int)
.	O
bgcolor	int
,	O
false	O
)	O
;	O
}	O
if	O
(	O
new_attr	struct(int,int,int,int,int)
.	O
weight	int
!=	O
old_attr	struct(int,int,int,int,int)
.	O
weight	int
||	O
(	O
cleared_attributes	O
&&	O
new_attr	struct(int,int,int,int,int)
.	O
weight	int
!=	O
WEIGHT_DEFAULT	O
)	O
)	O
{	O
out_weight_change	(int,int,int)->(void)
(	O
stream	int
,	O
new_attr	struct(int,int,int,int,int)
.	O
weight	int
,	O
false	O
)	O
;	O
}	O
if	O
(	O
new_attr	struct(int,int,int,int,int)
.	O
posture	int
!=	O
old_attr	struct(int,int,int,int,int)
.	O
posture	int
||	O
(	O
cleared_attributes	O
&&	O
new_attr	struct(int,int,int,int,int)
.	O
posture	int
!=	O
POSTURE_DEFAULT	O
)	O
)	O
{	O
out_posture_change	(int,int,int)->(void)
(	O
stream	int
,	O
new_attr	struct(int,int,int,int,int)
.	O
posture	int
,	O
false	O
)	O
;	O
}	O
if	O
(	O
new_attr	struct(int,int,int,int,int)
.	O
underline	int
!=	O
old_attr	struct(int,int,int,int,int)
.	O
underline	int
||	O
(	O
cleared_attributes	O
&&	O
new_attr	struct(int,int,int,int,int)
.	O
underline	int
!=	O
UNDERLINE_DEFAULT	O
)	O
)	O
{	O
out_underline_change	(int,int,int)->(void)
(	O
stream	int
,	O
new_attr	struct(int,int,int,int,int)
.	O
underline	int
,	O
false	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
restore	(int)->(void)
(	O
term_ostream_t	O
stream	int
)	O
{	O
{	O
out_stream	O
=	O
stream	int
;	O
out_fd	int
=	O
stream	int
->	O
fd	int
;	O
if	O
(	O
stream	int
->	O
restore_colors	O
!=	O
NULL	O
)	O
tputs	()->(int)
(	O
stream	int
->	O
restore_colors	O
,	O
1	int
,	O
out_char_unchecked	(int)->(int)
)	O
;	O
if	O
(	O
stream	int
->	O
restore_weight	O
!=	O
NULL	O
)	O
tputs	()->(int)
(	O
stream	int
->	O
restore_weight	O
,	O
1	int
,	O
out_char_unchecked	(int)->(int)
)	O
;	O
if	O
(	O
stream	int
->	O
restore_posture	O
!=	O
NULL	O
)	O
tputs	()->(int)
(	O
stream	int
->	O
restore_posture	O
,	O
1	int
,	O
out_char_unchecked	(int)->(int)
)	O
;	O
if	O
(	O
stream	int
->	O
restore_underline	O
!=	O
NULL	O
)	O
tputs	()->(int)
(	O
stream	int
->	O
restore_underline	O
,	O
1	int
,	O
out_char_unchecked	(int)->(int)
)	O
;	O
}	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
async_restore	(int)->(void)
(	O
term_ostream_t	O
stream	int
)	O
{	O
{	O
out_stream	O
=	O
stream	int
;	O
out_fd	int
=	O
stream	int
->	O
fd	int
;	O
if	O
(	O
stream	int
->	O
restore_colors	O
!=	O
NULL	O
)	O
tputs	()->(int)
(	O
stream	int
->	O
restore_colors	O
,	O
1	int
,	O
out_char_unchecked	(int)->(int)
)	O
;	O
if	O
(	O
stream	int
->	O
restore_weight	O
!=	O
NULL	O
)	O
tputs	()->(int)
(	O
stream	int
->	O
restore_weight	O
,	O
1	int
,	O
out_char_unchecked	(int)->(int)
)	O
;	O
if	O
(	O
stream	int
->	O
restore_posture	O
!=	O
NULL	O
)	O
tputs	()->(int)
(	O
stream	int
->	O
restore_posture	O
,	O
1	int
,	O
out_char_unchecked	(int)->(int)
)	O
;	O
if	O
(	O
stream	int
->	O
restore_underline	O
!=	O
NULL	O
)	O
tputs	()->(int)
(	O
stream	int
->	O
restore_underline	O
,	O
1	int
,	O
out_char_unchecked	(int)->(int)
)	O
;	O
}	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
async_set_attributes_from_default	(int)->(void)
(	O
term_ostream_t	O
stream	int
)	O
{	O
{	O
attributes_t	struct(int,int,int,int,int)
new_attr	struct(int,int,int,int,int)
=	O
stream	int
->	O
active_attr	O
;	O
new_attr	struct(int,int,int,int,int)
.	O
color	int
=	O
stream	int
->	O
active_attr_color	O
;	O
new_attr	struct(int,int,int,int,int)
.	O
bgcolor	int
=	O
stream	int
->	O
active_attr_bgcolor	O
;	O
out_stream	O
=	O
stream	int
;	O
out_fd	int
=	O
stream	int
->	O
fd	int
;	O
if	O
(	O
new_attr	struct(int,int,int,int,int)
.	O
color	int
!=	O
COLOR_DEFAULT	O
)	O
out_color_change	(int,int,int)->(void)
(	O
stream	int
,	O
new_attr	struct(int,int,int,int,int)
.	O
color	int
,	O
true	O
)	O
;	O
if	O
(	O
new_attr	struct(int,int,int,int,int)
.	O
bgcolor	int
!=	O
COLOR_DEFAULT	O
)	O
out_bgcolor_change	(int,int,int)->(void)
(	O
stream	int
,	O
new_attr	struct(int,int,int,int,int)
.	O
bgcolor	int
,	O
true	O
)	O
;	O
if	O
(	O
new_attr	struct(int,int,int,int,int)
.	O
weight	int
!=	O
WEIGHT_DEFAULT	O
)	O
out_weight_change	(int,int,int)->(void)
(	O
stream	int
,	O
new_attr	struct(int,int,int,int,int)
.	O
weight	int
,	O
true	O
)	O
;	O
if	O
(	O
new_attr	struct(int,int,int,int,int)
.	O
posture	int
!=	O
POSTURE_DEFAULT	O
)	O
out_posture_change	(int,int,int)->(void)
(	O
stream	int
,	O
new_attr	struct(int,int,int,int,int)
.	O
posture	int
,	O
true	O
)	O
;	O
if	O
(	O
new_attr	struct(int,int,int,int,int)
.	O
underline	int
!=	O
UNDERLINE_DEFAULT	O
)	O
out_underline_change	(int,int,int)->(void)
(	O
stream	int
,	O
new_attr	struct(int,int,int,int,int)
.	O
underline	int
,	O
true	O
)	O
;	O
}	O
}	O
static	O
const	O
struct	O
term_style_controller	O
controller	struct
=	O
{	O
get_control_data	(int)->(*(struct))
,	O
restore	(int)->(void)
,	O
async_restore	(int)->(void)
,	O
async_set_attributes_from_default	(int)->(void)
}	O
;	O
static	O
void	O
activate_default_attr	(int)->(void)
(	O
term_ostream_t	O
stream	int
)	O
{	O
out_attr_change	(int,struct(int,int,int,int,int))->(void)
(	O
stream	int
,	O
stream	int
->	O
default_attr	O
)	O
;	O
deactivate_term_non_default_mode	O
(	O
&	O
controller	struct
,	O
stream	int
)	O
;	O
}	O
static	O
void	O
output_buffer	(int,struct(int,int,int,int,int))->(void)
(	O
term_ostream_t	O
stream	int
,	O
attributes_t	struct(int,int,int,int,int)
goal_attr	struct(int,int,int,int,int)
)	O
{	O
const	O
char	O
*	O
cp	*(char)
;	O
const	O
attributes_t	struct(int,int,int,int,int)
*	O
ap	*(struct(int,int,int,int,int))
;	O
size_t	O
len	int
;	O
size_t	O
n	O
;	O
cp	*(char)
=	O
stream	int
->	O
buffer	O
;	O
ap	*(struct(int,int,int,int,int))
=	O
stream	int
->	O
attrbuffer	O
;	O
len	int
=	O
stream	int
->	O
buflen	O
;	O
for	O
(	O
n	O
=	O
0	int
;	O
n	O
<	O
len	int
&&	O
equal_attributes	(struct(int,int,int,int,int),struct(int,int,int,int,int))->(int)
(	O
ap	*(struct(int,int,int,int,int))
[	O
n	O
]	O
,	O
stream	int
->	O
active_attr	O
)	O
;	O
n	O
++	O
)	O
;	O
if	O
(	O
n	O
>	O
0	int
)	O
{	O
if	O
(	O
full_write	O
(	O
stream	int
->	O
fd	int
,	O
cp	*(char)
,	O
n	O
)	O
<	O
n	O
)	O
{	O
int	O
error_code	int
=	O
errno	O
;	O
if	O
(	O
!	O
equal_attributes	(struct(int,int,int,int,int),struct(int,int,int,int,int))->(int)
(	O
stream	int
->	O
active_attr	O
,	O
stream	int
->	O
default_attr	O
)	O
)	O
activate_default_attr	(int)->(void)
(	O
stream	int
)	O
;	O
error	()->(int)
(	O
EXIT_FAILURE	O
,	O
error_code	int
,	O
_	O
(	O
"error writing to %s"	*(char)
)	O
,	O
stream	int
->	O
filename	*(char)
)	O
;	O
}	O
cp	*(char)
+=	O
n	O
;	O
ap	*(struct(int,int,int,int,int))
+=	O
n	O
;	O
len	int
-=	O
n	O
;	O
}	O
if	O
(	O
len	int
>	O
0	int
)	O
{	O
if	O
(	O
!	O
equal_attributes	(struct(int,int,int,int,int),struct(int,int,int,int,int))->(int)
(	O
*	O
ap	*(struct(int,int,int,int,int))
,	O
stream	int
->	O
default_attr	O
)	O
)	O
activate_term_non_default_mode	O
(	O
&	O
controller	struct
,	O
stream	int
)	O
;	O
do	O
{	O
out_attr_change	(int,struct(int,int,int,int,int))->(void)
(	O
stream	int
,	O
*	O
ap	*(struct(int,int,int,int,int))
)	O
;	O
for	O
(	O
n	O
=	O
1	int
;	O
n	O
<	O
len	int
&&	O
equal_attributes	(struct(int,int,int,int,int),struct(int,int,int,int,int))->(int)
(	O
ap	*(struct(int,int,int,int,int))
[	O
n	O
]	O
,	O
stream	int
->	O
active_attr	O
)	O
;	O
n	O
++	O
)	O
;	O
if	O
(	O
full_write	O
(	O
stream	int
->	O
fd	int
,	O
cp	*(char)
,	O
n	O
)	O
<	O
n	O
)	O
{	O
int	O
error_code	int
=	O
errno	O
;	O
if	O
(	O
!	O
equal_attributes	(struct(int,int,int,int,int),struct(int,int,int,int,int))->(int)
(	O
stream	int
->	O
active_attr	O
,	O
stream	int
->	O
default_attr	O
)	O
)	O
activate_default_attr	(int)->(void)
(	O
stream	int
)	O
;	O
error	()->(int)
(	O
EXIT_FAILURE	O
,	O
error_code	int
,	O
_	O
(	O
"error writing to %s"	*(char)
)	O
,	O
stream	int
->	O
filename	*(char)
)	O
;	O
}	O
cp	*(char)
+=	O
n	O
;	O
ap	*(struct(int,int,int,int,int))
+=	O
n	O
;	O
len	int
-=	O
n	O
;	O
}	O
while	O
(	O
len	int
>	O
0	int
)	O
;	O
}	O
stream	int
->	O
buflen	O
=	O
0	int
;	O
if	O
(	O
!	O
equal_attributes	(struct(int,int,int,int,int),struct(int,int,int,int,int))->(int)
(	O
goal_attr	struct(int,int,int,int,int)
,	O
stream	int
->	O
default_attr	O
)	O
)	O
activate_term_non_default_mode	O
(	O
&	O
controller	struct
,	O
stream	int
)	O
;	O
if	O
(	O
!	O
equal_attributes	(struct(int,int,int,int,int),struct(int,int,int,int,int))->(int)
(	O
goal_attr	struct(int,int,int,int,int)
,	O
stream	int
->	O
active_attr	O
)	O
)	O
out_attr_change	(int,struct(int,int,int,int,int))->(void)
(	O
stream	int
,	O
goal_attr	struct(int,int,int,int,int)
)	O
;	O
if	O
(	O
equal_attributes	(struct(int,int,int,int,int),struct(int,int,int,int,int))->(int)
(	O
goal_attr	struct(int,int,int,int,int)
,	O
stream	int
->	O
default_attr	O
)	O
)	O
deactivate_term_non_default_mode	O
(	O
&	O
controller	struct
,	O
stream	int
)	O
;	O
}	O
static	O
term_color_t	O
term_ostream__rgb_to_color	(int,int,int,int)->(int)
(	O
term_ostream_t	O
stream	int
,	O
int	O
red	int
,	O
int	O
green	int
,	O
int	O
blue	int
)	O
{	O
switch	O
(	O
stream	int
->	O
colormodel	O
)	O
{	O
case	O
cm_monochrome	int
:	O
return	O
rgb_to_color_monochrome	()->(int)
(	O
)	O
;	O
case	O
cm_common8	int
:	O
return	O
rgb_to_color_common8	(int,int,int)->(int)
(	O
red	int
,	O
green	int
,	O
blue	int
)	O
;	O
case	O
cm_xterm8	int
:	O
return	O
rgb_to_color_xterm8	(int,int,int)->(int)
(	O
red	int
,	O
green	int
,	O
blue	int
)	O
;	O
case	O
cm_xterm16	int
:	O
return	O
rgb_to_color_xterm16	(int,int,int)->(int)
(	O
red	int
,	O
green	int
,	O
blue	int
)	O
;	O
case	O
cm_xterm88	int
:	O
return	O
rgb_to_color_xterm88	(int,int,int)->(int)
(	O
red	int
,	O
green	int
,	O
blue	int
)	O
;	O
case	O
cm_xterm256	int
:	O
return	O
rgb_to_color_xterm256	(int,int,int)->(int)
(	O
red	int
,	O
green	int
,	O
blue	int
)	O
;	O
case	O
cm_xtermrgb	int
:	O
return	O
rgb_to_color_xtermrgb	(int,int,int)->(int)
(	O
red	int
,	O
green	int
,	O
blue	int
)	O
;	O
default	O
:	O
abort	O
(	O
)	O
;	O
}	O
}	O
static	O
void	O
term_ostream__write_mem	(int,*(void),int)->(void)
(	O
term_ostream_t	O
stream	int
,	O
const	O
void	O
*	O
data	*(void)
,	O
size_t	O
len	int
)	O
{	O
const	O
char	O
*	O
cp	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
data	*(void)
;	O
while	O
(	O
len	int
>	O
0	int
)	O
{	O
const	O
char	O
*	O
newline	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
memchr	O
(	O
cp	*(char)
,	O
'\n'	O
,	O
len	int
)	O
;	O
size_t	O
n	O
=	O
(	O
newline	*(char)
!=	O
NULL	O
?	O
newline	*(char)
-	O
cp	*(char)
:	O
len	int
)	O
;	O
if	O
(	O
n	O
>	O
stream	int
->	O
allocated	O
-	O
stream	int
->	O
buflen	O
)	O
{	O
size_t	O
new_allocated	O
=	O
xmax	O
(	O
xsum	O
(	O
stream	int
->	O
buflen	O
,	O
n	O
)	O
,	O
xsum	O
(	O
stream	int
->	O
allocated	O
,	O
stream	int
->	O
allocated	O
)	O
)	O
;	O
if	O
(	O
size_overflow_p	()->(int)
(	O
new_allocated	O
)	O
)	O
error	()->(int)
(	O
EXIT_FAILURE	O
,	O
0	int
,	O
_	O
(	O
"%s: too much output, buffer size overflow"	*(char)
)	O
,	O
"term_ostream"	*(char)
)	O
;	O
stream	int
->	O
buffer	O
=	O
(	O
char	O
*	O
)	O
xrealloc	O
(	O
stream	int
->	O
buffer	O
,	O
new_allocated	O
)	O
;	O
stream	int
->	O
attrbuffer	O
=	O
(	O
attributes_t	struct(int,int,int,int,int)
*	O
)	O
xrealloc	O
(	O
stream	int
->	O
attrbuffer	O
,	O
new_allocated	O
*	O
sizeof	O
(	O
attributes_t	struct(int,int,int,int,int)
)	O
)	O
;	O
stream	int
->	O
allocated	O
=	O
new_allocated	O
;	O
}	O
memcpy	O
(	O
stream	int
->	O
buffer	O
+	O
stream	int
->	O
buflen	O
,	O
cp	*(char)
,	O
n	O
)	O
;	O
{	O
attributes_t	struct(int,int,int,int,int)
attr	struct(int,int,int,int,int)
=	O
stream	int
->	O
simp_attr	O
;	O
attributes_t	struct(int,int,int,int,int)
*	O
ap	*(struct(int,int,int,int,int))
=	O
stream	int
->	O
attrbuffer	O
+	O
stream	int
->	O
buflen	O
;	O
attributes_t	struct(int,int,int,int,int)
*	O
ap_end	*(struct(int,int,int,int,int))
=	O
ap	*(struct(int,int,int,int,int))
+	O
n	O
;	O
for	O
(	O
;	O
ap	*(struct(int,int,int,int,int))
<	O
ap_end	*(struct(int,int,int,int,int))
;	O
ap	*(struct(int,int,int,int,int))
++	O
)	O
*	O
ap	*(struct(int,int,int,int,int))
=	O
attr	struct(int,int,int,int,int)
;	O
}	O
stream	int
->	O
buflen	O
+=	O
n	O
;	O
if	O
(	O
newline	*(char)
!=	O
NULL	O
)	O
{	O
output_buffer	(int,struct(int,int,int,int,int))->(void)
(	O
stream	int
,	O
stream	int
->	O
default_attr	O
)	O
;	O
if	O
(	O
full_write	O
(	O
stream	int
->	O
fd	int
,	O
"\n"	*(char)
,	O
1	int
)	O
<	O
1	int
)	O
error	()->(int)
(	O
EXIT_FAILURE	O
,	O
errno	O
,	O
_	O
(	O
"error writing to %s"	*(char)
)	O
,	O
stream	int
->	O
filename	*(char)
)	O
;	O
cp	*(char)
+=	O
n	O
+	O
1	int
;	O
len	int
-=	O
n	O
+	O
1	int
;	O
}	O
else	O
break	O
;	O
}	O
}	O
static	O
void	O
term_ostream__flush	(int,int)->(void)
(	O
term_ostream_t	O
stream	int
,	O
ostream_flush_scope_t	O
scope	int
)	O
{	O
output_buffer	(int,struct(int,int,int,int,int))->(void)
(	O
stream	int
,	O
stream	int
->	O
default_attr	O
)	O
;	O
if	O
(	O
scope	int
==	O
FLUSH_ALL	O
)	O
{	O
{	O
fsync	()->(int)
(	O
stream	int
->	O
fd	int
)	O
;	O
nonintr_tcdrain	(int)->(int)
(	O
stream	int
->	O
fd	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
term_ostream__free	(int)->(void)
(	O
term_ostream_t	O
stream	int
)	O
{	O
term_ostream_flush	()->(int)
(	O
stream	int
,	O
FLUSH_THIS_STREAM	O
)	O
;	O
deactivate_term_style_controller	O
(	O
&	O
controller	struct
,	O
stream	int
)	O
;	O
free	()->(int)
(	O
stream	int
->	O
filename	*(char)
)	O
;	O
if	O
(	O
stream	int
->	O
set_a_foreground	O
!=	O
NULL	O
)	O
free	()->(int)
(	O
stream	int
->	O
set_a_foreground	O
)	O
;	O
if	O
(	O
stream	int
->	O
set_foreground	O
!=	O
NULL	O
)	O
free	()->(int)
(	O
stream	int
->	O
set_foreground	O
)	O
;	O
if	O
(	O
stream	int
->	O
set_a_background	O
!=	O
NULL	O
)	O
free	()->(int)
(	O
stream	int
->	O
set_a_background	O
)	O
;	O
if	O
(	O
stream	int
->	O
set_background	O
!=	O
NULL	O
)	O
free	()->(int)
(	O
stream	int
->	O
set_background	O
)	O
;	O
if	O
(	O
stream	int
->	O
orig_pair	O
!=	O
NULL	O
)	O
free	()->(int)
(	O
stream	int
->	O
orig_pair	O
)	O
;	O
if	O
(	O
stream	int
->	O
enter_bold_mode	O
!=	O
NULL	O
)	O
free	()->(int)
(	O
stream	int
->	O
enter_bold_mode	O
)	O
;	O
if	O
(	O
stream	int
->	O
enter_italics_mode	O
!=	O
NULL	O
)	O
free	()->(int)
(	O
stream	int
->	O
enter_italics_mode	O
)	O
;	O
if	O
(	O
stream	int
->	O
exit_italics_mode	O
!=	O
NULL	O
)	O
free	()->(int)
(	O
stream	int
->	O
exit_italics_mode	O
)	O
;	O
if	O
(	O
stream	int
->	O
enter_underline_mode	O
!=	O
NULL	O
)	O
free	()->(int)
(	O
stream	int
->	O
enter_underline_mode	O
)	O
;	O
if	O
(	O
stream	int
->	O
exit_underline_mode	O
!=	O
NULL	O
)	O
free	()->(int)
(	O
stream	int
->	O
exit_underline_mode	O
)	O
;	O
if	O
(	O
stream	int
->	O
exit_attribute_mode	O
!=	O
NULL	O
)	O
free	()->(int)
(	O
stream	int
->	O
exit_attribute_mode	O
)	O
;	O
free	()->(int)
(	O
stream	int
->	O
buffer	O
)	O
;	O
free	()->(int)
(	O
stream	int
)	O
;	O
}	O
static	O
term_color_t	O
term_ostream__get_color	(int)->(int)
(	O
term_ostream_t	O
stream	int
)	O
{	O
return	O
stream	int
->	O
curr_attr	O
.	O
color	int
;	O
}	O
static	O
void	O
term_ostream__set_color	(int,int)->(void)
(	O
term_ostream_t	O
stream	int
,	O
term_color_t	O
color	int
)	O
{	O
stream	int
->	O
curr_attr	O
.	O
color	int
=	O
color	int
;	O
stream	int
->	O
simp_attr	O
=	O
simplify_attributes	(int,struct(int,int,int,int,int))->(struct(int,int,int,int,int))
(	O
stream	int
,	O
stream	int
->	O
curr_attr	O
)	O
;	O
}	O
static	O
term_color_t	O
term_ostream__get_bgcolor	(int)->(int)
(	O
term_ostream_t	O
stream	int
)	O
{	O
return	O
stream	int
->	O
curr_attr	O
.	O
bgcolor	int
;	O
}	O
static	O
void	O
term_ostream__set_bgcolor	(int,int)->(void)
(	O
term_ostream_t	O
stream	int
,	O
term_color_t	O
color	int
)	O
{	O
stream	int
->	O
curr_attr	O
.	O
bgcolor	int
=	O
color	int
;	O
stream	int
->	O
simp_attr	O
=	O
simplify_attributes	(int,struct(int,int,int,int,int))->(struct(int,int,int,int,int))
(	O
stream	int
,	O
stream	int
->	O
curr_attr	O
)	O
;	O
}	O
static	O
term_weight_t	O
term_ostream__get_weight	(int)->(int)
(	O
term_ostream_t	O
stream	int
)	O
{	O
return	O
stream	int
->	O
curr_attr	O
.	O
weight	int
;	O
}	O
static	O
void	O
term_ostream__set_weight	(int,int)->(void)
(	O
term_ostream_t	O
stream	int
,	O
term_weight_t	O
weight	int
)	O
{	O
stream	int
->	O
curr_attr	O
.	O
weight	int
=	O
weight	int
;	O
stream	int
->	O
simp_attr	O
=	O
simplify_attributes	(int,struct(int,int,int,int,int))->(struct(int,int,int,int,int))
(	O
stream	int
,	O
stream	int
->	O
curr_attr	O
)	O
;	O
}	O
static	O
term_posture_t	O
term_ostream__get_posture	(int)->(int)
(	O
term_ostream_t	O
stream	int
)	O
{	O
return	O
stream	int
->	O
curr_attr	O
.	O
posture	int
;	O
}	O
static	O
void	O
term_ostream__set_posture	(int,int)->(void)
(	O
term_ostream_t	O
stream	int
,	O
term_posture_t	O
posture	int
)	O
{	O
stream	int
->	O
curr_attr	O
.	O
posture	int
=	O
posture	int
;	O
stream	int
->	O
simp_attr	O
=	O
simplify_attributes	(int,struct(int,int,int,int,int))->(struct(int,int,int,int,int))
(	O
stream	int
,	O
stream	int
->	O
curr_attr	O
)	O
;	O
}	O
static	O
term_underline_t	O
term_ostream__get_underline	(int)->(int)
(	O
term_ostream_t	O
stream	int
)	O
{	O
return	O
stream	int
->	O
curr_attr	O
.	O
underline	int
;	O
}	O
static	O
void	O
term_ostream__set_underline	(int,int)->(void)
(	O
term_ostream_t	O
stream	int
,	O
term_underline_t	O
underline	int
)	O
{	O
stream	int
->	O
curr_attr	O
.	O
underline	int
=	O
underline	int
;	O
stream	int
->	O
simp_attr	O
=	O
simplify_attributes	(int,struct(int,int,int,int,int))->(struct(int,int,int,int,int))
(	O
stream	int
,	O
stream	int
->	O
curr_attr	O
)	O
;	O
}	O
static	O
void	O
term_ostream__flush_to_current_style	(int)->(void)
(	O
term_ostream_t	O
stream	int
)	O
{	O
output_buffer	(int,struct(int,int,int,int,int))->(void)
(	O
stream	int
,	O
stream	int
->	O
simp_attr	O
)	O
;	O
}	O
static	O
inline	O
char	O
*	O
xstrdup0	(*(char))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
str	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
str	*(char)
==	O
(	O
const	O
char	O
*	O
)	O
(	O
-	O
1	int
)	O
)	O
return	O
NULL	O
;	O
return	O
xstrdup	O
(	O
str	*(char)
)	O
;	O
}	O
term_ostream_t	O
term_ostream_create	(int,*(char),int)->(int)
(	O
int	O
fd	int
,	O
const	O
char	O
*	O
filename	*(char)
,	O
ttyctl_t	O
tty_control	int
)	O
{	O
term_ostream_t	O
stream	int
=	O
XMALLOC	O
(	O
struct	O
term_ostream_representation	O
)	O
;	O
stream	int
->	O
base	O
.	O
vtable	*(struct)
=	O
&	O
term_ostream_vtable	O
;	O
stream	int
->	O
fd	int
=	O
fd	int
;	O
stream	int
->	O
filename	*(char)
=	O
xstrdup	O
(	O
filename	*(char)
)	O
;	O
stream	int
->	O
max_colors	O
=	O
-	O
1	int
;	O
stream	int
->	O
no_color_video	O
=	O
-	O
1	int
;	O
stream	int
->	O
set_a_foreground	O
=	O
NULL	O
;	O
stream	int
->	O
set_foreground	O
=	O
NULL	O
;	O
stream	int
->	O
set_a_background	O
=	O
NULL	O
;	O
stream	int
->	O
set_background	O
=	O
NULL	O
;	O
stream	int
->	O
orig_pair	O
=	O
NULL	O
;	O
stream	int
->	O
enter_bold_mode	O
=	O
NULL	O
;	O
stream	int
->	O
enter_italics_mode	O
=	O
NULL	O
;	O
stream	int
->	O
exit_italics_mode	O
=	O
NULL	O
;	O
stream	int
->	O
enter_underline_mode	O
=	O
NULL	O
;	O
stream	int
->	O
exit_underline_mode	O
=	O
NULL	O
;	O
stream	int
->	O
exit_attribute_mode	O
=	O
NULL	O
;	O
{	O
const	O
char	O
*	O
term	*(char)
;	O
term	*(char)
=	O
getenv	()->(int)
(	O
"TERM"	*(char)
)	O
;	O
if	O
(	O
term	*(char)
!=	O
NULL	O
&&	O
term	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
int	O
err	int
=	O
1	int
;	O
if	O
(	O
setupterm	()->(int)
(	O
term	*(char)
,	O
fd	int
,	O
&	O
err	int
)	O
||	O
err	int
==	O
1	int
)	O
{	O
stream	int
->	O
max_colors	O
=	O
tigetnum	()->(int)
(	O
"colors"	*(char)
)	O
;	O
stream	int
->	O
no_color_video	O
=	O
tigetnum	()->(int)
(	O
"ncv"	*(char)
)	O
;	O
stream	int
->	O
set_a_foreground	O
=	O
xstrdup0	(*(char))->(*(char))
(	O
tigetstr	()->(int)
(	O
"setaf"	*(char)
)	O
)	O
;	O
stream	int
->	O
set_foreground	O
=	O
xstrdup0	(*(char))->(*(char))
(	O
tigetstr	()->(int)
(	O
"setf"	*(char)
)	O
)	O
;	O
stream	int
->	O
set_a_background	O
=	O
xstrdup0	(*(char))->(*(char))
(	O
tigetstr	()->(int)
(	O
"setab"	*(char)
)	O
)	O
;	O
stream	int
->	O
set_background	O
=	O
xstrdup0	(*(char))->(*(char))
(	O
tigetstr	()->(int)
(	O
"setb"	*(char)
)	O
)	O
;	O
stream	int
->	O
orig_pair	O
=	O
xstrdup0	(*(char))->(*(char))
(	O
tigetstr	()->(int)
(	O
"op"	*(char)
)	O
)	O
;	O
stream	int
->	O
enter_bold_mode	O
=	O
xstrdup0	(*(char))->(*(char))
(	O
tigetstr	()->(int)
(	O
"bold"	*(char)
)	O
)	O
;	O
stream	int
->	O
enter_italics_mode	O
=	O
xstrdup0	(*(char))->(*(char))
(	O
tigetstr	()->(int)
(	O
"sitm"	*(char)
)	O
)	O
;	O
stream	int
->	O
exit_italics_mode	O
=	O
xstrdup0	(*(char))->(*(char))
(	O
tigetstr	()->(int)
(	O
"ritm"	*(char)
)	O
)	O
;	O
stream	int
->	O
enter_underline_mode	O
=	O
xstrdup0	(*(char))->(*(char))
(	O
tigetstr	()->(int)
(	O
"smul"	*(char)
)	O
)	O
;	O
stream	int
->	O
exit_underline_mode	O
=	O
xstrdup0	(*(char))->(*(char))
(	O
tigetstr	()->(int)
(	O
"rmul"	*(char)
)	O
)	O
;	O
stream	int
->	O
exit_attribute_mode	O
=	O
xstrdup0	(*(char))->(*(char))
(	O
tigetstr	()->(int)
(	O
"sgr0"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
stream	int
->	O
max_colors	O
<=	O
1	int
&&	O
(	O
strcmp	O
(	O
term	*(char)
,	O
"xterm"	*(char)
)	O
==	O
0	int
||	O
strcmp	O
(	O
term	*(char)
,	O
"xterms"	*(char)
)	O
==	O
0	int
)	O
)	O
{	O
stream	int
->	O
max_colors	O
=	O
8	int
;	O
stream	int
->	O
set_a_foreground	O
=	O
xstrdup	O
(	O
"\033[3%p1%dm"	*(char)
)	O
;	O
stream	int
->	O
set_a_background	O
=	O
xstrdup	O
(	O
"\033[4%p1%dm"	*(char)
)	O
;	O
stream	int
->	O
orig_pair	O
=	O
xstrdup	O
(	O
"\033[39;49m"	*(char)
)	O
;	O
}	O
}	O
stream	int
->	O
supports_foreground	O
=	O
(	O
stream	int
->	O
max_colors	O
>=	O
8	int
&&	O
(	O
stream	int
->	O
set_a_foreground	O
!=	O
NULL	O
||	O
stream	int
->	O
set_foreground	O
!=	O
NULL	O
)	O
&&	O
stream	int
->	O
orig_pair	O
!=	O
NULL	O
)	O
;	O
stream	int
->	O
supports_background	O
=	O
(	O
stream	int
->	O
max_colors	O
>=	O
8	int
&&	O
(	O
stream	int
->	O
set_a_background	O
!=	O
NULL	O
||	O
stream	int
->	O
set_background	O
!=	O
NULL	O
)	O
&&	O
stream	int
->	O
orig_pair	O
!=	O
NULL	O
)	O
;	O
stream	int
->	O
colormodel	O
=	O
(	O
stream	int
->	O
supports_foreground	O
||	O
stream	int
->	O
supports_background	O
?	O
(	O
term	*(char)
!=	O
NULL	O
&&	O
(	O
(	O
strlen	O
(	O
term	*(char)
)	O
>=	O
5	int
&&	O
memcmp	O
(	O
term	*(char)
,	O
"xterm"	*(char)
,	O
5	int
)	O
==	O
0	int
)	O
||	O
(	O
strlen	O
(	O
term	*(char)
)	O
>	O
8	int
&&	O
strcmp	O
(	O
term	*(char)
+	O
strlen	O
(	O
term	*(char)
)	O
-	O
8	int
,	O
"-16color"	*(char)
)	O
==	O
0	int
)	O
||	O
(	O
strlen	O
(	O
term	*(char)
)	O
>	O
9	int
&&	O
strcmp	O
(	O
term	*(char)
+	O
strlen	O
(	O
term	*(char)
)	O
-	O
9	int
,	O
"-256color"	*(char)
)	O
==	O
0	int
)	O
||	O
(	O
strlen	O
(	O
term	*(char)
)	O
>	O
8	int
&&	O
strcmp	O
(	O
term	*(char)
+	O
strlen	O
(	O
term	*(char)
)	O
-	O
8	int
,	O
"-direct"	*(char)
)	O
==	O
0	int
)	O
)	O
?	O
(	O
stream	int
->	O
max_colors	O
>=	O
0x7fff	int
?	O
cm_xtermrgb	int
:	O
stream	int
->	O
max_colors	O
==	O
256	int
?	O
cm_xterm256	int
:	O
stream	int
->	O
max_colors	O
==	O
88	int
?	O
cm_xterm88	int
:	O
stream	int
->	O
max_colors	O
==	O
16	int
?	O
cm_xterm16	int
:	O
cm_xterm8	int
)	O
:	O
cm_common8	int
)	O
:	O
cm_monochrome	int
)	O
;	O
stream	int
->	O
supports_weight	O
=	O
(	O
stream	int
->	O
enter_bold_mode	O
!=	O
NULL	O
&&	O
stream	int
->	O
exit_attribute_mode	O
!=	O
NULL	O
)	O
;	O
stream	int
->	O
supports_posture	O
=	O
(	O
stream	int
->	O
enter_italics_mode	O
!=	O
NULL	O
&&	O
(	O
stream	int
->	O
exit_italics_mode	O
!=	O
NULL	O
||	O
stream	int
->	O
exit_attribute_mode	O
!=	O
NULL	O
)	O
)	O
;	O
stream	int
->	O
supports_underline	O
=	O
(	O
stream	int
->	O
enter_underline_mode	O
!=	O
NULL	O
&&	O
(	O
stream	int
->	O
exit_underline_mode	O
!=	O
NULL	O
||	O
stream	int
->	O
exit_attribute_mode	O
!=	O
NULL	O
)	O
)	O
;	O
stream	int
->	O
restore_colors	O
=	O
(	O
stream	int
->	O
supports_foreground	O
||	O
stream	int
->	O
supports_background	O
?	O
stream	int
->	O
orig_pair	O
:	O
NULL	O
)	O
;	O
stream	int
->	O
restore_weight	O
=	O
(	O
stream	int
->	O
supports_weight	O
?	O
stream	int
->	O
exit_attribute_mode	O
:	O
NULL	O
)	O
;	O
stream	int
->	O
restore_posture	O
=	O
(	O
stream	int
->	O
supports_posture	O
?	O
(	O
stream	int
->	O
exit_italics_mode	O
!=	O
NULL	O
?	O
stream	int
->	O
exit_italics_mode	O
:	O
stream	int
->	O
exit_attribute_mode	O
)	O
:	O
NULL	O
)	O
;	O
stream	int
->	O
restore_underline	O
=	O
(	O
stream	int
->	O
supports_underline	O
?	O
(	O
stream	int
->	O
exit_underline_mode	O
!=	O
NULL	O
?	O
stream	int
->	O
exit_underline_mode	O
:	O
stream	int
->	O
exit_attribute_mode	O
)	O
:	O
NULL	O
)	O
;	O
}	O
stream	int
->	O
allocated	O
=	O
120	int
;	O
stream	int
->	O
buffer	O
=	O
XNMALLOC	()->(int)
(	O
stream	int
->	O
allocated	O
,	O
char	O
)	O
;	O
stream	int
->	O
attrbuffer	O
=	O
XNMALLOC	()->(int)
(	O
stream	int
->	O
allocated	O
,	O
attributes_t	struct(int,int,int,int,int)
)	O
;	O
stream	int
->	O
buflen	O
=	O
0	int
;	O
{	O
attributes_t	struct(int,int,int,int,int)
assumed_default	struct(int,int,int,int,int)
;	O
attributes_t	struct(int,int,int,int,int)
simplified_default	struct(int,int,int,int,int)
;	O
assumed_default	struct(int,int,int,int,int)
.	O
color	int
=	O
COLOR_DEFAULT	O
;	O
assumed_default	struct(int,int,int,int,int)
.	O
bgcolor	int
=	O
COLOR_DEFAULT	O
;	O
assumed_default	struct(int,int,int,int,int)
.	O
weight	int
=	O
WEIGHT_DEFAULT	O
;	O
assumed_default	struct(int,int,int,int,int)
.	O
posture	int
=	O
POSTURE_DEFAULT	O
;	O
assumed_default	struct(int,int,int,int,int)
.	O
underline	int
=	O
UNDERLINE_DEFAULT	O
;	O
simplified_default	struct(int,int,int,int,int)
=	O
simplify_attributes	(int,struct(int,int,int,int,int))->(struct(int,int,int,int,int))
(	O
stream	int
,	O
assumed_default	struct(int,int,int,int,int)
)	O
;	O
stream	int
->	O
default_attr	O
=	O
simplified_default	struct(int,int,int,int,int)
;	O
stream	int
->	O
active_attr	O
=	O
simplified_default	struct(int,int,int,int,int)
;	O
stream	int
->	O
curr_attr	O
=	O
assumed_default	struct(int,int,int,int,int)
;	O
stream	int
->	O
simp_attr	O
=	O
simplified_default	struct(int,int,int,int,int)
;	O
}	O
activate_term_style_controller	O
(	O
&	O
controller	struct
,	O
stream	int
,	O
fd	int
,	O
tty_control	int
)	O
;	O
return	O
stream	int
;	O
}	O
const	O
struct	O
term_ostream_implementation	O
term_ostream_vtable	O
=	O
{	O
term_ostream_superclasses	array(*(int))
,	O
sizeof	O
(	O
term_ostream_superclasses	array(*(int))
)	O
/	O
sizeof	O
(	O
term_ostream_superclasses	array(*(int))
[	O
0	int
]	O
)	O
,	O
sizeof	O
(	O
struct	O
term_ostream_representation	O
)	O
,	O
term_ostream__write_mem	(int,*(void),int)->(void)
,	O
term_ostream__flush	(int,int)->(void)
,	O
term_ostream__free	(int)->(void)
,	O
term_ostream__rgb_to_color	(int,int,int,int)->(int)
,	O
term_ostream__get_color	(int)->(int)
,	O
term_ostream__set_color	(int,int)->(void)
,	O
term_ostream__get_bgcolor	(int)->(int)
,	O
term_ostream__set_bgcolor	(int,int)->(void)
,	O
term_ostream__get_weight	(int)->(int)
,	O
term_ostream__set_weight	(int,int)->(void)
,	O
term_ostream__get_posture	(int)->(int)
,	O
term_ostream__set_posture	(int,int)->(void)
,	O
term_ostream__get_underline	(int)->(int)
,	O
term_ostream__set_underline	(int,int)->(void)
,	O
term_ostream__flush_to_current_style	(int)->(void)
,	O
}	O
;	O
void	O
term_ostream_write_mem	(int,*(void),int)->(void)
(	O
term_ostream_t	O
first_arg	int
,	O
const	O
void	O
*	O
data	*(void)
,	O
size_t	O
len	int
)	O
{	O
const	O
struct	O
term_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
term_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
vtable	*(struct)
->	O
write_mem	O
(	O
first_arg	int
,	O
data	*(void)
,	O
len	int
)	O
;	O
}	O
void	O
term_ostream_flush	()->(int)
(	O
term_ostream_t	O
first_arg	int
,	O
ostream_flush_scope_t	O
scope	int
)	O
{	O
const	O
struct	O
term_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
term_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
vtable	*(struct)
->	O
flush	O
(	O
first_arg	int
,	O
scope	int
)	O
;	O
}	O
void	O
term_ostream_free	(int)->(void)
(	O
term_ostream_t	O
first_arg	int
)	O
{	O
const	O
struct	O
term_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
term_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
vtable	*(struct)
->	O
free	()->(int)
(	O
first_arg	int
)	O
;	O
}	O
term_color_t	O
term_ostream_rgb_to_color	(int,int,int,int)->(int)
(	O
term_ostream_t	O
first_arg	int
,	O
int	O
red	int
,	O
int	O
green	int
,	O
int	O
blue	int
)	O
{	O
const	O
struct	O
term_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
term_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
return	O
vtable	*(struct)
->	O
rgb_to_color	O
(	O
first_arg	int
,	O
red	int
,	O
green	int
,	O
blue	int
)	O
;	O
}	O
term_color_t	O
term_ostream_get_color	(int)->(int)
(	O
term_ostream_t	O
first_arg	int
)	O
{	O
const	O
struct	O
term_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
term_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
return	O
vtable	*(struct)
->	O
get_color	O
(	O
first_arg	int
)	O
;	O
}	O
void	O
term_ostream_set_color	(int,int)->(void)
(	O
term_ostream_t	O
first_arg	int
,	O
term_color_t	O
color	int
)	O
{	O
const	O
struct	O
term_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
term_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
vtable	*(struct)
->	O
set_color	O
(	O
first_arg	int
,	O
color	int
)	O
;	O
}	O
term_color_t	O
term_ostream_get_bgcolor	(int)->(int)
(	O
term_ostream_t	O
first_arg	int
)	O
{	O
const	O
struct	O
term_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
term_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
return	O
vtable	*(struct)
->	O
get_bgcolor	O
(	O
first_arg	int
)	O
;	O
}	O
void	O
term_ostream_set_bgcolor	(int,int)->(void)
(	O
term_ostream_t	O
first_arg	int
,	O
term_color_t	O
color	int
)	O
{	O
const	O
struct	O
term_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
term_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
vtable	*(struct)
->	O
set_bgcolor	O
(	O
first_arg	int
,	O
color	int
)	O
;	O
}	O
term_weight_t	O
term_ostream_get_weight	(int)->(int)
(	O
term_ostream_t	O
first_arg	int
)	O
{	O
const	O
struct	O
term_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
term_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
return	O
vtable	*(struct)
->	O
get_weight	O
(	O
first_arg	int
)	O
;	O
}	O
void	O
term_ostream_set_weight	(int,int)->(void)
(	O
term_ostream_t	O
first_arg	int
,	O
term_weight_t	O
weight	int
)	O
{	O
const	O
struct	O
term_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
term_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
vtable	*(struct)
->	O
set_weight	O
(	O
first_arg	int
,	O
weight	int
)	O
;	O
}	O
term_posture_t	O
term_ostream_get_posture	(int)->(int)
(	O
term_ostream_t	O
first_arg	int
)	O
{	O
const	O
struct	O
term_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
term_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
return	O
vtable	*(struct)
->	O
get_posture	O
(	O
first_arg	int
)	O
;	O
}	O
void	O
term_ostream_set_posture	(int,int)->(void)
(	O
term_ostream_t	O
first_arg	int
,	O
term_posture_t	O
posture	int
)	O
{	O
const	O
struct	O
term_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
term_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
vtable	*(struct)
->	O
set_posture	O
(	O
first_arg	int
,	O
posture	int
)	O
;	O
}	O
term_underline_t	O
term_ostream_get_underline	(int)->(int)
(	O
term_ostream_t	O
first_arg	int
)	O
{	O
const	O
struct	O
term_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
term_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
return	O
vtable	*(struct)
->	O
get_underline	O
(	O
first_arg	int
)	O
;	O
}	O
void	O
term_ostream_set_underline	(int,int)->(void)
(	O
term_ostream_t	O
first_arg	int
,	O
term_underline_t	O
underline	int
)	O
{	O
const	O
struct	O
term_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
term_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
vtable	*(struct)
->	O
set_underline	O
(	O
first_arg	int
,	O
underline	int
)	O
;	O
}	O
void	O
term_ostream_flush_to_current_style	(int)->(void)
(	O
term_ostream_t	O
first_arg	int
)	O
{	O
const	O
struct	O
term_ostream_implementation	O
*	O
vtable	*(struct)
=	O
(	O
(	O
struct	O
term_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	*(struct)
;	O
vtable	*(struct)
->	O
flush_to_current_style	O
(	O
first_arg	int
)	O
;	O
}	O
