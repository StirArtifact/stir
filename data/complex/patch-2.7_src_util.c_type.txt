static	O
void	O
makedirs	(*(char))->(void)
(	O
char	O
const	O
*	O
)	O
;	O
typedef	O
struct	O
{	O
dev_t	long
dev	long
;	O
ino_t	long
ino	long
;	O
enum	O
file_id_type	enum(int,int,int,int)
type	enum(int,int,int,int)
;	O
bool	bool
queued_output	bool
;	O
}	O
file_id	struct(long,long,enum(int,int,int,int),bool)
;	O
static	O
size_t	long
file_id_hasher	(*(void),long)->(long)
(	O
void	O
const	O
*	O
entry	*(void)
,	O
size_t	long
table_size	long
)	O
{	O
file_id	struct(long,long,enum(int,int,int,int),bool)
const	O
*	O
e	*(struct(long,long,enum(int,int,int,int),bool))
=	O
entry	*(void)
;	O
size_t	long
i	int
=	O
e	*(struct(long,long,enum(int,int,int,int),bool))
->	O
ino	long
+	O
e	*(struct(long,long,enum(int,int,int,int),bool))
->	O
dev	long
;	O
return	O
i	int
%	O
table_size	long
;	O
}	O
static	O
bool	bool
file_id_comparator	(*(void),*(void))->(bool)
(	O
void	O
const	O
*	O
entry1	*(void)
,	O
void	O
const	O
*	O
entry2	*(void)
)	O
{	O
file_id	struct(long,long,enum(int,int,int,int),bool)
const	O
*	O
e1	*(struct(long,long,enum(int,int,int,int),bool))
=	O
entry1	*(void)
;	O
file_id	struct(long,long,enum(int,int,int,int),bool)
const	O
*	O
e2	*(struct(long,long,enum(int,int,int,int),bool))
=	O
entry2	*(void)
;	O
return	O
(	O
e1	*(struct(long,long,enum(int,int,int,int),bool))
->	O
ino	long
==	O
e2	*(struct(long,long,enum(int,int,int,int),bool))
->	O
ino	long
&&	O
e1	*(struct(long,long,enum(int,int,int,int),bool))
->	O
dev	long
==	O
e2	*(struct(long,long,enum(int,int,int,int),bool))
->	O
dev	long
)	O
;	O
}	O
static	O
Hash_table	struct
*	O
file_id_table	*(struct)
;	O
void	O
init_backup_hash_table	()->(void)
(	O
void	O
)	O
{	O
file_id_table	*(struct)
=	O
hash_initialize	(long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)))->(*(struct))
(	O
0	int
,	O
NULL	O
,	O
file_id_hasher	(*(void),long)->(long)
,	O
file_id_comparator	(*(void),*(void))->(bool)
,	O
free	(*(void))->(void)
)	O
;	O
if	O
(	O
!	O
file_id_table	*(struct)
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
}	O
static	O
file_id	struct(long,long,enum(int,int,int,int),bool)
*	O
__insert_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),enum(int,int,int,int))->(*(struct(long,long,enum(int,int,int,int),bool)))
(	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
const	O
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
enum	O
file_id_type	enum(int,int,int,int)
type	enum(int,int,int,int)
)	O
{	O
file_id	struct(long,long,enum(int,int,int,int),bool)
*	O
p	*(void)
;	O
static	O
file_id	struct(long,long,enum(int,int,int,int),bool)
*	O
next_slot	*(struct(long,long,enum(int,int,int,int),bool))
;	O
if	O
(	O
!	O
next_slot	*(struct(long,long,enum(int,int,int,int),bool))
)	O
next_slot	*(struct(long,long,enum(int,int,int,int),bool))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
next_slot	*(struct(long,long,enum(int,int,int,int),bool))
)	O
;	O
next_slot	*(struct(long,long,enum(int,int,int,int),bool))
->	O
dev	long
=	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_dev	long
;	O
next_slot	*(struct(long,long,enum(int,int,int,int),bool))
->	O
ino	long
=	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_ino	long
;	O
next_slot	*(struct(long,long,enum(int,int,int,int),bool))
->	O
queued_output	bool
=	O
false	int
;	O
p	*(void)
=	O
hash_insert	(*(struct),*(void))->(*(void))
(	O
file_id_table	*(struct)
,	O
next_slot	*(struct(long,long,enum(int,int,int,int),bool))
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
next_slot	*(struct(long,long,enum(int,int,int,int),bool))
)	O
next_slot	*(struct(long,long,enum(int,int,int,int),bool))
=	O
NULL	O
;	O
p	*(void)
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
return	O
p	*(void)
;	O
}	O
static	O
file_id	struct(long,long,enum(int,int,int,int),bool)
*	O
__lookup_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(struct(long,long,enum(int,int,int,int),bool)))
(	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
const	O
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
file_id	struct(long,long,enum(int,int,int,int),bool)
f	struct(long,long,enum(int,int,int,int),bool)
;	O
f	struct(long,long,enum(int,int,int,int),bool)
.	O
dev	long
=	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_dev	long
;	O
f	struct(long,long,enum(int,int,int,int),bool)
.	O
ino	long
=	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_ino	long
;	O
return	O
hash_lookup	(*(struct),*(void))->(*(void))
(	O
file_id_table	*(struct)
,	O
&	O
f	struct(long,long,enum(int,int,int,int),bool)
)	O
;	O
}	O
void	O
insert_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),enum(int,int,int,int))->(void)
(	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
const	O
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
enum	O
file_id_type	enum(int,int,int,int)
type	enum(int,int,int,int)
)	O
{	O
__insert_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),enum(int,int,int,int))->(*(struct(long,long,enum(int,int,int,int),bool)))
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
type	enum(int,int,int,int)
)	O
;	O
}	O
enum	O
file_id_type	enum(int,int,int,int)
lookup_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(enum(int,int,int,int))
(	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
const	O
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
file_id	struct(long,long,enum(int,int,int,int),bool)
*	O
p	*(void)
=	O
__lookup_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(struct(long,long,enum(int,int,int,int),bool)))
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
return	O
p	*(void)
?	O
p	*(void)
->	O
type	enum(int,int,int,int)
:	O
UNKNOWN	int
;	O
}	O
void	O
set_queued_output	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),bool)->(void)
(	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
const	O
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
bool	bool
queued_output	bool
)	O
{	O
file_id	struct(long,long,enum(int,int,int,int),bool)
*	O
p	*(void)
=	O
__lookup_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(struct(long,long,enum(int,int,int,int),bool)))
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
p	*(void)
=	O
__insert_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),enum(int,int,int,int))->(*(struct(long,long,enum(int,int,int,int),bool)))
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
UNKNOWN	int
)	O
;	O
p	*(void)
->	O
queued_output	bool
=	O
queued_output	bool
;	O
}	O
bool	bool
has_queued_output	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(bool)
(	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
const	O
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
file_id	struct(long,long,enum(int,int,int,int),bool)
*	O
p	*(void)
=	O
__lookup_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(struct(long,long,enum(int,int,int,int),bool)))
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
return	O
p	*(void)
&&	O
p	*(void)
->	O
queued_output	bool
;	O
}	O
static	O
bool	bool
_GL_ATTRIBUTE_PURE	O
contains_slash	(*(char))->(bool)
(	O
const	O
char	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
for	O
(	O
;	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
)	O
if	O
(	O
ISSLASH	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
)	O
return	O
true	int
;	O
return	O
false	int
;	O
}	O
static	O
int	O
copy_attr	(*(char),*(char))->(int)
(	O
char	O
const	O
*	O
src_path	*(char)
,	O
char	O
const	O
*	O
dst_path	*(char)
)	O
{	O
return	O
0	int
;	O
}	O
void	O
set_file_attributes	(*(char),enum(int,int,int,int),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,*(struct(long,long)))->(void)
(	O
char	O
const	O
*	O
to	*(char)
,	O
enum	O
file_attributes	enum(int,int,int,int)
attr	enum(int,int,int,int)
,	O
char	O
const	O
*	O
from	*(char)
,	O
const	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
mode_t	int
mode	int
,	O
struct	O
timespec	struct(long,long)
*	O
new_time	*(struct(long,long))
)	O
{	O
if	O
(	O
attr	enum(int,int,int,int)
&	O
FA_TIMES	int
)	O
{	O
struct	O
timespec	struct(long,long)
times	array(struct(long,long))
[	O
2	int
]	O
;	O
if	O
(	O
new_time	*(struct(long,long))
)	O
times	array(struct(long,long))
[	O
0	int
]	O
=	O
times	array(struct(long,long))
[	O
1	int
]	O
=	O
*	O
new_time	*(struct(long,long))
;	O
else	O
{	O
times	array(struct(long,long))
[	O
0	int
]	O
=	O
get_stat_atime	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(struct(long,long))
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
times	array(struct(long,long))
[	O
1	int
]	O
=	O
get_stat_mtime	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(struct(long,long))
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
}	O
if	O
(	O
lutimens	(*(char),array(struct(long,long)))->(int)
(	O
to	*(char)
,	O
times	array(struct(long,long))
)	O
!=	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"Failed to set the timestamps of %s %s"	*(char)
,	O
S_ISLNK	O
(	O
mode	int
)	O
?	O
"symbolic link"	*(char)
:	O
"file"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
to	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
attr	enum(int,int,int,int)
&	O
FA_IDS	int
)	O
{	O
static	O
uid_t	int
euid	int
=	O
-	O
1	int
;	O
static	O
gid_t	int
egid	int
=	O
-	O
1	int
;	O
uid_t	int
uid	int
;	O
uid_t	int
gid	int
;	O
if	O
(	O
euid	int
==	O
-	O
1	int
)	O
{	O
euid	int
=	O
geteuid	()->(int)
(	O
)	O
;	O
egid	int
=	O
getegid	()->(int)
(	O
)	O
;	O
}	O
uid	int
=	O
(	O
euid	int
==	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_uid	int
)	O
?	O
-	O
1	int
:	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_uid	int
;	O
gid	int
=	O
(	O
egid	int
==	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_gid	int
)	O
?	O
-	O
1	int
:	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_gid	int
;	O
if	O
(	O
(	O
uid	int
!=	O
-	O
1	int
||	O
gid	int
!=	O
-	O
1	int
)	O
&&	O
lchown	(*(char),int,int)->(int)
(	O
to	*(char)
,	O
uid	int
,	O
gid	int
)	O
!=	O
0	int
&&	O
(	O
errno	O
!=	O
EPERM	int
||	O
(	O
uid	int
!=	O
-	O
1	int
&&	O
lchown	(*(char),int,int)->(int)
(	O
to	*(char)
,	O
(	O
uid	int
=	O
-	O
1	int
)	O
,	O
gid	int
)	O
!=	O
0	int
&&	O
errno	O
!=	O
EPERM	int
)	O
)	O
)	O
pfatal	(*(char))->(void)
(	O
"Failed to set the %s of %s %s"	*(char)
,	O
(	O
uid	int
==	O
-	O
1	int
)	O
?	O
"owner"	*(char)
:	O
"owning group"	*(char)
,	O
S_ISLNK	O
(	O
mode	int
)	O
?	O
"symbolic link"	*(char)
:	O
"file"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
to	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
attr	enum(int,int,int,int)
&	O
FA_XATTRS	int
)	O
if	O
(	O
copy_attr	(*(char),*(char))->(int)
(	O
from	*(char)
,	O
to	*(char)
)	O
)	O
fatal_exit	(int)->(void)
(	O
0	int
)	O
;	O
if	O
(	O
attr	enum(int,int,int,int)
&	O
FA_MODE	int
)	O
{	O
if	O
(	O
!	O
S_ISLNK	O
(	O
mode	int
)	O
&&	O
chmod	(*(char),int)->(int)
(	O
to	*(char)
,	O
mode	int
)	O
!=	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"Failed to set the permissions of %s %s"	*(char)
,	O
S_ISLNK	O
(	O
mode	int
)	O
?	O
"symbolic link"	*(char)
:	O
"file"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
to	*(char)
)	O
)	O
;	O
}	O
}	O
static	O
void	O
create_backup_copy	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),bool)->(void)
(	O
char	O
const	O
*	O
from	*(char)
,	O
char	O
const	O
*	O
to	*(char)
,	O
const	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
bool	bool
to_dir_known_to_exist	bool
)	O
{	O
copy_file	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,int,bool)->(void)
(	O
from	*(char)
,	O
to	*(char)
,	O
NULL	O
,	O
0	int
,	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
,	O
to_dir_known_to_exist	bool
)	O
;	O
set_file_attributes	(*(char),enum(int,int,int,int),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,*(struct(long,long)))->(void)
(	O
to	*(char)
,	O
FA_TIMES	int
|	O
FA_IDS	int
|	O
FA_MODE	int
,	O
from	*(char)
,	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
,	O
NULL	O
)	O
;	O
}	O
void	O
create_backup	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),bool)->(void)
(	O
char	O
const	O
*	O
to	*(char)
,	O
const	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
bool	bool
leave_original	bool
)	O
{	O
if	O
(	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
&&	O
!	O
(	O
S_ISREG	O
(	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
||	O
S_ISLNK	O
(	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
)	O
)	O
fatal	(*(char))->(void)
(	O
"File %s is not a %s -- refusing to create backup"	*(char)
,	O
to	*(char)
,	O
S_ISLNK	O
(	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
?	O
"symbolic link"	*(char)
:	O
"regular file"	*(char)
)	O
;	O
if	O
(	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
&&	O
lookup_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(enum(int,int,int,int))
(	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
==	O
CREATED	int
)	O
{	O
if	O
(	O
debug	int
&	O
4	int
)	O
say	(*(char))->(void)
(	O
"File %s already seen\n"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
to	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
int	O
try_makedirs_errno	int
=	O
0	int
;	O
char	O
*	O
bakname	*(char)
;	O
if	O
(	O
origprae	*(char)
||	O
origbase	*(char)
||	O
origsuff	*(char)
)	O
{	O
char	O
const	O
*	O
p	*(void)
=	O
origprae	*(char)
?	O
origprae	*(char)
:	O
""	*(char)
;	O
char	O
const	O
*	O
b	struct(long,long)
=	O
origbase	*(char)
?	O
origbase	*(char)
:	O
""	*(char)
;	O
char	O
const	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
origsuff	*(char)
?	O
origsuff	*(char)
:	O
""	*(char)
;	O
char	O
const	O
*	O
t	struct(long,long)
=	O
to	*(char)
;	O
size_t	long
plen	long
=	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
;	O
size_t	long
blen	long
=	O
strlen	(*(char))->(long)
(	O
b	struct(long,long)
)	O
;	O
size_t	long
slen	long
=	O
strlen	(*(char))->(long)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
size_t	long
tlen	long
=	O
strlen	(*(char))->(long)
(	O
t	struct(long,long)
)	O
;	O
char	O
const	O
*	O
o	*(struct)
;	O
size_t	long
olen	long
;	O
for	O
(	O
o	*(struct)
=	O
t	struct(long,long)
+	O
tlen	long
,	O
olen	long
=	O
0	int
;	O
o	*(struct)
>	O
t	struct(long,long)
&&	O
!	O
ISSLASH	O
(	O
*	O
(	O
o	*(struct)
-	O
1	int
)	O
)	O
;	O
o	*(struct)
--	O
)	O
;	O
olen	long
=	O
t	struct(long,long)
+	O
tlen	long
-	O
o	*(struct)
;	O
tlen	long
-=	O
olen	long
;	O
bakname	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
plen	long
+	O
tlen	long
+	O
blen	long
+	O
olen	long
+	O
slen	long
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
bakname	*(char)
,	O
p	*(void)
,	O
plen	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
bakname	*(char)
+	O
plen	long
,	O
t	struct(long,long)
,	O
tlen	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
bakname	*(char)
+	O
plen	long
+	O
tlen	long
,	O
b	struct(long,long)
,	O
blen	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
bakname	*(char)
+	O
plen	long
+	O
tlen	long
+	O
blen	long
,	O
o	*(struct)
,	O
olen	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
bakname	*(char)
+	O
plen	long
+	O
tlen	long
+	O
blen	long
+	O
olen	long
,	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
slen	long
+	O
1	int
)	O
;	O
if	O
(	O
(	O
origprae	*(char)
&&	O
(	O
contains_slash	(*(char))->(bool)
(	O
origprae	*(char)
+	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
origprae	*(char)
)	O
)	O
||	O
contains_slash	(*(char))->(bool)
(	O
to	*(char)
)	O
)	O
)	O
||	O
(	O
origbase	*(char)
&&	O
contains_slash	(*(char))->(bool)
(	O
origbase	*(char)
)	O
)	O
)	O
try_makedirs_errno	int
=	O
ENOENT	int
;	O
}	O
else	O
{	O
bakname	*(char)
=	O
find_backup_file_name	(*(char),enum(int,int,int,int))->(*(char))
(	O
to	*(char)
,	O
backup_type	enum(int,int,int,int)
)	O
;	O
if	O
(	O
!	O
bakname	*(char)
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
int	O
fd	int
;	O
if	O
(	O
debug	int
&	O
4	int
)	O
say	(*(char))->(void)
(	O
"Creating empty file %s\n"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
bakname	*(char)
)	O
)	O
;	O
try_makedirs_errno	int
=	O
ENOENT	int
;	O
unlink	(*(char))->(int)
(	O
bakname	*(char)
)	O
;	O
while	O
(	O
(	O
fd	int
=	O
creat	(*(char),int)->(int)
(	O
bakname	*(char)
,	O
0666	int
)	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
try_makedirs_errno	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't create file %s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
bakname	*(char)
)	O
)	O
;	O
makedirs	(*(char))->(void)
(	O
bakname	*(char)
)	O
;	O
try_makedirs_errno	int
=	O
0	int
;	O
}	O
if	O
(	O
close	*((*(void))->(int))
(	O
fd	int
)	O
!=	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't close file %s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
bakname	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
leave_original	bool
)	O
create_backup_copy	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),bool)->(void)
(	O
to	*(char)
,	O
bakname	*(char)
,	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
try_makedirs_errno	int
==	O
0	int
)	O
;	O
else	O
{	O
if	O
(	O
debug	int
&	O
4	int
)	O
say	(*(char))->(void)
(	O
"Renaming file %s to %s\n"	*(char)
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
0	int
,	O
to	*(char)
)	O
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
1	int
,	O
bakname	*(char)
)	O
)	O
;	O
while	O
(	O
rename	(*(char),*(char))->(int)
(	O
to	*(char)
,	O
bakname	*(char)
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
try_makedirs_errno	int
)	O
{	O
makedirs	(*(char))->(void)
(	O
bakname	*(char)
)	O
;	O
try_makedirs_errno	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
errno	O
==	O
EXDEV	int
)	O
{	O
create_backup_copy	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),bool)->(void)
(	O
to	*(char)
,	O
bakname	*(char)
,	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
try_makedirs_errno	int
==	O
0	int
)	O
;	O
unlink	(*(char))->(int)
(	O
to	*(char)
)	O
;	O
break	O
;	O
}	O
else	O
pfatal	(*(char))->(void)
(	O
"Can't rename file %s to %s"	*(char)
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
0	int
,	O
to	*(char)
)	O
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
1	int
,	O
bakname	*(char)
)	O
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
bakname	*(char)
)	O
;	O
}	O
}	O
void	O
move_file	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(char),int,bool)->(void)
(	O
char	O
const	O
*	O
from	*(char)
,	O
int	O
*	O
from_needs_removal	*(int)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
const	O
*	O
fromst	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
char	O
const	O
*	O
to	*(char)
,	O
mode_t	int
mode	int
,	O
bool	bool
backup	bool
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
int	O
to_errno	int
;	O
to_errno	int
=	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
to	*(char)
,	O
&	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
==	O
0	int
?	O
0	int
:	O
errno	O
;	O
if	O
(	O
backup	bool
)	O
create_backup	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),bool)->(void)
(	O
to	*(char)
,	O
to_errno	int
?	O
NULL	O
:	O
&	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
false	int
)	O
;	O
if	O
(	O
!	O
to_errno	int
)	O
insert_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),enum(int,int,int,int))->(void)
(	O
&	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
OVERWRITTEN	int
)	O
;	O
if	O
(	O
from	*(char)
)	O
{	O
if	O
(	O
S_ISLNK	O
(	O
mode	int
)	O
)	O
{	O
bool	bool
to_dir_known_to_exist	bool
=	O
false	int
;	O
char	O
*	O
buffer	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
PATH_MAX	int
)	O
;	O
int	O
fd	int
,	O
size	*(long)
=	O
0	int
,	O
i	int
;	O
if	O
(	O
(	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
from	*(char)
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
<	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't reopen file %s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
from	*(char)
)	O
)	O
;	O
while	O
(	O
(	O
i	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
buffer	*(char)
+	O
size	*(long)
,	O
PATH_MAX	int
-	O
size	*(long)
)	O
)	O
>	O
0	int
)	O
size	*(long)
+=	O
i	int
;	O
if	O
(	O
i	int
!=	O
0	int
||	O
close	*((*(void))->(int))
(	O
fd	int
)	O
!=	O
0	int
)	O
read_fatal	()->(void)
(	O
)	O
;	O
buffer	*(char)
[	O
size	*(long)
]	O
=	O
0	int
;	O
if	O
(	O
!	O
backup	bool
)	O
{	O
if	O
(	O
unlink	(*(char))->(int)
(	O
to	*(char)
)	O
==	O
0	int
)	O
to_dir_known_to_exist	bool
=	O
true	int
;	O
}	O
if	O
(	O
symlink	(*(char),*(char))->(int)
(	O
buffer	*(char)
,	O
to	*(char)
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
&&	O
!	O
to_dir_known_to_exist	bool
)	O
makedirs	(*(char))->(void)
(	O
to	*(char)
)	O
;	O
if	O
(	O
symlink	(*(char),*(char))->(int)
(	O
buffer	*(char)
,	O
to	*(char)
)	O
!=	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't create %s %s"	*(char)
,	O
"symbolic link"	*(char)
,	O
to	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
buffer	*(char)
)	O
;	O
if	O
(	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
to	*(char)
,	O
&	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
!=	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't get file attributes of %s %s"	*(char)
,	O
"symbolic link"	*(char)
,	O
to	*(char)
)	O
;	O
insert_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),enum(int,int,int,int))->(void)
(	O
&	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
CREATED	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
debug	int
&	O
4	int
)	O
say	(*(char))->(void)
(	O
"Renaming file %s to %s\n"	*(char)
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
0	int
,	O
from	*(char)
)	O
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
1	int
,	O
to	*(char)
)	O
)	O
;	O
if	O
(	O
rename	(*(char),*(char))->(int)
(	O
from	*(char)
,	O
to	*(char)
)	O
!=	O
0	int
)	O
{	O
bool	bool
to_dir_known_to_exist	bool
=	O
false	int
;	O
if	O
(	O
errno	O
==	O
ENOENT	int
&&	O
(	O
to_errno	int
==	O
-	O
1	int
||	O
to_errno	int
==	O
ENOENT	int
)	O
)	O
{	O
makedirs	(*(char))->(void)
(	O
to	*(char)
)	O
;	O
to_dir_known_to_exist	bool
=	O
true	int
;	O
if	O
(	O
rename	(*(char),*(char))->(int)
(	O
from	*(char)
,	O
to	*(char)
)	O
==	O
0	int
)	O
goto	O
rename_succeeded	O
;	O
}	O
if	O
(	O
errno	O
==	O
EXDEV	int
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
tost	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
!	O
backup	bool
)	O
{	O
if	O
(	O
unlink	(*(char))->(int)
(	O
to	*(char)
)	O
==	O
0	int
)	O
to_dir_known_to_exist	bool
=	O
true	int
;	O
else	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't remove file %s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
to	*(char)
)	O
)	O
;	O
}	O
copy_file	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,int,bool)->(void)
(	O
from	*(char)
,	O
to	*(char)
,	O
&	O
tost	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
0	int
,	O
mode	int
,	O
to_dir_known_to_exist	bool
)	O
;	O
insert_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),enum(int,int,int,int))->(void)
(	O
&	O
tost	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
CREATED	int
)	O
;	O
return	O
;	O
}	O
pfatal	(*(char))->(void)
(	O
"Can't rename file %s to %s"	*(char)
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
0	int
,	O
from	*(char)
)	O
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
1	int
,	O
to	*(char)
)	O
)	O
;	O
}	O
rename_succeeded	O
:	O
insert_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),enum(int,int,int,int))->(void)
(	O
fromst	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
CREATED	int
)	O
;	O
if	O
(	O
(	O
0	int
<	O
to_errno	int
||	O
(	O
to_errno	int
==	O
0	int
&&	O
to_st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
.	O
st_nlink	long
<=	O
1	int
)	O
)	O
&&	O
from_needs_removal	*(int)
)	O
*	O
from_needs_removal	*(int)
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
backup	bool
)	O
{	O
if	O
(	O
debug	int
&	O
4	int
)	O
say	(*(char))->(void)
(	O
"Removing file %s\n"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
to	*(char)
)	O
)	O
;	O
if	O
(	O
unlink	(*(char))->(int)
(	O
to	*(char)
)	O
!=	O
0	int
&&	O
errno	O
!=	O
ENOENT	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't remove file %s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
to	*(char)
)	O
)	O
;	O
}	O
}	O
int	O
create_file	(*(char),int,int,bool)->(int)
(	O
char	O
const	O
*	O
file	*(char)
,	O
int	O
open_flags	int
,	O
mode_t	int
mode	int
,	O
bool	bool
to_dir_known_to_exist	bool
)	O
{	O
int	O
try_makedirs_errno	int
=	O
to_dir_known_to_exist	bool
?	O
0	int
:	O
ENOENT	int
;	O
int	O
fd	int
;	O
mode	int
|=	O
S_IRUSR	O
|	O
S_IWUSR	O
;	O
mode	int
&=	O
~	O
(	O
S_IXUSR	O
|	O
S_IXGRP	O
|	O
S_IXOTH	O
)	O
;	O
do	O
{	O
if	O
(	O
!	O
(	O
O_CREAT	int
&&	O
O_TRUNC	int
)	O
)	O
close	*((*(void))->(int))
(	O
creat	(*(char),int)->(int)
(	O
file	*(char)
,	O
mode	int
)	O
)	O
;	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
file	*(char)
,	O
O_CREAT	int
|	O
O_TRUNC	int
|	O
open_flags	int
,	O
mode	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
char	O
*	O
f	struct(long,long,enum(int,int,int,int),bool)
;	O
if	O
(	O
errno	O
!=	O
try_makedirs_errno	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't create file %s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
file	*(char)
)	O
)	O
;	O
f	struct(long,long,enum(int,int,int,int),bool)
=	O
xstrdup	(*(char))->(*(char))
(	O
file	*(char)
)	O
;	O
makedirs	(*(char))->(void)
(	O
f	struct(long,long,enum(int,int,int,int),bool)
)	O
;	O
free	(*(void))->(void)
(	O
f	struct(long,long,enum(int,int,int,int),bool)
)	O
;	O
try_makedirs_errno	int
=	O
0	int
;	O
}	O
}	O
while	O
(	O
fd	int
<	O
0	int
)	O
;	O
return	O
fd	int
;	O
}	O
static	O
void	O
copy_to_fd	(*(char),int)->(void)
(	O
const	O
char	O
*	O
from	*(char)
,	O
int	O
tofd	int
)	O
{	O
int	O
fromfd	int
;	O
ssize_t	long
i	int
;	O
if	O
(	O
(	O
fromfd	int
=	O
open	(*(char),int)->(int)
(	O
from	*(char)
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
<	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't reopen file %s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
from	*(char)
)	O
)	O
;	O
while	O
(	O
(	O
i	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
fromfd	int
,	O
buf	*(char)
,	O
bufsize	long
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
i	int
==	O
(	O
ssize_t	long
)	O
-	O
1	int
)	O
read_fatal	()->(void)
(	O
)	O
;	O
if	O
(	O
full_write	(int,*(void),long)->(long)
(	O
tofd	int
,	O
buf	*(char)
,	O
i	int
)	O
!=	O
i	int
)	O
write_fatal	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
close	*((*(void))->(int))
(	O
fromfd	int
)	O
!=	O
0	int
)	O
read_fatal	()->(void)
(	O
)	O
;	O
}	O
void	O
copy_file	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,int,bool)->(void)
(	O
char	O
const	O
*	O
from	*(char)
,	O
char	O
const	O
*	O
to	*(char)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
tost	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
int	O
to_flags	int
,	O
mode_t	int
mode	int
,	O
bool	bool
to_dir_known_to_exist	bool
)	O
{	O
int	O
tofd	int
;	O
if	O
(	O
debug	int
&	O
4	int
)	O
say	(*(char))->(void)
(	O
"Copying %s %s to %s\n"	*(char)
,	O
S_ISLNK	O
(	O
mode	int
)	O
?	O
"symbolic link"	*(char)
:	O
"file"	*(char)
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
0	int
,	O
from	*(char)
)	O
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
1	int
,	O
to	*(char)
)	O
)	O
;	O
if	O
(	O
S_ISLNK	O
(	O
mode	int
)	O
)	O
{	O
char	O
*	O
buffer	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
PATH_MAX	int
)	O
;	O
if	O
(	O
readlink	(*(char),*(char),long)->(long)
(	O
from	*(char)
,	O
buffer	*(char)
,	O
PATH_MAX	int
)	O
<	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't read %s %s"	*(char)
,	O
"symbolic link"	*(char)
,	O
from	*(char)
)	O
;	O
if	O
(	O
symlink	(*(char),*(char))->(int)
(	O
buffer	*(char)
,	O
to	*(char)
)	O
!=	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't create %s %s"	*(char)
,	O
"symbolic link"	*(char)
,	O
to	*(char)
)	O
;	O
if	O
(	O
tost	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
&&	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
to	*(char)
,	O
tost	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't get file attributes of %s %s"	*(char)
,	O
"symbolic link"	*(char)
,	O
to	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
buffer	*(char)
)	O
;	O
}	O
else	O
{	O
assert	O
(	O
S_ISREG	O
(	O
mode	int
)	O
)	O
;	O
tofd	int
=	O
create_file	(*(char),int,int,bool)->(int)
(	O
to	*(char)
,	O
O_WRONLY	int
|	O
O_BINARY	int
|	O
to_flags	int
,	O
mode	int
,	O
to_dir_known_to_exist	bool
)	O
;	O
copy_to_fd	(*(char),int)->(void)
(	O
from	*(char)
,	O
tofd	int
)	O
;	O
if	O
(	O
tost	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
&&	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
tofd	int
,	O
tost	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't get file attributes of %s %s"	*(char)
,	O
"file"	*(char)
,	O
to	*(char)
)	O
;	O
if	O
(	O
close	*((*(void))->(int))
(	O
tofd	int
)	O
!=	O
0	int
)	O
write_fatal	()->(void)
(	O
)	O
;	O
}	O
}	O
void	O
append_to_file	(*(char),*(char))->(void)
(	O
char	O
const	O
*	O
from	*(char)
,	O
char	O
const	O
*	O
to	*(char)
)	O
{	O
int	O
tofd	int
;	O
if	O
(	O
(	O
tofd	int
=	O
open	(*(char),int)->(int)
(	O
to	*(char)
,	O
O_WRONLY	int
|	O
O_BINARY	int
|	O
O_APPEND	int
)	O
)	O
<	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"Can't reopen file %s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
to	*(char)
)	O
)	O
;	O
copy_to_fd	(*(char),int)->(void)
(	O
from	*(char)
,	O
tofd	int
)	O
;	O
if	O
(	O
close	*((*(void))->(int))
(	O
tofd	int
)	O
!=	O
0	int
)	O
write_fatal	()->(void)
(	O
)	O
;	O
}	O
static	O
char	O
const	O
DEV_NULL	array(char)
[	O
]	O
=	O
NULL_DEVICE	*(char)
;	O
static	O
char	O
const	O
RCSSUFFIX	array(char)
[	O
]	O
=	O
",v"	*(char)
;	O
static	O
char	O
const	O
CHECKOUT	array(char)
[	O
]	O
=	O
"co %s"	*(char)
;	O
static	O
char	O
const	O
CHECKOUT_LOCKED	array(char)
[	O
]	O
=	O
"co -l %s"	*(char)
;	O
static	O
char	O
const	O
RCSDIFF1	array(char)
[	O
]	O
=	O
"rcsdiff %s"	*(char)
;	O
static	O
char	O
const	O
SCCSPREFIX	array(char)
[	O
]	O
=	O
"s."	*(char)
;	O
static	O
char	O
const	O
GET	array(char)
[	O
]	O
=	O
"get "	*(char)
;	O
static	O
char	O
const	O
GET_LOCKED	array(char)
[	O
]	O
=	O
"get -e "	*(char)
;	O
static	O
char	O
const	O
SCCSDIFF1	array(char)
[	O
]	O
=	O
"get -p "	*(char)
;	O
static	O
char	O
const	O
SCCSDIFF2	array(char)
[	O
]	O
=	O
"|diff - %s"	*(char)
;	O
static	O
char	O
const	O
CLEARTOOL_CO	array(char)
[	O
]	O
=	O
"cleartool co -unr -nc "	*(char)
;	O
static	O
char	O
const	O
PERFORCE_CO	array(char)
[	O
]	O
=	O
"p4 edit "	*(char)
;	O
static	O
size_t	long
quote_system_arg	(*(char),*(char))->(long)
(	O
char	O
*	O
quoted	*(char)
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
char	O
*	O
q	*(char)
=	O
quotearg_style	(enum(int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
shell_quoting_style	int
,	O
arg	*(char)
)	O
;	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
q	*(char)
)	O
;	O
if	O
(	O
quoted	*(char)
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
quoted	*(char)
,	O
q	*(char)
,	O
len	long
+	O
1	int
)	O
;	O
return	O
len	long
;	O
}	O
char	O
const	O
*	O
version_controller	(*(char),bool,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(*(char)),*(*(char)))->(*(char))
(	O
char	O
const	O
*	O
filename	*(char)
,	O
bool	bool
readonly	bool
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
const	O
*	O
filestat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
char	O
*	O
*	O
getbuf	*(*(char))
,	O
char	O
*	O
*	O
diffbuf	*(*(char))
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
cstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
char	O
*	O
dir	*(char)
=	O
dir_name	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
char	O
*	O
filebase	*(char)
=	O
base_name	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
char	O
const	O
*	O
dotslash	*(char)
=	O
*	O
filename	*(char)
==	O
'-'	O
?	O
"./"	*(char)
:	O
""	*(char)
;	O
size_t	long
dirlen	long
=	O
strlen	(*(char))->(long)
(	O
dir	*(char)
)	O
+	O
1	int
;	O
size_t	long
maxfixlen	long
=	O
sizeof	O
"SCCS/"	*(char)
-	O
1	int
+	O
sizeof	O
SCCSPREFIX	array(char)
-	O
1	int
;	O
size_t	long
maxtrysize	long
=	O
dirlen	long
+	O
strlen	(*(char))->(long)
(	O
filebase	*(char)
)	O
+	O
maxfixlen	long
+	O
1	int
;	O
size_t	long
quotelen	long
=	O
quote_system_arg	(*(char),*(char))->(long)
(	O
0	int
,	O
dir	*(char)
)	O
+	O
quote_system_arg	(*(char),*(char))->(long)
(	O
0	int
,	O
filebase	*(char)
)	O
;	O
size_t	long
maxgetsize	long
=	O
sizeof	O
CLEARTOOL_CO	array(char)
+	O
quotelen	long
+	O
maxfixlen	long
;	O
size_t	long
maxdiffsize	long
=	O
(	O
sizeof	O
SCCSDIFF1	array(char)
+	O
sizeof	O
SCCSDIFF2	array(char)
+	O
sizeof	O
DEV_NULL	array(char)
-	O
1	int
+	O
2	int
*	O
quotelen	long
+	O
maxfixlen	long
)	O
;	O
char	O
*	O
trybuf	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
maxtrysize	long
)	O
;	O
char	O
const	O
*	O
r	*(char)
=	O
0	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
trybuf	*(char)
,	O
"%s/"	*(char)
,	O
dir	*(char)
)	O
;	O
if	O
(	O
(	O
try2	O
(	O
"RCS/%s%s"	*(char)
,	O
filebase	*(char)
,	O
RCSSUFFIX	array(char)
)	O
||	O
try1	O
(	O
"RCS/%s"	*(char)
,	O
filebase	*(char)
)	O
||	O
try2	O
(	O
"%s%s"	*(char)
,	O
filebase	*(char)
,	O
RCSSUFFIX	array(char)
)	O
)	O
&&	O
!	O
(	O
filestat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
&&	O
filestat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_dev	long
==	O
cstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
&&	O
filestat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_ino	long
==	O
cstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_ino	long
)	O
)	O
{	O
if	O
(	O
getbuf	*(*(char))
)	O
{	O
char	O
*	O
p	*(void)
=	O
*	O
getbuf	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
maxgetsize	long
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
readonly	bool
?	O
CHECKOUT	array(char)
:	O
CHECKOUT_LOCKED	array(char)
,	O
dotslash	*(char)
)	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
quote_system_arg	(*(char),*(char))->(long)
(	O
p	*(void)
,	O
filename	*(char)
)	O
;	O
*	O
p	*(void)
=	O
'\0'	O
;	O
}	O
if	O
(	O
diffbuf	*(*(char))
)	O
{	O
char	O
*	O
p	*(void)
=	O
*	O
diffbuf	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
maxdiffsize	long
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
RCSDIFF1	array(char)
,	O
dotslash	*(char)
)	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
quote_system_arg	(*(char),*(char))->(long)
(	O
p	*(void)
,	O
filename	*(char)
)	O
;	O
*	O
p	*(void)
++	O
=	O
'>'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
DEV_NULL	array(char)
)	O
;	O
}	O
r	*(char)
=	O
"RCS"	*(char)
;	O
}	O
else	O
if	O
(	O
try2	O
(	O
"SCCS/%s%s"	*(char)
,	O
SCCSPREFIX	array(char)
,	O
filebase	*(char)
)	O
||	O
try2	O
(	O
"%s%s"	*(char)
,	O
SCCSPREFIX	array(char)
,	O
filebase	*(char)
)	O
)	O
{	O
if	O
(	O
getbuf	*(*(char))
)	O
{	O
char	O
*	O
p	*(void)
=	O
*	O
getbuf	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
maxgetsize	long
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
readonly	bool
?	O
GET	array(char)
:	O
GET_LOCKED	array(char)
)	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
quote_system_arg	(*(char),*(char))->(long)
(	O
p	*(void)
,	O
trybuf	*(char)
)	O
;	O
*	O
p	*(void)
=	O
'\0'	O
;	O
}	O
if	O
(	O
diffbuf	*(*(char))
)	O
{	O
char	O
*	O
p	*(void)
=	O
*	O
diffbuf	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
maxdiffsize	long
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
SCCSDIFF1	array(char)
)	O
;	O
p	*(void)
+=	O
sizeof	O
SCCSDIFF1	array(char)
-	O
1	int
;	O
p	*(void)
+=	O
quote_system_arg	(*(char),*(char))->(long)
(	O
p	*(void)
,	O
trybuf	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
SCCSDIFF2	array(char)
,	O
dotslash	*(char)
)	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
quote_system_arg	(*(char),*(char))->(long)
(	O
p	*(void)
,	O
filename	*(char)
)	O
;	O
*	O
p	*(void)
++	O
=	O
'>'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
DEV_NULL	array(char)
)	O
;	O
}	O
r	*(char)
=	O
"SCCS"	*(char)
;	O
}	O
else	O
if	O
(	O
!	O
readonly	bool
&&	O
filestat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
&&	O
try1	O
(	O
"%s@@"	*(char)
,	O
filebase	*(char)
)	O
&&	O
S_ISDIR	O
(	O
cstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
getbuf	*(*(char))
)	O
{	O
char	O
*	O
p	*(void)
=	O
*	O
getbuf	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
maxgetsize	long
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
CLEARTOOL_CO	array(char)
)	O
;	O
p	*(void)
+=	O
sizeof	O
CLEARTOOL_CO	array(char)
-	O
1	int
;	O
p	*(void)
+=	O
quote_system_arg	(*(char),*(char))->(long)
(	O
p	*(void)
,	O
filename	*(char)
)	O
;	O
*	O
p	*(void)
=	O
'\0'	O
;	O
}	O
if	O
(	O
diffbuf	*(*(char))
)	O
*	O
diffbuf	*(*(char))
=	O
0	int
;	O
r	*(char)
=	O
"ClearCase"	*(char)
;	O
}	O
else	O
if	O
(	O
!	O
readonly	bool
&&	O
filestat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
&&	O
(	O
getenv	(*(char))->(*(char))
(	O
"P4PORT"	*(char)
)	O
||	O
getenv	(*(char))->(*(char))
(	O
"P4USER"	*(char)
)	O
||	O
getenv	(*(char))->(*(char))
(	O
"P4CONFIG"	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
getbuf	*(*(char))
)	O
{	O
char	O
*	O
p	*(void)
=	O
*	O
getbuf	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
maxgetsize	long
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
PERFORCE_CO	array(char)
)	O
;	O
p	*(void)
+=	O
sizeof	O
PERFORCE_CO	array(char)
-	O
1	int
;	O
p	*(void)
+=	O
quote_system_arg	(*(char),*(char))->(long)
(	O
p	*(void)
,	O
filename	*(char)
)	O
;	O
*	O
p	*(void)
=	O
'\0'	O
;	O
}	O
if	O
(	O
diffbuf	*(*(char))
)	O
*	O
diffbuf	*(*(char))
=	O
0	int
;	O
r	*(char)
=	O
"Perforce"	*(char)
;	O
}	O
free	(*(void))->(void)
(	O
trybuf	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
filebase	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
dir	*(char)
)	O
;	O
return	O
r	*(char)
;	O
}	O
bool	bool
version_get	(*(char),*(char),bool,bool,*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(bool)
(	O
char	O
const	O
*	O
filename	*(char)
,	O
char	O
const	O
*	O
cs	short
,	O
bool	bool
exists	bool
,	O
bool	bool
readonly	bool
,	O
char	O
const	O
*	O
getbuf	*(*(char))
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
filestat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
if	O
(	O
patch_get	int
<	O
0	int
)	O
{	O
ask	(*(char))->(void)
(	O
"Get file %s from %s%s? [y] "	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
filename	*(char)
)	O
,	O
cs	short
,	O
readonly	bool
?	O
""	*(char)
:	O
" with lock"	*(char)
)	O
;	O
if	O
(	O
*	O
buf	*(char)
==	O
'n'	O
)	O
return	O
0	int
;	O
}	O
if	O
(	O
dry_run	bool
)	O
{	O
if	O
(	O
!	O
exists	bool
)	O
fatal	(*(char))->(void)
(	O
"can't do dry run on nonexistent version-controlled file %s; invoke '%s' and try again"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
filename	*(char)
)	O
,	O
getbuf	*(*(char))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
verbosity	enum(int,int,int)
==	O
VERBOSE	int
)	O
say	(*(char))->(void)
(	O
"Getting file %s from %s%s...\n"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
filename	*(char)
)	O
,	O
cs	short
,	O
readonly	bool
?	O
""	*(char)
:	O
" with lock"	*(char)
)	O
;	O
if	O
(	O
systemic	(*(char))->(int)
(	O
getbuf	*(*(char))
)	O
!=	O
0	int
)	O
fatal	(*(char))->(void)
(	O
"Can't get file %s from %s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
filename	*(char)
)	O
,	O
cs	short
)	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
filename	*(char)
,	O
filestat	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
!=	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"%s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
filename	*(char)
)	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
char	O
*	O
savebuf	(*(char),long)->(*(char))
(	O
char	O
const	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
size_t	long
size	*(long)
)	O
{	O
char	O
*	O
rv	*(char)
;	O
if	O
(	O
!	O
size	*(long)
)	O
return	O
NULL	O
;	O
rv	*(char)
=	O
malloc	(long)->(*(void))
(	O
size	*(long)
)	O
;	O
if	O
(	O
!	O
rv	*(char)
)	O
{	O
if	O
(	O
!	O
using_plan_a	bool
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
}	O
else	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
rv	*(char)
,	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
size	*(long)
)	O
;	O
return	O
rv	*(char)
;	O
}	O
char	O
*	O
savestr	(*(char))->(*(char))
(	O
char	O
const	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
return	O
savebuf	(*(char),long)->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
strlen	(*(char))->(long)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
+	O
1	int
)	O
;	O
}	O
void	O
remove_prefix	(*(char),long)->(void)
(	O
char	O
*	O
p	*(void)
,	O
size_t	long
prefixlen	long
)	O
{	O
char	O
const	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
p	*(void)
+	O
prefixlen	long
;	O
while	O
(	O
(	O
*	O
p	*(void)
++	O
=	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
)	O
)	O
;	O
}	O
char	O
*	O
format_linenum	(array(char),long)->(*(char))
(	O
char	O
numbuf	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
,	O
lin	long
n	int
)	O
{	O
char	O
*	O
p	*(void)
=	O
numbuf	array(char)
+	O
LINENUM_LENGTH_BOUND	O
;	O
*	O
p	*(void)
=	O
'\0'	O
;	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
do	O
*	O
--	O
p	*(void)
=	O
'0'	O
-	O
(	O
int	O
)	O
(	O
n	int
%	O
10	int
)	O
;	O
while	O
(	O
(	O
n	int
/=	O
10	int
)	O
!=	O
0	int
)	O
;	O
*	O
--	O
p	*(void)
=	O
'-'	O
;	O
}	O
else	O
{	O
do	O
*	O
--	O
p	*(void)
=	O
'0'	O
+	O
(	O
int	O
)	O
(	O
n	int
%	O
10	int
)	O
;	O
while	O
(	O
(	O
n	int
/=	O
10	int
)	O
!=	O
0	int
)	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
void	O
fatal	(*(char))->(void)
(	O
char	O
const	O
*	O
format	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: **** "	*(char)
,	O
program_name	*(char)
)	O
;	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
format	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
format	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fatal_exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
void	O
xalloc_die	()->(void)
(	O
void	O
)	O
{	O
fatal	(*(char))->(void)
(	O
"out of memory"	*(char)
)	O
;	O
}	O
void	O
read_fatal	()->(void)
(	O
void	O
)	O
{	O
pfatal	(*(char))->(void)
(	O
"read error"	*(char)
)	O
;	O
}	O
void	O
write_fatal	()->(void)
(	O
void	O
)	O
{	O
pfatal	(*(char))->(void)
(	O
"write error"	*(char)
)	O
;	O
}	O
void	O
pfatal	(*(char))->(void)
(	O
char	O
const	O
*	O
format	*(char)
,	O
...	O
)	O
{	O
int	O
errnum	int
=	O
errno	O
;	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: **** "	*(char)
,	O
program_name	*(char)
)	O
;	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
format	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
format	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
errno	O
=	O
errnum	int
;	O
perror	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fatal_exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
static	O
void	O
vsay	(*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
char	O
const	O
*	O
format	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
)	O
{	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
format	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
void	O
say	(*(char))->(void)
(	O
char	O
const	O
*	O
format	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
format	*(char)
)	O
;	O
vsay	(*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
format	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
ask	(*(char))->(void)
(	O
char	O
const	O
*	O
format	*(char)
,	O
...	O
)	O
{	O
static	O
int	O
ttyfd	int
=	O
-	O
2	int
;	O
ssize_t	long
r	*(char)
;	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
format	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
format	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ttyfd	int
==	O
-	O
2	int
)	O
{	O
ttyfd	int
=	O
(	O
posixly_correct	bool
||	O
isatty	(int)->(int)
(	O
STDOUT_FILENO	int
)	O
?	O
open	(*(char),int)->(int)
(	O
TTY_DEVICE	*(char)
,	O
O_RDONLY	int
)	O
:	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
ttyfd	int
<	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
buf	*(char)
[	O
0	int
]	O
=	O
'\n'	O
;	O
buf	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
size_t	long
s	enum(int,int,int,int,int,int,int,int,int)
=	O
0	int
;	O
while	O
(	O
(	O
r	*(char)
=	O
read	*((*(void),*(char),long)->(long))
(	O
ttyfd	int
,	O
buf	*(char)
+	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
bufsize	long
-	O
1	int
-	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
)	O
==	O
bufsize	long
-	O
1	int
-	O
s	enum(int,int,int,int,int,int,int,int,int)
&&	O
buf	*(char)
[	O
bufsize	long
-	O
2	int
]	O
!=	O
'\n'	O
)	O
{	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
bufsize	long
-	O
1	int
;	O
bufsize	long
*=	O
2	int
;	O
buf	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
buf	*(char)
,	O
bufsize	long
)	O
;	O
if	O
(	O
!	O
buf	*(char)
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
r	*(char)
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
"EOF\n"	*(char)
)	O
;	O
else	O
if	O
(	O
r	*(char)
<	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"tty read failed"	*(char)
)	O
;	O
ignore_value	O
(	O
close	*((*(void))->(int))
(	O
ttyfd	int
)	O
)	O
;	O
ttyfd	int
=	O
-	O
1	int
;	O
r	*(char)
=	O
0	int
;	O
}	O
buf	*(char)
[	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
r	*(char)
]	O
=	O
'\0'	O
;	O
}	O
}	O
bool	bool
ok_to_reverse	(*(char))->(bool)
(	O
char	O
const	O
*	O
format	*(char)
,	O
...	O
)	O
{	O
bool	bool
r	*(char)
=	O
false	int
;	O
if	O
(	O
noreverse	bool
||	O
!	O
(	O
force	bool
&&	O
verbosity	enum(int,int,int)
==	O
SILENT	int
)	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
format	*(char)
)	O
;	O
vsay	(*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
format	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
if	O
(	O
noreverse	bool
)	O
{	O
say	(*(char))->(void)
(	O
"  Skipping patch.\n"	*(char)
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
force	bool
)	O
{	O
if	O
(	O
verbosity	enum(int,int,int)
!=	O
SILENT	int
)	O
say	(*(char))->(void)
(	O
"  Applying it anyway.\n"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
batch	bool
)	O
{	O
say	(*(char))->(void)
(	O
reverse	bool
?	O
"  Ignoring -R.\n"	*(char)
:	O
"  Assuming -R.\n"	*(char)
)	O
;	O
r	*(char)
=	O
true	int
;	O
}	O
else	O
{	O
ask	(*(char))->(void)
(	O
reverse	bool
?	O
"  Ignore -R? [n] "	*(char)
:	O
"  Assume -R? [n] "	*(char)
)	O
;	O
r	*(char)
=	O
*	O
buf	*(char)
==	O
'y'	O
;	O
if	O
(	O
!	O
r	*(char)
)	O
{	O
ask	(*(char))->(void)
(	O
"Apply anyway? [n] "	*(char)
)	O
;	O
if	O
(	O
*	O
buf	*(char)
!=	O
'y'	O
)	O
{	O
if	O
(	O
verbosity	enum(int,int,int)
!=	O
SILENT	int
)	O
say	(*(char))->(void)
(	O
"Skipping patch.\n"	*(char)
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
}	O
}	O
}	O
return	O
r	*(char)
;	O
}	O
static	O
int	O
const	O
sigs	array(int)
[	O
]	O
=	O
{	O
SIGHUP	int
,	O
SIGPIPE	int
,	O
SIGTERM	int
,	O
SIGXCPU	int
,	O
SIGXFSZ	int
,	O
SIGINT	int
}	O
;	O
static	O
sigset_t	struct(array(long))
initial_signal_mask	struct(array(long))
;	O
static	O
sigset_t	struct(array(long))
signals_to_block	struct(array(long))
;	O
void	O
set_signals	(bool)->(void)
(	O
bool	bool
reset	bool
)	O
{	O
int	O
i	int
;	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
initial_act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
fatal_act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
fatal_act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
=	O
fatal_exit	(int)->(void)
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
fatal_act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
fatal_act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
0	int
;	O
if	O
(	O
!	O
reset	bool
)	O
{	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
signals_to_block	struct(array(long))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_SIGS	O
;	O
i	int
++	O
)	O
{	O
bool	bool
ignoring_signal	bool
;	O
if	O
(	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
sigs	array(int)
[	O
i	int
]	O
,	O
(	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
*	O
)	O
0	int
,	O
&	O
initial_act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
!=	O
0	int
)	O
continue	O
;	O
ignoring_signal	bool
=	O
initial_act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
==	O
SIG_IGN	O
;	O
if	O
(	O
!	O
ignoring_signal	bool
)	O
{	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
signals_to_block	struct(array(long))
,	O
sigs	array(int)
[	O
i	int
]	O
)	O
;	O
setup_handler	O
(	O
sigs	array(int)
[	O
i	int
]	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_SETMASK	int
,	O
&	O
initial_signal_mask	struct(array(long))
,	O
(	O
sigset_t	struct(array(long))
*	O
)	O
0	int
)	O
;	O
}	O
}	O
void	O
ignore_signals	()->(void)
(	O
void	O
)	O
{	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_BLOCK	int
,	O
&	O
signals_to_block	struct(array(long))
,	O
&	O
initial_signal_mask	struct(array(long))
)	O
;	O
}	O
void	O
exit_with_signal	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
sigset_t	struct(array(long))
s	enum(int,int,int,int,int,int,int,int,int)
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
sig	int
,	O
SIG_DFL	O
)	O
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
sig	int
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_UNBLOCK	int
,	O
&	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
(	O
sigset_t	struct(array(long))
*	O
)	O
0	int
)	O
;	O
raise	(int)->(int)
(	O
sig	int
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
int	O
systemic	(*(char))->(int)
(	O
char	O
const	O
*	O
command	*(char)
)	O
{	O
if	O
(	O
debug	int
&	O
8	int
)	O
say	(*(char))->(void)
(	O
"+ %s\n"	*(char)
,	O
command	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
system	(*(char))->(int)
(	O
command	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
replace_slashes	(*(char))->(*(char))
(	O
char	O
*	O
filename	*(char)
)	O
{	O
char	O
*	O
f	struct(long,long,enum(int,int,int,int),bool)
;	O
char	O
*	O
last_location_replaced	*(char)
=	O
0	int
;	O
char	O
const	O
*	O
component_start	*(char)
;	O
for	O
(	O
f	struct(long,long,enum(int,int,int,int),bool)
=	O
filename	*(char)
+	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
filename	*(char)
)	O
;	O
ISSLASH	O
(	O
*	O
f	struct(long,long,enum(int,int,int,int),bool)
)	O
;	O
f	struct(long,long,enum(int,int,int,int),bool)
++	O
)	O
;	O
component_start	*(char)
=	O
f	struct(long,long,enum(int,int,int,int),bool)
;	O
for	O
(	O
;	O
*	O
f	struct(long,long,enum(int,int,int,int),bool)
;	O
f	struct(long,long,enum(int,int,int,int),bool)
++	O
)	O
if	O
(	O
ISSLASH	O
(	O
*	O
f	struct(long,long,enum(int,int,int,int),bool)
)	O
)	O
{	O
char	O
*	O
slash	*(char)
=	O
f	struct(long,long,enum(int,int,int,int),bool)
;	O
while	O
(	O
ISSLASH	O
(	O
f	struct(long,long,enum(int,int,int,int),bool)
[	O
1	int
]	O
)	O
)	O
f	struct(long,long,enum(int,int,int,int),bool)
++	O
;	O
if	O
(	O
!	O
f	struct(long,long,enum(int,int,int,int),bool)
[	O
1	int
]	O
)	O
break	O
;	O
if	O
(	O
!	O
(	O
slash	*(char)
-	O
component_start	*(char)
<=	O
2	int
&&	O
component_start	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
slash	*(char)
[	O
-	O
1	int
]	O
==	O
'.'	O
)	O
)	O
{	O
*	O
slash	*(char)
=	O
'\0'	O
;	O
last_location_replaced	*(char)
=	O
slash	*(char)
;	O
}	O
component_start	*(char)
=	O
f	struct(long,long,enum(int,int,int,int),bool)
+	O
1	int
;	O
}	O
return	O
last_location_replaced	*(char)
;	O
}	O
static	O
void	O
makedirs	(*(char))->(void)
(	O
char	O
const	O
*	O
name	*(char)
)	O
{	O
char	O
*	O
filename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
char	O
*	O
f	struct(long,long,enum(int,int,int,int),bool)
;	O
char	O
*	O
flim	*(char)
=	O
replace_slashes	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
if	O
(	O
flim	*(char)
)	O
{	O
for	O
(	O
f	struct(long,long,enum(int,int,int,int),bool)
=	O
filename	*(char)
;	O
f	struct(long,long,enum(int,int,int,int),bool)
<=	O
flim	*(char)
;	O
f	struct(long,long,enum(int,int,int,int),bool)
++	O
)	O
if	O
(	O
!	O
*	O
f	struct(long,long,enum(int,int,int,int),bool)
)	O
{	O
mkdir	(*(char),int)->(int)
(	O
filename	*(char)
,	O
S_IRUSR	O
|	O
S_IWUSR	O
|	O
S_IXUSR	O
|	O
S_IRGRP	O
|	O
S_IWGRP	O
|	O
S_IXGRP	O
|	O
S_IROTH	O
|	O
S_IWOTH	O
|	O
S_IXOTH	O
)	O
;	O
*	O
f	struct(long,long,enum(int,int,int,int),bool)
=	O
'/'	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
}	O
void	O
removedirs	(*(char))->(void)
(	O
char	O
const	O
*	O
name	*(char)
)	O
{	O
char	O
*	O
filename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
;	O
i	int
!=	O
0	int
;	O
i	int
--	O
)	O
if	O
(	O
ISSLASH	O
(	O
filename	*(char)
[	O
i	int
]	O
)	O
&&	O
!	O
(	O
ISSLASH	O
(	O
filename	*(char)
[	O
i	int
-	O
1	int
]	O
)	O
||	O
(	O
filename	*(char)
[	O
i	int
-	O
1	int
]	O
==	O
'.'	O
&&	O
(	O
i	int
==	O
1	int
||	O
ISSLASH	O
(	O
filename	*(char)
[	O
i	int
-	O
2	int
]	O
)	O
||	O
(	O
filename	*(char)
[	O
i	int
-	O
2	int
]	O
==	O
'.'	O
&&	O
(	O
i	int
==	O
2	int
||	O
ISSLASH	O
(	O
filename	*(char)
[	O
i	int
-	O
3	int
]	O
)	O
)	O
)	O
)	O
)	O
)	O
)	O
{	O
filename	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
rmdir	(*(char))->(int)
(	O
filename	*(char)
)	O
==	O
0	int
&&	O
verbosity	enum(int,int,int)
==	O
VERBOSE	int
)	O
say	(*(char))->(void)
(	O
"Removed empty directory %s\n"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
filename	*(char)
)	O
)	O
;	O
filename	*(char)
[	O
i	int
]	O
=	O
'/'	O
;	O
}	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
}	O
static	O
struct	O
timespec	struct(long,long)
initial_time	struct(long,long)
;	O
void	O
init_time	()->(void)
(	O
void	O
)	O
{	O
gettime	(*(struct(long,long)))->(void)
(	O
&	O
initial_time	struct(long,long)
)	O
;	O
}	O
static	O
char	O
*	O
parse_c_string	(*(char),*(*(char)))->(*(char))
(	O
char	O
const	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
char	O
const	O
*	O
*	O
endp	*(*(char))
)	O
{	O
char	O
*	O
u	*(char)
,	O
*	O
v	*(char)
;	O
assert	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
'"'	O
)	O
;	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
u	*(char)
=	O
v	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
c	char
=	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
switch	O
(	O
c	char
)	O
{	O
case	O
0	int
:	O
goto	O
fail	O
;	O
case	O
'"'	O
:	O
*	O
v	*(char)
++	O
=	O
0	int
;	O
v	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
u	*(char)
,	O
v	*(char)
-	O
u	*(char)
)	O
;	O
if	O
(	O
v	*(char)
)	O
u	*(char)
=	O
v	*(char)
;	O
if	O
(	O
endp	*(*(char))
)	O
*	O
endp	*(*(char))
=	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
return	O
u	*(char)
;	O
case	O
'\\'	O
:	O
break	O
;	O
default	O
:	O
*	O
v	*(char)
++	O
=	O
c	char
;	O
continue	O
;	O
}	O
c	char
=	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
switch	O
(	O
c	char
)	O
{	O
case	O
'a'	O
:	O
c	char
=	O
'\a'	O
;	O
break	O
;	O
case	O
'b'	O
:	O
c	char
=	O
'\b'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
c	char
=	O
'\f'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
c	char
=	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
c	char
=	O
'\r'	O
;	O
break	O
;	O
case	O
't'	O
:	O
c	char
=	O
'\t'	O
;	O
break	O
;	O
case	O
'v'	O
:	O
c	char
=	O
'\v'	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
case	O
'"'	O
:	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
{	O
int	O
acc	int
=	O
(	O
c	char
-	O
'0'	O
)	O
<<	O
6	int
;	O
c	char
=	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
if	O
(	O
c	char
<	O
'0'	O
||	O
c	char
>	O
'7'	O
)	O
goto	O
fail	O
;	O
acc	int
|=	O
(	O
c	char
-	O
'0'	O
)	O
<<	O
3	int
;	O
c	char
=	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
if	O
(	O
c	char
<	O
'0'	O
||	O
c	char
>	O
'7'	O
)	O
goto	O
fail	O
;	O
acc	int
|=	O
(	O
c	char
-	O
'0'	O
)	O
;	O
c	char
=	O
acc	int
;	O
break	O
;	O
}	O
default	O
:	O
goto	O
fail	O
;	O
}	O
*	O
v	*(char)
++	O
=	O
c	char
;	O
}	O
fail	O
:	O
free	(*(void))->(void)
(	O
u	*(char)
)	O
;	O
if	O
(	O
endp	*(*(char))
)	O
*	O
endp	*(*(char))
=	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
return	O
NULL	O
;	O
}	O
static	O
bool	bool
strip_leading_slashes	(*(char),int)->(bool)
(	O
char	O
*	O
name	*(char)
,	O
int	O
strip_leading	int
)	O
{	O
int	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
strip_leading	int
;	O
char	O
*	O
p	*(void)
,	O
*	O
n	int
;	O
for	O
(	O
p	*(void)
=	O
n	int
=	O
name	*(char)
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
{	O
if	O
(	O
ISSLASH	O
(	O
*	O
p	*(void)
)	O
)	O
{	O
while	O
(	O
ISSLASH	O
(	O
p	*(void)
[	O
1	int
]	O
)	O
)	O
p	*(void)
++	O
;	O
if	O
(	O
strip_leading	int
<	O
0	int
||	O
--	O
s	enum(int,int,int,int,int,int,int,int,int)
>=	O
0	int
)	O
n	int
=	O
p	*(void)
+	O
1	int
;	O
}	O
}	O
if	O
(	O
(	O
strip_leading	int
<	O
0	int
||	O
s	enum(int,int,int,int,int,int,int,int,int)
<=	O
0	int
)	O
&&	O
*	O
n	int
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
name	*(char)
,	O
n	int
,	O
strlen	(*(char))->(long)
(	O
n	int
)	O
+	O
1	int
)	O
;	O
return	O
true	int
;	O
}	O
else	O
return	O
false	int
;	O
}	O
void	O
fetchname	(*(char),int,*(*(char)),*(*(char)),*(struct(long,long)))->(void)
(	O
char	O
const	O
*	O
at	*(char)
,	O
int	O
strip_leading	int
,	O
char	O
*	O
*	O
pname	*(*(char))
,	O
char	O
*	O
*	O
ptimestr	*(*(char))
,	O
struct	O
timespec	struct(long,long)
*	O
pstamp	*(struct(long,long))
)	O
{	O
char	O
*	O
name	*(char)
;	O
const	O
char	O
*	O
t	struct(long,long)
;	O
char	O
*	O
timestr	*(char)
=	O
NULL	O
;	O
struct	O
timespec	struct(long,long)
stamp	struct(long,long)
;	O
stamp	struct(long,long)
.	O
tv_sec	long
=	O
-	O
1	int
;	O
stamp	struct(long,long)
.	O
tv_nsec	long
=	O
0	int
;	O
while	O
(	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
at	*(char)
)	O
)	O
at	*(char)
++	O
;	O
if	O
(	O
debug	int
&	O
128	int
)	O
say	(*(char))->(void)
(	O
"fetchname %s %d\n"	*(char)
,	O
at	*(char)
,	O
strip_leading	int
)	O
;	O
if	O
(	O
*	O
at	*(char)
==	O
'"'	O
)	O
{	O
name	*(char)
=	O
parse_c_string	(*(char),*(*(char)))->(*(char))
(	O
at	*(char)
,	O
&	O
t	struct(long,long)
)	O
;	O
if	O
(	O
!	O
name	*(char)
)	O
{	O
if	O
(	O
debug	int
&	O
128	int
)	O
say	(*(char))->(void)
(	O
"ignoring malformed filename %s\n"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
at	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
t	struct(long,long)
=	O
at	*(char)
;	O
*	O
t	struct(long,long)
;	O
t	struct(long,long)
++	O
)	O
{	O
if	O
(	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
t	struct(long,long)
)	O
)	O
{	O
char	O
const	O
*	O
u	*(char)
=	O
t	struct(long,long)
;	O
while	O
(	O
*	O
u	*(char)
!=	O
'\t'	O
&&	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
u	*(char)
[	O
1	int
]	O
)	O
)	O
u	*(char)
++	O
;	O
if	O
(	O
*	O
u	*(char)
!=	O
'\t'	O
&&	O
(	O
strchr	(*(char),int)->(*(char))
(	O
u	*(char)
+	O
1	int
,	O
pstamp	*(struct(long,long))
?	O
'\t'	O
:	O
'\n'	O
)	O
)	O
)	O
continue	O
;	O
break	O
;	O
}	O
}	O
name	*(char)
=	O
savebuf	(*(char),long)->(*(char))
(	O
at	*(char)
,	O
t	struct(long,long)
-	O
at	*(char)
+	O
1	int
)	O
;	O
name	*(char)
[	O
t	struct(long,long)
-	O
at	*(char)
]	O
=	O
0	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"/dev/null"	*(char)
)	O
==	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
if	O
(	O
pstamp	*(struct(long,long))
)	O
{	O
pstamp	*(struct(long,long))
->	O
tv_sec	long
=	O
0	int
;	O
pstamp	*(struct(long,long))
->	O
tv_nsec	long
=	O
0	int
;	O
}	O
return	O
;	O
}	O
if	O
(	O
!	O
strip_leading_slashes	(*(char),int)->(bool)
(	O
name	*(char)
,	O
strip_leading	int
)	O
)	O
{	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
ptimestr	*(*(char))
)	O
{	O
char	O
const	O
*	O
u	*(char)
=	O
t	struct(long,long)
+	O
strlen	(*(char))->(long)
(	O
t	struct(long,long)
)	O
;	O
if	O
(	O
u	*(char)
!=	O
t	struct(long,long)
&&	O
*	O
(	O
u	*(char)
-	O
1	int
)	O
==	O
'\n'	O
)	O
u	*(char)
--	O
;	O
if	O
(	O
u	*(char)
!=	O
t	struct(long,long)
&&	O
*	O
(	O
u	*(char)
-	O
1	int
)	O
==	O
'\r'	O
)	O
u	*(char)
--	O
;	O
timestr	*(char)
=	O
savebuf	(*(char),long)->(*(char))
(	O
t	struct(long,long)
,	O
u	*(char)
-	O
t	struct(long,long)
+	O
1	int
)	O
;	O
timestr	*(char)
[	O
u	*(char)
-	O
t	struct(long,long)
]	O
=	O
0	int
;	O
}	O
if	O
(	O
*	O
t	struct(long,long)
!=	O
'\n'	O
)	O
{	O
if	O
(	O
!	O
pstamp	*(struct(long,long))
)	O
{	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
timestr	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
set_time	bool
|	O
set_utc	bool
)	O
get_date	O
(	O
&	O
stamp	struct(long,long)
,	O
t	struct(long,long)
,	O
&	O
initial_time	struct(long,long)
)	O
;	O
else	O
{	O
const	O
struct	O
timespec	struct(long,long)
lower	struct(long,long)
=	O
{	O
-	O
25L	int
*	O
60	int
*	O
60	int
}	O
,	O
upper	struct(long,long)
=	O
{	O
26L	int
*	O
60	int
*	O
60	int
}	O
;	O
if	O
(	O
get_date	O
(	O
&	O
stamp	struct(long,long)
,	O
t	struct(long,long)
,	O
&	O
initial_time	struct(long,long)
)	O
&&	O
timespec_cmp	(struct(long,long),struct(long,long))->(int)
(	O
stamp	struct(long,long)
,	O
lower	struct(long,long)
)	O
>	O
0	int
&&	O
timespec_cmp	(struct(long,long),struct(long,long))->(int)
(	O
stamp	struct(long,long)
,	O
upper	struct(long,long)
)	O
<	O
0	int
)	O
{	O
stamp	struct(long,long)
.	O
tv_sec	long
=	O
0	int
;	O
stamp	struct(long,long)
.	O
tv_nsec	long
=	O
0	int
;	O
}	O
}	O
}	O
free	(*(void))->(void)
(	O
*	O
pname	*(*(char))
)	O
;	O
*	O
pname	*(*(char))
=	O
name	*(char)
;	O
if	O
(	O
ptimestr	*(*(char))
)	O
{	O
free	(*(void))->(void)
(	O
*	O
ptimestr	*(*(char))
)	O
;	O
*	O
ptimestr	*(*(char))
=	O
timestr	*(char)
;	O
}	O
if	O
(	O
pstamp	*(struct(long,long))
)	O
*	O
pstamp	*(struct(long,long))
=	O
stamp	struct(long,long)
;	O
}	O
char	O
*	O
parse_name	(*(char),int,*(*(char)))->(*(char))
(	O
char	O
const	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
int	O
strip_leading	int
,	O
char	O
const	O
*	O
*	O
endp	*(*(char))
)	O
{	O
char	O
*	O
ret	*(char)
;	O
while	O
(	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
)	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
'"'	O
)	O
ret	*(char)
=	O
parse_c_string	(*(char),*(*(char)))->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
endp	*(*(char))
)	O
;	O
else	O
{	O
char	O
const	O
*	O
t	struct(long,long)
;	O
for	O
(	O
t	struct(long,long)
=	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
*	O
t	struct(long,long)
&&	O
!	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
t	struct(long,long)
)	O
;	O
t	struct(long,long)
++	O
)	O
;	O
ret	*(char)
=	O
savebuf	(*(char),long)->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
t	struct(long,long)
-	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
1	int
)	O
;	O
ret	*(char)
[	O
t	struct(long,long)
-	O
s	enum(int,int,int,int,int,int,int,int,int)
]	O
=	O
0	int
;	O
if	O
(	O
endp	*(*(char))
)	O
*	O
endp	*(*(char))
=	O
t	struct(long,long)
;	O
}	O
if	O
(	O
!	O
strip_leading_slashes	(*(char),int)->(bool)
(	O
ret	*(char)
,	O
strip_leading	int
)	O
)	O
{	O
free	(*(void))->(void)
(	O
ret	*(char)
)	O
;	O
ret	*(char)
=	O
NULL	O
;	O
}	O
return	O
ret	*(char)
;	O
}	O
void	O
Fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(void)
(	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
file_offset	long
offset	long
,	O
int	O
ptrname	int
)	O
{	O
if	O
(	O
file_seek	O
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
offset	long
,	O
ptrname	int
)	O
!=	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"fseek"	*(char)
)	O
;	O
}	O
int	O
make_tempfile	(*(*(char)),char,*(char),int,int)->(int)
(	O
char	O
const	O
*	O
*	O
name	*(char)
,	O
char	O
letter	char
,	O
char	O
const	O
*	O
real_name	*(char)
,	O
int	O
flags	int
,	O
mode_t	int
mode	int
)	O
{	O
int	O
try_makedirs_errno	int
=	O
ENOENT	int
;	O
char	O
*	O
template	*(char)
;	O
if	O
(	O
real_name	*(char)
)	O
{	O
char	O
*	O
dirname	*(char)
,	O
*	O
basename	(*(char))->(*(char))
;	O
dirname	*(char)
=	O
dir_name	(*(char))->(*(char))
(	O
real_name	*(char)
)	O
;	O
basename	(*(char))->(*(char))
=	O
base_name	(*(char))->(*(char))
(	O
real_name	*(char)
)	O
;	O
template	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
dirname	*(char)
)	O
+	O
1	int
+	O
strlen	(*(char))->(long)
(	O
basename	(*(char))->(*(char))
)	O
+	O
9	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
template	*(char)
,	O
"%s/%s.%cXXXXXX"	*(char)
,	O
dirname	*(char)
,	O
basename	(*(char))->(*(char))
,	O
letter	char
)	O
;	O
free	(*(void))->(void)
(	O
dirname	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
basename	(*(char))->(*(char))
)	O
;	O
}	O
else	O
{	O
char	O
const	O
*	O
tmpdir	*(char)
;	O
tmpdir	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"TMPDIR"	*(char)
)	O
;	O
if	O
(	O
!	O
tmpdir	*(char)
)	O
tmpdir	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"TMP"	*(char)
)	O
;	O
if	O
(	O
!	O
tmpdir	*(char)
)	O
tmpdir	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"TEMP"	*(char)
)	O
;	O
if	O
(	O
!	O
tmpdir	*(char)
)	O
tmpdir	*(char)
=	O
TMPDIR	*(char)
;	O
template	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
tmpdir	*(char)
)	O
+	O
10	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
template	*(char)
,	O
"%s/p%cXXXXXX"	*(char)
,	O
tmpdir	*(char)
,	O
letter	char
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
fd	int
;	O
if	O
(	O
gen_tempname	(*(char),int,int,int)->(int)
(	O
template	*(char)
,	O
0	int
,	O
flags	int
,	O
GT_NOCREATE	int
)	O
)	O
pfatal	(*(char))->(void)
(	O
"Can't create temporary file %s"	*(char)
,	O
template	*(char)
)	O
;	O
retry	O
:	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
template	*(char)
,	O
O_CREAT	int
|	O
O_EXCL	int
|	O
flags	int
,	O
mode	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
try_makedirs_errno	int
)	O
{	O
makedirs	(*(char))->(void)
(	O
template	*(char)
)	O
;	O
try_makedirs_errno	int
=	O
0	int
;	O
goto	O
retry	O
;	O
}	O
if	O
(	O
errno	O
==	O
EEXIST	int
)	O
continue	O
;	O
pfatal	(*(char))->(void)
(	O
"Can't create temporary file %s"	*(char)
,	O
template	*(char)
)	O
;	O
}	O
*	O
name	*(char)
=	O
template	*(char)
;	O
return	O
fd	int
;	O
}	O
}	O
