error_t	O
S_socket_connect2	(*(struct(struct,*(struct(int,union`,*`,*`,*`,int,int,int,int,*`,*`,*`,*`)))),*(struct(struct,*(struct(int,union`,*`,*`,*`,int,int,int,int,*`,*`,*`,*`)))))->(int)
(	O
struct	O
sock_user	struct(struct,*(struct))
*	O
user1	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
struct	O
sock_user	struct(struct,*(struct))
*	O
user2	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
error_t	O
err	O
;	O
if	O
(	O
!	O
user1	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
||	O
!	O
user2	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
return	O
EOPNOTSUPP	O
;	O
err	O
=	O
sock_connect	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(int)
(	O
user1	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
,	O
user2	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
)	O
;	O
if	O
(	O
!	O
err	O
&&	O
user1	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
->	O
pipe_class	*(struct)
->	O
flags	int
&	O
PIPE_CLASS_CONNECTIONLESS	O
)	O
err	O
=	O
sock_connect	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(int)
(	O
user2	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
,	O
user1	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
user2	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
pi	struct
.	O
port_right	O
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
ensure_connq	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(int)
(	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
!	O
sock	*(struct)
->	O
listen_queue	*(struct)
)	O
err	O
=	O
connq_create	()->(int)
(	O
&	O
sock	*(struct)
->	O
listen_queue	*(struct)
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	O
;	O
}	O
error_t	O
S_socket_listen	(*(struct(struct,*(struct(int,union`,*`,*`,*`,int,int,int,int,*`,*`,*`,*`)))),int)->(int)
(	O
struct	O
sock_user	struct(struct,*(struct))
*	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
int	O
queue_limit	int
)	O
{	O
error_t	O
err	O
;	O
if	O
(	O
!	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
queue_limit	int
<	O
0	int
)	O
return	O
EINVAL	O
;	O
err	O
=	O
ensure_connq	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(int)
(	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
connq_set_length	()->(int)
(	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
->	O
listen_queue	*(struct)
,	O
queue_limit	int
)	O
;	O
return	O
err	O
;	O
}	O
error_t	O
S_socket_connect	(*(struct(struct,*(struct(int,union`,*`,*`,*`,int,int,int,int,*`,*`,*`,*`)))),*(struct))->(int)
(	O
struct	O
sock_user	struct(struct,*(struct))
*	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
struct	O
addr	*(struct)
*	O
addr	*(struct)
)	O
{	O
error_t	O
err	O
;	O
struct	O
sock	*(struct)
*	O
peer	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
;	O
if	O
(	O
!	O
addr	*(struct)
)	O
return	O
ECONNREFUSED	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
(	O
(	O
struct	O
port_info	O
*	O
)	O
addr	*(struct)
)	O
->	O
port_right	O
)	O
;	O
if	O
(	O
!	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
return	O
EOPNOTSUPP	O
;	O
err	O
=	O
addr_get_sock	(*(struct),*(*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))->(int)
(	O
addr	*(struct)
,	O
&	O
peer	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
;	O
if	O
(	O
err	O
==	O
EADDRNOTAVAIL	O
)	O
err	O
=	O
ECONNREFUSED	O
;	O
else	O
if	O
(	O
!	O
err	O
)	O
{	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
=	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
;	O
struct	O
connq	O
*	O
cq	*(struct)
=	O
peer	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
listen_queue	*(struct)
;	O
if	O
(	O
sock	*(struct)
->	O
pipe_class	*(struct)
->	O
flags	int
&	O
PIPE_CLASS_CONNECTIONLESS	O
)	O
err	O
=	O
sock_connect	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(int)
(	O
sock	*(struct)
,	O
peer	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
;	O
else	O
if	O
(	O
cq	*(struct)
)	O
{	O
pthread_mutex_lock	()->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
sock	*(struct)
->	O
connect_queue	*(struct)
)	O
err	O
=	O
EALREADY	O
;	O
else	O
if	O
(	O
sock	*(struct)
->	O
flags	int
&	O
PFLOCAL_SOCK_CONNECTED	int
)	O
err	O
=	O
EISCONN	O
;	O
else	O
{	O
sock	*(struct)
->	O
connect_queue	*(struct)
=	O
cq	*(struct)
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
err	O
=	O
connq_connect	()->(int)
(	O
peer	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
listen_queue	*(struct)
,	O
sock	*(struct)
->	O
flags	int
&	O
PFLOCAL_SOCK_NONBLOCK	int
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
struct	O
sock	*(struct)
*	O
server	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
;	O
err	O
=	O
sock_clone	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))->(int)
(	O
peer	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
,	O
&	O
server	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
err	O
=	O
sock_connect	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(int)
(	O
sock	*(struct)
,	O
server	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
;	O
if	O
(	O
!	O
err	O
)	O
connq_connect_complete	()->(int)
(	O
peer	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
listen_queue	*(struct)
,	O
server	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
;	O
else	O
sock_free	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(void)
(	O
server	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
;	O
}	O
if	O
(	O
err	O
)	O
connq_connect_cancel	()->(int)
(	O
peer	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
listen_queue	*(struct)
)	O
;	O
}	O
pthread_mutex_lock	()->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
sock	*(struct)
->	O
connect_queue	*(struct)
=	O
NULL	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
}	O
else	O
err	O
=	O
ECONNREFUSED	O
;	O
sock_deref	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(void)
(	O
peer	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
;	O
}	O
return	O
err	O
;	O
}	O
error_t	O
S_socket_accept	(*(struct(struct,*(struct(int,union`,*`,*`,*`,int,int,int,int,*`,*`,*`,*`)))),*(int),*(int),*(int),*(int))->(int)
(	O
struct	O
sock_user	struct(struct,*(struct))
*	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
mach_port_t	O
*	O
port	*(int)
,	O
mach_msg_type_name_t	O
*	O
port_type	*(int)
,	O
mach_port_t	O
*	O
peer_addr_port	*(int)
,	O
mach_msg_type_name_t	O
*	O
peer_addr_port_type	*(int)
)	O
{	O
error_t	O
err	O
;	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
;	O
if	O
(	O
!	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
return	O
EOPNOTSUPP	O
;	O
sock	*(struct)
=	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
;	O
err	O
=	O
ensure_connq	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(int)
(	O
sock	*(struct)
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
struct	O
timespec	struct(long,long)
noblock	struct(long,long)
=	O
{	O
0	int
,	O
0	int
}	O
;	O
struct	O
sock	*(struct)
*	O
peer_sock	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
;	O
err	O
=	O
connq_listen	()->(int)
(	O
sock	*(struct)
->	O
listen_queue	*(struct)
,	O
(	O
sock	*(struct)
->	O
flags	int
&	O
PFLOCAL_SOCK_NONBLOCK	int
)	O
?	O
&	O
noblock	struct(long,long)
:	O
NULL	O
,	O
&	O
peer_sock	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
struct	O
addr	*(struct)
*	O
peer_addr	*(struct)
;	O
*	O
port_type	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
err	O
=	O
sock_create_port	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(int))->(int)
(	O
peer_sock	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
,	O
port	*(int)
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
sock_get_addr	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(*(struct)))->(int)
(	O
peer_sock	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
,	O
&	O
peer_addr	*(struct)
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
*	O
peer_addr_port	*(int)
=	O
ports_get_right	()->(int)
(	O
peer_addr	*(struct)
)	O
;	O
*	O
peer_addr_port_type	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
ports_port_deref	()->(int)
(	O
peer_addr	*(struct)
)	O
;	O
}	O
else	O
{	O
}	O
}	O
}	O
return	O
err	O
;	O
}	O
error_t	O
S_socket_bind	(*(struct(struct,*(struct(int,union`,*`,*`,*`,int,int,int,int,*`,*`,*`,*`)))),*(struct))->(int)
(	O
struct	O
sock_user	struct(struct,*(struct))
*	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
struct	O
addr	*(struct)
*	O
addr	*(struct)
)	O
{	O
if	O
(	O
!	O
addr	*(struct)
)	O
return	O
EADDRNOTAVAIL	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
(	O
(	O
struct	O
port_info	O
*	O
)	O
addr	*(struct)
)	O
->	O
port_right	O
)	O
;	O
if	O
(	O
!	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
return	O
EOPNOTSUPP	O
;	O
return	O
sock_bind	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(struct))->(int)
(	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
,	O
addr	*(struct)
)	O
;	O
}	O
error_t	O
S_socket_shutdown	(*(struct(struct,*(struct(int,union`,*`,*`,*`,int,int,int,int,*`,*`,*`,*`)))),int)->(int)
(	O
struct	O
sock_user	struct(struct,*(struct))
*	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
int	O
what	int
)	O
{	O
if	O
(	O
!	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
return	O
EOPNOTSUPP	O
;	O
sock_shutdown	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),int)->(void)
(	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
,	O
(	O
what	int
!=	O
1	int
?	O
PFLOCAL_SOCK_SHUTDOWN_READ	int
:	O
0	int
)	O
|	O
(	O
what	int
!=	O
0	int
?	O
PFLOCAL_SOCK_SHUTDOWN_WRITE	int
:	O
0	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_socket_name	(*(struct(struct,*(struct(int,union`,*`,*`,*`,int,int,int,int,*`,*`,*`,*`)))),*(int),*(int))->(int)
(	O
struct	O
sock_user	struct(struct,*(struct))
*	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
mach_port_t	O
*	O
addr_port	*(int)
,	O
mach_msg_type_name_t	O
*	O
addr_port_type	*(int)
)	O
{	O
error_t	O
err	O
;	O
struct	O
addr	*(struct)
*	O
addr	*(struct)
;	O
if	O
(	O
!	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
return	O
EOPNOTSUPP	O
;	O
err	O
=	O
sock_get_addr	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(*(struct)))->(int)
(	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
,	O
&	O
addr	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
*	O
addr_port	*(int)
=	O
ports_get_right	()->(int)
(	O
addr	*(struct)
)	O
;	O
*	O
addr_port_type	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
ports_port_deref	()->(int)
(	O
addr	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_socket_peername	(*(struct(struct,*(struct(int,union`,*`,*`,*`,int,int,int,int,*`,*`,*`,*`)))),*(int),*(int))->(int)
(	O
struct	O
sock_user	struct(struct,*(struct))
*	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
mach_port_t	O
*	O
addr_port	*(int)
,	O
mach_msg_type_name_t	O
*	O
addr_port_type	*(int)
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
!	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
return	O
EOPNOTSUPP	O
;	O
*	O
addr_port_type	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
}	O
error_t	O
S_socket_send	(*(struct(struct,*(struct(int,union`,*`,*`,*`,int,int,int,int,*`,*`,*`,*`)))),*(struct),int,*(char),long,*(int),long,*(char),long,*(long))->(int)
(	O
struct	O
sock_user	struct(struct,*(struct))
*	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
struct	O
addr	*(struct)
*	O
dest_addr	*(struct)
,	O
int	O
flags	int
,	O
char	O
*	O
data	*(char)
,	O
size_t	long
data_len	long
,	O
mach_port_t	O
*	O
ports	*(int)
,	O
size_t	long
num_ports	long
,	O
char	O
*	O
control	*(char)
,	O
size_t	long
control_len	long
,	O
size_t	long
*	O
amount	*(long)
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
int	O
noblock	struct(long,long)
;	O
struct	O
pipe	*(*(struct))
*	O
pipe	*(*(struct))
;	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
,	O
*	O
dest_sock	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
;	O
struct	O
addr	*(struct)
*	O
source_addr	*(struct)
;	O
if	O
(	O
!	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
return	O
EOPNOTSUPP	O
;	O
sock	*(struct)
=	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
;	O
if	O
(	O
flags	int
&	O
MSG_OOB	int
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
dest_addr	*(struct)
)	O
{	O
err	O
=	O
addr_get_sock	(*(struct),*(*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))->(int)
(	O
dest_addr	*(struct)
,	O
&	O
dest_sock	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
;	O
if	O
(	O
err	O
==	O
EADDRNOTAVAIL	O
)	O
err	O
=	O
ECONNREFUSED	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
if	O
(	O
sock	*(struct)
->	O
pipe_class	*(struct)
!=	O
dest_sock	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
->	O
pipe_class	*(struct)
)	O
err	O
=	O
EINVAL	O
;	O
}	O
else	O
dest_sock	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
=	O
0	int
;	O
if	O
(	O
!	O
err	O
&&	O
sock	*(struct)
->	O
pipe_class	*(struct)
->	O
flags	int
&	O
PIPE_CLASS_CONNECTIONLESS	O
)	O
err	O
=	O
sock_get_addr	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(*(struct)))->(int)
(	O
sock	*(struct)
,	O
&	O
source_addr	*(struct)
)	O
;	O
else	O
source_addr	*(struct)
=	O
NULL	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
if	O
(	O
dest_sock	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
err	O
=	O
sock_acquire_read_pipe	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(*(struct)))->(int)
(	O
dest_sock	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
,	O
&	O
pipe	*(*(struct))
)	O
;	O
else	O
err	O
=	O
sock_acquire_write_pipe	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(*(struct)))->(int)
(	O
sock	*(struct)
,	O
&	O
pipe	*(*(struct))
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
noblock	struct(long,long)
=	O
(	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
->	O
flags	int
&	O
PFLOCAL_SOCK_NONBLOCK	int
)	O
||	O
(	O
flags	int
&	O
MSG_DONTWAIT	int
)	O
;	O
err	O
=	O
pipe_send	()->(int)
(	O
pipe	*(*(struct))
,	O
noblock	struct(long,long)
,	O
source_addr	*(struct)
,	O
data	*(char)
,	O
data_len	long
,	O
control	*(char)
,	O
control_len	long
,	O
ports	*(int)
,	O
num_ports	long
,	O
amount	*(long)
)	O
;	O
if	O
(	O
dest_sock	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
pipe_release_reader	()->(int)
(	O
pipe	*(*(struct))
)	O
;	O
else	O
pipe_release_writer	()->(int)
(	O
pipe	*(*(struct))
)	O
;	O
}	O
if	O
(	O
err	O
)	O
{	O
if	O
(	O
source_addr	*(struct)
)	O
ports_port_deref	()->(int)
(	O
source_addr	*(struct)
)	O
;	O
while	O
(	O
num_ports	long
--	O
>	O
0	int
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
*	O
ports	*(int)
++	O
)	O
;	O
}	O
}	O
if	O
(	O
dest_sock	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
sock_deref	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))))->(void)
(	O
dest_sock	*(struct(int,union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct)))
)	O
;	O
return	O
err	O
;	O
}	O
error_t	O
S_socket_recv	(*(struct(struct,*(struct(int,union`,*`,*`,*`,int,int,int,int,*`,*`,*`,*`)))),*(int),*(int),int,*(*(char)),*(long),*(*(int)),*(int),*(long),*(*(char)),*(long),*(int),long)->(int)
(	O
struct	O
sock_user	struct(struct,*(struct))
*	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
mach_port_t	O
*	O
addr	*(struct)
,	O
mach_msg_type_name_t	O
*	O
addr_type	*(int)
,	O
int	O
in_flags	int
,	O
char	O
*	O
*	O
data	*(char)
,	O
size_t	long
*	O
data_len	long
,	O
mach_port_t	O
*	O
*	O
ports	*(int)
,	O
mach_msg_type_name_t	O
*	O
ports_type	*(int)
,	O
size_t	long
*	O
num_ports	long
,	O
char	O
*	O
*	O
control	*(char)
,	O
size_t	long
*	O
control_len	long
,	O
int	O
*	O
out_flags	*(int)
,	O
size_t	long
amount	*(long)
)	O
{	O
error_t	O
err	O
;	O
unsigned	O
flags	int
;	O
int	O
noblock	struct(long,long)
;	O
struct	O
pipe	*(*(struct))
*	O
pipe	*(*(struct))
;	O
void	O
*	O
source_addr	*(struct)
=	O
NULL	O
;	O
if	O
(	O
!	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
in_flags	int
&	O
MSG_OOB	int
)	O
return	O
EINVAL	O
;	O
flags	int
=	O
in_flags	int
&	O
MSG_PEEK	int
;	O
err	O
=	O
sock_acquire_read_pipe	(*(struct(int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long),*(struct),*(struct),*(struct),int,int,int,int,*(struct),*(struct),*(struct),*(struct))),*(*(struct)))->(int)
(	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
,	O
&	O
pipe	*(*(struct))
)	O
;	O
if	O
(	O
err	O
==	O
EPIPE	O
)	O
{	O
*	O
data_len	long
=	O
0	int
;	O
if	O
(	O
num_ports	long
)	O
*	O
num_ports	long
=	O
0	int
;	O
if	O
(	O
control_len	long
)	O
*	O
control_len	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
err	O
)	O
{	O
noblock	struct(long,long)
=	O
(	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
->	O
flags	int
&	O
PFLOCAL_SOCK_NONBLOCK	int
)	O
||	O
(	O
in_flags	int
&	O
MSG_DONTWAIT	int
)	O
;	O
err	O
=	O
pipe_recv	()->(int)
(	O
pipe	*(*(struct))
,	O
noblock	struct(long,long)
,	O
&	O
flags	int
,	O
&	O
source_addr	*(struct)
,	O
data	*(char)
,	O
data_len	long
,	O
amount	*(long)
,	O
control	*(char)
,	O
control_len	long
,	O
ports	*(int)
,	O
num_ports	long
)	O
;	O
pipe_release_reader	()->(int)
(	O
pipe	*(*(struct))
)	O
;	O
}	O
if	O
(	O
!	O
err	O
)	O
{	O
*	O
addr_type	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
*	O
ports_type	*(int)
=	O
MACH_MSG_TYPE_MOVE_SEND	O
;	O
if	O
(	O
source_addr	*(struct)
)	O
{	O
*	O
addr	*(struct)
=	O
ports_get_right	()->(int)
(	O
source_addr	*(struct)
)	O
;	O
ports_port_deref	()->(int)
(	O
source_addr	*(struct)
)	O
;	O
}	O
else	O
*	O
addr	*(struct)
=	O
MACH_PORT_NULL	O
;	O
}	O
*	O
out_flags	*(int)
=	O
0	int
;	O
return	O
err	O
;	O
}	O
error_t	O
S_socket_getopt	(*(struct(struct,*(struct(int,union`,*`,*`,*`,int,int,int,int,*`,*`,*`,*`)))),int,int,*(*(char)),*(long))->(int)
(	O
struct	O
sock_user	struct(struct,*(struct))
*	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
int	O
level	int
,	O
int	O
opt	int
,	O
char	O
*	O
*	O
value	*(*(char))
,	O
size_t	long
*	O
value_len	*(long)
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
if	O
(	O
!	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
switch	O
(	O
level	int
)	O
{	O
case	O
SOL_SOCKET	int
:	O
switch	O
(	O
opt	int
)	O
{	O
case	O
SO_TYPE	int
:	O
if	O
(	O
*	O
value_len	*(long)
<	O
sizeof	O
(	O
int	O
)	O
)	O
{	O
ret	int
=	O
EINVAL	O
;	O
break	O
;	O
}	O
*	O
(	O
int	O
*	O
)	O
*	O
value	*(*(char))
=	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
->	O
pipe_class	*(struct)
->	O
sock_type	O
;	O
*	O
value_len	*(long)
=	O
sizeof	O
(	O
int	O
)	O
;	O
break	O
;	O
case	O
SO_ERROR	int
:	O
if	O
(	O
*	O
value_len	*(long)
<	O
sizeof	O
(	O
short	O
)	O
)	O
{	O
*	O
(	O
char	O
*	O
)	O
*	O
value	*(*(char))
=	O
0	int
;	O
*	O
value_len	*(long)
=	O
sizeof	O
(	O
char	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
value_len	*(long)
<	O
sizeof	O
(	O
int	O
)	O
)	O
{	O
*	O
(	O
short	O
*	O
)	O
*	O
value	*(*(char))
=	O
0	int
;	O
*	O
value_len	*(long)
=	O
sizeof	O
(	O
short	O
)	O
;	O
}	O
else	O
{	O
*	O
(	O
int	O
*	O
)	O
*	O
value	*(*(char))
=	O
0	int
;	O
*	O
value_len	*(long)
=	O
sizeof	O
(	O
int	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
ret	int
=	O
ENOPROTOOPT	O
;	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
ret	int
=	O
ENOPROTOOPT	O
;	O
break	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
ret	int
;	O
}	O
error_t	O
S_socket_setopt	(*(struct(struct,*(struct(int,union`,*`,*`,*`,int,int,int,int,*`,*`,*`,*`)))),int,int,*(char),long)->(int)
(	O
struct	O
sock_user	struct(struct,*(struct))
*	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
int	O
level	int
,	O
int	O
opt	int
,	O
char	O
*	O
value	*(*(char))
,	O
size_t	long
value_len	*(long)
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
if	O
(	O
!	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
switch	O
(	O
level	int
)	O
{	O
default	O
:	O
ret	int
=	O
ENOPROTOOPT	O
;	O
break	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
user	*(struct(struct,*(struct(int,union(struct`,array(char),long),*(struct`),*(struct`),*(struct`),int,int,int,int,*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sock	*(struct)
->	O
lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
ret	int
;	O
}	O
