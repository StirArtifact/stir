static	O
const	O
ctf_dmodel_t	O
_libctf_models	O
[	O
]	O
=	O
{	O
{	O
"ILP32"	*(char)
,	O
CTF_MODEL_ILP32	O
,	O
4	int
,	O
1	int
,	O
2	int
,	O
4	int
,	O
4	int
}	O
,	O
{	O
"LP64"	*(char)
,	O
CTF_MODEL_LP64	O
,	O
8	int
,	O
1	int
,	O
2	int
,	O
4	int
,	O
8	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
const	O
char	O
_CTF_SECTION	O
[	O
]	O
=	O
".ctf"	*(char)
;	O
const	O
char	O
_CTF_NULLSTR	O
[	O
]	O
=	O
""	*(char)
;	O
static	O
uint32_t	int
get_kind_v1	O
(	O
uint32_t	int
info	*(struct(long))
)	O
{	O
return	O
(	O
CTF_V1_INFO_KIND	O
(	O
info	*(struct(long))
)	O
)	O
;	O
}	O
static	O
uint32_t	int
get_root_v1	O
(	O
uint32_t	int
info	*(struct(long))
)	O
{	O
return	O
(	O
CTF_V1_INFO_ISROOT	O
(	O
info	*(struct(long))
)	O
)	O
;	O
}	O
static	O
uint32_t	int
get_vlen_v1	O
(	O
uint32_t	int
info	*(struct(long))
)	O
{	O
return	O
(	O
CTF_V1_INFO_VLEN	O
(	O
info	*(struct(long))
)	O
)	O
;	O
}	O
static	O
uint32_t	int
get_kind_v2	O
(	O
uint32_t	int
info	*(struct(long))
)	O
{	O
return	O
(	O
CTF_V2_INFO_KIND	O
(	O
info	*(struct(long))
)	O
)	O
;	O
}	O
static	O
uint32_t	int
get_root_v2	O
(	O
uint32_t	int
info	*(struct(long))
)	O
{	O
return	O
(	O
CTF_V2_INFO_ISROOT	O
(	O
info	*(struct(long))
)	O
)	O
;	O
}	O
static	O
uint32_t	int
get_vlen_v2	O
(	O
uint32_t	int
info	*(struct(long))
)	O
{	O
return	O
(	O
CTF_V2_INFO_VLEN	O
(	O
info	*(struct(long))
)	O
)	O
;	O
}	O
static	O
inline	O
ssize_t	long
get_ctt_size_common	O
(	O
const	O
ctf_file_t	struct
*	O
fp	*(struct)
_libctf_unused_	O
,	O
const	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
tp	O
_libctf_unused_	O
,	O
ssize_t	long
*	O
sizep	O
,	O
ssize_t	long
*	O
incrementp	O
,	O
size_t	long
lsize	O
,	O
size_t	long
csize	O
,	O
size_t	long
ctf_type_size	(*(struct),long)->(long)
,	O
size_t	long
ctf_stype_size	O
,	O
size_t	long
ctf_lsize_sent	O
)	O
{	O
ssize_t	long
size	long
,	O
increment	O
;	O
if	O
(	O
csize	O
==	O
ctf_lsize_sent	O
)	O
{	O
size	long
=	O
lsize	O
;	O
increment	O
=	O
ctf_type_size	(*(struct),long)->(long)
;	O
}	O
else	O
{	O
size	long
=	O
csize	O
;	O
increment	O
=	O
ctf_stype_size	O
;	O
}	O
if	O
(	O
sizep	O
)	O
*	O
sizep	O
=	O
size	long
;	O
if	O
(	O
incrementp	O
)	O
*	O
incrementp	O
=	O
increment	O
;	O
return	O
size	long
;	O
}	O
static	O
ssize_t	long
get_ctt_size_v1	O
(	O
const	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
tp	O
,	O
ssize_t	long
*	O
sizep	O
,	O
ssize_t	long
*	O
incrementp	O
)	O
{	O
ctf_type_v1_t	struct(int,short,union(short,short),int,int)
*	O
t1p	O
=	O
(	O
ctf_type_v1_t	struct(int,short,union(short,short),int,int)
*	O
)	O
tp	O
;	O
return	O
(	O
get_ctt_size_common	O
(	O
fp	*(struct)
,	O
tp	O
,	O
sizep	O
,	O
incrementp	O
,	O
CTF_TYPE_LSIZE	O
(	O
t1p	O
)	O
,	O
t1p	O
->	O
ctt_size	short
,	O
sizeof	O
(	O
ctf_type_v1_t	struct(int,short,union(short,short),int,int)
)	O
,	O
sizeof	O
(	O
ctf_stype_v1_t	O
)	O
,	O
CTF_LSIZE_SENT_V1	O
)	O
)	O
;	O
}	O
static	O
ssize_t	long
get_ctt_size_v2_unconverted	O
(	O
const	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
tp	O
,	O
ssize_t	long
*	O
sizep	O
,	O
ssize_t	long
*	O
incrementp	O
)	O
{	O
ctf_type_v1_t	struct(int,short,union(short,short),int,int)
*	O
t1p	O
=	O
(	O
ctf_type_v1_t	struct(int,short,union(short,short),int,int)
*	O
)	O
tp	O
;	O
return	O
(	O
get_ctt_size_common	O
(	O
fp	*(struct)
,	O
tp	O
,	O
sizep	O
,	O
incrementp	O
,	O
CTF_TYPE_LSIZE	O
(	O
t1p	O
)	O
,	O
t1p	O
->	O
ctt_size	short
,	O
sizeof	O
(	O
ctf_type_t	struct(int,int,union(int,int),int,int)
)	O
,	O
sizeof	O
(	O
ctf_stype_t	O
)	O
,	O
CTF_LSIZE_SENT	O
)	O
)	O
;	O
}	O
static	O
ssize_t	long
get_ctt_size_v2	O
(	O
const	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
tp	O
,	O
ssize_t	long
*	O
sizep	O
,	O
ssize_t	long
*	O
incrementp	O
)	O
{	O
return	O
(	O
get_ctt_size_common	O
(	O
fp	*(struct)
,	O
tp	O
,	O
sizep	O
,	O
incrementp	O
,	O
CTF_TYPE_LSIZE	O
(	O
tp	O
)	O
,	O
tp	O
->	O
ctt_size	short
,	O
sizeof	O
(	O
ctf_type_t	struct(int,int,union(int,int),int,int)
)	O
,	O
sizeof	O
(	O
ctf_stype_t	O
)	O
,	O
CTF_LSIZE_SENT	O
)	O
)	O
;	O
}	O
static	O
ssize_t	long
get_vbytes_common	O
(	O
unsigned	O
short	O
kind	O
,	O
ssize_t	long
size	long
_libctf_unused_	O
,	O
size_t	long
vlen	O
)	O
{	O
switch	O
(	O
kind	O
)	O
{	O
case	O
CTF_K_INTEGER	O
:	O
case	O
CTF_K_FLOAT	O
:	O
return	O
(	O
sizeof	O
(	O
uint32_t	int
)	O
)	O
;	O
case	O
CTF_K_SLICE	O
:	O
return	O
(	O
sizeof	O
(	O
ctf_slice_t	struct(int,short,short)
)	O
)	O
;	O
case	O
CTF_K_ENUM	O
:	O
return	O
(	O
sizeof	O
(	O
ctf_enum_t	struct(int,int)
)	O
*	O
vlen	O
)	O
;	O
case	O
CTF_K_FORWARD	O
:	O
case	O
CTF_K_UNKNOWN	O
:	O
case	O
CTF_K_POINTER	O
:	O
case	O
CTF_K_TYPEDEF	O
:	O
case	O
CTF_K_VOLATILE	O
:	O
case	O
CTF_K_CONST	O
:	O
case	O
CTF_K_RESTRICT	O
:	O
return	O
0	int
;	O
default	O
:	O
ctf_dprintf	O
(	O
"detected invalid CTF kind -- %x\n"	*(char)
,	O
kind	O
)	O
;	O
return	O
ECTF_CORRUPT	int
;	O
}	O
}	O
static	O
ssize_t	long
get_vbytes_v1	O
(	O
unsigned	O
short	O
kind	O
,	O
ssize_t	long
size	long
,	O
size_t	long
vlen	O
)	O
{	O
switch	O
(	O
kind	O
)	O
{	O
case	O
CTF_K_ARRAY	O
:	O
return	O
(	O
sizeof	O
(	O
ctf_array_v1_t	struct(short,short,int)
)	O
)	O
;	O
case	O
CTF_K_FUNCTION	O
:	O
return	O
(	O
sizeof	O
(	O
unsigned	O
short	O
)	O
*	O
(	O
vlen	O
+	O
(	O
vlen	O
&	O
1	int
)	O
)	O
)	O
;	O
case	O
CTF_K_STRUCT	O
:	O
case	O
CTF_K_UNION	O
:	O
if	O
(	O
size	long
<	O
CTF_LSTRUCT_THRESH_V1	O
)	O
return	O
(	O
sizeof	O
(	O
ctf_member_v1_t	struct(int,short,short)
)	O
*	O
vlen	O
)	O
;	O
else	O
return	O
(	O
sizeof	O
(	O
ctf_lmember_v1_t	struct(int,short,short,int,int)
)	O
*	O
vlen	O
)	O
;	O
}	O
return	O
(	O
get_vbytes_common	O
(	O
kind	O
,	O
size	long
,	O
vlen	O
)	O
)	O
;	O
}	O
static	O
ssize_t	long
get_vbytes_v2	O
(	O
unsigned	O
short	O
kind	O
,	O
ssize_t	long
size	long
,	O
size_t	long
vlen	O
)	O
{	O
switch	O
(	O
kind	O
)	O
{	O
case	O
CTF_K_ARRAY	O
:	O
return	O
(	O
sizeof	O
(	O
ctf_array_t	struct(int,int,int)
)	O
)	O
;	O
case	O
CTF_K_FUNCTION	O
:	O
return	O
(	O
sizeof	O
(	O
uint32_t	int
)	O
*	O
(	O
vlen	O
+	O
(	O
vlen	O
&	O
1	int
)	O
)	O
)	O
;	O
case	O
CTF_K_STRUCT	O
:	O
case	O
CTF_K_UNION	O
:	O
if	O
(	O
size	long
<	O
CTF_LSTRUCT_THRESH	O
)	O
return	O
(	O
sizeof	O
(	O
ctf_member_t	struct(int,int,int)
)	O
*	O
vlen	O
)	O
;	O
else	O
return	O
(	O
sizeof	O
(	O
ctf_lmember_t	struct(int,int,int,int)
)	O
*	O
vlen	O
)	O
;	O
}	O
return	O
(	O
get_vbytes_common	O
(	O
kind	O
,	O
size	long
,	O
vlen	O
)	O
)	O
;	O
}	O
static	O
const	O
ctf_fileops_t	O
ctf_fileops	O
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
get_kind_v1	O
,	O
get_root_v1	O
,	O
get_vlen_v1	O
,	O
get_ctt_size_v1	O
,	O
get_vbytes_v1	O
}	O
,	O
{	O
get_kind_v2	O
,	O
get_root_v2	O
,	O
get_vlen_v2	O
,	O
get_ctt_size_v2	O
,	O
get_vbytes_v2	O
}	O
,	O
{	O
get_kind_v2	O
,	O
get_root_v2	O
,	O
get_vlen_v2	O
,	O
get_ctt_size_v2	O
,	O
get_vbytes_v2	O
}	O
,	O
{	O
get_kind_v2	O
,	O
get_root_v2	O
,	O
get_vlen_v2	O
,	O
get_ctt_size_v2	O
,	O
get_vbytes_v2	O
}	O
,	O
}	O
;	O
static	O
int	O
init_symtab	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
*	O
hp	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
sp	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
strp	O
)	O
{	O
const	O
unsigned	O
char	O
*	O
symp	O
=	O
sp	O
->	O
cts_data	*(void)
;	O
uint32_t	int
*	O
xp	O
=	O
fp	*(struct)
->	O
ctf_sxlate	O
;	O
uint32_t	int
*	O
xend	O
=	O
xp	O
+	O
fp	*(struct)
->	O
ctf_nsyms	O
;	O
uint32_t	int
objtoff	O
=	O
hp	O
->	O
cth_objtoff	int
;	O
uint32_t	int
funcoff	O
=	O
hp	O
->	O
cth_funcoff	int
;	O
uint32_t	int
info	*(struct(long))
,	O
vlen	O
;	O
Elf64_Sym	struct(int,char,char,short,long,long)
sym	*(struct)
,	O
*	O
gsp	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
for	O
(	O
;	O
xp	O
<	O
xend	O
;	O
xp	O
++	O
,	O
symp	O
+=	O
sp	O
->	O
cts_entsize	long
)	O
{	O
if	O
(	O
sp	O
->	O
cts_entsize	long
==	O
sizeof	O
(	O
Elf32_Sym	struct(int,int,int,char,char,short)
)	O
)	O
gsp	O
=	O
ctf_sym_to_elf64	O
(	O
(	O
Elf32_Sym	struct(int,int,int,char,char,short)
*	O
)	O
(	O
uintptr_t	long
)	O
symp	O
,	O
&	O
sym	*(struct)
)	O
;	O
else	O
gsp	O
=	O
(	O
Elf64_Sym	struct(int,char,char,short,long,long)
*	O
)	O
(	O
uintptr_t	long
)	O
symp	O
;	O
if	O
(	O
gsp	O
->	O
st_name	*(char)
<	O
strp	O
->	O
cts_size	long
)	O
name	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
strp	O
->	O
cts_data	*(void)
+	O
gsp	O
->	O
st_name	*(char)
;	O
else	O
name	*(char)
=	O
_CTF_NULLSTR	O
;	O
if	O
(	O
gsp	O
->	O
st_name	*(char)
==	O
0	int
||	O
gsp	O
->	O
st_shndx	int
==	O
SHN_UNDEF	O
||	O
strcmp	O
(	O
name	*(char)
,	O
"_START_"	*(char)
)	O
==	O
0	int
||	O
strcmp	O
(	O
name	*(char)
,	O
"_END_"	*(char)
)	O
==	O
0	int
)	O
{	O
*	O
xp	O
=	O
-	O
1u	int
;	O
continue	O
;	O
}	O
switch	O
(	O
ELF64_ST_TYPE	O
(	O
gsp	O
->	O
st_info	array(char)
)	O
)	O
{	O
case	O
STT_OBJECT	O
:	O
if	O
(	O
objtoff	O
>=	O
hp	O
->	O
cth_funcoff	int
||	O
(	O
gsp	O
->	O
st_shndx	int
==	O
SHN_EXTABS	O
&&	O
gsp	O
->	O
st_value	int
==	O
0	int
)	O
)	O
{	O
*	O
xp	O
=	O
-	O
1u	int
;	O
break	O
;	O
}	O
*	O
xp	O
=	O
objtoff	O
;	O
objtoff	O
+=	O
sizeof	O
(	O
uint32_t	int
)	O
;	O
break	O
;	O
case	O
STT_FUNC	O
:	O
if	O
(	O
funcoff	O
>=	O
hp	O
->	O
cth_objtidxoff	int
)	O
{	O
*	O
xp	O
=	O
-	O
1u	int
;	O
break	O
;	O
}	O
*	O
xp	O
=	O
funcoff	O
;	O
info	*(struct(long))
=	O
*	O
(	O
uint32_t	int
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
fp	*(struct)
->	O
ctf_buf	O
+	O
funcoff	O
)	O
;	O
vlen	O
=	O
LCTF_INFO_VLEN	O
(	O
fp	*(struct)
,	O
info	*(struct(long))
)	O
;	O
if	O
(	O
LCTF_INFO_KIND	O
(	O
fp	*(struct)
,	O
info	*(struct(long))
)	O
==	O
CTF_K_UNKNOWN	O
&&	O
vlen	O
==	O
0	int
)	O
funcoff	O
+=	O
sizeof	O
(	O
uint32_t	int
)	O
;	O
else	O
funcoff	O
+=	O
sizeof	O
(	O
uint32_t	int
)	O
*	O
(	O
vlen	O
+	O
2	int
)	O
;	O
break	O
;	O
default	O
:	O
*	O
xp	O
=	O
-	O
1u	int
;	O
break	O
;	O
}	O
}	O
ctf_dprintf	O
(	O
"loaded %lu symtab entries\n"	*(char)
,	O
fp	*(struct)
->	O
ctf_nsyms	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
ctf_set_base	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
*	O
hp	O
,	O
unsigned	O
char	O
*	O
base	*(void)
)	O
{	O
fp	*(struct)
->	O
ctf_buf	O
=	O
base	*(void)
+	O
(	O
fp	*(struct)
->	O
ctf_buf	O
-	O
fp	*(struct)
->	O
ctf_base	O
)	O
;	O
fp	*(struct)
->	O
ctf_base	O
=	O
base	*(void)
;	O
fp	*(struct)
->	O
ctf_vars	O
=	O
(	O
ctf_varent_t	struct(int,int)
*	O
)	O
(	O
(	O
const	O
char	O
*	O
)	O
fp	*(struct)
->	O
ctf_buf	O
+	O
hp	O
->	O
cth_varoff	int
)	O
;	O
fp	*(struct)
->	O
ctf_nvars	O
=	O
(	O
hp	O
->	O
cth_typeoff	int
-	O
hp	O
->	O
cth_varoff	int
)	O
/	O
sizeof	O
(	O
ctf_varent_t	struct(int,int)
)	O
;	O
fp	*(struct)
->	O
ctf_str	O
[	O
CTF_STRTAB_0	O
]	O
.	O
cts_strs	O
=	O
(	O
const	O
char	O
*	O
)	O
fp	*(struct)
->	O
ctf_buf	O
+	O
hp	O
->	O
cth_stroff	int
;	O
fp	*(struct)
->	O
ctf_str	O
[	O
CTF_STRTAB_0	O
]	O
.	O
cts_len	O
=	O
hp	O
->	O
cth_strlen	int
;	O
if	O
(	O
hp	O
->	O
cth_parlabel	int
!=	O
0	int
)	O
fp	*(struct)
->	O
ctf_parlabel	O
=	O
ctf_strptr	O
(	O
fp	*(struct)
,	O
hp	O
->	O
cth_parlabel	int
)	O
;	O
if	O
(	O
hp	O
->	O
cth_parname	int
!=	O
0	int
)	O
fp	*(struct)
->	O
ctf_parname	O
=	O
ctf_strptr	O
(	O
fp	*(struct)
,	O
hp	O
->	O
cth_parname	int
)	O
;	O
if	O
(	O
hp	O
->	O
cth_cuname	int
!=	O
0	int
)	O
fp	*(struct)
->	O
ctf_cuname	(*(struct))->(*(char))
=	O
ctf_strptr	O
(	O
fp	*(struct)
,	O
hp	O
->	O
cth_cuname	int
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_cuname	(*(struct))->(*(char))
)	O
ctf_dprintf	O
(	O
"ctf_set_base: CU name %s\n"	*(char)
,	O
fp	*(struct)
->	O
ctf_cuname	(*(struct))->(*(char))
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_parname	O
)	O
ctf_dprintf	O
(	O
"ctf_set_base: parent name %s (label %s)\n"	*(char)
,	O
fp	*(struct)
->	O
ctf_parname	O
,	O
fp	*(struct)
->	O
ctf_parlabel	O
?	O
fp	*(struct)
->	O
ctf_parlabel	O
:	O
"<NULL>"	*(char)
)	O
;	O
}	O
static	O
void	O
ctf_set_version	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
*	O
cth	O
,	O
int	O
ctf_version	(int)->(int)
)	O
{	O
fp	*(struct)
->	O
ctf_version	(int)->(int)
=	O
ctf_version	(int)->(int)
;	O
cth	O
->	O
cth_version	O
=	O
ctf_version	(int)->(int)
;	O
fp	*(struct)
->	O
ctf_fileops	O
=	O
&	O
ctf_fileops	O
[	O
ctf_version	(int)->(int)
]	O
;	O
}	O
static	O
void	O
upgrade_header	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
*	O
hp	O
)	O
{	O
ctf_header_v2_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int)
*	O
oldhp	O
=	O
(	O
ctf_header_v2_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int)
*	O
)	O
hp	O
;	O
hp	O
->	O
cth_strlen	int
=	O
oldhp	O
->	O
cth_strlen	int
;	O
hp	O
->	O
cth_stroff	int
=	O
oldhp	O
->	O
cth_stroff	int
;	O
hp	O
->	O
cth_typeoff	int
=	O
oldhp	O
->	O
cth_typeoff	int
;	O
hp	O
->	O
cth_varoff	int
=	O
oldhp	O
->	O
cth_varoff	int
;	O
hp	O
->	O
cth_funcidxoff	int
=	O
hp	O
->	O
cth_varoff	int
;	O
hp	O
->	O
cth_objtidxoff	int
=	O
hp	O
->	O
cth_funcidxoff	int
;	O
hp	O
->	O
cth_funcoff	int
=	O
oldhp	O
->	O
cth_funcoff	int
;	O
hp	O
->	O
cth_objtoff	int
=	O
oldhp	O
->	O
cth_objtoff	int
;	O
hp	O
->	O
cth_lbloff	int
=	O
oldhp	O
->	O
cth_lbloff	int
;	O
hp	O
->	O
cth_cuname	int
=	O
0	int
;	O
}	O
static	O
int	O
upgrade_types_v1	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
*	O
cth	O
)	O
{	O
const	O
ctf_type_v1_t	struct(int,short,union(short,short),int,int)
*	O
tbuf	O
;	O
const	O
ctf_type_v1_t	struct(int,short,union(short,short),int,int)
*	O
tend	O
;	O
unsigned	O
char	O
*	O
ctf_base	O
,	O
*	O
old_ctf_base	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
fp	*(struct)
->	O
ctf_dynbase	O
;	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
t2buf	O
;	O
ssize_t	long
increase	O
=	O
0	int
,	O
size	long
,	O
increment	O
,	O
v2increment	O
,	O
vbytes	O
,	O
v2bytes	O
;	O
const	O
ctf_type_v1_t	struct(int,short,union(short,short),int,int)
*	O
tp	O
;	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
t2p	O
;	O
tbuf	O
=	O
(	O
ctf_type_v1_t	struct(int,short,union(short,short),int,int)
*	O
)	O
(	O
fp	*(struct)
->	O
ctf_buf	O
+	O
cth	O
->	O
cth_typeoff	int
)	O
;	O
tend	O
=	O
(	O
ctf_type_v1_t	struct(int,short,union(short,short),int,int)
*	O
)	O
(	O
fp	*(struct)
->	O
ctf_buf	O
+	O
cth	O
->	O
cth_stroff	int
)	O
;	O
for	O
(	O
tp	O
=	O
tbuf	O
;	O
tp	O
<	O
tend	O
;	O
tp	O
=	O
(	O
ctf_type_v1_t	struct(int,short,union(short,short),int,int)
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
tp	O
+	O
increment	O
+	O
vbytes	O
)	O
)	O
{	O
unsigned	O
short	O
kind	O
=	O
CTF_V1_INFO_KIND	O
(	O
tp	O
->	O
ctt_info	short
)	O
;	O
unsigned	O
long	O
vlen	O
=	O
CTF_V1_INFO_VLEN	O
(	O
tp	O
->	O
ctt_info	short
)	O
;	O
size	long
=	O
get_ctt_size_v1	O
(	O
fp	*(struct)
,	O
(	O
const	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
)	O
tp	O
,	O
NULL	O
,	O
&	O
increment	O
)	O
;	O
vbytes	O
=	O
get_vbytes_v1	O
(	O
kind	O
,	O
size	long
,	O
vlen	O
)	O
;	O
get_ctt_size_v2_unconverted	O
(	O
fp	*(struct)
,	O
(	O
const	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
)	O
tp	O
,	O
NULL	O
,	O
&	O
v2increment	O
)	O
;	O
v2bytes	O
=	O
get_vbytes_v2	O
(	O
kind	O
,	O
size	long
,	O
vlen	O
)	O
;	O
if	O
(	O
(	O
vbytes	O
<	O
0	int
)	O
||	O
(	O
size	long
<	O
0	int
)	O
)	O
return	O
ECTF_CORRUPT	int
;	O
increase	O
+=	O
v2increment	O
-	O
increment	O
;	O
increase	O
+=	O
v2bytes	O
-	O
vbytes	O
;	O
}	O
if	O
(	O
(	O
ctf_base	O
=	O
malloc	(long)->(*(void))
(	O
fp	*(struct)
->	O
ctf_size	O
+	O
increase	O
)	O
)	O
==	O
NULL	O
)	O
return	O
ECTF_ZALLOC	int
;	O
memcpy	O
(	O
ctf_base	O
,	O
fp	*(struct)
->	O
ctf_buf	O
,	O
cth	O
->	O
cth_typeoff	int
)	O
;	O
memcpy	O
(	O
ctf_base	O
+	O
cth	O
->	O
cth_stroff	int
+	O
increase	O
,	O
fp	*(struct)
->	O
ctf_buf	O
+	O
cth	O
->	O
cth_stroff	int
,	O
cth	O
->	O
cth_strlen	int
)	O
;	O
memset	O
(	O
ctf_base	O
+	O
cth	O
->	O
cth_typeoff	int
,	O
0	int
,	O
cth	O
->	O
cth_stroff	int
-	O
cth	O
->	O
cth_typeoff	int
+	O
increase	O
)	O
;	O
cth	O
->	O
cth_stroff	int
+=	O
increase	O
;	O
fp	*(struct)
->	O
ctf_size	O
+=	O
increase	O
;	O
assert	O
(	O
cth	O
->	O
cth_stroff	int
>=	O
cth	O
->	O
cth_typeoff	int
)	O
;	O
fp	*(struct)
->	O
ctf_base	O
=	O
ctf_base	O
;	O
fp	*(struct)
->	O
ctf_buf	O
=	O
ctf_base	O
;	O
fp	*(struct)
->	O
ctf_dynbase	O
=	O
ctf_base	O
;	O
ctf_set_base	O
(	O
fp	*(struct)
,	O
cth	O
,	O
ctf_base	O
)	O
;	O
t2buf	O
=	O
(	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
)	O
(	O
fp	*(struct)
->	O
ctf_buf	O
+	O
cth	O
->	O
cth_typeoff	int
)	O
;	O
for	O
(	O
tp	O
=	O
tbuf	O
,	O
t2p	O
=	O
t2buf	O
;	O
tp	O
<	O
tend	O
;	O
tp	O
=	O
(	O
ctf_type_v1_t	struct(int,short,union(short,short),int,int)
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
tp	O
+	O
increment	O
+	O
vbytes	O
)	O
,	O
t2p	O
=	O
(	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
t2p	O
+	O
v2increment	O
+	O
v2bytes	O
)	O
)	O
{	O
unsigned	O
short	O
kind	O
=	O
CTF_V1_INFO_KIND	O
(	O
tp	O
->	O
ctt_info	short
)	O
;	O
int	O
isroot	O
=	O
CTF_V1_INFO_ISROOT	O
(	O
tp	O
->	O
ctt_info	short
)	O
;	O
unsigned	O
long	O
vlen	O
=	O
CTF_V1_INFO_VLEN	O
(	O
tp	O
->	O
ctt_info	short
)	O
;	O
ssize_t	long
v2size	O
;	O
void	O
*	O
vdata	O
,	O
*	O
v2data	O
;	O
size	long
=	O
get_ctt_size_v1	O
(	O
fp	*(struct)
,	O
(	O
const	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
)	O
tp	O
,	O
NULL	O
,	O
&	O
increment	O
)	O
;	O
vbytes	O
=	O
get_vbytes_v1	O
(	O
kind	O
,	O
size	long
,	O
vlen	O
)	O
;	O
t2p	O
->	O
ctt_name	int
=	O
tp	O
->	O
ctt_name	int
;	O
t2p	O
->	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
kind	O
,	O
isroot	O
,	O
vlen	O
)	O
;	O
switch	O
(	O
kind	O
)	O
{	O
case	O
CTF_K_FUNCTION	O
:	O
case	O
CTF_K_FORWARD	O
:	O
case	O
CTF_K_TYPEDEF	O
:	O
case	O
CTF_K_POINTER	O
:	O
case	O
CTF_K_VOLATILE	O
:	O
case	O
CTF_K_CONST	O
:	O
case	O
CTF_K_RESTRICT	O
:	O
t2p	O
->	O
ctt_type	short
=	O
tp	O
->	O
ctt_type	short
;	O
break	O
;	O
case	O
CTF_K_INTEGER	O
:	O
case	O
CTF_K_FLOAT	O
:	O
case	O
CTF_K_ARRAY	O
:	O
case	O
CTF_K_STRUCT	O
:	O
case	O
CTF_K_UNION	O
:	O
case	O
CTF_K_ENUM	O
:	O
case	O
CTF_K_UNKNOWN	O
:	O
if	O
(	O
(	O
size_t	long
)	O
size	long
<=	O
CTF_MAX_SIZE	O
)	O
t2p	O
->	O
ctt_size	short
=	O
size	long
;	O
else	O
{	O
t2p	O
->	O
ctt_lsizehi	O
=	O
CTF_SIZE_TO_LSIZE_HI	O
(	O
size	long
)	O
;	O
t2p	O
->	O
ctt_lsizelo	int
=	O
CTF_SIZE_TO_LSIZE_LO	O
(	O
size	long
)	O
;	O
}	O
break	O
;	O
}	O
v2size	O
=	O
get_ctt_size_v2	O
(	O
fp	*(struct)
,	O
t2p	O
,	O
NULL	O
,	O
&	O
v2increment	O
)	O
;	O
v2bytes	O
=	O
get_vbytes_v2	O
(	O
kind	O
,	O
v2size	O
,	O
vlen	O
)	O
;	O
assert	O
(	O
size	long
==	O
v2size	O
)	O
;	O
vdata	O
=	O
(	O
void	O
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
tp	O
+	O
increment	O
)	O
;	O
v2data	O
=	O
(	O
void	O
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
t2p	O
+	O
v2increment	O
)	O
;	O
switch	O
(	O
kind	O
)	O
{	O
case	O
CTF_K_ARRAY	O
:	O
{	O
const	O
ctf_array_v1_t	struct(short,short,int)
*	O
ap	O
=	O
(	O
const	O
ctf_array_v1_t	struct(short,short,int)
*	O
)	O
vdata	O
;	O
ctf_array_t	struct(int,int,int)
*	O
a2p	O
=	O
(	O
ctf_array_t	struct(int,int,int)
*	O
)	O
v2data	O
;	O
a2p	O
->	O
cta_contents	short
=	O
ap	O
->	O
cta_contents	short
;	O
a2p	O
->	O
cta_index	short
=	O
ap	O
->	O
cta_index	short
;	O
a2p	O
->	O
cta_nelems	int
=	O
ap	O
->	O
cta_nelems	int
;	O
break	O
;	O
}	O
case	O
CTF_K_STRUCT	O
:	O
case	O
CTF_K_UNION	O
:	O
{	O
ctf_member_t	struct(int,int,int)
tmp	O
;	O
const	O
ctf_member_v1_t	struct(int,short,short)
*	O
m1	O
=	O
(	O
const	O
ctf_member_v1_t	struct(int,short,short)
*	O
)	O
vdata	O
;	O
const	O
ctf_lmember_v1_t	struct(int,short,short,int,int)
*	O
lm1	O
=	O
(	O
const	O
ctf_lmember_v1_t	struct(int,short,short,int,int)
*	O
)	O
m1	O
;	O
ctf_member_t	struct(int,int,int)
*	O
m2	O
=	O
(	O
ctf_member_t	struct(int,int,int)
*	O
)	O
v2data	O
;	O
ctf_lmember_t	struct(int,int,int,int)
*	O
lm2	O
=	O
(	O
ctf_lmember_t	struct(int,int,int,int)
*	O
)	O
m2	O
;	O
unsigned	O
long	O
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
vlen	O
;	O
i	*(struct)
!=	O
0	int
;	O
i	*(struct)
--	O
,	O
m1	O
++	O
,	O
lm1	O
++	O
,	O
m2	O
++	O
,	O
lm2	O
++	O
)	O
{	O
size_t	long
offset	long
;	O
if	O
(	O
size	long
<	O
CTF_LSTRUCT_THRESH_V1	O
)	O
{	O
offset	long
=	O
m1	O
->	O
ctm_offset	short
;	O
tmp	O
.	O
ctm_name	int
=	O
m1	O
->	O
ctm_name	int
;	O
tmp	O
.	O
ctm_type	short
=	O
m1	O
->	O
ctm_type	short
;	O
}	O
else	O
{	O
offset	long
=	O
CTF_LMEM_OFFSET	O
(	O
lm1	O
)	O
;	O
tmp	O
.	O
ctm_name	int
=	O
lm1	O
->	O
ctlm_name	int
;	O
tmp	O
.	O
ctm_type	short
=	O
lm1	O
->	O
ctlm_type	short
;	O
}	O
if	O
(	O
size	long
<	O
CTF_LSTRUCT_THRESH	O
)	O
{	O
m2	O
->	O
ctm_name	int
=	O
tmp	O
.	O
ctm_name	int
;	O
m2	O
->	O
ctm_type	short
=	O
tmp	O
.	O
ctm_type	short
;	O
m2	O
->	O
ctm_offset	short
=	O
offset	long
;	O
}	O
else	O
{	O
lm2	O
->	O
ctlm_name	int
=	O
tmp	O
.	O
ctm_name	int
;	O
lm2	O
->	O
ctlm_type	short
=	O
tmp	O
.	O
ctm_type	short
;	O
lm2	O
->	O
ctlm_offsethi	int
=	O
CTF_OFFSET_TO_LMEMHI	O
(	O
offset	long
)	O
;	O
lm2	O
->	O
ctlm_offsetlo	int
=	O
CTF_OFFSET_TO_LMEMLO	O
(	O
offset	long
)	O
;	O
}	O
}	O
break	O
;	O
}	O
case	O
CTF_K_FUNCTION	O
:	O
{	O
unsigned	O
long	O
i	*(struct)
;	O
unsigned	O
short	O
*	O
a1	O
=	O
(	O
unsigned	O
short	O
*	O
)	O
vdata	O
;	O
uint32_t	int
*	O
a2	O
=	O
(	O
uint32_t	int
*	O
)	O
v2data	O
;	O
for	O
(	O
i	*(struct)
=	O
vlen	O
;	O
i	*(struct)
!=	O
0	int
;	O
i	*(struct)
--	O
,	O
a1	O
++	O
,	O
a2	O
++	O
)	O
*	O
a2	O
=	O
*	O
a1	O
;	O
}	O
default	O
:	O
assert	O
(	O
vbytes	O
==	O
v2bytes	O
)	O
;	O
memcpy	O
(	O
v2data	O
,	O
vdata	O
,	O
vbytes	O
)	O
;	O
}	O
}	O
assert	O
(	O
(	O
size_t	long
)	O
t2p	O
-	O
(	O
size_t	long
)	O
fp	*(struct)
->	O
ctf_buf	O
==	O
cth	O
->	O
cth_stroff	int
)	O
;	O
ctf_set_version	O
(	O
fp	*(struct)
,	O
cth	O
,	O
CTF_VERSION_1_UPGRADED_3	O
)	O
;	O
free	(*(void))->(void)
(	O
old_ctf_base	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
upgrade_types	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
*	O
cth	O
)	O
{	O
switch	O
(	O
cth	O
->	O
cth_version	O
)	O
{	O
case	O
CTF_VERSION_1	O
:	O
upgrade_types_v1	O
(	O
fp	*(struct)
,	O
cth	O
)	O
;	O
case	O
CTF_VERSION_1_UPGRADED_3	O
:	O
fp	*(struct)
->	O
ctf_parmax	O
=	O
CTF_MAX_PTYPE_V1	O
;	O
case	O
CTF_VERSION_2	O
:	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
init_types	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
*	O
cth	O
)	O
{	O
const	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
tbuf	O
;	O
const	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
tend	O
;	O
unsigned	O
long	O
pop	O
[	O
CTF_K_MAX	O
+	O
1	int
]	O
=	O
{	O
0	int
}	O
;	O
const	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
tp	O
;	O
uint32_t	int
id	int
,	O
dst	O
;	O
uint32_t	int
*	O
xp	O
;	O
int	O
child	O
=	O
cth	O
->	O
cth_parname	int
!=	O
0	int
;	O
int	O
nlstructs	O
=	O
0	int
,	O
nlunions	O
=	O
0	int
;	O
int	O
err	long
;	O
assert	O
(	O
!	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_RDWR	O
)	O
)	O
;	O
if	O
(	O
_libctf_unlikely_	O
(	O
fp	*(struct)
->	O
ctf_version	(int)->(int)
==	O
CTF_VERSION_1	O
)	O
)	O
{	O
int	O
err	long
;	O
if	O
(	O
(	O
err	long
=	O
upgrade_types	O
(	O
fp	*(struct)
,	O
cth	O
)	O
)	O
!=	O
0	int
)	O
return	O
err	long
;	O
}	O
tbuf	O
=	O
(	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
)	O
(	O
fp	*(struct)
->	O
ctf_buf	O
+	O
cth	O
->	O
cth_typeoff	int
)	O
;	O
tend	O
=	O
(	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
)	O
(	O
fp	*(struct)
->	O
ctf_buf	O
+	O
cth	O
->	O
cth_stroff	int
)	O
;	O
for	O
(	O
tp	O
=	O
tbuf	O
;	O
tp	O
<	O
tend	O
;	O
fp	*(struct)
->	O
ctf_typemax	O
++	O
)	O
{	O
unsigned	O
short	O
kind	O
=	O
LCTF_INFO_KIND	O
(	O
fp	*(struct)
,	O
tp	O
->	O
ctt_info	short
)	O
;	O
unsigned	O
long	O
vlen	O
=	O
LCTF_INFO_VLEN	O
(	O
fp	*(struct)
,	O
tp	O
->	O
ctt_info	short
)	O
;	O
ssize_t	long
size	long
,	O
increment	O
,	O
vbytes	O
;	O
(	O
void	O
)	O
ctf_get_ctt_size	O
(	O
fp	*(struct)
,	O
tp	O
,	O
&	O
size	long
,	O
&	O
increment	O
)	O
;	O
vbytes	O
=	O
LCTF_VBYTES	O
(	O
fp	*(struct)
,	O
kind	O
,	O
size	long
,	O
vlen	O
)	O
;	O
if	O
(	O
vbytes	O
<	O
0	int
)	O
return	O
ECTF_CORRUPT	int
;	O
if	O
(	O
kind	O
==	O
CTF_K_FORWARD	O
)	O
{	O
if	O
(	O
tp	O
->	O
ctt_type	short
==	O
CTF_K_UNKNOWN	O
||	O
tp	O
->	O
ctt_type	short
>=	O
CTF_K_MAX	O
)	O
pop	O
[	O
CTF_K_STRUCT	O
]	O
++	O
;	O
else	O
pop	O
[	O
tp	O
->	O
ctt_type	short
]	O
++	O
;	O
}	O
tp	O
=	O
(	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
tp	O
+	O
increment	O
+	O
vbytes	O
)	O
;	O
pop	O
[	O
kind	O
]	O
++	O
;	O
}	O
if	O
(	O
child	O
)	O
{	O
ctf_dprintf	O
(	O
"CTF container %p is a child\n"	*(char)
,	O
(	O
void	O
*	O
)	O
fp	*(struct)
)	O
;	O
fp	*(struct)
->	O
ctf_flags	O
|=	O
LCTF_CHILD	O
;	O
}	O
else	O
ctf_dprintf	O
(	O
"CTF container %p is a parent\n"	*(char)
,	O
(	O
void	O
*	O
)	O
fp	*(struct)
)	O
;	O
if	O
(	O
(	O
fp	*(struct)
->	O
ctf_structs	O
.	O
ctn_readonly	O
=	O
ctf_hash_create	O
(	O
pop	O
[	O
CTF_K_STRUCT	O
]	O
,	O
ctf_hash_string	O
,	O
ctf_hash_eq_string	O
)	O
)	O
==	O
NULL	O
)	O
return	O
ENOMEM	O
;	O
if	O
(	O
(	O
fp	*(struct)
->	O
ctf_unions	O
.	O
ctn_readonly	O
=	O
ctf_hash_create	O
(	O
pop	O
[	O
CTF_K_UNION	O
]	O
,	O
ctf_hash_string	O
,	O
ctf_hash_eq_string	O
)	O
)	O
==	O
NULL	O
)	O
return	O
ENOMEM	O
;	O
if	O
(	O
(	O
fp	*(struct)
->	O
ctf_enums	O
.	O
ctn_readonly	O
=	O
ctf_hash_create	O
(	O
pop	O
[	O
CTF_K_ENUM	O
]	O
,	O
ctf_hash_string	O
,	O
ctf_hash_eq_string	O
)	O
)	O
==	O
NULL	O
)	O
return	O
ENOMEM	O
;	O
if	O
(	O
(	O
fp	*(struct)
->	O
ctf_names	O
.	O
ctn_readonly	O
=	O
ctf_hash_create	O
(	O
pop	O
[	O
CTF_K_INTEGER	O
]	O
+	O
pop	O
[	O
CTF_K_FLOAT	O
]	O
+	O
pop	O
[	O
CTF_K_FUNCTION	O
]	O
+	O
pop	O
[	O
CTF_K_TYPEDEF	O
]	O
+	O
pop	O
[	O
CTF_K_POINTER	O
]	O
+	O
pop	O
[	O
CTF_K_VOLATILE	O
]	O
+	O
pop	O
[	O
CTF_K_CONST	O
]	O
+	O
pop	O
[	O
CTF_K_RESTRICT	O
]	O
,	O
ctf_hash_string	O
,	O
ctf_hash_eq_string	O
)	O
)	O
==	O
NULL	O
)	O
return	O
ENOMEM	O
;	O
fp	*(struct)
->	O
ctf_txlate	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
uint32_t	int
)	O
*	O
(	O
fp	*(struct)
->	O
ctf_typemax	O
+	O
1	int
)	O
)	O
;	O
fp	*(struct)
->	O
ctf_ptrtab_len	O
=	O
fp	*(struct)
->	O
ctf_typemax	O
+	O
1	int
;	O
fp	*(struct)
->	O
ctf_ptrtab	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
uint32_t	int
)	O
*	O
fp	*(struct)
->	O
ctf_ptrtab_len	O
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_txlate	O
==	O
NULL	O
||	O
fp	*(struct)
->	O
ctf_ptrtab	O
==	O
NULL	O
)	O
return	O
ENOMEM	O
;	O
xp	O
=	O
fp	*(struct)
->	O
ctf_txlate	O
;	O
*	O
xp	O
++	O
=	O
0	int
;	O
memset	O
(	O
fp	*(struct)
->	O
ctf_txlate	O
,	O
0	int
,	O
sizeof	O
(	O
uint32_t	int
)	O
*	O
(	O
fp	*(struct)
->	O
ctf_typemax	O
+	O
1	int
)	O
)	O
;	O
memset	O
(	O
fp	*(struct)
->	O
ctf_ptrtab	O
,	O
0	int
,	O
sizeof	O
(	O
uint32_t	int
)	O
*	O
(	O
fp	*(struct)
->	O
ctf_typemax	O
+	O
1	int
)	O
)	O
;	O
for	O
(	O
id	int
=	O
1	int
,	O
tp	O
=	O
tbuf	O
;	O
tp	O
<	O
tend	O
;	O
xp	O
++	O
,	O
id	int
++	O
)	O
{	O
unsigned	O
short	O
kind	O
=	O
LCTF_INFO_KIND	O
(	O
fp	*(struct)
,	O
tp	O
->	O
ctt_info	short
)	O
;	O
unsigned	O
short	O
flag	int
=	O
LCTF_INFO_ISROOT	O
(	O
fp	*(struct)
,	O
tp	O
->	O
ctt_info	short
)	O
;	O
unsigned	O
long	O
vlen	O
=	O
LCTF_INFO_VLEN	O
(	O
fp	*(struct)
,	O
tp	O
->	O
ctt_info	short
)	O
;	O
ssize_t	long
size	long
,	O
increment	O
,	O
vbytes	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
(	O
void	O
)	O
ctf_get_ctt_size	O
(	O
fp	*(struct)
,	O
tp	O
,	O
&	O
size	long
,	O
&	O
increment	O
)	O
;	O
name	*(char)
=	O
ctf_strptr	O
(	O
fp	*(struct)
,	O
tp	O
->	O
ctt_name	int
)	O
;	O
vbytes	O
=	O
LCTF_VBYTES	O
(	O
fp	*(struct)
,	O
kind	O
,	O
size	long
,	O
vlen	O
)	O
;	O
switch	O
(	O
kind	O
)	O
{	O
case	O
CTF_K_INTEGER	O
:	O
case	O
CTF_K_FLOAT	O
:	O
if	O
(	O
(	O
(	O
ctf_hash_lookup_type	O
(	O
fp	*(struct)
->	O
ctf_names	O
.	O
ctn_readonly	O
,	O
fp	*(struct)
,	O
name	*(char)
)	O
)	O
==	O
0	int
)	O
||	O
(	O
flag	int
&	O
CTF_ADD_ROOT	O
)	O
)	O
{	O
err	long
=	O
ctf_hash_define_type	O
(	O
fp	*(struct)
->	O
ctf_names	O
.	O
ctn_readonly	O
,	O
fp	*(struct)
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	*(struct)
,	O
id	int
,	O
child	O
)	O
,	O
tp	O
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
}	O
break	O
;	O
case	O
CTF_K_ARRAY	O
:	O
case	O
CTF_K_SLICE	O
:	O
break	O
;	O
case	O
CTF_K_FUNCTION	O
:	O
err	long
=	O
ctf_hash_insert_type	O
(	O
fp	*(struct)
->	O
ctf_names	O
.	O
ctn_readonly	O
,	O
fp	*(struct)
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	*(struct)
,	O
id	int
,	O
child	O
)	O
,	O
tp	O
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
break	O
;	O
case	O
CTF_K_STRUCT	O
:	O
err	long
=	O
ctf_hash_define_type	O
(	O
fp	*(struct)
->	O
ctf_structs	O
.	O
ctn_readonly	O
,	O
fp	*(struct)
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	*(struct)
,	O
id	int
,	O
child	O
)	O
,	O
tp	O
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
if	O
(	O
size	long
>=	O
CTF_LSTRUCT_THRESH	O
)	O
nlstructs	O
++	O
;	O
break	O
;	O
case	O
CTF_K_UNION	O
:	O
err	long
=	O
ctf_hash_define_type	O
(	O
fp	*(struct)
->	O
ctf_unions	O
.	O
ctn_readonly	O
,	O
fp	*(struct)
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	*(struct)
,	O
id	int
,	O
child	O
)	O
,	O
tp	O
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
if	O
(	O
size	long
>=	O
CTF_LSTRUCT_THRESH	O
)	O
nlunions	O
++	O
;	O
break	O
;	O
case	O
CTF_K_ENUM	O
:	O
err	long
=	O
ctf_hash_define_type	O
(	O
fp	*(struct)
->	O
ctf_enums	O
.	O
ctn_readonly	O
,	O
fp	*(struct)
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	*(struct)
,	O
id	int
,	O
child	O
)	O
,	O
tp	O
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
break	O
;	O
case	O
CTF_K_TYPEDEF	O
:	O
err	long
=	O
ctf_hash_insert_type	O
(	O
fp	*(struct)
->	O
ctf_names	O
.	O
ctn_readonly	O
,	O
fp	*(struct)
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	*(struct)
,	O
id	int
,	O
child	O
)	O
,	O
tp	O
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
break	O
;	O
case	O
CTF_K_FORWARD	O
:	O
{	O
ctf_names_t	O
*	O
np	O
=	O
ctf_name_table	O
(	O
fp	*(struct)
,	O
tp	O
->	O
ctt_type	short
)	O
;	O
if	O
(	O
ctf_hash_lookup_type	O
(	O
np	O
->	O
ctn_readonly	O
,	O
fp	*(struct)
,	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
err	long
=	O
ctf_hash_insert_type	O
(	O
np	O
->	O
ctn_readonly	O
,	O
fp	*(struct)
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	*(struct)
,	O
id	int
,	O
child	O
)	O
,	O
tp	O
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
}	O
break	O
;	O
}	O
case	O
CTF_K_POINTER	O
:	O
if	O
(	O
LCTF_TYPE_ISCHILD	O
(	O
fp	*(struct)
,	O
tp	O
->	O
ctt_type	short
)	O
==	O
child	O
&&	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	*(struct)
,	O
tp	O
->	O
ctt_type	short
)	O
<=	O
fp	*(struct)
->	O
ctf_typemax	O
)	O
fp	*(struct)
->	O
ctf_ptrtab	O
[	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	*(struct)
,	O
tp	O
->	O
ctt_type	short
)	O
]	O
=	O
id	int
;	O
case	O
CTF_K_VOLATILE	O
:	O
case	O
CTF_K_CONST	O
:	O
case	O
CTF_K_RESTRICT	O
:	O
err	long
=	O
ctf_hash_insert_type	O
(	O
fp	*(struct)
->	O
ctf_names	O
.	O
ctn_readonly	O
,	O
fp	*(struct)
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	*(struct)
,	O
id	int
,	O
child	O
)	O
,	O
tp	O
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
break	O
;	O
default	O
:	O
ctf_dprintf	O
(	O
"unhandled CTF kind in endianness conversion -- %x\n"	*(char)
,	O
kind	O
)	O
;	O
return	O
ECTF_CORRUPT	int
;	O
}	O
*	O
xp	O
=	O
(	O
uint32_t	int
)	O
(	O
(	O
uintptr_t	long
)	O
tp	O
-	O
(	O
uintptr_t	long
)	O
fp	*(struct)
->	O
ctf_buf	O
)	O
;	O
tp	O
=	O
(	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
tp	O
+	O
increment	O
+	O
vbytes	O
)	O
;	O
}	O
ctf_dprintf	O
(	O
"%lu total types processed\n"	*(char)
,	O
fp	*(struct)
->	O
ctf_typemax	O
)	O
;	O
ctf_dprintf	O
(	O
"%u enum names hashed\n"	*(char)
,	O
ctf_hash_size	O
(	O
fp	*(struct)
->	O
ctf_enums	O
.	O
ctn_readonly	O
)	O
)	O
;	O
ctf_dprintf	O
(	O
"%u struct names hashed (%d long)\n"	*(char)
,	O
ctf_hash_size	O
(	O
fp	*(struct)
->	O
ctf_structs	O
.	O
ctn_readonly	O
)	O
,	O
nlstructs	O
)	O
;	O
ctf_dprintf	O
(	O
"%u union names hashed (%d long)\n"	*(char)
,	O
ctf_hash_size	O
(	O
fp	*(struct)
->	O
ctf_unions	O
.	O
ctn_readonly	O
)	O
,	O
nlunions	O
)	O
;	O
ctf_dprintf	O
(	O
"%u base type names hashed\n"	*(char)
,	O
ctf_hash_size	O
(	O
fp	*(struct)
->	O
ctf_names	O
.	O
ctn_readonly	O
)	O
)	O
;	O
for	O
(	O
id	int
=	O
1	int
;	O
id	int
<=	O
fp	*(struct)
->	O
ctf_typemax	O
;	O
id	int
++	O
)	O
{	O
if	O
(	O
(	O
dst	O
=	O
fp	*(struct)
->	O
ctf_ptrtab	O
[	O
id	int
]	O
)	O
!=	O
0	int
)	O
{	O
tp	O
=	O
LCTF_INDEX_TO_TYPEPTR	O
(	O
fp	*(struct)
,	O
id	int
)	O
;	O
if	O
(	O
LCTF_INFO_KIND	O
(	O
fp	*(struct)
,	O
tp	O
->	O
ctt_info	short
)	O
==	O
CTF_K_TYPEDEF	O
&&	O
strcmp	O
(	O
ctf_strptr	O
(	O
fp	*(struct)
,	O
tp	O
->	O
ctt_name	int
)	O
,	O
""	*(char)
)	O
==	O
0	int
&&	O
LCTF_TYPE_ISCHILD	O
(	O
fp	*(struct)
,	O
tp	O
->	O
ctt_type	short
)	O
==	O
child	O
&&	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	*(struct)
,	O
tp	O
->	O
ctt_type	short
)	O
<=	O
fp	*(struct)
->	O
ctf_typemax	O
)	O
fp	*(struct)
->	O
ctf_ptrtab	O
[	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	*(struct)
,	O
tp	O
->	O
ctt_type	short
)	O
]	O
=	O
dst	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
flip_header	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
*	O
cth	O
)	O
{	O
swap_thing	O
(	O
cth	O
->	O
cth_preamble	struct(short,char,char)
.	O
ctp_magic	short
)	O
;	O
swap_thing	O
(	O
cth	O
->	O
cth_preamble	struct(short,char,char)
.	O
ctp_version	char
)	O
;	O
swap_thing	O
(	O
cth	O
->	O
cth_preamble	struct(short,char,char)
.	O
ctp_flags	char
)	O
;	O
swap_thing	O
(	O
cth	O
->	O
cth_parlabel	int
)	O
;	O
swap_thing	O
(	O
cth	O
->	O
cth_parname	int
)	O
;	O
swap_thing	O
(	O
cth	O
->	O
cth_cuname	int
)	O
;	O
swap_thing	O
(	O
cth	O
->	O
cth_objtoff	int
)	O
;	O
swap_thing	O
(	O
cth	O
->	O
cth_funcoff	int
)	O
;	O
swap_thing	O
(	O
cth	O
->	O
cth_objtidxoff	int
)	O
;	O
swap_thing	O
(	O
cth	O
->	O
cth_funcidxoff	int
)	O
;	O
swap_thing	O
(	O
cth	O
->	O
cth_varoff	int
)	O
;	O
swap_thing	O
(	O
cth	O
->	O
cth_typeoff	int
)	O
;	O
swap_thing	O
(	O
cth	O
->	O
cth_stroff	int
)	O
;	O
swap_thing	O
(	O
cth	O
->	O
cth_strlen	int
)	O
;	O
}	O
static	O
void	O
flip_lbls	O
(	O
void	O
*	O
start	O
,	O
size_t	long
len	int
)	O
{	O
ctf_lblent_t	struct(int,int)
*	O
lbl	O
=	O
start	O
;	O
ssize_t	long
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
len	int
/	O
sizeof	O
(	O
struct	O
ctf_lblent	struct(int,int)
)	O
;	O
i	*(struct)
>	O
0	int
;	O
lbl	O
++	O
,	O
i	*(struct)
--	O
)	O
{	O
swap_thing	O
(	O
lbl	O
->	O
ctl_label	int
)	O
;	O
swap_thing	O
(	O
lbl	O
->	O
ctl_type	int
)	O
;	O
}	O
}	O
static	O
void	O
flip_objts	O
(	O
void	O
*	O
start	O
,	O
size_t	long
len	int
)	O
{	O
uint32_t	int
*	O
obj	*(struct)
=	O
start	O
;	O
ssize_t	long
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
len	int
/	O
sizeof	O
(	O
uint32_t	int
)	O
;	O
i	*(struct)
>	O
0	int
;	O
obj	*(struct)
++	O
,	O
i	*(struct)
--	O
)	O
swap_thing	O
(	O
*	O
obj	*(struct)
)	O
;	O
}	O
static	O
void	O
flip_vars	O
(	O
void	O
*	O
start	O
,	O
size_t	long
len	int
)	O
{	O
ctf_varent_t	struct(int,int)
*	O
var	O
=	O
start	O
;	O
ssize_t	long
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
len	int
/	O
sizeof	O
(	O
struct	O
ctf_varent	struct(int,int)
)	O
;	O
i	*(struct)
>	O
0	int
;	O
var	O
++	O
,	O
i	*(struct)
--	O
)	O
{	O
swap_thing	O
(	O
var	O
->	O
ctv_name	int
)	O
;	O
swap_thing	O
(	O
var	O
->	O
ctv_type	int
)	O
;	O
}	O
}	O
static	O
int	O
flip_types	O
(	O
void	O
*	O
start	O
,	O
size_t	long
len	int
)	O
{	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
t	O
=	O
start	O
;	O
while	O
(	O
(	O
uintptr_t	long
)	O
t	O
<	O
(	O
(	O
uintptr_t	long
)	O
start	O
)	O
+	O
len	int
)	O
{	O
swap_thing	O
(	O
t	O
->	O
ctt_name	int
)	O
;	O
swap_thing	O
(	O
t	O
->	O
ctt_info	short
)	O
;	O
swap_thing	O
(	O
t	O
->	O
ctt_size	short
)	O
;	O
uint32_t	int
kind	O
=	O
CTF_V2_INFO_KIND	O
(	O
t	O
->	O
ctt_info	short
)	O
;	O
size_t	long
size	long
=	O
t	O
->	O
ctt_size	short
;	O
uint32_t	int
vlen	O
=	O
CTF_V2_INFO_VLEN	O
(	O
t	O
->	O
ctt_info	short
)	O
;	O
size_t	long
vbytes	O
=	O
get_vbytes_v2	O
(	O
kind	O
,	O
size	long
,	O
vlen	O
)	O
;	O
if	O
(	O
_libctf_unlikely_	O
(	O
size	long
==	O
CTF_LSIZE_SENT	O
)	O
)	O
{	O
swap_thing	O
(	O
t	O
->	O
ctt_lsizehi	O
)	O
;	O
swap_thing	O
(	O
t	O
->	O
ctt_lsizelo	int
)	O
;	O
size	long
=	O
CTF_TYPE_LSIZE	O
(	O
t	O
)	O
;	O
t	O
=	O
(	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
t	O
+	O
sizeof	O
(	O
ctf_type_t	struct(int,int,union(int,int),int,int)
)	O
)	O
;	O
}	O
else	O
t	O
=	O
(	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
t	O
+	O
sizeof	O
(	O
ctf_stype_t	O
)	O
)	O
;	O
switch	O
(	O
kind	O
)	O
{	O
case	O
CTF_K_FORWARD	O
:	O
case	O
CTF_K_UNKNOWN	O
:	O
case	O
CTF_K_POINTER	O
:	O
case	O
CTF_K_TYPEDEF	O
:	O
case	O
CTF_K_VOLATILE	O
:	O
case	O
CTF_K_CONST	O
:	O
case	O
CTF_K_RESTRICT	O
:	O
assert	O
(	O
vbytes	O
==	O
0	int
)	O
;	O
break	O
;	O
case	O
CTF_K_INTEGER	O
:	O
case	O
CTF_K_FLOAT	O
:	O
{	O
uint32_t	int
*	O
item	O
=	O
(	O
uint32_t	int
*	O
)	O
t	O
;	O
swap_thing	O
(	O
*	O
item	O
)	O
;	O
break	O
;	O
}	O
case	O
CTF_K_FUNCTION	O
:	O
{	O
uint32_t	int
*	O
item	O
=	O
(	O
uint32_t	int
*	O
)	O
t	O
;	O
ssize_t	long
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
vlen	O
;	O
i	*(struct)
>	O
0	int
;	O
item	O
++	O
,	O
i	*(struct)
--	O
)	O
swap_thing	O
(	O
*	O
item	O
)	O
;	O
break	O
;	O
}	O
case	O
CTF_K_ARRAY	O
:	O
{	O
ctf_array_t	struct(int,int,int)
*	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
(	O
ctf_array_t	struct(int,int,int)
*	O
)	O
t	O
;	O
assert	O
(	O
vbytes	O
==	O
sizeof	O
(	O
ctf_array_t	struct(int,int,int)
)	O
)	O
;	O
swap_thing	O
(	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
cta_contents	short
)	O
;	O
swap_thing	O
(	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
cta_index	short
)	O
;	O
swap_thing	O
(	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
cta_nelems	int
)	O
;	O
break	O
;	O
}	O
case	O
CTF_K_SLICE	O
:	O
{	O
ctf_slice_t	struct(int,short,short)
*	O
s	*(char)
=	O
(	O
ctf_slice_t	struct(int,short,short)
*	O
)	O
t	O
;	O
assert	O
(	O
vbytes	O
==	O
sizeof	O
(	O
ctf_slice_t	struct(int,short,short)
)	O
)	O
;	O
swap_thing	O
(	O
s	*(char)
->	O
cts_type	int
)	O
;	O
swap_thing	O
(	O
s	*(char)
->	O
cts_offset	short
)	O
;	O
swap_thing	O
(	O
s	*(char)
->	O
cts_bits	short
)	O
;	O
break	O
;	O
}	O
case	O
CTF_K_STRUCT	O
:	O
case	O
CTF_K_UNION	O
:	O
{	O
if	O
(	O
_libctf_unlikely_	O
(	O
size	long
>=	O
CTF_LSTRUCT_THRESH	O
)	O
)	O
{	O
ctf_lmember_t	struct(int,int,int,int)
*	O
lm	O
=	O
(	O
ctf_lmember_t	struct(int,int,int,int)
*	O
)	O
t	O
;	O
ssize_t	long
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
vlen	O
;	O
i	*(struct)
>	O
0	int
;	O
i	*(struct)
--	O
,	O
lm	O
++	O
)	O
{	O
swap_thing	O
(	O
lm	O
->	O
ctlm_name	int
)	O
;	O
swap_thing	O
(	O
lm	O
->	O
ctlm_offsethi	int
)	O
;	O
swap_thing	O
(	O
lm	O
->	O
ctlm_type	short
)	O
;	O
swap_thing	O
(	O
lm	O
->	O
ctlm_offsetlo	int
)	O
;	O
}	O
}	O
else	O
{	O
ctf_member_t	struct(int,int,int)
*	O
m	O
=	O
(	O
ctf_member_t	struct(int,int,int)
*	O
)	O
t	O
;	O
ssize_t	long
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
vlen	O
;	O
i	*(struct)
>	O
0	int
;	O
i	*(struct)
--	O
,	O
m	O
++	O
)	O
{	O
swap_thing	O
(	O
m	O
->	O
ctm_name	int
)	O
;	O
swap_thing	O
(	O
m	O
->	O
ctm_offset	short
)	O
;	O
swap_thing	O
(	O
m	O
->	O
ctm_type	short
)	O
;	O
}	O
}	O
break	O
;	O
}	O
case	O
CTF_K_ENUM	O
:	O
{	O
ctf_enum_t	struct(int,int)
*	O
item	O
=	O
(	O
ctf_enum_t	struct(int,int)
*	O
)	O
t	O
;	O
ssize_t	long
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
vlen	O
;	O
i	*(struct)
>	O
0	int
;	O
item	O
++	O
,	O
i	*(struct)
--	O
)	O
{	O
swap_thing	O
(	O
item	O
->	O
cte_name	int
)	O
;	O
swap_thing	O
(	O
item	O
->	O
cte_value	int
)	O
;	O
}	O
break	O
;	O
}	O
default	O
:	O
ctf_dprintf	O
(	O
"unhandled CTF kind in endianness conversion -- %x\n"	*(char)
,	O
kind	O
)	O
;	O
return	O
ECTF_CORRUPT	int
;	O
}	O
t	O
=	O
(	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
t	O
+	O
vbytes	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
flip_ctf	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
*	O
cth	O
,	O
unsigned	O
char	O
*	O
buf	*(void)
)	O
{	O
flip_lbls	O
(	O
buf	*(void)
+	O
cth	O
->	O
cth_lbloff	int
,	O
cth	O
->	O
cth_objtoff	int
-	O
cth	O
->	O
cth_lbloff	int
)	O
;	O
flip_objts	O
(	O
buf	*(void)
+	O
cth	O
->	O
cth_objtoff	int
,	O
cth	O
->	O
cth_funcoff	int
-	O
cth	O
->	O
cth_objtoff	int
)	O
;	O
flip_objts	O
(	O
buf	*(void)
+	O
cth	O
->	O
cth_funcoff	int
,	O
cth	O
->	O
cth_objtidxoff	int
-	O
cth	O
->	O
cth_funcoff	int
)	O
;	O
flip_objts	O
(	O
buf	*(void)
+	O
cth	O
->	O
cth_objtidxoff	int
,	O
cth	O
->	O
cth_funcidxoff	int
-	O
cth	O
->	O
cth_objtidxoff	int
)	O
;	O
flip_objts	O
(	O
buf	*(void)
+	O
cth	O
->	O
cth_funcidxoff	int
,	O
cth	O
->	O
cth_varoff	int
-	O
cth	O
->	O
cth_funcidxoff	int
)	O
;	O
flip_vars	O
(	O
buf	*(void)
+	O
cth	O
->	O
cth_varoff	int
,	O
cth	O
->	O
cth_typeoff	int
-	O
cth	O
->	O
cth_varoff	int
)	O
;	O
return	O
flip_types	O
(	O
buf	*(void)
+	O
cth	O
->	O
cth_typeoff	int
,	O
cth	O
->	O
cth_stroff	int
-	O
cth	O
->	O
cth_typeoff	int
)	O
;	O
}	O
void	O
ctf_set_ctl_hashes	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
0	int
]	O
.	O
ctl_prefix	O
=	O
"struct"	*(char)
;	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
0	int
]	O
.	O
ctl_len	O
=	O
strlen	O
(	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
0	int
]	O
.	O
ctl_prefix	O
)	O
;	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
0	int
]	O
.	O
ctl_hash	O
=	O
&	O
fp	*(struct)
->	O
ctf_structs	O
;	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
1	int
]	O
.	O
ctl_prefix	O
=	O
"union"	*(char)
;	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
1	int
]	O
.	O
ctl_len	O
=	O
strlen	O
(	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
1	int
]	O
.	O
ctl_prefix	O
)	O
;	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
1	int
]	O
.	O
ctl_hash	O
=	O
&	O
fp	*(struct)
->	O
ctf_unions	O
;	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
2	int
]	O
.	O
ctl_prefix	O
=	O
"enum"	*(char)
;	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
2	int
]	O
.	O
ctl_len	O
=	O
strlen	O
(	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
2	int
]	O
.	O
ctl_prefix	O
)	O
;	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
2	int
]	O
.	O
ctl_hash	O
=	O
&	O
fp	*(struct)
->	O
ctf_enums	O
;	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
3	int
]	O
.	O
ctl_prefix	O
=	O
_CTF_NULLSTR	O
;	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
3	int
]	O
.	O
ctl_len	O
=	O
strlen	O
(	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
3	int
]	O
.	O
ctl_prefix	O
)	O
;	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
3	int
]	O
.	O
ctl_hash	O
=	O
&	O
fp	*(struct)
->	O
ctf_names	O
;	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
4	int
]	O
.	O
ctl_prefix	O
=	O
NULL	O
;	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
4	int
]	O
.	O
ctl_len	O
=	O
0	int
;	O
fp	*(struct)
->	O
ctf_lookups	O
[	O
4	int
]	O
.	O
ctl_hash	O
=	O
NULL	O
;	O
}	O
ctf_file_t	struct
*	O
ctf_simple_open	(*(char),long,*(char),long,long,*(char),long,*(int))->(*(struct))
(	O
const	O
char	O
*	O
ctfsect	O
,	O
size_t	long
ctfsect_size	O
,	O
const	O
char	O
*	O
symsect	O
,	O
size_t	long
symsect_size	O
,	O
size_t	long
symsect_entsize	O
,	O
const	O
char	O
*	O
strsect	O
,	O
size_t	long
strsect_size	O
,	O
int	O
*	O
errp	*(int)
)	O
{	O
return	O
ctf_simple_open_internal	O
(	O
ctfsect	O
,	O
ctfsect_size	O
,	O
symsect	O
,	O
symsect_size	O
,	O
symsect_entsize	O
,	O
strsect	O
,	O
strsect_size	O
,	O
NULL	O
,	O
0	int
,	O
errp	*(int)
)	O
;	O
}	O
ctf_file_t	struct
*	O
ctf_simple_open_internal	O
(	O
const	O
char	O
*	O
ctfsect	O
,	O
size_t	long
ctfsect_size	O
,	O
const	O
char	O
*	O
symsect	O
,	O
size_t	long
symsect_size	O
,	O
size_t	long
symsect_entsize	O
,	O
const	O
char	O
*	O
strsect	O
,	O
size_t	long
strsect_size	O
,	O
ctf_dynhash_t	O
*	O
syn_strtab	O
,	O
int	O
writable	O
,	O
int	O
*	O
errp	*(int)
)	O
{	O
ctf_sect_t	struct(*(char),*(void),long,long)
skeleton	O
;	O
ctf_sect_t	struct(*(char),*(void),long,long)
ctf_sect	struct(*(char),*(void),long,long)
,	O
sym_sect	O
,	O
str_sect	O
;	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
ctfsectp	O
=	O
NULL	O
;	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
symsectp	O
=	O
NULL	O
;	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
strsectp	O
=	O
NULL	O
;	O
skeleton	O
.	O
cts_name	*(char)
=	O
_CTF_SECTION	O
;	O
skeleton	O
.	O
cts_entsize	long
=	O
1	int
;	O
if	O
(	O
ctfsect	O
)	O
{	O
memcpy	O
(	O
&	O
ctf_sect	struct(*(char),*(void),long,long)
,	O
&	O
skeleton	O
,	O
sizeof	O
(	O
struct	O
ctf_sect	struct(*(char),*(void),long,long)
)	O
)	O
;	O
ctf_sect	struct(*(char),*(void),long,long)
.	O
cts_data	*(void)
=	O
ctfsect	O
;	O
ctf_sect	struct(*(char),*(void),long,long)
.	O
cts_size	long
=	O
ctfsect_size	O
;	O
ctfsectp	O
=	O
&	O
ctf_sect	struct(*(char),*(void),long,long)
;	O
}	O
if	O
(	O
symsect	O
)	O
{	O
memcpy	O
(	O
&	O
sym_sect	O
,	O
&	O
skeleton	O
,	O
sizeof	O
(	O
struct	O
ctf_sect	struct(*(char),*(void),long,long)
)	O
)	O
;	O
sym_sect	O
.	O
cts_data	*(void)
=	O
symsect	O
;	O
sym_sect	O
.	O
cts_size	long
=	O
symsect_size	O
;	O
sym_sect	O
.	O
cts_entsize	long
=	O
symsect_entsize	O
;	O
symsectp	O
=	O
&	O
sym_sect	O
;	O
}	O
if	O
(	O
strsect	O
)	O
{	O
memcpy	O
(	O
&	O
str_sect	O
,	O
&	O
skeleton	O
,	O
sizeof	O
(	O
struct	O
ctf_sect	struct(*(char),*(void),long,long)
)	O
)	O
;	O
str_sect	O
.	O
cts_data	*(void)
=	O
strsect	O
;	O
str_sect	O
.	O
cts_size	long
=	O
strsect_size	O
;	O
strsectp	O
=	O
&	O
str_sect	O
;	O
}	O
return	O
ctf_bufopen_internal	O
(	O
ctfsectp	O
,	O
symsectp	O
,	O
strsectp	O
,	O
syn_strtab	O
,	O
writable	O
,	O
errp	*(int)
)	O
;	O
}	O
ctf_file_t	struct
*	O
ctf_bufopen	(*(struct(*(char),*(void),long,long)),*(struct(*(char),*(void),long,long)),*(struct(*(char),*(void),long,long)),*(int))->(*(struct))
(	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
ctfsect	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
symsect	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
strsect	O
,	O
int	O
*	O
errp	*(int)
)	O
{	O
return	O
ctf_bufopen_internal	O
(	O
ctfsect	O
,	O
symsect	O
,	O
strsect	O
,	O
NULL	O
,	O
0	int
,	O
errp	*(int)
)	O
;	O
}	O
ctf_file_t	struct
*	O
ctf_bufopen_internal	O
(	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
ctfsect	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
symsect	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
strsect	O
,	O
ctf_dynhash_t	O
*	O
syn_strtab	O
,	O
int	O
writable	O
,	O
int	O
*	O
errp	*(int)
)	O
{	O
const	O
ctf_preamble_t	struct(short,char,char)
*	O
pp	O
;	O
size_t	long
hdrsz	O
=	O
sizeof	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
*	O
hp	O
;	O
ctf_file_t	struct
*	O
fp	*(struct)
;	O
int	O
foreign_endian	O
=	O
0	int
;	O
int	O
err	long
;	O
libctf_init_debug	O
(	O
)	O
;	O
if	O
(	O
(	O
ctfsect	O
==	O
NULL	O
)	O
||	O
(	O
(	O
symsect	O
!=	O
NULL	O
)	O
&&	O
(	O
(	O
strsect	O
==	O
NULL	O
)	O
&&	O
syn_strtab	O
==	O
NULL	O
)	O
)	O
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
EINVAL	O
)	O
)	O
;	O
if	O
(	O
symsect	O
!=	O
NULL	O
&&	O
symsect	O
->	O
cts_entsize	long
!=	O
sizeof	O
(	O
Elf32_Sym	struct(int,int,int,char,char,short)
)	O
&&	O
symsect	O
->	O
cts_entsize	long
!=	O
sizeof	O
(	O
Elf64_Sym	struct(int,char,char,short,long,long)
)	O
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_SYMTAB	int
)	O
)	O
;	O
if	O
(	O
symsect	O
!=	O
NULL	O
&&	O
symsect	O
->	O
cts_data	*(void)
==	O
NULL	O
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_SYMBAD	int
)	O
)	O
;	O
if	O
(	O
strsect	O
!=	O
NULL	O
&&	O
strsect	O
->	O
cts_data	*(void)
==	O
NULL	O
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_STRBAD	int
)	O
)	O
;	O
if	O
(	O
ctfsect	O
->	O
cts_size	long
<	O
sizeof	O
(	O
ctf_preamble_t	struct(short,char,char)
)	O
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_NOCTFBUF	int
)	O
)	O
;	O
pp	O
=	O
(	O
const	O
ctf_preamble_t	struct(short,char,char)
*	O
)	O
ctfsect	O
->	O
cts_data	*(void)
;	O
ctf_dprintf	O
(	O
"ctf_bufopen: magic=0x%x version=%u\n"	*(char)
,	O
pp	O
->	O
ctp_magic	short
,	O
pp	O
->	O
ctp_version	char
)	O
;	O
if	O
(	O
_libctf_unlikely_	O
(	O
pp	O
->	O
ctp_magic	short
!=	O
CTF_MAGIC	O
)	O
)	O
{	O
if	O
(	O
pp	O
->	O
ctp_magic	short
==	O
bswap_16	O
(	O
CTF_MAGIC	O
)	O
)	O
{	O
if	O
(	O
pp	O
->	O
ctp_version	char
!=	O
CTF_VERSION_3	O
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_CTFVERS	int
)	O
)	O
;	O
foreign_endian	O
=	O
1	int
;	O
}	O
else	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_NOCTFBUF	int
)	O
)	O
;	O
}	O
if	O
(	O
_libctf_unlikely_	O
(	O
(	O
pp	O
->	O
ctp_version	char
<	O
CTF_VERSION_1	O
)	O
||	O
(	O
pp	O
->	O
ctp_version	char
>	O
CTF_VERSION_3	O
)	O
)	O
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_CTFVERS	int
)	O
)	O
;	O
if	O
(	O
(	O
symsect	O
!=	O
NULL	O
)	O
&&	O
(	O
pp	O
->	O
ctp_version	char
<	O
CTF_VERSION_2	O
)	O
)	O
{	O
ctf_dprintf	O
(	O
"ctf_bufopen: CTF version %d symsect not "	*(char)
"supported\n"	*(char)
,	O
pp	O
->	O
ctp_version	char
)	O
;	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_NOTSUP	int
)	O
)	O
;	O
}	O
if	O
(	O
pp	O
->	O
ctp_version	char
<	O
CTF_VERSION_3	O
)	O
hdrsz	O
=	O
sizeof	O
(	O
ctf_header_v2_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int)
)	O
;	O
if	O
(	O
ctfsect	O
->	O
cts_size	long
<	O
hdrsz	O
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_NOCTFBUF	int
)	O
)	O
;	O
if	O
(	O
(	O
fp	*(struct)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
ctf_file_t	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ENOMEM	O
)	O
)	O
;	O
memset	O
(	O
fp	*(struct)
,	O
0	int
,	O
sizeof	O
(	O
ctf_file_t	struct
)	O
)	O
;	O
if	O
(	O
writable	O
)	O
fp	*(struct)
->	O
ctf_flags	O
|=	O
LCTF_RDWR	O
;	O
if	O
(	O
(	O
fp	*(struct)
->	O
ctf_header	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
ctf_header	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
fp	*(struct)
)	O
;	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ENOMEM	O
)	O
)	O
;	O
}	O
hp	O
=	O
fp	*(struct)
->	O
ctf_header	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
;	O
memcpy	O
(	O
hp	O
,	O
ctfsect	O
->	O
cts_data	*(void)
,	O
hdrsz	O
)	O
;	O
if	O
(	O
pp	O
->	O
ctp_version	char
<	O
CTF_VERSION_3	O
)	O
upgrade_header	O
(	O
hp	O
)	O
;	O
if	O
(	O
foreign_endian	O
)	O
flip_header	O
(	O
hp	O
)	O
;	O
fp	*(struct)
->	O
ctf_openflags	O
=	O
hp	O
->	O
cth_flags	O
;	O
fp	*(struct)
->	O
ctf_size	O
=	O
hp	O
->	O
cth_stroff	int
+	O
hp	O
->	O
cth_strlen	int
;	O
ctf_dprintf	O
(	O
"ctf_bufopen: uncompressed size=%lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
fp	*(struct)
->	O
ctf_size	O
)	O
;	O
if	O
(	O
hp	O
->	O
cth_lbloff	int
>	O
fp	*(struct)
->	O
ctf_size	O
||	O
hp	O
->	O
cth_objtoff	int
>	O
fp	*(struct)
->	O
ctf_size	O
||	O
hp	O
->	O
cth_funcoff	int
>	O
fp	*(struct)
->	O
ctf_size	O
||	O
hp	O
->	O
cth_objtidxoff	int
>	O
fp	*(struct)
->	O
ctf_size	O
||	O
hp	O
->	O
cth_funcidxoff	int
>	O
fp	*(struct)
->	O
ctf_size	O
||	O
hp	O
->	O
cth_typeoff	int
>	O
fp	*(struct)
->	O
ctf_size	O
||	O
hp	O
->	O
cth_stroff	int
>	O
fp	*(struct)
->	O
ctf_size	O
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_CORRUPT	int
)	O
)	O
;	O
if	O
(	O
hp	O
->	O
cth_lbloff	int
>	O
hp	O
->	O
cth_objtoff	int
||	O
hp	O
->	O
cth_objtoff	int
>	O
hp	O
->	O
cth_funcoff	int
||	O
hp	O
->	O
cth_funcoff	int
>	O
hp	O
->	O
cth_typeoff	int
||	O
hp	O
->	O
cth_funcoff	int
>	O
hp	O
->	O
cth_objtidxoff	int
||	O
hp	O
->	O
cth_objtidxoff	int
>	O
hp	O
->	O
cth_funcidxoff	int
||	O
hp	O
->	O
cth_funcidxoff	int
>	O
hp	O
->	O
cth_varoff	int
||	O
hp	O
->	O
cth_varoff	int
>	O
hp	O
->	O
cth_typeoff	int
||	O
hp	O
->	O
cth_typeoff	int
>	O
hp	O
->	O
cth_stroff	int
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_CORRUPT	int
)	O
)	O
;	O
if	O
(	O
(	O
hp	O
->	O
cth_lbloff	int
&	O
3	int
)	O
||	O
(	O
hp	O
->	O
cth_objtoff	int
&	O
2	int
)	O
||	O
(	O
hp	O
->	O
cth_funcoff	int
&	O
2	int
)	O
||	O
(	O
hp	O
->	O
cth_objtidxoff	int
&	O
2	int
)	O
||	O
(	O
hp	O
->	O
cth_funcidxoff	int
&	O
2	int
)	O
||	O
(	O
hp	O
->	O
cth_varoff	int
&	O
3	int
)	O
||	O
(	O
hp	O
->	O
cth_typeoff	int
&	O
3	int
)	O
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_CORRUPT	int
)	O
)	O
;	O
if	O
(	O
hp	O
->	O
cth_flags	O
&	O
CTF_F_COMPRESS	O
)	O
{	O
size_t	long
srclen	O
;	O
uLongf	long
dstlen	O
;	O
const	O
void	O
*	O
src	O
;	O
int	O
rc	O
=	O
Z_OK	O
;	O
if	O
(	O
(	O
fp	*(struct)
->	O
ctf_base	O
=	O
malloc	(long)->(*(void))
(	O
fp	*(struct)
->	O
ctf_size	O
)	O
)	O
==	O
NULL	O
)	O
{	O
err	long
=	O
ECTF_ZALLOC	int
;	O
goto	O
bad	O
;	O
}	O
fp	*(struct)
->	O
ctf_dynbase	O
=	O
fp	*(struct)
->	O
ctf_base	O
;	O
hp	O
->	O
cth_flags	O
&=	O
~	O
CTF_F_COMPRESS	O
;	O
src	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
ctfsect	O
->	O
cts_data	*(void)
+	O
hdrsz	O
;	O
srclen	O
=	O
ctfsect	O
->	O
cts_size	long
-	O
hdrsz	O
;	O
dstlen	O
=	O
fp	*(struct)
->	O
ctf_size	O
;	O
fp	*(struct)
->	O
ctf_buf	O
=	O
fp	*(struct)
->	O
ctf_base	O
;	O
if	O
(	O
(	O
rc	O
=	O
uncompress	(*(char),*(long),*(char),long)->(int)
(	O
fp	*(struct)
->	O
ctf_base	O
,	O
&	O
dstlen	O
,	O
src	O
,	O
srclen	O
)	O
)	O
!=	O
Z_OK	O
)	O
{	O
ctf_dprintf	O
(	O
"zlib inflate err: %s\n"	*(char)
,	O
zError	(int)->(*(char))
(	O
rc	O
)	O
)	O
;	O
err	long
=	O
ECTF_DECOMPRESS	int
;	O
goto	O
bad	O
;	O
}	O
if	O
(	O
(	O
size_t	long
)	O
dstlen	O
!=	O
fp	*(struct)
->	O
ctf_size	O
)	O
{	O
ctf_dprintf	O
(	O
"zlib inflate short -- got %lu of %lu "	*(char)
"bytes\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
dstlen	O
,	O
(	O
unsigned	O
long	O
)	O
fp	*(struct)
->	O
ctf_size	O
)	O
;	O
err	long
=	O
ECTF_CORRUPT	int
;	O
goto	O
bad	O
;	O
}	O
}	O
else	O
if	O
(	O
foreign_endian	O
)	O
{	O
if	O
(	O
(	O
fp	*(struct)
->	O
ctf_base	O
=	O
malloc	(long)->(*(void))
(	O
fp	*(struct)
->	O
ctf_size	O
)	O
)	O
==	O
NULL	O
)	O
{	O
err	long
=	O
ECTF_ZALLOC	int
;	O
goto	O
bad	O
;	O
}	O
fp	*(struct)
->	O
ctf_dynbase	O
=	O
fp	*(struct)
->	O
ctf_base	O
;	O
memcpy	O
(	O
fp	*(struct)
->	O
ctf_base	O
,	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
ctfsect	O
->	O
cts_data	*(void)
)	O
+	O
hdrsz	O
,	O
fp	*(struct)
->	O
ctf_size	O
)	O
;	O
fp	*(struct)
->	O
ctf_buf	O
=	O
fp	*(struct)
->	O
ctf_base	O
;	O
}	O
else	O
{	O
fp	*(struct)
->	O
ctf_base	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
ctfsect	O
->	O
cts_data	*(void)
;	O
fp	*(struct)
->	O
ctf_dynbase	O
=	O
NULL	O
;	O
fp	*(struct)
->	O
ctf_buf	O
=	O
fp	*(struct)
->	O
ctf_base	O
+	O
hdrsz	O
;	O
}	O
ctf_set_version	O
(	O
fp	*(struct)
,	O
hp	O
,	O
hp	O
->	O
cth_version	O
)	O
;	O
ctf_str_create_atoms	O
(	O
fp	*(struct)
)	O
;	O
fp	*(struct)
->	O
ctf_parmax	O
=	O
CTF_MAX_PTYPE	O
;	O
memcpy	O
(	O
&	O
fp	*(struct)
->	O
ctf_data	O
,	O
ctfsect	O
,	O
sizeof	O
(	O
ctf_sect_t	struct(*(char),*(void),long,long)
)	O
)	O
;	O
if	O
(	O
symsect	O
!=	O
NULL	O
)	O
{	O
memcpy	O
(	O
&	O
fp	*(struct)
->	O
ctf_symtab	O
,	O
symsect	O
,	O
sizeof	O
(	O
ctf_sect_t	struct(*(char),*(void),long,long)
)	O
)	O
;	O
memcpy	O
(	O
&	O
fp	*(struct)
->	O
ctf_strtab	O
,	O
strsect	O
,	O
sizeof	O
(	O
ctf_sect_t	struct(*(char),*(void),long,long)
)	O
)	O
;	O
}	O
if	O
(	O
fp	*(struct)
->	O
ctf_data	O
.	O
cts_name	*(char)
!=	O
NULL	O
)	O
if	O
(	O
(	O
fp	*(struct)
->	O
ctf_data	O
.	O
cts_name	*(char)
=	O
strdup	O
(	O
fp	*(struct)
->	O
ctf_data	O
.	O
cts_name	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
err	long
=	O
ENOMEM	O
;	O
goto	O
bad	O
;	O
}	O
if	O
(	O
fp	*(struct)
->	O
ctf_symtab	O
.	O
cts_name	*(char)
!=	O
NULL	O
)	O
if	O
(	O
(	O
fp	*(struct)
->	O
ctf_symtab	O
.	O
cts_name	*(char)
=	O
strdup	O
(	O
fp	*(struct)
->	O
ctf_symtab	O
.	O
cts_name	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
err	long
=	O
ENOMEM	O
;	O
goto	O
bad	O
;	O
}	O
if	O
(	O
fp	*(struct)
->	O
ctf_strtab	O
.	O
cts_name	*(char)
!=	O
NULL	O
)	O
if	O
(	O
(	O
fp	*(struct)
->	O
ctf_strtab	O
.	O
cts_name	*(char)
=	O
strdup	O
(	O
fp	*(struct)
->	O
ctf_strtab	O
.	O
cts_name	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
err	long
=	O
ENOMEM	O
;	O
goto	O
bad	O
;	O
}	O
if	O
(	O
fp	*(struct)
->	O
ctf_data	O
.	O
cts_name	*(char)
==	O
NULL	O
)	O
fp	*(struct)
->	O
ctf_data	O
.	O
cts_name	*(char)
=	O
_CTF_NULLSTR	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_symtab	O
.	O
cts_name	*(char)
==	O
NULL	O
)	O
fp	*(struct)
->	O
ctf_symtab	O
.	O
cts_name	*(char)
=	O
_CTF_NULLSTR	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_strtab	O
.	O
cts_name	*(char)
==	O
NULL	O
)	O
fp	*(struct)
->	O
ctf_strtab	O
.	O
cts_name	*(char)
=	O
_CTF_NULLSTR	O
;	O
if	O
(	O
strsect	O
!=	O
NULL	O
)	O
{	O
fp	*(struct)
->	O
ctf_str	O
[	O
CTF_STRTAB_1	O
]	O
.	O
cts_strs	O
=	O
strsect	O
->	O
cts_data	*(void)
;	O
fp	*(struct)
->	O
ctf_str	O
[	O
CTF_STRTAB_1	O
]	O
.	O
cts_len	O
=	O
strsect	O
->	O
cts_size	long
;	O
}	O
fp	*(struct)
->	O
ctf_syn_ext_strtab	O
=	O
syn_strtab	O
;	O
if	O
(	O
foreign_endian	O
&&	O
(	O
err	long
=	O
flip_ctf	O
(	O
hp	O
,	O
fp	*(struct)
->	O
ctf_buf	O
)	O
)	O
!=	O
0	int
)	O
{	O
ctf_set_base	O
(	O
fp	*(struct)
,	O
hp	O
,	O
fp	*(struct)
->	O
ctf_base	O
)	O
;	O
goto	O
bad	O
;	O
}	O
ctf_set_base	O
(	O
fp	*(struct)
,	O
hp	O
,	O
fp	*(struct)
->	O
ctf_base	O
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_RDWR	O
)	O
{	O
fp	*(struct)
->	O
ctf_refcnt	O
=	O
1	int
;	O
return	O
fp	*(struct)
;	O
}	O
if	O
(	O
(	O
err	long
=	O
init_types	O
(	O
fp	*(struct)
,	O
hp	O
)	O
)	O
!=	O
0	int
)	O
goto	O
bad	O
;	O
if	O
(	O
symsect	O
!=	O
NULL	O
)	O
{	O
fp	*(struct)
->	O
ctf_nsyms	O
=	O
symsect	O
->	O
cts_size	long
/	O
symsect	O
->	O
cts_entsize	long
;	O
fp	*(struct)
->	O
ctf_sxlate	O
=	O
malloc	(long)->(*(void))
(	O
fp	*(struct)
->	O
ctf_nsyms	O
*	O
sizeof	O
(	O
uint32_t	int
)	O
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_sxlate	O
==	O
NULL	O
)	O
{	O
err	long
=	O
ENOMEM	O
;	O
goto	O
bad	O
;	O
}	O
if	O
(	O
(	O
err	long
=	O
init_symtab	O
(	O
fp	*(struct)
,	O
hp	O
,	O
symsect	O
,	O
strsect	O
)	O
)	O
!=	O
0	int
)	O
goto	O
bad	O
;	O
}	O
ctf_set_ctl_hashes	O
(	O
fp	*(struct)
)	O
;	O
if	O
(	O
symsect	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
symsect	O
->	O
cts_entsize	long
==	O
sizeof	O
(	O
Elf64_Sym	struct(int,char,char,short,long,long)
)	O
)	O
(	O
void	O
)	O
ctf_setmodel	(*(struct),int)->(int)
(	O
fp	*(struct)
,	O
CTF_MODEL_LP64	O
)	O
;	O
else	O
(	O
void	O
)	O
ctf_setmodel	(*(struct),int)->(int)
(	O
fp	*(struct)
,	O
CTF_MODEL_ILP32	O
)	O
;	O
}	O
else	O
(	O
void	O
)	O
ctf_setmodel	(*(struct),int)->(int)
(	O
fp	*(struct)
,	O
CTF_MODEL_NATIVE	O
)	O
;	O
fp	*(struct)
->	O
ctf_refcnt	O
=	O
1	int
;	O
return	O
fp	*(struct)
;	O
bad	O
:	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
err	long
)	O
;	O
ctf_file_close	(*(struct))->(void)
(	O
fp	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
ctf_file_close	(*(struct))->(void)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
,	O
*	O
ntd	O
;	O
ctf_dvdef_t	O
*	O
dvd	O
,	O
*	O
nvd	O
;	O
if	O
(	O
fp	*(struct)
==	O
NULL	O
)	O
return	O
;	O
ctf_dprintf	O
(	O
"ctf_file_close(%p) refcnt=%u\n"	*(char)
,	O
(	O
void	O
*	O
)	O
fp	*(struct)
,	O
fp	*(struct)
->	O
ctf_refcnt	O
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_refcnt	O
>	O
1	int
)	O
{	O
fp	*(struct)
->	O
ctf_refcnt	O
--	O
;	O
return	O
;	O
}	O
free	(*(void))->(void)
(	O
fp	*(struct)
->	O
ctf_dyncuname	O
)	O
;	O
free	(*(void))->(void)
(	O
fp	*(struct)
->	O
ctf_dynparname	O
)	O
;	O
ctf_file_close	(*(struct))->(void)
(	O
fp	*(struct)
->	O
ctf_parent	O
)	O
;	O
for	O
(	O
dtd	O
=	O
ctf_list_next	O
(	O
&	O
fp	*(struct)
->	O
ctf_dtdefs	O
)	O
;	O
dtd	O
!=	O
NULL	O
;	O
dtd	O
=	O
ntd	O
)	O
{	O
ntd	O
=	O
ctf_list_next	O
(	O
dtd	O
)	O
;	O
ctf_dtd_delete	O
(	O
fp	*(struct)
,	O
dtd	O
)	O
;	O
}	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_dthash	O
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_RDWR	O
)	O
{	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_structs	O
.	O
ctn_writable	O
)	O
;	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_unions	O
.	O
ctn_writable	O
)	O
;	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_enums	O
.	O
ctn_writable	O
)	O
;	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_names	O
.	O
ctn_writable	O
)	O
;	O
}	O
else	O
{	O
ctf_hash_destroy	O
(	O
fp	*(struct)
->	O
ctf_structs	O
.	O
ctn_readonly	O
)	O
;	O
ctf_hash_destroy	O
(	O
fp	*(struct)
->	O
ctf_unions	O
.	O
ctn_readonly	O
)	O
;	O
ctf_hash_destroy	O
(	O
fp	*(struct)
->	O
ctf_enums	O
.	O
ctn_readonly	O
)	O
;	O
ctf_hash_destroy	O
(	O
fp	*(struct)
->	O
ctf_names	O
.	O
ctn_readonly	O
)	O
;	O
}	O
for	O
(	O
dvd	O
=	O
ctf_list_next	O
(	O
&	O
fp	*(struct)
->	O
ctf_dvdefs	O
)	O
;	O
dvd	O
!=	O
NULL	O
;	O
dvd	O
=	O
nvd	O
)	O
{	O
nvd	O
=	O
ctf_list_next	O
(	O
dvd	O
)	O
;	O
ctf_dvd_delete	O
(	O
fp	*(struct)
,	O
dvd	O
)	O
;	O
}	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_dvhash	O
)	O
;	O
ctf_str_free_atoms	O
(	O
fp	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
fp	*(struct)
->	O
ctf_tmp_typeslice	O
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_data	O
.	O
cts_name	*(char)
!=	O
_CTF_NULLSTR	O
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
fp	*(struct)
->	O
ctf_data	O
.	O
cts_name	*(char)
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_symtab	O
.	O
cts_name	*(char)
!=	O
_CTF_NULLSTR	O
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
fp	*(struct)
->	O
ctf_symtab	O
.	O
cts_name	*(char)
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_strtab	O
.	O
cts_name	*(char)
!=	O
_CTF_NULLSTR	O
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
fp	*(struct)
->	O
ctf_strtab	O
.	O
cts_name	*(char)
)	O
;	O
else	O
if	O
(	O
fp	*(struct)
->	O
ctf_data_mmapped	O
)	O
ctf_munmap	O
(	O
fp	*(struct)
->	O
ctf_data_mmapped	O
,	O
fp	*(struct)
->	O
ctf_data_mmapped_len	O
)	O
;	O
free	(*(void))->(void)
(	O
fp	*(struct)
->	O
ctf_dynbase	O
)	O
;	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_syn_ext_strtab	O
)	O
;	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_link_inputs	O
)	O
;	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_link_outputs	O
)	O
;	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_link_type_mapping	O
)	O
;	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_link_cu_mapping	O
)	O
;	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_add_processing	O
)	O
;	O
free	(*(void))->(void)
(	O
fp	*(struct)
->	O
ctf_sxlate	O
)	O
;	O
free	(*(void))->(void)
(	O
fp	*(struct)
->	O
ctf_txlate	O
)	O
;	O
free	(*(void))->(void)
(	O
fp	*(struct)
->	O
ctf_ptrtab	O
)	O
;	O
free	(*(void))->(void)
(	O
fp	*(struct)
->	O
ctf_header	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
free	(*(void))->(void)
(	O
fp	*(struct)
)	O
;	O
}	O
void	O
ctf_close	(*(struct))->(void)
(	O
ctf_archive_t	struct
*	O
arc	O
)	O
{	O
ctf_arc_close	(*(struct))->(void)
(	O
arc	O
)	O
;	O
}	O
ctf_archive_t	struct
*	O
ctf_get_arc	(*(struct))->(*(struct))
(	O
const	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
return	O
fp	*(struct)
->	O
ctf_archive	struct(long,long,long,long,long)
;	O
}	O
ctf_sect_t	struct(*(char),*(void),long,long)
ctf_getdatasect	(*(struct))->(struct(*(char),*(void),long,long))
(	O
const	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
return	O
fp	*(struct)
->	O
ctf_data	O
;	O
}	O
ctf_file_t	struct
*	O
ctf_parent_file	(*(struct))->(*(struct))
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
return	O
fp	*(struct)
->	O
ctf_parent	O
;	O
}	O
const	O
char	O
*	O
ctf_parent_name	(*(struct))->(*(char))
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
return	O
fp	*(struct)
->	O
ctf_parname	O
;	O
}	O
int	O
ctf_parent_name_set	(*(struct),*(char))->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
fp	*(struct)
->	O
ctf_dynparname	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
fp	*(struct)
->	O
ctf_dynparname	O
)	O
;	O
if	O
(	O
(	O
fp	*(struct)
->	O
ctf_dynparname	O
=	O
strdup	O
(	O
name	*(char)
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ENOMEM	O
)	O
)	O
;	O
fp	*(struct)
->	O
ctf_parname	O
=	O
fp	*(struct)
->	O
ctf_dynparname	O
;	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
ctf_cuname	(*(struct))->(*(char))
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
return	O
fp	*(struct)
->	O
ctf_cuname	(*(struct))->(*(char))
;	O
}	O
int	O
ctf_cuname_set	(*(struct),*(char))->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
fp	*(struct)
->	O
ctf_dyncuname	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
fp	*(struct)
->	O
ctf_dyncuname	O
)	O
;	O
if	O
(	O
(	O
fp	*(struct)
->	O
ctf_dyncuname	O
=	O
strdup	O
(	O
name	*(char)
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ENOMEM	O
)	O
)	O
;	O
fp	*(struct)
->	O
ctf_cuname	(*(struct))->(*(char))
=	O
fp	*(struct)
->	O
ctf_dyncuname	O
;	O
return	O
0	int
;	O
}	O
int	O
ctf_import	(*(struct),*(struct))->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_file_t	struct
*	O
pfp	O
)	O
{	O
if	O
(	O
fp	*(struct)
==	O
NULL	O
||	O
fp	*(struct)
==	O
pfp	O
||	O
(	O
pfp	O
!=	O
NULL	O
&&	O
pfp	O
->	O
ctf_refcnt	O
==	O
0	int
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EINVAL	O
)	O
)	O
;	O
if	O
(	O
pfp	O
!=	O
NULL	O
&&	O
pfp	O
->	O
ctf_dmodel	O
!=	O
fp	*(struct)
->	O
ctf_dmodel	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_DMODEL	int
)	O
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_parent	O
!=	O
NULL	O
)	O
{	O
fp	*(struct)
->	O
ctf_parent	O
->	O
ctf_refcnt	O
--	O
;	O
ctf_file_close	(*(struct))->(void)
(	O
fp	*(struct)
->	O
ctf_parent	O
)	O
;	O
fp	*(struct)
->	O
ctf_parent	O
=	O
NULL	O
;	O
}	O
if	O
(	O
pfp	O
!=	O
NULL	O
)	O
{	O
int	O
err	long
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_parname	O
==	O
NULL	O
)	O
if	O
(	O
(	O
err	long
=	O
ctf_parent_name_set	(*(struct),*(char))->(int)
(	O
fp	*(struct)
,	O
"PARENT"	*(char)
)	O
)	O
<	O
0	int
)	O
return	O
err	long
;	O
fp	*(struct)
->	O
ctf_flags	O
|=	O
LCTF_CHILD	O
;	O
pfp	O
->	O
ctf_refcnt	O
++	O
;	O
}	O
fp	*(struct)
->	O
ctf_parent	O
=	O
pfp	O
;	O
return	O
0	int
;	O
}	O
int	O
ctf_setmodel	(*(struct),int)->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
int	O
model	O
)	O
{	O
const	O
ctf_dmodel_t	O
*	O
dp	O
;	O
for	O
(	O
dp	O
=	O
_libctf_models	O
;	O
dp	O
->	O
ctd_name	O
!=	O
NULL	O
;	O
dp	O
++	O
)	O
{	O
if	O
(	O
dp	O
->	O
ctd_code	O
==	O
model	O
)	O
{	O
fp	*(struct)
->	O
ctf_dmodel	O
=	O
dp	O
;	O
return	O
0	int
;	O
}	O
}	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EINVAL	O
)	O
)	O
;	O
}	O
int	O
ctf_getmodel	(*(struct))->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
return	O
fp	*(struct)
->	O
ctf_dmodel	O
->	O
ctd_code	O
;	O
}	O
void	O
ctf_setspecific	(*(struct),*(void))->(void)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
void	O
*	O
data	*(void)
)	O
{	O
fp	*(struct)
->	O
ctf_specific	O
=	O
data	*(void)
;	O
}	O
void	O
*	O
ctf_getspecific	(*(struct))->(*(void))
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
return	O
fp	*(struct)
->	O
ctf_specific	O
;	O
}	O
