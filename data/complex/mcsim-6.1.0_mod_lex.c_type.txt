PSTR	*(char)
vrgszLexTypes	array(*(char))
[	O
]	O
=	O
{	O
"null-type??"	*(char)
,	O
"identifier"	*(char)
,	O
"integer"	*(char)
,	O
"integer-or-id"	*(char)
,	O
"floating-point"	*(char)
,	O
"float-or-id"	*(char)
,	O
"number"	*(char)
,	O
"number-or-id"	*(char)
,	O
"punctuation"	*(char)
,	O
"invalid lexical type"	*(char)
,	O
"invalid lexical type"	*(char)
,	O
"invalid lexical type"	*(char)
,	O
"invalid lexical type"	*(char)
,	O
"invalid lexical type"	*(char)
,	O
"invalid lexical type"	*(char)
,	O
"invalid lexical type"	*(char)
,	O
"quoted-string"	*(char)
,	O
""	*(char)
}	O
;	O
long	O
CountChars	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
PFILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
pFileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
long	O
nChars	long
=	O
0	int
;	O
char	O
c	char
;	O
while	O
(	O
(	O
c	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pFileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
EOF	O
)	O
{	O
nChars	long
++	O
;	O
}	O
rewind	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
pFileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
(	O
nChars	long
)	O
;	O
}	O
BOOL	int
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),array(char),int)->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
PSTRLEX	array(char)
szLex	*(char)
,	O
int	O
iType	int
)	O
{	O
int	O
iLex	int
,	O
iErr	int
;	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szLex	*(char)
,	O
&	O
iLex	int
)	O
;	O
if	O
(	O
(	O
iErr	int
=	O
!	O
(	O
iType	int
&	O
iLex	int
)	O
)	O
)	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_LEXEXPECTED	int
,	O
vrgszLexTypes	array(*(char))
[	O
iType	int
]	O
,	O
szLex	*(char)
)	O
;	O
return	O
(	O
iErr	int
)	O
;	O
}	O
long	O
EvalAtom	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(*(char)),*(char),*(int))->(long)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
long	O
index	(*(char),int)->(*(char))
,	O
PSTR	*(char)
*	O
szExp	*(*(char))
,	O
PSTR	*(char)
szToken	*(char)
,	O
PINT	*(int)
piType	*(int)
)	O
{	O
long	O
result	long
=	O
0	int
;	O
switch	O
(	O
*	O
piType	*(int)
)	O
{	O
case	O
LX_IDENTIFIER	int
:	O
result	long
=	O
index	(*(char),int)->(*(char))
;	O
GetToken	(*(*(char)),*(char),*(int))->(void)
(	O
szExp	*(*(char))
,	O
szToken	*(char)
,	O
piType	*(int)
)	O
;	O
break	O
;	O
case	O
LX_INTEGER	int
:	O
result	long
=	O
atol	(*(char))->(long)
(	O
szToken	*(char)
)	O
;	O
GetToken	(*(*(char)),*(char),*(int))->(void)
(	O
szExp	*(*(char))
,	O
szToken	*(char)
,	O
piType	*(int)
)	O
;	O
break	O
;	O
default	O
:	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_UNEXPECTED	int
|	O
RE_FATAL	int
,	O
*	O
szExp	*(*(char))
,	O
"(While parsing bracketed expression)"	*(char)
)	O
;	O
}	O
return	O
(	O
result	long
)	O
;	O
}	O
long	O
EvalParen	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(*(char)),*(char),*(int))->(long)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
long	O
index	(*(char),int)->(*(char))
,	O
PSTR	*(char)
*	O
szExp	*(*(char))
,	O
PSTR	*(char)
szToken	*(char)
,	O
PINT	*(int)
piType	*(int)
)	O
{	O
long	O
result	long
;	O
if	O
(	O
*	O
szToken	*(char)
==	O
'('	O
)	O
{	O
GetToken	(*(*(char)),*(char),*(int))->(void)
(	O
szExp	*(*(char))
,	O
szToken	*(char)
,	O
piType	*(int)
)	O
;	O
result	long
=	O
EvalSum	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(*(char)),*(char),*(int))->(long)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
index	(*(char),int)->(*(char))
,	O
szExp	*(*(char))
,	O
szToken	*(char)
,	O
piType	*(int)
)	O
;	O
if	O
(	O
*	O
szToken	*(char)
!=	O
')'	O
)	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_UNEXPECTED	int
|	O
RE_FATAL	int
,	O
*	O
szExp	*(*(char))
,	O
"(While parsing bracketed expression)"	*(char)
)	O
;	O
GetToken	(*(*(char)),*(char),*(int))->(void)
(	O
szExp	*(*(char))
,	O
szToken	*(char)
,	O
piType	*(int)
)	O
;	O
}	O
else	O
result	long
=	O
EvalAtom	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(*(char)),*(char),*(int))->(long)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
index	(*(char),int)->(*(char))
,	O
szExp	*(*(char))
,	O
szToken	*(char)
,	O
piType	*(int)
)	O
;	O
return	O
(	O
result	long
)	O
;	O
}	O
long	O
EvalProd	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(*(char)),*(char),*(int))->(long)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
long	O
index	(*(char),int)->(*(char))
,	O
PSTR	*(char)
*	O
szExp	*(*(char))
,	O
PSTR	*(char)
szToken	*(char)
,	O
PINT	*(int)
piType	*(int)
)	O
{	O
register	O
char	O
cOperator	char
;	O
long	O
result	long
,	O
dTmp	long
;	O
result	long
=	O
EvalUnary	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(*(char)),*(char),*(int))->(long)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
index	(*(char),int)->(*(char))
,	O
szExp	*(*(char))
,	O
szToken	*(char)
,	O
piType	*(int)
)	O
;	O
while	O
(	O
(	O
(	O
cOperator	char
=	O
*	O
szToken	*(char)
)	O
==	O
'*'	O
)	O
||	O
(	O
cOperator	char
==	O
'/'	O
)	O
)	O
{	O
GetToken	(*(*(char)),*(char),*(int))->(void)
(	O
szExp	*(*(char))
,	O
szToken	*(char)
,	O
piType	*(int)
)	O
;	O
dTmp	long
=	O
EvalUnary	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(*(char)),*(char),*(int))->(long)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
index	(*(char),int)->(*(char))
,	O
szExp	*(*(char))
,	O
szToken	*(char)
,	O
piType	*(int)
)	O
;	O
switch	O
(	O
cOperator	char
)	O
{	O
case	O
'*'	O
:	O
result	long
=	O
result	long
*	O
dTmp	long
;	O
return	O
(	O
result	long
)	O
;	O
case	O
'/'	O
:	O
result	long
=	O
result	long
/	O
dTmp	long
;	O
return	O
(	O
result	long
)	O
;	O
default	O
:	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_UNEXPECTED	int
|	O
RE_FATAL	int
,	O
*	O
szExp	*(*(char))
,	O
"(While parsing bracketed expression)"	*(char)
)	O
;	O
}	O
}	O
return	O
(	O
result	long
)	O
;	O
}	O
long	O
EvalSum	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(*(char)),*(char),*(int))->(long)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
long	O
index	(*(char),int)->(*(char))
,	O
PSTR	*(char)
*	O
szExp	*(*(char))
,	O
PSTR	*(char)
szToken	*(char)
,	O
PINT	*(int)
piType	*(int)
)	O
{	O
register	O
char	O
cOperator	char
;	O
long	O
result	long
,	O
dTmp	long
;	O
result	long
=	O
EvalProd	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(*(char)),*(char),*(int))->(long)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
index	(*(char),int)->(*(char))
,	O
szExp	*(*(char))
,	O
szToken	*(char)
,	O
piType	*(int)
)	O
;	O
while	O
(	O
(	O
(	O
cOperator	char
=	O
*	O
szToken	*(char)
)	O
==	O
'+'	O
)	O
||	O
(	O
cOperator	char
==	O
'-'	O
)	O
)	O
{	O
GetToken	(*(*(char)),*(char),*(int))->(void)
(	O
szExp	*(*(char))
,	O
szToken	*(char)
,	O
piType	*(int)
)	O
;	O
dTmp	long
=	O
EvalProd	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(*(char)),*(char),*(int))->(long)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
index	(*(char),int)->(*(char))
,	O
szExp	*(*(char))
,	O
szToken	*(char)
,	O
piType	*(int)
)	O
;	O
switch	O
(	O
cOperator	char
)	O
{	O
case	O
'-'	O
:	O
result	long
=	O
result	long
-	O
dTmp	long
;	O
break	O
;	O
case	O
'+'	O
:	O
result	long
=	O
result	long
+	O
dTmp	long
;	O
break	O
;	O
default	O
:	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_UNEXPECTED	int
|	O
RE_FATAL	int
,	O
*	O
szExp	*(*(char))
,	O
"(While parsing bracketed expression)"	*(char)
)	O
;	O
}	O
}	O
return	O
(	O
result	long
)	O
;	O
}	O
long	O
EvaluateExpression	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(char))->(long)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
long	O
index	(*(char),int)->(*(char))
,	O
PSTR	*(char)
szExpress	*(char)
)	O
{	O
PSTRLEX	array(char)
szToken	*(char)
;	O
int	O
iType	int
;	O
GetToken	(*(*(char)),*(char),*(int))->(void)
(	O
&	O
szExpress	*(char)
,	O
szToken	*(char)
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
!	O
*	O
szToken	*(char)
)	O
{	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_UNEXPECTED	int
|	O
RE_FATAL	int
,	O
szExpress	*(char)
,	O
"(While parsing bracketed expression)"	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
return	O
EvalSum	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(*(char)),*(char),*(int))->(long)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
index	(*(char),int)->(*(char))
,	O
&	O
szExpress	*(char)
,	O
szToken	*(char)
,	O
&	O
iType	int
)	O
;	O
}	O
long	O
EvalUnary	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(*(char)),*(char),*(int))->(long)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
long	O
index	(*(char),int)->(*(char))
,	O
PSTR	*(char)
*	O
szExp	*(*(char))
,	O
PSTR	*(char)
szToken	*(char)
,	O
PINT	*(int)
piType	*(int)
)	O
{	O
register	O
char	O
cOperator	char
;	O
long	O
result	long
;	O
cOperator	char
=	O
0	int
;	O
if	O
(	O
(	O
*	O
piType	*(int)
==	O
LX_EQNPUNCT	int
)	O
&&	O
(	O
(	O
*	O
szToken	*(char)
==	O
'+'	O
)	O
||	O
(	O
*	O
szToken	*(char)
==	O
'-'	O
)	O
)	O
)	O
{	O
cOperator	char
=	O
*	O
szToken	*(char)
;	O
GetToken	(*(*(char)),*(char),*(int))->(void)
(	O
szExp	*(*(char))
,	O
szToken	*(char)
,	O
piType	*(int)
)	O
;	O
}	O
result	long
=	O
EvalParen	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(*(char)),*(char),*(int))->(long)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
index	(*(char),int)->(*(char))
,	O
szExp	*(*(char))
,	O
szToken	*(char)
,	O
piType	*(int)
)	O
;	O
if	O
(	O
cOperator	char
==	O
'-'	O
)	O
result	long
=	O
-	O
result	long
;	O
return	O
(	O
result	long
)	O
;	O
}	O
int	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long)->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
long	O
lBuffer_size	long
)	O
{	O
int	O
iReturn	int
=	O
0	int
;	O
int	O
iOffset	int
;	O
if	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
&&	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
&&	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufOrg	*(char)
)	O
{	O
if	O
(	O
(	O
iOffset	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufOrg	*(char)
,	O
1	int
,	O
lBuffer_size	long
,	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
{	O
iReturn	int
=	O
(	O
int	O
)	O
iOffset	int
;	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
=	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufOrg	*(char)
;	O
}	O
else	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
iReturn	int
=	O
EOF	O
;	O
else	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_FATAL	int
,	O
NULL	O
,	O
"Unexpected end of file."	*(char)
)	O
;	O
}	O
return	O
(	O
iReturn	int
)	O
;	O
}	O
void	O
GetToken	(*(*(char)),*(char),*(int))->(void)
(	O
PSTR	*(char)
*	O
szExp	*(*(char))
,	O
PSTR	*(char)
szToken	*(char)
,	O
PINT	*(int)
piType	*(int)
)	O
{	O
register	O
PSTR	*(char)
cTmp	*(char)
;	O
*	O
piType	*(int)
=	O
0	int
;	O
cTmp	*(char)
=	O
szToken	*(char)
;	O
*	O
cTmp	*(char)
=	O
'\0'	O
;	O
if	O
(	O
!	O
(	O
*	O
szExp	*(*(char))
)	O
)	O
return	O
;	O
while	O
(	O
isspace	(int)->(int)
(	O
*	O
*	O
szExp	*(*(char))
)	O
)	O
(	O
*	O
szExp	*(*(char))
)	O
++	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"+-*/()"	*(char)
,	O
*	O
*	O
szExp	*(*(char))
)	O
)	O
{	O
*	O
piType	*(int)
=	O
LX_EQNPUNCT	int
;	O
*	O
cTmp	*(char)
=	O
*	O
*	O
szExp	*(*(char))
;	O
cTmp	*(char)
++	O
;	O
(	O
*	O
szExp	*(*(char))
)	O
++	O
;	O
}	O
else	O
if	O
(	O
*	O
*	O
szExp	*(*(char))
==	O
'i'	O
)	O
{	O
*	O
piType	*(int)
=	O
LX_IDENTIFIER	int
;	O
while	O
(	O
!	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"+-*/()"	*(char)
,	O
*	O
*	O
szExp	*(*(char))
)	O
||	O
(	O
*	O
*	O
szExp	*(*(char))
==	O
'\0'	O
)	O
)	O
)	O
{	O
*	O
cTmp	*(char)
=	O
*	O
*	O
szExp	*(*(char))
;	O
cTmp	*(char)
++	O
;	O
(	O
*	O
szExp	*(*(char))
)	O
++	O
;	O
}	O
}	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
*	O
szExp	*(*(char))
)	O
)	O
{	O
*	O
piType	*(int)
=	O
LX_INTEGER	int
;	O
while	O
(	O
!	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"+-*/()"	*(char)
,	O
*	O
*	O
szExp	*(*(char))
)	O
||	O
(	O
*	O
*	O
szExp	*(*(char))
==	O
'\0'	O
)	O
)	O
)	O
{	O
*	O
cTmp	*(char)
=	O
*	O
*	O
szExp	*(*(char))
;	O
cTmp	*(char)
++	O
;	O
(	O
*	O
szExp	*(*(char))
)	O
++	O
;	O
}	O
}	O
*	O
cTmp	*(char)
=	O
'\0'	O
;	O
}	O
BOOL	int
InitBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(char))->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
long	O
lSize	long
,	O
PSTR	*(char)
szFileIn	*(char)
)	O
{	O
BOOL	int
bReturn	int
=	O
0	int
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
return	O
FALSE	int
;	O
if	O
(	O
lSize	long
<	O
0	int
)	O
{	O
if	O
(	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
szFileIn	*(char)
,	O
"r"	*(char)
)	O
)	O
)	O
{	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
lBufSize	long
=	O
CountChars	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_FILENOTFOUND	int
|	O
RE_FATAL	int
,	O
szFileIn	*(char)
,	O
NULL	O
)	O
;	O
}	O
else	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
lBufSize	long
=	O
lSize	long
;	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
iLineNum	int
=	O
1	int
;	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
iLNPrev	int
=	O
0	int
;	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
cErrors	int
=	O
0	int
;	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pInfo	*(void)
=	O
NULL	O
;	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pTempInfo	*(void)
=	O
NULL	O
;	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
=	O
NULL	O
;	O
if	O
(	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
szFileIn	*(char)
,	O
"r"	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufOrg	*(char)
=	O
(	O
PBUF	*(char)
)	O
malloc	(long)->(*(void))
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
lBufSize	long
)	O
)	O
)	O
bReturn	int
=	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
lBufSize	long
)	O
;	O
else	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"InitBuffer"	*(char)
,	O
NULL	O
)	O
;	O
}	O
else	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_FILENOTFOUND	int
|	O
RE_FATAL	int
,	O
szFileIn	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
lSize	long
<	O
0	int
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
(	O
bReturn	int
)	O
;	O
}	O
void	O
MakeStringBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pBuf	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pbufStr	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
PSTR	*(char)
sz	*(char)
)	O
{	O
pbufStr	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
pbufStr	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
=	O
pbufStr	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufOrg	*(char)
=	O
sz	*(char)
;	O
pbufStr	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
iLineNum	int
=	O
0	int
;	O
pbufStr	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
iLNPrev	int
=	O
0	int
;	O
pbufStr	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pInfo	*(void)
=	O
(	O
pBuf	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
?	O
pBuf	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pInfo	*(void)
:	O
NULL	O
)	O
;	O
if	O
(	O
pBuf	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
{	O
pbufStr	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
iLineNum	int
=	O
pBuf	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
iLineNum	int
;	O
pbufStr	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
iLNPrev	int
=	O
TRUE	int
;	O
}	O
}	O
void	O
FlushBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
{	O
PBUF	*(char)
pbuf	*(char)
=	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufOrg	*(char)
;	O
while	O
(	O
*	O
pbuf	*(char)
)	O
printf	(*(char))->(int)
(	O
"%c"	*(char)
,	O
*	O
pbuf	*(char)
++	O
)	O
;	O
printf	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
void	O
GetArrayBounds	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(long),*(long))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
PLONG	*(long)
piLB	*(long)
,	O
PLONG	*(long)
piUB	*(long)
)	O
{	O
PSTRLEX	array(char)
szTmp	array(char)
;	O
if	O
(	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szTmp	array(char)
,	O
LX_INTEGER	int
)	O
)	O
{	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_INIT	int
|	O
RE_FATAL	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
*	O
piLB	*(long)
=	O
atol	(*(char))->(long)
(	O
szTmp	array(char)
)	O
;	O
if	O
(	O
*	O
piLB	*(long)
<	O
0	int
)	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_POSITIVE	O
|	O
RE_FATAL	int
,	O
szTmp	array(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
NextChar	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(char)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
==	O
'-'	O
)	O
{	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
++	O
;	O
if	O
(	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szTmp	array(char)
,	O
LX_INTEGER	int
)	O
)	O
{	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_INIT	int
|	O
RE_FATAL	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
*	O
piUB	*(long)
=	O
atol	(*(char))->(long)
(	O
szTmp	array(char)
)	O
+	O
1	int
;	O
if	O
(	O
*	O
piUB	*(long)
<=	O
*	O
piLB	*(long)
)	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_UNKNOWN	int
|	O
RE_FATAL	int
,	O
""	*(char)
,	O
"Upper bound must be higher than lower bound"	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szTmp	array(char)
,	O
']'	O
)	O
)	O
{	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"]"	*(char)
,	O
NULL	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szTmp	array(char)
,	O
']'	O
)	O
)	O
{	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"]"	*(char)
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
*	O
piUB	*(long)
=	O
*	O
piLB	*(long)
+	O
1	int
;	O
}	O
}	O
}	O
}	O
void	O
GetaString	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
PSTR	*(char)
szLex	*(char)
)	O
{	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
||	O
!	O
szLex	*(char)
)	O
return	O
;	O
if	O
(	O
IsString	O
(	O
(	O
PSTR	*(char)
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
)	O
{	O
do	O
szLex	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
++	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
;	O
while	O
(	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
&&	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
!=	O
CH_STRDELIM	O
)	O
&&	O
(	O
i	int
<	O
MAX_LEX	int
-	O
1	int
)	O
)	O
;	O
}	O
if	O
(	O
i	int
==	O
MAX_LEX	int
-	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"\n***Error: max string length MAX_LEX exceeded in: %s\n"	*(char)
,	O
szLex	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Exiting...\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
if	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
==	O
CH_STRDELIM	O
)	O
{	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
++	O
;	O
i	int
--	O
;	O
}	O
szLex	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
BOOL	int
GetFuncArgs	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,array(int),*(char),array(long),array(long))->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
int	O
nArgs	int
,	O
int	O
rgiArgTypes	array(int)
[	O
]	O
,	O
PSTR	*(char)
szArgs	*(char)
,	O
long	O
rgiLowerB	array(long)
[	O
]	O
,	O
long	O
rgiUpperB	array(long)
[	O
]	O
)	O
{	O
BOOL	int
bOK	int
=	O
TRUE	int
;	O
int	O
i	int
,	O
iType	int
;	O
PSTRLEX	array(char)
szPunct	array(char)
;	O
if	O
(	O
!	O
(	O
bOK	int
=	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szPunct	array(char)
,	O
CH_LPAREN	O
)	O
)	O
)	O
{	O
szPunct	array(char)
[	O
1	int
]	O
=	O
CH_LPAREN	O
;	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_EXPECTED	int
,	O
szPunct	array(char)
,	O
NULL	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nArgs	int
&&	O
bOK	int
;	O
i	int
++	O
,	O
szArgs	*(char)
+=	O
MAX_LEX	int
)	O
{	O
if	O
(	O
i	int
)	O
if	O
(	O
!	O
(	O
bOK	int
=	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szArgs	*(char)
,	O
','	O
)	O
)	O
)	O
{	O
*	O
(	O
szArgs	*(char)
+	O
1	int
)	O
=	O
','	O
;	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_EXPECTED	int
,	O
szArgs	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
}	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szArgs	*(char)
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
!	O
(	O
bOK	int
&=	O
(	O
iType	int
&	O
rgiArgTypes	array(int)
[	O
i	int
]	O
)	O
>	O
0	int
)	O
)	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_LEXEXPECTED	int
,	O
vrgszLexTypes	array(*(char))
[	O
rgiArgTypes	array(int)
[	O
i	int
]	O
]	O
,	O
szArgs	*(char)
)	O
;	O
rgiLowerB	array(long)
[	O
i	int
]	O
=	O
rgiUpperB	array(long)
[	O
i	int
]	O
=	O
-	O
1	int
;	O
if	O
(	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szPunct	array(char)
,	O
'['	O
)	O
)	O
GetArrayBounds	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(long),*(long))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
&	O
rgiLowerB	array(long)
[	O
i	int
]	O
,	O
&	O
rgiUpperB	array(long)
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
!	O
(	O
bOK	int
=	O
(	O
szPunct	array(char)
[	O
0	int
]	O
==	O
CH_RPAREN	O
||	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szPunct	array(char)
,	O
CH_RPAREN	O
)	O
)	O
)	O
)	O
{	O
szPunct	array(char)
[	O
1	int
]	O
=	O
CH_RPAREN	O
;	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_EXPECTED	int
,	O
szPunct	array(char)
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
bOK	int
)	O
;	O
}	O
void	O
GetIdentifier	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
PSTR	*(char)
szLex	*(char)
)	O
{	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
||	O
!	O
szLex	*(char)
)	O
return	O
;	O
if	O
(	O
isalpha	(int)->(int)
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
||	O
IsUnderscore	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
)	O
{	O
do	O
{	O
szLex	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
++	O
;	O
}	O
while	O
(	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
&&	O
(	O
isalnum	(int)->(int)
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
||	O
IsUnderscore	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
)	O
&&	O
(	O
i	int
<	O
MAX_LEX	int
-	O
1	int
)	O
)	O
;	O
}	O
szLex	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
void	O
GetInteger	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),*(int))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
PINT	*(int)
piLexType	*(int)
)	O
{	O
int	O
i	int
=	O
0	int
;	O
char	O
c	char
;	O
BOOL	int
bHasSign	int
=	O
FALSE	int
;	O
enum	O
States	enum(int,int,int)
{	O
Start	int
,	O
Digits1	int
,	O
End	int
}	O
eState	enum(int,int,int)
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
||	O
!	O
szLex	*(char)
||	O
!	O
piLexType	*(int)
)	O
return	O
;	O
eState	enum(int,int,int)
=	O
Start	int
;	O
*	O
piLexType	*(int)
=	O
LX_NULL	int
;	O
while	O
(	O
(	O
c	char
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
&&	O
i	int
<	O
MAX_LEX	int
-	O
1	int
&&	O
eState	enum(int,int,int)
!=	O
End	int
)	O
{	O
switch	O
(	O
eState	enum(int,int,int)
)	O
{	O
case	O
Start	int
:	O
if	O
(	O
!	O
bHasSign	int
&&	O
IsSign	O
(	O
c	char
)	O
)	O
bHasSign	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
)	O
{	O
*	O
piLexType	*(int)
=	O
LX_INTEGER	int
;	O
eState	enum(int,int,int)
=	O
Digits1	int
;	O
}	O
else	O
eState	enum(int,int,int)
=	O
End	int
;	O
break	O
;	O
case	O
Digits1	int
:	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
c	char
)	O
)	O
eState	enum(int,int,int)
=	O
End	int
;	O
break	O
;	O
case	O
End	int
:	O
break	O
;	O
}	O
if	O
(	O
eState	enum(int,int,int)
!=	O
End	int
)	O
szLex	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
++	O
;	O
}	O
szLex	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
void	O
GetNumber	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),*(int))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
PINT	*(int)
piLexType	*(int)
)	O
{	O
int	O
i	int
=	O
0	int
;	O
char	O
c	char
;	O
BOOL	int
bHasSign	int
=	O
FALSE	int
;	O
BOOL	int
bLeadingDigits	int
=	O
FALSE	int
;	O
enum	O
States	enum(int,int,int)
{	O
Start	int
,	O
Digits1	int
,	O
Point	int
,	O
Digits2	int
,	O
Exp	int
,	O
ExpSign	int
,	O
Digits3	int
,	O
End	int
}	O
eState	enum(int,int,int)
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
||	O
!	O
szLex	*(char)
||	O
!	O
piLexType	*(int)
)	O
return	O
;	O
eState	enum(int,int,int)
=	O
Start	int
;	O
*	O
piLexType	*(int)
=	O
LX_NULL	int
;	O
while	O
(	O
(	O
c	char
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
&&	O
i	int
<	O
MAX_LEX	int
-	O
1	int
&&	O
eState	enum(int,int,int)
!=	O
End	int
)	O
{	O
switch	O
(	O
eState	enum(int,int,int)
)	O
{	O
case	O
Start	int
:	O
if	O
(	O
c	char
==	O
'.'	O
)	O
eState	enum(int,int,int)
=	O
Point	int
;	O
else	O
if	O
(	O
!	O
bHasSign	int
&&	O
IsSign	O
(	O
c	char
)	O
)	O
bHasSign	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
)	O
{	O
bLeadingDigits	int
=	O
*	O
piLexType	*(int)
=	O
LX_INTEGER	int
;	O
eState	enum(int,int,int)
=	O
Digits1	int
;	O
}	O
else	O
eState	enum(int,int,int)
=	O
End	int
;	O
break	O
;	O
case	O
Digits1	int
:	O
if	O
(	O
c	char
==	O
'.'	O
)	O
eState	enum(int,int,int)
=	O
Point	int
;	O
else	O
if	O
(	O
c	char
==	O
'e'	O
||	O
c	char
==	O
'E'	O
)	O
eState	enum(int,int,int)
=	O
Exp	int
;	O
else	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
c	char
)	O
)	O
eState	enum(int,int,int)
=	O
End	int
;	O
break	O
;	O
case	O
Point	int
:	O
*	O
piLexType	*(int)
=	O
LX_FLOAT	int
;	O
if	O
(	O
bLeadingDigits	int
&&	O
(	O
c	char
==	O
'e'	O
||	O
c	char
==	O
'E'	O
)	O
)	O
eState	enum(int,int,int)
=	O
Exp	int
;	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
c	char
)	O
)	O
eState	enum(int,int,int)
=	O
Digits2	int
;	O
else	O
{	O
if	O
(	O
!	O
bLeadingDigits	int
)	O
*	O
piLexType	*(int)
=	O
LX_NULL	int
;	O
eState	enum(int,int,int)
=	O
End	int
;	O
}	O
break	O
;	O
case	O
Digits2	int
:	O
if	O
(	O
c	char
==	O
'e'	O
||	O
c	char
==	O
'E'	O
)	O
eState	enum(int,int,int)
=	O
Exp	int
;	O
else	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
c	char
)	O
)	O
eState	enum(int,int,int)
=	O
End	int
;	O
break	O
;	O
case	O
Exp	int
:	O
*	O
piLexType	*(int)
=	O
LX_FLOAT	int
;	O
if	O
(	O
IsSign	O
(	O
c	char
)	O
)	O
{	O
eState	enum(int,int,int)
=	O
ExpSign	int
;	O
break	O
;	O
}	O
case	O
ExpSign	int
:	O
if	O
(	O
isdigit	(int)->(int)
(	O
c	char
)	O
)	O
eState	enum(int,int,int)
=	O
Digits3	int
;	O
else	O
{	O
*	O
piLexType	*(int)
=	O
LX_NULL	int
;	O
eState	enum(int,int,int)
=	O
End	int
;	O
}	O
break	O
;	O
case	O
Digits3	int
:	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
c	char
)	O
)	O
eState	enum(int,int,int)
=	O
End	int
;	O
break	O
;	O
case	O
End	int
:	O
break	O
;	O
}	O
if	O
(	O
eState	enum(int,int,int)
!=	O
End	int
)	O
szLex	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
++	O
;	O
}	O
szLex	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
void	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),array(char),*(int))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
PSTRLEX	array(char)
szLex	*(char)
,	O
PINT	*(int)
piLexType	*(int)
)	O
{	O
static	O
char	O
vszEqnPunct	array(char)
[	O
]	O
=	O
"+-/*()><?:,!="	*(char)
;	O
char	O
c	char
;	O
BOOL	int
fDone	int
=	O
FALSE	int
;	O
*	O
piLexType	*(int)
=	O
LX_NULL	int
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
||	O
!	O
szLex	*(char)
||	O
!	O
piLexType	*(int)
||	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
||	O
!	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
)	O
return	O
;	O
while	O
(	O
!	O
fDone	int
)	O
{	O
fDone	int
=	O
TRUE	int
;	O
SkipWhitespace	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
;	O
if	O
(	O
!	O
EOB	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
)	O
{	O
c	char
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
;	O
if	O
(	O
c	char
==	O
CH_COMMENT	O
)	O
{	O
fDone	int
=	O
FALSE	int
;	O
SkipComment	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
;	O
}	O
else	O
if	O
(	O
isalpha	(int)->(int)
(	O
c	char
)	O
||	O
IsUnderscore	O
(	O
c	char
)	O
)	O
{	O
*	O
piLexType	*(int)
=	O
LX_IDENTIFIER	int
;	O
GetIdentifier	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szLex	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
c	char
)	O
||	O
c	char
==	O
'.'	O
||	O
IsSign	O
(	O
c	char
)	O
)	O
{	O
GetNumber	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szLex	*(char)
,	O
piLexType	*(int)
)	O
;	O
if	O
(	O
IsSign	O
(	O
c	char
)	O
&&	O
!	O
*	O
piLexType	*(int)
)	O
{	O
szLex	*(char)
[	O
0	int
]	O
=	O
c	char
;	O
szLex	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
*	O
piLexType	*(int)
=	O
LX_EQNPUNCT	int
;	O
}	O
}	O
else	O
if	O
(	O
c	char
==	O
CH_STRDELIM	O
)	O
{	O
*	O
piLexType	*(int)
=	O
LX_STRING	int
;	O
GetaString	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szLex	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
vszEqnPunct	array(char)
,	O
c	char
)	O
)	O
{	O
*	O
piLexType	*(int)
=	O
LX_EQNPUNCT	int
;	O
szLex	*(char)
[	O
0	int
]	O
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
++	O
;	O
if	O
(	O
(	O
c	char
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
!=	O
'='	O
)	O
szLex	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
else	O
if	O
(	O
szLex	*(char)
[	O
0	int
]	O
==	O
'!'	O
||	O
szLex	*(char)
[	O
0	int
]	O
==	O
'<'	O
||	O
szLex	*(char)
[	O
0	int
]	O
==	O
'>'	O
||	O
szLex	*(char)
[	O
0	int
]	O
==	O
'='	O
)	O
{	O
szLex	*(char)
[	O
1	int
]	O
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
++	O
;	O
szLex	*(char)
[	O
2	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
else	O
{	O
*	O
piLexType	*(int)
=	O
LX_PUNCT	int
;	O
szLex	*(char)
[	O
0	int
]	O
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
++	O
;	O
szLex	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
}	O
}	O
void	O
PreventLexSplit	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int)->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
int	O
iOffset	int
)	O
{	O
long	O
lDelta	long
;	O
PBUF	*(char)
pbufEOB	*(char)
=	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufOrg	*(char)
+	O
iOffset	int
;	O
PBUF	*(char)
pbufEOBOld	*(char)
;	O
if	O
(	O
!	O
EOB	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
||	O
(	O
iOffset	int
==	O
BUFFER_SIZE	int
)	O
)	O
{	O
pbufEOBOld	*(char)
=	O
pbufEOB	*(char)
;	O
while	O
(	O
*	O
(	O
--	O
pbufEOB	*(char)
)	O
!=	O
CH_EOLN	O
)	O
;	O
*	O
pbufEOB	*(char)
=	O
'\0'	O
;	O
if	O
(	O
(	O
lDelta	long
=	O
(	O
long	O
)	O
(	O
pbufEOB	*(char)
-	O
pbufEOBOld	*(char)
)	O
)	O
)	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
lDelta	long
,	O
SEEK_CUR	int
)	O
;	O
}	O
else	O
*	O
pbufEOB	*(char)
=	O
'\0'	O
;	O
}	O
void	O
SkipComment	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
{	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
return	O
;	O
if	O
(	O
!	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
BUFFER_SIZE	int
)	O
;	O
while	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
++	O
!=	O
CH_EOLN	O
)	O
if	O
(	O
!	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
if	O
(	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
BUFFER_SIZE	int
)	O
==	O
EOF	O
)	O
break	O
;	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
iLineNum	int
++	O
;	O
if	O
(	O
!	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
BUFFER_SIZE	int
)	O
;	O
}	O
char	O
NextChar	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(char)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
{	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
||	O
(	O
!	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
&&	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
BUFFER_SIZE	int
)	O
==	O
EOF	O
)	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
return	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
;	O
}	O
int	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),char)->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
char	O
chPunct	char
)	O
{	O
int	O
iReturn	int
,	O
iType	int
;	O
iReturn	int
=	O
SkipWhitespace	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
;	O
if	O
(	O
NextChar	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(char)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
==	O
chPunct	char
)	O
{	O
iReturn	int
=	O
TRUE	int
;	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szLex	*(char)
,	O
&	O
iType	int
)	O
;	O
}	O
return	O
(	O
iReturn	int
)	O
;	O
}	O
int	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),char)->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
char	O
chPunct	char
)	O
{	O
int	O
iType	int
;	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szLex	*(char)
,	O
&	O
iType	int
)	O
;	O
return	O
(	O
(	O
iType	int
==	O
LX_PUNCT	int
||	O
iType	int
==	O
LX_EQNPUNCT	int
)	O
&&	O
szLex	*(char)
[	O
0	int
]	O
==	O
chPunct	char
)	O
;	O
}	O
int	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),char)->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
char	O
chPunct	char
)	O
{	O
int	O
iReturn	int
;	O
iReturn	int
=	O
!	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szLex	*(char)
,	O
chPunct	char
)	O
;	O
if	O
(	O
iReturn	int
)	O
{	O
szLex	*(char)
[	O
1	int
]	O
=	O
chPunct	char
;	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_EXPECTED	int
,	O
szLex	*(char)
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
iReturn	int
)	O
;	O
}	O
void	O
EatStatement	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pib	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
{	O
char	O
c	char
;	O
if	O
(	O
!	O
pib	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
return	O
;	O
while	O
(	O
(	O
c	char
=	O
NextChar	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(char)
(	O
pib	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
)	O
&&	O
(	O
c	char
!=	O
CH_STMTTERM	O
)	O
)	O
{	O
if	O
(	O
c	char
==	O
CH_EOLN	O
)	O
pib	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
iLineNum	int
++	O
;	O
pib	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
++	O
;	O
}	O
if	O
(	O
c	char
)	O
pib	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
++	O
;	O
}	O
void	O
GetStatement	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),int)->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
PSTR	*(char)
szStmt	*(char)
,	O
int	O
iKWCode	int
)	O
{	O
int	O
i	int
=	O
0	int
;	O
int	O
fDone	int
=	O
0	int
;	O
int	O
iParCount	int
=	O
0	int
;	O
BOOL	int
bParOpen	int
=	O
FALSE	int
;	O
BOOL	int
bEscaped	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
||	O
!	O
szStmt	*(char)
)	O
return	O
;	O
SkipWhitespace	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
;	O
if	O
(	O
!	O
EOB	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
)	O
{	O
while	O
(	O
!	O
fDone	int
)	O
{	O
if	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
{	O
if	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
==	O
'\\'	O
)	O
{	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
++	O
;	O
if	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
!=	O
CH_COMMENT	O
)	O
{	O
char	O
szTmp	array(char)
[	O
2	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
szTmp	array(char)
,	O
"\\%c"	*(char)
,	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
;	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_UNEXPESCAPE	int
|	O
RE_FATAL	int
,	O
szTmp	array(char)
,	O
NULL	O
)	O
;	O
}	O
bEscaped	int
=	O
TRUE	int
;	O
}	O
fDone	int
=	O
(	O
NextChar	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(char)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
==	O
CH_STMTTERM	O
)	O
;	O
if	O
(	O
iKWCode	int
==	O
KM_INLINE	int
)	O
fDone	int
=	O
(	O
fDone	int
&&	O
!	O
bParOpen	int
)	O
;	O
if	O
(	O
!	O
fDone	int
)	O
{	O
if	O
(	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
==	O
CH_COMMENT	O
)	O
&&	O
!	O
bEscaped	int
)	O
{	O
SkipComment	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
bEscaped	int
)	O
bEscaped	int
=	O
FALSE	int
;	O
if	O
(	O
i	int
<	O
MAX_EQN	int
-	O
2	int
)	O
{	O
if	O
(	O
(	O
szStmt	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
++	O
)	O
==	O
CH_EOLN	O
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
iLineNum	int
++	O
;	O
if	O
(	O
(	O
char	O
)	O
szStmt	*(char)
[	O
i	int
-	O
1	int
]	O
==	O
'('	O
)	O
{	O
iParCount	int
++	O
;	O
bParOpen	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
(	O
char	O
)	O
szStmt	*(char)
[	O
i	int
-	O
1	int
]	O
==	O
')'	O
)	O
iParCount	int
--	O
;	O
if	O
(	O
(	O
iParCount	int
==	O
0	int
)	O
&&	O
bParOpen	int
)	O
bParOpen	int
=	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
bParOpen	int
)	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_UNBALPAR	O
|	O
RE_FATAL	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
else	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_EQNTOOLONG	O
|	O
RE_FATAL	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
bParOpen	int
)	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_UNBALPAR	O
|	O
RE_FATAL	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
}	O
else	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_UNBALPAR	O
|	O
RE_FATAL	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
while	O
(	O
isspace	(int)->(int)
(	O
szStmt	*(char)
[	O
i	int
-	O
1	int
]	O
)	O
)	O
i	int
=	O
i	int
-	O
1	int
;	O
szStmt	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
!	O
i	int
)	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"rvalue to assignment"	*(char)
,	O
NULL	O
)	O
;	O
}	O
int	O
NextListItem	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),int,int,char)->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
int	O
bIdTypes	int
,	O
int	O
fItemNum	int
,	O
char	O
cListTerm	char
)	O
{	O
int	O
iType	int
,	O
iReturn	int
=	O
0	int
;	O
if	O
(	O
!	O
fItemNum	int
||	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szLex	*(char)
,	O
','	O
)	O
)	O
{	O
if	O
(	O
NextChar	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(char)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
!=	O
cListTerm	char
)	O
{	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
szLex	*(char)
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
(	O
iType	int
&	O
bIdTypes	int
)	O
)	O
iReturn	int
=	O
1	int
;	O
else	O
iReturn	int
=	O
-	O
1	int
;	O
}	O
}	O
return	O
(	O
iReturn	int
)	O
;	O
}	O
int	O
SkipWhitespace	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(int)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
{	O
char	O
c	char
;	O
int	O
fSkipped	int
=	O
0	int
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
return	O
0	int
;	O
if	O
(	O
!	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
&&	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
BUFFER_SIZE	int
)	O
;	O
while	O
(	O
isspace	(int)->(int)
(	O
c	char
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
||	O
c	char
==	O
CH_COMMENT	O
)	O
{	O
fSkipped	int
=	O
1	int
;	O
if	O
(	O
c	char
==	O
CH_COMMENT	O
)	O
SkipComment	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
)	O
;	O
else	O
{	O
if	O
(	O
c	char
==	O
'\n'	O
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
iLineNum	int
++	O
;	O
if	O
(	O
!	O
*	O
(	O
++	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pbufCur	*(char)
)	O
&&	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
->	O
pfileIn	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
if	O
(	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
BUFFER_SIZE	int
)	O
==	O
EOF	O
)	O
break	O
;	O
}	O
}	O
return	O
(	O
fSkipped	int
)	O
;	O
}	O
void	O
UnrollEquation	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(char),*(char))->(void)
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
long	O
index	(*(char),int)->(*(char))
,	O
PSTR	*(char)
szEqn	*(char)
,	O
PSTR	*(char)
szEqnU	*(char)
)	O
{	O
int	O
j	int
=	O
0	int
,	O
k	int
=	O
0	int
,	O
m	int
;	O
BOOL	int
bExpress	int
=	O
FALSE	int
;	O
PSTRLEX	array(char)
szExpression	array(char)
;	O
while	O
(	O
(	O
szEqn	*(char)
[	O
j	int
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
k	int
<	O
MAX_EQN	int
-	O
1	int
)	O
)	O
{	O
if	O
(	O
bExpress	int
)	O
{	O
m	int
=	O
0	int
;	O
while	O
(	O
(	O
szEqn	*(char)
[	O
j	int
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
szEqn	*(char)
[	O
j	int
]	O
!=	O
']'	O
)	O
&&	O
(	O
m	int
<	O
MAX_EQN	int
-	O
1	int
)	O
)	O
{	O
szExpression	array(char)
[	O
m	int
]	O
=	O
szEqn	*(char)
[	O
j	int
]	O
;	O
j	int
++	O
;	O
m	int
++	O
;	O
}	O
if	O
(	O
szEqn	*(char)
[	O
j	int
]	O
==	O
']'	O
)	O
{	O
j	int
++	O
;	O
bExpress	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
(	O
szEqn	*(char)
[	O
j	int
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
m	int
==	O
MAX_EQN	int
-	O
1	int
)	O
)	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_EQNTOOLONG	O
|	O
RE_FATAL	int
,	O
NULL	O
,	O
"(Occured while unrolling a loop)"	*(char)
)	O
;	O
szExpression	array(char)
[	O
m	int
]	O
=	O
'\0'	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
szExpression	array(char)
,	O
"%ld"	*(char)
,	O
EvaluateExpression	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),long,*(char))->(long)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
index	(*(char),int)->(*(char))
,	O
szExpression	array(char)
)	O
)	O
;	O
m	int
=	O
0	int
;	O
while	O
(	O
(	O
szExpression	array(char)
[	O
m	int
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
m	int
<	O
MAX_EQN	int
-	O
1	int
)	O
)	O
{	O
szEqnU	*(char)
[	O
k	int
]	O
=	O
szExpression	array(char)
[	O
m	int
]	O
;	O
k	int
++	O
;	O
m	int
++	O
;	O
}	O
}	O
else	O
switch	O
(	O
szEqn	*(char)
[	O
j	int
]	O
)	O
{	O
case	O
'['	O
:	O
szEqnU	*(char)
[	O
k	int
]	O
=	O
'_'	O
;	O
j	int
++	O
;	O
k	int
++	O
;	O
bExpress	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
']'	O
:	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_UNEXPECTED	int
|	O
RE_FATAL	int
,	O
"]"	*(char)
,	O
"(Could be nested brackets)"	*(char)
)	O
;	O
default	O
:	O
szEqnU	*(char)
[	O
k	int
]	O
=	O
szEqn	*(char)
[	O
j	int
]	O
;	O
j	int
++	O
;	O
k	int
++	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
szEqn	*(char)
[	O
j	int
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
k	int
==	O
MAX_EQN	int
-	O
1	int
)	O
)	O
ReportError	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void))),int,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),long,*(char),int,int,int,*(void),*(void)))
,	O
RE_EQNTOOLONG	O
|	O
RE_FATAL	int
,	O
NULL	O
,	O
"(Occured in UnrollEquation)"	*(char)
)	O
;	O
szEqnU	*(char)
[	O
k	int
]	O
=	O
'\0'	O
;	O
}	O
