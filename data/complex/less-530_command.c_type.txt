extern	O
int	O
erase_char	int
,	O
erase2_char	int
,	O
kill_char	int
;	O
extern	O
int	O
sigs	int
;	O
extern	O
int	O
quit_if_one_screen	int
;	O
extern	O
int	O
squished	int
;	O
extern	O
int	O
sc_width	int
;	O
extern	O
int	O
sc_height	int
;	O
extern	O
char	O
*	O
kent	*(char)
;	O
extern	O
int	O
swindow	int
;	O
extern	O
int	O
jump_sline	int
;	O
extern	O
int	O
quitting	int
;	O
extern	O
int	O
wscroll	int
;	O
extern	O
int	O
top_scroll	int
;	O
extern	O
int	O
ignore_eoi	int
;	O
extern	O
int	O
secure	int
;	O
extern	O
int	O
hshift	int
;	O
extern	O
int	O
bs_mode	int
;	O
extern	O
int	O
show_attn	int
;	O
extern	O
int	O
status_col	int
;	O
extern	O
POSITION	long
highest_hilite	long
;	O
extern	O
POSITION	long
start_attnpos	long
;	O
extern	O
POSITION	long
end_attnpos	long
;	O
extern	O
char	O
*	O
every_first_cmd	*(char)
;	O
extern	O
char	O
version	array(char)
[	O
]	O
;	O
extern	O
struct	O
scrpos	struct(long,int)
initial_scrpos	struct(long,int)
;	O
extern	O
IFILE	O
curr_ifile	*(void)
;	O
extern	O
void	O
*	O
ml_search	*(void)
;	O
extern	O
void	O
*	O
ml_examine	*(void)
;	O
extern	O
void	O
*	O
ml_shell	*(void)
;	O
extern	O
char	O
*	O
editor	*(char)
;	O
extern	O
char	O
*	O
editproto	*(char)
;	O
extern	O
int	O
screen_trashed	int
;	O
extern	O
int	O
shift_count	int
;	O
extern	O
int	O
oldbot	int
;	O
extern	O
int	O
forw_prompt	int
;	O
static	O
char	O
*	O
shellcmd	*(char)
=	O
NULL	O
;	O
static	O
int	O
mca	int
;	O
static	O
int	O
search_type	int
;	O
static	O
LINENUM	long
number	long
;	O
static	O
long	O
fraction	long
;	O
static	O
struct	O
loption	struct(char,*(struct(*(char),*(struct(*(char),*(struct`))))),int,int,*(int),*((int,*(char))->(void)),array(*(char)))
*	O
curropt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
;	O
static	O
int	O
opt_lower	int
;	O
static	O
int	O
optflag	int
;	O
static	O
int	O
optgetname	int
;	O
static	O
POSITION	long
bottompos	long
;	O
static	O
int	O
save_hshift	int
;	O
static	O
int	O
save_bs_mode	int
;	O
static	O
char	O
pipec	char
;	O
struct	O
ungot	struct(*(struct(*(struct(*(struct`),long)),long)),long)
{	O
struct	O
ungot	struct(*(struct(*(struct(*(struct`),long)),long)),long)
*	O
ug_next	*(struct(*(struct(*(struct`),long)),long))
;	O
LWCHAR	long
ug_char	long
;	O
}	O
;	O
static	O
struct	O
ungot	struct(*(struct(*(struct(*(struct`),long)),long)),long)
*	O
ungot	struct(*(struct(*(struct(*(struct`),long)),long)),long)
=	O
NULL	O
;	O
static	O
void	O
multi_search	()->(void)
(	O
)	O
;	O
static	O
void	O
cmd_exec	()->(void)
(	O
)	O
{	O
clear_attn	()->(void)
(	O
)	O
;	O
clear_bot	()->(void)
(	O
)	O
;	O
flush	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
start_mca	(int,*(char),*(void),int)->(void)
(	O
action	int
,	O
prompt	*(char)
,	O
mlist	*(void)
,	O
cmdflags	int
)	O
int	O
action	int
;	O
constant	O
char	O
*	O
prompt	*(char)
;	O
void	O
*	O
mlist	*(void)
;	O
int	O
cmdflags	int
;	O
{	O
mca	int
=	O
action	int
;	O
clear_bot	()->(void)
(	O
)	O
;	O
clear_cmd	()->(void)
(	O
)	O
;	O
cmd_putstr	(*(char))->(void)
(	O
prompt	*(char)
)	O
;	O
set_mlist	(*(void),int)->(void)
(	O
mlist	*(void)
,	O
cmdflags	int
)	O
;	O
}	O
public	O
int	O
in_mca	()->(int)
(	O
)	O
{	O
return	O
(	O
mca	int
!=	O
0	int
&&	O
mca	int
!=	O
A_PREFIX	int
)	O
;	O
}	O
static	O
void	O
mca_search	()->(void)
(	O
)	O
{	O
if	O
(	O
search_type	int
&	O
SRCH_FILTER	O
)	O
mca	int
=	O
A_FILTER	int
;	O
else	O
if	O
(	O
search_type	int
&	O
SRCH_FORW	O
)	O
mca	int
=	O
A_F_SEARCH	int
;	O
else	O
mca	int
=	O
A_B_SEARCH	int
;	O
clear_bot	()->(void)
(	O
)	O
;	O
clear_cmd	()->(void)
(	O
)	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_NO_MATCH	O
)	O
cmd_putstr	(*(char))->(void)
(	O
"Non-match "	*(char)
)	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_FIRST_FILE	O
)	O
cmd_putstr	(*(char))->(void)
(	O
"First-file "	*(char)
)	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_PAST_EOF	O
)	O
cmd_putstr	(*(char))->(void)
(	O
"EOF-ignore "	*(char)
)	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_NO_MOVE	O
)	O
cmd_putstr	(*(char))->(void)
(	O
"Keep-pos "	*(char)
)	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_NO_REGEX	O
)	O
cmd_putstr	(*(char))->(void)
(	O
"Regex-off "	*(char)
)	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_FILTER	O
)	O
cmd_putstr	(*(char))->(void)
(	O
"&/"	*(char)
)	O
;	O
else	O
if	O
(	O
search_type	int
&	O
SRCH_FORW	O
)	O
cmd_putstr	(*(char))->(void)
(	O
"/"	*(char)
)	O
;	O
else	O
cmd_putstr	(*(char))->(void)
(	O
"?"	*(char)
)	O
;	O
forw_prompt	int
=	O
0	int
;	O
set_mlist	(*(void),int)->(void)
(	O
ml_search	*(void)
,	O
0	int
)	O
;	O
}	O
static	O
void	O
mca_opt_toggle	()->(void)
(	O
)	O
{	O
int	O
no_prompt	int
;	O
int	O
flag	int
;	O
char	O
*	O
dash	*(char)
;	O
no_prompt	int
=	O
(	O
optflag	int
&	O
OPT_NO_PROMPT	int
)	O
;	O
flag	int
=	O
(	O
optflag	int
&	O
~	O
OPT_NO_PROMPT	int
)	O
;	O
dash	*(char)
=	O
(	O
flag	int
==	O
OPT_NO_TOGGLE	int
)	O
?	O
"_"	*(char)
:	O
"-"	*(char)
;	O
mca	int
=	O
A_OPT_TOGGLE	int
;	O
clear_bot	()->(void)
(	O
)	O
;	O
clear_cmd	()->(void)
(	O
)	O
;	O
cmd_putstr	(*(char))->(void)
(	O
dash	*(char)
)	O
;	O
if	O
(	O
optgetname	int
)	O
cmd_putstr	(*(char))->(void)
(	O
dash	*(char)
)	O
;	O
if	O
(	O
no_prompt	int
)	O
cmd_putstr	(*(char))->(void)
(	O
"(P)"	*(char)
)	O
;	O
switch	O
(	O
flag	int
)	O
{	O
case	O
OPT_UNSET	int
:	O
cmd_putstr	(*(char))->(void)
(	O
"+"	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_SET	int
:	O
cmd_putstr	(*(char))->(void)
(	O
"!"	*(char)
)	O
;	O
break	O
;	O
}	O
forw_prompt	int
=	O
0	int
;	O
set_mlist	(*(void),int)->(void)
(	O
NULL	O
,	O
0	int
)	O
;	O
}	O
static	O
void	O
exec_mca	()->(void)
(	O
)	O
{	O
char	O
*	O
cbuf	*(char)
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
cbuf	*(char)
=	O
get_cmdbuf	()->(*(char))
(	O
)	O
;	O
switch	O
(	O
mca	int
)	O
{	O
case	O
A_F_SEARCH	int
:	O
case	O
A_B_SEARCH	int
:	O
multi_search	()->(void)
(	O
cbuf	*(char)
,	O
(	O
int	O
)	O
number	long
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_FILTER	int
:	O
search_type	int
^=	O
SRCH_NO_MATCH	O
;	O
set_filter_pattern	(*(char),int)->(void)
(	O
cbuf	*(char)
,	O
search_type	int
)	O
;	O
break	O
;	O
case	O
A_FIRSTCMD	int
:	O
while	O
(	O
*	O
cbuf	*(char)
==	O
'+'	O
||	O
*	O
cbuf	*(char)
==	O
' '	O
)	O
cbuf	*(char)
++	O
;	O
if	O
(	O
every_first_cmd	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
every_first_cmd	*(char)
)	O
;	O
if	O
(	O
*	O
cbuf	*(char)
==	O
'\0'	O
)	O
every_first_cmd	*(char)
=	O
NULL	O
;	O
else	O
every_first_cmd	*(char)
=	O
save	(*(char))->(*(char))
(	O
cbuf	*(char)
)	O
;	O
break	O
;	O
case	O
A_OPT_TOGGLE	int
:	O
toggle_option	(*(struct),int,*(char),int)->(void)
(	O
curropt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
,	O
opt_lower	int
,	O
cbuf	*(char)
,	O
optflag	int
)	O
;	O
curropt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
=	O
NULL	O
;	O
break	O
;	O
case	O
A_F_BRACKET	int
:	O
match_brac	(int,int,int,int)->(void)
(	O
cbuf	*(char)
[	O
0	int
]	O
,	O
cbuf	*(char)
[	O
1	int
]	O
,	O
1	int
,	O
(	O
int	O
)	O
number	long
)	O
;	O
break	O
;	O
case	O
A_B_BRACKET	int
:	O
match_brac	(int,int,int,int)->(void)
(	O
cbuf	*(char)
[	O
1	int
]	O
,	O
cbuf	*(char)
[	O
0	int
]	O
,	O
0	int
,	O
(	O
int	O
)	O
number	long
)	O
;	O
break	O
;	O
case	O
A_EXAMINE	int
:	O
if	O
(	O
secure	int
)	O
break	O
;	O
edit_list	(*(char))->(int)
(	O
cbuf	*(char)
)	O
;	O
cleantags	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
A_SHELL	int
:	O
if	O
(	O
*	O
cbuf	*(char)
!=	O
'!'	O
)	O
{	O
if	O
(	O
shellcmd	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
shellcmd	*(char)
)	O
;	O
shellcmd	*(char)
=	O
fexpand	(*(char))->(*(char))
(	O
cbuf	*(char)
)	O
;	O
}	O
if	O
(	O
secure	int
)	O
break	O
;	O
if	O
(	O
shellcmd	*(char)
==	O
NULL	O
)	O
lsystem	(*(char),*(char))->(void)
(	O
""	*(char)
,	O
"!done"	*(char)
)	O
;	O
else	O
lsystem	(*(char),*(char))->(void)
(	O
shellcmd	*(char)
,	O
"!done"	*(char)
)	O
;	O
break	O
;	O
case	O
A_PIPE	int
:	O
if	O
(	O
secure	int
)	O
break	O
;	O
(	O
void	O
)	O
pipe_mark	(int,*(char))->(int)
(	O
pipec	char
,	O
cbuf	*(char)
)	O
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"|done"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
}	O
}	O
static	O
int	O
is_erase_char	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
return	O
(	O
c	int
==	O
erase_char	int
||	O
c	int
==	O
erase2_char	int
||	O
c	int
==	O
kill_char	int
)	O
;	O
}	O
static	O
int	O
is_newline_char	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
return	O
(	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
'\r'	O
)	O
;	O
}	O
static	O
int	O
mca_opt_first_char	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
int	O
flag	int
=	O
(	O
optflag	int
&	O
~	O
OPT_NO_PROMPT	int
)	O
;	O
if	O
(	O
flag	int
==	O
OPT_NO_TOGGLE	int
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'_'	O
:	O
optgetname	int
=	O
TRUE	int
;	O
mca_opt_toggle	()->(void)
(	O
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
}	O
}	O
else	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'+'	O
:	O
optflag	int
=	O
(	O
flag	int
==	O
OPT_UNSET	int
)	O
?	O
OPT_TOGGLE	int
:	O
OPT_UNSET	int
;	O
mca_opt_toggle	()->(void)
(	O
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
case	O
'!'	O
:	O
optflag	int
=	O
(	O
flag	int
==	O
OPT_SET	int
)	O
?	O
OPT_TOGGLE	int
:	O
OPT_SET	int
;	O
mca_opt_toggle	()->(void)
(	O
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
case	O
CONTROL	O
(	O
'P'	O
)	O
:	O
optflag	int
^=	O
OPT_NO_PROMPT	int
;	O
mca_opt_toggle	()->(void)
(	O
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
case	O
'-'	O
:	O
optgetname	int
=	O
TRUE	int
;	O
mca_opt_toggle	()->(void)
(	O
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
}	O
}	O
return	O
(	O
NO_MCA	int
)	O
;	O
}	O
static	O
int	O
mca_opt_nonfirst_char	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
char	O
*	O
p	*(char)
;	O
char	O
*	O
oname	*(char)
;	O
if	O
(	O
curropt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
!=	O
NULL	O
)	O
{	O
if	O
(	O
is_erase_char	(int)->(int)
(	O
c	int
)	O
)	O
return	O
(	O
MCA_DONE	int
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
}	O
if	O
(	O
cmd_char	(int)->(int)
(	O
c	int
)	O
==	O
CC_QUIT	int
)	O
return	O
(	O
MCA_DONE	int
)	O
;	O
p	*(char)
=	O
get_cmdbuf	()->(*(char))
(	O
)	O
;	O
opt_lower	int
=	O
ASCII_IS_LOWER	O
(	O
p	*(char)
[	O
0	int
]	O
)	O
;	O
curropt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
=	O
findopt_name	(*(*(char)),*(*(char)),*(int))->(*(struct))
(	O
&	O
p	*(char)
,	O
&	O
oname	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
curropt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
!=	O
NULL	O
)	O
{	O
cmd_reset	()->(void)
(	O
)	O
;	O
mca_opt_toggle	()->(void)
(	O
)	O
;	O
for	O
(	O
p	*(char)
=	O
oname	*(char)
;	O
*	O
p	*(char)
!=	O
'\0'	O
;	O
p	*(char)
++	O
)	O
{	O
c	int
=	O
*	O
p	*(char)
;	O
if	O
(	O
!	O
opt_lower	int
&&	O
ASCII_IS_LOWER	O
(	O
c	int
)	O
)	O
c	int
=	O
ASCII_TO_UPPER	O
(	O
c	int
)	O
;	O
if	O
(	O
cmd_char	(int)->(int)
(	O
c	int
)	O
!=	O
CC_OK	int
)	O
return	O
(	O
MCA_DONE	int
)	O
;	O
}	O
}	O
return	O
(	O
MCA_MORE	int
)	O
;	O
}	O
static	O
int	O
mca_opt_char	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
if	O
(	O
curropt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
==	O
NULL	O
&&	O
len_cmdbuf	()->(int)
(	O
)	O
==	O
0	int
)	O
{	O
int	O
ret	int
=	O
mca_opt_first_char	(int)->(int)
(	O
c	int
)	O
;	O
if	O
(	O
ret	int
!=	O
NO_MCA	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
optgetname	int
)	O
{	O
if	O
(	O
!	O
is_newline_char	(int)->(int)
(	O
c	int
)	O
)	O
return	O
(	O
mca_opt_nonfirst_char	(int)->(int)
(	O
c	int
)	O
)	O
;	O
if	O
(	O
curropt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
==	O
NULL	O
)	O
{	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
get_cmdbuf	()->(*(char))
(	O
)	O
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"There is no --%s option"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
return	O
(	O
MCA_DONE	int
)	O
;	O
}	O
optgetname	int
=	O
FALSE	int
;	O
cmd_reset	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
is_erase_char	(int)->(int)
(	O
c	int
)	O
)	O
return	O
(	O
NO_MCA	int
)	O
;	O
if	O
(	O
curropt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
!=	O
NULL	O
)	O
return	O
(	O
NO_MCA	int
)	O
;	O
curropt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
=	O
findopt	(int)->(*(struct))
(	O
c	int
)	O
;	O
if	O
(	O
curropt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
==	O
NULL	O
)	O
{	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
propt	(int)->(*(char))
(	O
c	int
)	O
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"There is no %s option"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
return	O
(	O
MCA_DONE	int
)	O
;	O
}	O
}	O
if	O
(	O
(	O
optflag	int
&	O
~	O
OPT_NO_PROMPT	int
)	O
!=	O
OPT_TOGGLE	int
||	O
!	O
opt_has_param	(*(struct))->(int)
(	O
curropt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
)	O
)	O
{	O
toggle_option	(*(struct),int,*(char),int)->(void)
(	O
curropt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
,	O
ASCII_IS_LOWER	O
(	O
c	int
)	O
,	O
""	*(char)
,	O
optflag	int
)	O
;	O
return	O
(	O
MCA_DONE	int
)	O
;	O
}	O
start_mca	(int,*(char),*(void),int)->(void)
(	O
A_OPT_TOGGLE	int
,	O
opt_prompt	(*(struct))->(*(char))
(	O
curropt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
)	O
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
}	O
static	O
int	O
mca_search_char	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
int	O
flag	int
=	O
0	int
;	O
if	O
(	O
len_cmdbuf	()->(int)
(	O
)	O
>	O
0	int
)	O
return	O
(	O
NO_MCA	int
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
CONTROL	O
(	O
'E'	O
)	O
:	O
case	O
'*'	O
:	O
if	O
(	O
mca	int
!=	O
A_FILTER	int
)	O
flag	int
=	O
SRCH_PAST_EOF	O
;	O
break	O
;	O
case	O
CONTROL	O
(	O
'F'	O
)	O
:	O
case	O
'@'	O
:	O
if	O
(	O
mca	int
!=	O
A_FILTER	int
)	O
flag	int
=	O
SRCH_FIRST_FILE	O
;	O
break	O
;	O
case	O
CONTROL	O
(	O
'K'	O
)	O
:	O
if	O
(	O
mca	int
!=	O
A_FILTER	int
)	O
flag	int
=	O
SRCH_NO_MOVE	O
;	O
break	O
;	O
case	O
CONTROL	O
(	O
'R'	O
)	O
:	O
flag	int
=	O
SRCH_NO_REGEX	O
;	O
break	O
;	O
case	O
CONTROL	O
(	O
'N'	O
)	O
:	O
case	O
'!'	O
:	O
flag	int
=	O
SRCH_NO_MATCH	O
;	O
break	O
;	O
}	O
if	O
(	O
flag	int
!=	O
0	int
)	O
{	O
search_type	int
^=	O
flag	int
;	O
mca_search	()->(void)
(	O
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
}	O
return	O
(	O
NO_MCA	int
)	O
;	O
}	O
static	O
int	O
mca_char	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
int	O
ret	int
;	O
switch	O
(	O
mca	int
)	O
{	O
case	O
0	int
:	O
return	O
(	O
NO_MCA	int
)	O
;	O
case	O
A_PREFIX	int
:	O
return	O
(	O
NO_MCA	int
)	O
;	O
case	O
A_DIGIT	int
:	O
if	O
(	O
!	O
(	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
||	O
c	int
==	O
'.'	O
)	O
&&	O
editchar	(int,int)->(int)
(	O
c	int
,	O
EC_PEEK	int
|	O
EC_NOHISTORY	int
|	O
EC_NOCOMPLETE	int
|	O
EC_NORIGHTLEFT	int
)	O
==	O
A_INVALID	int
)	O
{	O
number	long
=	O
cmd_int	(*(long))->(long)
(	O
&	O
fraction	long
)	O
;	O
mca	int
=	O
0	int
;	O
cmd_accept	()->(void)
(	O
)	O
;	O
return	O
(	O
NO_MCA	int
)	O
;	O
}	O
break	O
;	O
case	O
A_OPT_TOGGLE	int
:	O
ret	int
=	O
mca_opt_char	(int)->(int)
(	O
c	int
)	O
;	O
if	O
(	O
ret	int
!=	O
NO_MCA	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
case	O
A_F_SEARCH	int
:	O
case	O
A_B_SEARCH	int
:	O
case	O
A_FILTER	int
:	O
ret	int
=	O
mca_search_char	(int)->(int)
(	O
c	int
)	O
;	O
if	O
(	O
ret	int
!=	O
NO_MCA	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
is_newline_char	(int)->(int)
(	O
c	int
)	O
)	O
{	O
exec_mca	()->(void)
(	O
)	O
;	O
return	O
(	O
MCA_DONE	int
)	O
;	O
}	O
if	O
(	O
cmd_char	(int)->(int)
(	O
c	int
)	O
==	O
CC_QUIT	int
)	O
return	O
(	O
MCA_DONE	int
)	O
;	O
if	O
(	O
(	O
mca	int
==	O
A_F_BRACKET	int
||	O
mca	int
==	O
A_B_BRACKET	int
)	O
&&	O
len_cmdbuf	()->(int)
(	O
)	O
>=	O
2	int
)	O
{	O
exec_mca	()->(void)
(	O
)	O
;	O
return	O
(	O
MCA_DONE	int
)	O
;	O
}	O
return	O
(	O
MCA_MORE	int
)	O
;	O
}	O
static	O
void	O
clear_buffers	()->(void)
(	O
)	O
{	O
if	O
(	O
!	O
(	O
ch_getflags	()->(int)
(	O
)	O
&	O
CH_CANSEEK	int
)	O
)	O
return	O
;	O
ch_flush	()->(void)
(	O
)	O
;	O
clr_linenum	()->(void)
(	O
)	O
;	O
clr_hilite	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
make_display	()->(void)
(	O
)	O
{	O
if	O
(	O
empty_screen	()->(int)
(	O
)	O
)	O
{	O
if	O
(	O
initial_scrpos	struct(long,int)
.	O
pos	long
==	O
NULL_POSITION	O
)	O
jump_loc	(long,int)->(void)
(	O
ch_zero	O
(	O
)	O
,	O
1	int
)	O
;	O
else	O
jump_loc	(long,int)->(void)
(	O
initial_scrpos	struct(long,int)
.	O
pos	long
,	O
initial_scrpos	struct(long,int)
.	O
ln	int
)	O
;	O
}	O
else	O
if	O
(	O
screen_trashed	int
)	O
{	O
int	O
save_top_scroll	int
=	O
top_scroll	int
;	O
int	O
save_ignore_eoi	int
=	O
ignore_eoi	int
;	O
top_scroll	int
=	O
1	int
;	O
ignore_eoi	int
=	O
0	int
;	O
if	O
(	O
screen_trashed	int
==	O
2	int
)	O
{	O
reopen_curr_ifile	()->(void)
(	O
)	O
;	O
jump_forw	()->(void)
(	O
)	O
;	O
}	O
repaint	()->(void)
(	O
)	O
;	O
top_scroll	int
=	O
save_top_scroll	int
;	O
ignore_eoi	int
=	O
save_ignore_eoi	int
;	O
}	O
}	O
static	O
void	O
prompt	*(char)
(	O
)	O
{	O
constant	O
char	O
*	O
p	*(char)
;	O
if	O
(	O
ungot	struct(*(struct(*(struct(*(struct`),long)),long)),long)
!=	O
NULL	O
&&	O
ungot	struct(*(struct(*(struct(*(struct`),long)),long)),long)
->	O
ug_char	long
!=	O
CHAR_END_COMMAND	int
)	O
{	O
return	O
;	O
}	O
make_display	()->(void)
(	O
)	O
;	O
bottompos	long
=	O
position	(int)->(long)
(	O
BOTTOM_PLUS_ONE	O
)	O
;	O
if	O
(	O
get_quit_at_eof	()->(int)
(	O
)	O
==	O
OPT_ONPLUS	int
&&	O
eof_displayed	()->(int)
(	O
)	O
&&	O
!	O
(	O
ch_getflags	()->(int)
(	O
)	O
&	O
CH_HELPFILE	int
)	O
&&	O
next_ifile	(*(void))->(*(void))
(	O
curr_ifile	*(void)
)	O
==	O
NULL_IFILE	O
)	O
quit	(int)->(void)
(	O
QUIT_OK	int
)	O
;	O
if	O
(	O
quit_if_one_screen	int
&&	O
entire_file_displayed	()->(int)
(	O
)	O
&&	O
!	O
(	O
ch_getflags	()->(int)
(	O
)	O
&	O
CH_HELPFILE	int
)	O
&&	O
next_ifile	(*(void))->(*(void))
(	O
curr_ifile	*(void)
)	O
==	O
NULL_IFILE	O
)	O
quit	(int)->(void)
(	O
QUIT_OK	int
)	O
;	O
if	O
(	O
!	O
forw_prompt	int
)	O
clear_bot	()->(void)
(	O
)	O
;	O
clear_cmd	()->(void)
(	O
)	O
;	O
forw_prompt	int
=	O
0	int
;	O
p	*(char)
=	O
pr_string	()->(*(char))
(	O
)	O
;	O
if	O
(	O
is_filtering	()->(int)
(	O
)	O
)	O
putstr	(*(char))->(void)
(	O
"& "	*(char)
)	O
;	O
if	O
(	O
p	*(char)
==	O
NULL	O
||	O
*	O
p	*(char)
==	O
'\0'	O
)	O
putchr	(int)->(int)
(	O
':'	O
)	O
;	O
else	O
{	O
at_enter	(int)->(void)
(	O
AT_STANDOUT	O
)	O
;	O
putstr	(*(char))->(void)
(	O
p	*(char)
)	O
;	O
at_exit	()->(void)
(	O
)	O
;	O
}	O
clear_eol	()->(void)
(	O
)	O
;	O
}	O
public	O
void	O
dispversion	()->(void)
(	O
)	O
{	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
version	array(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"less %s"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
}	O
static	O
LWCHAR	long
getcc_end_command	()->(long)
(	O
)	O
{	O
switch	O
(	O
mca	int
)	O
{	O
case	O
A_DIGIT	int
:	O
return	O
(	O
'g'	O
)	O
;	O
case	O
A_F_SEARCH	int
:	O
case	O
A_B_SEARCH	int
:	O
return	O
(	O
'\n'	O
)	O
;	O
default	O
:	O
return	O
(	O
getchr	()->(int)
(	O
)	O
)	O
;	O
}	O
}	O
static	O
LWCHAR	long
getccu	()->(long)
(	O
VOID_PARAM	void
)	O
{	O
LWCHAR	long
c	int
;	O
if	O
(	O
ungot	struct(*(struct(*(struct(*(struct`),long)),long)),long)
==	O
NULL	O
)	O
{	O
c	int
=	O
getchr	()->(int)
(	O
)	O
;	O
}	O
else	O
{	O
struct	O
ungot	struct(*(struct(*(struct(*(struct`),long)),long)),long)
*	O
ug	*(struct(*(struct(*(struct`),long)),long))
=	O
ungot	struct(*(struct(*(struct(*(struct`),long)),long)),long)
;	O
c	int
=	O
ug	*(struct(*(struct(*(struct`),long)),long))
->	O
ug_char	long
;	O
ungot	struct(*(struct(*(struct(*(struct`),long)),long)),long)
=	O
ug	*(struct(*(struct(*(struct`),long)),long))
->	O
ug_next	*(struct(*(struct(*(struct`),long)),long))
;	O
free	(*(void))->(void)
(	O
ug	*(struct(*(struct(*(struct`),long)),long))
)	O
;	O
if	O
(	O
c	int
==	O
CHAR_END_COMMAND	int
)	O
c	int
=	O
getcc_end_command	()->(long)
(	O
)	O
;	O
}	O
return	O
(	O
c	int
)	O
;	O
}	O
static	O
LWCHAR	long
getcc_repl	(*(char),*(char),*(()->(long)),*((long)->(void)))->(long)
(	O
orig	*(char)
,	O
repl	*(char)
,	O
gr_getc	*(()->(long))
,	O
gr_ungetc	*((long)->(void))
)	O
char	O
const	O
*	O
orig	*(char)
;	O
char	O
const	O
*	O
repl	*(char)
;	O
LWCHAR	long
(	O
*	O
gr_getc	*(()->(long))
)	O
(	O
VOID_PARAM	void
)	O
;	O
void	O
(	O
*	O
gr_ungetc	*((long)->(void))
)	O
(	O
LWCHAR	long
)	O
;	O
{	O
LWCHAR	long
c	int
;	O
LWCHAR	long
keys	array(long)
[	O
16	int
]	O
;	O
int	O
ki	int
=	O
0	int
;	O
c	int
=	O
(	O
*	O
gr_getc	*(()->(long))
)	O
(	O
)	O
;	O
if	O
(	O
orig	*(char)
==	O
NULL	O
||	O
orig	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
c	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
keys	array(long)
[	O
ki	int
]	O
=	O
c	int
;	O
if	O
(	O
c	int
!=	O
orig	*(char)
[	O
ki	int
]	O
||	O
ki	int
>=	O
sizeof	O
(	O
keys	array(long)
)	O
-	O
1	int
)	O
{	O
while	O
(	O
ki	int
>	O
0	int
)	O
(	O
*	O
gr_ungetc	*((long)->(void))
)	O
(	O
keys	array(long)
[	O
ki	int
--	O
]	O
)	O
;	O
return	O
keys	array(long)
[	O
0	int
]	O
;	O
}	O
if	O
(	O
orig	*(char)
[	O
++	O
ki	int
]	O
==	O
'\0'	O
)	O
{	O
ki	int
=	O
strlen	(*(char))->(long)
(	O
repl	*(char)
)	O
-	O
1	int
;	O
while	O
(	O
ki	int
>	O
0	int
)	O
(	O
*	O
gr_ungetc	*((long)->(void))
)	O
(	O
repl	*(char)
[	O
ki	int
--	O
]	O
)	O
;	O
return	O
repl	*(char)
[	O
0	int
]	O
;	O
}	O
c	int
=	O
(	O
*	O
gr_getc	*(()->(long))
)	O
(	O
)	O
;	O
}	O
}	O
public	O
int	O
getcc	()->(int)
(	O
)	O
{	O
return	O
getcc_repl	(*(char),*(char),*(()->(long)),*((long)->(void)))->(long)
(	O
kent	*(char)
,	O
"\n"	*(char)
,	O
getccu	()->(long)
,	O
ungetcc	(long)->(void)
)	O
;	O
}	O
public	O
void	O
ungetcc	(long)->(void)
(	O
c	int
)	O
LWCHAR	long
c	int
;	O
{	O
struct	O
ungot	struct(*(struct(*(struct(*(struct`),long)),long)),long)
*	O
ug	*(struct(*(struct(*(struct`),long)),long))
=	O
(	O
struct	O
ungot	struct(*(struct(*(struct(*(struct`),long)),long)),long)
*	O
)	O
ecalloc	(int,int)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
struct	O
ungot	struct(*(struct(*(struct(*(struct`),long)),long)),long)
)	O
)	O
;	O
ug	*(struct(*(struct(*(struct`),long)),long))
->	O
ug_char	long
=	O
c	int
;	O
ug	*(struct(*(struct(*(struct`),long)),long))
->	O
ug_next	*(struct(*(struct(*(struct`),long)),long))
=	O
ungot	struct(*(struct(*(struct(*(struct`),long)),long)),long)
;	O
ungot	struct(*(struct(*(struct(*(struct`),long)),long)),long)
=	O
ug	*(struct(*(struct(*(struct`),long)),long))
;	O
}	O
public	O
void	O
ungetsc	(*(char))->(void)
(	O
s	*(char)
)	O
char	O
*	O
s	*(char)
;	O
{	O
char	O
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
s	*(char)
+	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
-	O
1	int
;	O
p	*(char)
>=	O
s	*(char)
;	O
p	*(char)
--	O
)	O
ungetcc	(long)->(void)
(	O
*	O
p	*(char)
)	O
;	O
}	O
public	O
LWCHAR	long
peekcc	()->(long)
(	O
)	O
{	O
LWCHAR	long
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
ungetcc	(long)->(void)
(	O
c	int
)	O
;	O
return	O
c	int
;	O
}	O
static	O
void	O
multi_search	()->(void)
(	O
pattern	*(char)
,	O
n	int
,	O
silent	int
)	O
char	O
*	O
pattern	*(char)
;	O
int	O
n	int
;	O
int	O
silent	int
;	O
{	O
int	O
nomore	int
;	O
IFILE	O
save_ifile	*(void)
;	O
int	O
changed_file	int
;	O
changed_file	int
=	O
0	int
;	O
save_ifile	*(void)
=	O
save_curr_ifile	()->(*(void))
(	O
)	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_FIRST_FILE	O
)	O
{	O
if	O
(	O
search_type	int
&	O
SRCH_FORW	O
)	O
nomore	int
=	O
edit_first	()->(int)
(	O
)	O
;	O
else	O
nomore	int
=	O
edit_last	()->(int)
(	O
)	O
;	O
if	O
(	O
nomore	int
)	O
{	O
unsave_ifile	(*(void))->(void)
(	O
save_ifile	*(void)
)	O
;	O
return	O
;	O
}	O
changed_file	int
=	O
1	int
;	O
search_type	int
&=	O
~	O
SRCH_FIRST_FILE	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
n	int
=	O
search	(int,*(char),int)->(int)
(	O
search_type	int
,	O
pattern	*(char)
,	O
n	int
)	O
;	O
search_type	int
&=	O
~	O
SRCH_NO_MOVE	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
unsave_ifile	(*(void))->(void)
(	O
save_ifile	*(void)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
n	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
search_type	int
&	O
SRCH_PAST_EOF	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_FORW	O
)	O
nomore	int
=	O
edit_next	(int)->(int)
(	O
1	int
)	O
;	O
else	O
nomore	int
=	O
edit_prev	(int)->(int)
(	O
1	int
)	O
;	O
if	O
(	O
nomore	int
)	O
break	O
;	O
changed_file	int
=	O
1	int
;	O
}	O
if	O
(	O
n	int
>	O
0	int
&&	O
!	O
silent	int
)	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Pattern not found"	*(char)
,	O
NULL_PARG	O
)	O
;	O
if	O
(	O
changed_file	int
)	O
{	O
reedit_ifile	(*(void))->(void)
(	O
save_ifile	*(void)
)	O
;	O
}	O
else	O
{	O
unsave_ifile	(*(void))->(void)
(	O
save_ifile	*(void)
)	O
;	O
}	O
}	O
static	O
int	O
forw_loop	(int)->(int)
(	O
until_hilite	int
)	O
int	O
until_hilite	int
;	O
{	O
POSITION	long
curr_len	long
;	O
if	O
(	O
ch_getflags	()->(int)
(	O
)	O
&	O
CH_HELPFILE	int
)	O
return	O
(	O
A_NOACTION	int
)	O
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
jump_forw_buffered	()->(void)
(	O
)	O
;	O
curr_len	long
=	O
ch_length	()->(long)
(	O
)	O
;	O
highest_hilite	long
=	O
until_hilite	int
?	O
curr_len	long
:	O
NULL_POSITION	O
;	O
ignore_eoi	int
=	O
1	int
;	O
while	O
(	O
!	O
sigs	int
)	O
{	O
if	O
(	O
until_hilite	int
&&	O
highest_hilite	long
>	O
curr_len	long
)	O
{	O
bell	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
make_display	()->(void)
(	O
)	O
;	O
forward	(int,int,int)->(void)
(	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
ignore_eoi	int
=	O
0	int
;	O
ch_set_eof	()->(void)
(	O
)	O
;	O
if	O
(	O
sigs	int
&&	O
!	O
ABORT_SIGS	O
(	O
)	O
)	O
return	O
(	O
until_hilite	int
?	O
A_F_UNTIL_HILITE	int
:	O
A_F_FOREVER	int
)	O
;	O
return	O
(	O
A_NOACTION	int
)	O
;	O
}	O
public	O
void	O
commands	()->(void)
(	O
)	O
{	O
int	O
c	int
;	O
int	O
action	int
;	O
char	O
*	O
cbuf	*(char)
;	O
int	O
newaction	int
;	O
int	O
save_search_type	int
;	O
char	O
*	O
extra	*(char)
;	O
char	O
tbuf	array(char)
[	O
2	int
]	O
;	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
IFILE	O
old_ifile	*(void)
;	O
IFILE	O
new_ifile	*(void)
;	O
char	O
*	O
tagfile	*(char)
;	O
search_type	int
=	O
SRCH_FORW	O
;	O
wscroll	int
=	O
(	O
sc_height	int
+	O
1	int
)	O
/	O
2	int
;	O
newaction	int
=	O
A_NOACTION	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
mca	int
=	O
0	int
;	O
cmd_accept	()->(void)
(	O
)	O
;	O
number	long
=	O
0	int
;	O
curropt	*(struct(char,*(struct(*(char),*(struct`))),int,int,*(int),*((int,*(char))->(void)),array(*(char))))
=	O
NULL	O
;	O
if	O
(	O
sigs	int
)	O
{	O
psignals	()->(void)
(	O
)	O
;	O
if	O
(	O
quitting	int
)	O
quit	(int)->(void)
(	O
QUIT_SAVED_STATUS	O
)	O
;	O
}	O
check_winch	()->(void)
(	O
)	O
;	O
cmd_reset	()->(void)
(	O
)	O
;	O
prompt	*(char)
(	O
)	O
;	O
if	O
(	O
sigs	int
)	O
continue	O
;	O
if	O
(	O
newaction	int
==	O
A_NOACTION	int
)	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
again	O
:	O
if	O
(	O
sigs	int
)	O
continue	O
;	O
if	O
(	O
newaction	int
!=	O
A_NOACTION	int
)	O
{	O
action	int
=	O
newaction	int
;	O
newaction	int
=	O
A_NOACTION	int
;	O
}	O
else	O
{	O
if	O
(	O
mca	int
)	O
switch	O
(	O
mca_char	(int)->(int)
(	O
c	int
)	O
)	O
{	O
case	O
MCA_MORE	int
:	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
MCA_DONE	int
:	O
continue	O
;	O
case	O
NO_MCA	int
:	O
break	O
;	O
}	O
if	O
(	O
mca	int
)	O
{	O
if	O
(	O
cmd_char	(int)->(int)
(	O
c	int
)	O
==	O
CC_QUIT	int
||	O
len_cmdbuf	()->(int)
(	O
)	O
==	O
0	int
)	O
continue	O
;	O
cbuf	*(char)
=	O
get_cmdbuf	()->(*(char))
(	O
)	O
;	O
}	O
else	O
{	O
tbuf	array(char)
[	O
0	int
]	O
=	O
c	int
;	O
tbuf	array(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
cbuf	*(char)
=	O
tbuf	array(char)
;	O
}	O
extra	*(char)
=	O
NULL	O
;	O
action	int
=	O
fcmd_decode	(*(char),*(*(char)))->(int)
(	O
cbuf	*(char)
,	O
&	O
extra	*(char)
)	O
;	O
if	O
(	O
extra	*(char)
!=	O
NULL	O
)	O
ungetsc	(*(char))->(void)
(	O
extra	*(char)
)	O
;	O
}	O
if	O
(	O
action	int
!=	O
A_PREFIX	int
)	O
cmd_reset	()->(void)
(	O
)	O
;	O
switch	O
(	O
action	int
)	O
{	O
case	O
A_DIGIT	int
:	O
start_mca	(int,*(char),*(void),int)->(void)
(	O
A_DIGIT	int
,	O
":"	*(char)
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
CF_QUIT_ON_ERASE	int
)	O
;	O
goto	O
again	O
;	O
case	O
A_F_WINDOW	int
:	O
if	O
(	O
number	long
>	O
0	int
)	O
swindow	int
=	O
(	O
int	O
)	O
number	long
;	O
case	O
A_F_SCREEN	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
get_swindow	()->(int)
(	O
)	O
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
if	O
(	O
show_attn	int
)	O
set_attnpos	(long)->(void)
(	O
bottompos	long
)	O
;	O
forward	(int,int,int)->(void)
(	O
(	O
int	O
)	O
number	long
,	O
0	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
A_B_WINDOW	int
:	O
if	O
(	O
number	long
>	O
0	int
)	O
swindow	int
=	O
(	O
int	O
)	O
number	long
;	O
case	O
A_B_SCREEN	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
get_swindow	()->(int)
(	O
)	O
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
backward	(int,int,int)->(void)
(	O
(	O
int	O
)	O
number	long
,	O
0	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
A_F_LINE	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
if	O
(	O
show_attn	int
==	O
OPT_ONPLUS	int
&&	O
number	long
>	O
1	int
)	O
set_attnpos	(long)->(void)
(	O
bottompos	long
)	O
;	O
forward	(int,int,int)->(void)
(	O
(	O
int	O
)	O
number	long
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_B_LINE	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
backward	(int,int,int)->(void)
(	O
(	O
int	O
)	O
number	long
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_FF_LINE	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
if	O
(	O
show_attn	int
==	O
OPT_ONPLUS	int
&&	O
number	long
>	O
1	int
)	O
set_attnpos	(long)->(void)
(	O
bottompos	long
)	O
;	O
forward	(int,int,int)->(void)
(	O
(	O
int	O
)	O
number	long
,	O
1	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_BF_LINE	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
backward	(int,int,int)->(void)
(	O
(	O
int	O
)	O
number	long
,	O
1	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_FF_SCREEN	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
get_swindow	()->(int)
(	O
)	O
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
if	O
(	O
show_attn	int
==	O
OPT_ONPLUS	int
)	O
set_attnpos	(long)->(void)
(	O
bottompos	long
)	O
;	O
forward	(int,int,int)->(void)
(	O
(	O
int	O
)	O
number	long
,	O
1	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_F_FOREVER	int
:	O
if	O
(	O
show_attn	int
)	O
set_attnpos	(long)->(void)
(	O
bottompos	long
)	O
;	O
newaction	int
=	O
forw_loop	(int)->(int)
(	O
0	int
)	O
;	O
break	O
;	O
case	O
A_F_UNTIL_HILITE	int
:	O
newaction	int
=	O
forw_loop	(int)->(int)
(	O
1	int
)	O
;	O
break	O
;	O
case	O
A_F_SCROLL	int
:	O
if	O
(	O
number	long
>	O
0	int
)	O
wscroll	int
=	O
(	O
int	O
)	O
number	long
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
if	O
(	O
show_attn	int
==	O
OPT_ONPLUS	int
)	O
set_attnpos	(long)->(void)
(	O
bottompos	long
)	O
;	O
forward	(int,int,int)->(void)
(	O
wscroll	int
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_B_SCROLL	int
:	O
if	O
(	O
number	long
>	O
0	int
)	O
wscroll	int
=	O
(	O
int	O
)	O
number	long
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
backward	(int,int,int)->(void)
(	O
wscroll	int
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_FREPAINT	int
:	O
clear_buffers	()->(void)
(	O
)	O
;	O
case	O
A_REPAINT	int
:	O
cmd_exec	()->(void)
(	O
)	O
;	O
repaint	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
A_GOLINE	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
jump_back	(long)->(void)
(	O
number	long
)	O
;	O
break	O
;	O
case	O
A_PERCENT	int
:	O
if	O
(	O
number	long
<	O
0	int
)	O
{	O
number	long
=	O
0	int
;	O
fraction	long
=	O
0	int
;	O
}	O
if	O
(	O
number	long
>	O
100	int
)	O
{	O
number	long
=	O
100	int
;	O
fraction	long
=	O
0	int
;	O
}	O
cmd_exec	()->(void)
(	O
)	O
;	O
jump_percent	(int,long)->(void)
(	O
(	O
int	O
)	O
number	long
,	O
fraction	long
)	O
;	O
break	O
;	O
case	O
A_GOEND	int
:	O
cmd_exec	()->(void)
(	O
)	O
;	O
if	O
(	O
number	long
<=	O
0	int
)	O
jump_forw	()->(void)
(	O
)	O
;	O
else	O
jump_back	(long)->(void)
(	O
number	long
)	O
;	O
break	O
;	O
case	O
A_GOEND_BUF	int
:	O
cmd_exec	()->(void)
(	O
)	O
;	O
if	O
(	O
number	long
<=	O
0	int
)	O
jump_forw_buffered	()->(void)
(	O
)	O
;	O
else	O
jump_back	(long)->(void)
(	O
number	long
)	O
;	O
break	O
;	O
case	O
A_GOPOS	int
:	O
cmd_exec	()->(void)
(	O
)	O
;	O
if	O
(	O
number	long
<	O
0	int
)	O
number	long
=	O
0	int
;	O
jump_line_loc	(long,int)->(void)
(	O
(	O
POSITION	long
)	O
number	long
,	O
jump_sline	int
)	O
;	O
break	O
;	O
case	O
A_STAT	int
:	O
if	O
(	O
ch_getflags	()->(int)
(	O
)	O
&	O
CH_HELPFILE	int
)	O
break	O
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
eq_message	()->(*(char))
(	O
)	O
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"%s"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
break	O
;	O
case	O
A_VERSION	int
:	O
cmd_exec	()->(void)
(	O
)	O
;	O
dispversion	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
A_QUIT	int
:	O
if	O
(	O
curr_ifile	*(void)
!=	O
NULL_IFILE	O
&&	O
ch_getflags	()->(int)
(	O
)	O
&	O
CH_HELPFILE	int
)	O
{	O
hshift	int
=	O
save_hshift	int
;	O
bs_mode	int
=	O
save_bs_mode	int
;	O
if	O
(	O
edit_prev	(int)->(int)
(	O
1	int
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
extra	*(char)
!=	O
NULL	O
)	O
quit	(int)->(void)
(	O
*	O
extra	*(char)
)	O
;	O
quit	(int)->(void)
(	O
QUIT_OK	int
)	O
;	O
break	O
;	O
case	O
A_F_SEARCH	int
:	O
search_type	int
=	O
SRCH_FORW	O
;	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
mca_search	()->(void)
(	O
)	O
;	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_B_SEARCH	int
:	O
search_type	int
=	O
SRCH_BACK	O
;	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
mca_search	()->(void)
(	O
)	O
;	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_FILTER	int
:	O
search_type	int
=	O
SRCH_FORW	O
|	O
SRCH_FILTER	O
;	O
mca_search	()->(void)
(	O
)	O
;	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_AGAIN_SEARCH	int
:	O
DO_SEARCH	O
(	O
)	O
;	O
break	O
;	O
case	O
A_T_AGAIN_SEARCH	int
:	O
search_type	int
|=	O
SRCH_PAST_EOF	O
;	O
DO_SEARCH	O
(	O
)	O
;	O
break	O
;	O
case	O
A_REVERSE_SEARCH	int
:	O
save_search_type	int
=	O
search_type	int
;	O
search_type	int
=	O
SRCH_REVERSE	O
(	O
search_type	int
)	O
;	O
DO_SEARCH	O
(	O
)	O
;	O
search_type	int
=	O
save_search_type	int
;	O
break	O
;	O
case	O
A_T_REVERSE_SEARCH	int
:	O
save_search_type	int
=	O
search_type	int
;	O
search_type	int
=	O
SRCH_REVERSE	O
(	O
search_type	int
)	O
;	O
search_type	int
|=	O
SRCH_PAST_EOF	O
;	O
DO_SEARCH	O
(	O
)	O
;	O
search_type	int
=	O
save_search_type	int
;	O
break	O
;	O
case	O
A_UNDO_SEARCH	int
:	O
undo_search	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
A_HELP	int
:	O
if	O
(	O
ch_getflags	()->(int)
(	O
)	O
&	O
CH_HELPFILE	int
)	O
break	O
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
save_hshift	int
=	O
hshift	int
;	O
hshift	int
=	O
0	int
;	O
save_bs_mode	int
=	O
bs_mode	int
;	O
bs_mode	int
=	O
BS_SPECIAL	int
;	O
(	O
void	O
)	O
edit	(*(char))->(int)
(	O
FAKE_HELPFILE	*(char)
)	O
;	O
break	O
;	O
case	O
A_EXAMINE	int
:	O
if	O
(	O
!	O
secure	int
)	O
{	O
start_mca	(int,*(char),*(void),int)->(void)
(	O
A_EXAMINE	int
,	O
"Examine: "	*(char)
,	O
ml_examine	*(void)
,	O
0	int
)	O
;	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
goto	O
again	O
;	O
}	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Command not available"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
A_VISUAL	int
:	O
if	O
(	O
!	O
secure	int
)	O
{	O
if	O
(	O
ch_getflags	()->(int)
(	O
)	O
&	O
CH_HELPFILE	int
)	O
break	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
get_filename	(*(void))->(*(char))
(	O
curr_ifile	*(void)
)	O
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Cannot edit standard input"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
get_altfilename	(*(void))->(*(char))
(	O
curr_ifile	*(void)
)	O
!=	O
NULL	O
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"WARNING: This file was viewed via LESSOPEN"	*(char)
,	O
NULL_PARG	O
)	O
;	O
}	O
start_mca	(int,*(char),*(void),int)->(void)
(	O
A_SHELL	int
,	O
"!"	*(char)
,	O
ml_shell	*(void)
,	O
0	int
)	O
;	O
make_display	()->(void)
(	O
)	O
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
lsystem	(*(char),*(char))->(void)
(	O
pr_expand	(*(char),int)->(*(char))
(	O
editproto	*(char)
,	O
0	int
)	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
}	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Command not available"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
A_NEXT_FILE	int
:	O
if	O
(	O
ntags	()->(int)
(	O
)	O
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"No next file"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
if	O
(	O
edit_next	(int)->(int)
(	O
(	O
int	O
)	O
number	long
)	O
)	O
{	O
if	O
(	O
get_quit_at_eof	()->(int)
(	O
)	O
&&	O
eof_displayed	()->(int)
(	O
)	O
&&	O
!	O
(	O
ch_getflags	()->(int)
(	O
)	O
&	O
CH_HELPFILE	int
)	O
)	O
quit	(int)->(void)
(	O
QUIT_OK	int
)	O
;	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
(	O
number	long
>	O
1	int
)	O
?	O
"(N-th) "	*(char)
:	O
""	*(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"No %snext file"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
}	O
break	O
;	O
case	O
A_PREV_FILE	int
:	O
if	O
(	O
ntags	()->(int)
(	O
)	O
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"No previous file"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
if	O
(	O
edit_prev	(int)->(int)
(	O
(	O
int	O
)	O
number	long
)	O
)	O
{	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
(	O
number	long
>	O
1	int
)	O
?	O
"(N-th) "	*(char)
:	O
""	*(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"No %sprevious file"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
}	O
break	O
;	O
case	O
A_NEXT_TAG	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
tagfile	*(char)
=	O
nexttag	(int)->(*(char))
(	O
(	O
int	O
)	O
number	long
)	O
;	O
if	O
(	O
tagfile	*(char)
==	O
NULL	O
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"No next tag"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
}	O
cmd_exec	()->(void)
(	O
)	O
;	O
if	O
(	O
edit	(*(char))->(int)
(	O
tagfile	*(char)
)	O
==	O
0	int
)	O
{	O
POSITION	long
pos	long
=	O
tagsearch	()->(long)
(	O
)	O
;	O
if	O
(	O
pos	long
!=	O
NULL_POSITION	O
)	O
jump_loc	(long,int)->(void)
(	O
pos	long
,	O
jump_sline	int
)	O
;	O
}	O
break	O
;	O
case	O
A_PREV_TAG	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
tagfile	*(char)
=	O
prevtag	(int)->(*(char))
(	O
(	O
int	O
)	O
number	long
)	O
;	O
if	O
(	O
tagfile	*(char)
==	O
NULL	O
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"No previous tag"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
}	O
cmd_exec	()->(void)
(	O
)	O
;	O
if	O
(	O
edit	(*(char))->(int)
(	O
tagfile	*(char)
)	O
==	O
0	int
)	O
{	O
POSITION	long
pos	long
=	O
tagsearch	()->(long)
(	O
)	O
;	O
if	O
(	O
pos	long
!=	O
NULL_POSITION	O
)	O
jump_loc	(long,int)->(void)
(	O
pos	long
,	O
jump_sline	int
)	O
;	O
}	O
break	O
;	O
case	O
A_INDEX_FILE	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
if	O
(	O
edit_index	(int)->(int)
(	O
(	O
int	O
)	O
number	long
)	O
)	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"No such file"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
A_REMOVE_FILE	int
:	O
if	O
(	O
ch_getflags	()->(int)
(	O
)	O
&	O
CH_HELPFILE	int
)	O
break	O
;	O
old_ifile	*(void)
=	O
curr_ifile	*(void)
;	O
new_ifile	*(void)
=	O
getoff_ifile	(*(void))->(*(void))
(	O
curr_ifile	*(void)
)	O
;	O
if	O
(	O
new_ifile	*(void)
==	O
NULL_IFILE	O
)	O
{	O
bell	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
edit_ifile	(*(void))->(int)
(	O
new_ifile	*(void)
)	O
!=	O
0	int
)	O
{	O
reedit_ifile	(*(void))->(void)
(	O
old_ifile	*(void)
)	O
;	O
break	O
;	O
}	O
del_ifile	(*(void))->(void)
(	O
old_ifile	*(void)
)	O
;	O
break	O
;	O
case	O
A_OPT_TOGGLE	int
:	O
optflag	int
=	O
OPT_TOGGLE	int
;	O
optgetname	int
=	O
FALSE	int
;	O
mca_opt_toggle	()->(void)
(	O
)	O
;	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_DISP_OPTION	int
:	O
optflag	int
=	O
OPT_NO_TOGGLE	int
;	O
optgetname	int
=	O
FALSE	int
;	O
mca_opt_toggle	()->(void)
(	O
)	O
;	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_FIRSTCMD	int
:	O
start_mca	(int,*(char),*(void),int)->(void)
(	O
A_FIRSTCMD	int
,	O
"+"	*(char)
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_SHELL	int
:	O
if	O
(	O
!	O
secure	int
)	O
{	O
start_mca	(int,*(char),*(void),int)->(void)
(	O
A_SHELL	int
,	O
"!"	*(char)
,	O
ml_shell	*(void)
,	O
0	int
)	O
;	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
goto	O
again	O
;	O
}	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Command not available"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
A_SETMARK	int
:	O
case	O
A_SETMARKBOT	int
:	O
if	O
(	O
ch_getflags	()->(int)
(	O
)	O
&	O
CH_HELPFILE	int
)	O
break	O
;	O
start_mca	(int,*(char),*(void),int)->(void)
(	O
A_SETMARK	int
,	O
"set mark: "	*(char)
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
if	O
(	O
is_erase_char	(int)->(int)
(	O
c	int
)	O
||	O
is_newline_char	(int)->(int)
(	O
c	int
)	O
)	O
break	O
;	O
setmark	(int,int)->(void)
(	O
c	int
,	O
action	int
==	O
A_SETMARKBOT	int
?	O
BOTTOM	O
:	O
TOP	O
)	O
;	O
repaint	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
A_CLRMARK	int
:	O
start_mca	(int,*(char),*(void),int)->(void)
(	O
A_CLRMARK	int
,	O
"clear mark: "	*(char)
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
if	O
(	O
is_erase_char	(int)->(int)
(	O
c	int
)	O
||	O
is_newline_char	(int)->(int)
(	O
c	int
)	O
)	O
break	O
;	O
clrmark	(int)->(void)
(	O
c	int
)	O
;	O
repaint	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
A_GOMARK	int
:	O
start_mca	(int,*(char),*(void),int)->(void)
(	O
A_GOMARK	int
,	O
"goto mark: "	*(char)
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
if	O
(	O
is_erase_char	(int)->(int)
(	O
c	int
)	O
||	O
is_newline_char	(int)->(int)
(	O
c	int
)	O
)	O
break	O
;	O
cmd_exec	()->(void)
(	O
)	O
;	O
gomark	(int)->(void)
(	O
c	int
)	O
;	O
break	O
;	O
case	O
A_PIPE	int
:	O
if	O
(	O
!	O
secure	int
)	O
{	O
start_mca	(int,*(char),*(void),int)->(void)
(	O
A_PIPE	int
,	O
"|mark: "	*(char)
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
if	O
(	O
is_erase_char	(int)->(int)
(	O
c	int
)	O
)	O
break	O
;	O
if	O
(	O
is_newline_char	(int)->(int)
(	O
c	int
)	O
)	O
c	int
=	O
'.'	O
;	O
if	O
(	O
badmark	(int)->(int)
(	O
c	int
)	O
)	O
break	O
;	O
pipec	char
=	O
c	int
;	O
start_mca	(int,*(char),*(void),int)->(void)
(	O
A_PIPE	int
,	O
"!"	*(char)
,	O
ml_shell	*(void)
,	O
0	int
)	O
;	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
goto	O
again	O
;	O
}	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Command not available"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
A_B_BRACKET	int
:	O
case	O
A_F_BRACKET	int
:	O
start_mca	(int,*(char),*(void),int)->(void)
(	O
action	int
,	O
"Brackets: "	*(char)
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_LSHIFT	int
:	O
if	O
(	O
number	long
>	O
0	int
)	O
shift_count	int
=	O
number	long
;	O
else	O
number	long
=	O
(	O
shift_count	int
>	O
0	int
)	O
?	O
shift_count	int
:	O
sc_width	int
/	O
2	int
;	O
if	O
(	O
number	long
>	O
hshift	int
)	O
number	long
=	O
hshift	int
;	O
hshift	int
-=	O
number	long
;	O
screen_trashed	int
=	O
1	int
;	O
break	O
;	O
case	O
A_RSHIFT	int
:	O
if	O
(	O
number	long
>	O
0	int
)	O
shift_count	int
=	O
number	long
;	O
else	O
number	long
=	O
(	O
shift_count	int
>	O
0	int
)	O
?	O
shift_count	int
:	O
sc_width	int
/	O
2	int
;	O
hshift	int
+=	O
number	long
;	O
screen_trashed	int
=	O
1	int
;	O
break	O
;	O
case	O
A_LLSHIFT	int
:	O
hshift	int
=	O
0	int
;	O
screen_trashed	int
=	O
1	int
;	O
break	O
;	O
case	O
A_RRSHIFT	int
:	O
hshift	int
=	O
rrshift	()->(int)
(	O
)	O
;	O
screen_trashed	int
=	O
1	int
;	O
break	O
;	O
case	O
A_PREFIX	int
:	O
if	O
(	O
mca	int
!=	O
A_PREFIX	int
)	O
{	O
cmd_reset	()->(void)
(	O
)	O
;	O
start_mca	(int,*(char),*(void),int)->(void)
(	O
A_PREFIX	int
,	O
" "	*(char)
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
CF_QUIT_ON_ERASE	int
)	O
;	O
(	O
void	O
)	O
cmd_char	(int)->(int)
(	O
c	int
)	O
;	O
}	O
c	int
=	O
getcc	()->(int)
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_NOACTION	int
:	O
break	O
;	O
default	O
:	O
bell	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
