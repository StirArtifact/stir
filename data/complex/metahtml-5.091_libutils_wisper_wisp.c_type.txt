static	O
void	O
initialize_string_buffer	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
print_object_to_string_buffer	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
static	O
void	O
print_string_to_string_buffer	(*(char))->(void)
(	O
char	O
*	O
string	*(char)
)	O
;	O
static	O
void	O
print_list_contents	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
WispObject	struct
*	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
static	O
char	O
*	O
get_string_buffer	()->(*(char))
(	O
void	O
)	O
;	O
static	O
char	O
*	O
read_string	()->(*(char))
(	O
void	O
)	O
;	O
static	O
WispObject	struct
*	O
read_symbol_or_number	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
void	O
)	O
;	O
static	O
WispObject	struct
*	O
read_list	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
void	O
)	O
;	O
static	O
int	O
read_character	()->(int)
(	O
void	O
)	O
;	O
static	O
void	O
unread_character	()->(void)
(	O
void	O
)	O
;	O
WispObject	struct
wisp_nil_value	struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct(enum(int,int,int,int,int),union`)),*(struct(enum(int,int,int,int,int),union`))),*(struct(*(char),*(struct`)))))
=	O
{	O
LT_nil	int
}	O
;	O
WispObject	struct
wisp_dot_value	struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct(enum(int,int,int,int,int),union`)),*(struct(enum(int,int,int,int,int),union`))),*(struct(*(char),*(struct`)))))
=	O
{	O
LT_string	int
,	O
{	O
"."	*(char)
}	O
}	O
;	O
static	O
WispObject	struct
*	O
*	O
obarray	*(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
=	O
(	O
WispObject	struct
*	O
*	O
)	O
NULL	O
;	O
static	O
int	O
obarray_index	int
=	O
0	int
;	O
static	O
int	O
obarray_size	int
=	O
0	int
;	O
static	O
void	O
obarray_add	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
{	O
if	O
(	O
(	O
obarray_index	int
+	O
2	int
)	O
>	O
obarray_size	int
)	O
obarray	*(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
=	O
(	O
WispObject	struct
*	O
*	O
)	O
xrealloc	(*(void),int)->(*(void))
(	O
obarray	*(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
,	O
(	O
obarray_size	int
+=	O
1000	int
)	O
*	O
sizeof	O
(	O
WispObject	struct
*	O
)	O
)	O
;	O
obarray	*(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
[	O
obarray_index	int
++	O
]	O
=	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
obarray	*(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
[	O
obarray_index	int
]	O
=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
;	O
}	O
static	O
void	O
obarray_del	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
{	O
register	O
int	O
i	int
,	O
j	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
obarray_index	int
;	O
i	int
++	O
)	O
if	O
(	O
obarray	*(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
[	O
i	int
]	O
==	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
{	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
(	O
obarray	*(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
[	O
i	int
]	O
=	O
obarray	*(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
[	O
j	int
]	O
)	O
!=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
;	O
j	int
++	O
,	O
i	int
++	O
)	O
;	O
if	O
(	O
obarray_index	int
==	O
j	int
)	O
obarray_index	int
--	O
;	O
break	O
;	O
}	O
}	O
void	O
gc_wisp_free	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
{	O
switch	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
type	enum(int,int,int,int,int)
)	O
{	O
case	O
LT_string	int
:	O
free	(*(void))->(void)
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
val	union(*(char),double,struct(*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`))),*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`)))),*(struct(*(char),*(struct(enum(int,int,int,int,int),union`)))))
.	O
string	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
break	O
;	O
case	O
LT_number	int
:	O
case	O
LT_cons	int
:	O
case	O
LT_symbol	int
:	O
free	(*(void))->(void)
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
break	O
;	O
case	O
LT_nil	int
:	O
break	O
;	O
}	O
}	O
void	O
gc_wisp_objects	()->(void)
(	O
)	O
{	O
register	O
int	O
i	int
;	O
register	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
obarray_index	int
;	O
i	int
++	O
)	O
{	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
obarray	*(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
[	O
i	int
]	O
;	O
gc_wisp_free	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
obarray_index	int
=	O
0	int
;	O
}	O
static	O
WispObject	struct
*	O
allocate_object	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
void	O
)	O
{	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
(	O
WispObject	struct
*	O
)	O
xmalloc	(int)->(*(void))
(	O
sizeof	O
(	O
WispObject	struct
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
void	O
*	O
)	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
,	O
0	int
,	O
sizeof	O
(	O
WispObject	struct
)	O
)	O
;	O
obarray_add	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
return	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
void	O
gc_steal	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
obarray_index	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
obarray	*(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
[	O
i	int
]	O
==	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
{	O
for	O
(	O
;	O
i	int
<	O
obarray_index	int
;	O
i	int
++	O
)	O
obarray	*(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
[	O
i	int
]	O
=	O
obarray	*(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
[	O
i	int
+	O
1	int
]	O
;	O
obarray	*(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
[	O
i	int
]	O
=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
;	O
obarray_index	int
--	O
;	O
break	O
;	O
}	O
}	O
}	O
WispObject	struct
*	O
make_string_object	(*(char))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
char	O
*	O
string	*(char)
)	O
{	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
allocate_object	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
;	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
type	enum(int,int,int,int,int)
=	O
LT_string	int
;	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
val	union(*(char),double,struct(*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`))),*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`)))),*(struct(*(char),*(struct(enum(int,int,int,int,int),union`)))))
.	O
string	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
string	*(char)
)	O
;	O
return	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
WispObject	struct
*	O
make_number_object	(double)->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
double	O
number	double
)	O
{	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
allocate_object	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
;	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
type	enum(int,int,int,int,int)
=	O
LT_number	int
;	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
val	union(*(char),double,struct(*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`))),*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`)))),*(struct(*(char),*(struct(enum(int,int,int,int,int),union`)))))
.	O
number	double
=	O
number	double
;	O
return	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
WispObject	struct
*	O
make_cons	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))),*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
WispObject	struct
*	O
car	*(struct)
,	O
WispObject	struct
*	O
cdr	*(struct)
)	O
{	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
allocate_object	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
;	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
type	enum(int,int,int,int,int)
=	O
LT_cons	int
;	O
CAR	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
=	O
car	*(struct)
;	O
CDR	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
=	O
cdr	*(struct)
;	O
return	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
WispObject	struct
*	O
make_list	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))),*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
WispObject	struct
*	O
car	*(struct)
,	O
WispObject	struct
*	O
cdr	*(struct)
)	O
{	O
WispObject	struct
*	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
make_cons	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))),*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
cdr	*(struct)
,	O
NIL	O
)	O
;	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
make_cons	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))),*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
car	*(struct)
,	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
return	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
char	O
*	O
string_from_wisp	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(*(char))
(	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
{	O
initialize_string_buffer	()->(void)
(	O
)	O
;	O
print_object_to_string_buffer	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
return	O
(	O
get_string_buffer	()->(*(char))
(	O
)	O
)	O
;	O
}	O
WispObject	struct
*	O
wisp_from_string	(*(char))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
char	O
*	O
string	*(char)
)	O
{	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
if	O
(	O
(	O
string	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
||	O
(	O
*	O
string	*(char)
==	O
'\0'	O
)	O
)	O
return	O
(	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
;	O
wisp_push_input_string	(*(char))->(void)
(	O
string	*(char)
)	O
;	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
wisp_read	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
;	O
wisp_pop_input_string	()->(void)
(	O
)	O
;	O
return	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
WispObject	struct
*	O
wisp_read	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
{	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
;	O
int	O
reading_object	int
=	O
1	int
;	O
while	O
(	O
reading_object	int
)	O
{	O
int	O
character	int
;	O
character	int
=	O
read_character	()->(int)
(	O
)	O
;	O
switch	O
(	O
character	int
)	O
{	O
case	O
EOF	O
:	O
reading_object	int
=	O
0	int
;	O
break	O
;	O
case	O
'"'	O
:	O
{	O
char	O
*	O
string	*(char)
;	O
string	*(char)
=	O
read_string	()->(*(char))
(	O
)	O
;	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
make_string_object	(*(char))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
string	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
string	*(char)
)	O
;	O
reading_object	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
'\''	O
:	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
wisp_read	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
;	O
reading_object	int
=	O
0	int
;	O
break	O
;	O
case	O
'('	O
:	O
{	O
WispObject	struct
*	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
read_list	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
;	O
if	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
==	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
NIL	O
;	O
else	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
reading_object	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
')'	O
:	O
reading_object	int
=	O
0	int
;	O
break	O
;	O
case	O
'\t'	O
:	O
case	O
' '	O
:	O
case	O
'\r'	O
:	O
case	O
'\n'	O
:	O
break	O
;	O
case	O
';'	O
:	O
while	O
(	O
(	O
(	O
character	int
=	O
read_character	()->(int)
(	O
)	O
)	O
!=	O
EOF	O
)	O
&&	O
(	O
character	int
!=	O
'\n'	O
)	O
)	O
;	O
break	O
;	O
default	O
:	O
{	O
unread_character	()->(void)
(	O
)	O
;	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
read_symbol_or_number	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
;	O
reading_object	int
=	O
0	int
;	O
if	O
(	O
(	O
(	O
STRING_P	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
&&	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
STRING_VALUE	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
,	O
"."	*(char)
)	O
==	O
0	int
)	O
)	O
||	O
(	O
(	O
SYMBOL_P	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
&&	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
SYMBOL_PNAME	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
,	O
"."	*(char)
)	O
==	O
0	int
)	O
)	O
)	O
{	O
obarray_del	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
free	(*(void))->(void)
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
val	union(*(char),double,struct(*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`))),*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`)))),*(struct(*(char),*(struct(enum(int,int,int,int,int),union`)))))
.	O
string	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
&	O
wisp_dot_value	struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct(enum(int,int,int,int,int),union`)),*(struct(enum(int,int,int,int,int),union`))),*(struct(*(char),*(struct`)))))
;	O
}	O
}	O
break	O
;	O
}	O
}	O
return	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
static	O
char	O
*	O
read_string_1	(int)->(*(char))
(	O
int	O
delimited	int
)	O
{	O
char	O
*	O
string	*(char)
;	O
int	O
string_index	int
,	O
string_size	int
;	O
int	O
chars_to_read	int
=	O
1	int
;	O
string	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(int)->(*(void))
(	O
1	int
)	O
;	O
*	O
string	*(char)
=	O
'\0'	O
;	O
string_index	int
=	O
0	int
;	O
string_size	int
=	O
1	int
;	O
while	O
(	O
chars_to_read	int
)	O
{	O
int	O
character	int
;	O
character	int
=	O
read_character	()->(int)
(	O
)	O
;	O
if	O
(	O
character	int
==	O
EOF	O
)	O
{	O
chars_to_read	int
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
delimited	int
)	O
{	O
if	O
(	O
self_delimiting	O
(	O
character	int
)	O
)	O
unread_character	()->(void)
(	O
)	O
;	O
if	O
(	O
whitespace_or_newline	O
(	O
character	int
)	O
||	O
self_delimiting	O
(	O
character	int
)	O
)	O
{	O
chars_to_read	int
=	O
0	int
;	O
continue	O
;	O
}	O
}	O
switch	O
(	O
character	int
)	O
{	O
case	O
'\\'	O
:	O
character	int
=	O
read_character	()->(int)
(	O
)	O
;	O
switch	O
(	O
character	int
)	O
{	O
case	O
'n'	O
:	O
case	O
'r'	O
:	O
character	int
=	O
'\n'	O
;	O
break	O
;	O
case	O
't'	O
:	O
character	int
=	O
'\t'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
character	int
=	O
'\f'	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
case	O
'\r'	O
:	O
continue	O
;	O
}	O
if	O
(	O
string_index	int
+	O
1	int
>=	O
string_size	int
)	O
string	*(char)
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),int)->(*(void))
(	O
string	*(char)
,	O
(	O
string_size	int
+=	O
20	int
)	O
)	O
;	O
string	*(char)
[	O
string_index	int
++	O
]	O
=	O
character	int
;	O
string	*(char)
[	O
string_index	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
case	O
'"'	O
:	O
chars_to_read	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
string_index	int
+	O
1	int
>=	O
string_size	int
)	O
string	*(char)
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),int)->(*(void))
(	O
string	*(char)
,	O
(	O
string_size	int
+=	O
20	int
)	O
)	O
;	O
string	*(char)
[	O
string_index	int
++	O
]	O
=	O
character	int
;	O
string	*(char)
[	O
string_index	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
return	O
(	O
string	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
read_string	()->(*(char))
(	O
)	O
{	O
return	O
(	O
read_string_1	(int)->(*(char))
(	O
1	int
)	O
)	O
;	O
}	O
static	O
WispObject	struct
*	O
read_symbol_or_number	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
void	O
)	O
{	O
char	O
*	O
string	*(char)
;	O
string	*(char)
=	O
read_string_1	(int)->(*(char))
(	O
0	int
)	O
;	O
{	O
WispObject	struct
*	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
make_string_object	(*(char))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
string	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
string	*(char)
)	O
;	O
return	O
(	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
}	O
static	O
WispObject	struct
*	O
read_list	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
void	O
)	O
{	O
WispObject	struct
*	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
,	O
*	O
val_read	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
val_read	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
wisp_read	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
;	O
if	O
(	O
val_read	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
==	O
&	O
wisp_dot_value	struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct(enum(int,int,int,int,int),union`)),*(struct(enum(int,int,int,int,int),union`))),*(struct(*(char),*(struct`)))))
)	O
{	O
WispObject	struct
*	O
next_val	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
;	O
val_read	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
wisp_read	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
;	O
if	O
(	O
val_read	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
!=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
{	O
next_val	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
wisp_read	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
;	O
if	O
(	O
next_val	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
==	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
return	O
(	O
val_read	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
else	O
{	O
WispObject	struct
*	O
new_list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
allocate_object	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
;	O
new_list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
type	enum(int,int,int,int,int)
=	O
LT_cons	int
;	O
CAR	O
(	O
new_list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
=	O
val_read	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
CDR	O
(	O
new_list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
=	O
make_cons	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))),*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
next_val	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
,	O
read_list	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
)	O
;	O
return	O
(	O
new_list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
}	O
}	O
if	O
(	O
val_read	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
==	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
NIL	O
;	O
else	O
{	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
allocate_object	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
;	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
type	enum(int,int,int,int,int)
=	O
LT_cons	int
;	O
CAR	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
=	O
val_read	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
CDR	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
=	O
read_list	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
;	O
}	O
return	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
static	O
void	O
print_object_to_string_buffer	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
{	O
if	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
==	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
switch	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
type	enum(int,int,int,int,int)
)	O
{	O
case	O
LT_string	int
:	O
{	O
register	O
int	O
i	int
,	O
j	int
;	O
char	O
*	O
string	*(char)
,	O
*	O
pr	*(char)
;	O
string	*(char)
=	O
STRING_VALUE	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
pr	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(int)->(*(void))
(	O
(	O
2	int
*	O
STRING_LENGTH	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
+	O
1	int
)	O
;	O
j	int
=	O
0	int
;	O
pr	*(char)
[	O
j	int
++	O
]	O
=	O
'"'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
string	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
(	O
string	*(char)
[	O
i	int
]	O
!=	O
'\0'	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
string	*(char)
[	O
i	int
]	O
==	O
'"'	O
)	O
pr	*(char)
[	O
j	int
++	O
]	O
=	O
'\\'	O
;	O
pr	*(char)
[	O
j	int
++	O
]	O
=	O
string	*(char)
[	O
i	int
]	O
;	O
}	O
pr	*(char)
[	O
j	int
++	O
]	O
=	O
'"'	O
;	O
pr	*(char)
[	O
j	int
++	O
]	O
=	O
'\0'	O
;	O
print_string_to_string_buffer	(*(char))->(void)
(	O
pr	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
pr	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
LT_number	int
:	O
{	O
char	O
float_rep	array(char)
[	O
100	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
float_rep	array(char)
,	O
"\"%.2f\""	*(char)
,	O
NUMBER_VALUE	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
;	O
print_string_to_string_buffer	(*(char))->(void)
(	O
float_rep	array(char)
)	O
;	O
}	O
break	O
;	O
case	O
LT_cons	int
:	O
if	O
(	O
CAR	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
==	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
else	O
{	O
print_string_to_string_buffer	(*(char))->(void)
(	O
"("	*(char)
)	O
;	O
print_list_contents	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
print_string_to_string_buffer	(*(char))->(void)
(	O
")"	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
LT_symbol	int
:	O
print_string_to_string_buffer	(*(char))->(void)
(	O
SYMBOL_PNAME	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
;	O
break	O
;	O
case	O
LT_nil	int
:	O
print_string_to_string_buffer	(*(char))->(void)
(	O
"()"	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
print_list_contents	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
WispObject	struct
*	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
{	O
if	O
(	O
NIL_P	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
return	O
;	O
print_object_to_string_buffer	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
CAR	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
;	O
if	O
(	O
!	O
NIL_P	O
(	O
CDR	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
)	O
{	O
print_string_to_string_buffer	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
if	O
(	O
CONS_P	O
(	O
CDR	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
)	O
print_list_contents	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
CDR	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
;	O
else	O
{	O
print_string_to_string_buffer	(*(char))->(void)
(	O
". "	*(char)
)	O
;	O
print_object_to_string_buffer	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(void)
(	O
CDR	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
;	O
}	O
}	O
}	O
static	O
char	O
*	O
string_buffer	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
int	O
sb_index	int
=	O
0	int
;	O
static	O
int	O
sb_size	int
=	O
0	int
;	O
static	O
void	O
initialize_string_buffer	()->(void)
(	O
)	O
{	O
sb_index	int
=	O
0	int
;	O
if	O
(	O
string_buffer	*(char)
)	O
string_buffer	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
static	O
char	O
*	O
get_string_buffer	()->(*(char))
(	O
)	O
{	O
return	O
(	O
string_buffer	*(char)
)	O
;	O
}	O
static	O
void	O
print_string_to_string_buffer	(*(char))->(void)
(	O
char	O
*	O
string	*(char)
)	O
{	O
int	O
len	int
=	O
0	int
;	O
if	O
(	O
string	*(char)
)	O
len	int
+=	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
;	O
if	O
(	O
!	O
len	int
)	O
return	O
;	O
while	O
(	O
(	O
sb_index	int
+	O
len	int
)	O
>=	O
sb_size	int
)	O
string_buffer	*(char)
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),int)->(*(void))
(	O
string_buffer	*(char)
,	O
(	O
sb_size	int
+=	O
EXPANSION	int
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
string_buffer	*(char)
+	O
sb_index	int
,	O
string	*(char)
)	O
;	O
sb_index	int
+=	O
len	int
;	O
}	O
static	O
char	O
*	O
the_input_string	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
int	O
the_input_string_index	int
=	O
0	int
;	O
void	O
wisp_push_input_string	(*(char))->(void)
(	O
char	O
*	O
string	*(char)
)	O
{	O
the_input_string	*(char)
=	O
string	*(char)
;	O
the_input_string_index	int
=	O
0	int
;	O
}	O
void	O
wisp_pop_input_string	()->(void)
(	O
)	O
{	O
the_input_string	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
the_input_string_index	int
=	O
0	int
;	O
}	O
static	O
int	O
read_character	()->(int)
(	O
)	O
{	O
int	O
character	int
=	O
EOF	O
;	O
if	O
(	O
(	O
the_input_string	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
(	O
the_input_string	*(char)
[	O
the_input_string_index	int
]	O
!=	O
'\0'	O
)	O
)	O
character	int
=	O
the_input_string	*(char)
[	O
the_input_string_index	int
++	O
]	O
&	O
0x00ff	int
;	O
return	O
(	O
character	int
)	O
;	O
}	O
static	O
void	O
unread_character	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
(	O
the_input_string	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
||	O
(	O
the_input_string_index	int
==	O
0	int
)	O
)	O
return	O
;	O
the_input_string_index	int
--	O
;	O
}	O
char	O
*	O
wisp_readable	(*(char))->(*(char))
(	O
char	O
*	O
string	*(char)
)	O
{	O
int	O
len	int
=	O
(	O
string	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
?	O
1	int
:	O
(	O
3	int
+	O
(	O
2	int
*	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
)	O
)	O
;	O
static	O
char	O
*	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),int)->(*(void))
(	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
,	O
len	int
)	O
;	O
if	O
(	O
string	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
register	O
int	O
i	int
,	O
j	int
;	O
j	int
=	O
0	int
;	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
[	O
j	int
++	O
]	O
=	O
'"'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
string	*(char)
[	O
i	int
]	O
!=	O
'\0'	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
string	*(char)
[	O
i	int
]	O
==	O
'"'	O
)	O
||	O
(	O
string	*(char)
[	O
i	int
]	O
==	O
'\\'	O
)	O
)	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
[	O
j	int
++	O
]	O
=	O
'\\'	O
;	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
[	O
j	int
++	O
]	O
=	O
string	*(char)
[	O
i	int
]	O
;	O
}	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
[	O
j	int
++	O
]	O
=	O
'"'	O
;	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
[	O
j	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
[	O
0	int
]	O
=	O
'0'	O
;	O
}	O
return	O
(	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
WispObject	struct
*	O
assoc	(*(char),*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
char	O
*	O
key	*(char)
,	O
WispObject	struct
*	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
{	O
while	O
(	O
CONS_P	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
&&	O
CONS_P	O
(	O
CAR	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
)	O
{	O
WispObject	struct
*	O
pair	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
,	O
*	O
car	*(struct)
;	O
pair	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
CAR	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
car	*(struct)
=	O
CAR	O
(	O
pair	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
if	O
(	O
STRING_P	O
(	O
car	*(struct)
)	O
&&	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
STRING_VALUE	O
(	O
car	*(struct)
)	O
,	O
key	*(char)
)	O
==	O
0	int
)	O
)	O
return	O
(	O
pair	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
CDR	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
return	O
(	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
;	O
}	O
char	O
*	O
sassoc	(*(char),*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(*(char))
(	O
char	O
*	O
key	*(char)
,	O
WispObject	struct
*	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
{	O
WispObject	struct
*	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
assoc	(*(char),*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
key	*(char)
,	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
if	O
(	O
(	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
!=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
&&	O
(	O
CONS_P	O
(	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
&&	O
(	O
STRING_P	O
(	O
CAR	O
(	O
CDR	O
(	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
)	O
)	O
)	O
return	O
(	O
STRING_VALUE	O
(	O
CAR	O
(	O
CDR	O
(	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
)	O
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
WispObject	struct
*	O
wisp_append	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))),*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
WispObject	struct
*	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
,	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
{	O
WispObject	struct
*	O
last_cons	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
if	O
(	O
NIL_P	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
return	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
while	O
(	O
CONS_P	O
(	O
last_cons	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
{	O
if	O
(	O
NIL_P	O
(	O
CDR	O
(	O
last_cons	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
)	O
{	O
CDR	O
(	O
last_cons	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
=	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
;	O
return	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
last_cons	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
CDR	O
(	O
last_cons	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
abort	()->(void)
(	O
)	O
;	O
}	O
WispObject	struct
*	O
copy_object	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
{	O
WispObject	struct
*	O
copy	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
;	O
if	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
==	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
return	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
copy	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
allocate_object	()->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
)	O
;	O
copy	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
type	enum(int,int,int,int,int)
=	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
type	enum(int,int,int,int,int)
;	O
switch	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
type	enum(int,int,int,int,int)
)	O
{	O
case	O
LT_string	int
:	O
copy	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
val	union(*(char),double,struct(*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`))),*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`)))),*(struct(*(char),*(struct(enum(int,int,int,int,int),union`)))))
.	O
string	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
STRING_VALUE	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
;	O
break	O
;	O
case	O
LT_number	int
:	O
copy	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
val	union(*(char),double,struct(*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`))),*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`)))),*(struct(*(char),*(struct(enum(int,int,int,int,int),union`)))))
.	O
number	double
=	O
NUMBER_VALUE	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
break	O
;	O
case	O
LT_cons	int
:	O
CAR	O
(	O
copy	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
=	O
copy_object	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
CAR	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
;	O
CDR	O
(	O
copy	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
=	O
copy_object	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
CDR	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
;	O
break	O
;	O
case	O
LT_symbol	int
:	O
copy	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
val	union(*(char),double,struct(*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`))),*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`)))),*(struct(*(char),*(struct(enum(int,int,int,int,int),union`)))))
.	O
symbol	*(struct(*(char),*(struct(enum(int,int,int,int,int)))))
=	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
val	union(*(char),double,struct(*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`))),*(struct(enum(int,int,int,int,int),union(*`,double,struct`,*`)))),*(struct(*(char),*(struct(enum(int,int,int,int,int),union`)))))
.	O
symbol	*(struct(*(char),*(struct(enum(int,int,int,int,int)))))
;	O
break	O
;	O
case	O
LT_nil	int
:	O
free	(*(void))->(void)
(	O
copy	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
copy	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
NIL	O
;	O
}	O
return	O
(	O
copy	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
WispObject	struct
*	O
wisp_nth	(int,*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))
(	O
int	O
n	int
,	O
WispObject	struct
*	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
{	O
WispObject	struct
*	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
NIL	O
;	O
while	O
(	O
(	O
CONS_P	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
&&	O
(	O
n	int
>	O
0	int
)	O
)	O
{	O
--	O
n	int
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
CAR	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
break	O
;	O
}	O
else	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
CDR	O
(	O
list	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
return	O
(	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
int	O
wisp_length	(*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*`,*`),*(struct`)))))->(int)
(	O
WispObject	struct
*	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
{	O
int	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
0	int
;	O
if	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
!=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
{	O
switch	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
->	O
type	enum(int,int,int,int,int)
)	O
{	O
case	O
LT_nil	int
:	O
break	O
;	O
case	O
LT_string	int
:	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
strlen	(*(char))->(long)
(	O
STRING_VALUE	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
;	O
break	O
;	O
case	O
LT_cons	int
:	O
{	O
while	O
(	O
CONS_P	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
{	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
++	O
;	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
CDR	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
if	O
(	O
!	O
CONS_P	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
&&	O
!	O
NIL_P	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
++	O
;	O
}	O
break	O
;	O
case	O
LT_number	int
:	O
{	O
char	O
buffer	array(char)
[	O
100	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buffer	array(char)
,	O
"%f"	*(char)
,	O
NUMBER_VALUE	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
;	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
strlen	(*(char))->(long)
(	O
buffer	array(char)
)	O
;	O
}	O
break	O
;	O
case	O
LT_symbol	int
:	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
=	O
strlen	(*(char))->(long)
(	O
SYMBOL_PNAME	O
(	O
object	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
return	O
(	O
result	*(struct(enum(int,int,int,int,int),union(*(char),double,struct(*(struct`),*(struct`)),*(struct(*`,*`)))))
)	O
;	O
}	O
