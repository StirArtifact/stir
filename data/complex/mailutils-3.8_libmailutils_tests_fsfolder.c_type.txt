int	O
sort_option	int
;	O
int	O
prefix_len	int
;	O
static	O
int	O
compare_response	(*(void),*(void))->(int)
(	O
void	O
const	O
*	O
a	*(struct(*(char),int,int))
,	O
void	O
const	O
*	O
b	*(struct(*(char),int,int))
)	O
{	O
struct	O
mu_list_response	struct(int,int,int,*(char),*(struct))
const	O
*	O
ra	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
=	O
a	*(struct(*(char),int,int))
;	O
struct	O
mu_list_response	struct(int,int,int,*(char),*(struct))
const	O
*	O
rb	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
=	O
b	*(struct(*(char),int,int))
;	O
if	O
(	O
ra	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
depth	int
<	O
rb	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
depth	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ra	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
depth	int
>	O
rb	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
depth	int
)	O
return	O
1	int
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
ra	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
name	*(char)
,	O
rb	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
name	*(char)
)	O
;	O
}	O
static	O
int	O
_print_list_entry	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
mu_list_response	struct(int,int,int,*(char),*(struct))
*	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
=	O
item	*(void)
;	O
int	O
len	int
=	O
data	*(void)
?	O
*	O
(	O
int	O
*	O
)	O
data	*(void)
:	O
0	int
;	O
mu_printf	(*(char))->(int)
(	O
"%c%c %c %4d %s\n"	*(char)
,	O
(	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
type	int
&	O
MU_FOLDER_ATTRIBUTE_DIRECTORY	int
)	O
?	O
'd'	O
:	O
'-'	O
,	O
(	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
type	int
&	O
MU_FOLDER_ATTRIBUTE_FILE	int
)	O
?	O
'f'	O
:	O
'-'	O
,	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
separator	int
?	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
separator	int
:	O
' '	O
,	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
depth	int
,	O
resp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
name	*(char)
+	O
len	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_list	(int,*(*(char)),*(struct),*(void))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
mu_assoc_t	*(struct)
options	*(struct)
,	O
void	O
*	O
env	*(void)
)	O
{	O
mu_folder_t	*(struct)
folder	*(struct)
=	O
env	*(void)
;	O
int	O
rc	int
;	O
mu_list_t	*(struct)
list	*(struct)
;	O
mu_printf	(*(char))->(int)
(	O
"listing '%s' '%s'\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_list	(*(struct),*(char),*(void),long,*(*(struct)))->(int)
(	O
folder	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
argv	*(*(char))
[	O
2	int
]	O
,	O
0	int
,	O
&	O
list	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_list"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
rc	int
)	O
;	O
else	O
{	O
if	O
(	O
sort_option	int
)	O
mu_list_sort	(*(struct),*((*(void),*(void))->(int)))->(void)
(	O
list	*(struct)
,	O
compare_response	(*(void),*(void))->(int)
)	O
;	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
list	*(struct)
,	O
_print_list_entry	(*(void),*(void))->(int)
,	O
&	O
prefix_len	int
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
list	*(struct)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
com_lsub	(int,*(*(char)),*(struct),*(void))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
mu_assoc_t	*(struct)
options	*(struct)
,	O
void	O
*	O
env	*(void)
)	O
{	O
mu_folder_t	*(struct)
folder	*(struct)
=	O
env	*(void)
;	O
int	O
rc	int
;	O
mu_list_t	*(struct)
list	*(struct)
;	O
mu_printf	(*(char))->(int)
(	O
"listing subscriptions for '%s' '%s'\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_lsub	(*(struct),*(char),*(char),*(*(struct)))->(int)
(	O
folder	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
argv	*(*(char))
[	O
2	int
]	O
,	O
&	O
list	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_lsub"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
rc	int
)	O
;	O
else	O
{	O
if	O
(	O
sort_option	int
)	O
mu_list_sort	(*(struct),*((*(void),*(void))->(int)))->(void)
(	O
list	*(struct)
,	O
compare_response	(*(void),*(void))->(int)
)	O
;	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
list	*(struct)
,	O
_print_list_entry	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
list	*(struct)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
com_rename	(int,*(*(char)),*(struct),*(void))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
mu_assoc_t	*(struct)
options	*(struct)
,	O
void	O
*	O
env	*(void)
)	O
{	O
int	O
rc	int
;	O
mu_folder_t	*(struct)
folder	*(struct)
=	O
env	*(void)
;	O
mu_printf	(*(char))->(int)
(	O
"renaming %s to %s\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_rename	(*(struct),*(char),*(char))->(int)
(	O
folder	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_rename"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
rc	int
)	O
;	O
else	O
mu_printf	(*(char))->(int)
(	O
"rename successful\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_subscribe	(int,*(*(char)),*(struct),*(void))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
mu_assoc_t	*(struct)
options	*(struct)
,	O
void	O
*	O
env	*(void)
)	O
{	O
mu_folder_t	*(struct)
folder	*(struct)
=	O
env	*(void)
;	O
int	O
rc	int
;	O
mu_printf	(*(char))->(int)
(	O
"subscribing %s\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_subscribe	(*(struct),*(char))->(int)
(	O
folder	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_subscribe"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
rc	int
)	O
;	O
else	O
mu_printf	(*(char))->(int)
(	O
"subscribe successful\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_unsubscribe	(int,*(*(char)),*(struct),*(void))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
mu_assoc_t	*(struct)
options	*(struct)
,	O
void	O
*	O
env	*(void)
)	O
{	O
mu_folder_t	*(struct)
folder	*(struct)
=	O
env	*(void)
;	O
int	O
rc	int
;	O
mu_printf	(*(char))->(int)
(	O
"unsubscribing %s\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_unsubscribe	(*(struct),*(char))->(int)
(	O
folder	*(struct)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_unsubscribe"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
rc	int
)	O
;	O
else	O
mu_printf	(*(char))->(int)
(	O
"unsubscribe successful\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_scan	(int,*(*(char)),*(struct),*(void))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
mu_assoc_t	*(struct)
options	*(struct)
,	O
void	O
*	O
env	*(void)
)	O
{	O
mu_folder_t	*(struct)
folder	*(struct)
=	O
env	*(void)
;	O
struct	O
mu_folder_scanner	struct(*(char),*(void),int,long,*((*(struct),*(struct(int,int,int,*(char),*(struct`))),*(void))->(int)),*(void),*(struct),*(struct))
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
=	O
MU_FOLDER_SCANNER_INITIALIZER	O
;	O
char	O
*	O
s	*(char)
;	O
int	O
rc	int
;	O
if	O
(	O
argc	int
>	O
1	int
)	O
{	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
.	O
refname	*(*(char))
=	O
argv	*(*(char))
[	O
1	int
]	O
;	O
if	O
(	O
argc	int
==	O
3	int
)	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
.	O
pattern	*(void)
=	O
argv	*(*(char))
[	O
2	int
]	O
;	O
}	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
.	O
result	*(struct)
)	O
;	O
if	O
(	O
mu_assoc_lookup	(*(struct),*(char),*(void))->(int)
(	O
options	*(struct)
,	O
"maxdepth"	*(char)
,	O
&	O
s	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
p	*(char)
;	O
errno	O
=	O
0	int
;	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
.	O
max_depth	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
s	*(char)
,	O
&	O
p	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
errno	O
||	O
*	O
p	*(char)
)	O
{	O
mu_error	(*(char))->(int)
(	O
"-maxdepth=%s: invalid depth"	*(char)
,	O
s	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
mu_assoc_lookup	(*(struct),*(char),*(void))->(int)
(	O
options	*(struct)
,	O
"type"	*(char)
,	O
&	O
s	*(char)
)	O
==	O
0	int
)	O
{	O
mu_record_t	*(struct)
rec	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
;	O
rc	int
=	O
mu_registrar_lookup_scheme	(*(char),*(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))->(int)
(	O
s	*(char)
,	O
&	O
rec	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
!	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
.	O
records	*(struct)
)	O
MU_ASSERT	O
(	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
.	O
records	*(struct)
)	O
)	O
;	O
MU_ASSERT	O
(	O
mu_list_append	(*(struct),*(void))->(int)
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
.	O
records	*(struct)
,	O
rec	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
rc	int
==	O
MU_ERR_NOENT	O
)	O
mu_error	(*(char))->(int)
(	O
"%s: no such record found"	*(char)
,	O
s	*(char)
)	O
;	O
else	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_registrar_lookup_scheme"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
.	O
records	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
rc	int
=	O
mu_folder_scan	(*(struct),*(struct(*(char),*(void),int,long,*((*`,*`,*`)->(int)),*(void),*(struct),*(struct))))->(int)
(	O
folder	*(struct)
,	O
&	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_scan"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
else	O
{	O
if	O
(	O
sort_option	int
)	O
mu_list_sort	(*(struct),*((*(void),*(void))->(int)))->(void)
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
.	O
result	*(struct)
,	O
compare_response	(*(void),*(void))->(int)
)	O
;	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
.	O
result	*(struct)
,	O
_print_list_entry	(*(void),*(void))->(int)
,	O
&	O
prefix_len	int
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
.	O
result	*(struct)
)	O
;	O
}	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
.	O
records	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
mu_tesh_command	struct(*(char),*(char),*((int,*(*(char)),*(struct),*(void))->(int)),int,int,*(struct))
comtab	array(struct(*(char),*(char),*((int,*(*(char)),*(struct),*(void))->(int)),int,int,*(struct)))
[	O
]	O
=	O
{	O
{	O
"list"	*(char)
,	O
"REF MBX"	*(char)
,	O
com_list	(int,*(*(char)),*(struct),*(void))->(int)
}	O
,	O
{	O
"lsub"	*(char)
,	O
"REF MBX"	*(char)
,	O
com_lsub	(int,*(*(char)),*(struct),*(void))->(int)
}	O
,	O
{	O
"rename"	*(char)
,	O
"OLD NEW"	*(char)
,	O
com_rename	(int,*(*(char)),*(struct),*(void))->(int)
}	O
,	O
{	O
"subscribe"	*(char)
,	O
"MBX"	*(char)
,	O
com_subscribe	(int,*(*(char)),*(struct),*(void))->(int)
}	O
,	O
{	O
"unsubscribe"	*(char)
,	O
"MBX"	*(char)
,	O
com_unsubscribe	(int,*(*(char)),*(struct),*(void))->(int)
}	O
,	O
{	O
"scan"	*(char)
,	O
"[-maxdepth=N] [-type=TYPE] [REF PATTERN]"	*(char)
,	O
com_scan	(int,*(*(char)),*(struct),*(void))->(int)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
void	O
usage	()->(void)
(	O
void	O
)	O
{	O
mu_printf	(*(char))->(int)
(	O
"usage: %s [-debug=SPEC] -name=URL [-sort] [-glob] OP ARG... [\\; OP ARG...]...]\n"	*(char)
,	O
mu_program_name	*(char)
)	O
;	O
mu_printf	(*(char))->(int)
(	O
"OPerations and corresponding ARGuments are:\n"	*(char)
)	O
;	O
mu_tesh_help	(*(struct(*(char),*(char),*((int,*`,*`,*`)->(int)),int,int,*(struct))),*(void))->(void)
(	O
comtab	array(struct(*(char),*(char),*((int,*(*(char)),*(struct),*(void))->(int)),int,int,*(struct)))
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
_always_is_scheme	(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(struct),int)->(int)
(	O
mu_record_t	*(struct)
record	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
,	O
mu_url_t	*(struct)
url	*(struct)
,	O
int	O
flags	int
)	O
{	O
int	O
res	*(int)
=	O
0	int
;	O
char	O
const	O
*	O
p	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long))
;	O
int	O
rc	int
=	O
mu_url_sget_path	(*(struct),*(*(char)))->(int)
(	O
url	*(struct)
,	O
&	O
p	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_url_sget_path"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
p	*(char)
,	O
&	O
st	*(struct(long,long,long))
)	O
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"lstat"	*(char)
,	O
p	*(char)
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
st	*(struct(long,long,long))
.	O
st_mode	int
)	O
)	O
res	*(int)
|=	O
MU_FOLDER_ATTRIBUTE_DIRECTORY	int
;	O
if	O
(	O
S_ISREG	O
(	O
st	*(struct(long,long,long))
.	O
st_mode	int
)	O
)	O
res	*(int)
|=	O
MU_FOLDER_ATTRIBUTE_FILE	int
;	O
if	O
(	O
S_ISLNK	O
(	O
st	*(struct(long,long,long))
.	O
st_mode	int
)	O
)	O
res	*(int)
|=	O
MU_FOLDER_ATTRIBUTE_LINK	int
;	O
return	O
res	*(int)
&	O
flags	int
;	O
}	O
static	O
struct	O
_mu_record	struct(int,*(char),int,int,int,*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(int)),*(void),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(struct),int)->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(char),int)->(int)))
any_record	struct(int,*(char),int,int,int,*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct(*`,*`,*`,*`,*`,int,int,long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))->(int)),*(void),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),int)->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),int)->(int)))
=	O
{	O
10	int
,	O
"any"	*(char)
,	O
MU_RECORD_LOCAL	int
,	O
MU_URL_SCHEME	int
|	O
MU_URL_PATH	int
,	O
MU_URL_PATH	int
,	O
mu_url_expand_path	(*(struct))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
_mu_fsfolder_init	(*(struct))->(int)
,	O
NULL	O
,	O
_always_is_scheme	(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(struct),int)->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
static	O
int	O
_reg_is_scheme	(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(struct),int)->(int)
(	O
mu_record_t	*(struct)
record	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
,	O
mu_url_t	*(struct)
url	*(struct)
,	O
int	O
flags	int
)	O
{	O
return	O
_always_is_scheme	(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(struct),int)->(int)
(	O
record	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
,	O
url	*(struct)
,	O
flags	int
)	O
&	O
MU_FOLDER_ATTRIBUTE_FILE	int
;	O
}	O
static	O
struct	O
_mu_record	struct(int,*(char),int,int,int,*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(int)),*(void),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(struct),int)->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(char),int)->(int)))
reg_record	struct(int,*(char),int,int,int,*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct(*`,*`,*`,*`,*`,int,int,long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))->(int)),*(void),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),int)->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),int)->(int)))
=	O
{	O
0	int
,	O
"reg"	*(char)
,	O
MU_RECORD_LOCAL	int
,	O
MU_URL_SCHEME	int
|	O
MU_URL_PATH	int
,	O
MU_URL_PATH	int
,	O
mu_url_expand_path	(*(struct))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
_mu_fsfolder_init	(*(struct))->(int)
,	O
NULL	O
,	O
_reg_is_scheme	(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(struct),int)->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
i	int
;	O
int	O
rc	int
;	O
mu_folder_t	*(struct)
folder	*(struct)
;	O
char	O
*	O
fname	*(char)
=	O
NULL	O
;	O
int	O
glob_option	int
=	O
0	int
;	O
mu_tesh_init	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
mu_registrar_record	(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))))->(int)
(	O
&	O
any_record	struct(int,*(char),int,int,int,*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct(*`,*`,*`,*`,*`,int,int,long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))->(int)),*(void),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),int)->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),int)->(int)))
)	O
;	O
mu_registrar_record	(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))))->(int)
(	O
&	O
reg_record	struct(int,*(char),int,int,int,*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct(*`,*`,*`,*`,*`,int,int,long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))->(int)),*(void),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),int)->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),int)->(int)))
)	O
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
usage	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-debug="	*(char)
,	O
7	int
)	O
==	O
0	int
)	O
mu_debug_parse_spec	(*(char))->(void)
(	O
argv	*(*(char))
[	O
i	int
]	O
+	O
7	int
)	O
;	O
else	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-name="	*(char)
,	O
6	int
)	O
==	O
0	int
)	O
fname	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
+	O
6	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-sort"	*(char)
)	O
==	O
0	int
)	O
sort_option	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-glob"	*(char)
)	O
==	O
0	int
)	O
glob_option	int
=	O
1	int
;	O
else	O
break	O
;	O
}	O
if	O
(	O
!	O
fname	*(char)
)	O
{	O
mu_error	(*(char))->(int)
(	O
"name not specified"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
fname	*(char)
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
char	O
*	O
cwd	*(char)
=	O
mu_getcwd	()->(*(char))
(	O
)	O
;	O
prefix_len	int
=	O
strlen	(*(char))->(long)
(	O
cwd	*(char)
)	O
;	O
if	O
(	O
cwd	*(char)
[	O
prefix_len	int
-	O
1	int
]	O
!=	O
'/'	O
)	O
prefix_len	int
++	O
;	O
fname	*(char)
=	O
mu_make_file_name	O
(	O
cwd	*(char)
,	O
fname	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cwd	*(char)
)	O
;	O
}	O
rc	int
=	O
mu_folder_create	(*(*(struct)),*(char))->(int)
(	O
&	O
folder	*(struct)
,	O
fname	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_create"	*(char)
,	O
fname	*(char)
,	O
rc	int
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
mu_folder_open	(*(struct),int)->(int)
(	O
folder	*(struct)
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_open"	*(char)
,	O
fname	*(char)
,	O
rc	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
glob_option	int
)	O
mu_folder_set_match	(*(struct),*((*(char),*(void),int)->(int)))->(int)
(	O
folder	*(struct)
,	O
mu_folder_glob_match	(*(char),*(void),int)->(int)
)	O
;	O
mu_tesh_read_and_eval	(int,*(*(char)),*(struct(*(char),*(char),*((int,*`,*`,*`)->(int)),int,int,*(struct))),*(void))->(void)
(	O
argc	int
-	O
i	int
,	O
argv	*(*(char))
+	O
i	int
,	O
comtab	array(struct(*(char),*(char),*((int,*(*(char)),*(struct),*(void))->(int)),int,int,*(struct)))
,	O
folder	*(struct)
)	O
;	O
mu_folder_close	(*(struct))->(int)
(	O
folder	*(struct)
)	O
;	O
mu_folder_destroy	(*(*(struct)))->(void)
(	O
&	O
folder	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
