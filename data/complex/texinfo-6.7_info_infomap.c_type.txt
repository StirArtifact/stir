void	O
keymap_bind_keyseq	(*(struct(char,union(*(struct`),*(struct`)))),*(int),*(struct(char,union(*(struct`),*(struct`)))))->(void)
(	O
Keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
map	*(struct)
,	O
int	O
*	O
keyseq	*(int)
,	O
KEYMAP_ENTRY	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
*	O
keyentry	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
)	O
;	O
Keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
keymap_make_keymap	()->(*(struct(char,union(*(struct`),*(struct`)))))
(	O
void	O
)	O
{	O
int	O
i	int
;	O
Keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
keymap	*(struct(char))
;	O
keymap	*(struct(char))
=	O
(	O
Keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
)	O
xmalloc	(long)->(*(void))
(	O
KEYMAP_SIZE	O
*	O
sizeof	O
(	O
KEYMAP_ENTRY	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
KEYMAP_SIZE	O
;	O
i	int
++	O
)	O
{	O
keymap	*(struct(char))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
=	O
ISFUNC	int
;	O
keymap	*(struct(char))
[	O
i	int
]	O
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
=	O
NULL	O
;	O
}	O
return	O
keymap	*(struct(char))
;	O
}	O
static	O
void	O
add_function_keyseq	(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(int),*(struct(char,union(*(struct`),*(struct`)))))->(void)
(	O
InfoCommand	struct(*(()->(void)),*(char),*(struct(*(struct(*`,*`,*`)),*(struct),*(int))),*(char))
*	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
,	O
int	O
*	O
keyseq	*(int)
,	O
Keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
rootmap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
)	O
{	O
FUNCTION_KEYSEQ	struct(*(struct(*(struct(*`,*`,*`)),*(struct),*(int))),*(struct),*(int))
*	O
ks	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
,	O
*	O
k	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
;	O
int	O
len	long
;	O
if	O
(	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
==	O
NULL	O
||	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
==	O
InfoCmd	O
(	O
info_do_lowercase_version	(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),int)->(void)
)	O
)	O
return	O
;	O
for	O
(	O
k	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
=	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
->	O
keys	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
;	O
k	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
;	O
k	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
=	O
k	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
)	O
if	O
(	O
k	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
->	O
map	*(struct)
==	O
rootmap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
)	O
return	O
;	O
ks	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
FUNCTION_KEYSEQ	struct(*(struct(*(struct(*`,*`,*`)),*(struct),*(int))),*(struct),*(int))
)	O
)	O
;	O
ks	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
=	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
->	O
keys	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
;	O
ks	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
->	O
map	*(struct)
=	O
rootmap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
;	O
for	O
(	O
len	long
=	O
0	int
;	O
keyseq	*(int)
[	O
len	long
]	O
;	O
len	long
++	O
)	O
;	O
ks	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
->	O
keyseq	*(int)
=	O
xmalloc	(long)->(*(void))
(	O
(	O
len	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
ks	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
->	O
keyseq	*(int)
,	O
keyseq	*(int)
,	O
(	O
len	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
->	O
keys	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
=	O
ks	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
;	O
}	O
void	O
keymap_bind_keyseq	(*(struct(char,union(*(struct`),*(struct`)))),*(int),*(struct(char,union(*(struct`),*(struct`)))))->(void)
(	O
Keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
map	*(struct)
,	O
int	O
*	O
keyseq	*(int)
,	O
KEYMAP_ENTRY	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
*	O
keyentry	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
)	O
{	O
Keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
m	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
=	O
map	*(struct)
;	O
int	O
*	O
s	*(char)
=	O
keyseq	*(int)
;	O
int	O
c	int
;	O
if	O
(	O
!	O
s	*(char)
||	O
*	O
s	*(char)
==	O
0	int
)	O
return	O
;	O
while	O
(	O
(	O
c	int
=	O
*	O
s	*(char)
++	O
)	O
!=	O
'\0'	O
)	O
{	O
switch	O
(	O
m	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
[	O
c	int
]	O
.	O
type	enum(int,int,int,int)
)	O
{	O
case	O
ISFUNC	int
:	O
if	O
(	O
m	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
[	O
c	int
]	O
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
)	O
return	O
;	O
if	O
(	O
*	O
s	*(char)
!=	O
'\0'	O
)	O
{	O
m	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
[	O
c	int
]	O
.	O
type	enum(int,int,int,int)
=	O
ISKMAP	int
;	O
m	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
[	O
c	int
]	O
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
keymap	*(struct(char))
=	O
keymap_make_keymap	()->(*(struct(char,union(*(struct`),*(struct`)))))
(	O
)	O
;	O
}	O
break	O
;	O
case	O
ISKMAP	int
:	O
if	O
(	O
*	O
s	*(char)
==	O
'\0'	O
)	O
return	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
s	*(char)
!=	O
'\0'	O
)	O
{	O
m	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
=	O
m	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
[	O
c	int
]	O
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
keymap	*(struct(char))
;	O
}	O
else	O
{	O
add_function_keyseq	(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(int),*(struct(char,union(*(struct`),*(struct`)))))->(void)
(	O
keyentry	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
,	O
keyseq	*(int)
,	O
map	*(struct)
)	O
;	O
m	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
[	O
c	int
]	O
=	O
*	O
keyentry	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
;	O
}	O
}	O
return	O
;	O
}	O
Keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
info_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
=	O
NULL	O
;	O
Keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
echo_area_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
=	O
NULL	O
;	O
static	O
int	O
default_emacs_like_info_keys	array(int)
[	O
]	O
=	O
{	O
'H'	O
,	O
NUL	char
,	O
A_info_get_help_window	int
,	O
'q'	O
,	O
NUL	char
,	O
A_info_quit	int
,	O
KEY_UP_ARROW	int
,	O
NUL	char
,	O
A_info_prev_line	int
,	O
KEY_DOWN_ARROW	int
,	O
NUL	char
,	O
A_info_next_line	int
,	O
KEY_PAGE_UP	int
,	O
NUL	char
,	O
A_info_scroll_backward	int
,	O
KEY_PAGE_DOWN	int
,	O
NUL	char
,	O
A_info_scroll_forward	int
,	O
KEY_HOME	int
,	O
NUL	char
,	O
A_info_beginning_of_node	int
,	O
KEY_END	int
,	O
NUL	char
,	O
A_info_end_of_node	int
,	O
'{'	O
,	O
NUL	char
,	O
A_info_search_previous	int
,	O
'}'	O
,	O
NUL	char
,	O
A_info_search_next	int
,	O
CONTROL	O
(	O
'g'	O
)	O
,	O
NUL	char
,	O
A_info_abort_key	int
,	O
RET	char
,	O
NUL	char
,	O
A_info_select_reference_this_line	int
,	O
TAB	char
,	O
NUL	char
,	O
A_info_move_to_next_xref	int
,	O
LFD	char
,	O
NUL	char
,	O
A_info_select_reference_this_line	int
,	O
CONTROL	O
(	O
'a'	O
)	O
,	O
NUL	char
,	O
A_info_beginning_of_line	int
,	O
CONTROL	O
(	O
'b'	O
)	O
,	O
NUL	char
,	O
A_info_backward_char	int
,	O
CONTROL	O
(	O
'e'	O
)	O
,	O
NUL	char
,	O
A_info_end_of_line	int
,	O
CONTROL	O
(	O
'f'	O
)	O
,	O
NUL	char
,	O
A_info_forward_char	int
,	O
CONTROL	O
(	O
'h'	O
)	O
,	O
NUL	char
,	O
A_info_scroll_backward	int
,	O
CONTROL	O
(	O
'l'	O
)	O
,	O
NUL	char
,	O
A_info_redraw_display	int
,	O
CONTROL	O
(	O
'n'	O
)	O
,	O
NUL	char
,	O
A_info_next_line	int
,	O
CONTROL	O
(	O
'p'	O
)	O
,	O
NUL	char
,	O
A_info_prev_line	int
,	O
CONTROL	O
(	O
'r'	O
)	O
,	O
NUL	char
,	O
A_isearch_backward	int
,	O
CONTROL	O
(	O
's'	O
)	O
,	O
NUL	char
,	O
A_isearch_forward	int
,	O
CONTROL	O
(	O
'u'	O
)	O
,	O
NUL	char
,	O
A_info_universal_argument	int
,	O
CONTROL	O
(	O
'v'	O
)	O
,	O
NUL	char
,	O
A_info_scroll_forward_page_only	int
,	O
SPC	char
,	O
NUL	char
,	O
A_info_scroll_forward	int
,	O
','	O
,	O
NUL	char
,	O
A_info_next_index_match	int
,	O
'/'	O
,	O
NUL	char
,	O
A_info_search	int
,	O
'0'	O
,	O
NUL	char
,	O
A_info_last_menu_item	int
,	O
'1'	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
'2'	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
'3'	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
'4'	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
'5'	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
'6'	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
'7'	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
'8'	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
'9'	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
'<'	O
,	O
NUL	char
,	O
A_info_first_node	int
,	O
'='	O
,	O
NUL	char
,	O
A_info_display_file_info	int
,	O
'>'	O
,	O
NUL	char
,	O
A_info_last_node	int
,	O
'?'	O
,	O
NUL	char
,	O
A_info_search_backward	int
,	O
'['	O
,	O
NUL	char
,	O
A_info_global_prev_node	int
,	O
']'	O
,	O
NUL	char
,	O
A_info_global_next_node	int
,	O
'b'	O
,	O
NUL	char
,	O
A_info_beginning_of_node	int
,	O
'd'	O
,	O
NUL	char
,	O
A_info_dir_node	int
,	O
'e'	O
,	O
NUL	char
,	O
A_info_end_of_node	int
,	O
'f'	O
,	O
NUL	char
,	O
A_info_xref_item	int
,	O
'g'	O
,	O
NUL	char
,	O
A_info_goto_node	int
,	O
'G'	O
,	O
NUL	char
,	O
A_info_menu_sequence	int
,	O
'h'	O
,	O
NUL	char
,	O
A_info_get_info_help_node	int
,	O
'i'	O
,	O
NUL	char
,	O
A_info_index_search	int
,	O
'I'	O
,	O
NUL	char
,	O
A_info_virtual_index	int
,	O
'l'	O
,	O
NUL	char
,	O
A_info_history_node	int
,	O
'm'	O
,	O
NUL	char
,	O
A_info_menu_item	int
,	O
'n'	O
,	O
NUL	char
,	O
A_info_next_node	int
,	O
'O'	O
,	O
NUL	char
,	O
A_info_goto_invocation_node	int
,	O
'p'	O
,	O
NUL	char
,	O
A_info_prev_node	int
,	O
'r'	O
,	O
NUL	char
,	O
A_info_xref_item	int
,	O
'R'	O
,	O
NUL	char
,	O
A_info_toggle_regexp	int
,	O
's'	O
,	O
NUL	char
,	O
A_info_search	int
,	O
'S'	O
,	O
NUL	char
,	O
A_info_search_case_sensitively	int
,	O
't'	O
,	O
NUL	char
,	O
A_info_top_node	int
,	O
'u'	O
,	O
NUL	char
,	O
A_info_up_node	int
,	O
'x'	O
,	O
NUL	char
,	O
A_info_delete_window	int
,	O
KEYMAP_META	O
(	O
'0'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'1'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'2'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'3'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'4'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'5'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'6'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'7'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'8'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'9'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'-'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
CONTROL	O
(	O
'f'	O
)	O
)	O
,	O
NUL	char
,	O
A_info_show_footnotes	int
,	O
KEYMAP_META	O
(	O
CONTROL	O
(	O
'g'	O
)	O
)	O
,	O
NUL	char
,	O
A_info_abort_key	int
,	O
KEYMAP_META	O
(	O
TAB	char
)	O
,	O
NUL	char
,	O
A_info_move_to_prev_xref	int
,	O
KEYMAP_META	O
(	O
CONTROL	O
(	O
'v'	O
)	O
)	O
,	O
NUL	char
,	O
A_info_scroll_other_window	int
,	O
KEYMAP_META	O
(	O
'<'	O
)	O
,	O
NUL	char
,	O
A_info_beginning_of_node	int
,	O
KEYMAP_META	O
(	O
'>'	O
)	O
,	O
NUL	char
,	O
A_info_end_of_node	int
,	O
KEYMAP_META	O
(	O
'b'	O
)	O
,	O
NUL	char
,	O
A_info_backward_word	int
,	O
KEYMAP_META	O
(	O
'f'	O
)	O
,	O
NUL	char
,	O
A_info_forward_word	int
,	O
KEYMAP_META	O
(	O
'r'	O
)	O
,	O
NUL	char
,	O
A_info_move_to_window_line	int
,	O
KEYMAP_META	O
(	O
'v'	O
)	O
,	O
NUL	char
,	O
A_info_scroll_backward_page_only	int
,	O
KEYMAP_META	O
(	O
'x'	O
)	O
,	O
NUL	char
,	O
A_info_execute_command	int
,	O
KEYMAP_META	O
(	O
'/'	O
)	O
,	O
NUL	char
,	O
A_info_tree_search	int
,	O
KEYMAP_META	O
(	O
'}'	O
)	O
,	O
NUL	char
,	O
A_info_tree_search_next	int
,	O
KEYMAP_META	O
(	O
'{'	O
)	O
,	O
NUL	char
,	O
A_info_tree_search_previous	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
CONTROL	O
(	O
'b'	O
)	O
,	O
NUL	char
,	O
A_list_visited_nodes	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
CONTROL	O
(	O
'c'	O
)	O
,	O
NUL	char
,	O
A_info_quit	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
CONTROL	O
(	O
'f'	O
)	O
,	O
NUL	char
,	O
A_info_view_file	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
CONTROL	O
(	O
'g'	O
)	O
,	O
NUL	char
,	O
A_info_abort_key	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
CONTROL	O
(	O
'v'	O
)	O
,	O
NUL	char
,	O
A_info_view_file	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'0'	O
,	O
NUL	char
,	O
A_info_delete_window	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'1'	O
,	O
NUL	char
,	O
A_info_keep_one_window	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'2'	O
,	O
NUL	char
,	O
A_info_split_window	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'^'	O
,	O
NUL	char
,	O
A_info_grow_window	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'b'	O
,	O
NUL	char
,	O
A_select_visited_node	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'f'	O
,	O
NUL	char
,	O
A_info_all_files	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'n'	O
,	O
NUL	char
,	O
A_info_search_next	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'N'	O
,	O
NUL	char
,	O
A_info_search_previous	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'o'	O
,	O
NUL	char
,	O
A_info_next_window	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
't'	O
,	O
NUL	char
,	O
A_info_tile_windows	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'w'	O
,	O
NUL	char
,	O
A_info_toggle_wrap	int
,	O
KEY_RIGHT_ARROW	int
,	O
NUL	char
,	O
A_info_forward_char	int
,	O
KEY_LEFT_ARROW	int
,	O
NUL	char
,	O
A_info_backward_char	int
,	O
KEY_DELETE	int
,	O
NUL	char
,	O
A_info_scroll_backward	int
,	O
ESC	char
,	O
KEY_PAGE_UP	int
,	O
NUL	char
,	O
A_info_scroll_other_window_backward	int
,	O
ESC	char
,	O
KEY_PAGE_DOWN	int
,	O
NUL	char
,	O
A_info_scroll_other_window	int
,	O
ESC	char
,	O
KEY_UP_ARROW	int
,	O
NUL	char
,	O
A_info_prev_line	int
,	O
ESC	char
,	O
KEY_DOWN_ARROW	int
,	O
NUL	char
,	O
A_info_next_line	int
,	O
ESC	char
,	O
KEY_RIGHT_ARROW	int
,	O
NUL	char
,	O
A_info_forward_word	int
,	O
ESC	char
,	O
KEY_LEFT_ARROW	int
,	O
NUL	char
,	O
A_info_backward_word	int
,	O
KEY_BACK_TAB	int
,	O
NUL	char
,	O
A_info_move_to_prev_xref	int
,	O
}	O
;	O
static	O
int	O
default_emacs_like_ea_keys	array(int)
[	O
]	O
=	O
{	O
KEYMAP_META	O
(	O
'0'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'1'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'2'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'3'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'4'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'5'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'6'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'7'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'8'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'9'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'-'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
CONTROL	O
(	O
'g'	O
)	O
)	O
,	O
NUL	char
,	O
A_ea_abort	int
,	O
KEYMAP_META	O
(	O
CONTROL	O
(	O
'v'	O
)	O
)	O
,	O
NUL	char
,	O
A_ea_scroll_completions_window	int
,	O
KEYMAP_META	O
(	O
'b'	O
)	O
,	O
NUL	char
,	O
A_ea_backward_word	int
,	O
KEYMAP_META	O
(	O
'd'	O
)	O
,	O
NUL	char
,	O
A_ea_kill_word	int
,	O
KEYMAP_META	O
(	O
'f'	O
)	O
,	O
NUL	char
,	O
A_ea_forward_word	int
,	O
KEYMAP_META	O
(	O
'y'	O
)	O
,	O
NUL	char
,	O
A_ea_yank_pop	int
,	O
KEYMAP_META	O
(	O
'?'	O
)	O
,	O
NUL	char
,	O
A_ea_possible_completions	int
,	O
KEYMAP_META	O
(	O
TAB	char
)	O
,	O
NUL	char
,	O
A_ea_tab_insert	int
,	O
KEYMAP_META	O
(	O
KEY_DELETE	int
)	O
,	O
NUL	char
,	O
A_ea_backward_kill_word	int
,	O
CONTROL	O
(	O
'a'	O
)	O
,	O
NUL	char
,	O
A_ea_beg_of_line	int
,	O
CONTROL	O
(	O
'b'	O
)	O
,	O
NUL	char
,	O
A_ea_backward	int
,	O
CONTROL	O
(	O
'd'	O
)	O
,	O
NUL	char
,	O
A_ea_delete	int
,	O
CONTROL	O
(	O
'e'	O
)	O
,	O
NUL	char
,	O
A_ea_end_of_line	int
,	O
CONTROL	O
(	O
'f'	O
)	O
,	O
NUL	char
,	O
A_ea_forward	int
,	O
CONTROL	O
(	O
'g'	O
)	O
,	O
NUL	char
,	O
A_ea_abort	int
,	O
ESC	char
,	O
NUL	char
,	O
A_ea_abort	int
,	O
CONTROL	O
(	O
'h'	O
)	O
,	O
NUL	char
,	O
A_ea_rubout	int
,	O
CONTROL	O
(	O
'k'	O
)	O
,	O
NUL	char
,	O
A_ea_kill_line	int
,	O
CONTROL	O
(	O
'l'	O
)	O
,	O
NUL	char
,	O
A_info_redraw_display	int
,	O
CONTROL	O
(	O
'q'	O
)	O
,	O
NUL	char
,	O
A_ea_quoted_insert	int
,	O
CONTROL	O
(	O
't'	O
)	O
,	O
NUL	char
,	O
A_ea_transpose_chars	int
,	O
CONTROL	O
(	O
'u'	O
)	O
,	O
NUL	char
,	O
A_info_universal_argument	int
,	O
CONTROL	O
(	O
'y'	O
)	O
,	O
NUL	char
,	O
A_ea_yank	int
,	O
LFD	char
,	O
NUL	char
,	O
A_ea_newline	int
,	O
RET	char
,	O
NUL	char
,	O
A_ea_newline	int
,	O
TAB	char
,	O
NUL	char
,	O
A_ea_complete	int
,	O
KEY_DELETE	int
,	O
NUL	char
,	O
A_ea_rubout	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
KEY_DELETE	int
,	O
NUL	char
,	O
A_ea_backward_kill_line	int
,	O
KEY_RIGHT_ARROW	int
,	O
NUL	char
,	O
A_ea_forward	int
,	O
KEY_LEFT_ARROW	int
,	O
NUL	char
,	O
A_ea_backward	int
,	O
KEY_HOME	int
,	O
NUL	char
,	O
A_ea_beg_of_line	int
,	O
KEY_END	int
,	O
NUL	char
,	O
A_ea_end_of_line	int
,	O
}	O
;	O
static	O
int	O
default_vi_like_info_keys	array(int)
[	O
]	O
=	O
{	O
'q'	O
,	O
NUL	char
,	O
A_info_quit	int
,	O
'x'	O
,	O
NUL	char
,	O
A_info_delete_window	int
,	O
SPC	char
,	O
NUL	char
,	O
A_info_scroll_forward	int
,	O
'{'	O
,	O
NUL	char
,	O
A_info_search_previous	int
,	O
'}'	O
,	O
NUL	char
,	O
A_info_search_next	int
,	O
KEY_UP_ARROW	int
,	O
NUL	char
,	O
A_info_up_line	int
,	O
KEY_DOWN_ARROW	int
,	O
NUL	char
,	O
A_info_down_line	int
,	O
'0'	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
'1'	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
'2'	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
'3'	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
'4'	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
'5'	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
'6'	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
'7'	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
'8'	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
'9'	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
'-'	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
TAB	char
,	O
NUL	char
,	O
A_info_move_to_next_xref	int
,	O
LFD	char
,	O
NUL	char
,	O
A_info_down_line	int
,	O
RET	char
,	O
NUL	char
,	O
A_info_down_line	int
,	O
CONTROL	O
(	O
'a'	O
)	O
,	O
NUL	char
,	O
A_info_beginning_of_line	int
,	O
CONTROL	O
(	O
'b'	O
)	O
,	O
NUL	char
,	O
A_info_scroll_backward_page_only	int
,	O
CONTROL	O
(	O
'c'	O
)	O
,	O
NUL	char
,	O
A_info_abort_key	int
,	O
CONTROL	O
(	O
'd'	O
)	O
,	O
NUL	char
,	O
A_info_scroll_half_screen_down	int
,	O
CONTROL	O
(	O
'e'	O
)	O
,	O
NUL	char
,	O
A_info_down_line	int
,	O
CONTROL	O
(	O
'f'	O
)	O
,	O
NUL	char
,	O
A_info_scroll_forward_page_only	int
,	O
CONTROL	O
(	O
'g'	O
)	O
,	O
NUL	char
,	O
A_info_display_file_info	int
,	O
CONTROL	O
(	O
'k'	O
)	O
,	O
NUL	char
,	O
A_info_up_line	int
,	O
CONTROL	O
(	O
'l'	O
)	O
,	O
NUL	char
,	O
A_info_redraw_display	int
,	O
CONTROL	O
(	O
'n'	O
)	O
,	O
NUL	char
,	O
A_info_down_line	int
,	O
CONTROL	O
(	O
'p'	O
)	O
,	O
NUL	char
,	O
A_info_up_line	int
,	O
CONTROL	O
(	O
'r'	O
)	O
,	O
NUL	char
,	O
A_info_redraw_display	int
,	O
CONTROL	O
(	O
's'	O
)	O
,	O
NUL	char
,	O
A_isearch_forward	int
,	O
CONTROL	O
(	O
'u'	O
)	O
,	O
NUL	char
,	O
A_info_scroll_half_screen_up	int
,	O
CONTROL	O
(	O
'v'	O
)	O
,	O
NUL	char
,	O
A_info_scroll_forward_page_only	int
,	O
CONTROL	O
(	O
'y'	O
)	O
,	O
NUL	char
,	O
A_info_up_line	int
,	O
','	O
,	O
NUL	char
,	O
A_info_next_index_match	int
,	O
'/'	O
,	O
NUL	char
,	O
A_info_search	int
,	O
KEYMAP_META	O
(	O
'0'	O
)	O
,	O
NUL	char
,	O
A_info_last_menu_item	int
,	O
KEYMAP_META	O
(	O
'1'	O
)	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
KEYMAP_META	O
(	O
'2'	O
)	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
KEYMAP_META	O
(	O
'3'	O
)	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
KEYMAP_META	O
(	O
'4'	O
)	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
KEYMAP_META	O
(	O
'5'	O
)	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
KEYMAP_META	O
(	O
'6'	O
)	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
KEYMAP_META	O
(	O
'7'	O
)	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
KEYMAP_META	O
(	O
'8'	O
)	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
KEYMAP_META	O
(	O
'9'	O
)	O
,	O
NUL	char
,	O
A_info_menu_digit	int
,	O
'<'	O
,	O
NUL	char
,	O
A_info_first_node	int
,	O
'>'	O
,	O
NUL	char
,	O
A_info_last_node	int
,	O
'?'	O
,	O
NUL	char
,	O
A_info_search_backward	int
,	O
'['	O
,	O
NUL	char
,	O
A_info_global_prev_node	int
,	O
']'	O
,	O
NUL	char
,	O
A_info_global_next_node	int
,	O
'\''	O
,	O
NUL	char
,	O
A_info_history_node	int
,	O
'b'	O
,	O
NUL	char
,	O
A_info_scroll_backward_page_only	int
,	O
'd'	O
,	O
NUL	char
,	O
A_info_scroll_half_screen_down	int
,	O
'e'	O
,	O
NUL	char
,	O
A_info_down_line	int
,	O
'E'	O
,	O
NUL	char
,	O
A_info_view_file	int
,	O
':'	O
,	O
'e'	O
,	O
NUL	char
,	O
A_info_view_file	int
,	O
'f'	O
,	O
NUL	char
,	O
A_info_scroll_forward_page_only	int
,	O
'F'	O
,	O
NUL	char
,	O
A_info_scroll_forward_page_only	int
,	O
'g'	O
,	O
NUL	char
,	O
A_info_first_node	int
,	O
'G'	O
,	O
NUL	char
,	O
A_info_last_node	int
,	O
'h'	O
,	O
NUL	char
,	O
A_info_get_help_window	int
,	O
'H'	O
,	O
NUL	char
,	O
A_info_get_help_window	int
,	O
'i'	O
,	O
NUL	char
,	O
A_info_index_search	int
,	O
'I'	O
,	O
NUL	char
,	O
A_info_goto_invocation_node	int
,	O
'j'	O
,	O
NUL	char
,	O
A_info_next_line	int
,	O
'k'	O
,	O
NUL	char
,	O
A_info_prev_line	int
,	O
'l'	O
,	O
NUL	char
,	O
A_info_history_node	int
,	O
'm'	O
,	O
NUL	char
,	O
A_info_menu_item	int
,	O
'n'	O
,	O
NUL	char
,	O
A_info_search_next	int
,	O
':'	O
,	O
'a'	O
,	O
NUL	char
,	O
A_info_all_files	int
,	O
'N'	O
,	O
NUL	char
,	O
A_info_search_previous	int
,	O
'O'	O
,	O
NUL	char
,	O
A_info_goto_invocation_node	int
,	O
'p'	O
,	O
NUL	char
,	O
A_info_prev_node	int
,	O
'Q'	O
,	O
NUL	char
,	O
A_info_quit	int
,	O
':'	O
,	O
'q'	O
,	O
NUL	char
,	O
A_info_quit	int
,	O
':'	O
,	O
'Q'	O
,	O
NUL	char
,	O
A_info_quit	int
,	O
'Z'	O
,	O
'Z'	O
,	O
NUL	char
,	O
A_info_quit	int
,	O
'r'	O
,	O
NUL	char
,	O
A_info_redraw_display	int
,	O
'R'	O
,	O
NUL	char
,	O
A_info_toggle_regexp	int
,	O
's'	O
,	O
NUL	char
,	O
A_info_search	int
,	O
'S'	O
,	O
NUL	char
,	O
A_info_search_case_sensitively	int
,	O
't'	O
,	O
NUL	char
,	O
A_info_top_node	int
,	O
'u'	O
,	O
NUL	char
,	O
A_info_scroll_half_screen_up	int
,	O
'w'	O
,	O
NUL	char
,	O
A_info_scroll_backward_page_only_set_window	int
,	O
'y'	O
,	O
NUL	char
,	O
A_info_up_line	int
,	O
'z'	O
,	O
NUL	char
,	O
A_info_scroll_forward_page_only_set_window	int
,	O
KEYMAP_META	O
(	O
CONTROL	O
(	O
'f'	O
)	O
)	O
,	O
NUL	char
,	O
A_info_show_footnotes	int
,	O
KEYMAP_META	O
(	O
CONTROL	O
(	O
'g'	O
)	O
)	O
,	O
NUL	char
,	O
A_info_abort_key	int
,	O
KEYMAP_META	O
(	O
TAB	char
)	O
,	O
NUL	char
,	O
A_info_move_to_prev_xref	int
,	O
KEYMAP_META	O
(	O
SPC	char
)	O
,	O
NUL	char
,	O
A_info_scroll_forward_page_only	int
,	O
KEYMAP_META	O
(	O
CONTROL	O
(	O
'v'	O
)	O
)	O
,	O
NUL	char
,	O
A_info_scroll_other_window	int
,	O
KEYMAP_META	O
(	O
'<'	O
)	O
,	O
NUL	char
,	O
A_info_beginning_of_node	int
,	O
KEYMAP_META	O
(	O
'>'	O
)	O
,	O
NUL	char
,	O
A_info_end_of_node	int
,	O
KEYMAP_META	O
(	O
'/'	O
)	O
,	O
NUL	char
,	O
A_info_search	int
,	O
KEYMAP_META	O
(	O
'?'	O
)	O
,	O
NUL	char
,	O
A_info_search_backward	int
,	O
KEYMAP_META	O
(	O
'b'	O
)	O
,	O
NUL	char
,	O
A_info_beginning_of_node	int
,	O
KEYMAP_META	O
(	O
'd'	O
)	O
,	O
NUL	char
,	O
A_info_dir_node	int
,	O
KEYMAP_META	O
(	O
'e'	O
)	O
,	O
NUL	char
,	O
A_info_end_of_node	int
,	O
KEYMAP_META	O
(	O
'f'	O
)	O
,	O
NUL	char
,	O
A_info_xref_item	int
,	O
KEYMAP_META	O
(	O
'g'	O
)	O
,	O
NUL	char
,	O
A_info_select_reference_this_line	int
,	O
KEYMAP_META	O
(	O
'h'	O
)	O
,	O
NUL	char
,	O
A_info_get_info_help_node	int
,	O
KEYMAP_META	O
(	O
'I'	O
)	O
,	O
NUL	char
,	O
A_info_virtual_index	int
,	O
KEYMAP_META	O
(	O
'm'	O
)	O
,	O
NUL	char
,	O
A_info_menu_item	int
,	O
KEYMAP_META	O
(	O
'n'	O
)	O
,	O
NUL	char
,	O
A_info_search	int
,	O
KEYMAP_META	O
(	O
'N'	O
)	O
,	O
NUL	char
,	O
A_info_search_backward	int
,	O
KEYMAP_META	O
(	O
'r'	O
)	O
,	O
NUL	char
,	O
A_isearch_backward	int
,	O
KEYMAP_META	O
(	O
's'	O
)	O
,	O
NUL	char
,	O
A_isearch_forward	int
,	O
KEYMAP_META	O
(	O
't'	O
)	O
,	O
NUL	char
,	O
A_info_top_node	int
,	O
KEYMAP_META	O
(	O
'v'	O
)	O
,	O
NUL	char
,	O
A_info_scroll_backward_page_only	int
,	O
KEYMAP_META	O
(	O
'x'	O
)	O
,	O
NUL	char
,	O
A_info_execute_command	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
CONTROL	O
(	O
'b'	O
)	O
,	O
NUL	char
,	O
A_list_visited_nodes	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
CONTROL	O
(	O
'c'	O
)	O
,	O
NUL	char
,	O
A_info_quit	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
CONTROL	O
(	O
'f'	O
)	O
,	O
NUL	char
,	O
A_info_view_file	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
CONTROL	O
(	O
'g'	O
)	O
,	O
NUL	char
,	O
A_info_abort_key	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
CONTROL	O
(	O
'v'	O
)	O
,	O
NUL	char
,	O
A_info_view_file	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
LFD	char
,	O
NUL	char
,	O
A_info_select_reference_this_line	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
RET	char
,	O
NUL	char
,	O
A_info_select_reference_this_line	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'0'	O
,	O
NUL	char
,	O
A_info_delete_window	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'1'	O
,	O
NUL	char
,	O
A_info_keep_one_window	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'2'	O
,	O
NUL	char
,	O
A_info_split_window	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'^'	O
,	O
NUL	char
,	O
A_info_grow_window	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'b'	O
,	O
NUL	char
,	O
A_select_visited_node	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'g'	O
,	O
NUL	char
,	O
A_info_goto_node	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'i'	O
,	O
NUL	char
,	O
A_info_index_search	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'I'	O
,	O
NUL	char
,	O
A_info_goto_invocation_node	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'n'	O
,	O
NUL	char
,	O
A_info_next_node	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'o'	O
,	O
NUL	char
,	O
A_info_next_window	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'O'	O
,	O
NUL	char
,	O
A_info_goto_invocation_node	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'p'	O
,	O
NUL	char
,	O
A_info_prev_node	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'r'	O
,	O
NUL	char
,	O
A_info_xref_item	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
't'	O
,	O
NUL	char
,	O
A_info_tile_windows	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'u'	O
,	O
NUL	char
,	O
A_info_up_node	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
'w'	O
,	O
NUL	char
,	O
A_info_toggle_wrap	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
','	O
,	O
NUL	char
,	O
A_info_next_index_match	int
,	O
KEY_PAGE_UP	int
,	O
NUL	char
,	O
A_info_scroll_backward	int
,	O
KEY_PAGE_DOWN	int
,	O
NUL	char
,	O
A_info_scroll_forward	int
,	O
KEY_DELETE	int
,	O
NUL	char
,	O
A_info_scroll_backward	int
,	O
KEY_RIGHT_ARROW	int
,	O
NUL	char
,	O
A_info_scroll_forward_page_only	int
,	O
KEY_LEFT_ARROW	int
,	O
NUL	char
,	O
A_info_scroll_backward_page_only	int
,	O
KEY_HOME	int
,	O
NUL	char
,	O
A_info_beginning_of_node	int
,	O
KEY_END	int
,	O
NUL	char
,	O
A_info_end_of_node	int
,	O
ESC	char
,	O
KEY_PAGE_DOWN	int
,	O
NUL	char
,	O
A_info_scroll_other_window	int
,	O
ESC	char
,	O
KEY_PAGE_UP	int
,	O
NUL	char
,	O
A_info_scroll_other_window_backward	int
,	O
ESC	char
,	O
KEY_DELETE	int
,	O
NUL	char
,	O
A_info_scroll_other_window_backward	int
,	O
ESC	char
,	O
KEY_UP_ARROW	int
,	O
NUL	char
,	O
A_info_prev_node	int
,	O
ESC	char
,	O
KEY_DOWN_ARROW	int
,	O
NUL	char
,	O
A_info_next_node	int
,	O
ESC	char
,	O
KEY_RIGHT_ARROW	int
,	O
NUL	char
,	O
A_info_xref_item	int
,	O
ESC	char
,	O
KEY_LEFT_ARROW	int
,	O
NUL	char
,	O
A_info_beginning_of_node	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
KEY_DELETE	int
,	O
NUL	char
,	O
A_ea_backward_kill_line	int
,	O
}	O
;	O
static	O
int	O
default_vi_like_ea_keys	array(int)
[	O
]	O
=	O
{	O
KEYMAP_META	O
(	O
'1'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'2'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'3'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'4'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'5'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'6'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'7'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'8'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'9'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
'-'	O
)	O
,	O
NUL	char
,	O
A_info_add_digit_to_numeric_arg	int
,	O
KEYMAP_META	O
(	O
CONTROL	O
(	O
'g'	O
)	O
)	O
,	O
NUL	char
,	O
A_ea_abort	int
,	O
KEYMAP_META	O
(	O
CONTROL	O
(	O
'h'	O
)	O
)	O
,	O
NUL	char
,	O
A_ea_backward_kill_word	int
,	O
KEYMAP_META	O
(	O
CONTROL	O
(	O
'v'	O
)	O
)	O
,	O
NUL	char
,	O
A_ea_scroll_completions_window	int
,	O
KEYMAP_META	O
(	O
'0'	O
)	O
,	O
NUL	char
,	O
A_ea_beg_of_line	int
,	O
KEYMAP_META	O
(	O
'$'	O
)	O
,	O
NUL	char
,	O
A_ea_end_of_line	int
,	O
KEYMAP_META	O
(	O
'b'	O
)	O
,	O
NUL	char
,	O
A_ea_backward_word	int
,	O
KEYMAP_META	O
(	O
'd'	O
)	O
,	O
NUL	char
,	O
A_ea_kill_word	int
,	O
KEYMAP_META	O
(	O
'f'	O
)	O
,	O
NUL	char
,	O
A_ea_forward_word	int
,	O
KEYMAP_META	O
(	O
'h'	O
)	O
,	O
NUL	char
,	O
A_ea_backward	int
,	O
KEYMAP_META	O
(	O
'l'	O
)	O
,	O
NUL	char
,	O
A_ea_forward	int
,	O
KEYMAP_META	O
(	O
'w'	O
)	O
,	O
NUL	char
,	O
A_ea_forward_word	int
,	O
KEYMAP_META	O
(	O
'x'	O
)	O
,	O
NUL	char
,	O
A_ea_delete	int
,	O
KEYMAP_META	O
(	O
'X'	O
)	O
,	O
NUL	char
,	O
A_ea_kill_word	int
,	O
KEYMAP_META	O
(	O
'y'	O
)	O
,	O
NUL	char
,	O
A_ea_yank_pop	int
,	O
KEYMAP_META	O
(	O
'?'	O
)	O
,	O
NUL	char
,	O
A_ea_possible_completions	int
,	O
KEYMAP_META	O
(	O
TAB	char
)	O
,	O
NUL	char
,	O
A_ea_tab_insert	int
,	O
KEYMAP_META	O
(	O
DEL	char
)	O
,	O
NUL	char
,	O
A_ea_kill_word	int
,	O
CONTROL	O
(	O
'a'	O
)	O
,	O
NUL	char
,	O
A_ea_beg_of_line	int
,	O
CONTROL	O
(	O
'b'	O
)	O
,	O
NUL	char
,	O
A_ea_backward	int
,	O
CONTROL	O
(	O
'd'	O
)	O
,	O
NUL	char
,	O
A_ea_delete	int
,	O
CONTROL	O
(	O
'e'	O
)	O
,	O
NUL	char
,	O
A_ea_end_of_line	int
,	O
CONTROL	O
(	O
'f'	O
)	O
,	O
NUL	char
,	O
A_ea_forward	int
,	O
CONTROL	O
(	O
'g'	O
)	O
,	O
NUL	char
,	O
A_ea_abort	int
,	O
ESC	char
,	O
NUL	char
,	O
A_ea_abort	int
,	O
CONTROL	O
(	O
'h'	O
)	O
,	O
NUL	char
,	O
A_ea_rubout	int
,	O
CONTROL	O
(	O
'k'	O
)	O
,	O
NUL	char
,	O
A_ea_kill_line	int
,	O
CONTROL	O
(	O
'l'	O
)	O
,	O
NUL	char
,	O
A_info_redraw_display	int
,	O
CONTROL	O
(	O
'q'	O
)	O
,	O
NUL	char
,	O
A_ea_quoted_insert	int
,	O
CONTROL	O
(	O
't'	O
)	O
,	O
NUL	char
,	O
A_ea_transpose_chars	int
,	O
CONTROL	O
(	O
'u'	O
)	O
,	O
NUL	char
,	O
A_ea_abort	int
,	O
CONTROL	O
(	O
'v'	O
)	O
,	O
NUL	char
,	O
A_ea_quoted_insert	int
,	O
CONTROL	O
(	O
'y'	O
)	O
,	O
NUL	char
,	O
A_ea_yank	int
,	O
LFD	char
,	O
NUL	char
,	O
A_ea_newline	int
,	O
RET	char
,	O
NUL	char
,	O
A_ea_newline	int
,	O
TAB	char
,	O
NUL	char
,	O
A_ea_complete	int
,	O
KEY_RIGHT_ARROW	int
,	O
NUL	char
,	O
A_ea_forward	int
,	O
KEY_LEFT_ARROW	int
,	O
NUL	char
,	O
A_ea_backward	int
,	O
KEY_HOME	int
,	O
NUL	char
,	O
A_ea_beg_of_line	int
,	O
KEY_END	int
,	O
NUL	char
,	O
A_ea_end_of_line	int
,	O
KEY_DELETE	int
,	O
NUL	char
,	O
A_ea_rubout	int
,	O
CONTROL	O
(	O
'x'	O
)	O
,	O
KEY_DELETE	int
,	O
NUL	char
,	O
A_ea_backward_kill_line	int
,	O
}	O
;	O
static	O
int	O
sup_info	int
,	O
sup_ea	int
;	O
static	O
int	O
fetch_user_maps	(*(char))->(int)
(	O
char	O
*	O
init_file	*(char)
)	O
{	O
char	O
*	O
filename	*(char)
=	O
NULL	O
;	O
char	O
*	O
homedir	*(char)
;	O
FILE	struct
*	O
inf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
compile	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(int),*(int))->(int)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
const	O
char	O
*	O
filename	*(char)
,	O
int	O
*	O
,	O
int	O
*	O
)	O
;	O
if	O
(	O
init_file	*(char)
)	O
filename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
init_file	*(char)
)	O
;	O
else	O
if	O
(	O
(	O
homedir	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
filename	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
homedir	*(char)
)	O
+	O
2	int
+	O
strlen	(*(char))->(long)
(	O
INFOKEY_FILE	*(char)
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
filename	*(char)
,	O
homedir	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
filename	*(char)
,	O
"/"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
filename	*(char)
,	O
INFOKEY_FILE	*(char)
)	O
;	O
}	O
inf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
inf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
if	O
(	O
init_file	*(char)
)	O
info_error	(*(char))->(void)
(	O
_	O
(	O
"could not open init file %s"	*(char)
)	O
,	O
init_file	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
compile	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(int),*(int))->(int)
(	O
inf	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
filename	*(char)
,	O
&	O
sup_info	int
,	O
&	O
sup_ea	int
)	O
;	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
section_to_keymaps	(*(struct(char,union(*(struct`),*(struct`)))),*(int),int)->(void)
(	O
Keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
map	*(struct)
,	O
int	O
*	O
table	*(int)
,	O
unsigned	O
int	O
len	long
)	O
{	O
int	O
k	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
;	O
Keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
esc_map	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
;	O
int	O
*	O
p	*(void)
;	O
int	O
*	O
seq	*(int)
;	O
enum	O
{	O
getseq	int
,	O
gotseq	int
,	O
getaction	int
}	O
state	*(int)
=	O
getseq	int
;	O
for	O
(	O
p	*(void)
=	O
table	*(int)
;	O
(	O
unsigned	O
int	O
)	O
(	O
p	*(void)
-	O
table	*(int)
)	O
<	O
len	long
;	O
p	*(void)
++	O
)	O
{	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
getseq	int
:	O
if	O
(	O
*	O
p	*(void)
)	O
{	O
seq	*(int)
=	O
p	*(void)
;	O
state	*(int)
=	O
gotseq	int
;	O
}	O
break	O
;	O
case	O
gotseq	int
:	O
if	O
(	O
!	O
*	O
p	*(void)
)	O
state	*(int)
=	O
getaction	int
;	O
break	O
;	O
case	O
getaction	int
:	O
{	O
unsigned	O
int	O
action	int
=	O
*	O
p	*(void)
;	O
KEYMAP_ENTRY	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
ke	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
;	O
state	*(int)
=	O
getseq	int
;	O
ke	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
.	O
type	enum(int,int,int,int)
=	O
ISFUNC	int
;	O
ke	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
=	O
action	int
<	O
A_NCOMMANDS	int
?	O
&	O
function_doc_array	array(struct(*(()->(void)),*(char),*(struct(*(struct(*`,*`,*`)),*(struct),*(int))),*(char)))
[	O
action	int
]	O
:	O
NULL	O
;	O
keymap_bind_keyseq	(*(struct(char,union(*(struct`),*(struct`)))),*(int),*(struct(char,union(*(struct`),*(struct`)))))->(void)
(	O
map	*(struct)
,	O
seq	*(int)
,	O
&	O
ke	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
)	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
state	*(int)
!=	O
getseq	int
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
map	*(struct)
[	O
ESC	char
]	O
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
)	O
{	O
map	*(struct)
[	O
ESC	char
]	O
.	O
type	enum(int,int,int,int)
=	O
ISKMAP	int
;	O
map	*(struct)
[	O
ESC	char
]	O
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
keymap	*(struct(char))
=	O
keymap_make_keymap	()->(*(struct(char,union(*(struct`),*(struct`)))))
(	O
)	O
;	O
}	O
if	O
(	O
map	*(struct)
[	O
ESC	char
]	O
.	O
type	enum(int,int,int,int)
!=	O
ISKMAP	int
)	O
return	O
;	O
esc_map	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
=	O
map	*(struct)
[	O
ESC	char
]	O
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
keymap	*(struct(char))
;	O
for	O
(	O
k	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
=	O
1	int
;	O
k	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
<	O
KEYMAP_META_BASE	int
;	O
k	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
++	O
)	O
{	O
if	O
(	O
map	*(struct)
[	O
k	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
+	O
KEYMAP_META_BASE	int
]	O
.	O
type	enum(int,int,int,int)
==	O
ISFUNC	int
&&	O
esc_map	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
[	O
k	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
]	O
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
==	O
0	int
)	O
{	O
esc_map	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
[	O
k	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
]	O
.	O
type	enum(int,int,int,int)
=	O
ISFUNC	int
;	O
esc_map	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
[	O
k	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
]	O
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
=	O
map	*(struct)
[	O
k	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct(char,union(*`,*`))),*(int)))
+	O
KEYMAP_META_BASE	int
]	O
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
;	O
}	O
}	O
return	O
;	O
}	O
void	O
read_init_file	(*(char))->(void)
(	O
char	O
*	O
init_file	*(char)
)	O
{	O
int	O
*	O
info_keys	*(int)
,	O
*	O
ea_keys	*(int)
;	O
long	O
info_keys_len	long
,	O
ea_keys_len	long
;	O
int	O
i	int
;	O
if	O
(	O
!	O
info_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
)	O
{	O
info_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
=	O
keymap_make_keymap	()->(*(struct(char,union(*(struct`),*(struct`)))))
(	O
)	O
;	O
echo_area_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
=	O
keymap_make_keymap	()->(*(struct(char,union(*(struct`),*(struct`)))))
(	O
)	O
;	O
}	O
if	O
(	O
!	O
vi_keys_p	int
)	O
{	O
info_keys	*(int)
=	O
default_emacs_like_info_keys	array(int)
;	O
info_keys_len	long
=	O
sizeof	O
(	O
default_emacs_like_info_keys	array(int)
)	O
/	O
sizeof	O
(	O
int	O
)	O
;	O
ea_keys	*(int)
=	O
default_emacs_like_ea_keys	array(int)
;	O
ea_keys_len	long
=	O
sizeof	O
(	O
default_emacs_like_ea_keys	array(int)
)	O
/	O
sizeof	O
(	O
int	O
)	O
;	O
}	O
else	O
{	O
info_keys	*(int)
=	O
default_vi_like_info_keys	array(int)
;	O
info_keys_len	long
=	O
sizeof	O
(	O
default_vi_like_info_keys	array(int)
)	O
/	O
sizeof	O
(	O
int	O
)	O
;	O
ea_keys	*(int)
=	O
default_vi_like_ea_keys	array(int)
;	O
ea_keys_len	long
=	O
sizeof	O
(	O
default_vi_like_ea_keys	array(int)
)	O
/	O
sizeof	O
(	O
int	O
)	O
;	O
}	O
if	O
(	O
fetch_user_maps	(*(char))->(int)
(	O
init_file	*(char)
)	O
)	O
{	O
if	O
(	O
sup_info	int
)	O
info_keys	*(int)
=	O
0	int
;	O
if	O
(	O
sup_ea	int
)	O
ea_keys	*(int)
=	O
0	int
;	O
}	O
if	O
(	O
info_keys	*(int)
)	O
section_to_keymaps	(*(struct(char,union(*(struct`),*(struct`)))),*(int),int)->(void)
(	O
info_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
,	O
info_keys	*(int)
,	O
info_keys_len	long
)	O
;	O
if	O
(	O
ea_keys	*(int)
)	O
section_to_keymaps	(*(struct(char,union(*(struct`),*(struct`)))),*(int),int)->(void)
(	O
echo_area_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
,	O
ea_keys	*(int)
,	O
ea_keys_len	long
)	O
;	O
for	O
(	O
i	int
=	O
'A'	O
;	O
i	int
<	O
(	O
'Z'	O
+	O
1	int
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
info_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
[	O
i	int
]	O
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
)	O
{	O
info_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
=	O
ISFUNC	int
;	O
info_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
[	O
i	int
]	O
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
=	O
InfoCmd	O
(	O
info_do_lowercase_version	(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),int)->(void)
)	O
;	O
}	O
if	O
(	O
!	O
info_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
[	O
KEYMAP_META	O
(	O
i	int
)	O
]	O
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
)	O
{	O
info_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
[	O
KEYMAP_META	O
(	O
i	int
)	O
]	O
.	O
type	enum(int,int,int,int)
=	O
ISFUNC	int
;	O
info_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
[	O
KEYMAP_META	O
(	O
i	int
)	O
]	O
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
=	O
InfoCmd	O
(	O
info_do_lowercase_version	(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),int)->(void)
)	O
;	O
}	O
}	O
}	O
