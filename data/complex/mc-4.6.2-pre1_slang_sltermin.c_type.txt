static	O
int	O
make_integer	(*(char))->(int)
(	O
unsigned	O
char	O
*	O
buf	*(char)
)	O
{	O
register	O
int	O
lo	int
,	O
hi	int
;	O
lo	int
=	O
(	O
int	O
)	O
*	O
buf	*(char)
++	O
;	O
hi	int
=	O
(	O
int	O
)	O
*	O
buf	*(char)
;	O
if	O
(	O
hi	int
==	O
0377	int
)	O
{	O
if	O
(	O
lo	int
==	O
0377	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
lo	int
==	O
0376	int
)	O
return	O
-	O
2	int
;	O
}	O
return	O
lo	int
+	O
256	int
*	O
hi	int
;	O
}	O
struct	O
_pSLterminfo_Type	struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))
{	O
unsigned	O
int	O
flags	int
;	O
unsigned	O
int	O
name_section_size	int
;	O
char	O
*	O
terminal_names	*(char)
;	O
unsigned	O
int	O
boolean_section_size	int
;	O
unsigned	O
char	O
*	O
boolean_flags	*(char)
;	O
unsigned	O
int	O
num_numbers	int
;	O
unsigned	O
char	O
*	O
numbers	*(char)
;	O
unsigned	O
int	O
num_string_offsets	int
;	O
unsigned	O
char	O
*	O
string_offsets	*(char)
;	O
unsigned	O
int	O
string_table_size	int
;	O
char	O
*	O
string_table	*(char)
;	O
}	O
;	O
static	O
char	O
*	O
tcap_getstr	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(*(char))
(	O
char	O
*	O
,	O
SLterminfo_Type	struct
*	O
)	O
;	O
static	O
int	O
tcap_getnum	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(int)
(	O
char	O
*	O
,	O
SLterminfo_Type	struct
*	O
)	O
;	O
static	O
int	O
tcap_getflag	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(int)
(	O
char	O
*	O
,	O
SLterminfo_Type	struct
*	O
)	O
;	O
static	O
int	O
tcap_getent	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(int)
(	O
char	O
*	O
,	O
SLterminfo_Type	struct
*	O
)	O
;	O
static	O
FILE	struct
*	O
open_terminfo	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
char	O
*	O
file	*(char)
,	O
SLterminfo_Type	struct
*	O
h	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
unsigned	O
char	O
buf	*(char)
[	O
12	int
]	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
file	*(char)
,	O
"rb"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
12	int
==	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
(	O
char	O
*	O
)	O
buf	*(char)
,	O
1	int
,	O
12	int
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
&&	O
(	O
MAGIC	int
==	O
make_integer	(*(char))->(int)
(	O
buf	*(char)
)	O
)	O
)	O
)	O
{	O
h	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
name_section_size	int
=	O
make_integer	(*(char))->(int)
(	O
buf	*(char)
+	O
2	int
)	O
;	O
h	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
boolean_section_size	int
=	O
make_integer	(*(char))->(int)
(	O
buf	*(char)
+	O
4	int
)	O
;	O
h	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
num_numbers	int
=	O
make_integer	(*(char))->(int)
(	O
buf	*(char)
+	O
6	int
)	O
;	O
h	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
num_string_offsets	int
=	O
make_integer	(*(char))->(int)
(	O
buf	*(char)
+	O
8	int
)	O
;	O
h	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
string_table_size	int
=	O
make_integer	(*(char))->(int)
(	O
buf	*(char)
+	O
10	int
)	O
;	O
}	O
else	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
}	O
return	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
static	O
unsigned	O
char	O
*	O
read_terminfo_section	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(*(char))
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
unsigned	O
int	O
size	long
)	O
{	O
char	O
*	O
s	*(char)
;	O
if	O
(	O
NULL	O
==	O
(	O
s	*(char)
=	O
(	O
char	O
*	O
)	O
SLmalloc	O
(	O
size	long
)	O
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
size	long
!=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
s	*(char)
,	O
1	int
,	O
size	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
SLfree	O
(	O
s	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
(	O
unsigned	O
char	O
*	O
)	O
s	*(char)
;	O
}	O
static	O
char	O
*	O
read_terminal_names	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(*(char))
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
SLterminfo_Type	struct
*	O
t	long
)	O
{	O
return	O
t	long
->	O
terminal_names	*(char)
=	O
(	O
char	O
*	O
)	O
read_terminfo_section	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(*(char))
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
t	long
->	O
name_section_size	int
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
read_boolean_flags	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(*(char))
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
SLterminfo_Type	struct
*	O
t	long
)	O
{	O
unsigned	O
int	O
size	long
=	O
(	O
t	long
->	O
name_section_size	int
+	O
t	long
->	O
boolean_section_size	int
)	O
%	O
2	int
;	O
size	long
+=	O
t	long
->	O
boolean_section_size	int
;	O
return	O
t	long
->	O
boolean_flags	*(char)
=	O
read_terminfo_section	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(*(char))
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
size	long
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
read_numbers	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(*(char))
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
SLterminfo_Type	struct
*	O
t	long
)	O
{	O
return	O
t	long
->	O
numbers	*(char)
=	O
read_terminfo_section	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(*(char))
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
2	int
*	O
t	long
->	O
num_numbers	int
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
read_string_offsets	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(*(char))
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
SLterminfo_Type	struct
*	O
t	long
)	O
{	O
return	O
t	long
->	O
string_offsets	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
read_terminfo_section	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(*(char))
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
2	int
*	O
t	long
->	O
num_string_offsets	int
)	O
;	O
}	O
static	O
char	O
*	O
read_string_table	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(*(char))
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
SLterminfo_Type	struct
*	O
t	long
)	O
{	O
return	O
t	long
->	O
string_table	*(char)
=	O
(	O
char	O
*	O
)	O
read_terminfo_section	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(*(char))
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
t	long
->	O
string_table_size	int
)	O
;	O
}	O
static	O
char	O
*	O
Terminfo_Dirs	array(*(char))
[	O
]	O
=	O
{	O
NULL	O
,	O
NULL	O
,	O
"/usr/share/terminfo"	*(char)
,	O
"/usr/lib/terminfo"	*(char)
,	O
"/usr/share/lib/terminfo"	*(char)
,	O
"/etc/terminfo"	*(char)
,	O
"/usr/local/lib/terminfo"	*(char)
,	O
""	*(char)
}	O
;	O
SLterminfo_Type	struct
*	O
_pSLtt_tigetent	(*(char))->(*(struct))
(	O
char	O
*	O
term	*(char)
)	O
{	O
char	O
*	O
tidir	*(char)
;	O
int	O
i	array(int)
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
char	O
file	*(char)
[	O
1024	int
]	O
;	O
static	O
char	O
home_ti	array(char)
[	O
1024	int
]	O
;	O
char	O
*	O
home	*(char)
;	O
SLterminfo_Type	struct
*	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
;	O
if	O
(	O
(	O
term	*(char)
==	O
NULL	O
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
_pSLsecure_issetugid	()->(int)
(	O
)	O
&&	O
(	O
(	O
term	*(char)
[	O
0	int
]	O
==	O
'.'	O
)	O
||	O
(	O
NULL	O
!=	O
strchr	(*(char),int)->(*(char))
(	O
term	*(char)
,	O
'/'	O
)	O
)	O
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
NULL	O
==	O
(	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
=	O
(	O
SLterminfo_Type	struct
*	O
)	O
SLmalloc	O
(	O
sizeof	O
(	O
SLterminfo_Type	struct
)	O
)	O
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
if	O
(	O
0	int
==	O
tcap_getent	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(int)
(	O
term	*(char)
,	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
)	O
)	O
return	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
;	O
if	O
(	O
NULL	O
!=	O
(	O
home	*(char)
=	O
_pSLsecure_getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
)	O
)	O
{	O
size_t	long
len	int
=	O
strlen	(*(char))->(long)
(	O
home	*(char)
)	O
;	O
if	O
(	O
len	int
>	O
sizeof	O
(	O
home_ti	array(char)
)	O
-	O
sizeof	O
(	O
"/.terminfo"	*(char)
)	O
)	O
len	int
=	O
sizeof	O
(	O
home_ti	array(char)
)	O
-	O
sizeof	O
(	O
"/.terminfo"	*(char)
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
home_ti	array(char)
,	O
home	*(char)
,	O
len	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
home_ti	array(char)
+	O
len	int
,	O
"/.terminfo"	*(char)
,	O
sizeof	O
(	O
"/.terminfo"	*(char)
)	O
)	O
;	O
Terminfo_Dirs	array(*(char))
[	O
0	int
]	O
=	O
home_ti	array(char)
;	O
}	O
Terminfo_Dirs	array(*(char))
[	O
1	int
]	O
=	O
_pSLsecure_getenv	(*(char))->(*(char))
(	O
"TERMINFO"	*(char)
)	O
;	O
i	array(int)
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
tidir	*(char)
=	O
Terminfo_Dirs	array(*(char))
[	O
i	array(int)
]	O
;	O
if	O
(	O
tidir	*(char)
!=	O
NULL	O
)	O
{	O
if	O
(	O
*	O
tidir	*(char)
==	O
0	int
)	O
break	O
;	O
if	O
(	O
sizeof	O
(	O
file	*(char)
)	O
>=	O
strlen	(*(char))->(long)
(	O
tidir	*(char)
)	O
+	O
4	int
+	O
strlen	(*(char))->(long)
(	O
term	*(char)
)	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
file	*(char)
,	O
"%s/%c/%s"	*(char)
,	O
tidir	*(char)
,	O
*	O
term	*(char)
,	O
term	*(char)
)	O
;	O
if	O
(	O
NULL	O
!=	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
open_terminfo	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
file	*(char)
,	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
)	O
)	O
)	O
break	O
;	O
}	O
}	O
i	array(int)
++	O
;	O
}	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
if	O
(	O
NULL	O
!=	O
read_terminal_names	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(*(char))
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
)	O
)	O
{	O
if	O
(	O
NULL	O
!=	O
read_boolean_flags	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(*(char))
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
)	O
)	O
{	O
if	O
(	O
NULL	O
!=	O
read_numbers	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(*(char))
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
)	O
)	O
{	O
if	O
(	O
NULL	O
!=	O
read_string_offsets	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(*(char))
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
)	O
)	O
{	O
if	O
(	O
NULL	O
!=	O
read_string_table	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(*(char))
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
)	O
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
flags	int
=	O
SLTERMINFO	int
;	O
return	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
;	O
}	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
string_offsets	*(char)
)	O
;	O
}	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
numbers	*(char)
)	O
;	O
}	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
boolean_flags	*(char)
)	O
;	O
}	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
terminal_names	*(char)
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
)	O
;	O
return	O
NULL	O
;	O
}	O
typedef	O
SLCONST	O
struct	O
{	O
char	O
name	*(char)
[	O
3	int
]	O
;	O
int	O
offset	int
;	O
}	O
Tgetstr_Map_Type	struct(array(char),int)
;	O
static	O
Tgetstr_Map_Type	struct(array(char),int)
Tgetstr_Map	array(struct(array(char),int))
[	O
]	O
=	O
{	O
{	O
"!1"	*(char)
,	O
212	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"!2"	*(char)
,	O
213	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"!3"	*(char)
,	O
214	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"#1"	*(char)
,	O
198	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"#2"	*(char)
,	O
199	int
UNTIC_COMMENT	O
(	O
"Key S-Home"	*(char)
)	O
}	O
,	O
{	O
"#3"	*(char)
,	O
200	int
UNTIC_COMMENT	O
(	O
"Key S-Insert"	*(char)
)	O
}	O
,	O
{	O
"#4"	*(char)
,	O
201	int
UNTIC_COMMENT	O
(	O
"Key S-Left"	*(char)
)	O
}	O
,	O
{	O
"%0"	*(char)
,	O
177	int
UNTIC_COMMENT	O
(	O
"redo key"	*(char)
)	O
}	O
,	O
{	O
"%1"	*(char)
,	O
168	int
UNTIC_COMMENT	O
(	O
"help key"	*(char)
)	O
}	O
,	O
{	O
"%2"	*(char)
,	O
169	int
UNTIC_COMMENT	O
(	O
"mark key"	*(char)
)	O
}	O
,	O
{	O
"%3"	*(char)
,	O
170	int
UNTIC_COMMENT	O
(	O
"message key"	*(char)
)	O
}	O
,	O
{	O
"%4"	*(char)
,	O
171	int
UNTIC_COMMENT	O
(	O
"move key"	*(char)
)	O
}	O
,	O
{	O
"%5"	*(char)
,	O
172	int
UNTIC_COMMENT	O
(	O
"next key"	*(char)
)	O
}	O
,	O
{	O
"%6"	*(char)
,	O
173	int
UNTIC_COMMENT	O
(	O
"open key"	*(char)
)	O
}	O
,	O
{	O
"%7"	*(char)
,	O
174	int
UNTIC_COMMENT	O
(	O
"options key"	*(char)
)	O
}	O
,	O
{	O
"%8"	*(char)
,	O
175	int
UNTIC_COMMENT	O
(	O
"previous key"	*(char)
)	O
}	O
,	O
{	O
"%9"	*(char)
,	O
176	int
UNTIC_COMMENT	O
(	O
"print key"	*(char)
)	O
}	O
,	O
{	O
"%a"	*(char)
,	O
202	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"%b"	*(char)
,	O
203	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"%c"	*(char)
,	O
204	int
UNTIC_COMMENT	O
(	O
"Key S-Next"	*(char)
)	O
}	O
,	O
{	O
"%d"	*(char)
,	O
205	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"%e"	*(char)
,	O
206	int
UNTIC_COMMENT	O
(	O
"Key S-Previous"	*(char)
)	O
}	O
,	O
{	O
"%f"	*(char)
,	O
207	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"%g"	*(char)
,	O
208	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"%h"	*(char)
,	O
209	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"%i"	*(char)
,	O
210	int
UNTIC_COMMENT	O
(	O
"Key S-Right"	*(char)
)	O
}	O
,	O
{	O
"%j"	*(char)
,	O
211	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"&0"	*(char)
,	O
187	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"&1"	*(char)
,	O
178	int
UNTIC_COMMENT	O
(	O
"reference key"	*(char)
)	O
}	O
,	O
{	O
"&2"	*(char)
,	O
179	int
UNTIC_COMMENT	O
(	O
"refresh key"	*(char)
)	O
}	O
,	O
{	O
"&3"	*(char)
,	O
180	int
UNTIC_COMMENT	O
(	O
"replace key"	*(char)
)	O
}	O
,	O
{	O
"&4"	*(char)
,	O
181	int
UNTIC_COMMENT	O
(	O
"restart key"	*(char)
)	O
}	O
,	O
{	O
"&5"	*(char)
,	O
182	int
UNTIC_COMMENT	O
(	O
"resume key"	*(char)
)	O
}	O
,	O
{	O
"&6"	*(char)
,	O
183	int
UNTIC_COMMENT	O
(	O
"save key"	*(char)
)	O
}	O
,	O
{	O
"&7"	*(char)
,	O
184	int
UNTIC_COMMENT	O
(	O
"suspend key"	*(char)
)	O
}	O
,	O
{	O
"&8"	*(char)
,	O
185	int
UNTIC_COMMENT	O
(	O
"undo key"	*(char)
)	O
}	O
,	O
{	O
"&9"	*(char)
,	O
186	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"*0"	*(char)
,	O
197	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"*1"	*(char)
,	O
188	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"*2"	*(char)
,	O
189	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"*3"	*(char)
,	O
190	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"*4"	*(char)
,	O
191	int
UNTIC_COMMENT	O
(	O
"Key S-Delete"	*(char)
)	O
}	O
,	O
{	O
"*5"	*(char)
,	O
192	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"*6"	*(char)
,	O
193	int
UNTIC_COMMENT	O
(	O
"select key"	*(char)
)	O
}	O
,	O
{	O
"*7"	*(char)
,	O
194	int
UNTIC_COMMENT	O
(	O
"Key S-End"	*(char)
)	O
}	O
,	O
{	O
"*8"	*(char)
,	O
195	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"*9"	*(char)
,	O
196	int
UNTIC_COMMENT	O
(	O
"shifted key"	*(char)
)	O
}	O
,	O
{	O
"@0"	*(char)
,	O
167	int
UNTIC_COMMENT	O
(	O
"find key"	*(char)
)	O
}	O
,	O
{	O
"@1"	*(char)
,	O
158	int
UNTIC_COMMENT	O
(	O
"begin key"	*(char)
)	O
}	O
,	O
{	O
"@2"	*(char)
,	O
159	int
UNTIC_COMMENT	O
(	O
"cancel key"	*(char)
)	O
}	O
,	O
{	O
"@3"	*(char)
,	O
160	int
UNTIC_COMMENT	O
(	O
"close key"	*(char)
)	O
}	O
,	O
{	O
"@4"	*(char)
,	O
161	int
UNTIC_COMMENT	O
(	O
"command key"	*(char)
)	O
}	O
,	O
{	O
"@5"	*(char)
,	O
162	int
UNTIC_COMMENT	O
(	O
"copy key"	*(char)
)	O
}	O
,	O
{	O
"@6"	*(char)
,	O
163	int
UNTIC_COMMENT	O
(	O
"create key"	*(char)
)	O
}	O
,	O
{	O
"@7"	*(char)
,	O
164	int
UNTIC_COMMENT	O
(	O
"Key End"	*(char)
)	O
}	O
,	O
{	O
"@8"	*(char)
,	O
165	int
UNTIC_COMMENT	O
(	O
"enter/send key"	*(char)
)	O
}	O
,	O
{	O
"@9"	*(char)
,	O
166	int
UNTIC_COMMENT	O
(	O
"exit key"	*(char)
)	O
}	O
,	O
{	O
"AB"	*(char)
,	O
360	int
UNTIC_COMMENT	O
(	O
"set ANSI color background"	*(char)
)	O
}	O
,	O
{	O
"AF"	*(char)
,	O
359	int
UNTIC_COMMENT	O
(	O
"set ANSI color foreground"	*(char)
)	O
}	O
,	O
{	O
"AL"	*(char)
,	O
110	int
UNTIC_COMMENT	O
(	O
"parm_insert_line"	*(char)
)	O
}	O
,	O
{	O
"CC"	*(char)
,	O
9	int
UNTIC_COMMENT	O
(	O
"terminal settable cmd character in prototype !?"	*(char)
)	O
}	O
,	O
{	O
"CM"	*(char)
,	O
15	int
UNTIC_COMMENT	O
(	O
"memory relative cursor addressing"	*(char)
)	O
}	O
,	O
{	O
"CW"	*(char)
,	O
277	int
UNTIC_COMMENT	O
(	O
"define a window #1 from #2, #3 to #4, #5"	*(char)
)	O
}	O
,	O
{	O
"DC"	*(char)
,	O
105	int
UNTIC_COMMENT	O
(	O
"delete #1 chars"	*(char)
)	O
}	O
,	O
{	O
"DI"	*(char)
,	O
280	int
UNTIC_COMMENT	O
(	O
"dial number #1"	*(char)
)	O
}	O
,	O
{	O
"DK"	*(char)
,	O
275	int
UNTIC_COMMENT	O
(	O
"display clock at (#1,#2)"	*(char)
)	O
}	O
,	O
{	O
"DL"	*(char)
,	O
106	int
UNTIC_COMMENT	O
(	O
"parm_delete_line"	*(char)
)	O
}	O
,	O
{	O
"DO"	*(char)
,	O
107	int
UNTIC_COMMENT	O
(	O
"down #1 lines"	*(char)
)	O
}	O
,	O
{	O
"F1"	*(char)
,	O
216	int
UNTIC_COMMENT	O
(	O
"key_f11"	*(char)
)	O
}	O
,	O
{	O
"F2"	*(char)
,	O
217	int
UNTIC_COMMENT	O
(	O
"key_f12"	*(char)
)	O
}	O
,	O
{	O
"F3"	*(char)
,	O
218	int
UNTIC_COMMENT	O
(	O
"key_f13"	*(char)
)	O
}	O
,	O
{	O
"F4"	*(char)
,	O
219	int
UNTIC_COMMENT	O
(	O
"key_f14"	*(char)
)	O
}	O
,	O
{	O
"F5"	*(char)
,	O
220	int
UNTIC_COMMENT	O
(	O
"key_f15"	*(char)
)	O
}	O
,	O
{	O
"F6"	*(char)
,	O
221	int
UNTIC_COMMENT	O
(	O
"key_f16"	*(char)
)	O
}	O
,	O
{	O
"F7"	*(char)
,	O
222	int
UNTIC_COMMENT	O
(	O
"key_f17"	*(char)
)	O
}	O
,	O
{	O
"F8"	*(char)
,	O
223	int
UNTIC_COMMENT	O
(	O
"key_f18"	*(char)
)	O
}	O
,	O
{	O
"F9"	*(char)
,	O
224	int
UNTIC_COMMENT	O
(	O
"key_f19"	*(char)
)	O
}	O
,	O
{	O
"FA"	*(char)
,	O
225	int
UNTIC_COMMENT	O
(	O
"key_f20"	*(char)
)	O
}	O
,	O
{	O
"FB"	*(char)
,	O
226	int
UNTIC_COMMENT	O
(	O
"F21 function key"	*(char)
)	O
}	O
,	O
{	O
"FC"	*(char)
,	O
227	int
UNTIC_COMMENT	O
(	O
"F22 function key"	*(char)
)	O
}	O
,	O
{	O
"FD"	*(char)
,	O
228	int
UNTIC_COMMENT	O
(	O
"F23 function key"	*(char)
)	O
}	O
,	O
{	O
"FE"	*(char)
,	O
229	int
UNTIC_COMMENT	O
(	O
"F24 function key"	*(char)
)	O
}	O
,	O
{	O
"FF"	*(char)
,	O
230	int
UNTIC_COMMENT	O
(	O
"F25 function key"	*(char)
)	O
}	O
,	O
{	O
"FG"	*(char)
,	O
231	int
UNTIC_COMMENT	O
(	O
"F26 function key"	*(char)
)	O
}	O
,	O
{	O
"FH"	*(char)
,	O
232	int
UNTIC_COMMENT	O
(	O
"F27 function key"	*(char)
)	O
}	O
,	O
{	O
"FI"	*(char)
,	O
233	int
UNTIC_COMMENT	O
(	O
"F28 function key"	*(char)
)	O
}	O
,	O
{	O
"FJ"	*(char)
,	O
234	int
UNTIC_COMMENT	O
(	O
"F29 function key"	*(char)
)	O
}	O
,	O
{	O
"FK"	*(char)
,	O
235	int
UNTIC_COMMENT	O
(	O
"F30 function key"	*(char)
)	O
}	O
,	O
{	O
"FL"	*(char)
,	O
236	int
UNTIC_COMMENT	O
(	O
"F31 function key"	*(char)
)	O
}	O
,	O
{	O
"FM"	*(char)
,	O
237	int
UNTIC_COMMENT	O
(	O
"F32 function key"	*(char)
)	O
}	O
,	O
{	O
"FN"	*(char)
,	O
238	int
UNTIC_COMMENT	O
(	O
"F33 function key"	*(char)
)	O
}	O
,	O
{	O
"FO"	*(char)
,	O
239	int
UNTIC_COMMENT	O
(	O
"F34 function key"	*(char)
)	O
}	O
,	O
{	O
"FP"	*(char)
,	O
240	int
UNTIC_COMMENT	O
(	O
"F35 function key"	*(char)
)	O
}	O
,	O
{	O
"FQ"	*(char)
,	O
241	int
UNTIC_COMMENT	O
(	O
"F36 function key"	*(char)
)	O
}	O
,	O
{	O
"FR"	*(char)
,	O
242	int
UNTIC_COMMENT	O
(	O
"F37 function key"	*(char)
)	O
}	O
,	O
{	O
"FS"	*(char)
,	O
243	int
UNTIC_COMMENT	O
(	O
"F38 function key"	*(char)
)	O
}	O
,	O
{	O
"FT"	*(char)
,	O
244	int
UNTIC_COMMENT	O
(	O
"F39 function key"	*(char)
)	O
}	O
,	O
{	O
"FU"	*(char)
,	O
245	int
UNTIC_COMMENT	O
(	O
"F40 function key"	*(char)
)	O
}	O
,	O
{	O
"FV"	*(char)
,	O
246	int
UNTIC_COMMENT	O
(	O
"F41 function key"	*(char)
)	O
}	O
,	O
{	O
"FW"	*(char)
,	O
247	int
UNTIC_COMMENT	O
(	O
"F42 function key"	*(char)
)	O
}	O
,	O
{	O
"FX"	*(char)
,	O
248	int
UNTIC_COMMENT	O
(	O
"F43 function key"	*(char)
)	O
}	O
,	O
{	O
"FY"	*(char)
,	O
249	int
UNTIC_COMMENT	O
(	O
"F44 function key"	*(char)
)	O
}	O
,	O
{	O
"FZ"	*(char)
,	O
250	int
UNTIC_COMMENT	O
(	O
"F45 function key"	*(char)
)	O
}	O
,	O
{	O
"Fa"	*(char)
,	O
251	int
UNTIC_COMMENT	O
(	O
"F46 function key"	*(char)
)	O
}	O
,	O
{	O
"Fb"	*(char)
,	O
252	int
UNTIC_COMMENT	O
(	O
"F47 function key"	*(char)
)	O
}	O
,	O
{	O
"Fc"	*(char)
,	O
253	int
UNTIC_COMMENT	O
(	O
"F48 function key"	*(char)
)	O
}	O
,	O
{	O
"Fd"	*(char)
,	O
254	int
UNTIC_COMMENT	O
(	O
"F49 function key"	*(char)
)	O
}	O
,	O
{	O
"Fe"	*(char)
,	O
255	int
UNTIC_COMMENT	O
(	O
"F50 function key"	*(char)
)	O
}	O
,	O
{	O
"Ff"	*(char)
,	O
256	int
UNTIC_COMMENT	O
(	O
"F51 function key"	*(char)
)	O
}	O
,	O
{	O
"Fg"	*(char)
,	O
257	int
UNTIC_COMMENT	O
(	O
"F52 function key"	*(char)
)	O
}	O
,	O
{	O
"Fh"	*(char)
,	O
258	int
UNTIC_COMMENT	O
(	O
"F53 function key"	*(char)
)	O
}	O
,	O
{	O
"Fi"	*(char)
,	O
259	int
UNTIC_COMMENT	O
(	O
"F54 function key"	*(char)
)	O
}	O
,	O
{	O
"Fj"	*(char)
,	O
260	int
UNTIC_COMMENT	O
(	O
"F55 function key"	*(char)
)	O
}	O
,	O
{	O
"Fk"	*(char)
,	O
261	int
UNTIC_COMMENT	O
(	O
"F56 function key"	*(char)
)	O
}	O
,	O
{	O
"Fl"	*(char)
,	O
262	int
UNTIC_COMMENT	O
(	O
"F57 function key"	*(char)
)	O
}	O
,	O
{	O
"Fm"	*(char)
,	O
263	int
UNTIC_COMMENT	O
(	O
"F58 function key"	*(char)
)	O
}	O
,	O
{	O
"Fn"	*(char)
,	O
264	int
UNTIC_COMMENT	O
(	O
"F59 function key"	*(char)
)	O
}	O
,	O
{	O
"Fo"	*(char)
,	O
265	int
UNTIC_COMMENT	O
(	O
"F60 function key"	*(char)
)	O
}	O
,	O
{	O
"Fp"	*(char)
,	O
266	int
UNTIC_COMMENT	O
(	O
"F61 function key"	*(char)
)	O
}	O
,	O
{	O
"Fq"	*(char)
,	O
267	int
UNTIC_COMMENT	O
(	O
"F62 function key"	*(char)
)	O
}	O
,	O
{	O
"Fr"	*(char)
,	O
268	int
UNTIC_COMMENT	O
(	O
"F63 function key"	*(char)
)	O
}	O
,	O
{	O
"G1"	*(char)
,	O
400	int
UNTIC_COMMENT	O
(	O
"single upper right"	*(char)
)	O
}	O
,	O
{	O
"G2"	*(char)
,	O
398	int
UNTIC_COMMENT	O
(	O
"single upper left"	*(char)
)	O
}	O
,	O
{	O
"G3"	*(char)
,	O
399	int
UNTIC_COMMENT	O
(	O
"single lower left"	*(char)
)	O
}	O
,	O
{	O
"G4"	*(char)
,	O
401	int
UNTIC_COMMENT	O
(	O
"single lower right"	*(char)
)	O
}	O
,	O
{	O
"GC"	*(char)
,	O
408	int
UNTIC_COMMENT	O
(	O
"single intersection"	*(char)
)	O
}	O
,	O
{	O
"GD"	*(char)
,	O
405	int
UNTIC_COMMENT	O
(	O
"tee pointing down"	*(char)
)	O
}	O
,	O
{	O
"GH"	*(char)
,	O
406	int
UNTIC_COMMENT	O
(	O
"single horizontal line"	*(char)
)	O
}	O
,	O
{	O
"GL"	*(char)
,	O
403	int
UNTIC_COMMENT	O
(	O
"tee pointing left"	*(char)
)	O
}	O
,	O
{	O
"GR"	*(char)
,	O
402	int
UNTIC_COMMENT	O
(	O
"tee pointing right"	*(char)
)	O
}	O
,	O
{	O
"GU"	*(char)
,	O
404	int
UNTIC_COMMENT	O
(	O
"tee pointing up"	*(char)
)	O
}	O
,	O
{	O
"GV"	*(char)
,	O
407	int
UNTIC_COMMENT	O
(	O
"single vertical line"	*(char)
)	O
}	O
,	O
{	O
"Gm"	*(char)
,	O
358	int
UNTIC_COMMENT	O
(	O
"Curses should get button events"	*(char)
)	O
}	O
,	O
{	O
"HU"	*(char)
,	O
279	int
UNTIC_COMMENT	O
(	O
"hang-up phone"	*(char)
)	O
}	O
,	O
{	O
"IC"	*(char)
,	O
108	int
UNTIC_COMMENT	O
(	O
"insert #1 chars"	*(char)
)	O
}	O
,	O
{	O
"Ic"	*(char)
,	O
299	int
UNTIC_COMMENT	O
(	O
"initialize color #1 to (#2,#3,#4)"	*(char)
)	O
}	O
,	O
{	O
"Ip"	*(char)
,	O
300	int
UNTIC_COMMENT	O
(	O
"Initialize color pair #1 to fg=(#2,#3,#4), bg=(#5,#6,#7)"	*(char)
)	O
}	O
,	O
{	O
"K1"	*(char)
,	O
139	int
UNTIC_COMMENT	O
(	O
"upper left of keypad"	*(char)
)	O
}	O
,	O
{	O
"K2"	*(char)
,	O
141	int
UNTIC_COMMENT	O
(	O
"center of keypad"	*(char)
)	O
}	O
,	O
{	O
"K3"	*(char)
,	O
140	int
UNTIC_COMMENT	O
(	O
"upper right of keypad"	*(char)
)	O
}	O
,	O
{	O
"K4"	*(char)
,	O
142	int
UNTIC_COMMENT	O
(	O
"lower left of keypad"	*(char)
)	O
}	O
,	O
{	O
"K5"	*(char)
,	O
143	int
UNTIC_COMMENT	O
(	O
"lower right of keypad"	*(char)
)	O
}	O
,	O
{	O
"Km"	*(char)
,	O
355	int
UNTIC_COMMENT	O
(	O
"Mouse event has occurred"	*(char)
)	O
}	O
,	O
{	O
"LE"	*(char)
,	O
111	int
UNTIC_COMMENT	O
(	O
"move #1 chars to the left"	*(char)
)	O
}	O
,	O
{	O
"LF"	*(char)
,	O
157	int
UNTIC_COMMENT	O
(	O
"turn off soft labels"	*(char)
)	O
}	O
,	O
{	O
"LO"	*(char)
,	O
156	int
UNTIC_COMMENT	O
(	O
"turn on soft labels"	*(char)
)	O
}	O
,	O
{	O
"Lf"	*(char)
,	O
273	int
UNTIC_COMMENT	O
(	O
"label format"	*(char)
)	O
}	O
,	O
{	O
"MC"	*(char)
,	O
270	int
UNTIC_COMMENT	O
(	O
"clear right and left soft margins"	*(char)
)	O
}	O
,	O
{	O
"ML"	*(char)
,	O
271	int
UNTIC_COMMENT	O
(	O
"set left soft margin"	*(char)
)	O
}	O
,	O
{	O
"ML"	*(char)
,	O
368	int
UNTIC_COMMENT	O
(	O
"Set both left and right margins to #1, #2"	*(char)
)	O
}	O
,	O
{	O
"MR"	*(char)
,	O
272	int
UNTIC_COMMENT	O
(	O
"set right soft margin"	*(char)
)	O
}	O
,	O
{	O
"MT"	*(char)
,	O
369	int
UNTIC_COMMENT	O
(	O
"Sets both top and bottom margins to #1, #2"	*(char)
)	O
}	O
,	O
{	O
"Mi"	*(char)
,	O
356	int
UNTIC_COMMENT	O
(	O
"Mouse status information"	*(char)
)	O
}	O
,	O
{	O
"PA"	*(char)
,	O
285	int
UNTIC_COMMENT	O
(	O
"pause for 2-3 seconds"	*(char)
)	O
}	O
,	O
{	O
"PU"	*(char)
,	O
283	int
UNTIC_COMMENT	O
(	O
"select pulse dialling"	*(char)
)	O
}	O
,	O
{	O
"QD"	*(char)
,	O
281	int
UNTIC_COMMENT	O
(	O
"dial number #1 without checking"	*(char)
)	O
}	O
,	O
{	O
"RA"	*(char)
,	O
152	int
UNTIC_COMMENT	O
(	O
"turn off automatic margins"	*(char)
)	O
}	O
,	O
{	O
"RC"	*(char)
,	O
276	int
UNTIC_COMMENT	O
(	O
"remove clock"	*(char)
)	O
}	O
,	O
{	O
"RF"	*(char)
,	O
215	int
UNTIC_COMMENT	O
(	O
"send next input char (for ptys)"	*(char)
)	O
}	O
,	O
{	O
"RI"	*(char)
,	O
112	int
UNTIC_COMMENT	O
(	O
"parm_right_cursor"	*(char)
)	O
}	O
,	O
{	O
"RQ"	*(char)
,	O
357	int
UNTIC_COMMENT	O
(	O
"Request mouse position"	*(char)
)	O
}	O
,	O
{	O
"RX"	*(char)
,	O
150	int
UNTIC_COMMENT	O
(	O
"turn off xon/xoff handshaking"	*(char)
)	O
}	O
,	O
{	O
"S1"	*(char)
,	O
378	int
UNTIC_COMMENT	O
(	O
"Display PC character"	*(char)
)	O
}	O
,	O
{	O
"S2"	*(char)
,	O
379	int
UNTIC_COMMENT	O
(	O
"Enter PC character display mode"	*(char)
)	O
}	O
,	O
{	O
"S3"	*(char)
,	O
380	int
UNTIC_COMMENT	O
(	O
"Exit PC character display mode"	*(char)
)	O
}	O
,	O
{	O
"S4"	*(char)
,	O
381	int
UNTIC_COMMENT	O
(	O
"Enter PC scancode mode"	*(char)
)	O
}	O
,	O
{	O
"S5"	*(char)
,	O
382	int
UNTIC_COMMENT	O
(	O
"Exit PC scancode mode"	*(char)
)	O
}	O
,	O
{	O
"S6"	*(char)
,	O
383	int
UNTIC_COMMENT	O
(	O
"PC terminal options"	*(char)
)	O
}	O
,	O
{	O
"S7"	*(char)
,	O
384	int
UNTIC_COMMENT	O
(	O
"Escape for scancode emulation"	*(char)
)	O
}	O
,	O
{	O
"S8"	*(char)
,	O
385	int
UNTIC_COMMENT	O
(	O
"Alternate escape for scancode emulation"	*(char)
)	O
}	O
,	O
{	O
"SA"	*(char)
,	O
151	int
UNTIC_COMMENT	O
(	O
"turn on automatic margins"	*(char)
)	O
}	O
,	O
{	O
"SC"	*(char)
,	O
274	int
UNTIC_COMMENT	O
(	O
"set clock, #1 hrs #2 mins #3 secs"	*(char)
)	O
}	O
,	O
{	O
"SF"	*(char)
,	O
109	int
UNTIC_COMMENT	O
(	O
"scroll forward #1 lines"	*(char)
)	O
}	O
,	O
{	O
"SR"	*(char)
,	O
113	int
UNTIC_COMMENT	O
(	O
"scroll back #1 lines"	*(char)
)	O
}	O
,	O
{	O
"SX"	*(char)
,	O
149	int
UNTIC_COMMENT	O
(	O
"turn on xon/xoff handshaking"	*(char)
)	O
}	O
,	O
{	O
"Sb"	*(char)
,	O
303	int
UNTIC_COMMENT	O
(	O
"set background (color)"	*(char)
)	O
}	O
,	O
{	O
"Sf"	*(char)
,	O
302	int
UNTIC_COMMENT	O
(	O
"set foreground (color)"	*(char)
)	O
}	O
,	O
{	O
"TO"	*(char)
,	O
282	int
UNTIC_COMMENT	O
(	O
"select touch tone dialing"	*(char)
)	O
}	O
,	O
{	O
"UP"	*(char)
,	O
114	int
UNTIC_COMMENT	O
(	O
"up #1 lines"	*(char)
)	O
}	O
,	O
{	O
"WA"	*(char)
,	O
286	int
UNTIC_COMMENT	O
(	O
"wait for dial-tone"	*(char)
)	O
}	O
,	O
{	O
"WG"	*(char)
,	O
278	int
UNTIC_COMMENT	O
(	O
"go to window #1"	*(char)
)	O
}	O
,	O
{	O
"XF"	*(char)
,	O
154	int
UNTIC_COMMENT	O
(	O
"XOFF character"	*(char)
)	O
}	O
,	O
{	O
"XN"	*(char)
,	O
153	int
UNTIC_COMMENT	O
(	O
"XON character"	*(char)
)	O
}	O
,	O
{	O
"Xh"	*(char)
,	O
386	int
UNTIC_COMMENT	O
(	O
"Enter horizontal highlight mode"	*(char)
)	O
}	O
,	O
{	O
"Xl"	*(char)
,	O
387	int
UNTIC_COMMENT	O
(	O
"Enter left highlight mode"	*(char)
)	O
}	O
,	O
{	O
"Xo"	*(char)
,	O
388	int
UNTIC_COMMENT	O
(	O
"Enter low highlight mode"	*(char)
)	O
}	O
,	O
{	O
"Xr"	*(char)
,	O
389	int
UNTIC_COMMENT	O
(	O
"Enter right highlight mode"	*(char)
)	O
}	O
,	O
{	O
"Xt"	*(char)
,	O
390	int
UNTIC_COMMENT	O
(	O
"Enter top highlight mode"	*(char)
)	O
}	O
,	O
{	O
"Xv"	*(char)
,	O
391	int
UNTIC_COMMENT	O
(	O
"Enter vertical highlight mode"	*(char)
)	O
}	O
,	O
{	O
"Xy"	*(char)
,	O
370	int
UNTIC_COMMENT	O
(	O
"Repeat bit image cell #1 #2 times"	*(char)
)	O
}	O
,	O
{	O
"YZ"	*(char)
,	O
377	int
UNTIC_COMMENT	O
(	O
"Set page length to #1 lines"	*(char)
)	O
}	O
,	O
{	O
"Yv"	*(char)
,	O
372	int
UNTIC_COMMENT	O
(	O
"Move to beginning of same row"	*(char)
)	O
}	O
,	O
{	O
"Yw"	*(char)
,	O
373	int
UNTIC_COMMENT	O
(	O
"Give name for color #1"	*(char)
)	O
}	O
,	O
{	O
"Yx"	*(char)
,	O
374	int
UNTIC_COMMENT	O
(	O
"Define rectangualar bit image region"	*(char)
)	O
}	O
,	O
{	O
"Yy"	*(char)
,	O
375	int
UNTIC_COMMENT	O
(	O
"End a bit-image region"	*(char)
)	O
}	O
,	O
{	O
"Yz"	*(char)
,	O
376	int
UNTIC_COMMENT	O
(	O
"Change to ribbon color #1"	*(char)
)	O
}	O
,	O
{	O
"ZA"	*(char)
,	O
304	int
UNTIC_COMMENT	O
(	O
"Change number of characters per inch"	*(char)
)	O
}	O
,	O
{	O
"ZB"	*(char)
,	O
305	int
UNTIC_COMMENT	O
(	O
"Change number of lines per inch"	*(char)
)	O
}	O
,	O
{	O
"ZC"	*(char)
,	O
306	int
UNTIC_COMMENT	O
(	O
"Change horizontal resolution"	*(char)
)	O
}	O
,	O
{	O
"ZD"	*(char)
,	O
307	int
UNTIC_COMMENT	O
(	O
"Change vertical resolution"	*(char)
)	O
}	O
,	O
{	O
"ZE"	*(char)
,	O
308	int
UNTIC_COMMENT	O
(	O
"Define a character"	*(char)
)	O
}	O
,	O
{	O
"ZF"	*(char)
,	O
309	int
UNTIC_COMMENT	O
(	O
"Enter double-wide mode"	*(char)
)	O
}	O
,	O
{	O
"ZG"	*(char)
,	O
310	int
UNTIC_COMMENT	O
(	O
"Enter draft-quality mode"	*(char)
)	O
}	O
,	O
{	O
"ZH"	*(char)
,	O
311	int
UNTIC_COMMENT	O
(	O
"Enter italic mode"	*(char)
)	O
}	O
,	O
{	O
"ZI"	*(char)
,	O
312	int
UNTIC_COMMENT	O
(	O
"Start leftward carriage motion"	*(char)
)	O
}	O
,	O
{	O
"ZJ"	*(char)
,	O
313	int
UNTIC_COMMENT	O
(	O
"Start micro-motion mode"	*(char)
)	O
}	O
,	O
{	O
"ZK"	*(char)
,	O
314	int
UNTIC_COMMENT	O
(	O
"Enter NLQ mode"	*(char)
)	O
}	O
,	O
{	O
"ZL"	*(char)
,	O
315	int
UNTIC_COMMENT	O
(	O
"Wnter normal-quality mode"	*(char)
)	O
}	O
,	O
{	O
"ZM"	*(char)
,	O
316	int
UNTIC_COMMENT	O
(	O
"Enter shadow-print mode"	*(char)
)	O
}	O
,	O
{	O
"ZN"	*(char)
,	O
317	int
UNTIC_COMMENT	O
(	O
"Enter subscript mode"	*(char)
)	O
}	O
,	O
{	O
"ZO"	*(char)
,	O
318	int
UNTIC_COMMENT	O
(	O
"Enter superscript mode"	*(char)
)	O
}	O
,	O
{	O
"ZP"	*(char)
,	O
319	int
UNTIC_COMMENT	O
(	O
"Start upward carriage motion"	*(char)
)	O
}	O
,	O
{	O
"ZQ"	*(char)
,	O
320	int
UNTIC_COMMENT	O
(	O
"End double-wide mode"	*(char)
)	O
}	O
,	O
{	O
"ZR"	*(char)
,	O
321	int
UNTIC_COMMENT	O
(	O
"End italic mode"	*(char)
)	O
}	O
,	O
{	O
"ZS"	*(char)
,	O
322	int
UNTIC_COMMENT	O
(	O
"End left-motion mode"	*(char)
)	O
}	O
,	O
{	O
"ZT"	*(char)
,	O
323	int
UNTIC_COMMENT	O
(	O
"End micro-motion mode"	*(char)
)	O
}	O
,	O
{	O
"ZU"	*(char)
,	O
324	int
UNTIC_COMMENT	O
(	O
"End shadow-print mode"	*(char)
)	O
}	O
,	O
{	O
"ZV"	*(char)
,	O
325	int
UNTIC_COMMENT	O
(	O
"End subscript mode"	*(char)
)	O
}	O
,	O
{	O
"ZW"	*(char)
,	O
326	int
UNTIC_COMMENT	O
(	O
"End superscript mode"	*(char)
)	O
}	O
,	O
{	O
"ZX"	*(char)
,	O
327	int
UNTIC_COMMENT	O
(	O
"End reverse character motion"	*(char)
)	O
}	O
,	O
{	O
"ZY"	*(char)
,	O
328	int
UNTIC_COMMENT	O
(	O
"Like column_address in micro mode"	*(char)
)	O
}	O
,	O
{	O
"ZZ"	*(char)
,	O
329	int
UNTIC_COMMENT	O
(	O
"Like cursor_down in micro mode"	*(char)
)	O
}	O
,	O
{	O
"Za"	*(char)
,	O
330	int
UNTIC_COMMENT	O
(	O
"Like cursor_left in micro mode"	*(char)
)	O
}	O
,	O
{	O
"Zb"	*(char)
,	O
331	int
UNTIC_COMMENT	O
(	O
"Like cursor_right in micro mode"	*(char)
)	O
}	O
,	O
{	O
"Zc"	*(char)
,	O
332	int
UNTIC_COMMENT	O
(	O
"Like row_address in micro mode"	*(char)
)	O
}	O
,	O
{	O
"Zd"	*(char)
,	O
333	int
UNTIC_COMMENT	O
(	O
"Like cursor_up in micro mode"	*(char)
)	O
}	O
,	O
{	O
"Ze"	*(char)
,	O
334	int
UNTIC_COMMENT	O
(	O
"Match software bits to print-head pins"	*(char)
)	O
}	O
,	O
{	O
"Zf"	*(char)
,	O
335	int
UNTIC_COMMENT	O
(	O
"Like parm_down_cursor in micro mode"	*(char)
)	O
}	O
,	O
{	O
"Zg"	*(char)
,	O
336	int
UNTIC_COMMENT	O
(	O
"Like parm_left_cursor in micro mode"	*(char)
)	O
}	O
,	O
{	O
"Zh"	*(char)
,	O
337	int
UNTIC_COMMENT	O
(	O
"Like parm_right_cursor in micro mode"	*(char)
)	O
}	O
,	O
{	O
"Zi"	*(char)
,	O
338	int
UNTIC_COMMENT	O
(	O
"Like parm_up_cursor in micro mode"	*(char)
)	O
}	O
,	O
{	O
"Zj"	*(char)
,	O
339	int
UNTIC_COMMENT	O
(	O
"Select character set"	*(char)
)	O
}	O
,	O
{	O
"Zk"	*(char)
,	O
340	int
UNTIC_COMMENT	O
(	O
"Set bottom margin at current line"	*(char)
)	O
}	O
,	O
{	O
"Zl"	*(char)
,	O
341	int
UNTIC_COMMENT	O
(	O
"Set bottom margin at line #1 or #2 lines from bottom"	*(char)
)	O
}	O
,	O
{	O
"Zm"	*(char)
,	O
342	int
UNTIC_COMMENT	O
(	O
"Set left (right) margin at column #1 (#2)"	*(char)
)	O
}	O
,	O
{	O
"Zn"	*(char)
,	O
343	int
UNTIC_COMMENT	O
(	O
"Set right margin at column #1"	*(char)
)	O
}	O
,	O
{	O
"Zo"	*(char)
,	O
344	int
UNTIC_COMMENT	O
(	O
"Set top margin at current line"	*(char)
)	O
}	O
,	O
{	O
"Zp"	*(char)
,	O
345	int
UNTIC_COMMENT	O
(	O
"Set top (bottom) margin at row #1 (#2)"	*(char)
)	O
}	O
,	O
{	O
"Zq"	*(char)
,	O
346	int
UNTIC_COMMENT	O
(	O
"Start printing bit image braphics"	*(char)
)	O
}	O
,	O
{	O
"Zr"	*(char)
,	O
347	int
UNTIC_COMMENT	O
(	O
"Start character set definition"	*(char)
)	O
}	O
,	O
{	O
"Zs"	*(char)
,	O
348	int
UNTIC_COMMENT	O
(	O
"Stop printing bit image graphics"	*(char)
)	O
}	O
,	O
{	O
"Zt"	*(char)
,	O
349	int
UNTIC_COMMENT	O
(	O
"End definition of character aet"	*(char)
)	O
}	O
,	O
{	O
"Zu"	*(char)
,	O
350	int
UNTIC_COMMENT	O
(	O
"List of subscriptable characters"	*(char)
)	O
}	O
,	O
{	O
"Zv"	*(char)
,	O
351	int
UNTIC_COMMENT	O
(	O
"List of superscriptable characters"	*(char)
)	O
}	O
,	O
{	O
"Zw"	*(char)
,	O
352	int
UNTIC_COMMENT	O
(	O
"Printing any of these chars causes CR"	*(char)
)	O
}	O
,	O
{	O
"Zx"	*(char)
,	O
353	int
UNTIC_COMMENT	O
(	O
"No motion for subsequent character"	*(char)
)	O
}	O
,	O
{	O
"Zy"	*(char)
,	O
354	int
UNTIC_COMMENT	O
(	O
"List of character set names"	*(char)
)	O
}	O
,	O
{	O
"Zz"	*(char)
,	O
371	int
UNTIC_COMMENT	O
(	O
"Move to next row of the bit image"	*(char)
)	O
}	O
,	O
{	O
"ac"	*(char)
,	O
146	int
UNTIC_COMMENT	O
(	O
"acs_chars"	*(char)
)	O
}	O
,	O
{	O
"ae"	*(char)
,	O
38	int
UNTIC_COMMENT	O
(	O
"exit_alt_charset_mode"	*(char)
)	O
}	O
,	O
{	O
"al"	*(char)
,	O
53	int
UNTIC_COMMENT	O
(	O
"insert line"	*(char)
)	O
}	O
,	O
{	O
"as"	*(char)
,	O
25	int
UNTIC_COMMENT	O
(	O
"enter_alt_charset_mode"	*(char)
)	O
}	O
,	O
{	O
"bc"	*(char)
,	O
395	int
UNTIC_COMMENT	O
(	O
"move left, if not ^H"	*(char)
)	O
}	O
,	O
{	O
"bl"	*(char)
,	O
1	int
UNTIC_COMMENT	O
(	O
"audible signal (bell)"	*(char)
)	O
}	O
,	O
{	O
"bt"	*(char)
,	O
0	int
UNTIC_COMMENT	O
(	O
"back tab"	*(char)
)	O
}	O
,	O
{	O
"bx"	*(char)
,	O
411	int
UNTIC_COMMENT	O
(	O
"box chars primary set"	*(char)
)	O
}	O
,	O
{	O
"cb"	*(char)
,	O
269	int
UNTIC_COMMENT	O
(	O
"Clear to beginning of line"	*(char)
)	O
}	O
,	O
{	O
"cd"	*(char)
,	O
7	int
UNTIC_COMMENT	O
(	O
"clear to end of screen"	*(char)
)	O
}	O
,	O
{	O
"ce"	*(char)
,	O
6	int
UNTIC_COMMENT	O
(	O
"clr_eol"	*(char)
)	O
}	O
,	O
{	O
"ch"	*(char)
,	O
8	int
UNTIC_COMMENT	O
(	O
"horizontal position #1, absolute"	*(char)
)	O
}	O
,	O
{	O
"ci"	*(char)
,	O
363	int
UNTIC_COMMENT	O
(	O
"Init sequence for multiple codesets"	*(char)
)	O
}	O
,	O
{	O
"cl"	*(char)
,	O
5	int
UNTIC_COMMENT	O
(	O
"clear screen and home cursor"	*(char)
)	O
}	O
,	O
{	O
"cm"	*(char)
,	O
10	int
UNTIC_COMMENT	O
(	O
"move to row #1 columns #2"	*(char)
)	O
}	O
,	O
{	O
"cr"	*(char)
,	O
2	int
UNTIC_COMMENT	O
(	O
"carriage return"	*(char)
)	O
}	O
,	O
{	O
"cs"	*(char)
,	O
3	int
UNTIC_COMMENT	O
(	O
"change region to line #1 to line #2"	*(char)
)	O
}	O
,	O
{	O
"ct"	*(char)
,	O
4	int
UNTIC_COMMENT	O
(	O
"clear all tab stops"	*(char)
)	O
}	O
,	O
{	O
"cv"	*(char)
,	O
127	int
UNTIC_COMMENT	O
(	O
"vertical position #1 absolute"	*(char)
)	O
}	O
,	O
{	O
"dc"	*(char)
,	O
21	int
UNTIC_COMMENT	O
(	O
"delete character"	*(char)
)	O
}	O
,	O
{	O
"dl"	*(char)
,	O
22	int
UNTIC_COMMENT	O
(	O
"delete line"	*(char)
)	O
}	O
,	O
{	O
"dm"	*(char)
,	O
29	int
UNTIC_COMMENT	O
(	O
"enter delete mode"	*(char)
)	O
}	O
,	O
{	O
"do"	*(char)
,	O
11	int
UNTIC_COMMENT	O
(	O
"down one line"	*(char)
)	O
}	O
,	O
{	O
"ds"	*(char)
,	O
23	int
UNTIC_COMMENT	O
(	O
"disable status line"	*(char)
)	O
}	O
,	O
{	O
"dv"	*(char)
,	O
362	int
UNTIC_COMMENT	O
(	O
"Indicate language/codeset support"	*(char)
)	O
}	O
,	O
{	O
"eA"	*(char)
,	O
155	int
UNTIC_COMMENT	O
(	O
"enable alternate char set"	*(char)
)	O
}	O
,	O
{	O
"ec"	*(char)
,	O
37	int
UNTIC_COMMENT	O
(	O
"erase #1 characters"	*(char)
)	O
}	O
,	O
{	O
"ed"	*(char)
,	O
41	int
UNTIC_COMMENT	O
(	O
"end delete mode"	*(char)
)	O
}	O
,	O
{	O
"ei"	*(char)
,	O
42	int
UNTIC_COMMENT	O
(	O
"exit insert mode"	*(char)
)	O
}	O
,	O
{	O
"ff"	*(char)
,	O
46	int
UNTIC_COMMENT	O
(	O
"hardcopy terminal page eject"	*(char)
)	O
}	O
,	O
{	O
"fh"	*(char)
,	O
284	int
UNTIC_COMMENT	O
(	O
"flash switch hook"	*(char)
)	O
}	O
,	O
{	O
"fs"	*(char)
,	O
47	int
UNTIC_COMMENT	O
(	O
"return from status line"	*(char)
)	O
}	O
,	O
{	O
"hd"	*(char)
,	O
24	int
UNTIC_COMMENT	O
(	O
"half a line down"	*(char)
)	O
}	O
,	O
{	O
"ho"	*(char)
,	O
12	int
UNTIC_COMMENT	O
(	O
"home cursor (if no cup)"	*(char)
)	O
}	O
,	O
{	O
"hu"	*(char)
,	O
137	int
UNTIC_COMMENT	O
(	O
"half a line up"	*(char)
)	O
}	O
,	O
{	O
"i1"	*(char)
,	O
48	int
UNTIC_COMMENT	O
(	O
"initialization string"	*(char)
)	O
}	O
,	O
{	O
"i2"	*(char)
,	O
392	int
UNTIC_COMMENT	O
(	O
"secondary initialization string"	*(char)
)	O
}	O
,	O
{	O
"i3"	*(char)
,	O
50	int
UNTIC_COMMENT	O
(	O
"initialization string"	*(char)
)	O
}	O
,	O
{	O
"iP"	*(char)
,	O
138	int
UNTIC_COMMENT	O
(	O
"path name of program for initialization"	*(char)
)	O
}	O
,	O
{	O
"ic"	*(char)
,	O
52	int
UNTIC_COMMENT	O
(	O
"insert character"	*(char)
)	O
}	O
,	O
{	O
"if"	*(char)
,	O
51	int
UNTIC_COMMENT	O
(	O
"name of initialization file"	*(char)
)	O
}	O
,	O
{	O
"im"	*(char)
,	O
31	int
UNTIC_COMMENT	O
(	O
"enter insert mode"	*(char)
)	O
}	O
,	O
{	O
"ip"	*(char)
,	O
54	int
UNTIC_COMMENT	O
(	O
"insert padding after inserted character"	*(char)
)	O
}	O
,	O
{	O
"is"	*(char)
,	O
49	int
UNTIC_COMMENT	O
(	O
"initialization string"	*(char)
)	O
}	O
,	O
{	O
"k0"	*(char)
,	O
65	int
UNTIC_COMMENT	O
(	O
"F0 function key"	*(char)
)	O
}	O
,	O
{	O
"k1"	*(char)
,	O
66	int
UNTIC_COMMENT	O
(	O
"F1 function key"	*(char)
)	O
}	O
,	O
{	O
"k2"	*(char)
,	O
68	int
UNTIC_COMMENT	O
(	O
"F2 function key"	*(char)
)	O
}	O
,	O
{	O
"k3"	*(char)
,	O
69	int
UNTIC_COMMENT	O
(	O
"F3 function key"	*(char)
)	O
}	O
,	O
{	O
"k4"	*(char)
,	O
70	int
UNTIC_COMMENT	O
(	O
"F4 function key"	*(char)
)	O
}	O
,	O
{	O
"k5"	*(char)
,	O
71	int
UNTIC_COMMENT	O
(	O
"F5 function key"	*(char)
)	O
}	O
,	O
{	O
"k6"	*(char)
,	O
72	int
UNTIC_COMMENT	O
(	O
"F6 function key"	*(char)
)	O
}	O
,	O
{	O
"k7"	*(char)
,	O
73	int
UNTIC_COMMENT	O
(	O
"F7 function key"	*(char)
)	O
}	O
,	O
{	O
"k8"	*(char)
,	O
74	int
UNTIC_COMMENT	O
(	O
"F8 fucntion key"	*(char)
)	O
}	O
,	O
{	O
"k9"	*(char)
,	O
75	int
UNTIC_COMMENT	O
(	O
"F9 function key"	*(char)
)	O
}	O
,	O
{	O
"k;"	*(char)
,	O
67	int
UNTIC_COMMENT	O
(	O
"F10 function key"	*(char)
)	O
}	O
,	O
{	O
"kA"	*(char)
,	O
78	int
UNTIC_COMMENT	O
(	O
"insert-line key"	*(char)
)	O
}	O
,	O
{	O
"kB"	*(char)
,	O
148	int
UNTIC_COMMENT	O
(	O
"back-tab key"	*(char)
)	O
}	O
,	O
{	O
"kC"	*(char)
,	O
57	int
UNTIC_COMMENT	O
(	O
"clear-screen or erase key"	*(char)
)	O
}	O
,	O
{	O
"kD"	*(char)
,	O
59	int
UNTIC_COMMENT	O
(	O
"delete-character key"	*(char)
)	O
}	O
,	O
{	O
"kE"	*(char)
,	O
63	int
UNTIC_COMMENT	O
(	O
"clear-to-end-of-line key"	*(char)
)	O
}	O
,	O
{	O
"kF"	*(char)
,	O
84	int
UNTIC_COMMENT	O
(	O
"scroll-forward key"	*(char)
)	O
}	O
,	O
{	O
"kH"	*(char)
,	O
80	int
UNTIC_COMMENT	O
(	O
"last-line key"	*(char)
)	O
}	O
,	O
{	O
"kI"	*(char)
,	O
77	int
UNTIC_COMMENT	O
(	O
"insert-character key"	*(char)
)	O
}	O
,	O
{	O
"kL"	*(char)
,	O
60	int
UNTIC_COMMENT	O
(	O
"delete-line key"	*(char)
)	O
}	O
,	O
{	O
"kM"	*(char)
,	O
62	int
UNTIC_COMMENT	O
(	O
"sent by rmir or smir in insert mode"	*(char)
)	O
}	O
,	O
{	O
"kN"	*(char)
,	O
81	int
UNTIC_COMMENT	O
(	O
"next-page key"	*(char)
)	O
}	O
,	O
{	O
"kP"	*(char)
,	O
82	int
UNTIC_COMMENT	O
(	O
"prev-page key"	*(char)
)	O
}	O
,	O
{	O
"kR"	*(char)
,	O
85	int
UNTIC_COMMENT	O
(	O
"scroll-backward key"	*(char)
)	O
}	O
,	O
{	O
"kS"	*(char)
,	O
64	int
UNTIC_COMMENT	O
(	O
"clear-to-end-of-screen key"	*(char)
)	O
}	O
,	O
{	O
"kT"	*(char)
,	O
86	int
UNTIC_COMMENT	O
(	O
"set-tab key"	*(char)
)	O
}	O
,	O
{	O
"ka"	*(char)
,	O
56	int
UNTIC_COMMENT	O
(	O
"clear-all-tabs key"	*(char)
)	O
}	O
,	O
{	O
"kb"	*(char)
,	O
55	int
UNTIC_COMMENT	O
(	O
"backspace key"	*(char)
)	O
}	O
,	O
{	O
"kd"	*(char)
,	O
61	int
UNTIC_COMMENT	O
(	O
"down-arrow key"	*(char)
)	O
}	O
,	O
{	O
"ke"	*(char)
,	O
88	int
UNTIC_COMMENT	O
(	O
"leave 'keyboard_transmit' mode"	*(char)
)	O
}	O
,	O
{	O
"kh"	*(char)
,	O
76	int
UNTIC_COMMENT	O
(	O
"home key"	*(char)
)	O
}	O
,	O
{	O
"kl"	*(char)
,	O
79	int
UNTIC_COMMENT	O
(	O
"left-arrow key"	*(char)
)	O
}	O
,	O
{	O
"ko"	*(char)
,	O
396	int
UNTIC_COMMENT	O
(	O
"list of self-mapped keycaps"	*(char)
)	O
}	O
,	O
{	O
"kr"	*(char)
,	O
83	int
UNTIC_COMMENT	O
(	O
"right-arrow key"	*(char)
)	O
}	O
,	O
{	O
"ks"	*(char)
,	O
89	int
UNTIC_COMMENT	O
(	O
"enter 'keyboard_transmit' mode"	*(char)
)	O
}	O
,	O
{	O
"kt"	*(char)
,	O
58	int
UNTIC_COMMENT	O
(	O
"clear-tab key"	*(char)
)	O
}	O
,	O
{	O
"ku"	*(char)
,	O
87	int
UNTIC_COMMENT	O
(	O
"up-arrow key"	*(char)
)	O
}	O
,	O
{	O
"l0"	*(char)
,	O
90	int
UNTIC_COMMENT	O
(	O
"label on function key f0 if not f0"	*(char)
)	O
}	O
,	O
{	O
"l1"	*(char)
,	O
91	int
UNTIC_COMMENT	O
(	O
"label on function key f1 if not f1"	*(char)
)	O
}	O
,	O
{	O
"l2"	*(char)
,	O
93	int
UNTIC_COMMENT	O
(	O
"label on function key f2 if not f2"	*(char)
)	O
}	O
,	O
{	O
"l3"	*(char)
,	O
94	int
UNTIC_COMMENT	O
(	O
"label on function key f3 if not f3"	*(char)
)	O
}	O
,	O
{	O
"l4"	*(char)
,	O
95	int
UNTIC_COMMENT	O
(	O
"label on function key f4 if not f4"	*(char)
)	O
}	O
,	O
{	O
"l5"	*(char)
,	O
96	int
UNTIC_COMMENT	O
(	O
"lable on function key f5 if not f5"	*(char)
)	O
}	O
,	O
{	O
"l6"	*(char)
,	O
97	int
UNTIC_COMMENT	O
(	O
"label on function key f6 if not f6"	*(char)
)	O
}	O
,	O
{	O
"l7"	*(char)
,	O
98	int
UNTIC_COMMENT	O
(	O
"label on function key f7 if not f7"	*(char)
)	O
}	O
,	O
{	O
"l8"	*(char)
,	O
99	int
UNTIC_COMMENT	O
(	O
"label on function key f8 if not f8"	*(char)
)	O
}	O
,	O
{	O
"l9"	*(char)
,	O
100	int
UNTIC_COMMENT	O
(	O
"label on function key f9 if not f9"	*(char)
)	O
}	O
,	O
{	O
"la"	*(char)
,	O
92	int
UNTIC_COMMENT	O
(	O
"label on function key f10 if not f10"	*(char)
)	O
}	O
,	O
{	O
"le"	*(char)
,	O
14	int
UNTIC_COMMENT	O
(	O
"move left one space"	*(char)
)	O
}	O
,	O
{	O
"ll"	*(char)
,	O
18	int
UNTIC_COMMENT	O
(	O
"last line, first column (if no cup)"	*(char)
)	O
}	O
,	O
{	O
"ma"	*(char)
,	O
397	int
UNTIC_COMMENT	O
(	O
"map arrow keys rogue(1) motion keys"	*(char)
)	O
}	O
,	O
{	O
"mb"	*(char)
,	O
26	int
UNTIC_COMMENT	O
(	O
"turn on blinking"	*(char)
)	O
}	O
,	O
{	O
"md"	*(char)
,	O
27	int
UNTIC_COMMENT	O
(	O
"turn on bold (extra bright) mode"	*(char)
)	O
}	O
,	O
{	O
"me"	*(char)
,	O
39	int
UNTIC_COMMENT	O
(	O
"turn off all attributes"	*(char)
)	O
}	O
,	O
{	O
"mh"	*(char)
,	O
30	int
UNTIC_COMMENT	O
(	O
"turn on half-bright mode"	*(char)
)	O
}	O
,	O
{	O
"mk"	*(char)
,	O
32	int
UNTIC_COMMENT	O
(	O
"turn on blank mode (characters invisible)"	*(char)
)	O
}	O
,	O
{	O
"ml"	*(char)
,	O
409	int
UNTIC_COMMENT	O
(	O
"memory lock above"	*(char)
)	O
}	O
,	O
{	O
"mm"	*(char)
,	O
102	int
UNTIC_COMMENT	O
(	O
"turn on meta mode (8th-bit on)"	*(char)
)	O
}	O
,	O
{	O
"mo"	*(char)
,	O
101	int
UNTIC_COMMENT	O
(	O
"turn off meta mode"	*(char)
)	O
}	O
,	O
{	O
"mp"	*(char)
,	O
33	int
UNTIC_COMMENT	O
(	O
"turn on protected mode"	*(char)
)	O
}	O
,	O
{	O
"mr"	*(char)
,	O
34	int
UNTIC_COMMENT	O
(	O
"turn on reverse video mode"	*(char)
)	O
}	O
,	O
{	O
"mu"	*(char)
,	O
410	int
UNTIC_COMMENT	O
(	O
"memory unlock"	*(char)
)	O
}	O
,	O
{	O
"nd"	*(char)
,	O
17	int
UNTIC_COMMENT	O
(	O
"move right one space"	*(char)
)	O
}	O
,	O
{	O
"nl"	*(char)
,	O
394	int
UNTIC_COMMENT	O
(	O
"use to move down"	*(char)
)	O
}	O
,	O
{	O
"nw"	*(char)
,	O
103	int
UNTIC_COMMENT	O
(	O
"newline (behave like cr followed by lf)"	*(char)
)	O
}	O
,	O
{	O
"oc"	*(char)
,	O
298	int
UNTIC_COMMENT	O
(	O
"Set all color pairs to the original ones"	*(char)
)	O
}	O
,	O
{	O
"op"	*(char)
,	O
297	int
UNTIC_COMMENT	O
(	O
"Set default pair to its original value"	*(char)
)	O
}	O
,	O
{	O
"pO"	*(char)
,	O
144	int
UNTIC_COMMENT	O
(	O
"turn on printer for #1 bytes"	*(char)
)	O
}	O
,	O
{	O
"pc"	*(char)
,	O
104	int
UNTIC_COMMENT	O
(	O
"padding char (instead of null)"	*(char)
)	O
}	O
,	O
{	O
"pf"	*(char)
,	O
119	int
UNTIC_COMMENT	O
(	O
"turn off printer"	*(char)
)	O
}	O
,	O
{	O
"pk"	*(char)
,	O
115	int
UNTIC_COMMENT	O
(	O
"program function key #1 to type string #2"	*(char)
)	O
}	O
,	O
{	O
"pl"	*(char)
,	O
116	int
UNTIC_COMMENT	O
(	O
"program function key #1 to execute string #2"	*(char)
)	O
}	O
,	O
{	O
"pn"	*(char)
,	O
147	int
UNTIC_COMMENT	O
(	O
"program label #1 to show string #2"	*(char)
)	O
}	O
,	O
{	O
"po"	*(char)
,	O
120	int
UNTIC_COMMENT	O
(	O
"turn on printer"	*(char)
)	O
}	O
,	O
{	O
"ps"	*(char)
,	O
118	int
UNTIC_COMMENT	O
(	O
"print contents of screen"	*(char)
)	O
}	O
,	O
{	O
"px"	*(char)
,	O
117	int
UNTIC_COMMENT	O
(	O
"program function key #1 to transmit string #2"	*(char)
)	O
}	O
,	O
{	O
"r1"	*(char)
,	O
122	int
UNTIC_COMMENT	O
(	O
"reset string"	*(char)
)	O
}	O
,	O
{	O
"r2"	*(char)
,	O
123	int
UNTIC_COMMENT	O
(	O
"reset string"	*(char)
)	O
}	O
,	O
{	O
"r3"	*(char)
,	O
124	int
UNTIC_COMMENT	O
(	O
"reset string"	*(char)
)	O
}	O
,	O
{	O
"rP"	*(char)
,	O
145	int
UNTIC_COMMENT	O
(	O
"like ip but when in insert mode"	*(char)
)	O
}	O
,	O
{	O
"rc"	*(char)
,	O
126	int
UNTIC_COMMENT	O
(	O
"restore cursor to last position of sc"	*(char)
)	O
}	O
,	O
{	O
"rf"	*(char)
,	O
125	int
UNTIC_COMMENT	O
(	O
"name of reset file"	*(char)
)	O
}	O
,	O
{	O
"rp"	*(char)
,	O
121	int
UNTIC_COMMENT	O
(	O
"repeat char #1 #2 times"	*(char)
)	O
}	O
,	O
{	O
"rs"	*(char)
,	O
393	int
UNTIC_COMMENT	O
(	O
"terminal reset string"	*(char)
)	O
}	O
,	O
{	O
"s0"	*(char)
,	O
364	int
UNTIC_COMMENT	O
(	O
"Shift to code set 0 (EUC set 0, ASCII)"	*(char)
)	O
}	O
,	O
{	O
"s1"	*(char)
,	O
365	int
UNTIC_COMMENT	O
(	O
"Shift to code set 1"	*(char)
)	O
}	O
,	O
{	O
"s2"	*(char)
,	O
366	int
UNTIC_COMMENT	O
(	O
"Shift to code set 2"	*(char)
)	O
}	O
,	O
{	O
"s3"	*(char)
,	O
367	int
UNTIC_COMMENT	O
(	O
"Shift to code set 3"	*(char)
)	O
}	O
,	O
{	O
"sa"	*(char)
,	O
131	int
UNTIC_COMMENT	O
(	O
"define video attributes #1-#9 (PG9)"	*(char)
)	O
}	O
,	O
{	O
"sc"	*(char)
,	O
128	int
UNTIC_COMMENT	O
(	O
"save current cursor position"	*(char)
)	O
}	O
,	O
{	O
"se"	*(char)
,	O
43	int
UNTIC_COMMENT	O
(	O
"exit standout mode"	*(char)
)	O
}	O
,	O
{	O
"sf"	*(char)
,	O
129	int
UNTIC_COMMENT	O
(	O
"scroll text up"	*(char)
)	O
}	O
,	O
{	O
"so"	*(char)
,	O
35	int
UNTIC_COMMENT	O
(	O
"begin standout mode"	*(char)
)	O
}	O
,	O
{	O
"sp"	*(char)
,	O
301	int
UNTIC_COMMENT	O
(	O
"Set current color pair to #1"	*(char)
)	O
}	O
,	O
{	O
"sr"	*(char)
,	O
130	int
UNTIC_COMMENT	O
(	O
"scroll text down"	*(char)
)	O
}	O
,	O
{	O
"st"	*(char)
,	O
132	int
UNTIC_COMMENT	O
(	O
"set a tab in every row, current columns"	*(char)
)	O
}	O
,	O
{	O
"ta"	*(char)
,	O
134	int
UNTIC_COMMENT	O
(	O
"tab to next 8-space hardware tab stop"	*(char)
)	O
}	O
,	O
{	O
"te"	*(char)
,	O
40	int
UNTIC_COMMENT	O
(	O
"strings to end programs using cup"	*(char)
)	O
}	O
,	O
{	O
"ti"	*(char)
,	O
28	int
UNTIC_COMMENT	O
(	O
"string to start programs using cup"	*(char)
)	O
}	O
,	O
{	O
"ts"	*(char)
,	O
135	int
UNTIC_COMMENT	O
(	O
"move to status line"	*(char)
)	O
}	O
,	O
{	O
"u0"	*(char)
,	O
287	int
UNTIC_COMMENT	O
(	O
"User string #0"	*(char)
)	O
}	O
,	O
{	O
"u1"	*(char)
,	O
288	int
UNTIC_COMMENT	O
(	O
"User string #1"	*(char)
)	O
}	O
,	O
{	O
"u2"	*(char)
,	O
289	int
UNTIC_COMMENT	O
(	O
"User string #2"	*(char)
)	O
}	O
,	O
{	O
"u3"	*(char)
,	O
290	int
UNTIC_COMMENT	O
(	O
"User string #3"	*(char)
)	O
}	O
,	O
{	O
"u4"	*(char)
,	O
291	int
UNTIC_COMMENT	O
(	O
"User string #4"	*(char)
)	O
}	O
,	O
{	O
"u5"	*(char)
,	O
292	int
UNTIC_COMMENT	O
(	O
"User string #5"	*(char)
)	O
}	O
,	O
{	O
"u6"	*(char)
,	O
293	int
UNTIC_COMMENT	O
(	O
"User string #6"	*(char)
)	O
}	O
,	O
{	O
"u7"	*(char)
,	O
294	int
UNTIC_COMMENT	O
(	O
"User string #7"	*(char)
)	O
}	O
,	O
{	O
"u8"	*(char)
,	O
295	int
UNTIC_COMMENT	O
(	O
"User string #8"	*(char)
)	O
}	O
,	O
{	O
"u9"	*(char)
,	O
296	int
UNTIC_COMMENT	O
(	O
"User string #9"	*(char)
)	O
}	O
,	O
{	O
"uc"	*(char)
,	O
136	int
UNTIC_COMMENT	O
(	O
"underline char and move past it"	*(char)
)	O
}	O
,	O
{	O
"ue"	*(char)
,	O
44	int
UNTIC_COMMENT	O
(	O
"exit underline mode"	*(char)
)	O
}	O
,	O
{	O
"up"	*(char)
,	O
19	int
UNTIC_COMMENT	O
(	O
"up one line"	*(char)
)	O
}	O
,	O
{	O
"us"	*(char)
,	O
36	int
UNTIC_COMMENT	O
(	O
"begin underline mode"	*(char)
)	O
}	O
,	O
{	O
"vb"	*(char)
,	O
45	int
UNTIC_COMMENT	O
(	O
"visible bell (may not move cursor)"	*(char)
)	O
}	O
,	O
{	O
"ve"	*(char)
,	O
16	int
UNTIC_COMMENT	O
(	O
"make cursor appear normal (undo civis/cvvis)"	*(char)
)	O
}	O
,	O
{	O
"vi"	*(char)
,	O
13	int
UNTIC_COMMENT	O
(	O
"make cursor invisible"	*(char)
)	O
}	O
,	O
{	O
"vs"	*(char)
,	O
20	int
UNTIC_COMMENT	O
(	O
"make cursor very visible"	*(char)
)	O
}	O
,	O
{	O
"wi"	*(char)
,	O
133	int
UNTIC_COMMENT	O
(	O
"current window is lines #1-#2 cols #3-#4"	*(char)
)	O
}	O
,	O
{	O
"xl"	*(char)
,	O
361	int
UNTIC_COMMENT	O
(	O
"Program function key #1 to type string #2 and show string #3"	*(char)
)	O
}	O
,	O
{	O
""	*(char)
,	O
-	O
1	int
UNTIC_COMMENT	O
(	O
NULL	O
)	O
}	O
}	O
;	O
static	O
int	O
compute_cap_offset	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))),*(struct(array(char),int)),int)->(int)
(	O
char	O
*	O
cap	*(char)
,	O
SLterminfo_Type	struct
*	O
t	long
,	O
Tgetstr_Map_Type	struct(array(char),int)
*	O
map	*(struct)
,	O
unsigned	O
int	O
max_ofs	int
)	O
{	O
char	O
cha	char
,	O
chb	char
;	O
(	O
void	O
)	O
t	long
;	O
cha	char
=	O
*	O
cap	*(char)
++	O
;	O
chb	char
=	O
*	O
cap	*(char)
;	O
while	O
(	O
*	O
map	*(struct)
->	O
name	*(char)
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
cha	char
==	O
*	O
map	*(struct)
->	O
name	*(char)
)	O
&&	O
(	O
chb	char
==	O
*	O
(	O
map	*(struct)
->	O
name	*(char)
+	O
1	int
)	O
)	O
)	O
{	O
if	O
(	O
map	*(struct)
->	O
offset	int
>=	O
(	O
int	O
)	O
max_ofs	int
)	O
return	O
-	O
1	int
;	O
return	O
map	*(struct)
->	O
offset	int
;	O
}	O
map	*(struct)
++	O
;	O
}	O
return	O
-	O
1	int
;	O
}	O
char	O
*	O
_pSLtt_tigetstr	(*(struct),*(char))->(*(char))
(	O
SLterminfo_Type	struct
*	O
t	long
,	O
char	O
*	O
cap	*(char)
)	O
{	O
int	O
offset	int
;	O
if	O
(	O
t	long
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
t	long
->	O
flags	int
==	O
SLTERMCAP	int
)	O
return	O
tcap_getstr	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(*(char))
(	O
cap	*(char)
,	O
t	long
)	O
;	O
offset	int
=	O
compute_cap_offset	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))),*(struct(array(char),int)),int)->(int)
(	O
cap	*(char)
,	O
t	long
,	O
Tgetstr_Map	array(struct(array(char),int))
,	O
t	long
->	O
num_string_offsets	int
)	O
;	O
if	O
(	O
offset	int
<	O
0	int
)	O
return	O
NULL	O
;	O
offset	int
=	O
make_integer	(*(char))->(int)
(	O
t	long
->	O
string_offsets	*(char)
+	O
2	int
*	O
offset	int
)	O
;	O
if	O
(	O
offset	int
<	O
0	int
)	O
return	O
NULL	O
;	O
return	O
t	long
->	O
string_table	*(char)
+	O
offset	int
;	O
}	O
static	O
Tgetstr_Map_Type	struct(array(char),int)
Tgetnum_Map	array(struct(array(char),int))
[	O
]	O
=	O
{	O
{	O
"BT"	*(char)
,	O
30	int
UNTIC_COMMENT	O
(	O
"number of buttons on mouse"	*(char)
)	O
}	O
,	O
{	O
"Co"	*(char)
,	O
13	int
UNTIC_COMMENT	O
(	O
"maximum numbers of colors on screen"	*(char)
)	O
}	O
,	O
{	O
"MW"	*(char)
,	O
12	int
UNTIC_COMMENT	O
(	O
"maxumum number of defineable windows"	*(char)
)	O
}	O
,	O
{	O
"NC"	*(char)
,	O
15	int
UNTIC_COMMENT	O
(	O
"video attributes that can't be used with colors"	*(char)
)	O
}	O
,	O
{	O
"Nl"	*(char)
,	O
8	int
UNTIC_COMMENT	O
(	O
"number of labels on screen"	*(char)
)	O
}	O
,	O
{	O
"Ya"	*(char)
,	O
16	int
UNTIC_COMMENT	O
(	O
"numbers of bytes buffered before printing"	*(char)
)	O
}	O
,	O
{	O
"Yb"	*(char)
,	O
17	int
UNTIC_COMMENT	O
(	O
"spacing of pins vertically in pins per inch"	*(char)
)	O
}	O
,	O
{	O
"Yc"	*(char)
,	O
18	int
UNTIC_COMMENT	O
(	O
"spacing of dots horizontally in dots per inch"	*(char)
)	O
}	O
,	O
{	O
"Yd"	*(char)
,	O
19	int
UNTIC_COMMENT	O
(	O
"maximum value in micro_..._address"	*(char)
)	O
}	O
,	O
{	O
"Ye"	*(char)
,	O
20	int
UNTIC_COMMENT	O
(	O
"maximum value in parm_..._micro"	*(char)
)	O
}	O
,	O
{	O
"Yf"	*(char)
,	O
21	int
UNTIC_COMMENT	O
(	O
"character size when in micro mode"	*(char)
)	O
}	O
,	O
{	O
"Yg"	*(char)
,	O
22	int
UNTIC_COMMENT	O
(	O
"line size when in micro mode"	*(char)
)	O
}	O
,	O
{	O
"Yh"	*(char)
,	O
23	int
UNTIC_COMMENT	O
(	O
"numbers of pins in print-head"	*(char)
)	O
}	O
,	O
{	O
"Yi"	*(char)
,	O
24	int
UNTIC_COMMENT	O
(	O
"horizontal resolution in units per line"	*(char)
)	O
}	O
,	O
{	O
"Yj"	*(char)
,	O
25	int
UNTIC_COMMENT	O
(	O
"vertical resolution in units per line"	*(char)
)	O
}	O
,	O
{	O
"Yk"	*(char)
,	O
26	int
UNTIC_COMMENT	O
(	O
"horizontal resolution in units per inch"	*(char)
)	O
}	O
,	O
{	O
"Yl"	*(char)
,	O
27	int
UNTIC_COMMENT	O
(	O
"vertical resolution in units per inch"	*(char)
)	O
}	O
,	O
{	O
"Ym"	*(char)
,	O
28	int
UNTIC_COMMENT	O
(	O
"print rate in chars per second"	*(char)
)	O
}	O
,	O
{	O
"Yn"	*(char)
,	O
29	int
UNTIC_COMMENT	O
(	O
"character step size when in double wide mode"	*(char)
)	O
}	O
,	O
{	O
"Yo"	*(char)
,	O
31	int
UNTIC_COMMENT	O
(	O
"number of passed for each bit-image row"	*(char)
)	O
}	O
,	O
{	O
"Yp"	*(char)
,	O
32	int
UNTIC_COMMENT	O
(	O
"type of bit-image device"	*(char)
)	O
}	O
,	O
{	O
"co"	*(char)
,	O
0	int
UNTIC_COMMENT	O
(	O
"number of columns in aline"	*(char)
)	O
}	O
,	O
{	O
"dB"	*(char)
,	O
36	int
UNTIC_COMMENT	O
(	O
"padding required for ^H"	*(char)
)	O
}	O
,	O
{	O
"dC"	*(char)
,	O
34	int
UNTIC_COMMENT	O
(	O
"pad needed for CR"	*(char)
)	O
}	O
,	O
{	O
"dN"	*(char)
,	O
35	int
UNTIC_COMMENT	O
(	O
"pad needed for LF"	*(char)
)	O
}	O
,	O
{	O
"dT"	*(char)
,	O
37	int
UNTIC_COMMENT	O
(	O
"padding required for ^I"	*(char)
)	O
}	O
,	O
{	O
"it"	*(char)
,	O
1	int
UNTIC_COMMENT	O
(	O
"tabs initially every # spaces"	*(char)
)	O
}	O
,	O
{	O
"kn"	*(char)
,	O
38	int
UNTIC_COMMENT	O
(	O
"count of function keys"	*(char)
)	O
}	O
,	O
{	O
"lh"	*(char)
,	O
9	int
UNTIC_COMMENT	O
(	O
"rows in each label"	*(char)
)	O
}	O
,	O
{	O
"li"	*(char)
,	O
2	int
UNTIC_COMMENT	O
(	O
"number of lines on screen or page"	*(char)
)	O
}	O
,	O
{	O
"lm"	*(char)
,	O
3	int
UNTIC_COMMENT	O
(	O
"lines of memory if > line. 0 => varies"	*(char)
)	O
}	O
,	O
{	O
"lw"	*(char)
,	O
10	int
UNTIC_COMMENT	O
(	O
"columns in each label"	*(char)
)	O
}	O
,	O
{	O
"ma"	*(char)
,	O
11	int
UNTIC_COMMENT	O
(	O
"maximum combined attributes terminal can handle"	*(char)
)	O
}	O
,	O
{	O
"pa"	*(char)
,	O
14	int
UNTIC_COMMENT	O
(	O
"maximum number of color-pairs on the screen"	*(char)
)	O
}	O
,	O
{	O
"pb"	*(char)
,	O
5	int
UNTIC_COMMENT	O
(	O
"lowest baud rate where padding needed"	*(char)
)	O
}	O
,	O
{	O
"sg"	*(char)
,	O
4	int
UNTIC_COMMENT	O
(	O
"number of blank chars left by smso or rmso"	*(char)
)	O
}	O
,	O
{	O
"ug"	*(char)
,	O
33	int
UNTIC_COMMENT	O
(	O
"number of blanks left by ul"	*(char)
)	O
}	O
,	O
{	O
"vt"	*(char)
,	O
6	int
UNTIC_COMMENT	O
(	O
"virtual terminal number (CB/unix)"	*(char)
)	O
}	O
,	O
{	O
"ws"	*(char)
,	O
7	int
UNTIC_COMMENT	O
(	O
"columns in status line"	*(char)
)	O
}	O
,	O
{	O
""	*(char)
,	O
-	O
1	int
UNTIC_COMMENT	O
(	O
NULL	O
)	O
}	O
}	O
;	O
int	O
_pSLtt_tigetnum	(*(struct),*(char))->(int)
(	O
SLterminfo_Type	struct
*	O
t	long
,	O
char	O
*	O
cap	*(char)
)	O
{	O
int	O
offset	int
;	O
if	O
(	O
t	long
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
t	long
->	O
flags	int
==	O
SLTERMCAP	int
)	O
return	O
tcap_getnum	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(int)
(	O
cap	*(char)
,	O
t	long
)	O
;	O
offset	int
=	O
compute_cap_offset	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))),*(struct(array(char),int)),int)->(int)
(	O
cap	*(char)
,	O
t	long
,	O
Tgetnum_Map	array(struct(array(char),int))
,	O
t	long
->	O
num_numbers	int
)	O
;	O
if	O
(	O
offset	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
make_integer	(*(char))->(int)
(	O
t	long
->	O
numbers	*(char)
+	O
2	int
*	O
offset	int
)	O
;	O
}	O
static	O
Tgetstr_Map_Type	struct(array(char),int)
Tgetflag_Map	array(struct(array(char),int))
[	O
]	O
=	O
{	O
{	O
"5i"	*(char)
,	O
22	int
UNTIC_COMMENT	O
(	O
"printer won't echo on screen"	*(char)
)	O
}	O
,	O
{	O
"HC"	*(char)
,	O
23	int
UNTIC_COMMENT	O
(	O
"cursor is hard to see"	*(char)
)	O
}	O
,	O
{	O
"MT"	*(char)
,	O
40	int
UNTIC_COMMENT	O
(	O
"has meta key"	*(char)
)	O
}	O
,	O
{	O
"ND"	*(char)
,	O
26	int
UNTIC_COMMENT	O
(	O
"scrolling region is non-destructive"	*(char)
)	O
}	O
,	O
{	O
"NL"	*(char)
,	O
41	int
UNTIC_COMMENT	O
(	O
"move down with \n"	*(char)
)	O
}	O
,	O
{	O
"NP"	*(char)
,	O
25	int
UNTIC_COMMENT	O
(	O
"pad character does not exist"	*(char)
)	O
}	O
,	O
{	O
"NR"	*(char)
,	O
24	int
UNTIC_COMMENT	O
(	O
"smcup does not reverse rmcup"	*(char)
)	O
}	O
,	O
{	O
"YA"	*(char)
,	O
30	int
UNTIC_COMMENT	O
(	O
"only positive motion for hpa/mhpa caps"	*(char)
)	O
}	O
,	O
{	O
"YB"	*(char)
,	O
31	int
UNTIC_COMMENT	O
(	O
"using cr turns off micro mode"	*(char)
)	O
}	O
,	O
{	O
"YC"	*(char)
,	O
32	int
UNTIC_COMMENT	O
(	O
"printer needs operator to change character set"	*(char)
)	O
}	O
,	O
{	O
"YD"	*(char)
,	O
33	int
UNTIC_COMMENT	O
(	O
"only positive motion for vpa/mvpa caps"	*(char)
)	O
}	O
,	O
{	O
"YE"	*(char)
,	O
34	int
UNTIC_COMMENT	O
(	O
"printing in last column causes cr"	*(char)
)	O
}	O
,	O
{	O
"YF"	*(char)
,	O
35	int
UNTIC_COMMENT	O
(	O
"changing character pitch changes resolution"	*(char)
)	O
}	O
,	O
{	O
"YG"	*(char)
,	O
36	int
UNTIC_COMMENT	O
(	O
"changing line pitch changes resolution"	*(char)
)	O
}	O
,	O
{	O
"am"	*(char)
,	O
1	int
UNTIC_COMMENT	O
(	O
"terminal has automatic margins"	*(char)
)	O
}	O
,	O
{	O
"bs"	*(char)
,	O
37	int
UNTIC_COMMENT	O
(	O
"uses ^H to move left"	*(char)
)	O
}	O
,	O
{	O
"bw"	*(char)
,	O
0	int
UNTIC_COMMENT	O
(	O
"cub1 wraps from column 0 to last column"	*(char)
)	O
}	O
,	O
{	O
"cc"	*(char)
,	O
27	int
UNTIC_COMMENT	O
(	O
"terminal can re-define existing colors"	*(char)
)	O
}	O
,	O
{	O
"da"	*(char)
,	O
11	int
UNTIC_COMMENT	O
(	O
"display may be retained above the screen"	*(char)
)	O
}	O
,	O
{	O
"db"	*(char)
,	O
12	int
UNTIC_COMMENT	O
(	O
"display may be retained below the screen"	*(char)
)	O
}	O
,	O
{	O
"eo"	*(char)
,	O
5	int
UNTIC_COMMENT	O
(	O
"can erase overstrikes with a blank"	*(char)
)	O
}	O
,	O
{	O
"es"	*(char)
,	O
16	int
UNTIC_COMMENT	O
(	O
"escape can be used on the status line"	*(char)
)	O
}	O
,	O
{	O
"gn"	*(char)
,	O
6	int
UNTIC_COMMENT	O
(	O
"generic line type"	*(char)
)	O
}	O
,	O
{	O
"hc"	*(char)
,	O
7	int
UNTIC_COMMENT	O
(	O
"hardcopy terminal"	*(char)
)	O
}	O
,	O
{	O
"hl"	*(char)
,	O
29	int
UNTIC_COMMENT	O
(	O
"terminal uses only HLS color notation (tektronix)"	*(char)
)	O
}	O
,	O
{	O
"hs"	*(char)
,	O
9	int
UNTIC_COMMENT	O
(	O
"has extra status line"	*(char)
)	O
}	O
,	O
{	O
"hz"	*(char)
,	O
18	int
UNTIC_COMMENT	O
(	O
"can't print ~'s (hazeltine)"	*(char)
)	O
}	O
,	O
{	O
"in"	*(char)
,	O
10	int
UNTIC_COMMENT	O
(	O
"insert mode distinguishes nulls"	*(char)
)	O
}	O
,	O
{	O
"km"	*(char)
,	O
8	int
UNTIC_COMMENT	O
(	O
"Has a meta key, sets msb high"	*(char)
)	O
}	O
,	O
{	O
"mi"	*(char)
,	O
13	int
UNTIC_COMMENT	O
(	O
"safe to move while in insert mode"	*(char)
)	O
}	O
,	O
{	O
"ms"	*(char)
,	O
14	int
UNTIC_COMMENT	O
(	O
"safe to move while in standout mode"	*(char)
)	O
}	O
,	O
{	O
"nc"	*(char)
,	O
39	int
UNTIC_COMMENT	O
(	O
"no way to go to start of line"	*(char)
)	O
}	O
,	O
{	O
"ns"	*(char)
,	O
38	int
UNTIC_COMMENT	O
(	O
"crt cannot scroll"	*(char)
)	O
}	O
,	O
{	O
"nx"	*(char)
,	O
21	int
UNTIC_COMMENT	O
(	O
"padding won't work, xon/xoff required"	*(char)
)	O
}	O
,	O
{	O
"os"	*(char)
,	O
15	int
UNTIC_COMMENT	O
(	O
"terminal can overstrike"	*(char)
)	O
}	O
,	O
{	O
"pt"	*(char)
,	O
42	int
UNTIC_COMMENT	O
(	O
"has 8-char tabs invoked with ^I"	*(char)
)	O
}	O
,	O
{	O
"ul"	*(char)
,	O
19	int
UNTIC_COMMENT	O
(	O
"underline character overstrikes"	*(char)
)	O
}	O
,	O
{	O
"ut"	*(char)
,	O
28	int
UNTIC_COMMENT	O
(	O
"screen erased with background color"	*(char)
)	O
}	O
,	O
{	O
"xb"	*(char)
,	O
2	int
UNTIC_COMMENT	O
(	O
"beehive (f1=escape, f2=ctrl C)"	*(char)
)	O
}	O
,	O
{	O
"xn"	*(char)
,	O
4	int
UNTIC_COMMENT	O
(	O
"newline ignored after 80 cols (concept)"	*(char)
)	O
}	O
,	O
{	O
"xo"	*(char)
,	O
20	int
UNTIC_COMMENT	O
(	O
"terminal uses xon/xoff handshaking"	*(char)
)	O
}	O
,	O
{	O
"xr"	*(char)
,	O
43	int
UNTIC_COMMENT	O
(	O
"return clears the line"	*(char)
)	O
}	O
,	O
{	O
"xs"	*(char)
,	O
3	int
UNTIC_COMMENT	O
(	O
"standout not erased by overwriting (hp)"	*(char)
)	O
}	O
,	O
{	O
"xt"	*(char)
,	O
17	int
UNTIC_COMMENT	O
(	O
"tabs destructive, magic so char (t1061)"	*(char)
)	O
}	O
,	O
{	O
""	*(char)
,	O
-	O
1	int
UNTIC_COMMENT	O
(	O
NULL	O
)	O
}	O
}	O
;	O
int	O
_pSLtt_tigetflag	(*(struct),*(char))->(int)
(	O
SLterminfo_Type	struct
*	O
t	long
,	O
char	O
*	O
cap	*(char)
)	O
{	O
int	O
offset	int
;	O
if	O
(	O
t	long
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
t	long
->	O
flags	int
==	O
SLTERMCAP	int
)	O
return	O
tcap_getflag	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(int)
(	O
cap	*(char)
,	O
t	long
)	O
;	O
offset	int
=	O
compute_cap_offset	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))),*(struct(array(char),int)),int)->(int)
(	O
cap	*(char)
,	O
t	long
,	O
Tgetflag_Map	array(struct(array(char),int))
,	O
t	long
->	O
boolean_section_size	int
)	O
;	O
if	O
(	O
offset	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
(	O
int	O
)	O
*	O
(	O
t	long
->	O
boolean_flags	*(char)
+	O
offset	int
)	O
;	O
}	O
static	O
int	O
tcap_getflag	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(int)
(	O
char	O
*	O
cap	*(char)
,	O
SLterminfo_Type	struct
*	O
t	long
)	O
{	O
char	O
a	*(char)
,	O
b	*(char)
;	O
char	O
*	O
f	float
=	O
(	O
char	O
*	O
)	O
t	long
->	O
boolean_flags	*(char)
;	O
char	O
*	O
fmax	*(char)
;	O
if	O
(	O
f	float
==	O
NULL	O
)	O
return	O
0	int
;	O
fmax	*(char)
=	O
f	float
+	O
t	long
->	O
boolean_section_size	int
;	O
a	*(char)
=	O
*	O
cap	*(char)
;	O
b	*(char)
=	O
*	O
(	O
cap	*(char)
+	O
1	int
)	O
;	O
while	O
(	O
f	float
<	O
fmax	*(char)
)	O
{	O
if	O
(	O
(	O
a	*(char)
==	O
f	float
[	O
0	int
]	O
)	O
&&	O
(	O
b	*(char)
==	O
f	float
[	O
1	int
]	O
)	O
)	O
return	O
1	int
;	O
f	float
+=	O
2	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
tcap_get_cap	(*(char),*(char),int)->(*(char))
(	O
unsigned	O
char	O
*	O
cap	*(char)
,	O
unsigned	O
char	O
*	O
caps	*(char)
,	O
unsigned	O
int	O
len	int
)	O
{	O
unsigned	O
char	O
c0	char
,	O
c1	char
;	O
unsigned	O
char	O
*	O
caps_max	*(char)
;	O
c0	char
=	O
cap	*(char)
[	O
0	int
]	O
;	O
c1	char
=	O
cap	*(char)
[	O
1	int
]	O
;	O
if	O
(	O
caps	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
caps_max	*(char)
=	O
caps	*(char)
+	O
len	int
;	O
while	O
(	O
caps	*(char)
<	O
caps_max	*(char)
)	O
{	O
if	O
(	O
(	O
c0	char
==	O
caps	*(char)
[	O
0	int
]	O
)	O
&&	O
(	O
c1	char
==	O
caps	*(char)
[	O
1	int
]	O
)	O
)	O
{	O
return	O
(	O
char	O
*	O
)	O
caps	*(char)
+	O
3	int
;	O
}	O
caps	*(char)
+=	O
(	O
int	O
)	O
caps	*(char)
[	O
2	int
]	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
tcap_getnum	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(int)
(	O
char	O
*	O
cap	*(char)
,	O
SLterminfo_Type	struct
*	O
t	long
)	O
{	O
cap	*(char)
=	O
tcap_get_cap	(*(char),*(char),int)->(*(char))
(	O
(	O
unsigned	O
char	O
*	O
)	O
cap	*(char)
,	O
t	long
->	O
numbers	*(char)
,	O
t	long
->	O
num_numbers	int
)	O
;	O
if	O
(	O
cap	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
return	O
atoi	(*(char))->(int)
(	O
cap	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
tcap_getstr	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(*(char))
(	O
char	O
*	O
cap	*(char)
,	O
SLterminfo_Type	struct
*	O
t	long
)	O
{	O
return	O
tcap_get_cap	(*(char),*(char),int)->(*(char))
(	O
(	O
unsigned	O
char	O
*	O
)	O
cap	*(char)
,	O
(	O
unsigned	O
char	O
*	O
)	O
t	long
->	O
string_table	*(char)
,	O
t	long
->	O
string_table_size	int
)	O
;	O
}	O
static	O
int	O
tcap_extract_field	(*(char))->(int)
(	O
unsigned	O
char	O
*	O
t0	*(char)
)	O
{	O
register	O
unsigned	O
char	O
ch	int
,	O
*	O
t	long
=	O
t0	*(char)
;	O
while	O
(	O
(	O
(	O
ch	int
=	O
*	O
t	long
)	O
!=	O
0	int
)	O
&&	O
(	O
ch	int
!=	O
':'	O
)	O
)	O
t	long
++	O
;	O
if	O
(	O
ch	int
==	O
':'	O
)	O
return	O
(	O
int	O
)	O
(	O
t	long
-	O
t0	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
int	O
SLtt_Try_Termcap	int
=	O
1	int
;	O
static	O
int	O
tcap_getent	(*(char),*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char))))->(int)
(	O
char	O
*	O
term	*(char)
,	O
SLterminfo_Type	struct
*	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
)	O
{	O
unsigned	O
char	O
*	O
termcap	*(char)
,	O
ch	int
;	O
unsigned	O
char	O
*	O
buf	*(char)
,	O
*	O
b	*(char)
;	O
unsigned	O
char	O
*	O
t	long
;	O
int	O
len	int
;	O
if	O
(	O
SLtt_Try_Termcap	int
==	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
term	*(char)
,	O
"xterm"	*(char)
,	O
5	int
)	O
)	O
return	O
-	O
1	int
;	O
termcap	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
getenv	(*(char))->(*(char))
(	O
"TERMCAP"	*(char)
)	O
;	O
if	O
(	O
(	O
termcap	*(char)
==	O
NULL	O
)	O
||	O
(	O
*	O
termcap	*(char)
==	O
'/'	O
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
termcap	*(char)
[	O
0	int
]	O
==	O
':'	O
)	O
&&	O
(	O
termcap	*(char)
[	O
1	int
]	O
==	O
0	int
)	O
)	O
return	O
-	O
1	int
;	O
t	long
=	O
termcap	*(char)
;	O
while	O
(	O
(	O
len	int
=	O
tcap_extract_field	(*(char))->(int)
(	O
t	long
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
len	int
>	O
3	int
)	O
&&	O
(	O
t	long
[	O
0	int
]	O
==	O
't'	O
)	O
&&	O
(	O
t	long
[	O
1	int
]	O
==	O
'c'	O
)	O
&&	O
(	O
t	long
[	O
2	int
]	O
==	O
'='	O
)	O
)	O
return	O
-	O
1	int
;	O
t	long
+=	O
(	O
len	int
+	O
1	int
)	O
;	O
}	O
len	int
=	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
termcap	*(char)
)	O
+	O
256	int
;	O
if	O
(	O
NULL	O
==	O
(	O
buf	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
SLmalloc	O
(	O
(	O
unsigned	O
int	O
)	O
len	int
)	O
)	O
)	O
return	O
-	O
1	int
;	O
b	*(char)
=	O
buf	*(char)
;	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
terminal_names	*(char)
=	O
(	O
char	O
*	O
)	O
b	*(char)
;	O
t	long
=	O
termcap	*(char)
;	O
len	int
=	O
tcap_extract_field	(*(char))->(int)
(	O
t	long
)	O
;	O
if	O
(	O
len	int
<	O
0	int
)	O
{	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
buf	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
(	O
char	O
*	O
)	O
b	*(char)
,	O
(	O
char	O
*	O
)	O
t	long
,	O
(	O
unsigned	O
int	O
)	O
len	int
)	O
;	O
b	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
b	*(char)
+=	O
len	int
+	O
1	int
;	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
name_section_size	int
=	O
len	int
;	O
termcap	*(char)
=	O
t	long
+	O
(	O
len	int
+	O
1	int
)	O
;	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
string_table	*(char)
=	O
(	O
char	O
*	O
)	O
b	*(char)
;	O
t	long
=	O
termcap	*(char)
;	O
while	O
(	O
-	O
1	int
!=	O
(	O
len	int
=	O
tcap_extract_field	(*(char))->(int)
(	O
t	long
)	O
)	O
)	O
{	O
unsigned	O
char	O
*	O
b1	*(char)
;	O
unsigned	O
char	O
*	O
tmax	*(char)
;	O
if	O
(	O
(	O
len	int
<	O
4	int
)	O
||	O
(	O
t	long
[	O
2	int
]	O
!=	O
'='	O
)	O
||	O
(	O
*	O
t	long
==	O
'.'	O
)	O
)	O
{	O
t	long
+=	O
len	int
+	O
1	int
;	O
continue	O
;	O
}	O
tmax	*(char)
=	O
t	long
+	O
len	int
;	O
b1	*(char)
=	O
b	*(char)
;	O
while	O
(	O
t	long
<	O
tmax	*(char)
)	O
{	O
ch	int
=	O
*	O
t	long
++	O
;	O
if	O
(	O
(	O
ch	int
==	O
'\\'	O
)	O
&&	O
(	O
t	long
<	O
tmax	*(char)
)	O
)	O
{	O
SLwchar_Type	int
wch	int
;	O
t	long
=	O
(	O
unsigned	O
char	O
*	O
)	O
_pSLexpand_escaped_char	(*(char),*(int),*(int))->(*(char))
(	O
(	O
char	O
*	O
)	O
t	long
,	O
&	O
wch	int
,	O
NULL	O
)	O
;	O
if	O
(	O
t	long
==	O
NULL	O
)	O
{	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
buf	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
ch	int
=	O
(	O
char	O
)	O
wch	int
;	O
}	O
else	O
if	O
(	O
(	O
ch	int
==	O
'^'	O
)	O
&&	O
(	O
t	long
<	O
tmax	*(char)
)	O
)	O
{	O
ch	int
=	O
*	O
t	long
++	O
;	O
if	O
(	O
ch	int
==	O
'?'	O
)	O
ch	int
=	O
127	int
;	O
else	O
ch	int
=	O
(	O
ch	int
|	O
0x20	int
)	O
-	O
(	O
'a'	O
-	O
1	int
)	O
;	O
}	O
*	O
b	*(char)
++	O
=	O
ch	int
;	O
}	O
*	O
b	*(char)
++	O
=	O
0	int
;	O
len	int
=	O
(	O
int	O
)	O
(	O
b	*(char)
-	O
b1	*(char)
)	O
;	O
b1	*(char)
[	O
2	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
len	int
;	O
t	long
++	O
;	O
}	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
string_table_size	int
=	O
(	O
int	O
)	O
(	O
b	*(char)
-	O
(	O
unsigned	O
char	O
*	O
)	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
string_table	*(char)
)	O
;	O
t	long
=	O
termcap	*(char)
;	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
numbers	*(char)
=	O
b	*(char)
;	O
while	O
(	O
-	O
1	int
!=	O
(	O
len	int
=	O
tcap_extract_field	(*(char))->(int)
(	O
t	long
)	O
)	O
)	O
{	O
unsigned	O
char	O
*	O
b1	*(char)
;	O
unsigned	O
char	O
*	O
tmax	*(char)
;	O
if	O
(	O
(	O
len	int
<	O
4	int
)	O
||	O
(	O
t	long
[	O
2	int
]	O
!=	O
'#'	O
)	O
||	O
(	O
*	O
t	long
==	O
'.'	O
)	O
)	O
{	O
t	long
+=	O
len	int
+	O
1	int
;	O
continue	O
;	O
}	O
tmax	*(char)
=	O
t	long
+	O
len	int
;	O
b1	*(char)
=	O
b	*(char)
;	O
while	O
(	O
t	long
<	O
tmax	*(char)
)	O
{	O
*	O
b	*(char)
++	O
=	O
*	O
t	long
++	O
;	O
}	O
*	O
b	*(char)
++	O
=	O
0	int
;	O
len	int
=	O
(	O
int	O
)	O
(	O
b	*(char)
-	O
b1	*(char)
)	O
;	O
b1	*(char)
[	O
2	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
len	int
;	O
t	long
++	O
;	O
}	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
num_numbers	int
=	O
(	O
int	O
)	O
(	O
b	*(char)
-	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
numbers	*(char)
)	O
;	O
t	long
=	O
termcap	*(char)
;	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
boolean_flags	*(char)
=	O
b	*(char)
;	O
while	O
(	O
-	O
1	int
!=	O
(	O
len	int
=	O
tcap_extract_field	(*(char))->(int)
(	O
t	long
)	O
)	O
)	O
{	O
if	O
(	O
(	O
len	int
!=	O
2	int
)	O
||	O
(	O
*	O
t	long
==	O
'.'	O
)	O
||	O
(	O
*	O
t	long
<=	O
' '	O
)	O
)	O
{	O
t	long
+=	O
len	int
+	O
1	int
;	O
continue	O
;	O
}	O
b	*(char)
[	O
0	int
]	O
=	O
t	long
[	O
0	int
]	O
;	O
b	*(char)
[	O
1	int
]	O
=	O
t	long
[	O
1	int
]	O
;	O
t	long
+=	O
3	int
;	O
b	*(char)
+=	O
2	int
;	O
}	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
boolean_section_size	int
=	O
(	O
int	O
)	O
(	O
b	*(char)
-	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
boolean_flags	*(char)
)	O
;	O
ti	*(struct(int,int,*(char),int,*(char),int,*(char),int,*(char),int,*(char)))
->	O
flags	int
=	O
SLTERMCAP	int
;	O
return	O
0	int
;	O
}	O
char	O
*	O
SLtt_tigetent	(*(char))->(*(char))
(	O
char	O
*	O
s	*(char)
)	O
{	O
return	O
(	O
char	O
*	O
)	O
_pSLtt_tigetent	(*(char))->(*(struct))
(	O
s	*(char)
)	O
;	O
}	O
extern	O
char	O
*	O
SLtt_tigetstr	(*(char),*(*(char)))->(*(char))
(	O
char	O
*	O
s	*(char)
,	O
char	O
*	O
*	O
p	*(char)
)	O
{	O
if	O
(	O
p	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
_pSLtt_tigetstr	(*(struct),*(char))->(*(char))
(	O
(	O
SLterminfo_Type	struct
*	O
)	O
*	O
p	*(char)
,	O
s	*(char)
)	O
;	O
}	O
extern	O
int	O
SLtt_tigetnum	(*(char),*(*(char)))->(int)
(	O
char	O
*	O
s	*(char)
,	O
char	O
*	O
*	O
p	*(char)
)	O
{	O
if	O
(	O
p	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
return	O
_pSLtt_tigetnum	(*(struct),*(char))->(int)
(	O
(	O
SLterminfo_Type	struct
*	O
)	O
*	O
p	*(char)
,	O
s	*(char)
)	O
;	O
}	O
