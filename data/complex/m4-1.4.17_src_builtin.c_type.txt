DECLARE	O
(	O
m4___file__	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4___line__	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4___program__	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_builtin	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_changecom	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_changequote	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_debugmode	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_debugfile	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_decr	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_define	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_defn	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_divert	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_divnum	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_dnl	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_dumpdef	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_errprint	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_esyscmd	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_eval	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_format	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_ifdef	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_ifelse	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_include	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_incr	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_index	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_indir	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_len	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_m4exit	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_m4wrap	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_maketemp	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_mkstemp	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_patsubst	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_popdef	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_pushdef	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_regexp	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_shift	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_sinclude	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_substr	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_syscmd	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_sysval	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_traceoff	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_traceon	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_translit	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_undefine	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
DECLARE	O
(	O
m4_undivert	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
;	O
static	O
builtin	struct(*(char),bool,bool,bool,*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void)))
const	O
builtin_tab	array(struct(*(char),bool,bool,bool,*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
[	O
]	O
=	O
{	O
{	O
"__file__"	*(char)
,	O
true	int
,	O
false	int
,	O
false	int
,	O
m4___file__	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"__line__"	*(char)
,	O
true	int
,	O
false	int
,	O
false	int
,	O
m4___line__	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"__program__"	*(char)
,	O
true	int
,	O
false	int
,	O
false	int
,	O
m4___program__	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"builtin"	*(char)
,	O
true	int
,	O
true	int
,	O
true	int
,	O
m4_builtin	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"changecom"	*(char)
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_changecom	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"changequote"	*(char)
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_changequote	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"debugmode"	*(char)
,	O
true	int
,	O
false	int
,	O
false	int
,	O
m4_debugmode	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"debugfile"	*(char)
,	O
true	int
,	O
false	int
,	O
false	int
,	O
m4_debugfile	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"decr"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_decr	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"define"	*(char)
,	O
false	int
,	O
true	int
,	O
true	int
,	O
m4_define	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"defn"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_defn	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"divert"	*(char)
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_divert	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"divnum"	*(char)
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_divnum	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"dnl"	*(char)
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_dnl	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"dumpdef"	*(char)
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_dumpdef	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"errprint"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_errprint	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"esyscmd"	*(char)
,	O
true	int
,	O
false	int
,	O
true	int
,	O
m4_esyscmd	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"eval"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_eval	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"format"	*(char)
,	O
true	int
,	O
false	int
,	O
true	int
,	O
m4_format	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"ifdef"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_ifdef	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"ifelse"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_ifelse	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"include"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_include	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"incr"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_incr	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"index"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_index	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"indir"	*(char)
,	O
true	int
,	O
true	int
,	O
true	int
,	O
m4_indir	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"len"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_len	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"m4exit"	*(char)
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_m4exit	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"m4wrap"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_m4wrap	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"maketemp"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_maketemp	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"mkstemp"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_mkstemp	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"patsubst"	*(char)
,	O
true	int
,	O
false	int
,	O
true	int
,	O
m4_patsubst	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"popdef"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_popdef	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"pushdef"	*(char)
,	O
false	int
,	O
true	int
,	O
true	int
,	O
m4_pushdef	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"regexp"	*(char)
,	O
true	int
,	O
false	int
,	O
true	int
,	O
m4_regexp	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"shift"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_shift	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"sinclude"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_sinclude	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"substr"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_substr	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"syscmd"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_syscmd	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"sysval"	*(char)
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_sysval	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"traceoff"	*(char)
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_traceoff	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"traceon"	*(char)
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_traceon	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"translit"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_translit	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"undefine"	*(char)
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_undefine	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
"undivert"	*(char)
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_undivert	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
{	O
0	int
,	O
false	int
,	O
false	int
,	O
false	int
,	O
0	int
}	O
,	O
{	O
"placeholder"	*(char)
,	O
true	int
,	O
false	int
,	O
false	int
,	O
m4_placeholder	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
}	O
,	O
}	O
;	O
static	O
predefined	struct(*(char),*(char),*(char))
const	O
predefined_tab	array(struct(*(char),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"unix"	*(char)
,	O
"__unix__"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
NULL	O
,	O
"__gnu__"	*(char)
,	O
""	*(char)
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
}	O
;	O
const	O
builtin	struct(*(char),bool,bool,bool,*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void)))
*	O
M4_GNUC_PURE	O
find_builtin_by_addr	(*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))->(*(struct(*(char),bool,bool,bool,*((*`,int,*`)->(void)))))
(	O
builtin_func	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct)))->(void)
*	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
)	O
{	O
const	O
builtin	struct(*(char),bool,bool,bool,*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void)))
*	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
;	O
for	O
(	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
=	O
&	O
builtin_tab	array(struct(*(char),bool,bool,bool,*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
[	O
0	int
]	O
;	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
name	*(char)
!=	O
NULL	O
;	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
++	O
)	O
if	O
(	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
==	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
)	O
return	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
;	O
if	O
(	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
==	O
m4_placeholder	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
return	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
+	O
1	int
;	O
return	O
NULL	O
;	O
}	O
const	O
builtin	struct(*(char),bool,bool,bool,*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void)))
*	O
M4_GNUC_PURE	O
find_builtin_by_name	(*(char))->(*(struct(*(char),bool,bool,bool,*((*`,int,*`)->(void)))))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
const	O
builtin	struct(*(char),bool,bool,bool,*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void)))
*	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
;	O
for	O
(	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
=	O
&	O
builtin_tab	array(struct(*(char),bool,bool,bool,*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
[	O
0	int
]	O
;	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
name	*(char)
!=	O
NULL	O
;	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
++	O
)	O
if	O
(	O
STREQ	O
(	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
name	*(char)
,	O
name	*(char)
)	O
)	O
return	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
;	O
return	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
+	O
1	int
;	O
}	O
void	O
define_builtin	(*(char),*(struct(*(char),bool,bool,bool,*((*`,int,*`)->(void)))),enum(int,int,int,int,int))->(void)
(	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
builtin	struct(*(char),bool,bool,bool,*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void)))
*	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
,	O
symbol_lookup	enum(int,int,int,int,int)
mode	int
)	O
{	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
lookup_symbol	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
name	*(char)
,	O
mode	int
)	O
;	O
SYMBOL_TYPE	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
TOKEN_FUNC	int
;	O
SYMBOL_MACRO_ARGS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
groks_macro_args	bool
;	O
SYMBOL_BLIND_NO_ARGS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
blind_if_no_args	bool
;	O
SYMBOL_FUNC	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
;	O
}	O
static	O
struct	O
re_pattern_buffer	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
macro_sequence_buf	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
static	O
struct	O
re_registers	struct(int,*(int),*(int))
macro_sequence_regs	struct(int,*(int),*(int))
;	O
static	O
bool	bool
macro_sequence_inuse	bool
;	O
static	O
void	O
free_pattern_buffer	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(struct(int,*(int),*(int))))->(void)
(	O
struct	O
re_pattern_buffer	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
*	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
struct	O
re_registers	struct(int,*(int),*(int))
*	O
regs	*(struct(int,*(int),*(int)))
)	O
{	O
regfree	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)))->(void)
(	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
)	O
;	O
free	(*(void))->(void)
(	O
regs	*(struct(int,*(int),*(int)))
->	O
start	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
regs	*(struct(int,*(int),*(int)))
->	O
end	*(int)
)	O
;	O
}	O
void	O
set_macro_sequence	(*(char))->(void)
(	O
const	O
char	O
*	O
regexp	*(char)
)	O
{	O
const	O
char	O
*	O
msg	*(char)
;	O
if	O
(	O
!	O
regexp	*(char)
)	O
regexp	*(char)
=	O
DEFAULT_MACRO_SEQUENCE	*(char)
;	O
else	O
if	O
(	O
regexp	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
macro_sequence_inuse	bool
=	O
false	int
;	O
return	O
;	O
}	O
msg	*(char)
=	O
re_compile_pattern	(*(char),long,*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)))->(*(char))
(	O
regexp	*(char)
,	O
strlen	(*(char))->(long)
(	O
regexp	*(char)
)	O
,	O
&	O
macro_sequence_buf	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
)	O
;	O
if	O
(	O
msg	*(char)
!=	O
NULL	O
)	O
{	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"--warn-macro-sequence: bad regular expression `%s': %s"	*(char)
,	O
regexp	*(char)
,	O
msg	*(char)
)	O
)	O
;	O
}	O
re_set_registers	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(struct(int,*(int),*(int))),int,*(int),*(int))->(void)
(	O
&	O
macro_sequence_buf	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
&	O
macro_sequence_regs	struct(int,*(int),*(int))
,	O
macro_sequence_regs	struct(int,*(int),*(int))
.	O
num_regs	int
,	O
macro_sequence_regs	struct(int,*(int),*(int))
.	O
start	*(int)
,	O
macro_sequence_regs	struct(int,*(int),*(int))
.	O
end	*(int)
)	O
;	O
macro_sequence_inuse	bool
=	O
true	int
;	O
}	O
void	O
free_macro_sequence	()->(void)
(	O
void	O
)	O
{	O
free_pattern_buffer	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(struct(int,*(int),*(int))))->(void)
(	O
&	O
macro_sequence_buf	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
&	O
macro_sequence_regs	struct(int,*(int),*(int))
)	O
;	O
}	O
void	O
define_user_macro	(*(char),*(char),enum(int,int,int,int,int))->(void)
(	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
text	*(char)
,	O
symbol_lookup	enum(int,int,int,int,int)
mode	int
)	O
{	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
s	long
;	O
char	O
*	O
defn	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
text	*(char)
?	O
text	*(char)
:	O
""	*(char)
)	O
;	O
s	long
=	O
lookup_symbol	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
name	*(char)
,	O
mode	int
)	O
;	O
if	O
(	O
SYMBOL_TYPE	O
(	O
s	long
)	O
==	O
TOKEN_TEXT	int
)	O
free	(*(void))->(void)
(	O
SYMBOL_TEXT	O
(	O
s	long
)	O
)	O
;	O
SYMBOL_TYPE	O
(	O
s	long
)	O
=	O
TOKEN_TEXT	int
;	O
SYMBOL_TEXT	O
(	O
s	long
)	O
=	O
defn	*(char)
;	O
if	O
(	O
macro_sequence_inuse	bool
&&	O
text	*(char)
)	O
{	O
regoff_t	int
offset	long
=	O
0	int
;	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
defn	*(char)
)	O
;	O
while	O
(	O
(	O
offset	long
=	O
re_search	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int,int,int,*(struct(int,*(int),*(int))))->(int)
(	O
&	O
macro_sequence_buf	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
defn	*(char)
,	O
len	long
,	O
offset	long
,	O
len	long
-	O
offset	long
,	O
&	O
macro_sequence_regs	struct(int,*(int),*(int))
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
macro_sequence_regs	struct(int,*(int),*(int))
.	O
start	*(int)
[	O
0	int
]	O
==	O
macro_sequence_regs	struct(int,*(int),*(int))
.	O
end	*(int)
[	O
0	int
]	O
)	O
offset	long
++	O
;	O
else	O
{	O
char	O
tmp	char
;	O
offset	long
=	O
macro_sequence_regs	struct(int,*(int),*(int))
.	O
end	*(int)
[	O
0	int
]	O
;	O
tmp	char
=	O
defn	*(char)
[	O
offset	long
]	O
;	O
defn	*(char)
[	O
offset	long
]	O
=	O
'\0'	O
;	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: definition of `%s' contains sequence `%s'"	*(char)
,	O
name	*(char)
,	O
defn	*(char)
+	O
macro_sequence_regs	struct(int,*(int),*(int))
.	O
start	*(int)
[	O
0	int
]	O
)	O
)	O
;	O
defn	*(char)
[	O
offset	long
]	O
=	O
tmp	char
;	O
}	O
}	O
if	O
(	O
offset	long
==	O
-	O
2	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"error checking --warn-macro-sequence for macro `%s'"	*(char)
,	O
name	*(char)
)	O
)	O
;	O
}	O
}	O
void	O
builtin_init	()->(void)
(	O
void	O
)	O
{	O
const	O
builtin	struct(*(char),bool,bool,bool,*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void)))
*	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
;	O
const	O
predefined	struct(*(char),*(char),*(char))
*	O
pp	*(struct(*(char),*(char),*(char)))
;	O
char	O
*	O
string	struct(*(char),long)
;	O
for	O
(	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
=	O
&	O
builtin_tab	array(struct(*(char),bool,bool,bool,*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void))))
[	O
0	int
]	O
;	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
name	*(char)
!=	O
NULL	O
;	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
++	O
)	O
if	O
(	O
!	O
no_gnu_extensions	int
||	O
!	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
gnu_extension	bool
)	O
{	O
if	O
(	O
prefix_all_builtins	int
)	O
{	O
string	struct(*(char),long)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
name	*(char)
)	O
+	O
4	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
string	struct(*(char),long)
,	O
"m4_"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
string	struct(*(char),long)
,	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
name	*(char)
)	O
;	O
define_builtin	(*(char),*(struct(*(char),bool,bool,bool,*((*`,int,*`)->(void)))),enum(int,int,int,int,int))->(void)
(	O
string	struct(*(char),long)
,	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
,	O
SYMBOL_INSERT	int
)	O
;	O
free	(*(void))->(void)
(	O
string	struct(*(char),long)
)	O
;	O
}	O
else	O
define_builtin	(*(char),*(struct(*(char),bool,bool,bool,*((*`,int,*`)->(void)))),enum(int,int,int,int,int))->(void)
(	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
name	*(char)
,	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
,	O
SYMBOL_INSERT	int
)	O
;	O
}	O
for	O
(	O
pp	*(struct(*(char),*(char),*(char)))
=	O
&	O
predefined_tab	array(struct(*(char),*(char),*(char)))
[	O
0	int
]	O
;	O
pp	*(struct(*(char),*(char),*(char)))
->	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
!=	O
NULL	O
;	O
pp	*(struct(*(char),*(char),*(char)))
++	O
)	O
if	O
(	O
no_gnu_extensions	int
)	O
{	O
if	O
(	O
pp	*(struct(*(char),*(char),*(char)))
->	O
unix_name	*(char)
!=	O
NULL	O
)	O
define_user_macro	(*(char),*(char),enum(int,int,int,int,int))->(void)
(	O
pp	*(struct(*(char),*(char),*(char)))
->	O
unix_name	*(char)
,	O
pp	*(struct(*(char),*(char),*(char)))
->	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
,	O
SYMBOL_INSERT	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pp	*(struct(*(char),*(char),*(char)))
->	O
gnu_name	*(char)
!=	O
NULL	O
)	O
define_user_macro	(*(char),*(char),enum(int,int,int,int,int))->(void)
(	O
pp	*(struct(*(char),*(char),*(char)))
->	O
gnu_name	*(char)
,	O
pp	*(struct(*(char),*(char),*(char)))
->	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
,	O
SYMBOL_INSERT	int
)	O
;	O
}	O
}	O
static	O
bool	bool
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
token_data	struct
*	O
name	*(char)
,	O
int	O
argc	int
,	O
int	O
min	int
,	O
int	O
max	int
)	O
{	O
bool	bool
isbad	bool
=	O
false	int
;	O
if	O
(	O
min	int
>	O
0	int
&&	O
argc	int
<	O
min	int
)	O
{	O
if	O
(	O
!	O
suppress_warnings	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: too few arguments to builtin `%s'"	*(char)
,	O
TOKEN_DATA_TEXT	O
(	O
name	*(char)
)	O
)	O
)	O
;	O
isbad	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
max	int
>	O
0	int
&&	O
argc	int
>	O
max	int
&&	O
!	O
suppress_warnings	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: excess arguments to builtin `%s' ignored"	*(char)
,	O
TOKEN_DATA_TEXT	O
(	O
name	*(char)
)	O
)	O
)	O
;	O
return	O
isbad	bool
;	O
}	O
static	O
bool	bool
numeric_arg	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),*(char),*(int))->(bool)
(	O
token_data	struct
*	O
macro	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
,	O
const	O
char	O
*	O
arg	*(char)
,	O
int	O
*	O
valuep	*(int)
)	O
{	O
char	O
*	O
endp	*(char)
;	O
if	O
(	O
*	O
arg	*(char)
==	O
'\0'	O
)	O
{	O
*	O
valuep	*(int)
=	O
0	int
;	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"empty string treated as 0 in builtin `%s'"	*(char)
,	O
TOKEN_DATA_TEXT	O
(	O
macro	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
)	O
)	O
;	O
}	O
else	O
{	O
errno	O
=	O
0	int
;	O
*	O
valuep	*(int)
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
,	O
&	O
endp	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
endp	*(char)
!=	O
'\0'	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"non-numeric argument to builtin `%s'"	*(char)
,	O
TOKEN_DATA_TEXT	O
(	O
macro	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
)	O
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
isspace	(int)->(int)
(	O
to_uchar	O
(	O
*	O
arg	*(char)
)	O
)	O
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"leading whitespace ignored in builtin `%s'"	*(char)
,	O
TOKEN_DATA_TEXT	O
(	O
macro	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
)	O
)	O
;	O
else	O
if	O
(	O
errno	O
==	O
ERANGE	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"numeric overflow detected in builtin `%s'"	*(char)
,	O
TOKEN_DATA_TEXT	O
(	O
macro	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
)	O
)	O
;	O
}	O
return	O
true	int
;	O
}	O
static	O
char	O
const	O
digits	array(char)
[	O
]	O
=	O
"0123456789abcdefghijklmnopqrstuvwxyz"	*(char)
;	O
const	O
char	O
*	O
ntoa	(int,int)->(*(char))
(	O
int32_t	int
value	bool
,	O
int	O
radix	int
)	O
{	O
bool	bool
negative	bool
;	O
uint32_t	int
uvalue	int
;	O
static	O
char	O
str	*(char)
[	O
256	int
]	O
;	O
char	O
*	O
s	long
=	O
&	O
str	*(char)
[	O
sizeof	O
str	*(char)
]	O
;	O
*	O
--	O
s	long
=	O
'\0'	O
;	O
if	O
(	O
value	bool
<	O
0	int
)	O
{	O
negative	bool
=	O
true	int
;	O
uvalue	int
=	O
-	O
(	O
uint32_t	int
)	O
value	bool
;	O
}	O
else	O
{	O
negative	bool
=	O
false	int
;	O
uvalue	int
=	O
(	O
uint32_t	int
)	O
value	bool
;	O
}	O
do	O
{	O
*	O
--	O
s	long
=	O
digits	array(char)
[	O
uvalue	int
%	O
radix	int
]	O
;	O
uvalue	int
/=	O
radix	int
;	O
}	O
while	O
(	O
uvalue	int
>	O
0	int
)	O
;	O
if	O
(	O
negative	bool
)	O
*	O
--	O
s	long
=	O
'-'	O
;	O
return	O
s	long
;	O
}	O
static	O
void	O
shipout_int	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int)->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
val	array(int)
)	O
{	O
const	O
char	O
*	O
s	long
;	O
s	long
=	O
ntoa	(int,int)->(*(char))
(	O
(	O
int32_t	int
)	O
val	array(int)
,	O
10	int
)	O
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
s	long
,	O
strlen	(*(char))->(long)
(	O
s	long
)	O
)	O
;	O
}	O
static	O
void	O
dump_args	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))),*(char),bool)->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
const	O
char	O
*	O
sep	*(char)
,	O
bool	bool
quoted	bool
)	O
{	O
int	O
i	int
;	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
sep	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
>	O
1	int
)	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
sep	*(char)
,	O
len	long
)	O
;	O
if	O
(	O
quoted	bool
)	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
lquote	struct(*(char),long)
.	O
length	long
)	O
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
i	int
]	O
)	O
,	O
strlen	(*(char))->(long)
(	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
i	int
]	O
)	O
)	O
)	O
;	O
if	O
(	O
quoted	bool
)	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
rquote	struct(*(char),long)
.	O
length	long
)	O
;	O
}	O
}	O
static	O
void	O
define_macro	(int,*(*(struct(enum(int,int,int),union(struct`,*`)))),enum(int,int,int,int,int))->(void)
(	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
symbol_lookup	enum(int,int,int,int,int)
mode	int
)	O
{	O
const	O
builtin	struct(*(char),bool,bool,bool,*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void)))
*	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
3	int
)	O
)	O
return	O
;	O
if	O
(	O
TOKEN_DATA_TYPE	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
1	int
]	O
)	O
!=	O
TOKEN_TEXT	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: %s: invalid macro name ignored"	*(char)
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
argc	int
==	O
2	int
)	O
{	O
define_user_macro	(*(char),*(char),enum(int,int,int,int,int))->(void)
(	O
ARG	O
(	O
1	int
)	O
,	O
""	*(char)
,	O
mode	int
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
TOKEN_DATA_TYPE	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
2	int
]	O
)	O
)	O
{	O
case	O
TOKEN_TEXT	int
:	O
define_user_macro	(*(char),*(char),enum(int,int,int,int,int))->(void)
(	O
ARG	O
(	O
1	int
)	O
,	O
ARG	O
(	O
2	int
)	O
,	O
mode	int
)	O
;	O
break	O
;	O
case	O
TOKEN_FUNC	int
:	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
=	O
find_builtin_by_addr	(*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))->(*(struct(*(char),bool,bool,bool,*((*`,int,*`)->(void)))))
(	O
TOKEN_DATA_FUNC	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
2	int
]	O
)	O
)	O
;	O
if	O
(	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
==	O
NULL	O
)	O
return	O
;	O
else	O
define_builtin	(*(char),*(struct(*(char),bool,bool,bool,*((*`,int,*`)->(void)))),enum(int,int,int,int,int))->(void)
(	O
ARG	O
(	O
1	int
)	O
,	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
,	O
mode	int
)	O
;	O
break	O
;	O
case	O
TOKEN_VOID	int
:	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad token data type in define_macro ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
static	O
void	O
m4_define	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
define_macro	(int,*(*(struct(enum(int,int,int),union(struct`,*`)))),enum(int,int,int,int,int))->(void)
(	O
argc	int
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
SYMBOL_INSERT	int
)	O
;	O
}	O
static	O
void	O
m4_undefine	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
int	O
i	int
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
lookup_symbol	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
ARG	O
(	O
i	int
)	O
,	O
SYMBOL_DELETE	int
)	O
;	O
}	O
static	O
void	O
m4_pushdef	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
define_macro	(int,*(*(struct(enum(int,int,int),union(struct`,*`)))),enum(int,int,int,int,int))->(void)
(	O
argc	int
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
SYMBOL_PUSHDEF	int
)	O
;	O
}	O
static	O
void	O
m4_popdef	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
int	O
i	int
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
lookup_symbol	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
ARG	O
(	O
i	int
)	O
,	O
SYMBOL_POPDEF	int
)	O
;	O
}	O
static	O
void	O
m4_ifdef	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
s	long
;	O
const	O
char	O
*	O
result	*(*(char))
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
3	int
,	O
4	int
)	O
)	O
return	O
;	O
s	long
=	O
lookup_symbol	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
ARG	O
(	O
1	int
)	O
,	O
SYMBOL_LOOKUP	int
)	O
;	O
if	O
(	O
s	long
!=	O
NULL	O
&&	O
SYMBOL_TYPE	O
(	O
s	long
)	O
!=	O
TOKEN_VOID	int
)	O
result	*(*(char))
=	O
ARG	O
(	O
2	int
)	O
;	O
else	O
if	O
(	O
argc	int
>=	O
4	int
)	O
result	*(*(char))
=	O
ARG	O
(	O
3	int
)	O
;	O
else	O
result	*(*(char))
=	O
NULL	O
;	O
if	O
(	O
result	*(*(char))
!=	O
NULL	O
)	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
result	*(*(char))
,	O
strlen	(*(char))->(long)
(	O
result	*(*(char))
)	O
)	O
;	O
}	O
static	O
void	O
m4_ifelse	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
const	O
char	O
*	O
result	*(*(char))
;	O
token_data	struct
*	O
me	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
=	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
;	O
if	O
(	O
argc	int
==	O
2	int
)	O
return	O
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
me	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
,	O
argc	int
,	O
4	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
else	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
me	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
,	O
(	O
argc	int
+	O
2	int
)	O
%	O
3	int
,	O
-	O
1	int
,	O
1	int
)	O
;	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
++	O
;	O
argc	int
--	O
;	O
result	*(*(char))
=	O
NULL	O
;	O
while	O
(	O
result	*(*(char))
==	O
NULL	O
)	O
if	O
(	O
STREQ	O
(	O
ARG	O
(	O
0	int
)	O
,	O
ARG	O
(	O
1	int
)	O
)	O
)	O
result	*(*(char))
=	O
ARG	O
(	O
2	int
)	O
;	O
else	O
switch	O
(	O
argc	int
)	O
{	O
case	O
3	int
:	O
return	O
;	O
case	O
4	int
:	O
case	O
5	int
:	O
result	*(*(char))
=	O
ARG	O
(	O
3	int
)	O
;	O
break	O
;	O
default	O
:	O
argc	int
-=	O
3	int
;	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
+=	O
3	int
;	O
}	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
result	*(*(char))
,	O
strlen	(*(char))->(long)
(	O
result	*(*(char))
)	O
)	O
;	O
}	O
struct	O
dump_symbol_data	struct(*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int)),*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`))))),int)
{	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
;	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
*	O
base	*(char)
;	O
int	O
size	int
;	O
}	O
;	O
static	O
void	O
dump_symbol	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),*(void))->(void)
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
void	O
*	O
arg	*(char)
)	O
{	O
struct	O
dump_symbol_data	struct(*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int)),*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`))))),int)
*	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
=	O
(	O
struct	O
dump_symbol_data	struct(*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int)),*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`))))),int)
*	O
)	O
arg	*(char)
;	O
if	O
(	O
!	O
SYMBOL_SHADOWED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
&&	O
SYMBOL_TYPE	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
!=	O
TOKEN_VOID	int
)	O
{	O
obstack_blank	O
(	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
->	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
sizeof	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
)	O
)	O
;	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
->	O
base	*(char)
=	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
*	O
)	O
obstack_base	O
(	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
->	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
->	O
base	*(char)
[	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
->	O
size	int
++	O
]	O
=	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
}	O
}	O
static	O
int	O
dumpdef_cmp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
s1	*(void)
,	O
const	O
void	O
*	O
s2	*(void)
)	O
{	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
SYMBOL_NAME	O
(	O
*	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
const	O
*	O
)	O
s1	*(void)
)	O
,	O
SYMBOL_NAME	O
(	O
*	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
const	O
*	O
)	O
s2	*(void)
)	O
)	O
;	O
}	O
static	O
void	O
m4_dumpdef	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
s	long
;	O
int	O
i	int
;	O
struct	O
dump_symbol_data	struct(*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int)),*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`))))),int)
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
;	O
const	O
builtin	struct(*(char),bool,bool,bool,*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void)))
*	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
;	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
.	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
=	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
;	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
.	O
base	*(char)
=	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
*	O
)	O
obstack_base	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
.	O
size	int
=	O
0	int
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
hack_all_symbols	(*((*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),*(void))->(void)),*(void))->(void)
(	O
dump_symbol	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),*(void))->(void)
,	O
&	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
s	long
=	O
lookup_symbol	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
i	int
]	O
)	O
,	O
SYMBOL_LOOKUP	int
)	O
;	O
if	O
(	O
s	long
!=	O
NULL	O
&&	O
SYMBOL_TYPE	O
(	O
s	long
)	O
!=	O
TOKEN_VOID	int
)	O
dump_symbol	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),*(void))->(void)
(	O
s	long
,	O
&	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
;	O
else	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"undefined macro `%s'"	*(char)
,	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
i	int
]	O
)	O
)	O
)	O
;	O
}	O
}	O
obstack_finish	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
.	O
base	*(char)
,	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
.	O
size	int
,	O
sizeof	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
)	O
,	O
dumpdef_cmp	(*(void),*(void))->(int)
)	O
;	O
for	O
(	O
;	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
.	O
size	int
>	O
0	int
;	O
--	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
.	O
size	int
,	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
.	O
base	*(char)
++	O
)	O
{	O
DEBUG_PRINT1	O
(	O
"%s:\t"	*(char)
,	O
SYMBOL_NAME	O
(	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
.	O
base	*(char)
[	O
0	int
]	O
)	O
)	O
;	O
switch	O
(	O
SYMBOL_TYPE	O
(	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
.	O
base	*(char)
[	O
0	int
]	O
)	O
)	O
{	O
case	O
TOKEN_TEXT	int
:	O
if	O
(	O
debug_level	int
&	O
DEBUG_TRACE_QUOTE	int
)	O
DEBUG_PRINT3	O
(	O
"%s%s%s\n"	*(char)
,	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
SYMBOL_TEXT	O
(	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
.	O
base	*(char)
[	O
0	int
]	O
)	O
,	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
)	O
;	O
else	O
DEBUG_PRINT1	O
(	O
"%s\n"	*(char)
,	O
SYMBOL_TEXT	O
(	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
.	O
base	*(char)
[	O
0	int
]	O
)	O
)	O
;	O
break	O
;	O
case	O
TOKEN_FUNC	int
:	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
=	O
find_builtin_by_addr	(*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))->(*(struct(*(char),bool,bool,bool,*((*`,int,*`)->(void)))))
(	O
SYMBOL_FUNC	O
(	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
.	O
base	*(char)
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
==	O
NULL	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: builtin not found in builtin table"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
DEBUG_PRINT1	O
(	O
"<%s>\n"	*(char)
,	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
name	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_VOID	int
:	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad token data type in m4_dumpdef ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
m4_builtin	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
const	O
builtin	struct(*(char),bool,bool,bool,*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void)))
*	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
;	O
const	O
char	O
*	O
name	*(char)
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
if	O
(	O
TOKEN_DATA_TYPE	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
1	int
]	O
)	O
!=	O
TOKEN_TEXT	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: %s: invalid macro name ignored"	*(char)
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
name	*(char)
=	O
ARG	O
(	O
1	int
)	O
;	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
=	O
find_builtin_by_name	(*(char))->(*(struct(*(char),bool,bool,bool,*((*`,int,*`)->(void)))))
(	O
name	*(char)
)	O
;	O
if	O
(	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
==	O
m4_placeholder	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"undefined builtin `%s'"	*(char)
,	O
name	*(char)
)	O
)	O
;	O
else	O
{	O
int	O
i	int
;	O
if	O
(	O
!	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
groks_macro_args	bool
)	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
if	O
(	O
TOKEN_DATA_TYPE	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
i	int
]	O
)	O
!=	O
TOKEN_TEXT	int
)	O
{	O
TOKEN_DATA_TYPE	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
i	int
]	O
)	O
=	O
TOKEN_TEXT	int
;	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
i	int
]	O
)	O
=	O
(	O
char	O
*	O
)	O
""	*(char)
;	O
}	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
argc	int
-	O
1	int
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
+	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
m4_indir	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
s	long
;	O
const	O
char	O
*	O
name	*(char)
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
if	O
(	O
TOKEN_DATA_TYPE	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
1	int
]	O
)	O
!=	O
TOKEN_TEXT	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: %s: invalid macro name ignored"	*(char)
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
name	*(char)
=	O
ARG	O
(	O
1	int
)	O
;	O
s	long
=	O
lookup_symbol	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
name	*(char)
,	O
SYMBOL_LOOKUP	int
)	O
;	O
if	O
(	O
s	long
==	O
NULL	O
||	O
SYMBOL_TYPE	O
(	O
s	long
)	O
==	O
TOKEN_VOID	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"undefined macro `%s'"	*(char)
,	O
name	*(char)
)	O
)	O
;	O
else	O
{	O
int	O
i	int
;	O
if	O
(	O
!	O
SYMBOL_MACRO_ARGS	O
(	O
s	long
)	O
)	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
if	O
(	O
TOKEN_DATA_TYPE	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
i	int
]	O
)	O
!=	O
TOKEN_TEXT	int
)	O
{	O
TOKEN_DATA_TYPE	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
i	int
]	O
)	O
=	O
TOKEN_TEXT	int
;	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
i	int
]	O
)	O
=	O
(	O
char	O
*	O
)	O
""	*(char)
;	O
}	O
call_macro	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),int,*(*(struct(enum(int,int,int),union(struct`,*`)))),*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))->(void)
(	O
s	long
,	O
argc	int
-	O
1	int
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
+	O
1	int
,	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
}	O
}	O
static	O
void	O
m4_defn	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
s	long
;	O
builtin_func	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct)))->(void)
*	O
b	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void))
;	O
unsigned	O
int	O
i	int
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
assert	O
(	O
0	int
<	O
argc	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
(	O
unsigned	O
)	O
argc	int
;	O
i	int
++	O
)	O
{	O
const	O
char	O
*	O
arg	*(char)
=	O
ARG	O
(	O
(	O
int	O
)	O
i	int
)	O
;	O
s	long
=	O
lookup_symbol	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
arg	*(char)
,	O
SYMBOL_LOOKUP	int
)	O
;	O
if	O
(	O
s	long
==	O
NULL	O
)	O
continue	O
;	O
switch	O
(	O
SYMBOL_TYPE	O
(	O
s	long
)	O
)	O
{	O
case	O
TOKEN_TEXT	int
:	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
lquote	struct(*(char),long)
.	O
length	long
)	O
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
SYMBOL_TEXT	O
(	O
s	long
)	O
,	O
strlen	(*(char))->(long)
(	O
SYMBOL_TEXT	O
(	O
s	long
)	O
)	O
)	O
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
rquote	struct(*(char),long)
.	O
length	long
)	O
;	O
break	O
;	O
case	O
TOKEN_FUNC	int
:	O
b	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void))
=	O
SYMBOL_FUNC	O
(	O
s	long
)	O
;	O
if	O
(	O
b	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void))
==	O
m4_placeholder	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"builtin `%s' requested by frozen file is not supported"	*(char)
,	O
arg	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
argc	int
!=	O
2	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: cannot concatenate builtin `%s'"	*(char)
,	O
arg	*(char)
)	O
)	O
;	O
else	O
push_macro	(*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))->(void)
(	O
b	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void))
)	O
;	O
break	O
;	O
case	O
TOKEN_VOID	int
:	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad symbol type in m4_defn ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
static	O
int	O
sysval	int
;	O
static	O
void	O
m4_syscmd	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
const	O
char	O
*	O
cmd	*(char)
=	O
ARG	O
(	O
1	int
)	O
;	O
int	O
status	int
;	O
int	O
sig_status	int
;	O
const	O
char	O
*	O
prog_args	array(*(char))
[	O
4	int
]	O
=	O
{	O
"sh"	*(char)
,	O
"-c"	*(char)
}	O
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
||	O
!	O
*	O
cmd	*(char)
)	O
{	O
sysval	int
=	O
0	int
;	O
return	O
;	O
}	O
debug_flush_files	()->(void)
(	O
)	O
;	O
prog_args	array(*(char))
[	O
2	int
]	O
=	O
cmd	*(char)
;	O
errno	O
=	O
0	int
;	O
status	int
=	O
execute	(*(char),*(char),*(*(char)),bool,bool,bool,bool,bool,bool,*(int))->(int)
(	O
ARG	O
(	O
0	int
)	O
,	O
SYSCMD_SHELL	*(char)
,	O
(	O
char	O
*	O
*	O
)	O
prog_args	array(*(char))
,	O
false	int
,	O
false	int
,	O
false	int
,	O
false	int
,	O
true	int
,	O
false	int
,	O
&	O
sig_status	int
)	O
;	O
if	O
(	O
sig_status	int
)	O
{	O
assert	O
(	O
status	int
==	O
127	int
)	O
;	O
sysval	int
=	O
sig_status	int
<<	O
8	int
;	O
}	O
else	O
{	O
if	O
(	O
status	int
==	O
127	int
&&	O
errno	O
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"cannot run command `%s'"	*(char)
,	O
cmd	*(char)
)	O
)	O
;	O
sysval	int
=	O
status	int
;	O
}	O
}	O
static	O
void	O
m4_esyscmd	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
const	O
char	O
*	O
cmd	*(char)
=	O
ARG	O
(	O
1	int
)	O
;	O
const	O
char	O
*	O
prog_args	array(*(char))
[	O
4	int
]	O
=	O
{	O
"sh"	*(char)
,	O
"-c"	*(char)
}	O
;	O
pid_t	int
child	int
;	O
int	O
fd	int
;	O
FILE	struct
*	O
pin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
status	int
;	O
int	O
sig_status	int
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
||	O
!	O
*	O
cmd	*(char)
)	O
{	O
sysval	int
=	O
0	int
;	O
return	O
;	O
}	O
debug_flush_files	()->(void)
(	O
)	O
;	O
prog_args	array(*(char))
[	O
2	int
]	O
=	O
cmd	*(char)
;	O
errno	O
=	O
0	int
;	O
child	int
=	O
create_pipe_in	(*(char),*(char),*(*(char)),*(char),bool,bool,bool,array(int))->(int)
(	O
ARG	O
(	O
0	int
)	O
,	O
SYSCMD_SHELL	*(char)
,	O
(	O
char	O
*	O
*	O
)	O
prog_args	array(*(char))
,	O
NULL	O
,	O
false	int
,	O
true	int
,	O
false	int
,	O
&	O
fd	int
)	O
;	O
if	O
(	O
child	int
==	O
-	O
1	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"cannot run command `%s'"	*(char)
,	O
cmd	*(char)
)	O
)	O
;	O
sysval	int
=	O
127	int
;	O
return	O
;	O
}	O
pin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fd	int
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
pin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"cannot run command `%s'"	*(char)
,	O
cmd	*(char)
)	O
)	O
;	O
sysval	int
=	O
127	int
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
return	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
size_t	long
avail	long
=	O
obstack_room	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
size_t	long
len	long
;	O
if	O
(	O
!	O
avail	long
)	O
{	O
int	O
ch	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
break	O
;	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
ch	int
)	O
;	O
continue	O
;	O
}	O
len	long
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
obstack_next_free	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
,	O
1	int
,	O
avail	long
,	O
pin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
len	long
<=	O
0	int
)	O
break	O
;	O
obstack_blank_fast	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
len	long
)	O
;	O
}	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
||	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot read pipe"	*(char)
)	O
)	O
;	O
errno	O
=	O
0	int
;	O
status	int
=	O
wait_subprocess	(int,*(char),bool,bool,bool,bool,*(int))->(int)
(	O
child	int
,	O
ARG	O
(	O
0	int
)	O
,	O
false	int
,	O
true	int
,	O
true	int
,	O
false	int
,	O
&	O
sig_status	int
)	O
;	O
if	O
(	O
sig_status	int
)	O
{	O
assert	O
(	O
status	int
==	O
127	int
)	O
;	O
sysval	int
=	O
sig_status	int
<<	O
8	int
;	O
}	O
else	O
{	O
if	O
(	O
status	int
==	O
127	int
&&	O
errno	O
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"cannot run command `%s'"	*(char)
,	O
cmd	*(char)
)	O
)	O
;	O
sysval	int
=	O
status	int
;	O
}	O
}	O
static	O
void	O
m4_sysval	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
M4_GNUC_UNUSED	O
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
M4_GNUC_UNUSED	O
)	O
{	O
shipout_int	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
sysval	int
)	O
;	O
}	O
static	O
void	O
m4_eval	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
int32_t	int
value	bool
=	O
0	int
;	O
int	O
radix	int
=	O
10	int
;	O
int	O
min	int
=	O
1	int
;	O
const	O
char	O
*	O
s	long
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
4	int
)	O
)	O
return	O
;	O
if	O
(	O
*	O
ARG	O
(	O
2	int
)	O
&&	O
!	O
numeric_arg	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),*(char),*(int))->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
ARG	O
(	O
2	int
)	O
,	O
&	O
radix	int
)	O
)	O
return	O
;	O
if	O
(	O
radix	int
<	O
1	int
||	O
radix	int
>	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
digits	array(char)
)	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"radix %d in builtin `%s' out of range"	*(char)
,	O
radix	int
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
argc	int
>=	O
4	int
&&	O
!	O
numeric_arg	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),*(char),*(int))->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
ARG	O
(	O
3	int
)	O
,	O
&	O
min	int
)	O
)	O
return	O
;	O
if	O
(	O
min	int
<	O
0	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"negative width to builtin `%s'"	*(char)
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
*	O
ARG	O
(	O
1	int
)	O
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"empty string treated as 0 in builtin `%s'"	*(char)
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
else	O
if	O
(	O
evaluate	(*(char),*(int))->(bool)
(	O
ARG	O
(	O
1	int
)	O
,	O
&	O
value	bool
)	O
)	O
return	O
;	O
if	O
(	O
radix	int
==	O
1	int
)	O
{	O
if	O
(	O
value	bool
<	O
0	int
)	O
{	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
'-'	O
)	O
;	O
value	bool
=	O
-	O
value	bool
;	O
}	O
while	O
(	O
min	int
--	O
-	O
value	bool
>	O
0	int
)	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
'0'	O
)	O
;	O
while	O
(	O
value	bool
--	O
!=	O
0	int
)	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
'1'	O
)	O
;	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
'\0'	O
)	O
;	O
return	O
;	O
}	O
s	long
=	O
ntoa	(int,int)->(*(char))
(	O
value	bool
,	O
radix	int
)	O
;	O
if	O
(	O
*	O
s	long
==	O
'-'	O
)	O
{	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
'-'	O
)	O
;	O
s	long
++	O
;	O
}	O
for	O
(	O
min	int
-=	O
strlen	(*(char))->(long)
(	O
s	long
)	O
;	O
--	O
min	int
>=	O
0	int
;	O
)	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
'0'	O
)	O
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
s	long
,	O
strlen	(*(char))->(long)
(	O
s	long
)	O
)	O
;	O
}	O
static	O
void	O
m4_incr	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
int	O
value	bool
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
)	O
return	O
;	O
if	O
(	O
!	O
numeric_arg	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),*(char),*(int))->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
ARG	O
(	O
1	int
)	O
,	O
&	O
value	bool
)	O
)	O
return	O
;	O
shipout_int	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
value	bool
+	O
1	int
)	O
;	O
}	O
static	O
void	O
m4_decr	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
int	O
value	bool
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
)	O
return	O
;	O
if	O
(	O
!	O
numeric_arg	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),*(char),*(int))->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
ARG	O
(	O
1	int
)	O
,	O
&	O
value	bool
)	O
)	O
return	O
;	O
shipout_int	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
value	bool
-	O
1	int
)	O
;	O
}	O
static	O
void	O
m4_divert	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
2	int
)	O
)	O
return	O
;	O
if	O
(	O
argc	int
>=	O
2	int
&&	O
!	O
numeric_arg	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),*(char),*(int))->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
ARG	O
(	O
1	int
)	O
,	O
&	O
i	int
)	O
)	O
return	O
;	O
make_diversion	(int)->(void)
(	O
i	int
)	O
;	O
}	O
static	O
void	O
m4_divnum	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
1	int
)	O
)	O
return	O
;	O
shipout_int	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
current_diversion	int
)	O
;	O
}	O
static	O
void	O
m4_undivert	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
int	O
i	int
,	O
file	*(char)
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
endp	*(char)
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
undivert_all	()->(void)
(	O
)	O
;	O
else	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
file	*(char)
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
ARG	O
(	O
i	int
)	O
,	O
&	O
endp	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
endp	*(char)
==	O
'\0'	O
&&	O
!	O
isspace	(int)->(int)
(	O
to_uchar	O
(	O
*	O
ARG	O
(	O
i	int
)	O
)	O
)	O
)	O
insert_diversion	(int)->(void)
(	O
file	*(char)
)	O
;	O
else	O
if	O
(	O
no_gnu_extensions	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"non-numeric argument to builtin `%s'"	*(char)
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
else	O
{	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
m4_path_search	(*(char),*(*(char)))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
ARG	O
(	O
i	int
)	O
,	O
NULL	O
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
insert_file	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"error undiverting `%s'"	*(char)
,	O
ARG	O
(	O
i	int
)	O
)	O
)	O
;	O
}	O
else	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"cannot undivert `%s'"	*(char)
,	O
ARG	O
(	O
i	int
)	O
)	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
m4_dnl	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
1	int
)	O
)	O
return	O
;	O
skip_line	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
m4_shift	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
dump_args	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))),*(char),bool)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
argc	int
-	O
1	int
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
+	O
1	int
,	O
","	*(char)
,	O
true	int
)	O
;	O
}	O
static	O
void	O
m4_changequote	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
3	int
)	O
)	O
return	O
;	O
set_quotes	(*(char),*(char))->(void)
(	O
(	O
argc	int
>=	O
2	int
)	O
?	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
1	int
]	O
)	O
:	O
NULL	O
,	O
(	O
argc	int
>=	O
3	int
)	O
?	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
2	int
]	O
)	O
:	O
NULL	O
)	O
;	O
}	O
static	O
void	O
m4_changecom	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
3	int
)	O
)	O
return	O
;	O
set_comment	(*(char),*(char))->(void)
(	O
(	O
argc	int
>=	O
2	int
)	O
?	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
1	int
]	O
)	O
:	O
NULL	O
,	O
(	O
argc	int
>=	O
3	int
)	O
?	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
2	int
]	O
)	O
:	O
NULL	O
)	O
;	O
}	O
static	O
void	O
include	(int,*(*(struct(enum(int,int,int),union(struct`,*`)))),bool)->(void)
(	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
bool	bool
silent	bool
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
name	*(char)
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
)	O
return	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
m4_path_search	(*(char),*(*(char)))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
ARG	O
(	O
1	int
)	O
,	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
silent	bool
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"cannot open `%s'"	*(char)
,	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
retcode	int
=	O
EXIT_FAILURE	int
;	O
}	O
return	O
;	O
}	O
push_file	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),bool)->(void)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
name	*(char)
,	O
true	int
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
}	O
static	O
void	O
m4_include	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
include	(int,*(*(struct(enum(int,int,int),union(struct`,*`)))),bool)->(void)
(	O
argc	int
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
false	int
)	O
;	O
}	O
static	O
void	O
m4_sinclude	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
include	(int,*(*(struct(enum(int,int,int),union(struct`,*`)))),bool)->(void)
(	O
argc	int
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
true	int
)	O
;	O
}	O
static	O
void	O
mkstemp_helper	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(char),*(char),long)->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
const	O
char	O
*	O
me	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
,	O
const	O
char	O
*	O
pattern	*(char)
,	O
size_t	long
len	long
)	O
{	O
int	O
fd	int
;	O
size_t	long
i	int
;	O
char	O
*	O
name	*(char)
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
lquote	struct(*(char),long)
.	O
length	long
)	O
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
pattern	*(char)
,	O
len	long
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
len	long
>	O
0	int
&&	O
i	int
<	O
6	int
;	O
i	int
++	O
)	O
if	O
(	O
pattern	*(char)
[	O
len	long
-	O
i	int
-	O
1	int
]	O
!=	O
'X'	O
)	O
break	O
;	O
obstack_grow0	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
"XXXXXX"	*(char)
,	O
6	int
-	O
i	int
)	O
;	O
name	*(char)
=	O
(	O
char	O
*	O
)	O
obstack_base	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
+	O
lquote	struct(*(char),long)
.	O
length	long
;	O
errno	O
=	O
0	int
;	O
fd	int
=	O
mkstemp	(*(char))->(int)
(	O
name	*(char)
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
M4ERROR	O
(	O
(	O
0	int
,	O
errno	O
,	O
"%s: cannot create tempfile `%s'"	*(char)
,	O
me	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
,	O
pattern	*(char)
)	O
)	O
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
obstack_finish	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
)	O
;	O
}	O
else	O
{	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
obstack_blank	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
-	O
1	int
)	O
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
rquote	struct(*(char),long)
.	O
length	long
)	O
;	O
}	O
}	O
static	O
void	O
m4_maketemp	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
)	O
return	O
;	O
if	O
(	O
no_gnu_extensions	int
)	O
{	O
const	O
char	O
*	O
str	*(char)
=	O
ARG	O
(	O
1	int
)	O
;	O
int	O
len	long
=	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
;	O
int	O
i	int
;	O
int	O
len2	int
;	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"recommend using mkstemp instead"	*(char)
)	O
)	O
;	O
for	O
(	O
i	int
=	O
len	long
;	O
i	int
>	O
1	int
;	O
i	int
--	O
)	O
if	O
(	O
str	*(char)
[	O
i	int
-	O
1	int
]	O
!=	O
'X'	O
)	O
break	O
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
str	*(char)
,	O
i	int
)	O
;	O
str	*(char)
=	O
ntoa	(int,int)->(*(char))
(	O
(	O
int32_t	int
)	O
getpid	()->(int)
(	O
)	O
,	O
10	int
)	O
;	O
len2	int
=	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
;	O
if	O
(	O
len2	int
>	O
len	long
-	O
i	int
)	O
obstack_grow0	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
str	*(char)
+	O
len2	int
-	O
(	O
len	long
-	O
i	int
)	O
,	O
len	long
-	O
i	int
)	O
;	O
else	O
{	O
while	O
(	O
i	int
++	O
<	O
len	long
-	O
len2	int
)	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
'0'	O
)	O
;	O
obstack_grow0	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
str	*(char)
,	O
len2	int
)	O
;	O
}	O
}	O
else	O
mkstemp_helper	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(char),*(char),long)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
ARG	O
(	O
0	int
)	O
,	O
ARG	O
(	O
1	int
)	O
,	O
strlen	(*(char))->(long)
(	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
m4_mkstemp	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
)	O
return	O
;	O
mkstemp_helper	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(char),*(char),long)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
ARG	O
(	O
0	int
)	O
,	O
ARG	O
(	O
1	int
)	O
,	O
strlen	(*(char))->(long)
(	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
m4_errprint	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
dump_args	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))),*(char),bool)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
argc	int
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
" "	*(char)
,	O
false	int
)	O
;	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
'\0'	O
)	O
;	O
debug_flush_files	()->(void)
(	O
)	O
;	O
xfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
m4___file__	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
1	int
)	O
)	O
return	O
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
lquote	struct(*(char),long)
.	O
length	long
)	O
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
current_file	*(char)
,	O
strlen	(*(char))->(long)
(	O
current_file	*(char)
)	O
)	O
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
rquote	struct(*(char),long)
.	O
length	long
)	O
;	O
}	O
static	O
void	O
m4___line__	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
1	int
)	O
)	O
return	O
;	O
shipout_int	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
current_line	int
)	O
;	O
}	O
static	O
void	O
m4___program__	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
1	int
)	O
)	O
return	O
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
lquote	struct(*(char),long)
.	O
length	long
)	O
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
program_name	*(char)
,	O
strlen	(*(char))->(long)
(	O
program_name	*(char)
)	O
)	O
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
rquote	struct(*(char),long)
.	O
length	long
)	O
;	O
}	O
static	O
void	O
M4_GNUC_NORETURN	O
m4_m4exit	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
int	O
exit_code	int
=	O
EXIT_SUCCESS	int
;	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
2	int
)	O
;	O
if	O
(	O
argc	int
>=	O
2	int
&&	O
!	O
numeric_arg	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),*(char),*(int))->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
ARG	O
(	O
1	int
)	O
,	O
&	O
exit_code	int
)	O
)	O
exit_code	int
=	O
EXIT_FAILURE	int
;	O
if	O
(	O
exit_code	int
<	O
0	int
||	O
exit_code	int
>	O
255	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"exit status out of range: `%d'"	*(char)
,	O
exit_code	int
)	O
)	O
;	O
exit_code	int
=	O
EXIT_FAILURE	int
;	O
}	O
debug_set_output	(*(char))->(bool)
(	O
NULL	O
)	O
;	O
debug_flush_files	()->(void)
(	O
)	O
;	O
if	O
(	O
exit_code	int
==	O
EXIT_SUCCESS	int
&&	O
retcode	int
!=	O
EXIT_SUCCESS	int
)	O
exit_code	int
=	O
retcode	int
;	O
if	O
(	O
exit_code	int
!=	O
EXIT_SUCCESS	int
)	O
exit_failure	int
=	O
exit_code	int
;	O
exit	(int)->(void)
(	O
exit_code	int
)	O
;	O
}	O
static	O
void	O
m4_m4wrap	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
if	O
(	O
no_gnu_extensions	int
)	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
ARG	O
(	O
1	int
)	O
,	O
strlen	(*(char))->(long)
(	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
else	O
dump_args	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))),*(char),bool)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
argc	int
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
" "	*(char)
,	O
false	int
)	O
;	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
'\0'	O
)	O
;	O
push_wrapup	(*(char))->(void)
(	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
)	O
;	O
}	O
static	O
void	O
set_trace	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),*(void))->(void)
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
void	O
*	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
{	O
SYMBOL_TRACED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
!=	O
NULL	O
;	O
if	O
(	O
SYMBOL_TYPE	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
==	O
TOKEN_VOID	int
&&	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
==	O
NULL	O
)	O
lookup_symbol	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
SYMBOL_NAME	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
,	O
SYMBOL_POPDEF	int
)	O
;	O
}	O
static	O
void	O
m4_traceon	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
s	long
;	O
int	O
i	int
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
hack_all_symbols	(*((*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),*(void))->(void)),*(void))->(void)
(	O
set_trace	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),*(void))->(void)
,	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
else	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
s	long
=	O
lookup_symbol	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
ARG	O
(	O
i	int
)	O
,	O
SYMBOL_LOOKUP	int
)	O
;	O
if	O
(	O
!	O
s	long
)	O
s	long
=	O
lookup_symbol	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
ARG	O
(	O
i	int
)	O
,	O
SYMBOL_INSERT	int
)	O
;	O
set_trace	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),*(void))->(void)
(	O
s	long
,	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
}	O
}	O
static	O
void	O
m4_traceoff	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
s	long
;	O
int	O
i	int
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
hack_all_symbols	(*((*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),*(void))->(void)),*(void))->(void)
(	O
set_trace	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),*(void))->(void)
,	O
NULL	O
)	O
;	O
else	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
s	long
=	O
lookup_symbol	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
i	int
]	O
)	O
,	O
SYMBOL_LOOKUP	int
)	O
;	O
if	O
(	O
s	long
!=	O
NULL	O
)	O
set_trace	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),*(void))->(void)
(	O
s	long
,	O
NULL	O
)	O
;	O
}	O
}	O
static	O
void	O
m4_debugmode	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
int	O
new_debug_level	int
;	O
int	O
change_flag	int
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
2	int
)	O
)	O
return	O
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
debug_level	int
=	O
0	int
;	O
else	O
{	O
if	O
(	O
ARG	O
(	O
1	int
)	O
[	O
0	int
]	O
==	O
'+'	O
||	O
ARG	O
(	O
1	int
)	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
change_flag	int
=	O
ARG	O
(	O
1	int
)	O
[	O
0	int
]	O
;	O
new_debug_level	int
=	O
debug_decode	(*(char))->(int)
(	O
ARG	O
(	O
1	int
)	O
+	O
1	int
)	O
;	O
}	O
else	O
{	O
change_flag	int
=	O
0	int
;	O
new_debug_level	int
=	O
debug_decode	(*(char))->(int)
(	O
ARG	O
(	O
1	int
)	O
)	O
;	O
}	O
if	O
(	O
new_debug_level	int
<	O
0	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Debugmode: bad debug flags: `%s'"	*(char)
,	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
else	O
{	O
switch	O
(	O
change_flag	int
)	O
{	O
case	O
0	int
:	O
debug_level	int
=	O
new_debug_level	int
;	O
break	O
;	O
case	O
'+'	O
:	O
debug_level	int
|=	O
new_debug_level	int
;	O
break	O
;	O
case	O
'-'	O
:	O
debug_level	int
&=	O
~	O
new_debug_level	int
;	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad flag in m4_debugmode ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
m4_debugfile	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
2	int
)	O
)	O
return	O
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
debug_set_output	(*(char))->(bool)
(	O
NULL	O
)	O
;	O
else	O
if	O
(	O
!	O
debug_set_output	(*(char))->(bool)
(	O
ARG	O
(	O
1	int
)	O
)	O
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"cannot set debug file `%s'"	*(char)
,	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
m4_len	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
)	O
return	O
;	O
shipout_int	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
strlen	(*(char))->(long)
(	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
m4_index	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
const	O
char	O
*	O
haystack	*(char)
;	O
const	O
char	O
*	O
result	*(*(char))
;	O
int	O
retval	int
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
3	int
,	O
3	int
)	O
)	O
{	O
if	O
(	O
argc	int
==	O
2	int
)	O
shipout_int	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
0	int
)	O
;	O
return	O
;	O
}	O
haystack	*(char)
=	O
ARG	O
(	O
1	int
)	O
;	O
result	*(*(char))
=	O
strstr	(*(char),*(char))->(*(char))
(	O
haystack	*(char)
,	O
ARG	O
(	O
2	int
)	O
)	O
;	O
retval	int
=	O
result	*(*(char))
?	O
result	*(*(char))
-	O
haystack	*(char)
:	O
-	O
1	int
;	O
shipout_int	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
retval	int
)	O
;	O
}	O
static	O
void	O
m4_substr	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
int	O
start	*(int)
=	O
0	int
;	O
int	O
length	long
,	O
avail	long
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
3	int
,	O
4	int
)	O
)	O
{	O
if	O
(	O
argc	int
==	O
2	int
)	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
ARG	O
(	O
1	int
)	O
,	O
strlen	(*(char))->(long)
(	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
length	long
=	O
avail	long
=	O
strlen	(*(char))->(long)
(	O
ARG	O
(	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
numeric_arg	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),*(char),*(int))->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
ARG	O
(	O
2	int
)	O
,	O
&	O
start	*(int)
)	O
)	O
return	O
;	O
if	O
(	O
argc	int
>=	O
4	int
&&	O
!	O
numeric_arg	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),*(char),*(int))->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
ARG	O
(	O
3	int
)	O
,	O
&	O
length	long
)	O
)	O
return	O
;	O
if	O
(	O
start	*(int)
<	O
0	int
||	O
length	long
<=	O
0	int
||	O
start	*(int)
>=	O
avail	long
)	O
return	O
;	O
if	O
(	O
start	*(int)
+	O
length	long
>	O
avail	long
)	O
length	long
=	O
avail	long
-	O
start	*(int)
;	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
ARG	O
(	O
1	int
)	O
+	O
start	*(int)
,	O
length	long
)	O
;	O
}	O
static	O
const	O
char	O
*	O
expand_ranges	(*(char),*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))->(*(char))
(	O
const	O
char	O
*	O
s	long
,	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
{	O
unsigned	O
char	O
from	char
;	O
unsigned	O
char	O
to	char
;	O
for	O
(	O
from	char
=	O
'\0'	O
;	O
*	O
s	long
!=	O
'\0'	O
;	O
from	char
=	O
to_uchar	O
(	O
*	O
s	long
++	O
)	O
)	O
{	O
if	O
(	O
*	O
s	long
==	O
'-'	O
&&	O
from	char
!=	O
'\0'	O
)	O
{	O
to	char
=	O
to_uchar	O
(	O
*	O
++	O
s	long
)	O
;	O
if	O
(	O
to	char
==	O
'\0'	O
)	O
{	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
'-'	O
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
from	char
<=	O
to	char
)	O
{	O
while	O
(	O
from	char
++	O
<	O
to	char
)	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
from	char
)	O
;	O
}	O
else	O
{	O
while	O
(	O
--	O
from	char
>=	O
to	char
)	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
from	char
)	O
;	O
}	O
}	O
else	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
*	O
s	long
)	O
;	O
}	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
'\0'	O
)	O
;	O
return	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
}	O
static	O
void	O
m4_translit	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
const	O
char	O
*	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
=	O
ARG	O
(	O
1	int
)	O
;	O
const	O
char	O
*	O
from	char
=	O
ARG	O
(	O
2	int
)	O
;	O
const	O
char	O
*	O
to	char
;	O
char	O
map	array(char)
[	O
UCHAR_MAX	O
+	O
1	int
]	O
;	O
char	O
found	array(char)
[	O
UCHAR_MAX	O
+	O
1	int
]	O
;	O
unsigned	O
char	O
ch	int
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
3	int
,	O
4	int
)	O
||	O
!	O
*	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
||	O
!	O
*	O
from	char
)	O
{	O
if	O
(	O
2	int
<=	O
argc	int
)	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
,	O
strlen	(*(char))->(long)
(	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
)	O
;	O
return	O
;	O
}	O
to	char
=	O
ARG	O
(	O
3	int
)	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
to	char
,	O
'-'	O
)	O
!=	O
NULL	O
)	O
{	O
to	char
=	O
expand_ranges	(*(char),*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))->(*(char))
(	O
to	char
,	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
assert	O
(	O
to	char
&&	O
*	O
to	char
)	O
;	O
}	O
if	O
(	O
!	O
from	char
[	O
1	int
]	O
||	O
!	O
from	char
[	O
2	int
]	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
;	O
while	O
(	O
(	O
p	*(void)
=	O
(	O
char	O
*	O
)	O
memchr2	(*(void),int,int,long)->(*(void))
(	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
,	O
from	char
[	O
0	int
]	O
,	O
from	char
[	O
1	int
]	O
,	O
len	long
)	O
)	O
)	O
{	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
,	O
p	*(void)
-	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
;	O
len	long
-=	O
p	*(void)
-	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
;	O
if	O
(	O
!	O
len	long
)	O
return	O
;	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
=	O
p	*(void)
+	O
1	int
;	O
len	long
--	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
from	char
[	O
0	int
]	O
&&	O
to	char
[	O
0	int
]	O
)	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
to	char
[	O
0	int
]	O
)	O
;	O
else	O
if	O
(	O
*	O
p	*(void)
==	O
from	char
[	O
1	int
]	O
&&	O
to	char
[	O
0	int
]	O
&&	O
to	char
[	O
1	int
]	O
)	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
to	char
[	O
1	int
]	O
)	O
;	O
}	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
,	O
len	long
)	O
;	O
return	O
;	O
}	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
from	char
,	O
'-'	O
)	O
!=	O
NULL	O
)	O
{	O
from	char
=	O
expand_ranges	(*(char),*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))->(*(char))
(	O
from	char
,	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
assert	O
(	O
from	char
&&	O
*	O
from	char
)	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
map	array(char)
,	O
0	int
,	O
sizeof	O
map	array(char)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
found	array(char)
,	O
0	int
,	O
sizeof	O
found	array(char)
)	O
;	O
for	O
(	O
;	O
(	O
ch	int
=	O
*	O
from	char
)	O
!=	O
'\0'	O
;	O
from	char
++	O
)	O
{	O
if	O
(	O
!	O
found	array(char)
[	O
ch	int
]	O
)	O
{	O
found	array(char)
[	O
ch	int
]	O
=	O
1	int
;	O
map	array(char)
[	O
ch	int
]	O
=	O
*	O
to	char
;	O
}	O
if	O
(	O
*	O
to	char
!=	O
'\0'	O
)	O
to	char
++	O
;	O
}	O
for	O
(	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
=	O
ARG	O
(	O
1	int
)	O
;	O
(	O
ch	int
=	O
*	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
!=	O
'\0'	O
;	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
++	O
)	O
{	O
if	O
(	O
!	O
found	array(char)
[	O
ch	int
]	O
)	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
ch	int
)	O
;	O
else	O
if	O
(	O
map	array(char)
[	O
ch	int
]	O
)	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
map	array(char)
[	O
ch	int
]	O
)	O
;	O
}	O
}	O
static	O
void	O
m4_format	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
expand_format	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
argc	int
-	O
1	int
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
+	O
1	int
)	O
;	O
}	O
static	O
int	O
substitute_warned	int
=	O
0	int
;	O
static	O
void	O
substitute	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(char),*(char),*(struct(int,*(int),*(int))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
const	O
char	O
*	O
victim	*(char)
,	O
const	O
char	O
*	O
repl	*(char)
,	O
struct	O
re_registers	struct(int,*(int),*(int))
*	O
regs	*(struct(int,*(int),*(int)))
)	O
{	O
int	O
ch	int
;	O
__re_size_t	int
ind	int
;	O
while	O
(	O
1	int
)	O
{	O
const	O
char	O
*	O
backslash	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
repl	*(char)
,	O
'\\'	O
)	O
;	O
if	O
(	O
!	O
backslash	*(char)
)	O
{	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
repl	*(char)
,	O
strlen	(*(char))->(long)
(	O
repl	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
repl	*(char)
,	O
backslash	*(char)
-	O
repl	*(char)
)	O
;	O
repl	*(char)
=	O
backslash	*(char)
;	O
ch	int
=	O
*	O
++	O
repl	*(char)
;	O
switch	O
(	O
ch	int
)	O
{	O
case	O
'0'	O
:	O
if	O
(	O
!	O
substitute_warned	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: \\0 will disappear, use \\& instead in replacements"	*(char)
)	O
)	O
;	O
substitute_warned	int
=	O
1	int
;	O
}	O
case	O
'&'	O
:	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
victim	*(char)
+	O
regs	*(struct(int,*(int),*(int)))
->	O
start	*(int)
[	O
0	int
]	O
,	O
regs	*(struct(int,*(int),*(int)))
->	O
end	*(int)
[	O
0	int
]	O
-	O
regs	*(struct(int,*(int),*(int)))
->	O
start	*(int)
[	O
0	int
]	O
)	O
;	O
repl	*(char)
++	O
;	O
break	O
;	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
ind	int
=	O
ch	int
-=	O
'0'	O
;	O
if	O
(	O
regs	*(struct(int,*(int),*(int)))
->	O
num_regs	int
-	O
1	int
<=	O
ind	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: sub-expression %d not present"	*(char)
,	O
ch	int
)	O
)	O
;	O
else	O
if	O
(	O
regs	*(struct(int,*(int),*(int)))
->	O
end	*(int)
[	O
ch	int
]	O
>	O
0	int
)	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
victim	*(char)
+	O
regs	*(struct(int,*(int),*(int)))
->	O
start	*(int)
[	O
ch	int
]	O
,	O
regs	*(struct(int,*(int),*(int)))
->	O
end	*(int)
[	O
ch	int
]	O
-	O
regs	*(struct(int,*(int),*(int)))
->	O
start	*(int)
[	O
ch	int
]	O
)	O
;	O
repl	*(char)
++	O
;	O
break	O
;	O
case	O
'\0'	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: trailing \\ ignored in replacement"	*(char)
)	O
)	O
;	O
return	O
;	O
default	O
:	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
ch	int
)	O
;	O
repl	*(char)
++	O
;	O
break	O
;	O
}	O
}	O
}	O
void	O
init_pattern_buffer	(*(struct),*(struct))->(void)
(	O
struct	O
re_pattern_buffer	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
*	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
struct	O
re_registers	struct(int,*(int),*(int))
*	O
regs	*(struct(int,*(int),*(int)))
)	O
{	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
->	O
translate	*(char)
=	O
NULL	O
;	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
->	O
fastmap	*(char)
=	O
NULL	O
;	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
->	O
buffer	*(struct)
=	O
NULL	O
;	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
->	O
allocated	long
=	O
0	int
;	O
if	O
(	O
regs	*(struct(int,*(int),*(int)))
)	O
{	O
regs	*(struct(int,*(int),*(int)))
->	O
start	*(int)
=	O
NULL	O
;	O
regs	*(struct(int,*(int),*(int)))
->	O
end	*(int)
=	O
NULL	O
;	O
}	O
}	O
static	O
void	O
m4_regexp	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
const	O
char	O
*	O
victim	*(char)
;	O
const	O
char	O
*	O
regexp	*(char)
;	O
const	O
char	O
*	O
repl	*(char)
;	O
struct	O
re_pattern_buffer	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
;	O
struct	O
re_registers	struct(int,*(int),*(int))
regs	*(struct(int,*(int),*(int)))
;	O
const	O
char	O
*	O
msg	*(char)
;	O
int	O
startpos	int
;	O
int	O
length	long
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
3	int
,	O
4	int
)	O
)	O
{	O
if	O
(	O
argc	int
==	O
2	int
)	O
shipout_int	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
0	int
)	O
;	O
return	O
;	O
}	O
victim	*(char)
=	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
1	int
]	O
)	O
;	O
regexp	*(char)
=	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
2	int
]	O
)	O
;	O
init_pattern_buffer	(*(struct),*(struct))->(void)
(	O
&	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
&	O
regs	*(struct(int,*(int),*(int)))
)	O
;	O
msg	*(char)
=	O
re_compile_pattern	(*(char),long,*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)))->(*(char))
(	O
regexp	*(char)
,	O
strlen	(*(char))->(long)
(	O
regexp	*(char)
)	O
,	O
&	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
)	O
;	O
if	O
(	O
msg	*(char)
!=	O
NULL	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"bad regular expression: `%s': %s"	*(char)
,	O
regexp	*(char)
,	O
msg	*(char)
)	O
)	O
;	O
free_pattern_buffer	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(struct(int,*(int),*(int))))->(void)
(	O
&	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
&	O
regs	*(struct(int,*(int),*(int)))
)	O
;	O
return	O
;	O
}	O
length	long
=	O
strlen	(*(char))->(long)
(	O
victim	*(char)
)	O
;	O
startpos	int
=	O
re_search	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int,int,int,*(struct(int,*(int),*(int))))->(int)
(	O
&	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
victim	*(char)
,	O
length	long
,	O
0	int
,	O
length	long
,	O
argc	int
==	O
3	int
?	O
NULL	O
:	O
&	O
regs	*(struct(int,*(int),*(int)))
)	O
;	O
if	O
(	O
startpos	int
==	O
-	O
2	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"error matching regular expression `%s'"	*(char)
,	O
regexp	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
argc	int
==	O
3	int
)	O
shipout_int	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
startpos	int
)	O
;	O
else	O
if	O
(	O
startpos	int
>=	O
0	int
)	O
{	O
repl	*(char)
=	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
3	int
]	O
)	O
;	O
substitute	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(char),*(char),*(struct(int,*(int),*(int))))->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
victim	*(char)
,	O
repl	*(char)
,	O
&	O
regs	*(struct(int,*(int),*(int)))
)	O
;	O
}	O
free_pattern_buffer	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(struct(int,*(int),*(int))))->(void)
(	O
&	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
&	O
regs	*(struct(int,*(int),*(int)))
)	O
;	O
}	O
static	O
void	O
m4_patsubst	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
const	O
char	O
*	O
victim	*(char)
;	O
const	O
char	O
*	O
regexp	*(char)
;	O
struct	O
re_pattern_buffer	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
;	O
struct	O
re_registers	struct(int,*(int),*(int))
regs	*(struct(int,*(int),*(int)))
;	O
const	O
char	O
*	O
msg	*(char)
;	O
int	O
matchpos	int
;	O
int	O
offset	long
;	O
int	O
length	long
;	O
if	O
(	O
bad_argc	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int,int,int)->(bool)
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
,	O
argc	int
,	O
3	int
,	O
4	int
)	O
)	O
{	O
if	O
(	O
argc	int
==	O
2	int
)	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
ARG	O
(	O
1	int
)	O
,	O
strlen	(*(char))->(long)
(	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
regexp	*(char)
=	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
2	int
]	O
)	O
;	O
init_pattern_buffer	(*(struct),*(struct))->(void)
(	O
&	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
&	O
regs	*(struct(int,*(int),*(int)))
)	O
;	O
msg	*(char)
=	O
re_compile_pattern	(*(char),long,*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)))->(*(char))
(	O
regexp	*(char)
,	O
strlen	(*(char))->(long)
(	O
regexp	*(char)
)	O
,	O
&	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
)	O
;	O
if	O
(	O
msg	*(char)
!=	O
NULL	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"bad regular expression `%s': %s"	*(char)
,	O
regexp	*(char)
,	O
msg	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
.	O
buffer	*(struct)
)	O
;	O
return	O
;	O
}	O
victim	*(char)
=	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
1	int
]	O
)	O
;	O
length	long
=	O
strlen	(*(char))->(long)
(	O
victim	*(char)
)	O
;	O
offset	long
=	O
0	int
;	O
while	O
(	O
offset	long
<=	O
length	long
)	O
{	O
matchpos	int
=	O
re_search	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int,int,int,*(struct(int,*(int),*(int))))->(int)
(	O
&	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
victim	*(char)
,	O
length	long
,	O
offset	long
,	O
length	long
-	O
offset	long
,	O
&	O
regs	*(struct(int,*(int),*(int)))
)	O
;	O
if	O
(	O
matchpos	int
<	O
0	int
)	O
{	O
if	O
(	O
matchpos	int
==	O
-	O
2	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"error matching regular expression `%s'"	*(char)
,	O
regexp	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
offset	long
<	O
length	long
)	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
victim	*(char)
+	O
offset	long
,	O
length	long
-	O
offset	long
)	O
;	O
break	O
;	O
}	O
if	O
(	O
matchpos	int
>	O
offset	long
)	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
victim	*(char)
+	O
offset	long
,	O
matchpos	int
-	O
offset	long
)	O
;	O
substitute	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(char),*(char),*(struct(int,*(int),*(int))))->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
victim	*(char)
,	O
ARG	O
(	O
3	int
)	O
,	O
&	O
regs	*(struct(int,*(int),*(int)))
)	O
;	O
offset	long
=	O
regs	*(struct(int,*(int),*(int)))
.	O
end	*(int)
[	O
0	int
]	O
;	O
if	O
(	O
regs	*(struct(int,*(int),*(int)))
.	O
start	*(int)
[	O
0	int
]	O
==	O
regs	*(struct(int,*(int),*(int)))
.	O
end	*(int)
[	O
0	int
]	O
)	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
victim	*(char)
[	O
offset	long
++	O
]	O
)	O
;	O
}	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
'\0'	O
)	O
;	O
free_pattern_buffer	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(struct(int,*(int),*(int))))->(void)
(	O
&	O
buf	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
&	O
regs	*(struct(int,*(int),*(int)))
)	O
;	O
}	O
void	O
m4_placeholder	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"builtin `%s' requested by frozen file is not supported"	*(char)
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
}	O
void	O
expand_user_macro	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
const	O
char	O
*	O
text	*(char)
=	O
SYMBOL_TEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
int	O
i	int
;	O
while	O
(	O
1	int
)	O
{	O
const	O
char	O
*	O
dollar	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
text	*(char)
,	O
'$'	O
)	O
;	O
if	O
(	O
!	O
dollar	*(char)
)	O
{	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
text	*(char)
,	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
text	*(char)
,	O
dollar	*(char)
-	O
text	*(char)
)	O
;	O
text	*(char)
=	O
dollar	*(char)
;	O
switch	O
(	O
*	O
++	O
text	*(char)
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
if	O
(	O
no_gnu_extensions	int
)	O
{	O
i	int
=	O
*	O
text	*(char)
++	O
-	O
'0'	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
isdigit	(int)->(int)
(	O
to_uchar	O
(	O
*	O
text	*(char)
)	O
)	O
;	O
text	*(char)
++	O
)	O
i	int
=	O
i	int
*	O
10	int
+	O
(	O
*	O
text	*(char)
-	O
'0'	O
)	O
;	O
}	O
if	O
(	O
i	int
<	O
argc	int
)	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
i	int
]	O
)	O
,	O
strlen	(*(char))->(long)
(	O
TOKEN_DATA_TEXT	O
(	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
i	int
]	O
)	O
)	O
)	O
;	O
break	O
;	O
case	O
'#'	O
:	O
shipout_int	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
argc	int
-	O
1	int
)	O
;	O
text	*(char)
++	O
;	O
break	O
;	O
case	O
'*'	O
:	O
case	O
'@'	O
:	O
dump_args	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union(struct`,*`)))),*(char),bool)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
argc	int
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
","	*(char)
,	O
*	O
text	*(char)
==	O
'@'	O
)	O
;	O
text	*(char)
++	O
;	O
break	O
;	O
default	O
:	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
'$'	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
