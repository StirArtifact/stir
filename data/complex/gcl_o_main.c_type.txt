static	O
void	O
init_main	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
initlisp	()->(void)
(	O
void	O
)	O
;	O
static	O
int	O
multiply_stacks	(int)->(int)
(	O
int	O
)	O
;	O
bool	O
saving_system	int
=	O
FALSE	O
;	O
char	O
*	O
system_directory	*(char)
;	O
char	O
stdin_buf	char
[	O
BUFSIZ	O
+	O
EXTRA_BUFSIZE	int
]	O
;	O
char	O
stdout_buf	char
[	O
BUFSIZ	O
+	O
EXTRA_BUFSIZE	int
]	O
;	O
int	O
debug	int
;	O
int	O
raw_image	int
=	O
TRUE	O
;	O
bool	O
GBC_enable	int
=	O
FALSE	O
;	O
long	O
real_maxpage	long
;	O
object	O
sSAlisp_maxpagesA	int
;	O
object	O
siClisp_pagesize	int
;	O
object	O
sStop_level	int
;	O
object	O
sSAmultiply_stacksA	int
;	O
int	O
stack_multiple	int
=	O
1	int
;	O
static	O
object	O
stack_space	int
;	O
void	O
install_segmentation_catcher	()->(void)
(	O
void	O
)	O
;	O
int	O
cstack_dir	(int)->(int)
(	O
fixnum	O
j	int
)	O
{	O
static	O
fixnum	O
n	int
;	O
if	O
(	O
!	O
n	int
)	O
{	O
n	int
=	O
1	int
;	O
return	O
cstack_dir	(int)->(int)
(	O
(	O
fixnum	O
)	O
&	O
j	int
)	O
;	O
}	O
return	O
(	O
fixnum	O
)	O
&	O
j	int
<	O
j	int
?	O
-	O
1	int
:	O
1	int
;	O
}	O
fixnum	O
log_maxpage_bound	int
=	O
sizeof	O
(	O
fixnum	O
)	O
*	O
8	int
-	O
1	int
;	O
inline	O
int	O
mbrk	(*(void))->(int)
(	O
void	O
*	O
v	*(void)
)	O
{	O
ufixnum	O
uv	O
=	O
(	O
ufixnum	O
)	O
v	*(void)
,	O
uc	O
=	O
(	O
ufixnum	O
)	O
sbrk	(long)->(*(void))
(	O
0	int
)	O
,	O
ux	O
,	O
um	O
;	O
fixnum	O
m	int
=	O
(	O
(	O
1UL	int
<<	O
(	O
sizeof	O
(	O
fixnum	O
)	O
*	O
8	int
-	O
1	int
)	O
)	O
-	O
1	int
)	O
;	O
if	O
(	O
uv	O
<	O
uc	O
)	O
{	O
um	O
=	O
uv	O
;	O
ux	O
=	O
uc	O
;	O
}	O
else	O
{	O
um	O
=	O
uc	O
;	O
ux	O
=	O
uv	O
;	O
}	O
if	O
(	O
(	O
(	O
fixnum	O
)	O
(	O
ux	O
-	O
um	O
)	O
)	O
<	O
0	int
)	O
return	O
mbrk	(*(void))->(int)
(	O
(	O
void	O
*	O
)	O
uc	O
+	O
(	O
uv	O
<	O
uc	O
?	O
-	O
m	int
:	O
m	int
)	O
)	O
||	O
mbrk	(*(void))->(int)
(	O
v	*(void)
)	O
;	O
return	O
uc	O
==	O
(	O
ufixnum	O
)	O
sbrk	(long)->(*(void))
(	O
uv	O
-	O
uc	O
)	O
?	O
0	int
:	O
-	O
1	int
;	O
}	O
ufixnum	O
get_phys_pages_no_malloc	()->(int)
(	O
void	O
)	O
{	O
int	O
l	int
;	O
char	O
b	char
[	O
PAGESIZE	O
]	O
,	O
*	O
c	O
;	O
const	O
char	O
*	O
k	*(char)
=	O
"MemTotal:"	*(char)
,	O
*	O
f	*(char)
=	O
"/proc/meminfo"	*(char)
;	O
ufixnum	O
res	O
=	O
0	int
,	O
n	int
;	O
if	O
(	O
(	O
l	int
=	O
open	(*(char),int)->(int)
(	O
f	*(char)
,	O
O_RDONLY	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
n	int
=	O
read	(int,*(void),long)->(long)
(	O
l	int
,	O
b	char
,	O
sizeof	O
(	O
b	char
)	O
)	O
)	O
<	O
sizeof	O
(	O
b	char
)	O
&&	O
!	O
(	O
b	char
[	O
n	int
]	O
=	O
0	int
)	O
&&	O
(	O
c	O
=	O
strstr	(*(char),*(char))->(*(char))
(	O
b	char
,	O
k	*(char)
)	O
)	O
&&	O
sscanf	O
(	O
c	O
+	O
strlen	(*(char))->(long)
(	O
k	*(char)
)	O
,	O
"%lu"	*(char)
,	O
&	O
n	int
)	O
==	O
1	int
)	O
res	O
=	O
n	int
;	O
close	(int)->(int)
(	O
l	int
)	O
;	O
}	O
return	O
res	O
>>	O
(	O
PAGEWIDTH	O
-	O
10	int
)	O
;	O
}	O
int	O
update_real_maxpage	()->(int)
(	O
void	O
)	O
{	O
ufixnum	O
i	int
,	O
j	int
,	O
k	*(char)
;	O
void	O
*	O
end	*(void)
,	O
*	O
cur	*(void)
,	O
*	O
beg	*(void)
;	O
massert	()->(int)
(	O
cur	*(void)
=	O
sbrk	(long)->(*(void))
(	O
0	int
)	O
)	O
;	O
beg	*(void)
=	O
data_start	O
?	O
data_start	O
:	O
cur	*(void)
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
(	O
1L	int
<<	O
log_maxpage_bound	int
)	O
;	O
j	int
>	O
PAGESIZE	O
;	O
j	int
>>=	O
1	int
)	O
if	O
(	O
(	O
end	*(void)
=	O
beg	*(void)
+	O
i	int
+	O
j	int
-	O
PAGESIZE	O
)	O
>	O
cur	*(void)
)	O
if	O
(	O
!	O
mbrk	(*(void))->(int)
(	O
end	*(void)
)	O
)	O
{	O
real_maxpage	long
=	O
page	()->(int)
(	O
end	*(void)
)	O
;	O
i	int
+=	O
j	int
;	O
}	O
massert	()->(int)
(	O
!	O
mbrk	(*(void))->(int)
(	O
cur	*(void)
)	O
)	O
;	O
phys_pages	O
=	O
get_phys_pages_no_malloc	()->(int)
(	O
)	O
;	O
available_pages	O
=	O
real_maxpage	long
-	O
page	()->(int)
(	O
beg	*(void)
)	O
;	O
for	O
(	O
i	int
=	O
t_start	O
,	O
j	int
=	O
0	int
;	O
i	int
<	O
t_other	O
;	O
i	int
++	O
)	O
{	O
k	*(char)
=	O
tm_table	O
[	O
i	int
]	O
.	O
tm_maxpage	O
;	O
if	O
(	O
tm_table	O
[	O
i	int
]	O
.	O
tm_type	O
==	O
t_relocatable	O
)	O
k	*(char)
*=	O
2	int
;	O
else	O
j	int
+=	O
k	*(char)
;	O
available_pages	O
-=	O
k	*(char)
;	O
}	O
resv_pages	O
=	O
40	int
<	O
available_pages	O
?	O
40	int
:	O
available_pages	O
;	O
available_pages	O
-=	O
resv_pages	O
;	O
new_holepage	long
=	O
available_pages	O
/	O
starting_hole_div	O
;	O
k	*(char)
=	O
available_pages	O
/	O
20	int
;	O
j	int
*=	O
starting_relb_heap_mult	O
;	O
j	int
=	O
j	int
<	O
k	*(char)
?	O
j	int
:	O
k	*(char)
;	O
if	O
(	O
maxrbpage	O
<	O
j	int
)	O
set_tm_maxpage	()->(int)
(	O
tm_table	O
+	O
t_relocatable	O
,	O
j	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
minimize_image	()->(int)
(	O
void	O
)	O
{	O
int	O
in_sgc	int
=	O
0	int
;	O
extern	O
long	O
new_holepage	long
;	O
fixnum	O
old_holepage	O
=	O
new_holepage	long
,	O
i	int
;	O
void	O
*	O
new	*(void)
;	O
if	O
(	O
in_sgc	int
)	O
sgc_quit	()->(int)
(	O
)	O
;	O
holepage	O
=	O
new_holepage	long
=	O
1	int
;	O
GBC	()->(int)
(	O
t_relocatable	O
)	O
;	O
if	O
(	O
in_sgc	int
)	O
sgc_start	()->(int)
(	O
)	O
;	O
new	*(void)
=	O
(	O
void	O
*	O
)	O
(	O
(	O
(	O
(	O
(	O
ufixnum	O
)	O
rb_pointer	O
)	O
+	O
PAGESIZE	O
-	O
1	int
)	O
/	O
PAGESIZE	O
)	O
*	O
PAGESIZE	O
)	O
;	O
core_end	O
=	O
new	*(void)
;	O
rb_end	O
=	O
rb_limit	O
=	O
new	*(void)
;	O
set_tm_maxpage	()->(int)
(	O
tm_table	O
+	O
t_relocatable	O
,	O
(	O
nrbpage	O
=	O
(	O
(	O
char	O
*	O
)	O
new	*(void)
-	O
REAL_RB_START	O
)	O
/	O
PAGESIZE	O
)	O
)	O
;	O
new_holepage	long
=	O
old_holepage	O
;	O
cbgbccount	O
=	O
tm_table	O
[	O
t_contiguous	O
]	O
.	O
tm_adjgbccnt	O
=	O
tm_table	O
[	O
t_contiguous	O
]	O
.	O
tm_opt_maxpage	O
=	O
0	int
;	O
rbgbccount	O
=	O
tm_table	O
[	O
t_relocatable	O
]	O
.	O
tm_adjgbccnt	O
=	O
tm_table	O
[	O
t_relocatable	O
]	O
.	O
tm_opt_maxpage	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
int	O
)	O
t_end	O
;	O
i	int
++	O
)	O
tm_table	O
[	O
i	int
]	O
.	O
tm_gbccount	O
=	O
tm_table	O
[	O
i	int
]	O
.	O
tm_adjgbccnt	O
=	O
tm_table	O
[	O
i	int
]	O
.	O
tm_opt_maxpage	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"SET-LOG-MAXPAGE-BOUND"	*(char)
,	O
object	O
,	O
fSset_log_maxpage_bound	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
II	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
l	int
)	O
,	O
""	*(char)
)	O
{	O
void	O
*	O
end	*(void)
,	O
*	O
dend	*(void)
;	O
fixnum	O
def	O
=	O
sizeof	O
(	O
fixnum	O
)	O
*	O
8	int
-	O
1	int
;	O
l	int
=	O
l	int
<	O
def	O
?	O
l	int
:	O
def	O
;	O
end	*(void)
=	O
data_start	O
+	O
(	O
1L	int
<<	O
l	int
)	O
-	O
PAGESIZE	O
;	O
GBC	()->(int)
(	O
t_relocatable	O
)	O
;	O
dend	*(void)
=	O
heap_end	O
+	O
PAGESIZE	O
+	O
(	O
(	O
(	O
rb_pointer	O
-	O
REAL_RB_START	O
)	O
+	O
PAGESIZE	O
-	O
1	int
)	O
&	O
(	O
-	O
PAGESIZE	O
)	O
)	O
;	O
if	O
(	O
end	*(void)
>=	O
dend	*(void)
)	O
{	O
minimize_image	()->(int)
(	O
)	O
;	O
log_maxpage_bound	int
=	O
l	int
;	O
update_real_maxpage	()->(int)
(	O
)	O
;	O
}	O
return	O
(	O
object	O
)	O
log_maxpage_bound	int
;	O
}	O
int	O
main	(int,*(*(char)),*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
*	O
envp	*(*(char))
)	O
{	O
gcl_init_alloc	()->(int)
(	O
&	O
argv	*(*(char))
)	O
;	O
kcl_self	O
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
*	O
argv	*(*(char))
=	O
kcl_self	O
;	O
setbuf	()->(int)
(	O
stdin	O
,	O
stdin_buf	char
)	O
;	O
setbuf	()->(int)
(	O
stdout	O
,	O
stdout_buf	char
)	O
;	O
ARGC	O
=	O
argc	int
;	O
ARGV	O
=	O
argv	*(*(char))
;	O
ENVP	O
=	O
envp	*(*(char))
;	O
vs_top	O
=	O
vs_base	O
=	O
vs_org	O
;	O
ihs_top	O
=	O
ihs_org	O
-	O
1	int
;	O
bds_top	O
=	O
bds_org	O
-	O
1	int
;	O
frs_top	O
=	O
frs_org	O
-	O
1	int
;	O
if	O
(	O
raw_image	int
)	O
{	O
printf	O
(	O
"GCL (GNU Common Lisp)  %s  %ld pages\n"	*(char)
,	O
LISP_IMPLEMENTATION_VERSION	*(char)
,	O
real_maxpage	long
)	O
;	O
fflush	()->(int)
(	O
stdout	O
)	O
;	O
if	O
(	O
argc	int
>	O
1	int
)	O
{	O
massert	()->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
[	O
strlen	(*(char))->(long)
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
-	O
1	int
]	O
==	O
'/'	O
)	O
;	O
system_directory	*(char)
=	O
argv	*(*(char))
[	O
1	int
]	O
;	O
}	O
initlisp	()->(void)
(	O
)	O
;	O
lex_new	()->(int)
(	O
)	O
;	O
GBC_enable	int
=	O
TRUE	O
;	O
gcl_init_init	()->(int)
(	O
)	O
;	O
sLApackageA	O
->	O
s	*(char)
.	O
s_dbind	O
=	O
user_package	O
;	O
}	O
else	O
{	O
terminal_io	O
->	O
sm	O
.	O
sm_object0	O
->	O
sm	O
.	O
sm_fp	O
=	O
stdin	O
;	O
terminal_io	O
->	O
sm	O
.	O
sm_object1	O
->	O
sm	O
.	O
sm_fp	O
=	O
stdout	O
;	O
gcl_init_big1	()->(int)
(	O
)	O
;	O
}	O
sSAlisp_maxpagesA	int
->	O
s	*(char)
.	O
s_dbind	O
=	O
make_fixnum	()->(int)
(	O
real_maxpage	long
)	O
;	O
ihs_push	()->(int)
(	O
Cnil	O
)	O
;	O
lex_new	()->(int)
(	O
)	O
;	O
vs_base	O
=	O
vs_top	O
;	O
interrupt_enable	O
=	O
TRUE	O
;	O
install_default_signals	()->(int)
(	O
)	O
;	O
do	O
super_funcall	()->(int)
(	O
sStop_level	int
)	O
;	O
while	O
(	O
type_of	()->(int)
(	O
sSAmultiply_stacksA	int
->	O
s	*(char)
.	O
s_dbind	O
)	O
==	O
t_fixnum	O
&&	O
multiply_stacks	(int)->(int)
(	O
fix	()->(int)
(	O
sSAmultiply_stacksA	int
->	O
s	*(char)
.	O
s_dbind	O
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
install_segmentation_catcher	()->(void)
(	O
void	O
)	O
{	O
unblock_signals	()->(int)
(	O
SIGSEGV	O
,	O
SIGSEGV	O
)	O
;	O
unblock_signals	()->(int)
(	O
SIGBUS	O
,	O
SIGBUS	O
)	O
;	O
(	O
void	O
)	O
gcl_signal	()->(int)
(	O
SIGSEGV	O
,	O
segmentation_catcher	(int)->(void)
)	O
;	O
(	O
void	O
)	O
gcl_signal	()->(int)
(	O
SIGBUS	O
,	O
segmentation_catcher	(int)->(void)
)	O
;	O
}	O
int	O
catch_fatal	int
=	O
1	int
;	O
void	O
error	(*(char))->(void)
(	O
char	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
catch_fatal	int
>	O
0	int
&&	O
interrupt_enable	O
)	O
{	O
catch_fatal	int
=	O
-	O
1	int
;	O
{	O
install_segmentation_catcher	()->(void)
(	O
)	O
;	O
}	O
FEerror	()->(int)
(	O
"Caught fatal error [memory may be damaged]"	*(char)
,	O
0	int
)	O
;	O
}	O
printf	O
(	O
"\nUnrecoverable error: %s.\n"	*(char)
,	O
s	*(char)
)	O
;	O
fflush	()->(int)
(	O
stdout	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
initlisp	()->(void)
(	O
void	O
)	O
{	O
void	O
*	O
v	*(void)
=	O
&	O
v	*(void)
;	O
if	O
(	O
NULL_OR_ON_C_STACK	()->(int)
(	O
v	*(void)
)	O
==	O
0	int
||	O
NULL_OR_ON_C_STACK	()->(int)
(	O
pagetoinfo	()->(int)
(	O
first_data_page	O
)	O
)	O
||	O
NULL_OR_ON_C_STACK	()->(int)
(	O
core_end	O
-	O
1	int
)	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%p %d "	*(char)
"%p %d %p %d\n"	*(char)
,	O
v	*(void)
,	O
NULL_OR_ON_C_STACK	()->(int)
(	O
v	*(void)
)	O
,	O
pagetoinfo	()->(int)
(	O
first_data_page	O
)	O
,	O
NULL_OR_ON_C_STACK	()->(int)
(	O
pagetoinfo	()->(int)
(	O
first_data_page	O
)	O
)	O
,	O
core_end	O
-	O
1	int
,	O
NULL_OR_ON_C_STACK	()->(int)
(	O
core_end	O
-	O
1	int
)	O
)	O
;	O
error	(*(char))->(void)
(	O
"NULL_OR_ON_C_STACK macro invalid"	*(char)
)	O
;	O
}	O
Cnil	O
->	O
fw	O
=	O
0	int
;	O
set_type_of	()->(int)
(	O
Cnil	O
,	O
t_symbol	O
)	O
;	O
Cnil	O
->	O
c	O
.	O
c_cdr	O
=	O
Cnil	O
;	O
Cnil_body	O
.	O
s	*(char)
.	O
s_dbind	O
=	O
Cnil	O
;	O
Cnil_body	O
.	O
s	*(char)
.	O
s_sfdef	O
=	O
NOT_SPECIAL	O
;	O
Cnil_body	O
.	O
s	*(char)
.	O
s_fillp	O
=	O
3	int
;	O
Cnil_body	O
.	O
s	*(char)
.	O
s_self	O
=	O
"NIL"	*(char)
;	O
Cnil_body	O
.	O
s	*(char)
.	O
s_gfdef	O
=	O
OBJNULL	O
;	O
Cnil_body	O
.	O
s	*(char)
.	O
s_plist	O
=	O
Cnil	O
;	O
Cnil_body	O
.	O
s	*(char)
.	O
s_hpack	O
=	O
Cnil	O
;	O
Cnil_body	O
.	O
s	*(char)
.	O
s_stype	O
=	O
(	O
short	O
)	O
stp_constant	O
;	O
Cnil_body	O
.	O
s	*(char)
.	O
s_mflag	O
=	O
FALSE	O
;	O
Ct	O
->	O
fw	O
=	O
0	int
;	O
set_type_of	()->(int)
(	O
Ct	O
,	O
t_symbol	O
)	O
;	O
Ct_body	O
.	O
s	*(char)
.	O
s_dbind	O
=	O
Ct	O
;	O
Ct_body	O
.	O
s	*(char)
.	O
s_sfdef	O
=	O
NOT_SPECIAL	O
;	O
Ct_body	O
.	O
s	*(char)
.	O
s_fillp	O
=	O
1	int
;	O
Ct_body	O
.	O
s	*(char)
.	O
s_self	O
=	O
"T"	*(char)
;	O
Ct_body	O
.	O
s	*(char)
.	O
s_gfdef	O
=	O
OBJNULL	O
;	O
Ct_body	O
.	O
s	*(char)
.	O
s_plist	O
=	O
Cnil	O
;	O
Ct_body	O
.	O
s	*(char)
.	O
s_hpack	O
=	O
Cnil	O
;	O
Ct_body	O
.	O
s	*(char)
.	O
s_stype	O
=	O
(	O
short	O
)	O
stp_constant	O
;	O
Ct_body	O
.	O
s	*(char)
.	O
s_mflag	O
=	O
FALSE	O
;	O
gcl_init_symbol	()->(int)
(	O
)	O
;	O
gcl_init_package	()->(int)
(	O
)	O
;	O
Cnil	O
->	O
s	*(char)
.	O
s_hpack	O
=	O
lisp_package	O
;	O
import	()->(int)
(	O
Cnil	O
,	O
lisp_package	O
)	O
;	O
export	()->(int)
(	O
Cnil	O
,	O
lisp_package	O
)	O
;	O
Ct	O
->	O
s	*(char)
.	O
s_hpack	O
=	O
lisp_package	O
;	O
import	()->(int)
(	O
Ct	O
,	O
lisp_package	O
)	O
;	O
export	()->(int)
(	O
Ct	O
,	O
lisp_package	O
)	O
;	O
sLlambda	O
=	O
make_ordinary	()->(int)
(	O
"LAMBDA"	*(char)
)	O
;	O
sLlambda_block	O
=	O
make_ordinary	()->(int)
(	O
"LAMBDA-BLOCK"	*(char)
)	O
;	O
sLlambda_closure	O
=	O
make_ordinary	()->(int)
(	O
"LAMBDA-CLOSURE"	*(char)
)	O
;	O
sLlambda_block_closure	O
=	O
make_ordinary	()->(int)
(	O
"LAMBDA-BLOCK-CLOSURE"	*(char)
)	O
;	O
sLspecial	O
=	O
make_ordinary	()->(int)
(	O
"SPECIAL"	*(char)
)	O
;	O
NewInit	()->(int)
(	O
)	O
;	O
gcl_init_typespec	()->(int)
(	O
)	O
;	O
gcl_init_number	()->(int)
(	O
)	O
;	O
gcl_init_character	()->(int)
(	O
)	O
;	O
gcl_init_read	()->(int)
(	O
)	O
;	O
gcl_init_bind	()->(int)
(	O
)	O
;	O
gcl_init_pathname	()->(int)
(	O
)	O
;	O
gcl_init_print	()->(int)
(	O
)	O
;	O
gcl_init_GBC	()->(int)
(	O
)	O
;	O
gcl_init_unixfasl	()->(int)
(	O
)	O
;	O
gcl_init_unixsys	()->(int)
(	O
)	O
;	O
gcl_init_unixsave	()->(int)
(	O
)	O
;	O
gcl_init_alloc_function	()->(int)
(	O
)	O
;	O
gcl_init_array_function	()->(int)
(	O
)	O
;	O
gcl_init_character_function	()->(int)
(	O
)	O
;	O
gcl_init_file_function	()->(int)
(	O
)	O
;	O
gcl_init_list_function	()->(int)
(	O
)	O
;	O
gcl_init_package_function	()->(int)
(	O
)	O
;	O
gcl_init_pathname_function	()->(int)
(	O
)	O
;	O
gcl_init_predicate_function	()->(int)
(	O
)	O
;	O
gcl_init_print_function	()->(int)
(	O
)	O
;	O
gcl_init_read_function	()->(int)
(	O
)	O
;	O
gcl_init_sequence_function	()->(int)
(	O
)	O
;	O
gcl_init_structure_function	()->(int)
(	O
)	O
;	O
gcl_init_string_function	()->(int)
(	O
)	O
;	O
gcl_init_symbol_function	()->(int)
(	O
)	O
;	O
gcl_init_typespec_function	()->(int)
(	O
)	O
;	O
gcl_init_hash	()->(int)
(	O
)	O
;	O
gcl_init_cfun	()->(int)
(	O
)	O
;	O
gcl_init_unixfsys	()->(int)
(	O
)	O
;	O
gcl_init_unixtime	()->(int)
(	O
)	O
;	O
gcl_init_eval	()->(int)
(	O
)	O
;	O
gcl_init_lex	()->(int)
(	O
)	O
;	O
gcl_init_prog	()->(int)
(	O
)	O
;	O
gcl_init_catch	()->(int)
(	O
)	O
;	O
gcl_init_block	()->(int)
(	O
)	O
;	O
gcl_init_macros	()->(int)
(	O
)	O
;	O
gcl_init_conditional	()->(int)
(	O
)	O
;	O
gcl_init_reference	()->(int)
(	O
)	O
;	O
gcl_init_assignment	()->(int)
(	O
)	O
;	O
gcl_init_multival	()->(int)
(	O
)	O
;	O
gcl_init_error	()->(int)
(	O
)	O
;	O
gcl_init_let	()->(int)
(	O
)	O
;	O
gcl_init_mapfun	()->(int)
(	O
)	O
;	O
gcl_init_iteration	()->(int)
(	O
)	O
;	O
gcl_init_toplevel	()->(int)
(	O
)	O
;	O
gcl_init_cmpaux	()->(int)
(	O
)	O
;	O
init_main	()->(void)
(	O
)	O
;	O
gcl_init_format	()->(int)
(	O
)	O
;	O
gcl_init_links	()->(int)
(	O
)	O
;	O
gcl_init_fat_string	()->(int)
(	O
)	O
;	O
gcl_init_sfasl	()->(int)
(	O
)	O
;	O
gcl_init_cmac	()->(int)
(	O
)	O
;	O
}	O
object	O
vs_overflow	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
vs_limit	O
>	O
vs_org	O
+	O
stack_multiple	int
*	O
VSSIZE	O
)	O
error	(*(char))->(void)
(	O
"value stack overflow"	*(char)
)	O
;	O
vs_limit	O
+=	O
STACK_OVER	int
*	O
VSGETA	O
;	O
FEerror	()->(int)
(	O
"Value stack overflow."	*(char)
,	O
0	int
)	O
;	O
return	O
Cnil	O
;	O
}	O
void	O
bds_overflow	()->(void)
(	O
void	O
)	O
{	O
--	O
bds_top	O
;	O
if	O
(	O
bds_limit	O
>	O
bds_org	O
+	O
stack_multiple	int
*	O
BDSSIZE	O
)	O
{	O
error	(*(char))->(void)
(	O
"bind stack overflow"	*(char)
)	O
;	O
}	O
bds_limit	O
+=	O
STACK_OVER	int
*	O
BDSGETA	O
;	O
FEerror	()->(int)
(	O
"Bind stack overflow."	*(char)
,	O
0	int
)	O
;	O
}	O
void	O
frs_overflow	()->(void)
(	O
void	O
)	O
{	O
--	O
frs_top	O
;	O
if	O
(	O
frs_limit	O
>	O
frs_org	O
+	O
stack_multiple	int
*	O
FRSSIZE	O
)	O
error	(*(char))->(void)
(	O
"frame stack overflow"	*(char)
)	O
;	O
frs_limit	O
+=	O
STACK_OVER	int
*	O
FRSGETA	O
;	O
FEerror	()->(int)
(	O
"Frame stack overflow."	*(char)
,	O
0	int
)	O
;	O
}	O
void	O
ihs_overflow	()->(void)
(	O
void	O
)	O
{	O
--	O
ihs_top	O
;	O
if	O
(	O
ihs_limit	O
>	O
ihs_org	O
+	O
stack_multiple	int
*	O
IHSSIZE	O
)	O
error	(*(char))->(void)
(	O
"invocation history stack overflow"	*(char)
)	O
;	O
ihs_limit	O
+=	O
STACK_OVER	int
*	O
IHSGETA	O
;	O
FEerror	()->(int)
(	O
"Invocation history stack overflow."	*(char)
,	O
0	int
)	O
;	O
}	O
void	O
segmentation_catcher	(int)->(void)
(	O
int	O
i	int
)	O
{	O
error	(*(char))->(void)
(	O
"Segmentation violation."	*(char)
)	O
;	O
}	O
DEFUNO_NEW	()->(int)
(	O
"BYE"	*(char)
,	O
object	O
,	O
fLbye	O
,	O
LISP	O
,	O
0	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lby	O
,	O
(	O
object	O
exitc	O
)	O
,	O
""	*(char)
)	O
{	O
int	O
n	int
=	O
VFUN_NARGS	O
;	O
int	O
exit_code	int
;	O
if	O
(	O
n	int
>=	O
1	int
)	O
exit_code	int
=	O
fix	()->(int)
(	O
exitc	O
)	O
;	O
else	O
exit_code	int
=	O
0	int
;	O
exit	(int)->(void)
(	O
exit_code	int
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"QUIT"	*(char)
,	O
object	O
,	O
fLquit	O
,	O
LISP	O
,	O
0	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
exitc	O
)	O
,	O
""	*(char)
)	O
{	O
return	O
FFN	()->(int)
(	O
fLbye	O
)	O
(	O
exitc	O
)	O
;	O
}	O
static	O
void	O
FFN	()->(int)
(	O
siLargc	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
0	int
)	O
;	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
ARGC	O
)	O
)	O
;	O
}	O
static	O
void	O
FFN	()->(int)
(	O
siLargv	int
)	O
(	O
void	O
)	O
{	O
int	O
i	int
=	O
0	int
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
!=	O
t_fixnum	O
||	O
(	O
i	int
=	O
fix	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
<	O
0	int
||	O
i	int
>=	O
ARGC	O
)	O
FEerror	()->(int)
(	O
"Illegal argument index: ~S."	*(char)
,	O
1	int
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
make_simple_string	()->(int)
(	O
ARGV	O
[	O
i	int
]	O
)	O
;	O
}	O
static	O
void	O
FFN	()->(int)
(	O
siLgetenv	int
)	O
(	O
void	O
)	O
{	O
char	O
name	array(char)
[	O
256	int
]	O
;	O
int	O
i	int
;	O
char	O
*	O
value	*(char)
;	O
extern	O
char	O
*	O
getenv	(*(char))->(*(char))
(	O
const	O
char	O
*	O
)	O
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_string	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
->	O
st	O
.	O
st_fillp	O
>=	O
256	int
)	O
FEerror	()->(int)
(	O
"Too long name: ~S."	*(char)
,	O
1	int
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
vs_base	O
[	O
0	int
]	O
->	O
st	O
.	O
st_fillp	O
;	O
i	int
++	O
)	O
name	array(char)
[	O
i	int
]	O
=	O
vs_base	O
[	O
0	int
]	O
->	O
st	O
.	O
st_self	O
[	O
i	int
]	O
;	O
name	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
value	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
name	array(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
vs_base	O
[	O
0	int
]	O
=	O
make_simple_string	()->(int)
(	O
value	*(char)
)	O
;	O
}	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
object	O
*	O
vs_marker	*(int)
;	O
static	O
void	O
FFN	()->(int)
(	O
siLmark_vs	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
0	int
)	O
;	O
vs_marker	*(int)
=	O
vs_base	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
static	O
void	O
FFN	()->(int)
(	O
siLcheck_vs	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
0	int
)	O
;	O
if	O
(	O
vs_base	O
!=	O
vs_marker	*(int)
)	O
FEerror	()->(int)
(	O
"Value stack is flawed."	*(char)
,	O
0	int
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
static	O
object	O
FFN	()->(int)
(	O
siLcatch_fatal	int
)	O
(	O
int	O
i	int
)	O
{	O
catch_fatal	int
=	O
i	int
;	O
return	O
Cnil	O
;	O
}	O
LFD	(int)->(int)
(	O
siLreset_stack_limits	int
)	O
(	O
void	O
)	O
{	O
long	O
i	int
=	O
0	int
;	O
check_arg	()->(int)
(	O
0	int
)	O
;	O
if	O
(	O
catch_fatal	int
<	O
0	int
)	O
catch_fatal	int
=	O
1	int
;	O
if	O
(	O
vs_top	O
<	O
vs_org	O
+	O
stack_multiple	int
*	O
VSSIZE	O
)	O
vs_limit	O
=	O
vs_org	O
+	O
stack_multiple	int
*	O
VSSIZE	O
;	O
else	O
error	(*(char))->(void)
(	O
"can't reset vs_limit"	*(char)
)	O
;	O
if	O
(	O
bds_top	O
<	O
bds_org	O
+	O
stack_multiple	int
*	O
BDSSIZE	O
)	O
bds_limit	O
=	O
bds_org	O
+	O
stack_multiple	int
*	O
BDSSIZE	O
;	O
else	O
error	(*(char))->(void)
(	O
"can't reset bds_limit"	*(char)
)	O
;	O
if	O
(	O
frs_top	O
<	O
frs_org	O
+	O
stack_multiple	int
*	O
FRSSIZE	O
)	O
frs_limit	O
=	O
frs_org	O
+	O
stack_multiple	int
*	O
FRSSIZE	O
;	O
else	O
error	(*(char))->(void)
(	O
"can't reset frs_limit"	*(char)
)	O
;	O
if	O
(	O
ihs_top	O
<	O
ihs_org	O
+	O
stack_multiple	int
*	O
IHSSIZE	O
)	O
ihs_limit	O
=	O
ihs_org	O
+	O
stack_multiple	int
*	O
IHSSIZE	O
;	O
else	O
error	(*(char))->(void)
(	O
"can't reset ihs_limit"	*(char)
)	O
;	O
if	O
(	O
cs_base	O
==	O
cs_org	O
)	O
cs_org	O
=	O
(	O
void	O
*	O
)	O
&	O
i	int
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
static	O
int	O
multiply_stacks	(int)->(int)
(	O
int	O
m	int
)	O
{	O
void	O
*	O
p	*(void)
;	O
int	O
vs	int
,	O
bd	int
,	O
frs	int
,	O
ihs	int
;	O
stack_multiple	int
=	O
stack_multiple	int
*	O
m	int
;	O
vs	int
=	O
(	O
stack_multiple	int
*	O
VSSIZE	O
+	O
(	O
STACK_OVER	int
+	O
1	int
)	O
*	O
VSGETA	O
)	O
*	O
ELTSIZE	O
(	O
vs_org	O
)	O
;	O
bd	int
=	O
(	O
stack_multiple	int
*	O
BDSSIZE	O
+	O
(	O
STACK_OVER	int
+	O
1	int
)	O
*	O
BDSGETA	O
)	O
*	O
ELTSIZE	O
(	O
bds_org	O
)	O
;	O
frs	int
=	O
(	O
stack_multiple	int
*	O
FRSSIZE	O
+	O
(	O
STACK_OVER	int
+	O
1	int
)	O
*	O
FRSGETA	O
)	O
*	O
ELTSIZE	O
(	O
frs_org	O
)	O
;	O
ihs	int
=	O
(	O
stack_multiple	int
*	O
IHSSIZE	O
+	O
(	O
STACK_OVER	int
+	O
1	int
)	O
*	O
IHSGETA	O
)	O
*	O
ELTSIZE	O
(	O
ihs_org	O
)	O
;	O
if	O
(	O
stack_space	int
==	O
0	int
)	O
{	O
enter_mark_origin	()->(int)
(	O
&	O
stack_space	int
)	O
;	O
}	O
stack_space	int
=	O
alloc_simple_string	()->(int)
(	O
vs	int
+	O
bd	int
+	O
frs	int
+	O
ihs	int
)	O
;	O
array_allocself	()->(int)
(	O
stack_space	int
,	O
1	int
,	O
code_char	()->(int)
(	O
0	int
)	O
)	O
;	O
p	*(void)
=	O
stack_space	int
->	O
st	O
.	O
st_self	O
;	O
COPYSTACK	O
(	O
vs_org	O
,	O
p	*(void)
,	O
object	O
,	O
vs_limit	O
,	O
vs_top	O
,	O
VSGETA	O
,	O
VSSIZE	O
)	O
;	O
COPYSTACK	O
(	O
bds_org	O
,	O
p	*(void)
,	O
struct	O
bds_bd	O
,	O
bds_limit	O
,	O
bds_top	O
,	O
BDSGETA	O
,	O
BDSSIZE	O
)	O
;	O
COPYSTACK	O
(	O
frs_org	O
,	O
p	*(void)
,	O
struct	O
frame	O
,	O
frs_limit	O
,	O
frs_top	O
,	O
FRSGETA	O
,	O
FRSSIZE	O
)	O
;	O
COPYSTACK	O
(	O
ihs_org	O
,	O
p	*(void)
,	O
struct	O
invocation_history	O
,	O
ihs_limit	O
,	O
ihs_top	O
,	O
IHSGETA	O
,	O
IHSSIZE	O
)	O
;	O
vs_base	O
=	O
vs_top	O
;	O
return	O
stack_multiple	int
;	O
}	O
DEFVAR	()->(int)
(	O
"*NO-INIT*"	*(char)
,	O
sSAno_initA	O
,	O
SI	O
,	O
Cnil	O
,	O
""	*(char)
)	O
;	O
LFD	(int)->(int)
(	O
siLinit_system	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
0	int
)	O
;	O
gcl_init_system	()->(int)
(	O
sSAno_initA	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
static	O
void	O
FFN	()->(int)
(	O
siLuser_init	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
0	int
)	O
;	O
sLApackageA	O
->	O
s	*(char)
.	O
s_dbind	O
=	O
user_package	O
;	O
user_init	()->(int)
(	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"NANI"	*(char)
,	O
object	O
,	O
fSnani	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OI	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
address	O
)	O
,	O
""	*(char)
)	O
{	O
RETURN1	()->(int)
(	O
(	O
object	O
)	O
address	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"ADDRESS"	*(char)
,	O
object	O
,	O
fSaddress	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
IO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x	O
)	O
,	O
""	*(char)
)	O
{	O
RETURN1	()->(int)
(	O
x	O
)	O
;	O
}	O
static	O
void	O
FFN	()->(int)
(	O
siLinitialization_failure	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
0	int
)	O
;	O
printf	O
(	O
"lisp initialization failed\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
DEFUNO_NEW	()->(int)
(	O
"IDENTITY"	*(char)
,	O
object	O
,	O
fLidentity	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lidentity	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	*(char)
)	O
{	O
RETURN1	()->(int)
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	()->(int)
(	O
"GCL-COMPILE-TIME"	*(char)
,	O
object	O
,	O
fSgcl_compile_time	O
,	O
SI	O
,	O
0	int
,	O
0	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lgcl_compile_time	O
,	O
(	O
void	O
)	O
,	O
""	*(char)
)	O
{	O
RETURN1	()->(int)
(	O
make_simple_string	()->(int)
(	O
__DATE__	O
" "	*(char)
__TIME__	O
)	O
)	O
;	O
}	O
DEFUNO_NEW	()->(int)
(	O
"LDB1"	*(char)
,	O
object	O
,	O
fSldb1	O
,	O
SI	O
,	O
3	int
,	O
3	int
,	O
NONE	O
,	O
OI	O
,	O
II	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lldb1	O
,	O
(	O
fixnum	O
a	O
,	O
fixnum	O
b	char
,	O
fixnum	O
c	O
)	O
,	O
""	*(char)
)	O
{	O
RETURN1	()->(int)
(	O
make_fixnum	()->(int)
(	O
(	O
(	O
(	O
(	O
~	O
(	O
-	O
1	int
<<	O
(	O
a	O
)	O
)	O
)	O
<<	O
(	O
b	char
)	O
)	O
&	O
(	O
c	O
)	O
)	O
>>	O
(	O
b	char
)	O
)	O
)	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"LISP-IMPLEMENTATION-VERSION"	*(char)
,	O
object	O
,	O
fLlisp_implementation_version	O
,	O
LISP	O
,	O
0	int
,	O
0	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
void	O
)	O
,	O
""	*(char)
)	O
{	O
RETURN1	()->(int)
(	O
(	O
make_simple_string	()->(int)
(	O
LISP_IMPLEMENTATION_VERSION	*(char)
)	O
)	O
)	O
;	O
}	O
static	O
void	O
FFN	()->(int)
(	O
siLsave_system	int
)	O
(	O
void	O
)	O
{	O
saving_system	int
=	O
TRUE	O
;	O
minimize_image	()->(int)
(	O
)	O
;	O
saving_system	int
=	O
FALSE	O
;	O
Lsave	()->(int)
(	O
)	O
;	O
alloc_page	()->(int)
(	O
-	O
(	O
holepage	O
+	O
nrbpage	O
)	O
)	O
;	O
}	O
DEFVAR	()->(int)
(	O
"*LISP-MAXPAGES*"	*(char)
,	O
sSAlisp_maxpagesA	int
,	O
SI	O
,	O
make_fixnum	()->(int)
(	O
real_maxpage	long
)	O
,	O
""	*(char)
)	O
;	O
DEFVAR	()->(int)
(	O
"*SYSTEM-DIRECTORY*"	*(char)
,	O
sSAsystem_directoryA	O
,	O
SI	O
,	O
make_simple_string	()->(int)
(	O
system_directory	*(char)
)	O
,	O
""	*(char)
)	O
;	O
DEFVAR	()->(int)
(	O
"*MULTIPLY-STACKS*"	*(char)
,	O
sSAmultiply_stacksA	int
,	O
SI	O
,	O
Cnil	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"TOP-LEVEL"	*(char)
,	O
sStop_level	int
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEFVAR	()->(int)
(	O
"*COMMAND-ARGS*"	*(char)
,	O
sSAcommand_argsA	O
,	O
SI	O
,	O
sLnil	O
,	O
""	*(char)
)	O
;	O
static	O
void	O
init_main	()->(void)
(	O
void	O
)	O
{	O
make_function	()->(int)
(	O
"BY"	*(char)
,	O
Lby	O
)	O
;	O
make_si_function	()->(int)
(	O
"ARGC"	*(char)
,	O
siLargc	int
)	O
;	O
make_si_function	()->(int)
(	O
"ARGV"	*(char)
,	O
siLargv	int
)	O
;	O
make_si_function	()->(int)
(	O
"GETENV"	*(char)
,	O
siLgetenv	int
)	O
;	O
make_si_function	()->(int)
(	O
"MARK-VS"	*(char)
,	O
siLmark_vs	int
)	O
;	O
make_si_function	()->(int)
(	O
"CHECK-VS"	*(char)
,	O
siLcheck_vs	int
)	O
;	O
make_si_function	()->(int)
(	O
"RESET-STACK-LIMITS"	*(char)
,	O
siLreset_stack_limits	int
)	O
;	O
make_si_function	()->(int)
(	O
"INIT-SYSTEM"	*(char)
,	O
siLinit_system	int
)	O
;	O
make_si_function	()->(int)
(	O
"USER-INIT"	*(char)
,	O
siLuser_init	int
)	O
;	O
make_si_function	()->(int)
(	O
"INITIALIZATION-FAILURE"	*(char)
,	O
siLinitialization_failure	int
)	O
;	O
siClisp_pagesize	int
=	O
make_si_constant	()->(int)
(	O
"LISP-PAGESIZE"	*(char)
,	O
make_fixnum	()->(int)
(	O
PAGESIZE	O
)	O
)	O
;	O
{	O
object	O
features	O
;	O
features	O
=	O
make_cons	()->(int)
(	O
make_keyword	()->(int)
(	O
"COMMON"	*(char)
)	O
,	O
make_cons	()->(int)
(	O
make_keyword	()->(int)
(	O
"KCL"	*(char)
)	O
,	O
Cnil	O
)	O
)	O
;	O
ADD_FEATURE	O
(	O
"AKCL"	*(char)
)	O
;	O
ADD_FEATURE	O
(	O
"GCL"	*(char)
)	O
;	O
ADD_FEATURE	O
(	O
"UNIX"	*(char)
)	O
;	O
ADD_FEATURE	O
(	O
HOST_CPU	O
)	O
;	O
ADD_FEATURE	O
(	O
HOST_KERNEL	O
)	O
;	O
ADD_FEATURE	O
(	O
"CLX-LITTLE-ENDIAN"	*(char)
)	O
;	O
{	O
int	O
Bigm	int
=	O
BIGM	O
;	O
int	O
Smallm	int
=	O
-	O
BIGM	O
-	O
1	int
;	O
int	O
Seven	int
=	O
7	int
;	O
int	O
Three	int
=	O
3	int
;	O
if	O
(	O
(	O
Smallm	int
/	O
Seven	int
)	O
<	O
0	int
&&	O
(	O
Smallm	int
/	O
(	O
-	O
Seven	int
)	O
)	O
>	O
0	int
&&	O
(	O
Bigm	int
/	O
(	O
-	O
Seven	int
)	O
)	O
<	O
0	int
&&	O
(	O
(	O
-	O
Seven	int
)	O
/	O
Three	int
)	O
==	O
-	O
2	int
&&	O
(	O
Seven	int
/	O
(	O
-	O
Three	int
)	O
)	O
==	O
-	O
2	int
&&	O
(	O
(	O
-	O
Seven	int
)	O
/	O
(	O
-	O
Three	int
)	O
)	O
==	O
2	int
)	O
{	O
ADD_FEATURE	O
(	O
"TRUNCATE_USE_C"	*(char)
)	O
;	O
}	O
}	O
ADD_FEATURE	O
(	O
"NATIVE-RELOC"	*(char)
)	O
;	O
ADD_FEATURE	O
(	O
"UNEXEC"	*(char)
)	O
;	O
make_special	()->(int)
(	O
"*FEATURES*"	*(char)
,	O
features	O
)	O
;	O
}	O
make_si_function	()->(int)
(	O
"SAVE-SYSTEM"	*(char)
,	O
siLsave_system	int
)	O
;	O
make_si_sfun	()->(int)
(	O
"CATCH-FATAL"	*(char)
,	O
siLcatch_fatal	int
,	O
ARGTYPE1	()->(int)
(	O
f_fixnum	O
)	O
)	O
;	O
make_si_function	()->(int)
(	O
"WARN-VERSION"	*(char)
,	O
Lidentity	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"DISASSEMBLE-INSTRUCTION"	*(char)
,	O
object	O
,	O
fSdisassemble_instruction	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OI	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
addr	O
)	O
,	O
""	*(char)
)	O
{	O
return	O
MMcons	()->(int)
(	O
make_simple_string	()->(int)
(	O
"fnop ;"	*(char)
)	O
,	O
make_fixnum	()->(int)
(	O
0	int
)	O
)	O
;	O
}	O
typedef	O
struct	O
{	O
enum	O
type	O
tt	enum
;	O
struct	O
typemanager	O
*	O
tp	*(struct)
;	O
}	O
Tbl	struct(enum,*(struct))
;	O
DEFUN_NEW	()->(int)
(	O
"FUNCTION-BY-ADDRESS"	*(char)
,	O
object	O
,	O
fSfunction_by_address	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OI	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
ad	O
)	O
,	O
""	*(char)
)	O
{	O
ufixnum	O
m	int
=	O
-	O
1	int
,	O
mm	O
,	O
j	int
;	O
void	O
*	O
o	*(void)
;	O
object	O
x	O
,	O
xx	O
=	O
Cnil	O
;	O
Tbl	struct(enum,*(struct))
tb1	array(struct(enum,*(struct)))
[	O
]	O
=	O
{	O
Tblof	O
(	O
t_sfun	O
)	O
,	O
Tblof	O
(	O
t_cfun	O
)	O
,	O
Tblof	O
(	O
t_vfun	O
)	O
,	O
Tblof	O
(	O
t_afun	O
)	O
,	O
Tblof	O
(	O
t_gfun	O
)	O
,	O
Tblof	O
(	O
t_closure	O
)	O
,	O
Tblof	O
(	O
t_cclosure	O
)	O
,	O
{	O
0	int
}	O
}	O
;	O
struct	O
typemanager	O
*	O
tp	*(struct)
;	O
enum	O
type	O
tt	enum
;	O
struct	O
pageinfo	O
*	O
v	*(void)
;	O
if	O
(	O
VALID_DATA_ADDRESS_P	()->(int)
(	O
ad	O
)	O
)	O
for	O
(	O
v	*(void)
=	O
cell_list_head	O
;	O
v	*(void)
;	O
v	*(void)
=	O
v	*(void)
->	O
next	O
)	O
if	O
(	O
tblookup	O
(	O
mtm_of	O
(	O
v	*(void)
->	O
type	O
)	O
,	O
tp	*(struct)
)	O
)	O
for	O
(	O
o	*(void)
=	O
pagetochar	()->(int)
(	O
page	()->(int)
(	O
v	*(void)
)	O
)	O
,	O
j	int
=	O
tp	*(struct)
->	O
tm_nppage	O
;	O
j	int
--	O
;	O
o	*(void)
+=	O
tp	*(struct)
->	O
tm_size	O
)	O
if	O
(	O
tblookup	O
(	O
type_of	()->(int)
(	O
(	O
x	O
=	O
o	*(void)
)	O
)	O
,	O
tt	enum
)	O
)	O
if	O
(	O
!	O
is_free	()->(int)
(	O
x	O
)	O
&&	O
(	O
mm	O
=	O
ad	O
-	O
(	O
ufixnum	O
)	O
x	O
->	O
sfn	O
.	O
sfn_self	O
)	O
<	O
m	int
)	O
{	O
m	int
=	O
mm	O
;	O
xx	O
=	O
x	O
;	O
}	O
return	O
xx	O
;	O
}	O
