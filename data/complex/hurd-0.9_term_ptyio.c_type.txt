static	O
int	O
pty_read_blocked	int
=	O
0	int
;	O
static	O
pthread_cond_t	O
pty_read_wakeup	int
=	O
PTHREAD_COND_INITIALIZER	O
;	O
static	O
pthread_cond_t	O
pty_select_wakeup	int
=	O
PTHREAD_COND_INITIALIZER	O
;	O
static	O
int	O
dtr_on	int
=	O
0	int
;	O
static	O
int	O
packet_mode	int
=	O
0	int
;	O
static	O
int	O
user_ioctl_mode	int
=	O
0	int
;	O
static	O
char	O
control_byte	char
=	O
0	int
;	O
static	O
int	O
output_stopped	int
=	O
0	int
;	O
static	O
int	O
pktnostop	int
=	O
0	int
;	O
static	O
int	O
ptyopen	int
=	O
0	int
;	O
static	O
int	O
nptyperopens	int
=	O
0	int
;	O
static	O
error_t	O
ptyio_init	()->(int)
(	O
void	O
)	O
{	O
pty_select_alert	O
=	O
&	O
pty_select_wakeup	int
;	O
return	O
0	int
;	O
}	O
error_t	O
pty_open_hook	(*(struct),*(struct),int)->(int)
(	O
struct	O
trivfs_control	O
*	O
cntl	*(struct)
,	O
struct	O
iouser	O
*	O
user	*(struct)
,	O
int	O
flags	int
)	O
{	O
if	O
(	O
(	O
flags	int
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
==	O
0	int
)	O
return	O
0	int
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
ptyopen	int
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
EBUSY	O
;	O
}	O
ptyopen	int
=	O
1	int
;	O
external_processing	O
=	O
0	int
;	O
packet_mode	int
=	O
0	int
;	O
user_ioctl_mode	int
=	O
0	int
;	O
control_byte	char
=	O
0	int
;	O
pktnostop	int
=	O
0	int
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
pty_po_create_hook	(*(struct))->(int)
(	O
struct	O
trivfs_peropen	O
*	O
po	*(struct)
)	O
{	O
pthread_mutex_lock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
{	O
nptyperopens	int
++	O
;	O
report_carrier_on	()->(int)
(	O
)	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
pty_po_destroy_hook	(*(struct))->(int)
(	O
struct	O
trivfs_peropen	O
*	O
po	*(struct)
)	O
{	O
pthread_mutex_lock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
(	O
po	*(struct)
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
==	O
0	int
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
0	int
;	O
}	O
nptyperopens	int
--	O
;	O
if	O
(	O
!	O
nptyperopens	int
)	O
{	O
ptyopen	int
=	O
0	int
;	O
report_carrier_off	()->(int)
(	O
)	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
inline	O
void	O
wake_reader	()->(void)
(	O
)	O
{	O
if	O
(	O
pty_read_blocked	int
)	O
{	O
pty_read_blocked	int
=	O
0	int
;	O
pthread_cond_broadcast	()->(int)
(	O
&	O
pty_read_wakeup	int
)	O
;	O
pthread_cond_broadcast	()->(int)
(	O
&	O
pty_select_wakeup	int
)	O
;	O
}	O
}	O
static	O
error_t	O
ptyio_start_output	()->(int)
(	O
)	O
{	O
if	O
(	O
packet_mode	int
&&	O
output_stopped	int
&&	O
(	O
!	O
(	O
termflags	O
&	O
USER_OUTPUT_SUSP	O
)	O
)	O
)	O
{	O
control_byte	char
&=	O
~	O
TIOCPKT_STOP	int
;	O
control_byte	char
|=	O
TIOCPKT_START	int
;	O
output_stopped	int
=	O
0	int
;	O
}	O
wake_reader	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
ptyio_abandon_physical_output	()->(int)
(	O
)	O
{	O
if	O
(	O
packet_mode	int
)	O
{	O
control_byte	char
|=	O
TIOCPKT_FLUSHWRITE	int
;	O
wake_reader	()->(void)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	O
ptyio_suspend_physical_output	()->(int)
(	O
)	O
{	O
if	O
(	O
packet_mode	int
)	O
{	O
control_byte	char
&=	O
~	O
TIOCPKT_START	int
;	O
control_byte	char
|=	O
TIOCPKT_STOP	int
;	O
output_stopped	int
=	O
1	int
;	O
wake_reader	()->(void)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
ptyio_pending_output_size	()->(int)
(	O
)	O
{	O
return	O
0	int
;	O
}	O
static	O
error_t	O
ptyio_notice_input_flushed	()->(int)
(	O
)	O
{	O
if	O
(	O
packet_mode	int
)	O
{	O
control_byte	char
|=	O
TIOCPKT_FLUSHREAD	int
;	O
wake_reader	()->(void)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	O
ptyio_assert_dtr	()->(int)
(	O
)	O
{	O
dtr_on	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
ptyio_desert_dtr	()->(int)
(	O
)	O
{	O
dtr_on	int
=	O
0	int
;	O
wake_reader	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
ptyio_set_bits	(*(struct))->(int)
(	O
struct	O
termios	O
*	O
state	*(struct)
)	O
{	O
if	O
(	O
packet_mode	int
)	O
{	O
int	O
wakeup	int
=	O
0	int
;	O
int	O
stop	int
=	O
(	O
(	O
state	*(struct)
->	O
c_iflag	short
&	O
IXON	O
)	O
&&	O
CCEQ	()->(int)
(	O
state	*(struct)
->	O
c_cc	array(char)
[	O
VSTOP	O
]	O
,	O
CHAR_DC3	O
)	O
&&	O
CCEQ	()->(int)
(	O
state	*(struct)
->	O
c_cc	array(char)
[	O
VSTART	O
]	O
,	O
CHAR_DC1	O
)	O
)	O
;	O
if	O
(	O
external_processing	O
)	O
{	O
control_byte	char
|=	O
TIOCPKT_IOCTL	int
;	O
wakeup	int
=	O
1	int
;	O
}	O
if	O
(	O
pktnostop	int
&&	O
stop	int
)	O
{	O
pktnostop	int
=	O
0	int
;	O
control_byte	char
|=	O
TIOCPKT_DOSTOP	int
;	O
control_byte	char
&=	O
~	O
TIOCPKT_NOSTOP	int
;	O
wakeup	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
pktnostop	int
&&	O
!	O
stop	int
)	O
{	O
pktnostop	int
=	O
1	int
;	O
control_byte	char
|=	O
TIOCPKT_NOSTOP	int
;	O
control_byte	char
&=	O
~	O
TIOCPKT_DOSTOP	int
;	O
wakeup	int
=	O
1	int
;	O
}	O
if	O
(	O
wakeup	int
)	O
wake_reader	()->(void)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	O
ptyio_set_break	()->(int)
(	O
)	O
{	O
return	O
0	int
;	O
}	O
static	O
error_t	O
ptyio_clear_break	()->(int)
(	O
)	O
{	O
return	O
0	int
;	O
}	O
static	O
error_t	O
ptyio_mdmctl	(int,int)->(int)
(	O
int	O
a	int
,	O
int	O
b	int
)	O
{	O
return	O
0	int
;	O
}	O
static	O
error_t	O
ptyio_mdmstate	(*(int))->(int)
(	O
int	O
*	O
state	*(struct)
)	O
{	O
*	O
state	*(struct)
=	O
0	int
;	O
return	O
0	int
;	O
}	O
const	O
struct	O
bottomhalf	O
ptyio_bottom	struct
=	O
{	O
TERM_ON_MASTERPTY	O
,	O
ptyio_init	()->(int)
,	O
NULL	O
,	O
NULL	O
,	O
ptyio_start_output	()->(int)
,	O
ptyio_set_break	()->(int)
,	O
ptyio_clear_break	()->(int)
,	O
ptyio_abandon_physical_output	()->(int)
,	O
ptyio_suspend_physical_output	()->(int)
,	O
ptyio_pending_output_size	()->(int)
,	O
ptyio_notice_input_flushed	()->(int)
,	O
ptyio_assert_dtr	()->(int)
,	O
ptyio_desert_dtr	()->(int)
,	O
ptyio_set_bits	(*(struct))->(int)
,	O
ptyio_mdmctl	(int,int)->(int)
,	O
ptyio_mdmstate	(*(int))->(int)
,	O
}	O
;	O
error_t	O
pty_io_read	(*(struct),*(*(char)),*(int),int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
char	O
*	O
*	O
data	*(*(char))
,	O
mach_msg_type_number_t	O
*	O
datalen	*(int)
,	O
mach_msg_type_number_t	O
amount	int
)	O
{	O
int	O
size	int
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
O_READ	O
)	O
==	O
0	int
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
EBADF	O
;	O
}	O
while	O
(	O
!	O
control_byte	char
&&	O
(	O
termflags	O
&	O
TTY_OPEN	O
)	O
&&	O
(	O
!	O
qsize	()->(int)
(	O
outputq	O
)	O
||	O
(	O
termflags	O
&	O
USER_OUTPUT_SUSP	O
)	O
)	O
)	O
{	O
if	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
O_NONBLOCK	int
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
EWOULDBLOCK	O
;	O
}	O
pty_read_blocked	int
=	O
1	int
;	O
if	O
(	O
pthread_hurd_cond_wait_np	()->(int)
(	O
&	O
pty_read_wakeup	int
,	O
&	O
global_lock	O
)	O
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
EINTR	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
termflags	O
&	O
TTY_OPEN	O
)	O
&&	O
!	O
qsize	()->(int)
(	O
outputq	O
)	O
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
EIO	O
;	O
}	O
if	O
(	O
control_byte	char
)	O
{	O
size	int
=	O
1	int
;	O
if	O
(	O
packet_mode	int
&&	O
(	O
control_byte	char
&	O
TIOCPKT_IOCTL	int
)	O
)	O
size	int
+=	O
sizeof	O
(	O
struct	O
termios	O
)	O
;	O
}	O
else	O
{	O
size	int
=	O
qsize	()->(int)
(	O
outputq	O
)	O
;	O
if	O
(	O
packet_mode	int
||	O
user_ioctl_mode	int
)	O
size	int
++	O
;	O
}	O
if	O
(	O
size	int
>	O
amount	int
)	O
size	int
=	O
amount	int
;	O
if	O
(	O
size	int
>	O
*	O
datalen	*(int)
)	O
*	O
data	*(*(char))
=	O
mmap	()->(int)
(	O
0	int
,	O
size	int
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
*	O
datalen	*(int)
=	O
size	int
;	O
if	O
(	O
control_byte	char
)	O
{	O
*	O
*	O
data	*(*(char))
=	O
control_byte	char
;	O
if	O
(	O
packet_mode	int
&&	O
(	O
control_byte	char
&	O
TIOCPKT_IOCTL	int
)	O
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
*	O
data	*(*(char))
+	O
1	int
,	O
&	O
termstate	O
,	O
size	int
-	O
1	int
)	O
;	O
control_byte	char
=	O
0	int
;	O
}	O
else	O
{	O
char	O
*	O
cp	*(char)
=	O
*	O
data	*(*(char))
;	O
if	O
(	O
packet_mode	int
||	O
user_ioctl_mode	int
)	O
{	O
*	O
cp	*(char)
++	O
=	O
TIOCPKT_DATA	int
;	O
--	O
size	int
;	O
}	O
while	O
(	O
size	int
--	O
)	O
*	O
cp	*(char)
++	O
=	O
dequeue	()->(int)
(	O
outputq	O
)	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
pty_io_write	(*(struct),*(char),int,*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
char	O
*	O
data	*(*(char))
,	O
mach_msg_type_number_t	O
datalen	*(int)
,	O
mach_msg_type_number_t	O
*	O
amount	int
)	O
{	O
int	O
i	int
,	O
flush	int
;	O
int	O
cancel	int
=	O
0	int
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
O_WRITE	O
)	O
==	O
0	int
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
EBADF	O
;	O
}	O
if	O
(	O
remote_input_mode	O
)	O
{	O
while	O
(	O
qsize	()->(int)
(	O
inputq	O
)	O
&&	O
!	O
cancel	int
)	O
{	O
if	O
(	O
cred	*(struct)
->	O
po	*(struct)
->	O
openmodes	O
&	O
O_NONBLOCK	int
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
EWOULDBLOCK	O
;	O
}	O
cancel	int
=	O
pthread_hurd_cond_wait_np	()->(int)
(	O
inputq	O
->	O
wait	O
,	O
&	O
global_lock	O
)	O
;	O
}	O
if	O
(	O
cancel	int
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
EINTR	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
datalen	*(int)
;	O
i	int
++	O
)	O
enqueue	()->(int)
(	O
&	O
inputq	O
,	O
data	*(*(char))
[	O
i	int
]	O
)	O
;	O
enqueue	()->(int)
(	O
&	O
inputq	O
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
termstate	O
.	O
c_cflag	short
&	O
CREAD	O
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
datalen	*(int)
;	O
i	int
++	O
)	O
{	O
flush	int
=	O
input_character	()->(int)
(	O
data	*(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
flush	int
)	O
{	O
if	O
(	O
packet_mode	int
)	O
{	O
control_byte	char
|=	O
TIOCPKT_FLUSHREAD	int
;	O
wake_reader	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
}	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
*	O
amount	int
=	O
datalen	*(int)
;	O
return	O
0	int
;	O
}	O
error_t	O
pty_io_readable	(*(long))->(int)
(	O
size_t	long
*	O
amt	*(long)
)	O
{	O
pthread_mutex_lock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
control_byte	char
)	O
{	O
*	O
amt	*(long)
=	O
1	int
;	O
if	O
(	O
packet_mode	int
&&	O
(	O
control_byte	char
&	O
TIOCPKT_IOCTL	int
)	O
)	O
*	O
amt	*(long)
+=	O
sizeof	O
(	O
struct	O
termios	O
)	O
;	O
}	O
else	O
*	O
amt	*(long)
=	O
qsize	()->(int)
(	O
outputq	O
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
pty_io_select	(*(struct),int,*(struct),*(int))->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
mach_port_t	O
reply	int
,	O
struct	O
timespec	O
*	O
tsp	*(struct)
,	O
int	O
*	O
type	enum(int,int,int,int)
)	O
{	O
int	O
avail	int
=	O
0	int
;	O
error_t	O
err	O
;	O
if	O
(	O
*	O
type	enum(int,int,int,int)
==	O
0	int
)	O
return	O
0	int
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
(	O
*	O
type	enum(int,int,int,int)
&	O
SELECT_READ	O
)	O
&&	O
(	O
control_byte	char
||	O
qsize	()->(int)
(	O
outputq	O
)	O
||	O
!	O
(	O
termflags	O
&	O
TTY_OPEN	O
)	O
)	O
)	O
avail	int
|=	O
SELECT_READ	O
;	O
if	O
(	O
(	O
*	O
type	enum(int,int,int,int)
&	O
SELECT_URG	O
)	O
&&	O
control_byte	char
)	O
avail	int
|=	O
SELECT_URG	O
;	O
if	O
(	O
(	O
*	O
type	enum(int,int,int,int)
&	O
SELECT_WRITE	O
)	O
&&	O
(	O
!	O
remote_input_mode	O
||	O
!	O
qsize	()->(int)
(	O
inputq	O
)	O
)	O
)	O
avail	int
|=	O
SELECT_WRITE	O
;	O
if	O
(	O
avail	int
)	O
{	O
*	O
type	enum(int,int,int,int)
=	O
avail	int
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
0	int
;	O
}	O
ports_interrupt_self_on_port_death	()->(int)
(	O
cred	*(struct)
,	O
reply	int
)	O
;	O
pty_read_blocked	int
=	O
1	int
;	O
err	O
=	O
pthread_hurd_cond_timedwait_np	()->(int)
(	O
&	O
pty_select_wakeup	int
,	O
&	O
global_lock	O
,	O
tsp	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
{	O
*	O
type	enum(int,int,int,int)
=	O
0	int
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
err	O
==	O
ETIMEDOUT	O
)	O
err	O
=	O
0	int
;	O
return	O
err	O
;	O
}	O
}	O
}	O
error_t	O
S_tioctl_tiocsig	(*(struct),int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
sig	int
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	O
.	O
bucket	O
!=	O
term_bucket	O
||	O
cred	*(struct)
->	O
pi	O
.	O
class	O
!=	O
pty_class	O
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
drop_output	()->(int)
(	O
)	O
;	O
clear_queue	()->(int)
(	O
inputq	O
)	O
;	O
clear_queue	()->(int)
(	O
rawq	O
)	O
;	O
ptyio_notice_input_flushed	()->(int)
(	O
)	O
;	O
send_signal	()->(int)
(	O
sig	int
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_tioctl_tiocpkt	(*(struct),int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
mode	int
)	O
{	O
error_t	O
err	O
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	O
.	O
bucket	O
!=	O
term_bucket	O
||	O
cred	*(struct)
->	O
pi	O
.	O
class	O
!=	O
pty_class	O
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
!	O
!	O
mode	int
==	O
!	O
!	O
packet_mode	int
)	O
err	O
=	O
0	int
;	O
else	O
if	O
(	O
mode	int
&&	O
user_ioctl_mode	int
)	O
err	O
=	O
EINVAL	O
;	O
else	O
{	O
packet_mode	int
=	O
mode	int
;	O
control_byte	char
=	O
0	int
;	O
err	O
=	O
0	int
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
err	O
;	O
}	O
error_t	O
S_tioctl_tiocucntl	(*(struct),int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
mode	int
)	O
{	O
error_t	O
err	O
;	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	O
.	O
bucket	O
!=	O
term_bucket	O
||	O
cred	*(struct)
->	O
pi	O
.	O
class	O
!=	O
pty_class	O
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
!	O
!	O
mode	int
==	O
!	O
!	O
user_ioctl_mode	int
)	O
err	O
=	O
0	int
;	O
else	O
if	O
(	O
mode	int
&&	O
packet_mode	int
)	O
err	O
=	O
EINVAL	O
;	O
else	O
{	O
user_ioctl_mode	int
=	O
mode	int
;	O
control_byte	char
=	O
0	int
;	O
err	O
=	O
0	int
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
err	O
;	O
}	O
error_t	O
S_tioctl_tiocremote	(*(struct),int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
how	int
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	O
.	O
bucket	O
!=	O
term_bucket	O
||	O
cred	*(struct)
->	O
pi	O
.	O
class	O
!=	O
pty_class	O
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
remote_input_mode	O
=	O
how	int
;	O
drop_output	()->(int)
(	O
)	O
;	O
clear_queue	()->(int)
(	O
inputq	O
)	O
;	O
clear_queue	()->(int)
(	O
rawq	O
)	O
;	O
ptyio_notice_input_flushed	()->(int)
(	O
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_tioctl_tiocext	(*(struct),int)->(int)
(	O
struct	O
trivfs_protid	O
*	O
cred	*(struct)
,	O
int	O
mode	int
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
||	O
cred	*(struct)
->	O
pi	O
.	O
bucket	O
!=	O
term_bucket	O
||	O
cred	*(struct)
->	O
pi	O
.	O
class	O
!=	O
pty_class	O
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
mode	int
&&	O
!	O
external_processing	O
)	O
{	O
if	O
(	O
packet_mode	int
)	O
{	O
control_byte	char
|=	O
TIOCPKT_IOCTL	int
;	O
wake_reader	()->(void)
(	O
)	O
;	O
}	O
external_processing	O
=	O
1	int
;	O
termstate	O
.	O
c_lflag	short
|=	O
EXTPROC	O
;	O
}	O
else	O
if	O
(	O
!	O
mode	int
&&	O
external_processing	O
)	O
{	O
if	O
(	O
packet_mode	int
)	O
{	O
control_byte	char
|=	O
TIOCPKT_IOCTL	int
;	O
wake_reader	()->(void)
(	O
)	O
;	O
}	O
external_processing	O
=	O
0	int
;	O
termstate	O
.	O
c_lflag	short
&=	O
~	O
EXTPROC	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
0	int
;	O
}	O
