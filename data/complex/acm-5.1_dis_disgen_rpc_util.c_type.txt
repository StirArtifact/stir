static	O
char	O
rcsid	array(char)
[	O
]	O
=	O
"$Id: rpc_util.c,v 1.1.1.1 2005/10/28 14:46:46 k0ro Exp $"	*(char)
;	O
char	O
curline	array(char)
[	O
MAXLINESIZE	int
]	O
;	O
char	O
*	O
where	*(char)
=	O
curline	array(char)
;	O
int	O
linenum	int
=	O
0	int
;	O
char	O
*	O
infilename	*(char)
;	O
char	O
*	O
outfiles	array(*(char))
[	O
NFILES	int
]	O
;	O
int	O
nfiles	int
;	O
FILE	struct
*	O
fout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
FILE	struct
*	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
list	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
*	O
defined	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
static	O
void	O
printwhere	()->(void)
(	O
)	O
;	O
void	O
crash	()->(void)
(	O
)	O
;	O
void	O
reinitialize	()->(void)
(	O
)	O
{	O
memset	O
(	O
curline	array(char)
,	O
0	int
,	O
MAXLINESIZE	int
)	O
;	O
where	*(char)
=	O
curline	array(char)
;	O
linenum	int
=	O
0	int
;	O
defined	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
NULL	O
;	O
}	O
streq	()->(int)
(	O
a	*(char)
,	O
b	*(char)
)	O
char	O
*	O
a	*(char)
;	O
char	O
*	O
b	*(char)
;	O
{	O
return	O
(	O
strcmp	O
(	O
a	*(char)
,	O
b	*(char)
)	O
==	O
0	int
)	O
;	O
}	O
char	O
*	O
findval	()->(*(char))
(	O
lst	*(struct(*(char),*(struct(*(char),*(struct`)))))
,	O
val	*(char)
,	O
cmp	*(()->(int))
)	O
list	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
*	O
lst	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
char	O
*	O
val	*(char)
;	O
int	O
(	O
*	O
cmp	*(()->(int))
)	O
(	O
)	O
;	O
{	O
for	O
(	O
;	O
lst	*(struct(*(char),*(struct(*(char),*(struct`)))))
!=	O
NULL	O
;	O
lst	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
lst	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
{	O
if	O
(	O
(	O
*	O
cmp	*(()->(int))
)	O
(	O
lst	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
val	*(char)
,	O
val	*(char)
)	O
)	O
{	O
return	O
(	O
lst	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
val	*(char)
)	O
;	O
}	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
void	O
storeval	()->(void)
(	O
lstp	*(*(struct(*(char),*(struct(*`,*`)))))
,	O
val	*(char)
)	O
list	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
*	O
*	O
lstp	*(*(struct(*(char),*(struct(*`,*`)))))
;	O
char	O
*	O
val	*(char)
;	O
{	O
list	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
*	O
*	O
l	*(*(struct(*(char),*(struct(*`,*`)))))
;	O
list	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
*	O
lst	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
for	O
(	O
l	*(*(struct(*(char),*(struct(*`,*`)))))
=	O
lstp	*(*(struct(*(char),*(struct(*`,*`)))))
;	O
*	O
l	*(*(struct(*(char),*(struct(*`,*`)))))
!=	O
NULL	O
;	O
l	*(*(struct(*(char),*(struct(*`,*`)))))
=	O
(	O
list	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
*	O
*	O
)	O
&	O
(	O
*	O
l	*(*(struct(*(char),*(struct(*`,*`)))))
)	O
->	O
next	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
;	O
lst	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
ALLOC	O
(	O
list	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
)	O
;	O
lst	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
val	*(char)
=	O
val	*(char)
;	O
lst	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
NULL	O
;	O
*	O
l	*(*(struct(*(char),*(struct(*`,*`)))))
=	O
lst	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
static	O
findit	(*(struct(*(char),enum(int,int,int,int,int,int),union(*(char),struct(*`,int,array(char)),struct(struct`,*`,*`),struct(*`),struct(*`,*`,int,array(char),enum(int,int,int,int,int),*`),struct(*`,*`)))),*(char))->(int)
(	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
,	O
type	*(char)
)	O
definition	struct(*(char),enum(int,int,int,int,int,int),union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`))))))
*	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
;	O
char	O
*	O
type	*(char)
;	O
{	O
return	O
(	O
streq	()->(int)
(	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
->	O
def_name	*(char)
,	O
type	*(char)
)	O
)	O
;	O
}	O
static	O
char	O
*	O
fixit	(*(char),*(char))->(*(char))
(	O
type	*(char)
,	O
orig	*(char)
)	O
char	O
*	O
type	*(char)
;	O
char	O
*	O
orig	*(char)
;	O
{	O
definition	struct(*(char),enum(int,int,int,int,int,int),union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`))))))
*	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
;	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
=	O
(	O
definition	struct(*(char),enum(int,int,int,int,int,int),union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`))))))
*	O
)	O
FINDVAL	O
(	O
defined	*(struct(*(char),*(struct(*(char),*(struct`)))))
,	O
type	*(char)
,	O
findit	(*(struct(*(char),enum(int,int,int,int,int,int),union(*(char),struct(*`,int,array(char)),struct(struct`,*`,*`),struct(*`),struct(*`,*`,int,array(char),enum(int,int,int,int,int),*`),struct(*`,*`)))),*(char))->(int)
)	O
;	O
if	O
(	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
==	O
NULL	O
||	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
->	O
def_kind	enum(int,int,int,int,int,int)
!=	O
DEF_TYPEDEF	int
)	O
{	O
return	O
(	O
orig	*(char)
)	O
;	O
}	O
switch	O
(	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
->	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
.	O
ty	struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char))
.	O
rel	enum(int,int,int,int,int)
)	O
{	O
case	O
REL_VECTOR	int
:	O
return	O
(	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
->	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
.	O
ty	struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char))
.	O
old_type	*(char)
)	O
;	O
case	O
REL_ALIAS	int
:	O
return	O
(	O
fixit	(*(char),*(char))->(*(char))
(	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
->	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
.	O
ty	struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char))
.	O
old_type	*(char)
,	O
orig	*(char)
)	O
)	O
;	O
default	O
:	O
return	O
(	O
orig	*(char)
)	O
;	O
}	O
}	O
char	O
*	O
fixtype	()->(*(char))
(	O
type	*(char)
)	O
char	O
*	O
type	*(char)
;	O
{	O
return	O
(	O
fixit	(*(char),*(char))->(*(char))
(	O
type	*(char)
,	O
type	*(char)
)	O
)	O
;	O
}	O
char	O
*	O
stringfix	()->(*(char))
(	O
type	*(char)
)	O
char	O
*	O
type	*(char)
;	O
{	O
if	O
(	O
streq	()->(int)
(	O
type	*(char)
,	O
"string"	*(char)
)	O
)	O
{	O
return	O
(	O
"wrapstring"	*(char)
)	O
;	O
}	O
else	O
{	O
return	O
(	O
type	*(char)
)	O
;	O
}	O
}	O
void	O
ptype	()->(void)
(	O
prefix	*(char)
,	O
type	*(char)
,	O
follow	int
)	O
char	O
*	O
prefix	*(char)
;	O
char	O
*	O
type	*(char)
;	O
int	O
follow	int
;	O
{	O
if	O
(	O
prefix	*(char)
!=	O
NULL	O
)	O
{	O
if	O
(	O
streq	()->(int)
(	O
prefix	*(char)
,	O
"enum"	*(char)
)	O
)	O
{	O
f_print	O
(	O
fout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"enum "	*(char)
)	O
;	O
}	O
else	O
{	O
f_print	O
(	O
fout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"struct "	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
streq	()->(int)
(	O
type	*(char)
,	O
"bool"	*(char)
)	O
)	O
{	O
f_print	O
(	O
fout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"bool_t "	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
streq	()->(int)
(	O
type	*(char)
,	O
"string"	*(char)
)	O
)	O
{	O
f_print	O
(	O
fout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"char *"	*(char)
)	O
;	O
}	O
else	O
{	O
f_print	O
(	O
fout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s "	*(char)
,	O
follow	int
?	O
fixtype	()->(*(char))
(	O
type	*(char)
)	O
:	O
type	*(char)
)	O
;	O
}	O
}	O
static	O
typedefed	(*(struct(*(char),enum(int,int,int,int,int,int),union(*(char),struct(*`,int,array(char)),struct(struct`,*`,*`),struct(*`),struct(*`,*`,int,array(char),enum(int,int,int,int,int),*`),struct(*`,*`)))),*(char))->(int)
(	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
,	O
type	*(char)
)	O
definition	struct(*(char),enum(int,int,int,int,int,int),union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`))))))
*	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
;	O
char	O
*	O
type	*(char)
;	O
{	O
if	O
(	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
->	O
def_kind	enum(int,int,int,int,int,int)
!=	O
DEF_TYPEDEF	int
||	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
->	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
.	O
ty	struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char))
.	O
old_prefix	*(char)
!=	O
NULL	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
return	O
(	O
streq	()->(int)
(	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
->	O
def_name	*(char)
,	O
type	*(char)
)	O
)	O
;	O
}	O
}	O
isvectordef	()->(int)
(	O
type	*(char)
,	O
rel	enum(int,int,int,int,int)
)	O
char	O
*	O
type	*(char)
;	O
relation	enum(int,int,int,int,int)
rel	enum(int,int,int,int,int)
;	O
{	O
definition	struct(*(char),enum(int,int,int,int,int,int),union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`))))))
*	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
;	O
for	O
(	O
;	O
;	O
)	O
{	O
switch	O
(	O
rel	enum(int,int,int,int,int)
)	O
{	O
case	O
REL_VECTOR	int
:	O
return	O
(	O
!	O
streq	()->(int)
(	O
type	*(char)
,	O
"string"	*(char)
)	O
)	O
;	O
case	O
REL_ARRAY	int
:	O
case	O
REL_ARRAY2	int
:	O
return	O
(	O
0	int
)	O
;	O
case	O
REL_POINTER	int
:	O
return	O
(	O
0	int
)	O
;	O
case	O
REL_ALIAS	int
:	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
=	O
(	O
definition	struct(*(char),enum(int,int,int,int,int,int),union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`))))))
*	O
)	O
FINDVAL	O
(	O
defined	*(struct(*(char),*(struct(*(char),*(struct`)))))
,	O
type	*(char)
,	O
typedefed	(*(struct(*(char),enum(int,int,int,int,int,int),union(*(char),struct(*`,int,array(char)),struct(struct`,*`,*`),struct(*`),struct(*`,*`,int,array(char),enum(int,int,int,int,int),*`),struct(*`,*`)))),*(char))->(int)
)	O
;	O
if	O
(	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
==	O
NULL	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
type	*(char)
=	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
->	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
.	O
ty	struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char))
.	O
old_type	*(char)
;	O
rel	enum(int,int,int,int,int)
=	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
->	O
def	union(*(char),struct(*(struct(struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),int,array(char)),struct(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)),*(struct(*(char),struct(*`,*`,int,array(char),*`,enum(int,int,int,int,int),*`),*(struct`))),*(struct(*(char),*(char),int,array(char),*(char),enum(int,int,int,int,int),*(char)))),struct(*(struct(*(char),*(char),*(struct`)))),struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char)),struct(*(char),*(struct(*(char),*(char),*(struct`),*(struct`)))))
.	O
ty	struct(*(char),*(char),int,array(char),enum(int,int,int,int,int),*(char))
.	O
rel	enum(int,int,int,int,int)
;	O
}	O
}	O
}	O
static	O
char	O
*	O
locase	(*(char))->(*(char))
(	O
str	*(char)
)	O
char	O
*	O
str	*(char)
;	O
{	O
char	O
c	char
;	O
static	O
char	O
buf	array(char)
[	O
100	int
]	O
;	O
char	O
*	O
p	*(char)
=	O
buf	array(char)
;	O
while	O
(	O
c	char
=	O
*	O
str	*(char)
++	O
)	O
{	O
*	O
p	*(char)
++	O
=	O
(	O
c	char
>=	O
'A'	O
&&	O
c	char
<=	O
'Z'	O
)	O
?	O
(	O
c	char
-	O
'A'	O
+	O
'a'	O
)	O
:	O
c	char
;	O
}	O
*	O
p	*(char)
=	O
0	int
;	O
return	O
(	O
buf	array(char)
)	O
;	O
}	O
void	O
pvname	()->(void)
(	O
pname	*(char)
,	O
vnum	*(char)
)	O
char	O
*	O
pname	*(char)
;	O
char	O
*	O
vnum	*(char)
;	O
{	O
f_print	O
(	O
fout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s_%s"	*(char)
,	O
locase	(*(char))->(*(char))
(	O
pname	*(char)
)	O
,	O
vnum	*(char)
)	O
;	O
}	O
void	O
error	()->(void)
(	O
msg	*(char)
)	O
char	O
*	O
msg	*(char)
;	O
{	O
printwhere	()->(void)
(	O
)	O
;	O
f_print	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s, line %d: "	*(char)
,	O
infilename	*(char)
,	O
linenum	int
)	O
;	O
f_print	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
msg	*(char)
)	O
;	O
crash	()->(void)
(	O
)	O
;	O
}	O
void	O
crash	()->(void)
(	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nfiles	int
;	O
i	int
++	O
)	O
{	O
(	O
void	O
)	O
unlink	()->(int)
(	O
outfiles	array(*(char))
[	O
i	int
]	O
)	O
;	O
}	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
void	O
record_open	()->(void)
(	O
file	*(char)
)	O
char	O
*	O
file	*(char)
;	O
{	O
if	O
(	O
nfiles	int
<	O
NFILES	int
)	O
{	O
outfiles	array(*(char))
[	O
nfiles	int
++	O
]	O
=	O
file	*(char)
;	O
}	O
else	O
{	O
f_print	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"too many files!\n"	*(char)
)	O
;	O
crash	()->(void)
(	O
)	O
;	O
}	O
}	O
static	O
char	O
expectbuf	array(char)
[	O
100	int
]	O
;	O
static	O
char	O
*	O
toktostr	()->(*(char))
(	O
)	O
;	O
void	O
expected1	()->(void)
(	O
exp1	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
tok_kind	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
exp1	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
{	O
s_print	O
(	O
expectbuf	array(char)
,	O
"expected '%s'"	*(char)
,	O
toktostr	()->(*(char))
(	O
exp1	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
)	O
;	O
error	()->(void)
(	O
expectbuf	array(char)
)	O
;	O
}	O
void	O
expected2	()->(void)
(	O
exp1	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
exp2	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
tok_kind	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
exp1	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
exp2	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
{	O
s_print	O
(	O
expectbuf	array(char)
,	O
"expected '%s' or '%s'"	*(char)
,	O
toktostr	()->(*(char))
(	O
exp1	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
,	O
toktostr	()->(*(char))
(	O
exp2	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
)	O
;	O
error	()->(void)
(	O
expectbuf	array(char)
)	O
;	O
}	O
void	O
expected3	()->(void)
(	O
exp1	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
exp2	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
exp3	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
tok_kind	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
exp1	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
exp2	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
exp3	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
{	O
s_print	O
(	O
expectbuf	array(char)
,	O
"expected '%s', '%s' or '%s'"	*(char)
,	O
toktostr	()->(*(char))
(	O
exp1	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
,	O
toktostr	()->(*(char))
(	O
exp2	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
,	O
toktostr	()->(*(char))
(	O
exp3	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
)	O
;	O
error	()->(void)
(	O
expectbuf	array(char)
)	O
;	O
}	O
void	O
tabify	()->(void)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
tab	int
)	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
tab	int
;	O
{	O
while	O
(	O
tab	int
--	O
)	O
{	O
(	O
void	O
)	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\t'	O
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
static	O
token	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char))
tokstrings	array(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
[	O
]	O
=	O
{	O
{	O
TOK_IDENT	int
,	O
"identifier"	*(char)
}	O
,	O
{	O
TOK_CONST	int
,	O
"const"	*(char)
}	O
,	O
{	O
TOK_RPAREN	int
,	O
")"	*(char)
}	O
,	O
{	O
TOK_LPAREN	int
,	O
"("	*(char)
}	O
,	O
{	O
TOK_RBRACE	int
,	O
"}"	*(char)
}	O
,	O
{	O
TOK_LBRACE	int
,	O
"{"	*(char)
}	O
,	O
{	O
TOK_LBRACKET	int
,	O
"["	*(char)
}	O
,	O
{	O
TOK_RBRACKET	int
,	O
"]"	*(char)
}	O
,	O
{	O
TOK_STAR	int
,	O
"*"	*(char)
}	O
,	O
{	O
TOK_COMMA	int
,	O
","	*(char)
}	O
,	O
{	O
TOK_EQUAL	int
,	O
"="	*(char)
}	O
,	O
{	O
TOK_COLON	int
,	O
":"	*(char)
}	O
,	O
{	O
TOK_SEMICOLON	int
,	O
";"	*(char)
}	O
,	O
{	O
TOK_UNION	int
,	O
"union"	*(char)
}	O
,	O
{	O
TOK_STRUCT	int
,	O
"struct"	*(char)
}	O
,	O
{	O
TOK_SWITCH	int
,	O
"switch"	*(char)
}	O
,	O
{	O
TOK_CASE	int
,	O
"case"	*(char)
}	O
,	O
{	O
TOK_DEFAULT	int
,	O
"default"	*(char)
}	O
,	O
{	O
TOK_ENUM	int
,	O
"enum"	*(char)
}	O
,	O
{	O
TOK_TYPEDEF	int
,	O
"typedef"	*(char)
}	O
,	O
{	O
TOK_INT	int
,	O
"int"	*(char)
}	O
,	O
{	O
TOK_SHORT	int
,	O
"short"	*(char)
}	O
,	O
{	O
TOK_LONG	int
,	O
"long"	*(char)
}	O
,	O
{	O
TOK_UNSIGNED	int
,	O
"unsigned"	*(char)
}	O
,	O
{	O
TOK_DOUBLE	int
,	O
"double"	*(char)
}	O
,	O
{	O
TOK_FLOAT	int
,	O
"float"	*(char)
}	O
,	O
{	O
TOK_CHAR	int
,	O
"char"	*(char)
}	O
,	O
{	O
TOK_STRING	int
,	O
"string"	*(char)
}	O
,	O
{	O
TOK_OPAQUE	int
,	O
"opaque"	*(char)
}	O
,	O
{	O
TOK_BOOL	int
,	O
"bool"	*(char)
}	O
,	O
{	O
TOK_VOID	int
,	O
"void"	*(char)
}	O
,	O
{	O
TOK_PROGRAM	int
,	O
"program"	*(char)
}	O
,	O
{	O
TOK_VERSION	int
,	O
"version"	*(char)
}	O
,	O
{	O
TOK_EOF	int
,	O
"??????"	*(char)
}	O
}	O
;	O
static	O
char	O
*	O
toktostr	()->(*(char))
(	O
kind	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
tok_kind	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
kind	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
{	O
token	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char))
*	O
sp	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
;	O
for	O
(	O
sp	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
=	O
tokstrings	array(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
;	O
sp	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
->	O
kind	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
TOK_EOF	int
&&	O
sp	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
->	O
kind	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
kind	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
sp	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
++	O
)	O
;	O
return	O
(	O
sp	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
->	O
str	*(char)
)	O
;	O
}	O
static	O
void	O
printbuf	()->(void)
(	O
)	O
{	O
char	O
c	char
;	O
int	O
i	int
;	O
int	O
cnt	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
c	char
=	O
curline	array(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
c	char
==	O
'\t'	O
)	O
{	O
cnt	int
=	O
8	int
-	O
(	O
i	int
%	O
TABSIZE	int
)	O
;	O
c	char
=	O
' '	O
;	O
}	O
else	O
{	O
cnt	int
=	O
1	int
;	O
}	O
while	O
(	O
cnt	int
--	O
)	O
{	O
(	O
void	O
)	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	char
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
}	O
static	O
void	O
printwhere	()->(void)
(	O
)	O
{	O
int	O
i	int
;	O
char	O
c	char
;	O
int	O
cnt	int
;	O
printbuf	()->(void)
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
where	*(char)
-	O
curline	array(char)
;	O
i	int
++	O
)	O
{	O
c	char
=	O
curline	array(char)
[	O
i	int
]	O
;	O
if	O
(	O
c	char
==	O
'\t'	O
)	O
{	O
cnt	int
=	O
8	int
-	O
(	O
i	int
%	O
TABSIZE	int
)	O
;	O
}	O
else	O
{	O
cnt	int
=	O
1	int
;	O
}	O
while	O
(	O
cnt	int
--	O
)	O
{	O
(	O
void	O
)	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'^'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
(	O
void	O
)	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
