OM_uint32	int
gss_import_name	(*(int),*(struct(long,*(void))),*(struct(int,*(void))),*(*(struct)))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
const	O
gss_buffer_t	*(struct(long,*(void)))
input_name_buffer	*(struct(long,*(void)))
,	O
const	O
gss_OID	*(struct(int,*(void)))
input_name_type	*(struct(int,*(void)))
,	O
gss_name_t	*(struct)
*	O
output_name	*(*(struct))
)	O
{	O
if	O
(	O
!	O
output_name	*(*(struct))
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_BAD_NAME	O
|	O
GSS_S_CALL_INACCESSIBLE_WRITE	O
;	O
}	O
*	O
output_name	*(*(struct))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
*	O
output_name	*(*(struct))
)	O
)	O
;	O
if	O
(	O
!	O
*	O
output_name	*(*(struct))
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
ENOMEM	int
;	O
return	O
GSS_S_FAILURE	O
;	O
}	O
(	O
*	O
output_name	*(*(struct))
)	O
->	O
length	int
=	O
input_name_buffer	*(struct(long,*(void)))
->	O
length	int
;	O
(	O
*	O
output_name	*(*(struct))
)	O
->	O
value	*(void)
=	O
malloc	(long)->(*(void))
(	O
input_name_buffer	*(struct(long,*(void)))
->	O
length	int
)	O
;	O
if	O
(	O
!	O
(	O
*	O
output_name	*(*(struct))
)	O
->	O
value	*(void)
)	O
{	O
free	(*(void))->(void)
(	O
*	O
output_name	*(*(struct))
)	O
;	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
ENOMEM	int
;	O
return	O
GSS_S_FAILURE	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
(	O
*	O
output_name	*(*(struct))
)	O
->	O
value	*(void)
,	O
input_name_buffer	*(struct(long,*(void)))
->	O
value	*(void)
,	O
input_name_buffer	*(struct(long,*(void)))
->	O
length	int
)	O
;	O
(	O
*	O
output_name	*(*(struct))
)	O
->	O
type	*(struct(int,*(void)))
=	O
input_name_type	*(struct(int,*(void)))
;	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
OM_uint32	int
gss_display_name	(*(int),*(struct),*(struct(long,*(void))),*(*(struct(int,*(void)))))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
const	O
gss_name_t	*(struct)
input_name	*(struct)
,	O
gss_buffer_t	*(struct(long,*(void)))
output_name_buffer	*(struct(long,*(void)))
,	O
gss_OID	*(struct(int,*(void)))
*	O
output_name_type	*(*(struct(int,*(void))))
)	O
{	O
if	O
(	O
!	O
input_name	*(struct)
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_BAD_NAME	O
;	O
}	O
output_name_buffer	*(struct(long,*(void)))
->	O
length	int
=	O
input_name	*(struct)
->	O
length	int
;	O
output_name_buffer	*(struct(long,*(void)))
->	O
value	*(void)
=	O
malloc	(long)->(*(void))
(	O
input_name	*(struct)
->	O
length	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
output_name_buffer	*(struct(long,*(void)))
->	O
value	*(void)
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
ENOMEM	int
;	O
return	O
GSS_S_FAILURE	O
;	O
}	O
if	O
(	O
input_name	*(struct)
->	O
value	*(void)
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
output_name_buffer	*(struct(long,*(void)))
->	O
value	*(void)
,	O
input_name	*(struct)
->	O
value	*(void)
,	O
input_name	*(struct)
->	O
length	int
)	O
;	O
if	O
(	O
output_name_type	*(*(struct(int,*(void))))
)	O
*	O
output_name_type	*(*(struct(int,*(void))))
=	O
input_name	*(struct)
->	O
type	*(struct(int,*(void)))
;	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
OM_uint32	int
gss_compare_name	(*(int),*(struct),*(struct),*(int))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
const	O
gss_name_t	*(struct)
name1	*(struct)
,	O
const	O
gss_name_t	*(struct)
name2	*(struct)
,	O
int	O
*	O
name_equal	*(int)
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
if	O
(	O
!	O
name1	*(struct)
||	O
!	O
name2	*(struct)
)	O
return	O
GSS_S_BAD_NAME	O
|	O
GSS_S_CALL_INACCESSIBLE_READ	O
;	O
if	O
(	O
!	O
gss_oid_equal	(*(struct(int,*(void))),*(struct(int,*(void))))->(int)
(	O
name1	*(struct)
->	O
type	*(struct(int,*(void)))
,	O
name2	*(struct)
->	O
type	*(struct(int,*(void)))
)	O
)	O
return	O
GSS_S_BAD_NAMETYPE	O
;	O
if	O
(	O
name_equal	*(int)
)	O
*	O
name_equal	*(int)
=	O
(	O
name1	*(struct)
->	O
length	int
==	O
name2	*(struct)
->	O
length	int
)	O
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
name1	*(struct)
->	O
value	*(void)
,	O
name2	*(struct)
->	O
value	*(void)
,	O
name1	*(struct)
->	O
length	int
)	O
==	O
0	int
;	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
OM_uint32	int
gss_release_name	(*(int),*(*(struct)))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
gss_name_t	*(struct)
*	O
name	*(*(struct))
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
if	O
(	O
!	O
name	*(*(struct))
)	O
return	O
GSS_S_BAD_NAME	O
|	O
GSS_S_CALL_INACCESSIBLE_READ	O
;	O
if	O
(	O
*	O
name	*(*(struct))
!=	O
GSS_C_NO_NAME	O
)	O
{	O
if	O
(	O
(	O
*	O
name	*(*(struct))
)	O
->	O
value	*(void)
)	O
free	(*(void))->(void)
(	O
(	O
*	O
name	*(*(struct))
)	O
->	O
value	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
*	O
name	*(*(struct))
)	O
;	O
*	O
name	*(*(struct))
=	O
GSS_C_NO_NAME	O
;	O
}	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
OM_uint32	int
gss_inquire_names_for_mech	(*(int),*(struct(int,*(void))),*(*(struct(long,*(struct`)))))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
const	O
gss_OID	*(struct(int,*(void)))
mechanism	*(struct(int,*(void)))
,	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
*	O
name_types	*(*(struct(long,*(struct(int,*`)))))
)	O
{	O
OM_uint32	int
maj_stat	int
;	O
_gss_mech_api_t	*(struct(*(struct(int,*(void))),*(char),*(char),*(char),array(*(struct(int,*(void)))),*((*(int),*(struct`),*(*`),*(struct`),*(struct`),int,int,*(struct`),*(struct`),*(*`),*(struct`),*(int),*(int))->(int)),*((*(int),*(struct`),*(struct`),*(*`))->(int)),*((*(int),*(struct`),*(struct`))->(int)),*((*(int),*(struct`),int,int,*(struct`),*(int),*(struct`))->(int)),*((*(int),*(struct`),*(struct`),*(struct`),*(int),*(int))->(int)),*((*(int),*(struct`),int,*(struct`),*(struct`))->(int)),*((*(int),*(struct`),*(struct`),*(struct`),*(int))->(int)),*((*(int),int,int,*(struct`),*(int),*(struct`))->(int)),*((*(int),*(struct`),int,*(struct`),int,*(*`),*(*`),*(int))->(int)),*((*(int),*(*`))->(int)),*((*(int),*(*`),*(struct`),*(struct`),*(struct`),*(*`),*(*`),*(struct`),*(int),*(int),*(*`))->(int)),*((*(int),*(*`),*(struct`))->(int)),*((*(int),*(struct`),*(int))->(int)),*((*(int),*(struct`),*(*`),*(int),*(int),*(*`))->(int)),*((*(int),*(struct`),*(struct`),*(*`),*(int),*(int),*(int))->(int))))
mech	*(struct(int,*(void)))
;	O
int	O
i	int
;	O
mech	*(struct(int,*(void)))
=	O
_gss_find_mech	(*(struct(int,*(void))))->(*(struct(*(struct(int,*`)),*(char),*(char),*(char),array(*(struct(int,*(void)))),*((*`,*`,*`,*`,*`,int,int,*`,*`,*`,*`,*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`,int,int,*`,*`,*`)->(int)),*((*`,*`,*`,*`,*`,*`)->(int)),*((*`,*`,int,*`,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,int,int,*`,*`,*`)->(int)),*((*`,*`,int,*`,int,*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`,*`,*`,*`,*`)->(int)),*((*`,*`,*`,*`,*`,*`,*`)->(int)))))
(	O
mechanism	*(struct(int,*(void)))
)	O
;	O
maj_stat	int
=	O
gss_create_empty_oid_set	(*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
name_types	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
if	O
(	O
maj_stat	int
!=	O
GSS_S_COMPLETE	int
)	O
return	O
maj_stat	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
mech	*(struct(int,*(void)))
->	O
name_types	*(*(struct(long,*(struct(int,*`)))))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
maj_stat	int
=	O
gss_add_oid_set_member	(*(int),*(struct(int,*(void))),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
mech	*(struct(int,*(void)))
->	O
name_types	*(*(struct(long,*(struct(int,*`)))))
[	O
i	int
]	O
,	O
name_types	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
if	O
(	O
maj_stat	int
!=	O
GSS_S_COMPLETE	int
)	O
{	O
gss_release_oid_set	(*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
name_types	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
return	O
maj_stat	int
;	O
}	O
}	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
static	O
OM_uint32	int
_gss_inquire_mechs_for_name3	(*(int),*(struct(int,*(void))),*(struct(int,*(void))),*(*(struct(long,*(struct`)))))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
gss_OID	*(struct(int,*(void)))
mech	*(struct(int,*(void)))
,	O
gss_OID	*(struct(int,*(void)))
name_type	*(struct(int,*(void)))
,	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
*	O
mech_types	*(*(struct(long,*(struct(int,*`)))))
)	O
{	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
oids	*(struct(long,*(struct(int,*(void)))))
;	O
int	O
supported	int
;	O
OM_uint32	int
maj_stat	int
;	O
maj_stat	int
=	O
gss_inquire_names_for_mech	(*(int),*(struct(int,*(void))),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
mech	*(struct(int,*(void)))
,	O
&	O
oids	*(struct(long,*(struct(int,*(void)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
maj_stat	int
=	O
gss_test_oid_set_member	(*(int),*(struct(int,*(void))),*(struct(long,*(struct(int,*`)))),*(int))->(int)
(	O
minor_status	*(int)
,	O
name_type	*(struct(int,*(void)))
,	O
oids	*(struct(long,*(struct(int,*(void)))))
,	O
&	O
supported	int
)	O
;	O
gss_release_oid_set	(*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
&	O
oids	*(struct(long,*(struct(int,*(void)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
if	O
(	O
supported	int
)	O
{	O
maj_stat	int
=	O
gss_add_oid_set_member	(*(int),*(struct(int,*(void))),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
mech	*(struct(int,*(void)))
,	O
mech_types	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
}	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
static	O
OM_uint32	int
_gss_inquire_mechs_for_name2	(*(int),*(struct(int,*(void))),*(*(struct(long,*(struct`)))),*(struct(long,*(struct(int,*`)))))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
gss_OID	*(struct(int,*(void)))
name_type	*(struct(int,*(void)))
,	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
*	O
out_mech_types	*(*(struct(long,*(struct(int,*`)))))
,	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
supported_mech_types	*(struct(long,*(struct(int,*(void)))))
)	O
{	O
OM_uint32	int
maj_stat	int
;	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
supported_mech_types	*(struct(long,*(struct(int,*(void)))))
->	O
count	long
;	O
i	int
++	O
)	O
{	O
maj_stat	int
=	O
_gss_inquire_mechs_for_name3	(*(int),*(struct(int,*(void))),*(struct(int,*(void))),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
&	O
(	O
supported_mech_types	*(struct(long,*(struct(int,*(void)))))
->	O
elements	*(void)
)	O
[	O
i	int
]	O
,	O
name_type	*(struct(int,*(void)))
,	O
out_mech_types	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
}	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
static	O
OM_uint32	int
_gss_inquire_mechs_for_name1	(*(int),*(struct(int,*(void))),*(*(struct(long,*(struct`)))))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
gss_OID	*(struct(int,*(void)))
name_type	*(struct(int,*(void)))
,	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
*	O
out_mech_types	*(*(struct(long,*(struct(int,*`)))))
)	O
{	O
OM_uint32	int
maj_stat	int
;	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
supported_mech_types	*(struct(long,*(struct(int,*(void)))))
;	O
maj_stat	int
=	O
gss_indicate_mechs	(*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
&	O
supported_mech_types	*(struct(long,*(struct(int,*(void)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
maj_stat	int
=	O
_gss_inquire_mechs_for_name2	(*(int),*(struct(int,*(void))),*(*(struct(long,*(struct`)))),*(struct(long,*(struct(int,*`)))))->(int)
(	O
minor_status	*(int)
,	O
name_type	*(struct(int,*(void)))
,	O
out_mech_types	*(*(struct(long,*(struct(int,*`)))))
,	O
supported_mech_types	*(struct(long,*(struct(int,*(void)))))
)	O
;	O
gss_release_oid_set	(*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
&	O
supported_mech_types	*(struct(long,*(struct(int,*(void)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
OM_uint32	int
gss_inquire_mechs_for_name	(*(int),*(struct),*(*(struct(long,*(struct`)))))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
const	O
gss_name_t	*(struct)
input_name	*(struct)
,	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
*	O
mech_types	*(*(struct(long,*(struct(int,*`)))))
)	O
{	O
OM_uint32	int
maj_stat	int
;	O
if	O
(	O
input_name	*(struct)
==	O
GSS_C_NO_NAME	O
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_BAD_NAME	O
|	O
GSS_S_CALL_INACCESSIBLE_READ	O
;	O
}	O
maj_stat	int
=	O
gss_create_empty_oid_set	(*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
mech_types	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
maj_stat	int
=	O
_gss_inquire_mechs_for_name1	(*(int),*(struct(int,*(void))),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
input_name	*(struct)
->	O
type	*(struct(int,*(void)))
,	O
mech_types	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
{	O
gss_release_oid_set	(*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
mech_types	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
return	O
maj_stat	int
;	O
}	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
OM_uint32	int
gss_export_name	(*(int),*(struct),*(struct(long,*(void))))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
const	O
gss_name_t	*(struct)
input_name	*(struct)
,	O
gss_buffer_t	*(struct(long,*(void)))
exported_name	*(struct(long,*(void)))
)	O
{	O
OM_uint32	int
maj_stat	int
;	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
mechs	*(struct(long,*(struct(int,*(void)))))
;	O
_gss_mech_api_t	*(struct(*(struct(int,*(void))),*(char),*(char),*(char),array(*(struct(int,*(void)))),*((*(int),*(struct`),*(*`),*(struct`),*(struct`),int,int,*(struct`),*(struct`),*(*`),*(struct`),*(int),*(int))->(int)),*((*(int),*(struct`),*(struct`),*(*`))->(int)),*((*(int),*(struct`),*(struct`))->(int)),*((*(int),*(struct`),int,int,*(struct`),*(int),*(struct`))->(int)),*((*(int),*(struct`),*(struct`),*(struct`),*(int),*(int))->(int)),*((*(int),*(struct`),int,*(struct`),*(struct`))->(int)),*((*(int),*(struct`),*(struct`),*(struct`),*(int))->(int)),*((*(int),int,int,*(struct`),*(int),*(struct`))->(int)),*((*(int),*(struct`),int,*(struct`),int,*(*`),*(*`),*(int))->(int)),*((*(int),*(*`))->(int)),*((*(int),*(*`),*(struct`),*(struct`),*(struct`),*(*`),*(*`),*(struct`),*(int),*(int),*(*`))->(int)),*((*(int),*(*`),*(struct`))->(int)),*((*(int),*(struct`),*(int))->(int)),*((*(int),*(struct`),*(*`),*(int),*(int),*(*`))->(int)),*((*(int),*(struct`),*(struct`),*(*`),*(int),*(int),*(int))->(int))))
mech	*(struct(int,*(void)))
;	O
maj_stat	int
=	O
gss_inquire_mechs_for_name	(*(int),*(struct),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
input_name	*(struct)
,	O
&	O
mechs	*(struct(long,*(struct(int,*(void)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
if	O
(	O
mechs	*(struct(long,*(struct(int,*(void)))))
->	O
count	long
==	O
0	int
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_BAD_NAMETYPE	O
;	O
}	O
mech	*(struct(int,*(void)))
=	O
_gss_find_mech	(*(struct(int,*(void))))->(*(struct(*(struct(int,*`)),*(char),*(char),*(char),array(*(struct(int,*(void)))),*((*`,*`,*`,*`,*`,int,int,*`,*`,*`,*`,*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`,int,int,*`,*`,*`)->(int)),*((*`,*`,*`,*`,*`,*`)->(int)),*((*`,*`,int,*`,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,int,int,*`,*`,*`)->(int)),*((*`,*`,int,*`,int,*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`,*`,*`,*`,*`)->(int)),*((*`,*`,*`,*`,*`,*`,*`)->(int)))))
(	O
mechs	*(struct(long,*(struct(int,*(void)))))
->	O
elements	*(void)
)	O
;	O
if	O
(	O
mech	*(struct(int,*(void)))
==	O
NULL	O
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_BAD_MECH	O
;	O
}	O
return	O
mech	*(struct(int,*(void)))
->	O
export_name	*((*(int),*(struct(long,*(char),*(struct`))),*(struct(long,*(void))))->(int))
(	O
minor_status	*(int)
,	O
input_name	*(struct)
,	O
exported_name	*(struct(long,*(void)))
)	O
;	O
}	O
OM_uint32	int
gss_canonicalize_name	(*(int),*(struct),*(struct(int,*(void))),*(*(struct)))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
const	O
gss_name_t	*(struct)
input_name	*(struct)
,	O
const	O
gss_OID	*(struct(int,*(void)))
mech_type	*(struct(int,*(void)))
,	O
gss_name_t	*(struct)
*	O
output_name	*(*(struct))
)	O
{	O
_gss_mech_api_t	*(struct(*(struct(int,*(void))),*(char),*(char),*(char),array(*(struct(int,*(void)))),*((*(int),*(struct`),*(*`),*(struct`),*(struct`),int,int,*(struct`),*(struct`),*(*`),*(struct`),*(int),*(int))->(int)),*((*(int),*(struct`),*(struct`),*(*`))->(int)),*((*(int),*(struct`),*(struct`))->(int)),*((*(int),*(struct`),int,int,*(struct`),*(int),*(struct`))->(int)),*((*(int),*(struct`),*(struct`),*(struct`),*(int),*(int))->(int)),*((*(int),*(struct`),int,*(struct`),*(struct`))->(int)),*((*(int),*(struct`),*(struct`),*(struct`),*(int))->(int)),*((*(int),int,int,*(struct`),*(int),*(struct`))->(int)),*((*(int),*(struct`),int,*(struct`),int,*(*`),*(*`),*(int))->(int)),*((*(int),*(*`))->(int)),*((*(int),*(*`),*(struct`),*(struct`),*(struct`),*(*`),*(*`),*(struct`),*(int),*(int),*(*`))->(int)),*((*(int),*(*`),*(struct`))->(int)),*((*(int),*(struct`),*(int))->(int)),*((*(int),*(struct`),*(*`),*(int),*(int),*(*`))->(int)),*((*(int),*(struct`),*(struct`),*(*`),*(int),*(int),*(int))->(int))))
mech	*(struct(int,*(void)))
;	O
mech	*(struct(int,*(void)))
=	O
_gss_find_mech	(*(struct(int,*(void))))->(*(struct(*(struct(int,*`)),*(char),*(char),*(char),array(*(struct(int,*(void)))),*((*`,*`,*`,*`,*`,int,int,*`,*`,*`,*`,*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`,int,int,*`,*`,*`)->(int)),*((*`,*`,*`,*`,*`,*`)->(int)),*((*`,*`,int,*`,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,int,int,*`,*`,*`)->(int)),*((*`,*`,int,*`,int,*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`,*`,*`,*`,*`)->(int)),*((*`,*`,*`,*`,*`,*`,*`)->(int)))))
(	O
mech_type	*(struct(int,*(void)))
)	O
;	O
if	O
(	O
mech	*(struct(int,*(void)))
==	O
NULL	O
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_BAD_MECH	O
;	O
}	O
return	O
mech	*(struct(int,*(void)))
->	O
canonicalize_name	*((*(int),*(struct(long,*(char),*(struct`))),*(struct(int,*(void))),*(*(struct(long,*`,*`))))->(int))
(	O
minor_status	*(int)
,	O
input_name	*(struct)
,	O
mech_type	*(struct(int,*(void)))
,	O
output_name	*(*(struct))
)	O
;	O
}	O
OM_uint32	int
gss_duplicate_name	(*(int),*(struct),*(*(struct)))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
const	O
gss_name_t	*(struct)
src_name	*(*(struct))
,	O
gss_name_t	*(struct)
*	O
dest_name	*(*(struct))
)	O
{	O
if	O
(	O
src_name	*(*(struct))
==	O
GSS_C_NO_NAME	O
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_BAD_NAME	O
;	O
}	O
if	O
(	O
!	O
dest_name	*(*(struct))
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_FAILURE	O
|	O
GSS_S_CALL_INACCESSIBLE_WRITE	O
;	O
}	O
*	O
dest_name	*(*(struct))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
*	O
dest_name	*(*(struct))
)	O
)	O
;	O
if	O
(	O
!	O
*	O
dest_name	*(*(struct))
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
ENOMEM	int
;	O
return	O
GSS_S_FAILURE	O
;	O
}	O
(	O
*	O
dest_name	*(*(struct))
)	O
->	O
type	*(struct(int,*(void)))
=	O
src_name	*(*(struct))
->	O
type	*(struct(int,*(void)))
;	O
(	O
*	O
dest_name	*(*(struct))
)	O
->	O
length	int
=	O
src_name	*(*(struct))
->	O
length	int
;	O
(	O
*	O
dest_name	*(*(struct))
)	O
->	O
value	*(void)
=	O
malloc	(long)->(*(void))
(	O
src_name	*(*(struct))
->	O
length	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
(	O
*	O
dest_name	*(*(struct))
)	O
->	O
value	*(void)
)	O
{	O
free	(*(void))->(void)
(	O
*	O
dest_name	*(*(struct))
)	O
;	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
ENOMEM	int
;	O
return	O
GSS_S_FAILURE	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
(	O
*	O
dest_name	*(*(struct))
)	O
->	O
value	*(void)
,	O
src_name	*(*(struct))
->	O
value	*(void)
,	O
src_name	*(*(struct))
->	O
length	int
)	O
;	O
(	O
*	O
dest_name	*(*(struct))
)	O
->	O
value	*(void)
[	O
src_name	*(*(struct))
->	O
length	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
