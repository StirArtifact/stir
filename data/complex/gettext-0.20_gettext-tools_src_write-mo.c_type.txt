size_t	long
alignment	long
;	O
bool	bool
byteswap	bool
;	O
bool	bool
no_hash_table	bool
;	O
enum	O
{	O
M_ID	O
=	O
0	int
,	O
M_STR	O
=	O
1	int
}	O
;	O
struct	O
pre_string	O
{	O
size_t	long
length	int
;	O
const	O
char	O
*	O
pointer	O
;	O
}	O
;	O
struct	O
pre_message	O
{	O
struct	O
pre_string	O
str	O
[	O
2	int
]	O
;	O
const	O
char	O
*	O
id_plural	O
;	O
size_t	long
id_plural_len	O
;	O
}	O
;	O
static	O
int	O
compare_id	O
(	O
const	O
void	O
*	O
pval1	O
,	O
const	O
void	O
*	O
pval2	O
)	O
{	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
(	O
(	O
struct	O
pre_message	O
*	O
)	O
pval1	O
)	O
->	O
str	O
[	O
M_ID	O
]	O
.	O
pointer	O
,	O
(	O
(	O
struct	O
pre_message	O
*	O
)	O
pval2	O
)	O
->	O
str	O
[	O
M_ID	O
]	O
.	O
pointer	O
)	O
;	O
}	O
struct	O
pre_sysdep_segment	O
{	O
size_t	long
length	int
;	O
const	O
char	O
*	O
pointer	O
;	O
}	O
;	O
struct	O
pre_segment_pair	O
{	O
size_t	long
segsize	int
;	O
const	O
char	O
*	O
segptr	O
;	O
size_t	long
sysdepref	int
;	O
}	O
;	O
struct	O
pre_sysdep_string	O
{	O
unsigned	O
int	O
segmentcount	O
;	O
struct	O
pre_segment_pair	O
segments	array(struct(int,int))
[	O
1	int
]	O
;	O
}	O
;	O
struct	O
pre_sysdep_message	O
{	O
struct	O
pre_sysdep_string	O
*	O
str	O
[	O
2	int
]	O
;	O
const	O
char	O
*	O
id_plural	O
;	O
size_t	long
id_plural_len	O
;	O
}	O
;	O
static	O
void	O
write_table	O
(	O
FILE	struct
*	O
output_file	O
,	O
message_list_ty	struct
*	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
)	O
{	O
char	O
*	O
*	O
msgctid_arr	O
;	O
size_t	long
nstrings	int
;	O
struct	O
pre_message	O
*	O
msg_arr	O
;	O
size_t	long
n_sysdep_strings	int
;	O
struct	O
pre_sysdep_message	O
*	O
sysdep_msg_arr	O
;	O
size_t	long
n_sysdep_segments	int
;	O
struct	O
pre_sysdep_segment	O
*	O
sysdep_segments	O
;	O
bool	bool
have_outdigits	O
;	O
int	O
major_revision	O
;	O
int	O
minor_revision	O
;	O
bool	bool
omit_hash_table	O
;	O
nls_uint32	int
hash_tab_size	int
;	O
struct	O
mo_file_header	struct(int,int,int,int,int,int,int,int,int,int,int,int)
header	O
;	O
size_t	long
header_size	O
;	O
size_t	long
offset	int
;	O
struct	O
string_desc	struct(int,int)
*	O
orig_tab	O
;	O
struct	O
string_desc	struct(int,int)
*	O
trans_tab	O
;	O
size_t	long
sysdep_tab_offset	O
=	O
0	int
;	O
size_t	long
end_offset	O
;	O
char	O
*	O
null	O
;	O
size_t	long
j	O
,	O
m	O
;	O
msgctid_arr	O
=	O
XNMALLOC	O
(	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
nitems	long
,	O
char	O
*	O
)	O
;	O
nstrings	int
=	O
0	int
;	O
msg_arr	O
=	O
XNMALLOC	O
(	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
nitems	long
,	O
struct	O
pre_message	O
)	O
;	O
n_sysdep_strings	int
=	O
0	int
;	O
sysdep_msg_arr	O
=	O
XNMALLOC	O
(	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
nitems	long
,	O
struct	O
pre_sysdep_message	O
)	O
;	O
n_sysdep_segments	int
=	O
0	int
;	O
sysdep_segments	O
=	O
NULL	O
;	O
have_outdigits	O
=	O
false	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
nitems	long
;	O
j	O
++	O
)	O
{	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
=	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
item	*(*(char))
[	O
j	O
]	O
;	O
size_t	long
msgctlen	O
;	O
char	O
*	O
msgctid	O
;	O
struct	O
interval	O
*	O
intervals	O
[	O
2	int
]	O
;	O
size_t	long
nintervals	O
[	O
2	int
]	O
;	O
msgctlen	O
=	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgctxt	*(char)
!=	O
NULL	O
?	O
strlen	(*(char))->(long)
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgctxt	*(char)
)	O
+	O
1	int
:	O
0	int
)	O
;	O
msgctid	O
=	O
XNMALLOC	O
(	O
msgctlen	O
+	O
strlen	(*(char))->(long)
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid	*(char)
)	O
+	O
1	int
,	O
char	O
)	O
;	O
if	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgctxt	*(char)
!=	O
NULL	O
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
msgctid	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgctxt	*(char)
,	O
msgctlen	O
-	O
1	int
)	O
;	O
msgctid	O
[	O
msgctlen	O
-	O
1	int
]	O
=	O
MSGCTXT_SEPARATOR	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
msgctid	O
+	O
msgctlen	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid	*(char)
)	O
;	O
msgctid_arr	O
[	O
j	O
]	O
=	O
msgctid	O
;	O
intervals	O
[	O
M_ID	O
]	O
=	O
NULL	O
;	O
nintervals	O
[	O
M_ID	O
]	O
=	O
0	int
;	O
intervals	O
[	O
M_STR	O
]	O
=	O
NULL	O
;	O
nintervals	O
[	O
M_STR	O
]	O
=	O
0	int
;	O
if	O
(	O
possible_format_p	(enum(int,int,int,int,int,int))->(bool)
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
is_format	enum(int,int,int,int,int,int)
[	O
format_c	int
]	O
)	O
||	O
possible_format_p	(enum(int,int,int,int,int,int))->(bool)
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
is_format	enum(int,int,int,int,int,int)
[	O
format_objc	int
]	O
)	O
)	O
{	O
const	O
char	O
*	O
p_end	O
;	O
const	O
char	O
*	O
p	*(void)
;	O
get_sysdep_c_format_directives	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid	*(char)
,	O
false	O
,	O
&	O
intervals	O
[	O
M_ID	O
]	O
,	O
&	O
nintervals	O
[	O
M_ID	O
]	O
)	O
;	O
if	O
(	O
msgctlen	O
>	O
0	int
)	O
{	O
struct	O
interval	O
*	O
id_intervals	O
=	O
intervals	O
[	O
M_ID	O
]	O
;	O
size_t	long
id_nintervals	O
=	O
nintervals	O
[	O
M_ID	O
]	O
;	O
if	O
(	O
id_nintervals	O
>	O
0	int
)	O
{	O
unsigned	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
id_nintervals	O
;	O
i	long
++	O
)	O
{	O
id_intervals	O
[	O
i	long
]	O
.	O
startpos	O
+=	O
msgctlen	O
;	O
id_intervals	O
[	O
i	long
]	O
.	O
endpos	O
+=	O
msgctlen	O
;	O
}	O
}	O
}	O
p_end	O
=	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
+	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr_len	long
;	O
for	O
(	O
p	*(void)
=	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
;	O
p	*(void)
<	O
p_end	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
+	O
1	int
)	O
{	O
struct	O
interval	O
*	O
part_intervals	O
;	O
size_t	long
part_nintervals	O
;	O
get_sysdep_c_format_directives	O
(	O
p	*(void)
,	O
true	O
,	O
&	O
part_intervals	O
,	O
&	O
part_nintervals	O
)	O
;	O
if	O
(	O
part_nintervals	O
>	O
0	int
)	O
{	O
size_t	long
d	O
=	O
p	*(void)
-	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
;	O
unsigned	O
int	O
i	long
;	O
intervals	O
[	O
M_STR	O
]	O
=	O
(	O
struct	O
interval	O
*	O
)	O
xrealloc	O
(	O
intervals	O
[	O
M_STR	O
]	O
,	O
(	O
nintervals	O
[	O
M_STR	O
]	O
+	O
part_nintervals	O
)	O
*	O
sizeof	O
(	O
struct	O
interval	O
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
part_nintervals	O
;	O
i	long
++	O
)	O
{	O
intervals	O
[	O
M_STR	O
]	O
[	O
nintervals	O
[	O
M_STR	O
]	O
+	O
i	long
]	O
.	O
startpos	O
=	O
d	O
+	O
part_intervals	O
[	O
i	long
]	O
.	O
startpos	O
;	O
intervals	O
[	O
M_STR	O
]	O
[	O
nintervals	O
[	O
M_STR	O
]	O
+	O
i	long
]	O
.	O
endpos	O
=	O
d	O
+	O
part_intervals	O
[	O
i	long
]	O
.	O
endpos	O
;	O
}	O
nintervals	O
[	O
M_STR	O
]	O
+=	O
part_nintervals	O
;	O
}	O
}	O
}	O
if	O
(	O
nintervals	O
[	O
M_ID	O
]	O
>	O
0	int
||	O
nintervals	O
[	O
M_STR	O
]	O
>	O
0	int
)	O
{	O
for	O
(	O
m	O
=	O
0	int
;	O
m	O
<	O
2	int
;	O
m	O
++	O
)	O
{	O
struct	O
pre_sysdep_string	O
*	O
pre	O
=	O
(	O
struct	O
pre_sysdep_string	O
*	O
)	O
xmalloc	O
(	O
xsum	O
(	O
sizeof	O
(	O
struct	O
pre_sysdep_string	O
)	O
,	O
xtimes	O
(	O
nintervals	O
[	O
m	O
]	O
,	O
sizeof	O
(	O
struct	O
pre_segment_pair	O
)	O
)	O
)	O
)	O
;	O
const	O
char	O
*	O
str	O
;	O
size_t	long
str_len	O
;	O
size_t	long
lastpos	O
;	O
unsigned	O
int	O
i	long
;	O
if	O
(	O
m	O
==	O
M_ID	O
)	O
{	O
str	O
=	O
msgctid	O
;	O
str_len	O
=	O
strlen	(*(char))->(long)
(	O
msgctid	O
)	O
+	O
1	int
;	O
}	O
else	O
{	O
str	O
=	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
;	O
str_len	O
=	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr_len	long
;	O
}	O
lastpos	O
=	O
0	int
;	O
pre	O
->	O
segmentcount	O
=	O
nintervals	O
[	O
m	O
]	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nintervals	O
[	O
m	O
]	O
;	O
i	long
++	O
)	O
{	O
size_t	long
length	int
;	O
const	O
char	O
*	O
pointer	O
;	O
size_t	long
r	O
;	O
pre	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
segptr	O
=	O
str	O
+	O
lastpos	O
;	O
pre	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
segsize	int
=	O
intervals	O
[	O
m	O
]	O
[	O
i	long
]	O
.	O
startpos	O
-	O
lastpos	O
;	O
length	int
=	O
intervals	O
[	O
m	O
]	O
[	O
i	long
]	O
.	O
endpos	O
-	O
intervals	O
[	O
m	O
]	O
[	O
i	long
]	O
.	O
startpos	O
;	O
pointer	O
=	O
str	O
+	O
intervals	O
[	O
m	O
]	O
[	O
i	long
]	O
.	O
startpos	O
;	O
if	O
(	O
length	int
>=	O
2	int
&&	O
pointer	O
[	O
0	int
]	O
==	O
'<'	O
&&	O
pointer	O
[	O
length	int
-	O
1	int
]	O
==	O
'>'	O
)	O
{	O
length	int
-=	O
2	int
;	O
pointer	O
+=	O
1	int
;	O
}	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
n_sysdep_segments	int
;	O
r	O
++	O
)	O
if	O
(	O
sysdep_segments	O
[	O
r	O
]	O
.	O
length	int
==	O
length	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
sysdep_segments	O
[	O
r	O
]	O
.	O
pointer	O
,	O
pointer	O
,	O
length	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
r	O
==	O
n_sysdep_segments	int
)	O
{	O
n_sysdep_segments	int
++	O
;	O
sysdep_segments	O
=	O
(	O
struct	O
pre_sysdep_segment	O
*	O
)	O
xrealloc	O
(	O
sysdep_segments	O
,	O
n_sysdep_segments	int
*	O
sizeof	O
(	O
struct	O
pre_sysdep_segment	O
)	O
)	O
;	O
sysdep_segments	O
[	O
r	O
]	O
.	O
length	int
=	O
length	int
;	O
sysdep_segments	O
[	O
r	O
]	O
.	O
pointer	O
=	O
pointer	O
;	O
}	O
pre	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
sysdepref	int
=	O
r	O
;	O
if	O
(	O
length	int
==	O
1	int
&&	O
*	O
pointer	O
==	O
'I'	O
)	O
have_outdigits	O
=	O
true	O
;	O
lastpos	O
=	O
intervals	O
[	O
m	O
]	O
[	O
i	long
]	O
.	O
endpos	O
;	O
}	O
pre	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
segptr	O
=	O
str	O
+	O
lastpos	O
;	O
pre	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
segsize	int
=	O
str_len	O
-	O
lastpos	O
;	O
pre	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
sysdepref	int
=	O
SEGMENTS_END	O
;	O
sysdep_msg_arr	O
[	O
n_sysdep_strings	int
]	O
.	O
str	O
[	O
m	O
]	O
=	O
pre	O
;	O
}	O
sysdep_msg_arr	O
[	O
n_sysdep_strings	int
]	O
.	O
id_plural	O
=	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid_plural	*(char)
;	O
sysdep_msg_arr	O
[	O
n_sysdep_strings	int
]	O
.	O
id_plural_len	O
=	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid_plural	*(char)
!=	O
NULL	O
?	O
strlen	(*(char))->(long)
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid_plural	*(char)
)	O
+	O
1	int
:	O
0	int
)	O
;	O
n_sysdep_strings	int
++	O
;	O
}	O
else	O
{	O
msg_arr	O
[	O
nstrings	int
]	O
.	O
str	O
[	O
M_ID	O
]	O
.	O
pointer	O
=	O
msgctid	O
;	O
msg_arr	O
[	O
nstrings	int
]	O
.	O
str	O
[	O
M_ID	O
]	O
.	O
length	int
=	O
strlen	(*(char))->(long)
(	O
msgctid	O
)	O
+	O
1	int
;	O
msg_arr	O
[	O
nstrings	int
]	O
.	O
str	O
[	O
M_STR	O
]	O
.	O
pointer	O
=	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
;	O
msg_arr	O
[	O
nstrings	int
]	O
.	O
str	O
[	O
M_STR	O
]	O
.	O
length	int
=	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr_len	long
;	O
msg_arr	O
[	O
nstrings	int
]	O
.	O
id_plural	O
=	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid_plural	*(char)
;	O
msg_arr	O
[	O
nstrings	int
]	O
.	O
id_plural_len	O
=	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid_plural	*(char)
!=	O
NULL	O
?	O
strlen	(*(char))->(long)
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid_plural	*(char)
)	O
+	O
1	int
:	O
0	int
)	O
;	O
nstrings	int
++	O
;	O
}	O
for	O
(	O
m	O
=	O
0	int
;	O
m	O
<	O
2	int
;	O
m	O
++	O
)	O
if	O
(	O
intervals	O
[	O
m	O
]	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
intervals	O
[	O
m	O
]	O
)	O
;	O
}	O
if	O
(	O
nstrings	int
>	O
0	int
)	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
msg_arr	O
,	O
nstrings	int
,	O
sizeof	O
(	O
struct	O
pre_message	O
)	O
,	O
compare_id	O
)	O
;	O
major_revision	O
=	O
(	O
have_outdigits	O
?	O
MO_REVISION_NUMBER_WITH_SYSDEP_I	O
:	O
MO_REVISION_NUMBER	O
)	O
;	O
minor_revision	O
=	O
(	O
n_sysdep_strings	int
>	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
omit_hash_table	O
=	O
(	O
no_hash_table	bool
&&	O
minor_revision	O
==	O
0	int
)	O
;	O
if	O
(	O
!	O
omit_hash_table	O
)	O
{	O
hash_tab_size	int
=	O
next_prime	(long)->(long)
(	O
(	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
nitems	long
*	O
4	int
)	O
/	O
3	int
)	O
;	O
if	O
(	O
hash_tab_size	int
<=	O
2	int
)	O
hash_tab_size	int
=	O
3	int
;	O
}	O
else	O
hash_tab_size	int
=	O
0	int
;	O
header	O
.	O
magic	int
=	O
_MAGIC	O
;	O
header	O
.	O
revision	int
=	O
(	O
major_revision	O
<<	O
16	int
)	O
+	O
minor_revision	O
;	O
header_size	O
=	O
(	O
minor_revision	O
==	O
0	int
?	O
offsetof	O
(	O
struct	O
mo_file_header	struct(int,int,int,int,int,int,int,int,int,int,int,int)
,	O
n_sysdep_segments	int
)	O
:	O
sizeof	O
(	O
struct	O
mo_file_header	struct(int,int,int,int,int,int,int,int,int,int,int,int)
)	O
)	O
;	O
offset	int
=	O
header_size	O
;	O
header	O
.	O
nstrings	int
=	O
nstrings	int
;	O
header	O
.	O
orig_tab_offset	int
=	O
offset	int
;	O
offset	int
+=	O
nstrings	int
*	O
sizeof	O
(	O
struct	O
string_desc	struct(int,int)
)	O
;	O
orig_tab	O
=	O
XNMALLOC	O
(	O
nstrings	int
,	O
struct	O
string_desc	struct(int,int)
)	O
;	O
header	O
.	O
trans_tab_offset	int
=	O
offset	int
;	O
offset	int
+=	O
nstrings	int
*	O
sizeof	O
(	O
struct	O
string_desc	struct(int,int)
)	O
;	O
trans_tab	O
=	O
XNMALLOC	O
(	O
nstrings	int
,	O
struct	O
string_desc	struct(int,int)
)	O
;	O
header	O
.	O
hash_tab_size	int
=	O
hash_tab_size	int
;	O
header	O
.	O
hash_tab_offset	int
=	O
offset	int
;	O
offset	int
+=	O
hash_tab_size	int
*	O
sizeof	O
(	O
nls_uint32	int
)	O
;	O
if	O
(	O
minor_revision	O
>=	O
1	int
)	O
{	O
header	O
.	O
n_sysdep_segments	int
=	O
n_sysdep_segments	int
;	O
header	O
.	O
sysdep_segments_offset	int
=	O
offset	int
;	O
offset	int
+=	O
n_sysdep_segments	int
*	O
sizeof	O
(	O
struct	O
sysdep_segment	struct(int,int)
)	O
;	O
header	O
.	O
n_sysdep_strings	int
=	O
n_sysdep_strings	int
;	O
header	O
.	O
orig_sysdep_tab_offset	int
=	O
offset	int
;	O
offset	int
+=	O
n_sysdep_strings	int
*	O
sizeof	O
(	O
nls_uint32	int
)	O
;	O
header	O
.	O
trans_sysdep_tab_offset	int
=	O
offset	int
;	O
offset	int
+=	O
n_sysdep_strings	int
*	O
sizeof	O
(	O
nls_uint32	int
)	O
;	O
sysdep_tab_offset	O
=	O
offset	int
;	O
for	O
(	O
m	O
=	O
0	int
;	O
m	O
<	O
2	int
;	O
m	O
++	O
)	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
n_sysdep_strings	int
;	O
j	O
++	O
)	O
offset	int
+=	O
sizeof	O
(	O
struct	O
sysdep_string	struct(int,array(struct(int,int)))
)	O
+	O
sysdep_msg_arr	O
[	O
j	O
]	O
.	O
str	O
[	O
m	O
]	O
->	O
segmentcount	O
*	O
sizeof	O
(	O
struct	O
segment_pair	struct(int,int)
)	O
;	O
}	O
end_offset	O
=	O
offset	int
;	O
if	O
(	O
byteswap	bool
)	O
{	O
BSWAP32	O
(	O
header	O
.	O
magic	int
)	O
;	O
BSWAP32	O
(	O
header	O
.	O
revision	int
)	O
;	O
BSWAP32	O
(	O
header	O
.	O
nstrings	int
)	O
;	O
BSWAP32	O
(	O
header	O
.	O
orig_tab_offset	int
)	O
;	O
BSWAP32	O
(	O
header	O
.	O
trans_tab_offset	int
)	O
;	O
BSWAP32	O
(	O
header	O
.	O
hash_tab_size	int
)	O
;	O
BSWAP32	O
(	O
header	O
.	O
hash_tab_offset	int
)	O
;	O
if	O
(	O
minor_revision	O
>=	O
1	int
)	O
{	O
BSWAP32	O
(	O
header	O
.	O
n_sysdep_segments	int
)	O
;	O
BSWAP32	O
(	O
header	O
.	O
sysdep_segments_offset	int
)	O
;	O
BSWAP32	O
(	O
header	O
.	O
n_sysdep_strings	int
)	O
;	O
BSWAP32	O
(	O
header	O
.	O
orig_sysdep_tab_offset	int
)	O
;	O
BSWAP32	O
(	O
header	O
.	O
trans_sysdep_tab_offset	int
)	O
;	O
}	O
}	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
header	O
,	O
header_size	O
,	O
1	int
,	O
output_file	O
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nstrings	int
;	O
j	O
++	O
)	O
{	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
orig_tab	O
[	O
j	O
]	O
.	O
length	int
=	O
msg_arr	O
[	O
j	O
]	O
.	O
str	O
[	O
M_ID	O
]	O
.	O
length	int
+	O
msg_arr	O
[	O
j	O
]	O
.	O
id_plural_len	O
;	O
orig_tab	O
[	O
j	O
]	O
.	O
offset	int
=	O
offset	int
;	O
offset	int
+=	O
orig_tab	O
[	O
j	O
]	O
.	O
length	int
;	O
orig_tab	O
[	O
j	O
]	O
.	O
length	int
--	O
;	O
}	O
if	O
(	O
byteswap	bool
)	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nstrings	int
;	O
j	O
++	O
)	O
{	O
BSWAP32	O
(	O
orig_tab	O
[	O
j	O
]	O
.	O
length	int
)	O
;	O
BSWAP32	O
(	O
orig_tab	O
[	O
j	O
]	O
.	O
offset	int
)	O
;	O
}	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
orig_tab	O
,	O
nstrings	int
*	O
sizeof	O
(	O
struct	O
string_desc	struct(int,int)
)	O
,	O
1	int
,	O
output_file	O
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nstrings	int
;	O
j	O
++	O
)	O
{	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
trans_tab	O
[	O
j	O
]	O
.	O
length	int
=	O
msg_arr	O
[	O
j	O
]	O
.	O
str	O
[	O
M_STR	O
]	O
.	O
length	int
;	O
trans_tab	O
[	O
j	O
]	O
.	O
offset	int
=	O
offset	int
;	O
offset	int
+=	O
trans_tab	O
[	O
j	O
]	O
.	O
length	int
;	O
trans_tab	O
[	O
j	O
]	O
.	O
length	int
--	O
;	O
}	O
if	O
(	O
byteswap	bool
)	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nstrings	int
;	O
j	O
++	O
)	O
{	O
BSWAP32	O
(	O
trans_tab	O
[	O
j	O
]	O
.	O
length	int
)	O
;	O
BSWAP32	O
(	O
trans_tab	O
[	O
j	O
]	O
.	O
offset	int
)	O
;	O
}	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
trans_tab	O
,	O
nstrings	int
*	O
sizeof	O
(	O
struct	O
string_desc	struct(int,int)
)	O
,	O
1	int
,	O
output_file	O
)	O
;	O
if	O
(	O
!	O
omit_hash_table	O
)	O
{	O
nls_uint32	int
*	O
hash_tab	O
;	O
unsigned	O
int	O
j	O
;	O
hash_tab	O
=	O
XNMALLOC	O
(	O
hash_tab_size	int
,	O
nls_uint32	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
hash_tab	O
,	O
'\0'	O
,	O
hash_tab_size	int
*	O
sizeof	O
(	O
nls_uint32	int
)	O
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nstrings	int
;	O
j	O
++	O
)	O
{	O
nls_uint32	int
hash_val	O
=	O
hash_string	(*(char))->(long)
(	O
msg_arr	O
[	O
j	O
]	O
.	O
str	O
[	O
M_ID	O
]	O
.	O
pointer	O
)	O
;	O
nls_uint32	int
idx	O
=	O
hash_val	O
%	O
hash_tab_size	int
;	O
if	O
(	O
hash_tab	O
[	O
idx	O
]	O
!=	O
0	int
)	O
{	O
nls_uint32	int
incr	O
=	O
1	int
+	O
(	O
hash_val	O
%	O
(	O
hash_tab_size	int
-	O
2	int
)	O
)	O
;	O
do	O
if	O
(	O
idx	O
>=	O
hash_tab_size	int
-	O
incr	O
)	O
idx	O
-=	O
hash_tab_size	int
-	O
incr	O
;	O
else	O
idx	O
+=	O
incr	O
;	O
while	O
(	O
hash_tab	O
[	O
idx	O
]	O
!=	O
0	int
)	O
;	O
}	O
hash_tab	O
[	O
idx	O
]	O
=	O
j	O
+	O
1	int
;	O
}	O
if	O
(	O
byteswap	bool
)	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
hash_tab_size	int
;	O
j	O
++	O
)	O
BSWAP32	O
(	O
hash_tab	O
[	O
j	O
]	O
)	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
hash_tab	O
,	O
hash_tab_size	int
*	O
sizeof	O
(	O
nls_uint32	int
)	O
,	O
1	int
,	O
output_file	O
)	O
;	O
free	(*(void))->(void)
(	O
hash_tab	O
)	O
;	O
}	O
if	O
(	O
minor_revision	O
>=	O
1	int
)	O
{	O
struct	O
sysdep_segment	struct(int,int)
*	O
sysdep_segments_tab	O
;	O
nls_uint32	int
*	O
sysdep_tab	O
;	O
size_t	long
stoffset	O
;	O
unsigned	O
int	O
i	long
;	O
sysdep_segments_tab	O
=	O
XNMALLOC	O
(	O
n_sysdep_segments	int
,	O
struct	O
sysdep_segment	struct(int,int)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n_sysdep_segments	int
;	O
i	long
++	O
)	O
{	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
sysdep_segments_tab	O
[	O
i	long
]	O
.	O
length	int
=	O
sysdep_segments	O
[	O
i	long
]	O
.	O
length	int
+	O
1	int
;	O
sysdep_segments_tab	O
[	O
i	long
]	O
.	O
offset	int
=	O
offset	int
;	O
offset	int
+=	O
sysdep_segments_tab	O
[	O
i	long
]	O
.	O
length	int
;	O
}	O
if	O
(	O
byteswap	bool
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n_sysdep_segments	int
;	O
i	long
++	O
)	O
{	O
BSWAP32	O
(	O
sysdep_segments_tab	O
[	O
i	long
]	O
.	O
length	int
)	O
;	O
BSWAP32	O
(	O
sysdep_segments_tab	O
[	O
i	long
]	O
.	O
offset	int
)	O
;	O
}	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
sysdep_segments_tab	O
,	O
n_sysdep_segments	int
*	O
sizeof	O
(	O
struct	O
sysdep_segment	struct(int,int)
)	O
,	O
1	int
,	O
output_file	O
)	O
;	O
free	(*(void))->(void)
(	O
sysdep_segments_tab	O
)	O
;	O
sysdep_tab	O
=	O
XNMALLOC	O
(	O
n_sysdep_strings	int
,	O
nls_uint32	int
)	O
;	O
stoffset	O
=	O
sysdep_tab_offset	O
;	O
for	O
(	O
m	O
=	O
0	int
;	O
m	O
<	O
2	int
;	O
m	O
++	O
)	O
{	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
n_sysdep_strings	int
;	O
j	O
++	O
)	O
{	O
sysdep_tab	O
[	O
j	O
]	O
=	O
stoffset	O
;	O
stoffset	O
+=	O
sizeof	O
(	O
struct	O
sysdep_string	struct(int,array(struct(int,int)))
)	O
+	O
sysdep_msg_arr	O
[	O
j	O
]	O
.	O
str	O
[	O
m	O
]	O
->	O
segmentcount	O
*	O
sizeof	O
(	O
struct	O
segment_pair	struct(int,int)
)	O
;	O
}	O
if	O
(	O
byteswap	bool
)	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
n_sysdep_strings	int
;	O
j	O
++	O
)	O
BSWAP32	O
(	O
sysdep_tab	O
[	O
j	O
]	O
)	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
sysdep_tab	O
,	O
n_sysdep_strings	int
*	O
sizeof	O
(	O
nls_uint32	int
)	O
,	O
1	int
,	O
output_file	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
sysdep_tab	O
)	O
;	O
for	O
(	O
m	O
=	O
0	int
;	O
m	O
<	O
2	int
;	O
m	O
++	O
)	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
n_sysdep_strings	int
;	O
j	O
++	O
)	O
{	O
struct	O
pre_sysdep_message	O
*	O
msg	O
=	O
&	O
sysdep_msg_arr	O
[	O
j	O
]	O
;	O
struct	O
pre_sysdep_string	O
*	O
pre	O
=	O
msg	O
->	O
str	O
[	O
m	O
]	O
;	O
struct	O
sysdep_string	struct(int,array(struct(int,int)))
*	O
str	O
=	O
(	O
struct	O
sysdep_string	struct(int,array(struct(int,int)))
*	O
)	O
xmalloca	O
(	O
sizeof	O
(	O
struct	O
sysdep_string	struct(int,array(struct(int,int)))
)	O
+	O
pre	O
->	O
segmentcount	O
*	O
sizeof	O
(	O
struct	O
segment_pair	struct(int,int)
)	O
)	O
;	O
unsigned	O
int	O
i	long
;	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
str	O
->	O
offset	int
=	O
offset	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
pre	O
->	O
segmentcount	O
;	O
i	long
++	O
)	O
{	O
str	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
segsize	int
=	O
pre	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
segsize	int
;	O
str	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
sysdepref	int
=	O
pre	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
sysdepref	int
;	O
offset	int
+=	O
str	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
segsize	int
;	O
}	O
if	O
(	O
m	O
==	O
M_ID	O
&&	O
msg	O
->	O
id_plural_len	O
>	O
0	int
)	O
{	O
str	O
->	O
segments	array(struct(int,int))
[	O
pre	O
->	O
segmentcount	O
]	O
.	O
segsize	int
+=	O
msg	O
->	O
id_plural_len	O
;	O
offset	int
+=	O
msg	O
->	O
id_plural_len	O
;	O
}	O
if	O
(	O
byteswap	bool
)	O
{	O
BSWAP32	O
(	O
str	O
->	O
offset	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
pre	O
->	O
segmentcount	O
;	O
i	long
++	O
)	O
{	O
BSWAP32	O
(	O
str	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
segsize	int
)	O
;	O
BSWAP32	O
(	O
str	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
sysdepref	int
)	O
;	O
}	O
}	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
str	O
,	O
sizeof	O
(	O
struct	O
sysdep_string	struct(int,array(struct(int,int)))
)	O
+	O
pre	O
->	O
segmentcount	O
*	O
sizeof	O
(	O
struct	O
segment_pair	struct(int,int)
)	O
,	O
1	int
,	O
output_file	O
)	O
;	O
freea	O
(	O
str	O
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
trans_tab	O
)	O
;	O
free	(*(void))->(void)
(	O
orig_tab	O
)	O
;	O
offset	int
=	O
end_offset	O
;	O
null	O
=	O
(	O
char	O
*	O
)	O
alloca	O
(	O
alignment	long
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
null	O
,	O
'\0'	O
,	O
alignment	long
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nstrings	int
;	O
j	O
++	O
)	O
{	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
null	O
,	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
-	O
offset	int
,	O
1	int
,	O
output_file	O
)	O
;	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
msg_arr	O
[	O
j	O
]	O
.	O
str	O
[	O
M_ID	O
]	O
.	O
pointer	O
,	O
msg_arr	O
[	O
j	O
]	O
.	O
str	O
[	O
M_ID	O
]	O
.	O
length	int
,	O
1	int
,	O
output_file	O
)	O
;	O
if	O
(	O
msg_arr	O
[	O
j	O
]	O
.	O
id_plural_len	O
>	O
0	int
)	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
msg_arr	O
[	O
j	O
]	O
.	O
id_plural	O
,	O
msg_arr	O
[	O
j	O
]	O
.	O
id_plural_len	O
,	O
1	int
,	O
output_file	O
)	O
;	O
offset	int
+=	O
msg_arr	O
[	O
j	O
]	O
.	O
str	O
[	O
M_ID	O
]	O
.	O
length	int
+	O
msg_arr	O
[	O
j	O
]	O
.	O
id_plural_len	O
;	O
}	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nstrings	int
;	O
j	O
++	O
)	O
{	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
null	O
,	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
-	O
offset	int
,	O
1	int
,	O
output_file	O
)	O
;	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
msg_arr	O
[	O
j	O
]	O
.	O
str	O
[	O
M_STR	O
]	O
.	O
pointer	O
,	O
msg_arr	O
[	O
j	O
]	O
.	O
str	O
[	O
M_STR	O
]	O
.	O
length	int
,	O
1	int
,	O
output_file	O
)	O
;	O
offset	int
+=	O
msg_arr	O
[	O
j	O
]	O
.	O
str	O
[	O
M_STR	O
]	O
.	O
length	int
;	O
}	O
if	O
(	O
minor_revision	O
>=	O
1	int
)	O
{	O
unsigned	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n_sysdep_segments	int
;	O
i	long
++	O
)	O
{	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
null	O
,	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
-	O
offset	int
,	O
1	int
,	O
output_file	O
)	O
;	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
sysdep_segments	O
[	O
i	long
]	O
.	O
pointer	O
,	O
sysdep_segments	O
[	O
i	long
]	O
.	O
length	int
,	O
1	int
,	O
output_file	O
)	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
null	O
,	O
1	int
,	O
1	int
,	O
output_file	O
)	O
;	O
offset	int
+=	O
sysdep_segments	O
[	O
i	long
]	O
.	O
length	int
+	O
1	int
;	O
}	O
for	O
(	O
m	O
=	O
0	int
;	O
m	O
<	O
2	int
;	O
m	O
++	O
)	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
n_sysdep_strings	int
;	O
j	O
++	O
)	O
{	O
struct	O
pre_sysdep_message	O
*	O
msg	O
=	O
&	O
sysdep_msg_arr	O
[	O
j	O
]	O
;	O
struct	O
pre_sysdep_string	O
*	O
pre	O
=	O
msg	O
->	O
str	O
[	O
m	O
]	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
null	O
,	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
-	O
offset	int
,	O
1	int
,	O
output_file	O
)	O
;	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
pre	O
->	O
segmentcount	O
;	O
i	long
++	O
)	O
{	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
pre	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
segptr	O
,	O
pre	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
segsize	int
,	O
1	int
,	O
output_file	O
)	O
;	O
offset	int
+=	O
pre	O
->	O
segments	array(struct(int,int))
[	O
i	long
]	O
.	O
segsize	int
;	O
}	O
if	O
(	O
m	O
==	O
M_ID	O
&&	O
msg	O
->	O
id_plural_len	O
>	O
0	int
)	O
{	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
msg	O
->	O
id_plural	O
,	O
msg	O
->	O
id_plural_len	O
,	O
1	int
,	O
output_file	O
)	O
;	O
offset	int
+=	O
msg	O
->	O
id_plural_len	O
;	O
}	O
free	(*(void))->(void)
(	O
pre	O
)	O
;	O
}	O
}	O
freea	O
(	O
null	O
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
nitems	long
;	O
j	O
++	O
)	O
free	(*(void))->(void)
(	O
msgctid_arr	O
[	O
j	O
]	O
)	O
;	O
free	(*(void))->(void)
(	O
sysdep_msg_arr	O
)	O
;	O
free	(*(void))->(void)
(	O
msg_arr	O
)	O
;	O
free	(*(void))->(void)
(	O
msgctid_arr	O
)	O
;	O
}	O
int	O
msgdomain_write_mo	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),*(char),*(char))->(int)
(	O
message_list_ty	struct
*	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
const	O
char	O
*	O
domain_name	*(char)
,	O
const	O
char	O
*	O
file_name	*(char)
)	O
{	O
FILE	struct
*	O
output_file	O
;	O
if	O
(	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
nitems	long
!=	O
0	int
)	O
{	O
message_list_delete_header_field	O
(	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
"POT-Creation-Date:"	*(char)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
domain_name	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
{	O
output_file	O
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
SET_BINARY	O
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
output_file	O
)	O
)	O
;	O
}	O
else	O
{	O
output_file	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
file_name	*(char)
,	O
"wb"	*(char)
)	O
;	O
if	O
(	O
output_file	O
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"error while opening \"%s\" for writing"	*(char)
)	O
,	O
file_name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
output_file	O
!=	O
NULL	O
)	O
{	O
write_table	O
(	O
output_file	O
,	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
)	O
;	O
if	O
(	O
fwriteerror	O
(	O
output_file	O
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"error while writing \"%s\" file"	*(char)
)	O
,	O
file_name	*(char)
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
