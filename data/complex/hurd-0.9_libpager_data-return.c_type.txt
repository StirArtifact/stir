kern_return_t	O
_pager_do_write_request	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)),int,int,int,int,int,int,int)->(int)
(	O
struct	O
pager	struct(struct,*(struct),enum(int,int,int),int,int,*(struct),*(struct),int,int,int,int,int,int,int,*(short),int)
*	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
,	O
mach_port_t	O
control	int
,	O
vm_offset_t	int
offset	int
,	O
pointer_t	O
data	int
,	O
vm_size_t	int
length	int
,	O
int	O
dirty	int
,	O
int	O
kcopy	int
,	O
int	O
initializing	int
)	O
{	O
short	O
*	O
pm_entries	*(short)
;	O
int	O
npages	int
,	O
i	int
;	O
char	O
*	O
notified	*(char)
;	O
error_t	int
*	O
pagerrs	O
;	O
struct	O
lock_request	struct(*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int)),*(*(struct(*(struct(*`,*`,int,int,int,int,int)),*(*(struct`)),int,int,int,int,int))),int,int,int,int,int)
*	O
lr	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
;	O
struct	O
lock_list	struct(*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int)),*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`))))))
{	O
struct	O
lock_request	struct(*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int)),*(*(struct(*(struct(*`,*`,int,int,int,int,int)),*(*(struct`)),int,int,int,int,int))),int,int,int,int,int)
*	O
lr	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
;	O
struct	O
lock_list	struct(*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int)),*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`))))))
*	O
next	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
;	O
}	O
*	O
lock_list	struct(*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int)),*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`))))))
,	O
*	O
ll	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`)))))
;	O
int	O
wakeup	int
;	O
int	O
omitdata	int
=	O
0	int
;	O
if	O
(	O
!	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
||	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
port	struct
.	O
class	O
!=	O
_pager_class	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
interlock	int
)	O
;	O
if	O
(	O
control	int
!=	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
memobjcntl	int
)	O
{	O
printf	O
(	O
"incg data return: wrong control port\n"	*(char)
)	O
;	O
goto	O
release_out	O
;	O
}	O
if	O
(	O
length	int
%	O
__vm_page_size	O
)	O
{	O
printf	O
(	O
"incg data return: bad length size %zd\n"	*(char)
,	O
length	int
)	O
;	O
goto	O
release_out	O
;	O
}	O
if	O
(	O
offset	int
%	O
__vm_page_size	O
)	O
{	O
printf	O
(	O
"incg data return: misaligned request\n"	*(char)
)	O
;	O
goto	O
release_out	O
;	O
}	O
if	O
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
pager_state	enum(int,int,int)
!=	O
NORMAL	int
)	O
{	O
printf	O
(	O
"pager in wrong state for write\n"	*(char)
)	O
;	O
goto	O
release_out	O
;	O
}	O
npages	int
=	O
length	int
/	O
__vm_page_size	O
;	O
pagerrs	O
=	O
alloca	O
(	O
npages	int
*	O
sizeof	O
(	O
error_t	int
)	O
)	O
;	O
notified	*(char)
=	O
alloca	O
(	O
npages	int
*	O
(	O
sizeof	O
*	O
notified	*(char)
)	O
)	O
;	O
memset	O
(	O
notified	*(char)
,	O
-	O
1	int
,	O
npages	int
*	O
(	O
sizeof	O
*	O
notified	*(char)
)	O
)	O
;	O
_pager_block_termination	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)))->(void)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
)	O
;	O
_pager_pagemap_resize	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)),int)->(int)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
,	O
offset	int
+	O
length	int
)	O
;	O
pm_entries	*(short)
=	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
pagemap	*(short)
[	O
offset	int
/	O
__vm_page_size	O
]	O
;	O
if	O
(	O
!	O
dirty	int
)	O
{	O
munmap	()->(int)
(	O
(	O
void	O
*	O
)	O
data	int
,	O
length	int
)	O
;	O
if	O
(	O
!	O
kcopy	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npages	int
;	O
i	int
++	O
)	O
notified	*(char)
[	O
i	int
]	O
=	O
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
notify_on_evict	int
&&	O
!	O
(	O
pm_entries	*(short)
[	O
i	int
]	O
&	O
PM_PAGEINWAIT	int
)	O
)	O
;	O
goto	O
notify	O
;	O
}	O
else	O
{	O
_pager_allow_termination	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)))->(void)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
)	O
;	O
goto	O
release_out	O
;	O
}	O
}	O
retry	O
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npages	int
;	O
i	int
++	O
)	O
if	O
(	O
pm_entries	*(short)
[	O
i	int
]	O
&	O
PM_PAGINGOUT	int
)	O
{	O
pm_entries	*(short)
[	O
i	int
]	O
|=	O
PM_WRITEWAIT	int
;	O
pthread_cond_wait	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
wakeup	int
,	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
interlock	int
)	O
;	O
goto	O
retry	O
;	O
}	O
if	O
(	O
initializing	int
)	O
{	O
assert	()->(int)
(	O
npages	int
<=	O
32	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npages	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
pm_entries	*(short)
[	O
i	int
]	O
&	O
PM_INIT	int
)	O
omitdata	int
|=	O
1	int
<<	O
i	int
;	O
else	O
pm_entries	*(short)
[	O
i	int
]	O
|=	O
PM_PAGINGOUT	int
|	O
PM_INIT	int
;	O
}	O
}	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npages	int
;	O
i	int
++	O
)	O
pm_entries	*(short)
[	O
i	int
]	O
|=	O
PM_PAGINGOUT	int
|	O
PM_INIT	int
;	O
lock_list	struct(*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int)),*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`))))))
=	O
0	int
;	O
for	O
(	O
lr	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
=	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
lock_requests	*(struct)
;	O
lr	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
;	O
lr	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
=	O
lr	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
->	O
next	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
)	O
if	O
(	O
offset	int
<	O
lr	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
->	O
end	int
&&	O
offset	int
+	O
length	int
>=	O
lr	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
->	O
start	int
)	O
{	O
ll	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`)))))
=	O
alloca	O
(	O
sizeof	O
(	O
struct	O
lock_list	struct(*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int)),*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`))))))
)	O
)	O
;	O
ll	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`)))))
->	O
lr	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
=	O
lr	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
;	O
ll	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
=	O
lock_list	struct(*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int)),*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`))))))
;	O
lock_list	struct(*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int)),*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`))))))
=	O
ll	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`)))))
;	O
lr	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
->	O
pending_writes	int
++	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
interlock	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npages	int
;	O
i	int
++	O
)	O
if	O
(	O
!	O
(	O
omitdata	int
&	O
(	O
1	int
<<	O
i	int
)	O
)	O
)	O
pagerrs	O
[	O
i	int
]	O
=	O
pager_write_page	()->(int)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
upi	*(struct)
,	O
offset	int
+	O
(	O
vm_page_size	O
*	O
i	int
)	O
,	O
data	int
+	O
(	O
vm_page_size	O
*	O
i	int
)	O
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
interlock	int
)	O
;	O
_pager_pagemap_resize	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)),int)->(int)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
,	O
offset	int
+	O
length	int
)	O
;	O
pm_entries	*(short)
=	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
pagemap	*(short)
[	O
offset	int
/	O
__vm_page_size	O
]	O
;	O
wakeup	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npages	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
omitdata	int
&	O
(	O
1	int
<<	O
i	int
)	O
)	O
{	O
notified	*(char)
[	O
i	int
]	O
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
pm_entries	*(short)
[	O
i	int
]	O
&	O
PM_WRITEWAIT	int
)	O
wakeup	int
=	O
1	int
;	O
if	O
(	O
pagerrs	O
[	O
i	int
]	O
&&	O
!	O
(	O
pm_entries	*(short)
[	O
i	int
]	O
&	O
PM_PAGEINWAIT	int
)	O
)	O
pm_entries	*(short)
[	O
i	int
]	O
|=	O
PM_INVALID	int
;	O
if	O
(	O
pm_entries	*(short)
[	O
i	int
]	O
&	O
PM_PAGEINWAIT	int
)	O
{	O
memory_object_data_supply	()->(int)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
memobjcntl	int
,	O
offset	int
+	O
(	O
vm_page_size	O
*	O
i	int
)	O
,	O
data	int
+	O
(	O
vm_page_size	O
*	O
i	int
)	O
,	O
vm_page_size	O
,	O
1	int
,	O
VM_PROT_NONE	O
,	O
0	int
,	O
MACH_PORT_NULL	O
)	O
;	O
notified	*(char)
[	O
i	int
]	O
=	O
0	int
;	O
}	O
else	O
{	O
munmap	()->(int)
(	O
(	O
void	O
*	O
)	O
(	O
data	int
+	O
(	O
vm_page_size	O
*	O
i	int
)	O
)	O
,	O
vm_page_size	O
)	O
;	O
notified	*(char)
[	O
i	int
]	O
=	O
(	O
!	O
kcopy	int
&&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
notify_on_evict	int
)	O
;	O
if	O
(	O
!	O
kcopy	int
)	O
pm_entries	*(short)
[	O
i	int
]	O
&=	O
~	O
PM_INCORE	int
;	O
}	O
pm_entries	*(short)
[	O
i	int
]	O
&=	O
~	O
(	O
PM_PAGINGOUT	int
|	O
PM_PAGEINWAIT	int
|	O
PM_WRITEWAIT	int
)	O
;	O
}	O
for	O
(	O
ll	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`)))))
=	O
lock_list	struct(*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int)),*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`))))))
;	O
ll	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`)))))
;	O
ll	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`)))))
=	O
ll	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
)	O
if	O
(	O
!	O
--	O
ll	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`)))))
->	O
lr	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
->	O
pending_writes	int
&&	O
!	O
ll	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(struct`)))))
->	O
lr	*(struct(*(struct(*(struct`),*(*`),int,int,int,int,int)),*(*(struct(*`,*`,int,int,int,int,int))),int,int,int,int,int))
->	O
locks_pending	int
)	O
wakeup	int
=	O
1	int
;	O
if	O
(	O
wakeup	int
)	O
pthread_cond_broadcast	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
wakeup	int
)	O
;	O
notify	O
:	O
_pager_allow_termination	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)))->(void)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
interlock	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npages	int
;	O
i	int
++	O
)	O
{	O
assert	()->(int)
(	O
notified	*(char)
[	O
i	int
]	O
==	O
0	int
||	O
notified	*(char)
[	O
i	int
]	O
==	O
1	int
)	O
;	O
if	O
(	O
notified	*(char)
[	O
i	int
]	O
)	O
{	O
short	O
*	O
pm_entry	*(short)
=	O
&	O
pm_entries	*(short)
[	O
i	int
]	O
;	O
pager_notify_evict	()->(int)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
upi	*(struct)
,	O
offset	int
+	O
(	O
i	int
*	O
vm_page_size	O
)	O
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
interlock	int
)	O
;	O
*	O
pm_entry	*(short)
=	O
SET_PM_ERROR	O
(	O
SET_PM_NEXTERROR	O
(	O
*	O
pm_entry	*(short)
,	O
0	int
)	O
,	O
0	int
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
interlock	int
)	O
;	O
}	O
}	O
return	O
0	int
;	O
release_out	O
:	O
pthread_mutex_unlock	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
interlock	int
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
_pager_S_memory_object_data_return	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)),int,int,int,int,int,int)->(int)
(	O
struct	O
pager	struct(struct,*(struct),enum(int,int,int),int,int,*(struct),*(struct),int,int,int,int,int,int,int,*(short),int)
*	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
,	O
mach_port_t	O
control	int
,	O
vm_offset_t	int
offset	int
,	O
pointer_t	O
data	int
,	O
vm_size_t	int
length	int
,	O
int	O
dirty	int
,	O
int	O
kcopy	int
)	O
{	O
return	O
_pager_do_write_request	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)),int,int,int,int,int,int,int)->(int)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
,	O
control	int
,	O
offset	int
,	O
data	int
,	O
length	int
,	O
dirty	int
,	O
kcopy	int
,	O
0	int
)	O
;	O
}	O
