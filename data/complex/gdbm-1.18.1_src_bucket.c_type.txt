void	O
_gdbm_new_bucket	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int)->(void)
(	O
GDBM_FILE	*(struct)
dbf	*(struct)
,	O
hash_bucket	struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))
*	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
int	O
bits	int
)	O
{	O
int	O
index	(*(char),int)->(*(char))
;	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
av_count	int
=	O
0	int
;	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
bucket_bits	int
=	O
bits	int
;	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
count	int
=	O
0	int
;	O
for	O
(	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
index	(*(char),int)->(*(char))
<	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_elems	int
;	O
index	(*(char),int)->(*(char))
++	O
)	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
hash_value	int
=	O
-	O
1	int
;	O
}	O
int	O
gdbm_dir_entry_valid_p	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(int)
(	O
GDBM_FILE	*(struct)
dbf	*(struct)
,	O
int	O
dir_index	int
)	O
{	O
return	O
dir_index	int
>=	O
0	int
&&	O
dir_index	int
<	O
GDBM_DIR_COUNT	O
(	O
dbf	*(struct)
)	O
&&	O
dbf	*(struct)
->	O
dir	long
[	O
dir_index	int
]	O
>=	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
block_size	int
;	O
}	O
int	O
_gdbm_get_bucket	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(int)
(	O
GDBM_FILE	*(struct)
dbf	*(struct)
,	O
int	O
dir_index	int
)	O
{	O
int	O
rc	int
;	O
off_t	long
bucket_adr	long
;	O
off_t	long
file_pos	long
;	O
int	O
index	(*(char),int)->(*(char))
;	O
if	O
(	O
!	O
gdbm_dir_entry_valid_p	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(int)
(	O
dbf	*(struct)
,	O
dir_index	int
)	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	*(struct)
,	O
GDBM_BAD_DIR_ENTRY	int
,	O
TRUE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
dbf	*(struct)
->	O
bucket_dir	int
=	O
dir_index	int
;	O
bucket_adr	long
=	O
dbf	*(struct)
->	O
dir	long
[	O
dir_index	int
]	O
;	O
if	O
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
==	O
NULL	O
)	O
{	O
if	O
(	O
_gdbm_init_cache	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),long)->(int)
(	O
dbf	*(struct)
,	O
DEFAULT_CACHESIZE	int
)	O
==	O
-	O
1	int
)	O
{	O
_gdbm_fatal	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(char))->(void)
(	O
dbf	*(struct)
,	O
_	O
(	O
"couldn't init cache"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
dbf	*(struct)
->	O
cache_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
->	O
ca_adr	long
!=	O
bucket_adr	long
)	O
{	O
size_t	long
lru	long
;	O
hash_bucket	struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))
*	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
;	O
for	O
(	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
index	(*(char),int)->(*(char))
<	O
dbf	*(struct)
->	O
cache_size	long
;	O
index	(*(char),int)->(*(char))
++	O
)	O
{	O
if	O
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
ca_adr	long
==	O
bucket_adr	long
)	O
{	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
=	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
ca_bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
;	O
dbf	*(struct)
->	O
cache_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
=	O
&	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
index	(*(char),int)->(*(char))
]	O
;	O
return	O
0	int
;	O
}	O
}	O
file_pos	long
=	O
gdbm_file_seek	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),long,int)->(long)
(	O
dbf	*(struct)
,	O
bucket_adr	long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
file_pos	long
!=	O
bucket_adr	long
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	*(struct)
,	O
GDBM_FILE_SEEK_ERROR	int
,	O
TRUE	int
)	O
;	O
_gdbm_fatal	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(char))->(void)
(	O
dbf	*(struct)
,	O
_	O
(	O
"lseek error"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
lru	long
=	O
(	O
dbf	*(struct)
->	O
last_read	long
+	O
1	int
)	O
%	O
dbf	*(struct)
->	O
cache_size	long
;	O
if	O
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
lru	long
]	O
.	O
ca_changed	char
)	O
{	O
if	O
(	O
_gdbm_write_bucket	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int))))->(int)
(	O
dbf	*(struct)
,	O
&	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
lru	long
]	O
)	O
)	O
return	O
-	O
1	int
;	O
}	O
_gdbm_cache_entry_invalidate	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(void)
(	O
dbf	*(struct)
,	O
lru	long
)	O
;	O
rc	int
=	O
_gdbm_full_read	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(void),long)->(int)
(	O
dbf	*(struct)
,	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
lru	long
]	O
.	O
ca_bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_size	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
GDBM_DEBUG	O
(	O
GDBM_DEBUG_ERR	O
,	O
"%s: error reading bucket: %s"	*(char)
,	O
dbf	*(struct)
->	O
name	*(char)
,	O
gdbm_db_strerror	(*(struct))->(*(char))
(	O
dbf	*(struct)
)	O
)	O
;	O
dbf	*(struct)
->	O
need_recovery	int
=	O
TRUE	int
;	O
_gdbm_fatal	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(char))->(void)
(	O
dbf	*(struct)
,	O
gdbm_db_strerror	(*(struct))->(*(char))
(	O
dbf	*(struct)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
=	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
lru	long
]	O
.	O
ca_bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
;	O
if	O
(	O
!	O
(	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
count	int
>=	O
0	int
&&	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
count	int
<=	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_elems	int
&&	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
bucket_bits	int
>=	O
0	int
&&	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
bucket_bits	int
<=	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir_bits	int
)	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	*(struct)
,	O
GDBM_BAD_BUCKET	int
,	O
TRUE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
gdbm_bucket_avail_table_validate	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))))->(int)
(	O
dbf	*(struct)
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
)	O
)	O
return	O
-	O
1	int
;	O
dbf	*(struct)
->	O
last_read	long
=	O
lru	long
;	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
lru	long
]	O
.	O
ca_adr	long
=	O
bucket_adr	long
;	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
=	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
lru	long
]	O
.	O
ca_bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
;	O
dbf	*(struct)
->	O
cache_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
=	O
&	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
lru	long
]	O
;	O
dbf	*(struct)
->	O
cache_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
->	O
ca_data	struct(int,int,int,*(char),long,int)
.	O
elem_loc	int
=	O
-	O
1	int
;	O
dbf	*(struct)
->	O
cache_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
->	O
ca_changed	char
=	O
FALSE	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
_gdbm_read_bucket_at	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long)->(int)
(	O
GDBM_FILE	*(struct)
dbf	*(struct)
,	O
off_t	long
off	long
,	O
hash_bucket	struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))
*	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
size_t	long
size	int
)	O
{	O
off_t	long
file_pos	long
;	O
int	O
i	int
;	O
if	O
(	O
dbf	*(struct)
->	O
cache_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
&&	O
dbf	*(struct)
->	O
cache_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
->	O
ca_adr	long
==	O
off	long
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
size	int
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dbf	*(struct)
->	O
cache_size	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
i	int
]	O
.	O
ca_adr	long
==	O
off	long
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
i	int
]	O
.	O
ca_bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
size	int
)	O
;	O
return	O
0	int
;	O
}	O
}	O
file_pos	long
=	O
gdbm_file_seek	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),long,int)->(long)
(	O
dbf	*(struct)
,	O
off	long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
file_pos	long
!=	O
off	long
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	*(struct)
,	O
GDBM_FILE_SEEK_ERROR	int
,	O
TRUE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
_gdbm_full_read	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(void),long)->(int)
(	O
dbf	*(struct)
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
size	int
)	O
)	O
{	O
GDBM_DEBUG	O
(	O
GDBM_DEBUG_ERR	O
,	O
"%s: error reading bucket: %s"	*(char)
,	O
dbf	*(struct)
->	O
name	*(char)
,	O
gdbm_db_strerror	(*(struct))->(*(char))
(	O
dbf	*(struct)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
_gdbm_split_bucket	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(int)
(	O
GDBM_FILE	*(struct)
dbf	*(struct)
,	O
int	O
next_insert	int
)	O
{	O
hash_bucket	struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))
*	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
2	int
]	O
;	O
int	O
new_bits	int
;	O
int	O
cache_0	int
;	O
int	O
cache_1	int
;	O
off_t	long
adr_0	long
;	O
off_t	long
adr_1	long
;	O
avail_elem	struct(int,long)
old_bucket	struct(int,long)
;	O
off_t	long
dir_start0	long
;	O
off_t	long
dir_start1	long
;	O
off_t	long
dir_end	long
;	O
off_t	long
*	O
new_dir	*(long)
;	O
off_t	long
dir_adr	long
;	O
int	O
dir_size	int
;	O
off_t	long
old_adr	array(long)
[	O
GDBM_HASH_BITS	int
]	O
;	O
int	O
old_size	array(int)
[	O
GDBM_HASH_BITS	int
]	O
;	O
int	O
old_count	int
;	O
int	O
index	(*(char),int)->(*(char))
;	O
int	O
index1	int
;	O
int	O
elem_loc	int
;	O
bucket_element	struct(int,array(char),long,int,int)
*	O
old_el	*(struct(int,array(char),long,int,int))
;	O
int	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
;	O
old_count	int
=	O
0	int
;	O
if	O
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
==	O
NULL	O
)	O
{	O
if	O
(	O
_gdbm_init_cache	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),long)->(int)
(	O
dbf	*(struct)
,	O
DEFAULT_CACHESIZE	int
)	O
==	O
-	O
1	int
)	O
{	O
_gdbm_fatal	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(char))->(void)
(	O
dbf	*(struct)
,	O
_	O
(	O
"couldn't init cache"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
while	O
(	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
count	int
==	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_elems	int
)	O
{	O
do	O
{	O
dbf	*(struct)
->	O
last_read	long
=	O
(	O
dbf	*(struct)
->	O
last_read	long
+	O
1	int
)	O
%	O
dbf	*(struct)
->	O
cache_size	long
;	O
cache_0	int
=	O
dbf	*(struct)
->	O
last_read	long
;	O
}	O
while	O
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
cache_0	int
]	O
.	O
ca_bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
==	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
)	O
;	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
0	int
]	O
=	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
cache_0	int
]	O
.	O
ca_bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
;	O
if	O
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
cache_0	int
]	O
.	O
ca_changed	char
)	O
{	O
if	O
(	O
_gdbm_write_bucket	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int))))->(int)
(	O
dbf	*(struct)
,	O
&	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
cache_0	int
]	O
)	O
)	O
return	O
-	O
1	int
;	O
}	O
do	O
{	O
dbf	*(struct)
->	O
last_read	long
=	O
(	O
dbf	*(struct)
->	O
last_read	long
+	O
1	int
)	O
%	O
dbf	*(struct)
->	O
cache_size	long
;	O
cache_1	int
=	O
dbf	*(struct)
->	O
last_read	long
;	O
}	O
while	O
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
cache_1	int
]	O
.	O
ca_bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
==	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
)	O
;	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
1	int
]	O
=	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
cache_1	int
]	O
.	O
ca_bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
;	O
if	O
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
cache_1	int
]	O
.	O
ca_changed	char
)	O
{	O
if	O
(	O
_gdbm_write_bucket	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int))))->(int)
(	O
dbf	*(struct)
,	O
&	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
cache_1	int
]	O
)	O
)	O
return	O
-	O
1	int
;	O
}	O
new_bits	int
=	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
bucket_bits	int
+	O
1	int
;	O
_gdbm_new_bucket	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int)->(void)
(	O
dbf	*(struct)
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
0	int
]	O
,	O
new_bits	int
)	O
;	O
_gdbm_new_bucket	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int)->(void)
(	O
dbf	*(struct)
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
1	int
]	O
,	O
new_bits	int
)	O
;	O
adr_0	long
=	O
_gdbm_alloc	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(long)
(	O
dbf	*(struct)
,	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_size	int
)	O
;	O
if	O
(	O
adr_0	long
==	O
0	int
)	O
return	O
-	O
1	int
;	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
cache_0	int
]	O
.	O
ca_adr	long
=	O
adr_0	long
;	O
adr_1	long
=	O
_gdbm_alloc	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(long)
(	O
dbf	*(struct)
,	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_size	int
)	O
;	O
if	O
(	O
adr_1	long
==	O
0	int
)	O
return	O
-	O
1	int
;	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
cache_1	int
]	O
.	O
ca_adr	long
=	O
adr_1	long
;	O
if	O
(	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir_bits	int
==	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
bucket_bits	int
)	O
{	O
if	O
(	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir_size	int
>=	O
GDBM_MAX_DIR_HALF	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	*(struct)
,	O
GDBM_DIR_OVERFLOW	int
,	O
TRUE	int
)	O
;	O
_gdbm_fatal	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(char))->(void)
(	O
dbf	*(struct)
,	O
_	O
(	O
"directory overflow"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
dir_size	int
=	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir_size	int
*	O
2	int
;	O
dir_adr	long
=	O
_gdbm_alloc	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(long)
(	O
dbf	*(struct)
,	O
dir_size	int
)	O
;	O
if	O
(	O
dir_adr	long
==	O
0	int
)	O
return	O
-	O
1	int
;	O
new_dir	*(long)
=	O
malloc	(long)->(*(void))
(	O
dir_size	int
)	O
;	O
if	O
(	O
new_dir	*(long)
==	O
NULL	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	*(struct)
,	O
GDBM_MALLOC_ERROR	int
,	O
TRUE	int
)	O
;	O
_gdbm_fatal	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(char))->(void)
(	O
dbf	*(struct)
,	O
_	O
(	O
"malloc error"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
index	(*(char),int)->(*(char))
<	O
GDBM_DIR_COUNT	O
(	O
dbf	*(struct)
)	O
;	O
index	(*(char),int)->(*(char))
++	O
)	O
{	O
new_dir	*(long)
[	O
2	int
*	O
index	(*(char),int)->(*(char))
]	O
=	O
dbf	*(struct)
->	O
dir	long
[	O
index	(*(char),int)->(*(char))
]	O
;	O
new_dir	*(long)
[	O
2	int
*	O
index	(*(char),int)->(*(char))
+	O
1	int
]	O
=	O
dbf	*(struct)
->	O
dir	long
[	O
index	(*(char),int)->(*(char))
]	O
;	O
}	O
old_adr	array(long)
[	O
old_count	int
]	O
=	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir	long
;	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir	long
=	O
dir_adr	long
;	O
old_size	array(int)
[	O
old_count	int
]	O
=	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir_size	int
;	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir_size	int
=	O
dir_size	int
;	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir_bits	int
=	O
new_bits	int
;	O
old_count	int
++	O
;	O
dbf	*(struct)
->	O
header_changed	int
=	O
TRUE	int
;	O
dbf	*(struct)
->	O
bucket_dir	int
*=	O
2	int
;	O
free	(*(void))->(void)
(	O
dbf	*(struct)
->	O
dir	long
)	O
;	O
dbf	*(struct)
->	O
dir	long
=	O
new_dir	*(long)
;	O
}	O
for	O
(	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
index	(*(char),int)->(*(char))
<	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_elems	int
;	O
index	(*(char),int)->(*(char))
++	O
)	O
{	O
old_el	*(struct(int,array(char),long,int,int))
=	O
&	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
index	(*(char),int)->(*(char))
]	O
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
=	O
(	O
old_el	*(struct(int,array(char),long,int,int))
->	O
hash_value	int
>>	O
(	O
GDBM_HASH_BITS	int
-	O
new_bits	int
)	O
)	O
&	O
1	int
;	O
elem_loc	int
=	O
old_el	*(struct(int,array(char),long,int,int))
->	O
hash_value	int
%	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_elems	int
;	O
while	O
(	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
]	O
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
elem_loc	int
]	O
.	O
hash_value	int
!=	O
-	O
1	int
)	O
elem_loc	int
=	O
(	O
elem_loc	int
+	O
1	int
)	O
%	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_elems	int
;	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
]	O
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
elem_loc	int
]	O
=	O
*	O
old_el	*(struct(int,array(char),long,int,int))
;	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
]	O
->	O
count	int
++	O
;	O
}	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
1	int
]	O
->	O
bucket_avail	array(struct(int,long))
[	O
0	int
]	O
.	O
av_adr	long
=	O
_gdbm_alloc	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(long)
(	O
dbf	*(struct)
,	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
block_size	int
)	O
;	O
if	O
(	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
1	int
]	O
->	O
bucket_avail	array(struct(int,long))
[	O
0	int
]	O
.	O
av_adr	long
==	O
0	int
)	O
return	O
-	O
1	int
;	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
1	int
]	O
->	O
bucket_avail	array(struct(int,long))
[	O
0	int
]	O
.	O
av_size	int
=	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
block_size	int
;	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
1	int
]	O
->	O
av_count	int
=	O
1	int
;	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
0	int
]	O
->	O
av_count	int
=	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
av_count	int
;	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
index1	int
=	O
0	int
;	O
if	O
(	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
0	int
]	O
->	O
av_count	int
==	O
BUCKET_AVAIL	int
)	O
{	O
_gdbm_put_av_elem	(struct(int,long),array(struct(int,long)),*(int),int)->(void)
(	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
bucket_avail	array(struct(int,long))
[	O
0	int
]	O
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
1	int
]	O
->	O
bucket_avail	array(struct(int,long))
,	O
&	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
1	int
]	O
->	O
av_count	int
,	O
dbf	*(struct)
->	O
coalesce_blocks	int
)	O
;	O
index	(*(char),int)->(*(char))
=	O
1	int
;	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
0	int
]	O
->	O
av_count	int
--	O
;	O
}	O
for	O
(	O
;	O
index	(*(char),int)->(*(char))
<	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
av_count	int
;	O
index	(*(char),int)->(*(char))
++	O
)	O
{	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
0	int
]	O
->	O
bucket_avail	array(struct(int,long))
[	O
index1	int
++	O
]	O
=	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
bucket_avail	array(struct(int,long))
[	O
index	(*(char),int)->(*(char))
]	O
;	O
}	O
dir_start1	long
=	O
(	O
dbf	*(struct)
->	O
bucket_dir	int
>>	O
(	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir_bits	int
-	O
new_bits	int
)	O
)	O
|	O
1	int
;	O
dir_end	long
=	O
(	O
dir_start1	long
+	O
1	int
)	O
<<	O
(	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir_bits	int
-	O
new_bits	int
)	O
;	O
dir_start1	long
=	O
dir_start1	long
<<	O
(	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir_bits	int
-	O
new_bits	int
)	O
;	O
dir_start0	long
=	O
dir_start1	long
-	O
(	O
dir_end	long
-	O
dir_start1	long
)	O
;	O
for	O
(	O
index	(*(char),int)->(*(char))
=	O
dir_start0	long
;	O
index	(*(char),int)->(*(char))
<	O
dir_start1	long
;	O
index	(*(char),int)->(*(char))
++	O
)	O
dbf	*(struct)
->	O
dir	long
[	O
index	(*(char),int)->(*(char))
]	O
=	O
adr_0	long
;	O
for	O
(	O
index	(*(char),int)->(*(char))
=	O
dir_start1	long
;	O
index	(*(char),int)->(*(char))
<	O
dir_end	long
;	O
index	(*(char),int)->(*(char))
++	O
)	O
dbf	*(struct)
->	O
dir	long
[	O
index	(*(char),int)->(*(char))
]	O
=	O
adr_1	long
;	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
cache_0	int
]	O
.	O
ca_changed	char
=	O
TRUE	int
;	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
cache_1	int
]	O
.	O
ca_changed	char
=	O
TRUE	int
;	O
dbf	*(struct)
->	O
bucket_changed	int
=	O
TRUE	int
;	O
dbf	*(struct)
->	O
directory_changed	int
=	O
TRUE	int
;	O
dbf	*(struct)
->	O
second_changed	int
=	O
TRUE	int
;	O
dbf	*(struct)
->	O
bucket_dir	int
=	O
_gdbm_bucket_dir	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(int)
(	O
dbf	*(struct)
,	O
next_insert	int
)	O
;	O
old_bucket	struct(int,long)
.	O
av_adr	long
=	O
dbf	*(struct)
->	O
cache_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
->	O
ca_adr	long
;	O
old_bucket	struct(int,long)
.	O
av_size	int
=	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_size	int
;	O
dbf	*(struct)
->	O
cache_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
->	O
ca_adr	long
=	O
0	int
;	O
dbf	*(struct)
->	O
cache_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
->	O
ca_changed	char
=	O
FALSE	int
;	O
if	O
(	O
dbf	*(struct)
->	O
dir	long
[	O
dbf	*(struct)
->	O
bucket_dir	int
]	O
==	O
adr_0	long
)	O
{	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
=	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
0	int
]	O
;	O
dbf	*(struct)
->	O
cache_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
=	O
&	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
cache_0	int
]	O
;	O
_gdbm_put_av_elem	(struct(int,long),array(struct(int,long)),*(int),int)->(void)
(	O
old_bucket	struct(int,long)
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
1	int
]	O
->	O
bucket_avail	array(struct(int,long))
,	O
&	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
1	int
]	O
->	O
av_count	int
,	O
dbf	*(struct)
->	O
coalesce_blocks	int
)	O
;	O
}	O
else	O
{	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
=	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
1	int
]	O
;	O
dbf	*(struct)
->	O
cache_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
=	O
&	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
cache_1	int
]	O
;	O
_gdbm_put_av_elem	(struct(int,long),array(struct(int,long)),*(int),int)->(void)
(	O
old_bucket	struct(int,long)
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
0	int
]	O
->	O
bucket_avail	array(struct(int,long))
,	O
&	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
[	O
0	int
]	O
->	O
av_count	int
,	O
dbf	*(struct)
->	O
coalesce_blocks	int
)	O
;	O
}	O
}	O
for	O
(	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
index	(*(char),int)->(*(char))
<	O
old_count	int
;	O
index	(*(char),int)->(*(char))
++	O
)	O
if	O
(	O
_gdbm_free	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),long,int)->(int)
(	O
dbf	*(struct)
,	O
old_adr	array(long)
[	O
index	(*(char),int)->(*(char))
]	O
,	O
old_size	array(int)
[	O
index	(*(char),int)->(*(char))
]	O
)	O
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
_gdbm_write_bucket	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int))))->(int)
(	O
GDBM_FILE	*(struct)
dbf	*(struct)
,	O
cache_elem	struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int))
*	O
ca_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
)	O
{	O
int	O
rc	int
;	O
off_t	long
file_pos	long
;	O
file_pos	long
=	O
gdbm_file_seek	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),long,int)->(long)
(	O
dbf	*(struct)
,	O
ca_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
->	O
ca_adr	long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
file_pos	long
!=	O
ca_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
->	O
ca_adr	long
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	*(struct)
,	O
GDBM_FILE_SEEK_ERROR	int
,	O
TRUE	int
)	O
;	O
_gdbm_fatal	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(char))->(void)
(	O
dbf	*(struct)
,	O
_	O
(	O
"lseek error"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
_gdbm_full_write	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(void),long)->(int)
(	O
dbf	*(struct)
,	O
ca_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
->	O
ca_bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_size	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
GDBM_DEBUG	O
(	O
GDBM_DEBUG_STORE	O
|	O
GDBM_DEBUG_ERR	O
,	O
"%s: error writing bucket: %s"	*(char)
,	O
dbf	*(struct)
->	O
name	*(char)
,	O
gdbm_db_strerror	(*(struct))->(*(char))
(	O
dbf	*(struct)
)	O
)	O
;	O
_gdbm_fatal	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(char))->(void)
(	O
dbf	*(struct)
,	O
gdbm_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
ca_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
->	O
ca_changed	char
=	O
FALSE	int
;	O
ca_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
->	O
ca_data	struct(int,int,int,*(char),long,int)
.	O
hash_val	int
=	O
-	O
1	int
;	O
ca_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
->	O
ca_data	struct(int,int,int,*(char),long,int)
.	O
elem_loc	int
=	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
