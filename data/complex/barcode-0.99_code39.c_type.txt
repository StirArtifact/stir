static	O
char	O
alphabet	array(char)
[	O
]	O
=	O
"1234567890"	*(char)
"ABCDEFGHIJ"	*(char)
"KLMNOPQRST"	*(char)
"UVWXYZ-. *"	*(char)
"$/+%"	*(char)
;	O
static	O
char	O
checkbet	array(char)
[	O
]	O
=	O
"0123456789"	*(char)
"ABCDEFGHIJ"	*(char)
"KLMNOPQRST"	*(char)
"UVWXYZ-. $"	*(char)
"/+%"	*(char)
;	O
static	O
char	O
*	O
bars	array(*(char))
[	O
]	O
=	O
{	O
"31113"	*(char)
,	O
"13113"	*(char)
,	O
"33111"	*(char)
,	O
"11313"	*(char)
,	O
"31311"	*(char)
,	O
"13311"	*(char)
,	O
"11133"	*(char)
,	O
"31131"	*(char)
,	O
"13131"	*(char)
,	O
"11331"	*(char)
}	O
;	O
static	O
char	O
*	O
spaces	array(*(char))
[	O
]	O
=	O
{	O
"1311"	*(char)
,	O
"1131"	*(char)
,	O
"1113"	*(char)
,	O
"3111"	*(char)
}	O
;	O
static	O
char	O
*	O
specialbars	array(*(char))
[	O
]	O
=	O
{	O
"11111"	*(char)
,	O
"11111"	*(char)
,	O
"11111"	*(char)
,	O
"11111"	*(char)
}	O
;	O
static	O
char	O
*	O
specialspaces	array(*(char))
[	O
]	O
=	O
{	O
"3331"	*(char)
,	O
"3313"	*(char)
,	O
"3133"	*(char)
,	O
"1333"	*(char)
}	O
;	O
static	O
char	O
*	O
fillers	array(*(char))
[	O
]	O
=	O
{	O
"0a3a1c1c1a"	*(char)
,	O
"1a3a1c1c1a"	*(char)
}	O
;	O
static	O
char	O
*	O
code39ext	array(*(char))
[	O
]	O
=	O
{	O
"%U"	*(char)
,	O
"$A"	*(char)
,	O
"$B"	*(char)
,	O
"$C"	*(char)
,	O
"$D"	*(char)
,	O
"$E"	*(char)
,	O
"$F"	*(char)
,	O
"$G"	*(char)
,	O
"$H"	*(char)
,	O
"$I"	*(char)
,	O
"$J"	*(char)
,	O
"$K"	*(char)
,	O
"$L"	*(char)
,	O
"$M"	*(char)
,	O
"$N"	*(char)
,	O
"$O"	*(char)
,	O
"$P"	*(char)
,	O
"$Q"	*(char)
,	O
"$R"	*(char)
,	O
"$S"	*(char)
,	O
"$T"	*(char)
,	O
"$U"	*(char)
,	O
"$V"	*(char)
,	O
"$W"	*(char)
,	O
"$X"	*(char)
,	O
"$Y"	*(char)
,	O
"$Z"	*(char)
,	O
"%A"	*(char)
,	O
"%B"	*(char)
,	O
"%C"	*(char)
,	O
"%D"	*(char)
,	O
"%E"	*(char)
,	O
" "	*(char)
,	O
"/A"	*(char)
,	O
"/B"	*(char)
,	O
"/C"	*(char)
,	O
"/D"	*(char)
,	O
"/E"	*(char)
,	O
"/F"	*(char)
,	O
"/G"	*(char)
,	O
"/H"	*(char)
,	O
"/I"	*(char)
,	O
"/J"	*(char)
,	O
"/K"	*(char)
,	O
"/L"	*(char)
,	O
"-"	*(char)
,	O
"."	*(char)
,	O
"/O"	*(char)
,	O
"0"	*(char)
,	O
"1"	*(char)
,	O
"2"	*(char)
,	O
"3"	*(char)
,	O
"4"	*(char)
,	O
"5"	*(char)
,	O
"6"	*(char)
,	O
"7"	*(char)
,	O
"8"	*(char)
,	O
"9"	*(char)
,	O
"/Z"	*(char)
,	O
"%F"	*(char)
,	O
"%G"	*(char)
,	O
"%H"	*(char)
,	O
"%I"	*(char)
,	O
"%J"	*(char)
,	O
"%V"	*(char)
,	O
"A"	*(char)
,	O
"B"	*(char)
,	O
"C"	*(char)
,	O
"D"	*(char)
,	O
"E"	*(char)
,	O
"F"	*(char)
,	O
"G"	*(char)
,	O
"H"	*(char)
,	O
"I"	*(char)
,	O
"J"	*(char)
,	O
"K"	*(char)
,	O
"L"	*(char)
,	O
"M"	*(char)
,	O
"N"	*(char)
,	O
"O"	*(char)
,	O
"P"	*(char)
,	O
"Q"	*(char)
,	O
"R"	*(char)
,	O
"S"	*(char)
,	O
"T"	*(char)
,	O
"U"	*(char)
,	O
"V"	*(char)
,	O
"W"	*(char)
,	O
"X"	*(char)
,	O
"Y"	*(char)
,	O
"Z"	*(char)
,	O
"%K"	*(char)
,	O
"%L"	*(char)
,	O
"%M"	*(char)
,	O
"%N"	*(char)
,	O
"%O"	*(char)
,	O
"%W"	*(char)
,	O
"+A"	*(char)
,	O
"+B"	*(char)
,	O
"+C"	*(char)
,	O
"+D"	*(char)
,	O
"+E"	*(char)
,	O
"+F"	*(char)
,	O
"+G"	*(char)
,	O
"+H"	*(char)
,	O
"+I"	*(char)
,	O
"+J"	*(char)
,	O
"+K"	*(char)
,	O
"+L"	*(char)
,	O
"+M"	*(char)
,	O
"+N"	*(char)
,	O
"+O"	*(char)
,	O
"+P"	*(char)
,	O
"+Q"	*(char)
,	O
"+R"	*(char)
,	O
"+S"	*(char)
,	O
"+T"	*(char)
,	O
"+U"	*(char)
,	O
"+V"	*(char)
,	O
"+W"	*(char)
,	O
"+X"	*(char)
,	O
"+Y"	*(char)
,	O
"+Z"	*(char)
,	O
"%P"	*(char)
,	O
"%Q"	*(char)
,	O
"%R"	*(char)
,	O
"%S"	*(char)
,	O
"%T"	*(char)
}	O
;	O
int	O
Barcode_39_verify	(*(char))->(int)
(	O
unsigned	O
char	O
*	O
text	*(char)
)	O
{	O
int	O
i	int
,	O
lower	int
=	O
0	int
,	O
upper	int
=	O
0	int
;	O
if	O
(	O
text	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
text	*(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
isupper	(int)->(int)
(	O
text	*(char)
[	O
i	int
]	O
)	O
)	O
upper	int
++	O
;	O
if	O
(	O
islower	(int)->(int)
(	O
text	*(char)
[	O
i	int
]	O
)	O
)	O
lower	int
++	O
;	O
if	O
(	O
!	O
strchr	(*(char),int)->(*(char))
(	O
alphabet	array(char)
,	O
toupper	(int)->(int)
(	O
text	*(char)
[	O
i	int
]	O
)	O
)	O
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
lower	int
&&	O
upper	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
Barcode_39ext_verify	(*(char))->(int)
(	O
unsigned	O
char	O
*	O
text	*(char)
)	O
{	O
int	O
i	int
;	O
if	O
(	O
text	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
text	*(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
text	*(char)
[	O
i	int
]	O
>	O
127	int
)	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
add_one	(*(char),int)->(int)
(	O
char	O
*	O
ptr	*(char)
,	O
int	O
code	int
)	O
{	O
char	O
*	O
b	*(char)
,	O
*	O
s	*(char)
;	O
if	O
(	O
code	int
<	O
40	int
)	O
{	O
b	*(char)
=	O
bars	array(*(char))
[	O
code	int
%	O
10	int
]	O
;	O
s	*(char)
=	O
spaces	array(*(char))
[	O
code	int
/	O
10	int
]	O
;	O
}	O
else	O
{	O
b	*(char)
=	O
specialbars	array(*(char))
[	O
code	int
-	O
40	int
]	O
;	O
s	*(char)
=	O
specialspaces	array(*(char))
[	O
code	int
-	O
40	int
]	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
ptr	*(char)
,	O
"1%c%c%c%c%c%c%c%c%c"	*(char)
,	O
b	*(char)
[	O
0	int
]	O
,	O
s	*(char)
[	O
0	int
]	O
,	O
b	*(char)
[	O
1	int
]	O
,	O
s	*(char)
[	O
1	int
]	O
,	O
b	*(char)
[	O
2	int
]	O
,	O
s	*(char)
[	O
2	int
]	O
,	O
b	*(char)
[	O
3	int
]	O
,	O
s	*(char)
[	O
3	int
]	O
,	O
b	*(char)
[	O
4	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
Barcode_39_encode	(*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)))->(int)
(	O
struct	O
Barcode_Item	struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)
*	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
)	O
{	O
static	O
char	O
*	O
text	*(char)
;	O
static	O
char	O
*	O
partial	*(char)
;	O
static	O
char	O
*	O
textinfo	*(char)
;	O
char	O
*	O
c	*(char)
,	O
*	O
ptr	*(char)
,	O
*	O
textptr	*(char)
;	O
int	O
i	int
,	O
code	int
,	O
textpos	int
,	O
checksum	int
=	O
0	int
;	O
if	O
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
)	O
free	(*(void))->(void)
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
)	O
;	O
if	O
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
)	O
free	(*(void))->(void)
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
)	O
;	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
=	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
encoding	*(char)
)	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
encoding	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
"code 39"	*(char)
)	O
;	O
text	*(char)
=	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
ascii	*(char)
;	O
if	O
(	O
!	O
text	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
partial	*(char)
=	O
malloc	(long)->(*(void))
(	O
(	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
+	O
3	int
)	O
*	O
10	int
+	O
2	int
)	O
;	O
if	O
(	O
!	O
partial	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
errno	O
;	O
return	O
-	O
1	int
;	O
}	O
textinfo	*(char)
=	O
malloc	(long)->(*(void))
(	O
10	int
*	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
+	O
2	int
)	O
;	O
if	O
(	O
!	O
textinfo	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
partial	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
fillers	array(*(char))
[	O
0	int
]	O
)	O
;	O
ptr	*(char)
=	O
partial	*(char)
+	O
strlen	(*(char))->(long)
(	O
partial	*(char)
)	O
;	O
textptr	*(char)
=	O
textinfo	*(char)
;	O
textpos	int
=	O
22	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
text	*(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
c	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
alphabet	array(char)
,	O
toupper	(int)->(int)
(	O
text	*(char)
[	O
i	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
c	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
EINVAL	int
;	O
free	(*(void))->(void)
(	O
partial	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
textinfo	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
code	int
=	O
c	*(char)
-	O
alphabet	array(char)
;	O
add_one	(*(char),int)->(int)
(	O
ptr	*(char)
,	O
code	int
)	O
;	O
c	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
checkbet	array(char)
,	O
*	O
c	*(char)
)	O
;	O
if	O
(	O
c	*(char)
)	O
checksum	int
+=	O
(	O
c	*(char)
-	O
checkbet	array(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
textptr	*(char)
,	O
"%i:12:%c "	*(char)
,	O
textpos	int
,	O
toupper	(int)->(int)
(	O
text	*(char)
[	O
i	int
]	O
)	O
)	O
;	O
textpos	int
+=	O
16	int
;	O
textptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
textptr	*(char)
)	O
;	O
ptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
ptr	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
flags	int
&	O
BARCODE_NO_CHECKSUM	int
)	O
==	O
0	int
)	O
{	O
code	int
=	O
(	O
strchr	(*(char),int)->(*(char))
(	O
alphabet	array(char)
,	O
checkbet	array(char)
[	O
checksum	int
%	O
43	int
]	O
)	O
-	O
alphabet	array(char)
)	O
;	O
add_one	(*(char),int)->(int)
(	O
ptr	*(char)
,	O
code	int
)	O
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
ptr	*(char)
,	O
fillers	array(*(char))
[	O
1	int
]	O
)	O
;	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
=	O
partial	*(char)
;	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
=	O
textinfo	*(char)
;	O
return	O
0	int
;	O
}	O
int	O
Barcode_39ext_encode	(*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)))->(int)
(	O
struct	O
Barcode_Item	struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)
*	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
)	O
{	O
static	O
char	O
*	O
eascii	*(char)
;	O
static	O
char	O
*	O
text	*(char)
;	O
char	O
c	*(char)
,	O
*	O
ptr	*(char)
;	O
int	O
i	int
;	O
text	*(char)
=	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
ascii	*(char)
;	O
if	O
(	O
!	O
text	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
eascii	*(char)
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
*	O
2	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
eascii	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
errno	O
;	O
return	O
-	O
1	int
;	O
}	O
ptr	*(char)
=	O
eascii	*(char)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
text	*(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
c	*(char)
=	O
text	*(char)
[	O
i	int
]	O
;	O
if	O
(	O
c	*(char)
<	O
0	int
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
EINVAL	int
;	O
free	(*(void))->(void)
(	O
eascii	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
ptr	*(char)
,	O
code39ext	array(*(char))
[	O
(	O
int	O
)	O
c	*(char)
]	O
)	O
;	O
ptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
ptr	*(char)
)	O
;	O
}	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
ascii	*(char)
=	O
eascii	*(char)
;	O
free	(*(void))->(void)
(	O
text	*(char)
)	O
;	O
return	O
Barcode_39_encode	(*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)))->(int)
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
)	O
;	O
}	O
