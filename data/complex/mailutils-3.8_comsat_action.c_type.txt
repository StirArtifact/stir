static	O
int	O
expand_escape	(*(*(char)),*(struct),*(struct))->(int)
(	O
char	O
*	O
*	O
pp	*(*(char))
,	O
mu_message_t	*(struct)
msg	*(struct)
,	O
mu_opool_t	*(struct)
pool	*(struct)
)	O
{	O
char	O
*	O
p	*(char)
=	O
*	O
pp	*(*(char))
;	O
char	O
*	O
start	long
,	O
*	O
sval	*(char)
,	O
*	O
namep	*(*(char))
;	O
int	O
len	int
;	O
mu_header_t	*(struct)
hdr	*(struct)
;	O
mu_body_t	*(struct)
body	*(struct)
;	O
mu_stream_t	*(struct)
stream	*(struct)
;	O
int	O
rc	int
=	O
1	int
;	O
size_t	long
size	*(long)
=	O
0	int
,	O
lncount	long
=	O
0	int
;	O
switch	O
(	O
*	O
++	O
p	*(char)
)	O
{	O
case	O
'u'	O
:	O
mu_opool_appendz	(*(struct),*(char))->(int)
(	O
pool	*(struct)
,	O
username	*(char)
)	O
;	O
*	O
pp	*(*(char))
=	O
p	*(char)
;	O
rc	int
=	O
0	int
;	O
break	O
;	O
case	O
'h'	O
:	O
mu_opool_appendz	(*(struct),*(char))->(int)
(	O
pool	*(struct)
,	O
hostname	*(char)
)	O
;	O
*	O
pp	*(*(char))
=	O
p	*(char)
;	O
rc	int
=	O
0	int
;	O
break	O
;	O
case	O
'H'	O
:	O
if	O
(	O
*	O
++	O
p	*(char)
!=	O
'{'	O
)	O
break	O
;	O
start	long
=	O
++	O
p	*(char)
;	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(char)
,	O
'}'	O
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
break	O
;	O
len	int
=	O
p	*(char)
-	O
start	long
;	O
if	O
(	O
len	int
==	O
0	int
||	O
(	O
namep	*(*(char))
=	O
malloc	(long)->(*(void))
(	O
len	int
+	O
1	int
)	O
)	O
==	O
NULL	O
)	O
break	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
namep	*(*(char))
,	O
start	long
,	O
len	int
)	O
;	O
namep	*(*(char))
[	O
len	int
]	O
=	O
0	int
;	O
if	O
(	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
hdr	*(struct)
)	O
==	O
0	int
&&	O
mu_header_aget_value	O
(	O
hdr	*(struct)
,	O
namep	*(*(char))
,	O
&	O
sval	*(char)
)	O
==	O
0	int
)	O
mu_opool_appendz	(*(struct),*(char))->(int)
(	O
pool	*(struct)
,	O
sval	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
namep	*(*(char))
)	O
;	O
*	O
pp	*(*(char))
=	O
p	*(char)
;	O
rc	int
=	O
0	int
;	O
break	O
;	O
case	O
'B'	O
:	O
if	O
(	O
*	O
++	O
p	*(char)
==	O
'('	O
)	O
{	O
size	*(long)
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
p	*(char)
+	O
1	int
,	O
&	O
p	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
','	O
)	O
lncount	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
p	*(char)
+	O
1	int
,	O
&	O
p	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(char)
!=	O
')'	O
)	O
break	O
;	O
}	O
if	O
(	O
size	*(long)
==	O
0	int
)	O
size	*(long)
=	O
400	int
;	O
if	O
(	O
lncount	long
==	O
0	int
)	O
lncount	long
=	O
maxlines	int
;	O
if	O
(	O
mu_message_get_body	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
body	*(struct)
)	O
==	O
0	int
&&	O
mu_body_get_streamref	(*(struct),*(*(struct)))->(int)
(	O
body	*(struct)
,	O
&	O
stream	*(struct)
)	O
==	O
0	int
)	O
{	O
size_t	long
nread	long
;	O
char	O
*	O
buf	*(char)
=	O
malloc	(long)->(*(void))
(	O
size	*(long)
+	O
1	int
)	O
;	O
if	O
(	O
!	O
buf	*(char)
)	O
break	O
;	O
if	O
(	O
mu_stream_read	(*(struct),*(void),long,*(long))->(int)
(	O
stream	*(struct)
,	O
buf	*(char)
,	O
size	*(long)
,	O
&	O
nread	long
)	O
==	O
0	int
)	O
{	O
char	O
*	O
q	*(char)
;	O
buf	*(char)
[	O
nread	long
]	O
=	O
0	int
;	O
q	*(char)
=	O
buf	*(char)
;	O
size	*(long)
=	O
0	int
;	O
while	O
(	O
lncount	long
--	O
)	O
{	O
char	O
*	O
s	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
q	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
s	*(char)
)	O
break	O
;	O
size	*(long)
+=	O
s	*(char)
-	O
q	*(char)
+	O
1	int
;	O
q	*(char)
=	O
s	*(char)
+	O
1	int
;	O
}	O
mu_opool_append	(*(struct),*(void),long)->(int)
(	O
pool	*(struct)
,	O
buf	*(char)
,	O
size	*(long)
)	O
;	O
}	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
stream	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
}	O
*	O
pp	*(*(char))
=	O
p	*(char)
;	O
rc	int
=	O
0	int
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
char	O
*	O
expand_line	(*(char),*(struct))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
,	O
mu_message_t	*(struct)
msg	*(struct)
)	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
int	O
c	char
=	O
0	int
;	O
mu_opool_t	*(struct)
pool	*(struct)
;	O
if	O
(	O
!	O
*	O
str	*(char)
)	O
return	O
NULL	O
;	O
mu_opool_create	(*(*(struct)),int)->(int)
(	O
&	O
pool	*(struct)
,	O
MU_OPOOL_ENOMEMABRT	int
)	O
;	O
for	O
(	O
p	*(char)
=	O
str	*(char)
;	O
*	O
p	*(char)
;	O
p	*(char)
++	O
)	O
{	O
switch	O
(	O
*	O
p	*(char)
)	O
{	O
case	O
'\\'	O
:	O
p	*(char)
++	O
;	O
if	O
(	O
*	O
p	*(char)
)	O
{	O
c	char
=	O
mu_wordsplit_c_unquote_char	(int)->(int)
(	O
*	O
p	*(char)
)	O
;	O
mu_opool_append_char	(*(struct),char)->(int)
(	O
pool	*(struct)
,	O
c	char
)	O
;	O
}	O
break	O
;	O
case	O
'$'	O
:	O
if	O
(	O
expand_escape	(*(*(char)),*(struct),*(struct))->(int)
(	O
(	O
char	O
*	O
*	O
)	O
&	O
p	*(char)
,	O
msg	*(struct)
,	O
pool	*(struct)
)	O
==	O
0	int
)	O
break	O
;	O
default	O
:	O
mu_opool_append_char	(*(struct),char)->(int)
(	O
pool	*(struct)
,	O
*	O
p	*(char)
)	O
;	O
}	O
}	O
mu_opool_append_char	(*(struct),char)->(int)
(	O
pool	*(struct)
,	O
0	int
)	O
;	O
str	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
mu_opool_finish	(*(struct),*(long))->(*(void))
(	O
pool	*(struct)
,	O
NULL	O
)	O
)	O
;	O
mu_opool_destroy	(*(*(struct)))->(void)
(	O
&	O
pool	*(struct)
)	O
;	O
return	O
(	O
char	O
*	O
)	O
str	*(char)
;	O
}	O
const	O
char	O
*	O
default_action	*(char)
=	O
;	O
static	O
int	O
study_tty	(*(struct),array(*(char)),*(int))->(int)
(	O
mu_stream_t	*(struct)
str	*(char)
,	O
char	O
*	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
[	O
]	O
,	O
int	O
*	O
nflt	*(int)
)	O
{	O
mu_transport_t	*(void)
trans	array(*(void))
[	O
2	int
]	O
;	O
int	O
fd	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long))
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
str	*(char)
,	O
MU_IOCTL_TRANSPORT	int
,	O
MU_IOCTL_OP_GET	int
,	O
trans	array(*(void))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_ioctl"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
rc	int
;	O
}	O
*	O
nflt	*(int)
=	O
0	int
;	O
fd	int
=	O
(	O
int	O
)	O
(	O
intptr_t	long
)	O
trans	array(*(void))
[	O
0	int
]	O
;	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fd	int
,	O
&	O
st	*(struct(long,long,long))
)	O
==	O
0	int
)	O
{	O
switch	O
(	O
st	*(struct(long,long,long))
.	O
st_mode	int
&	O
S_IFMT	O
)	O
{	O
case	O
S_IFREG	O
:	O
return	O
0	int
;	O
case	O
S_IFCHR	O
:	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
[	O
(	O
*	O
nflt	*(int)
)	O
++	O
]	O
=	O
"7BIT"	*(char)
;	O
{	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
tbuf	struct(int,int,int,int,char,array(char),int,int)
;	O
if	O
(	O
!	O
(	O
tcgetattr	(int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
fd	int
,	O
&	O
tbuf	struct(int,int,int,int,char,array(char),int,int)
)	O
==	O
0	int
&&	O
(	O
tbuf	struct(int,int,int,int,char,array(char),int,int)
.	O
c_oflag	int
&	O
OPOST	int
)	O
&&	O
(	O
tbuf	struct(int,int,int,int,char,array(char),int,int)
.	O
c_oflag	int
&	O
ONLCR	int
)	O
)	O
)	O
{	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
[	O
(	O
*	O
nflt	*(int)
)	O
++	O
]	O
=	O
"+"	*(char)
;	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
[	O
(	O
*	O
nflt	*(int)
)	O
++	O
]	O
=	O
"CRLF"	*(char)
;	O
}	O
}	O
break	O
;	O
case	O
S_IFSOCK	O
:	O
return	O
0	int
;	O
default	O
:	O
return	O
0	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
mu_stream_t	*(struct)
_open_tty	(*(char),int,*(*(char)))->(*(struct))
(	O
const	O
char	O
*	O
device	*(char)
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
mu_stream_t	*(struct)
dev	*(struct)
;	O
int	O
status	int
;	O
char	O
*	O
dfl_argv	array(*(char))
[	O
4	int
]	O
;	O
status	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
dev	*(struct)
,	O
device	*(char)
,	O
MU_STREAM_APPEND	int
|	O
MU_STREAM_CREAT	int
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot open device %s: %s"	*(char)
)	O
,	O
device	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
mu_stream_set_buffer	(*(struct),enum(int,int,int),long)->(int)
(	O
dev	*(struct)
,	O
mu_buffer_line	int
,	O
0	int
)	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
{	O
status	int
=	O
study_tty	(*(struct),array(*(char)),*(int))->(int)
(	O
dev	*(struct)
,	O
dfl_argv	array(*(char))
,	O
&	O
argc	int
)	O
;	O
if	O
(	O
status	int
)	O
return	O
NULL	O
;	O
argv	*(*(char))
=	O
dfl_argv	array(*(char))
;	O
}	O
if	O
(	O
argc	int
)	O
{	O
mu_stream_t	*(struct)
str	*(char)
;	O
status	int
=	O
mu_filter_chain_create	(*(*(struct)),*(struct),int,int,long,*(*(char)))->(int)
(	O
&	O
str	*(char)
,	O
dev	*(struct)
,	O
MU_FILTER_ENCODE	int
,	O
MU_STREAM_WRITE	int
,	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
dev	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_filter_chain_create"	*(char)
,	O
device	*(char)
,	O
status	int
)	O
;	O
return	O
NULL	O
;	O
}	O
dev	*(struct)
=	O
str	*(char)
;	O
}	O
return	O
dev	*(struct)
;	O
}	O
mu_stream_t	*(struct)
open_tty	(*(char),int,*(*(char)))->(*(struct))
(	O
const	O
char	O
*	O
device	*(char)
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
mu_stream_t	*(struct)
dev	*(struct)
;	O
if	O
(	O
!	O
device	*(char)
||	O
!	O
*	O
device	*(char)
||	O
strcmp	(*(char),*(char))->(int)
(	O
device	*(char)
,	O
"null"	*(char)
)	O
==	O
0	int
)	O
{	O
int	O
rc	int
=	O
mu_nullstream_create	(*(*(struct)),int)->(int)
(	O
&	O
dev	*(struct)
,	O
MU_STREAM_WRITE	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot open null stream: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
dev	*(struct)
=	O
NULL	O
;	O
}	O
}	O
else	O
dev	*(struct)
=	O
_open_tty	(*(char),int,*(*(char)))->(*(struct))
(	O
device	*(char)
,	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
return	O
dev	*(struct)
;	O
}	O
struct	O
biffrc_environ	struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*(char),int,int),struct(*(char),int,int)),int,*(char),long)
{	O
mu_stream_t	*(struct)
tty	*(struct)
;	O
mu_stream_t	*(struct)
logstr	*(struct)
;	O
mu_message_t	*(struct)
msg	*(struct)
;	O
mu_stream_t	*(struct)
input	*(char)
;	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
int	O
use_default	int
;	O
char	O
*	O
errbuf	*(char)
;	O
size_t	long
errsize	long
;	O
}	O
;	O
static	O
void	O
report_error	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),*(char))->(void)
(	O
struct	O
biffrc_environ	struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*(char),int,int),struct(*(char),int,int)),int,*(char),long)
*	O
env	*(struct)
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
if	O
(	O
biffrc_errors	int
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
mu_vasnprintf	(*(*(char)),*(long),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
&	O
env	*(struct)
->	O
errbuf	*(char)
,	O
&	O
env	*(struct)
->	O
errsize	long
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
if	O
(	O
biffrc_errors	int
&	O
BIFFRC_ERRORS_TO_TTY	int
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
env	*(struct)
->	O
logstr	*(struct)
,	O
"%s\n"	*(char)
,	O
env	*(struct)
->	O
errbuf	*(char)
)	O
;	O
if	O
(	O
biffrc_errors	int
&	O
BIFFRC_ERRORS_TO_ERR	int
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
"%s"	*(char)
,	O
env	*(struct)
->	O
errbuf	*(char)
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
}	O
static	O
void	O
action_beep	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),long,*(*(char)))->(void)
(	O
struct	O
biffrc_environ	struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*(char),int,int),struct(*(char),int,int)),int,*(char),long)
*	O
env	*(struct)
,	O
size_t	long
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
mu_stream_write	(*(struct),*(void),long,*(long))->(int)
(	O
env	*(struct)
->	O
tty	*(struct)
,	O
"\a\a"	*(char)
,	O
2	int
,	O
NULL	O
)	O
;	O
mu_stream_flush	(*(struct))->(int)
(	O
env	*(struct)
->	O
tty	*(struct)
)	O
;	O
}	O
static	O
void	O
echo_string	(*(struct),*(char))->(void)
(	O
mu_stream_t	*(struct)
tty	*(struct)
,	O
char	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
!	O
str	*(char)
)	O
return	O
;	O
mu_stream_write	(*(struct),*(void),long,*(long))->(int)
(	O
tty	*(struct)
,	O
str	*(char)
,	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
action_echo	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),long,*(*(char)))->(void)
(	O
struct	O
biffrc_environ	struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*(char),int,int),struct(*(char),int,int)),int,*(char),long)
*	O
env	*(struct)
,	O
size_t	long
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
i	int
=	O
1	int
;	O
int	O
omit_newline	int
;	O
if	O
(	O
argc	int
>	O
2	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-n"	*(char)
)	O
==	O
0	int
)	O
{	O
omit_newline	int
=	O
1	int
;	O
i	int
++	O
;	O
}	O
else	O
omit_newline	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
echo_string	(*(struct),*(char))->(void)
(	O
env	*(struct)
->	O
tty	*(struct)
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
++	O
i	int
<	O
argc	int
)	O
echo_string	(*(struct),*(char))->(void)
(	O
env	*(struct)
->	O
tty	*(struct)
,	O
" "	*(char)
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
!	O
omit_newline	int
)	O
echo_string	(*(struct),*(char))->(void)
(	O
env	*(struct)
->	O
tty	*(struct)
,	O
"\n"	*(char)
)	O
;	O
}	O
static	O
void	O
action_exec	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),long,*(*(char)))->(void)
(	O
struct	O
biffrc_environ	struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*(char),int,int),struct(*(char),int,int)),int,*(char),long)
*	O
env	*(struct)
,	O
size_t	long
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
mu_stream_t	*(struct)
pstream	*(*(struct))
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
stb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
status	int
;	O
argc	int
--	O
;	O
argv	*(*(char))
++	O
;	O
if	O
(	O
argv	*(*(char))
[	O
0	int
]	O
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
report_error	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),*(char))->(void)
(	O
env	*(struct)
,	O
_	O
(	O
"not an absolute pathname: %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
&	O
stb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"stat"	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
,	O
errno	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
stb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
(	O
S_ISUID	O
|	O
S_ISGID	O
)	O
)	O
{	O
report_error	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),*(char))->(void)
(	O
env	*(struct)
,	O
_	O
(	O
"will not execute set[ug]id programs"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
status	int
=	O
mu_prog_stream_create	(*(*(struct)),*(char),long,*(*(char)),int,*(struct(*(char),int,*(int),long,array(long),int,*(struct),*(struct))),int)->(int)
(	O
&	O
pstream	*(*(struct))
,	O
argv	*(*(char))
[	O
0	int
]	O
,	O
argc	int
,	O
argv	*(*(char))
,	O
MU_PROG_HINT_ERRTOOUT	int
,	O
NULL	O
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
status	int
)	O
{	O
report_error	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),*(char))->(void)
(	O
env	*(struct)
,	O
"mu_prog_stream_create(%s) failed: %s"	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
return	O
;	O
}	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
env	*(struct)
->	O
tty	*(struct)
,	O
pstream	*(*(struct))
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
pstream	*(*(struct))
)	O
;	O
}	O
static	O
void	O
action_default	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),long,*(*(char)))->(void)
(	O
struct	O
biffrc_environ	struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*(char),int,int),struct(*(char),int,int)),int,*(char),long)
*	O
env	*(struct)
,	O
size_t	long
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
env	*(struct)
->	O
use_default	int
=	O
1	int
;	O
}	O
static	O
void	O
action_tty	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),long,*(*(char)))->(void)
(	O
struct	O
biffrc_environ	struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*(char),int,int),struct(*(char),int,int)),int,*(char),long)
*	O
env	*(struct)
,	O
size_t	long
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
mu_stream_t	*(struct)
ntty	*(struct)
=	O
open_tty	(*(char),int,*(*(char)))->(*(struct))
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
argc	int
-	O
2	int
,	O
argv	*(*(char))
+	O
2	int
)	O
;	O
if	O
(	O
!	O
ntty	*(struct)
)	O
report_error	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),*(char))->(void)
(	O
env	*(struct)
,	O
_	O
(	O
"cannot open tty %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
env	*(struct)
->	O
tty	*(struct)
)	O
;	O
env	*(struct)
->	O
tty	*(struct)
=	O
ntty	*(struct)
;	O
}	O
static	O
mu_stream_t	*(struct)
open_rc	(*(char),*(struct))->(*(struct))
(	O
const	O
char	O
*	O
filename	*(char)
,	O
mu_stream_t	*(struct)
tty	*(struct)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
stb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
username	*(char)
)	O
;	O
mu_stream_t	*(struct)
stream	*(struct)
,	O
input	*(char)
;	O
int	O
rc	int
;	O
static	O
char	O
*	O
linecon_args	array(*(char))
[	O
]	O
=	O
{	O
"linecon"	*(char)
,	O
"-i"	*(char)
,	O
"#line"	*(char)
,	O
NULL	O
}	O
;	O
if	O
(	O
!	O
allow_biffrc	int
||	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_uid	int
==	O
0	int
)	O
return	O
NULL	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
filename	*(char)
,	O
&	O
stb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
)	O
{	O
if	O
(	O
stb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_uid	int
!=	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_uid	int
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_NOTICE	O
,	O
_	O
(	O
"%s's %s is not owned by %s"	*(char)
)	O
,	O
username	*(char)
,	O
filename	*(char)
,	O
username	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
stb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
0777	int
)	O
!=	O
0600	int
)	O
{	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
tty	*(struct)
,	O
"%s\n"	*(char)
,	O
_	O
(	O
"Warning: your .biffrc has wrong permissions"	*(char)
)	O
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_NOTICE	O
,	O
_	O
(	O
"%s's %s has wrong permissions"	*(char)
)	O
,	O
username	*(char)
,	O
filename	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
input	*(char)
,	O
filename	*(char)
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
if	O
(	O
rc	int
!=	O
ENOENT	int
)	O
{	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
tty	*(struct)
,	O
_	O
(	O
"Cannot open .biffrc file: %s\n"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_NOTICE	O
,	O
_	O
(	O
"cannot open %s for %s: %s"	*(char)
)	O
,	O
filename	*(char)
,	O
username	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
rc	int
=	O
mu_filter_create_args	(*(*(struct)),*(struct),*(char),int,*(*(char)),int,int)->(int)
(	O
&	O
stream	*(struct)
,	O
input	*(char)
,	O
"LINECON"	*(char)
,	O
MU_ARRAY_SIZE	O
(	O
linecon_args	array(*(char))
)	O
-	O
1	int
,	O
(	O
const	O
char	O
*	O
*	O
)	O
linecon_args	array(*(char))
,	O
MU_FILTER_DECODE	int
,	O
MU_STREAM_READ	int
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
input	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
tty	*(struct)
,	O
_	O
(	O
"Cannot create filter for your .biffrc file: %s\n"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_NOTICE	O
,	O
_	O
(	O
"cannot create filter for file %s of %s: %s"	*(char)
)	O
,	O
filename	*(char)
,	O
username	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
stream	*(struct)
;	O
}	O
struct	O
biffrc_stmt	struct(*(char),int,int,int,*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),struct(struct`,struct`),int,*(char),long)),long,*(*(char)))->(void)))
{	O
const	O
char	O
*	O
id	*(char)
;	O
int	O
argmin	int
;	O
int	O
argmax	int
;	O
int	O
expand	int
;	O
void	O
(	O
*	O
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
)	O
(	O
struct	O
biffrc_environ	struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*(char),int,int),struct(*(char),int,int)),int,*(char),long)
*	O
env	*(struct)
,	O
size_t	long
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
;	O
}	O
;	O
struct	O
biffrc_stmt	struct(*(char),int,int,int,*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),struct(struct`,struct`),int,*(char),long)),long,*(*(char)))->(void)))
biffrc_tab	array(struct(*(char),int,int,int,*((*(struct(*`,*`,*`,*`,struct`,int,*`,long)),long,*(*(char)))->(void))))
[	O
]	O
=	O
{	O
{	O
"beep"	*(char)
,	O
1	int
,	O
1	int
,	O
0	int
,	O
action_beep	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),long,*(*(char)))->(void)
}	O
,	O
{	O
"tty"	*(char)
,	O
2	int
,	O
-	O
1	int
,	O
0	int
,	O
action_tty	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),long,*(*(char)))->(void)
}	O
,	O
{	O
"echo"	*(char)
,	O
2	int
,	O
-	O
1	int
,	O
1	int
,	O
action_echo	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),long,*(*(char)))->(void)
}	O
,	O
{	O
"exec"	*(char)
,	O
2	int
,	O
-	O
1	int
,	O
1	int
,	O
action_exec	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),long,*(*(char)))->(void)
}	O
,	O
{	O
"default"	*(char)
,	O
1	int
,	O
1	int
,	O
0	int
,	O
action_default	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),long,*(*(char)))->(void)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
biffrc_stmt	struct(*(char),int,int,int,*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),struct(struct`,struct`),int,*(char),long)),long,*(*(char)))->(void)))
*	O
find_stmt	(*(char))->(*(struct(*(char),int,int,int,*((*`,long,*`)->(void)))))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
biffrc_stmt	struct(*(char),int,int,int,*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),struct(struct`,struct`),int,*(char),long)),long,*(*(char)))->(void)))
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
biffrc_tab	array(struct(*(char),int,int,int,*((*(struct(*`,*`,*`,*`,struct`,int,*`,long)),long,*(*(char)))->(void))))
;	O
p	*(char)
->	O
id	*(char)
;	O
p	*(char)
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
p	*(char)
->	O
id	*(char)
)	O
==	O
0	int
)	O
return	O
p	*(char)
;	O
return	O
NULL	O
;	O
}	O
void	O
eval_biffrc	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)))->(void)
(	O
struct	O
biffrc_environ	struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*(char),int,int),struct(*(char),int,int)),int,*(char),long)
*	O
env	*(struct)
)	O
{	O
char	O
*	O
stmt	*(char)
=	O
NULL	O
;	O
size_t	long
size	*(long)
=	O
0	int
;	O
size_t	long
n	int
;	O
struct	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
int	O
wsflags	int
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_comment	*(char)
=	O
"#"	*(char)
;	O
wsflags	int
=	O
MU_WRDSF_DEFFLAGS	O
|	O
MU_WRDSF_COMMENT	O
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
&	O
env	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
env	*(struct)
->	O
logstr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
&	O
env	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
while	O
(	O
mu_stream_getline	(*(struct),*(*(char)),*(long),*(long))->(int)
(	O
env	*(struct)
->	O
input	*(char)
,	O
&	O
stmt	*(char)
,	O
&	O
size	*(long)
,	O
&	O
n	int
)	O
==	O
0	int
&&	O
n	int
>	O
0	int
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
stmt	*(char)
,	O
"#line "	*(char)
,	O
6	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
p	*(char)
;	O
env	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
mu_line	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
stmt	*(char)
+	O
6	int
,	O
&	O
p	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(char)
!=	O
'\n'	O
)	O
{	O
report_error	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),*(char))->(void)
(	O
env	*(struct)
,	O
_	O
(	O
"malformed #line directive: %s"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_LINE	int
,	O
&	O
env	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
mu_line	int
)	O
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
env	*(struct)
->	O
logstr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_LINE	int
,	O
&	O
env	*(struct)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
mu_line	int
)	O
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
stmt	*(char)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
wsflags	int
)	O
==	O
0	int
)	O
{	O
struct	O
biffrc_stmt	struct(*(char),int,int,int,*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),struct(struct`,struct`),int,*(char),long)),long,*(*(char)))->(void)))
*	O
sp	*(struct(int,long,long,long,long,long,long,int,long))
;	O
if	O
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
==	O
0	int
)	O
{	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_ADVANCE_LOCUS_LINE	int
,	O
NULL	O
)	O
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
env	*(struct)
->	O
logstr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_ADVANCE_LOCUS_LINE	int
,	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
sp	*(struct(int,long,long,long,long,long,long,int,long))
=	O
find_stmt	(*(char))->(*(struct(*(char),int,int,int,*((*`,long,*`)->(void)))))
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
sp	*(struct(int,long,long,long,long,long,long,int,long))
)	O
report_error	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),*(char))->(void)
(	O
env	*(struct)
,	O
_	O
(	O
"unknown keyword"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
<	O
sp	*(struct(int,long,long,long,long,long,long,int,long))
->	O
argmin	int
)	O
report_error	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),*(char))->(void)
(	O
env	*(struct)
,	O
_	O
(	O
"too few arguments"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
sp	*(struct(int,long,long,long,long,long,long,int,long))
->	O
argmax	int
!=	O
-	O
1	int
&&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
>	O
sp	*(struct(int,long,long,long,long,long,long,int,long))
->	O
argmax	int
)	O
report_error	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),*(char))->(void)
(	O
env	*(struct)
,	O
_	O
(	O
"too many arguments"	*(char)
)	O
)	O
;	O
else	O
{	O
if	O
(	O
sp	*(struct(int,long,long,long,long,long,long,int,long))
->	O
expand	int
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
;	O
i	int
++	O
)	O
{	O
char	O
*	O
oldarg	*(char)
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	int
]	O
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	int
]	O
=	O
expand_line	(*(char),*(struct))->(*(char))
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	int
]	O
,	O
env	*(struct)
->	O
msg	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
oldarg	*(char)
)	O
;	O
if	O
(	O
!	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	int
]	O
)	O
break	O
;	O
}	O
}	O
sp	*(struct(int,long,long,long,long,long,long,int,long))
->	O
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
(	O
env	*(struct)
,	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
,	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
)	O
;	O
}	O
}	O
else	O
report_error	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)),*(char))->(void)
(	O
env	*(struct)
,	O
"%s"	*(char)
,	O
mu_wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
;	O
wsflags	int
|=	O
MU_WRDSF_REUSE	O
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_ADVANCE_LOCUS_LINE	int
,	O
NULL	O
)	O
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
env	*(struct)
->	O
logstr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_ADVANCE_LOCUS_LINE	int
,	O
NULL	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
stmt	*(char)
)	O
;	O
mu_wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
NULL	O
)	O
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
env	*(struct)
->	O
logstr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
NULL	O
)	O
;	O
}	O
void	O
run_user_action	(*(char),*(struct))->(void)
(	O
const	O
char	O
*	O
device	*(char)
,	O
mu_message_t	*(struct)
msg	*(struct)
)	O
{	O
int	O
rc	int
,	O
mode	int
;	O
mu_stream_t	*(struct)
stream	*(struct)
;	O
struct	O
biffrc_environ	struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*(char),int,int),struct(*(char),int,int)),int,*(char),long)
env	*(struct)
;	O
env	*(struct)
.	O
tty	*(struct)
=	O
open_tty	(*(char),int,*(*(char)))->(*(struct))
(	O
device	*(char)
,	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
env	*(struct)
.	O
tty	*(struct)
)	O
return	O
;	O
env	*(struct)
.	O
msg	*(struct)
=	O
msg	*(struct)
;	O
env	*(struct)
.	O
errbuf	*(char)
=	O
NULL	O
;	O
env	*(struct)
.	O
errsize	long
=	O
0	int
;	O
rc	int
=	O
mu_log_stream_create	(*(*(struct)),*(struct))->(int)
(	O
&	O
env	*(struct)
.	O
logstr	*(struct)
,	O
env	*(struct)
.	O
tty	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"cannot create log stream: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
env	*(struct)
.	O
tty	*(struct)
)	O
;	O
return	O
;	O
}	O
mode	int
=	O
MU_LOGMODE_LOCUS	int
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
env	*(struct)
.	O
logstr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_MODE	int
,	O
&	O
mode	int
)	O
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_MODE	int
,	O
&	O
mode	int
)	O
;	O
env	*(struct)
.	O
input	*(char)
=	O
open_rc	(*(char),*(struct))->(*(struct))
(	O
biffrc	*(char)
,	O
env	*(struct)
.	O
tty	*(struct)
)	O
;	O
if	O
(	O
env	*(struct)
.	O
input	*(char)
)	O
{	O
char	O
*	O
cwd	short
=	O
mu_getcwd	()->(*(char))
(	O
)	O
;	O
char	O
*	O
rcname	*(char)
;	O
rcname	*(char)
=	O
mu_make_file_name	O
(	O
cwd	short
,	O
BIFF_RC	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cwd	short
)	O
;	O
if	O
(	O
!	O
rcname	*(char)
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_make_file_name"	*(char)
,	O
NULL	O
,	O
ENOMEM	int
)	O
;	O
env	*(struct)
.	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
mu_file	*(char)
=	O
BIFF_RC	*(char)
;	O
}	O
else	O
env	*(struct)
.	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
mu_file	*(char)
=	O
rcname	*(char)
;	O
env	*(struct)
.	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
mu_line	int
=	O
1	int
;	O
env	*(struct)
.	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
mu_col	int
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
env	*(struct)
.	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
end	struct(*(char),int,int)
,	O
0	int
,	O
sizeof	O
env	*(struct)
.	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
end	struct(*(char),int,int)
)	O
;	O
env	*(struct)
.	O
use_default	int
=	O
0	int
;	O
eval_biffrc	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)))->(void)
(	O
&	O
env	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
env	*(struct)
.	O
input	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
rcname	*(char)
)	O
;	O
}	O
else	O
env	*(struct)
.	O
use_default	int
=	O
1	int
;	O
if	O
(	O
env	*(struct)
.	O
use_default	int
&&	O
mu_static_memory_stream_create	(*(*(struct)),*(void),long)->(int)
(	O
&	O
stream	*(struct)
,	O
default_action	*(char)
,	O
strlen	(*(char))->(long)
(	O
default_action	*(char)
)	O
)	O
==	O
0	int
)	O
{	O
int	O
rc	int
=	O
mu_filter_create	(*(*(struct)),*(struct),*(char),int,int)->(int)
(	O
&	O
env	*(struct)
.	O
input	*(char)
,	O
stream	*(struct)
,	O
"LINECON"	*(char)
,	O
MU_FILTER_DECODE	int
,	O
MU_STREAM_READ	int
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
stream	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
env	*(struct)
.	O
tty	*(struct)
,	O
_	O
(	O
"Cannot create filter for the default action: %s\n"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_NOTICE	O
,	O
_	O
(	O
"cannot create default filter for %s: %s"	*(char)
)	O
,	O
username	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
else	O
{	O
env	*(struct)
.	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
mu_file	*(char)
=	O
"<default>"	*(char)
;	O
env	*(struct)
.	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
mu_line	int
=	O
1	int
;	O
env	*(struct)
.	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
mu_col	int
=	O
0	int
;	O
eval_biffrc	(*(struct(*(struct),*(struct),*(struct),*(struct),struct(struct(*`,int,int),struct(*`,int,int)),int,*(char),long)))->(void)
(	O
&	O
env	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
env	*(struct)
.	O
input	*(char)
)	O
;	O
}	O
}	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
env	*(struct)
.	O
logstr	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
env	*(struct)
.	O
tty	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
env	*(struct)
.	O
errbuf	*(char)
)	O
;	O
}	O
