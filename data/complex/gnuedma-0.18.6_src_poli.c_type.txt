EUint32	long
EDMAPROC	O
edma_over_met	(long,*(char),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(()->(long)))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
PPROC	*(()->(long))
Func	*(()->(long))
)	O
{	O
OBJID	long
r	long
;	O
ESint32	long
indx	long
,	O
pos	long
,	O
i	long
;	O
ESint32	long
Tipo	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_over_met"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
Id1	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_over_met] Invalid "	*(char)
"Method Identifier (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
Func	*(()->(long))
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_over_met] Invalid Overwritter "	*(char)
"function (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
r	long
=	O
_edma_locate_method	(long,*(char),*(char),*(long),*(long))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
NULL	O
,	O
&	O
pos	long
,	O
&	O
indx	long
)	O
;	O
if	O
(	O
r	long
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_over_met] Can't run method '%s'"	*(char)
" on object %d of class '%s'"	*(char)
,	O
Id1	*(char)
,	O
IdObj	long
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
}	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
r	long
]	O
;	O
if	O
(	O
(	O
r	long
==	O
IdObj	long
)	O
&&	O
pos	long
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_over_met] Inheritance cycle detected, running "	*(char)
"method '%s' in object %ld of class '%s'"	*(char)
,	O
Id1	*(char)
,	O
IdObj	long
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
Tipo	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdClass	long
;	O
if	O
(	O
indx	long
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_over_met] Property not found... "	*(char)
"Checking for SIU"	*(char)
)	O
;	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_over_met] Still NOT IMPLEMENTED"	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
Tipo	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Virtual	char
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
Tipo	long
]	O
->	O
nMetVir	long
;	O
i	long
++	O
)	O
if	O
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Ind	long
==	O
indx	long
)	O
break	O
;	O
if	O
(	O
i	long
==	O
gClass	O
[	O
Tipo	long
]	O
->	O
nMetVir	long
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_over_met] Method %s in Class %s "	*(char)
"isn't Virtual"	*(char)
,	O
Id1	*(char)
,	O
gClass	O
[	O
Tipo	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Flag	char
=	O
2	int
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Func	*(()->(long))
=	O
Func	*(()->(long))
;	O
if	O
(	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
==	O
0	int
)	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Obj	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
else	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Obj	long
=	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
;	O
}	O
}	O
else	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_over_met] Method %s in Class %s "	*(char)
"isn't Virtual"	*(char)
,	O
Id1	*(char)
,	O
gClass	O
[	O
Tipo	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_over_met1	(long,*(char),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(()->(long)),*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
,	O
PPROC	*(()->(long))
Func	*(()->(long))
,	O
EPChar	*(char)
OverId	*(char)
)	O
{	O
OBJID	long
r	long
;	O
ESint32	long
indx	long
,	O
pos	long
,	O
i	long
;	O
ESint32	long
Tipo	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
OverObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
NULL	O
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_over_met1"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
Id1	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_over_met1] Invalid "	*(char)
"Target Method Identifier (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
OverId	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_over_met1] Invalid "	*(char)
"Source Method Identifier (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
Func	*(()->(long))
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_over_met] Invalid "	*(char)
"Overwritter function (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
r	long
=	O
_edma_locate_method	(long,*(char),*(char),*(long),*(long))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
NULL	O
,	O
&	O
pos	long
,	O
&	O
indx	long
)	O
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
r	long
]	O
;	O
if	O
(	O
r	long
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_over_met1] Can't run method '%s'"	*(char)
" on object %d of class '%s'"	*(char)
,	O
Id1	*(char)
,	O
IdObj	long
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
}	O
if	O
(	O
(	O
r	long
==	O
IdObj	long
)	O
&&	O
pos	long
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_over_met1] Inheritance cycle detected, running "	*(char)
"method '%s' in object %ld of class '%s'"	*(char)
,	O
Id1	*(char)
,	O
IdObj	long
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
Tipo	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdClass	long
;	O
if	O
(	O
indx	long
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_over_met1] Property not found... "	*(char)
"Checking for SIU"	*(char)
)	O
;	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_over_met1] Still NOT IMPLEMENTED"	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
Tipo	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Virtual	char
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
Tipo	long
]	O
->	O
nMetVir	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Ind	long
==	O
indx	long
)	O
break	O
;	O
}	O
if	O
(	O
i	long
==	O
gClass	O
[	O
Tipo	long
]	O
->	O
nMetVir	long
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"Method %s in Class %s isn't Virtual"	*(char)
,	O
Id1	*(char)
,	O
gClass	O
[	O
Tipo	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Flag	char
=	O
1	int
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
(	O
EPChar	*(char)
)	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Id	long
,	O
OverId	*(char)
,	O
EDMA_MET_NAME_LEN	O
)	O
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Func	*(()->(long))
=	O
Func	*(()->(long))
;	O
if	O
(	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
==	O
0	int
)	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Obj	long
=	O
OverObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
else	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Obj	long
=	O
pObj1	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_over_met3	(long,*(char),*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id2	*(char)
,	O
EPChar	*(char)
Id1	*(char)
)	O
{	O
OBJID	long
r	long
;	O
ESint32	long
indx	long
,	O
pos	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
PPROC	*(()->(long))
Func	*(()->(long))
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_over_met"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
Id2	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_over_met1] Invalid "	*(char)
"Target Method Identifier (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
Id1	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_over_met1] Invalid "	*(char)
"Target Method Identifier (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
r	long
=	O
_edma_locate_method	(long,*(char),*(char),*(long),*(long))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
NULL	O
,	O
&	O
pos	long
,	O
&	O
indx	long
)	O
;	O
if	O
(	O
r	long
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_over_met3] Can't found method '%s'"	*(char)
" on object %d of class '%s'"	*(char)
,	O
Id2	*(char)
,	O
IdObj	long
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
}	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
r	long
]	O
;	O
if	O
(	O
(	O
r	long
==	O
IdObj	long
)	O
&&	O
pos	long
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_over_met3] Inheritance cycle detected, running "	*(char)
"method '%s' in object %ld of class '%s'"	*(char)
,	O
Id1	*(char)
,	O
IdObj	long
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
indx	long
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_over_met3] Method not found... Checking for SIU"	*(char)
)	O
;	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_over_met3] Still NOT IMPLEMENTED"	*(char)
)	O
;	O
}	O
else	O
{	O
Func	*(()->(long))
=	O
(	O
PPROC	*(()->(long))
)	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdClass	long
]	O
->	O
met_func	*(struct(*(*(()->(long)))))
[	O
indx	long
]	O
.	O
Func	*(()->(long))
;	O
edma_over_met1	(long,*(char),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(()->(long)),*(char))->(long)
(	O
IdObj	long
,	O
Id2	*(char)
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
Func	*(()->(long))
,	O
Id1	*(char)
+	O
pos	long
)	O
;	O
}	O
return	O
0	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_restore_met	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
)	O
{	O
OBJID	long
r	long
;	O
ESint32	long
indx	long
,	O
pos	long
,	O
i	long
;	O
ESint32	long
Tipo	long
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_over_met"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
Id1	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_over_met1] Invalid "	*(char)
"Target Method Identifier (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
r	long
=	O
_edma_locate_method	(long,*(char),*(char),*(long),*(long))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
NULL	O
,	O
&	O
pos	long
,	O
&	O
indx	long
)	O
;	O
if	O
(	O
r	long
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_over_met] Can't run method '%s'"	*(char)
" on object %d of class '%s'"	*(char)
,	O
Id1	*(char)
,	O
IdObj	long
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
}	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
r	long
]	O
;	O
if	O
(	O
(	O
r	long
==	O
IdObj	long
)	O
&&	O
pos	long
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_over_met] Inheritance cycle detected, running "	*(char)
"method '%s' in object %ld of class '%s'"	*(char)
,	O
Id1	*(char)
,	O
IdObj	long
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
Tipo	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdClass	long
;	O
if	O
(	O
indx	long
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_over_met] Property not found... "	*(char)
"Checking for SIU"	*(char)
)	O
;	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_over_met] Still NOT IMPLEMENTED"	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
Tipo	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Virtual	char
)	O
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
Tipo	long
]	O
->	O
nMetVir	long
;	O
i	long
++	O
)	O
if	O
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Ind	long
==	O
indx	long
)	O
break	O
;	O
if	O
(	O
i	long
==	O
gClass	O
[	O
Tipo	long
]	O
->	O
nMetVir	long
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"Method %s in Class %s isn't Virtual"	*(char)
,	O
Id1	*(char)
,	O
gClass	O
[	O
Tipo	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Func	*(()->(long))
=	O
(	O
PPROC	*(()->(long))
)	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
Tipo	long
]	O
->	O
met_func	*(struct(*(*(()->(long)))))
[	O
indx	long
]	O
.	O
Func	*(()->(long))
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Obj	long
=	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Flag	char
=	O
0	int
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
i	long
]	O
.	O
Id	long
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
Tipo	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
IdMet	array(char)
,	O
EDMA_MET_NAME_LEN	O
)	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_old_met3	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id	long
,	O
...	O
)	O
{	O
va_list	*(char)
p	*(char)
;	O
ESint32	long
r	long
;	O
va_start	O
(	O
p	*(char)
,	O
Id	long
)	O
;	O
r	long
=	O
edma_met3_pargs	(long,*(char),*(char),long,*(char))->(long)
(	O
IdObj	long
,	O
Id	long
,	O
NULL	O
,	O
0	int
,	O
p	*(char)
)	O
;	O
va_end	O
(	O
p	*(char)
)	O
;	O
return	O
r	long
;	O
}	O
