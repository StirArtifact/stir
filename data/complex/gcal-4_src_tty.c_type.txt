__BEGIN_DECLARATIONS	O
static	O
char	O
*	O
skip_leading_padding_info	(*(char))->(*(char))
__P_	O
(	O
(	O
char	O
*	O
sequence_str	*(char)
)	O
)	O
;	O
static	O
Bool	int
open_termcap	()->(int)
__P_	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
get_ospeed	()->(void)
__P_	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
outchar	(int)->(int)
__P_	O
(	O
(	O
int	O
ch	int
)	O
)	O
;	O
static	O
Bool	int
get_termcap_hls	(*(int),*(int))->(int)
__P_	O
(	O
(	O
Bool	int
*	O
hls1_set	*(int)
,	O
Bool	int
*	O
hls2_set	*(int)
)	O
)	O
;	O
static	O
Bool	int
get_termcap_scr_attrib	(*(int),*(int))->(int)
__P_	O
(	O
(	O
int	O
*	O
rows	*(int)
,	O
int	O
*	O
cols	*(int)
)	O
)	O
;	O
static	O
void	O
get_hl_seq	(*(char),*(int),*(int))->(void)
__P_	O
(	O
(	O
const	O
char	O
*	O
sequence_str	*(char)
,	O
Bool	int
*	O
hls1_set	*(int)
,	O
Bool	int
*	O
hls2_set	*(int)
)	O
)	O
;	O
__END_DECLARATIONS	O
static	O
char	O
tc_buf	array(char)
[	O
TC_BUFLEN	int
]	O
;	O
static	O
Bool	int
tc_no_error	int
=	O
TRUE	O
;	O
static	O
FILE	struct
*	O
fp_outchar	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
(	O
FILE	struct
*	O
)	O
NULL	O
;	O
static	O
Bool	int
is_padding	int
=	O
FALSE	O
;	O
static	O
Bool	int
tty_am	int
=	O
TRUE	O
;	O
static	O
Bool	int
tty_xn	int
=	O
FALSE	O
;	O
void	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
text_line	*(char)
)	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
text_line	*(char)
;	O
{	O
if	O
(	O
is_tty	int
&&	O
is_tty1	int
&&	O
is_tty2	int
)	O
{	O
register	O
int	O
hls_pos	int
=	O
SPECIAL_VALUE	O
;	O
register	O
int	O
hls1_pos	int
=	O
SPECIAL_VALUE	O
;	O
register	O
int	O
hls2_pos	int
=	O
SPECIAL_VALUE	O
;	O
register	O
int	O
hls_chars	int
=	O
0	int
;	O
register	O
int	O
i	int
=	O
0	int
;	O
register	O
int	O
nl	int
;	O
register	O
int	O
j	int
;	O
register	O
int	O
k	int
;	O
register	O
int	O
final_nl	int
=	O
0	int
;	O
static	O
int	O
lines_printed	int
=	O
0	int
;	O
auto	O
char	O
*	O
ptr_1hls	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
auto	O
char	O
*	O
ptr_2hls	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
auto	O
Bool	int
hls_start	int
;	O
auto	O
Bool	int
print_hls	int
=	O
(	O
Bool	int
)	O
(	O
is_tty	int
&&	O
highlight_flag	int
&&	O
!	O
emu_hls	int
)	O
;	O
auto	O
Bool	int
nl_found	int
=	O
FALSE	O
;	O
auto	O
Bool	int
buf_highlight_flag	int
=	O
highlight_flag	int
;	O
fp_outchar	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
LOOP	O
{	O
if	O
(	O
final_nl	int
!=	O
SPECIAL_VALUE	O
)	O
final_nl	int
=	O
0	int
;	O
hls_chars	int
=	O
nl	int
=	O
j	int
=	O
0	int
;	O
if	O
(	O
highlight_flag	int
&&	O
!	O
emu_hls	int
)	O
{	O
hls_pos	int
=	O
hls1_pos	int
=	O
hls2_pos	int
=	O
SPECIAL_VALUE	O
;	O
if	O
(	O
*	O
(	O
text_line	*(char)
+	O
i	int
)	O
)	O
{	O
if	O
(	O
tty_cols	int
!=	O
SPECIAL_VALUE	O
)	O
{	O
ptr_1hls	*(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
text_line	*(char)
+	O
i	int
,	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
if	O
(	O
ptr_1hls	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
hls1_pos	int
=	O
i	int
+	O
(	O
int	O
)	O
(	O
ptr_1hls	*(char)
-	O
(	O
text_line	*(char)
+	O
i	int
)	O
)	O
;	O
ptr_2hls	*(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
text_line	*(char)
+	O
i	int
,	O
ehls2s	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
if	O
(	O
ptr_2hls	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
hls2_pos	int
=	O
i	int
+	O
(	O
int	O
)	O
(	O
ptr_2hls	*(char)
-	O
(	O
text_line	*(char)
+	O
i	int
)	O
)	O
;	O
}	O
if	O
(	O
(	O
hls1_pos	int
!=	O
SPECIAL_VALUE	O
)	O
&&	O
(	O
hls2_pos	int
!=	O
SPECIAL_VALUE	O
)	O
)	O
{	O
if	O
(	O
hls1_pos	int
>	O
hls2_pos	int
)	O
hls_pos	int
=	O
hls2_pos	int
;	O
else	O
hls_pos	int
=	O
hls1_pos	int
;	O
}	O
else	O
if	O
(	O
hls1_pos	int
!=	O
SPECIAL_VALUE	O
)	O
hls_pos	int
=	O
hls1_pos	int
;	O
else	O
if	O
(	O
hls2_pos	int
!=	O
SPECIAL_VALUE	O
)	O
hls_pos	int
=	O
hls2_pos	int
;	O
}	O
if	O
(	O
hls_pos	int
==	O
SPECIAL_VALUE	O
)	O
highlight_flag	int
=	O
FALSE	O
;	O
}	O
if	O
(	O
(	O
strchr	(*(char),int)->(*(char))
(	O
text_line	*(char)
+	O
i	int
,	O
'\n'	O
)	O
==	O
(	O
char	O
*	O
)	O
NULL	O
||	O
!	O
pager_flag	int
||	O
(	O
pager_flag	int
&&	O
(	O
ext_pager	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
)	O
&&	O
(	O
hls_pos	int
==	O
SPECIAL_VALUE	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
text_line	*(char)
+	O
i	int
)	O
;	O
i	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
text_line	*(char)
)	O
;	O
}	O
else	O
{	O
hls_start	int
=	O
TRUE	O
;	O
while	O
(	O
*	O
(	O
text_line	*(char)
+	O
i	int
)	O
)	O
{	O
if	O
(	O
*	O
(	O
text_line	*(char)
+	O
i	int
)	O
==	O
'\n'	O
)	O
{	O
i	int
++	O
;	O
if	O
(	O
j	int
)	O
nl	int
++	O
;	O
nl_found	int
=	O
TRUE	O
;	O
if	O
(	O
final_nl	int
!=	O
SPECIAL_VALUE	O
)	O
final_nl	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
highlight_flag	int
&&	O
!	O
emu_hls	int
&&	O
(	O
i	int
==	O
hls_pos	int
)	O
)	O
{	O
if	O
(	O
hls_pos	int
==	O
hls1_pos	int
)	O
{	O
if	O
(	O
hls_start	int
)	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
(	O
char	O
*	O
)	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
,	O
1	int
,	O
outchar	(int)->(int)
)	O
;	O
hls_chars	int
+=	O
ehls1s	struct(*(char),int)
.	O
len	int
;	O
i	int
+=	O
ehls1s	struct(*(char),int)
.	O
len	int
;	O
if	O
(	O
tty_cols	int
!=	O
SPECIAL_VALUE	O
)	O
ptr_1hls	*(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
text_line	*(char)
+	O
i	int
,	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
if	O
(	O
ptr_1hls	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
hls_pos	int
=	O
hls1_pos	int
=	O
i	int
+	O
(	O
int	O
)	O
(	O
ptr_1hls	*(char)
-	O
(	O
text_line	*(char)
+	O
i	int
)	O
)	O
;	O
else	O
hls_pos	int
=	O
hls2_pos	int
;	O
hls_start	int
=	O
FALSE	O
;	O
}	O
else	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
(	O
char	O
*	O
)	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
,	O
1	int
,	O
outchar	(int)->(int)
)	O
;	O
hls_chars	int
+=	O
ehls1e	struct(*(char),int)
.	O
len	int
;	O
i	int
+=	O
ehls1e	struct(*(char),int)
.	O
len	int
;	O
if	O
(	O
tty_cols	int
!=	O
SPECIAL_VALUE	O
)	O
ptr_1hls	*(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
text_line	*(char)
+	O
i	int
,	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
if	O
(	O
ptr_1hls	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
hls_pos	int
=	O
hls1_pos	int
=	O
i	int
+	O
(	O
int	O
)	O
(	O
ptr_1hls	*(char)
-	O
(	O
text_line	*(char)
+	O
i	int
)	O
)	O
;	O
else	O
hls_pos	int
=	O
hls2_pos	int
;	O
hls_start	int
=	O
TRUE	O
;	O
}	O
if	O
(	O
*	O
(	O
text_line	*(char)
+	O
i	int
)	O
)	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
*	O
(	O
text_line	*(char)
+	O
i	int
)	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
break	O
;	O
}	O
else	O
if	O
(	O
hls_pos	int
==	O
hls2_pos	int
)	O
{	O
if	O
(	O
hls_start	int
)	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
(	O
char	O
*	O
)	O
ehls2s	struct(*(char),int)
.	O
seq	*(char)
,	O
1	int
,	O
outchar	(int)->(int)
)	O
;	O
hls_chars	int
+=	O
ehls2s	struct(*(char),int)
.	O
len	int
;	O
i	int
+=	O
ehls2s	struct(*(char),int)
.	O
len	int
;	O
if	O
(	O
tty_cols	int
!=	O
SPECIAL_VALUE	O
)	O
ptr_2hls	*(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
text_line	*(char)
+	O
i	int
,	O
ehls2e	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
if	O
(	O
ptr_2hls	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
hls_pos	int
=	O
hls2_pos	int
=	O
i	int
+	O
(	O
int	O
)	O
(	O
ptr_2hls	*(char)
-	O
(	O
text_line	*(char)
+	O
i	int
)	O
)	O
;	O
else	O
hls_pos	int
=	O
hls1_pos	int
;	O
hls_start	int
=	O
FALSE	O
;	O
}	O
else	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
(	O
char	O
*	O
)	O
ehls2e	struct(*(char),int)
.	O
seq	*(char)
,	O
1	int
,	O
outchar	(int)->(int)
)	O
;	O
hls_chars	int
+=	O
ehls2e	struct(*(char),int)
.	O
len	int
;	O
i	int
+=	O
ehls2e	struct(*(char),int)
.	O
len	int
;	O
if	O
(	O
tty_cols	int
!=	O
SPECIAL_VALUE	O
)	O
ptr_2hls	*(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
text_line	*(char)
+	O
i	int
,	O
ehls2s	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
if	O
(	O
ptr_2hls	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
hls_pos	int
=	O
hls2_pos	int
=	O
i	int
+	O
(	O
int	O
)	O
(	O
ptr_2hls	*(char)
-	O
(	O
text_line	*(char)
+	O
i	int
)	O
)	O
;	O
else	O
hls_pos	int
=	O
hls1_pos	int
;	O
hls_start	int
=	O
TRUE	O
;	O
}	O
if	O
(	O
*	O
(	O
text_line	*(char)
+	O
i	int
)	O
)	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
*	O
(	O
text_line	*(char)
+	O
i	int
)	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
break	O
;	O
}	O
}	O
else	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
*	O
(	O
text_line	*(char)
+	O
i	int
)	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
j	int
++	O
;	O
i	int
++	O
;	O
}	O
S_NEWLINE	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
pager_flag	int
&&	O
(	O
ext_pager	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
if	O
(	O
!	O
tty_am	int
)	O
j	int
=	O
0	int
;	O
else	O
{	O
k	int
=	O
(	O
(	O
nl_found	int
)	O
?	O
j	int
:	O
i	int
)	O
-	O
nl	int
-	O
hls_chars	int
;	O
j	int
=	O
k	int
/	O
tty_cols	int
;	O
if	O
(	O
j	int
&&	O
tty_xn	int
&&	O
!	O
(	O
k	int
%	O
tty_cols	int
)	O
)	O
j	int
--	O
;	O
}	O
if	O
(	O
lines_printed	int
+	O
j	int
>=	O
tty_rows	int
-	O
1	int
)	O
{	O
if	O
(	O
print_hls	int
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
(	O
char	O
*	O
)	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
,	O
1	int
,	O
outchar	(int)->(int)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: <Return> for more, <%s> to quit..."	*(char)
)	O
,	O
prgr_name	*(char)
,	O
PAGER_QUIT	*(char)
)	O
;	O
if	O
(	O
print_hls	int
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
(	O
char	O
*	O
)	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
,	O
1	int
,	O
outchar	(int)->(int)
)	O
;	O
k	int
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
tolower	(int)->(int)
(	O
k	int
)	O
==	O
(	O
int	O
)	O
*	O
PAGER_QUIT	*(char)
)	O
{	O
while	O
(	O
(	O
(	O
k	int
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
'\n'	O
)	O
&&	O
(	O
k	int
!=	O
EOF	O
)	O
)	O
;	O
k	int
=	O
EOF	O
;	O
}	O
else	O
if	O
(	O
k	int
!=	O
'\n'	O
)	O
while	O
(	O
(	O
(	O
k	int
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
'\n'	O
)	O
&&	O
(	O
tolower	(int)->(int)
(	O
k	int
)	O
!=	O
(	O
int	O
)	O
*	O
PAGER_QUIT	*(char)
)	O
&&	O
(	O
k	int
!=	O
EOF	O
)	O
)	O
;	O
if	O
(	O
tolower	(int)->(int)
(	O
k	int
)	O
==	O
(	O
int	O
)	O
*	O
PAGER_QUIT	*(char)
)	O
{	O
while	O
(	O
(	O
(	O
k	int
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
'\n'	O
)	O
&&	O
(	O
k	int
!=	O
EOF	O
)	O
)	O
;	O
k	int
=	O
EOF	O
;	O
}	O
if	O
(	O
k	int
==	O
EOF	O
)	O
my_exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
lines_printed	int
=	O
0	int
;	O
}	O
else	O
lines_printed	int
+=	O
(	O
j	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
*	O
(	O
text_line	*(char)
+	O
i	int
)	O
)	O
{	O
if	O
(	O
final_nl	int
&&	O
(	O
final_nl	int
!=	O
SPECIAL_VALUE	O
)	O
)	O
{	O
final_nl	int
=	O
SPECIAL_VALUE	O
;	O
i	int
--	O
;	O
}	O
else	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
*	O
(	O
text_line	*(char)
+	O
i	int
)	O
)	O
break	O
;	O
}	O
highlight_flag	int
=	O
buf_highlight_flag	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
(	O
FILE	struct
*	O
)	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
&&	O
(	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
text_line	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
text_line	*(char)
)	O
;	O
}	O
*	O
text_line	*(char)
=	O
'\0'	O
;	O
}	O
void	O
get_tty_hls	(*(char))->(void)
(	O
sequence_str	*(char)
)	O
const	O
char	O
*	O
sequence_str	*(char)
;	O
{	O
auto	O
char	O
*	O
ptr_env	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_GCALANSI	*(char)
)	O
;	O
auto	O
Bool	int
check_again	int
=	O
FALSE	O
;	O
auto	O
Bool	int
hls1_set	*(int)
=	O
FALSE	O
;	O
auto	O
Bool	int
hls2_set	*(int)
=	O
FALSE	O
;	O
if	O
(	O
!	O
highlight_flag	int
)	O
{	O
emu_hls	int
=	O
TRUE	O
;	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
=	O
NO_HLS	*(char)
;	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
=	O
NO_HLS	*(char)
;	O
ehls2s	struct(*(char),int)
.	O
seq	*(char)
=	O
NO_HLS	*(char)
;	O
ehls2e	struct(*(char),int)
.	O
seq	*(char)
=	O
NO_HLS	*(char)
;	O
}	O
else	O
{	O
if	O
(	O
!	O
is_tty	int
&&	O
!	O
emu_hls	int
&&	O
highlight_flag	int
)	O
emu_hls	int
=	O
TRUE	O
;	O
if	O
(	O
sequence_str	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
get_hl_seq	(*(char),*(int),*(int))->(void)
(	O
sequence_str	*(char)
,	O
&	O
hls1_set	*(int)
,	O
&	O
hls2_set	*(int)
)	O
;	O
if	O
(	O
(	O
hls1_set	*(int)
&&	O
(	O
ehls1s	struct(*(char),int)
.	O
len	int
>	O
1	int
||	O
ehls1e	struct(*(char),int)
.	O
len	int
>	O
1	int
)	O
)	O
||	O
(	O
hls2_set	*(int)
&&	O
(	O
ehls2s	struct(*(char),int)
.	O
len	int
>	O
1	int
||	O
ehls2e	struct(*(char),int)
.	O
len	int
>	O
1	int
)	O
)	O
)	O
check_again	int
=	O
TRUE	O
;	O
}	O
if	O
(	O
!	O
hls1_set	*(int)
||	O
check_again	int
||	O
!	O
hls2_set	*(int)
)	O
{	O
if	O
(	O
!	O
emu_hls	int
)	O
{	O
tc_no_error	int
=	O
open_termcap	()->(int)
(	O
)	O
;	O
if	O
(	O
tc_no_error	int
)	O
get_termcap_hls	(*(int),*(int))->(int)
(	O
&	O
hls1_set	*(int)
,	O
&	O
hls2_set	*(int)
)	O
;	O
if	O
(	O
check_again	int
)	O
{	O
get_hl_seq	(*(char),*(int),*(int))->(void)
(	O
sequence_str	*(char)
,	O
&	O
hls1_set	*(int)
,	O
&	O
hls2_set	*(int)
)	O
;	O
if	O
(	O
tc_no_error	int
)	O
get_termcap_hls	(*(int),*(int))->(int)
(	O
&	O
hls1_set	*(int)
,	O
&	O
hls2_set	*(int)
)	O
;	O
}	O
if	O
(	O
ptr_env	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
!	O
hls1_set	*(int)
)	O
{	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
=	O
HLS1S	*(char)
;	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
=	O
HLS1E	*(char)
;	O
}	O
if	O
(	O
!	O
hls2_set	*(int)
)	O
{	O
ehls2s	struct(*(char),int)
.	O
seq	*(char)
=	O
HLS2S	*(char)
;	O
ehls2e	struct(*(char),int)
.	O
seq	*(char)
=	O
HLS2E	*(char)
;	O
}	O
}	O
else	O
if	O
(	O
!	O
hls1_set	*(int)
||	O
!	O
hls2_set	*(int)
)	O
{	O
emu_hls	int
=	O
TRUE	O
;	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
=	O
BUF_HLS1S	*(char)
;	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
=	O
BUF_HLS1E	*(char)
;	O
ehls2s	struct(*(char),int)
.	O
seq	*(char)
=	O
BUF_HLS2S	*(char)
;	O
ehls2e	struct(*(char),int)
.	O
seq	*(char)
=	O
BUF_HLS2E	*(char)
;	O
}	O
}	O
else	O
{	O
if	O
(	O
emu_hls	int
)	O
{	O
if	O
(	O
!	O
hls1_set	*(int)
)	O
{	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
=	O
BUF_HLS1S	*(char)
;	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
=	O
BUF_HLS1E	*(char)
;	O
}	O
if	O
(	O
!	O
hls2_set	*(int)
)	O
{	O
ehls2s	struct(*(char),int)
.	O
seq	*(char)
=	O
BUF_HLS2S	*(char)
;	O
ehls2e	struct(*(char),int)
.	O
seq	*(char)
=	O
BUF_HLS2E	*(char)
;	O
}	O
}	O
else	O
{	O
if	O
(	O
ptr_env	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
!	O
hls1_set	*(int)
)	O
{	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
=	O
HLS1S	*(char)
;	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
=	O
HLS1E	*(char)
;	O
}	O
if	O
(	O
!	O
hls2_set	*(int)
)	O
{	O
ehls2s	struct(*(char),int)
.	O
seq	*(char)
=	O
HLS2S	*(char)
;	O
ehls2e	struct(*(char),int)
.	O
seq	*(char)
=	O
HLS2E	*(char)
;	O
}	O
}	O
else	O
if	O
(	O
!	O
hls1_set	*(int)
||	O
!	O
hls2_set	*(int)
)	O
{	O
emu_hls	int
=	O
TRUE	O
;	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
=	O
BUF_HLS1S	*(char)
;	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
=	O
BUF_HLS1E	*(char)
;	O
ehls2s	struct(*(char),int)
.	O
seq	*(char)
=	O
BUF_HLS2S	*(char)
;	O
ehls2e	struct(*(char),int)
.	O
seq	*(char)
=	O
BUF_HLS2E	*(char)
;	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
is_padding	int
&&	O
(	O
!	O
is_tty	int
||	O
!	O
is_tty1	int
||	O
!	O
is_tty2	int
)	O
)	O
{	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
skip_leading_padding_info	(*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
skip_leading_padding_info	(*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
ehls2s	struct(*(char),int)
.	O
seq	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
skip_leading_padding_info	(*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
ehls2s	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
ehls2e	struct(*(char),int)
.	O
seq	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
skip_leading_padding_info	(*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
ehls2e	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
}	O
ehls1s	struct(*(char),int)
.	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
ehls1e	struct(*(char),int)
.	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
ehls2s	struct(*(char),int)
.	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ehls2s	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
ehls2e	struct(*(char),int)
.	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ehls2e	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
}	O
void	O
get_tty_scr_size	(*(int),*(int))->(void)
(	O
rows	*(int)
,	O
cols	*(int)
)	O
int	O
*	O
rows	*(int)
;	O
int	O
*	O
cols	*(int)
;	O
{	O
register	O
int	O
li	int
=	O
0	int
;	O
register	O
int	O
co	int
=	O
0	int
;	O
auto	O
char	O
*	O
ptr_env	*(char)
;	O
ptr_env	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_LI	*(char)
)	O
;	O
if	O
(	O
ptr_env	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
*	O
ptr_env	*(char)
)	O
{	O
li	int
=	O
my_atoi	(*(char))->(int)
(	O
ptr_env	*(char)
)	O
;	O
ptr_env	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_CO	*(char)
)	O
;	O
if	O
(	O
ptr_env	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
*	O
ptr_env	*(char)
)	O
co	int
=	O
my_atoi	(*(char))->(int)
(	O
ptr_env	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
li	int
>	O
0	int
)	O
&&	O
(	O
co	int
>	O
0	int
)	O
)	O
{	O
*	O
rows	*(int)
=	O
li	int
;	O
*	O
cols	*(int)
=	O
co	int
;	O
}	O
else	O
{	O
ptr_env	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_LI2	*(char)
)	O
;	O
if	O
(	O
ptr_env	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
*	O
ptr_env	*(char)
)	O
{	O
li	int
=	O
my_atoi	(*(char))->(int)
(	O
ptr_env	*(char)
)	O
;	O
ptr_env	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_CO2	*(char)
)	O
;	O
if	O
(	O
ptr_env	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
*	O
ptr_env	*(char)
)	O
co	int
=	O
my_atoi	(*(char))->(int)
(	O
ptr_env	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
li	int
>	O
0	int
)	O
&&	O
(	O
co	int
>	O
0	int
)	O
)	O
{	O
*	O
rows	*(int)
=	O
li	int
;	O
*	O
cols	*(int)
=	O
co	int
;	O
}	O
else	O
{	O
auto	O
struct	O
winsize	struct(short,short,short,short)
wsz	struct(short,short,short,short)
;	O
if	O
(	O
!	O
ioctl	(int,long)->(int)
(	O
1	int
,	O
TIOCGWINSZ	int
,	O
&	O
wsz	struct(short,short,short,short)
)	O
&&	O
(	O
wsz	struct(short,short,short,short)
.	O
ws_row	short
>	O
0	int
)	O
)	O
{	O
*	O
rows	*(int)
=	O
wsz	struct(short,short,short,short)
.	O
ws_row	short
;	O
if	O
(	O
!	O
ioctl	(int,long)->(int)
(	O
1	int
,	O
TIOCGWINSZ	int
,	O
&	O
wsz	struct(short,short,short,short)
)	O
&&	O
(	O
wsz	struct(short,short,short,short)
.	O
ws_col	short
>	O
0	int
)	O
)	O
*	O
cols	*(int)
=	O
wsz	struct(short,short,short,short)
.	O
ws_col	short
;	O
else	O
*	O
rows	*(int)
=	O
SPECIAL_VALUE	O
;	O
}	O
if	O
(	O
(	O
*	O
rows	*(int)
==	O
SPECIAL_VALUE	O
)	O
&&	O
(	O
*	O
cols	*(int)
==	O
SPECIAL_VALUE	O
)	O
)	O
{	O
tc_no_error	int
=	O
open_termcap	()->(int)
(	O
)	O
;	O
if	O
(	O
tc_no_error	int
)	O
{	O
if	O
(	O
!	O
get_termcap_scr_attrib	(*(int),*(int))->(int)
(	O
rows	*(int)
,	O
cols	*(int)
)	O
)	O
{	O
*	O
rows	*(int)
=	O
SCREEN_ROWS	int
;	O
*	O
cols	*(int)
=	O
SCREEN_COLS	int
;	O
}	O
}	O
else	O
{	O
*	O
rows	*(int)
=	O
SCREEN_ROWS	int
;	O
*	O
cols	*(int)
=	O
SCREEN_COLS	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
*	O
rows	*(int)
>	O
1	int
)	O
(	O
*	O
rows	*(int)
)	O
--	O
;	O
}	O
static	O
char	O
*	O
skip_leading_padding_info	(*(char))->(*(char))
(	O
sequence_str	*(char)
)	O
char	O
*	O
sequence_str	*(char)
;	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
sequence_str	*(char)
)	O
)	O
{	O
is_padding	int
=	O
TRUE	O
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
*	O
sequence_str	*(char)
)	O
)	O
sequence_str	*(char)
++	O
;	O
if	O
(	O
*	O
sequence_str	*(char)
==	O
'.'	O
)	O
{	O
sequence_str	*(char)
++	O
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
sequence_str	*(char)
)	O
)	O
sequence_str	*(char)
++	O
;	O
}	O
if	O
(	O
*	O
sequence_str	*(char)
==	O
'*'	O
)	O
sequence_str	*(char)
++	O
;	O
}	O
return	O
(	O
sequence_str	*(char)
)	O
;	O
}	O
static	O
Bool	int
open_termcap	()->(int)
(	O
)	O
{	O
auto	O
char	O
*	O
term	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_TERM	*(char)
)	O
;	O
static	O
Bool	int
func_accessed	int
=	O
FALSE	O
;	O
auto	O
Bool	int
is_error	int
=	O
FALSE	O
;	O
if	O
(	O
!	O
func_accessed	int
)	O
{	O
func_accessed	int
=	O
TRUE	O
;	O
if	O
(	O
term	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
warning_level	int
>=	O
0	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"environment variable `%s' not found"	*(char)
)	O
,	O
ENV_VAR_TERM	*(char)
)	O
;	O
is_error	int
=	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
!	O
*	O
term	*(char)
)	O
{	O
if	O
(	O
warning_level	int
>=	O
0	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"environment variable `%s' not set"	*(char)
)	O
,	O
ENV_VAR_TERM	*(char)
)	O
;	O
is_error	int
=	O
TRUE	O
;	O
}	O
else	O
{	O
switch	O
(	O
tgetent	(*(char),*(char))->(int)
(	O
tc_buf	array(char)
,	O
term	*(char)
)	O
)	O
{	O
case	O
-	O
1	int
:	O
if	O
(	O
warning_level	int
>=	O
0	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
s1	*(char)
,	O
_	O
(	O
"`termcap' file not found"	*(char)
)	O
)	O
;	O
is_error	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
0	int
:	O
if	O
(	O
warning_level	int
>=	O
0	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"unknown terminal type defined in `%s'"	*(char)
)	O
,	O
ENV_VAR_TERM	*(char)
)	O
;	O
is_error	int
=	O
TRUE	O
;	O
break	O
;	O
default	O
:	O
;	O
}	O
}	O
if	O
(	O
is_error	int
&&	O
(	O
warning_level	int
>=	O
0	int
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\n%s: warning, %s.\n\n"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
s1	*(char)
)	O
;	O
return	O
(	O
(	O
Bool	int
)	O
!	O
is_error	int
)	O
;	O
}	O
return	O
(	O
tc_no_error	int
)	O
;	O
}	O
static	O
void	O
get_ospeed	()->(void)
(	O
)	O
{	O
auto	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
buf	*(char)
;	O
tcgetattr	(int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
1	int
,	O
&	O
buf	*(char)
)	O
;	O
switch	O
(	O
cfgetospeed	(*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
&	O
buf	*(char)
)	O
)	O
{	O
case	O
B0	int
:	O
ospeed	short
=	O
0	int
;	O
break	O
;	O
case	O
B50	int
:	O
ospeed	short
=	O
1	int
;	O
break	O
;	O
case	O
B75	int
:	O
ospeed	short
=	O
2	int
;	O
break	O
;	O
case	O
B110	int
:	O
ospeed	short
=	O
3	int
;	O
break	O
;	O
case	O
B134	int
:	O
ospeed	short
=	O
4	int
;	O
break	O
;	O
case	O
B150	int
:	O
ospeed	short
=	O
5	int
;	O
break	O
;	O
case	O
B200	int
:	O
ospeed	short
=	O
6	int
;	O
break	O
;	O
case	O
B300	int
:	O
ospeed	short
=	O
7	int
;	O
break	O
;	O
case	O
B600	int
:	O
ospeed	short
=	O
8	int
;	O
break	O
;	O
case	O
B1200	int
:	O
ospeed	short
=	O
9	int
;	O
break	O
;	O
case	O
B1800	int
:	O
ospeed	short
=	O
10	int
;	O
break	O
;	O
case	O
B2400	int
:	O
ospeed	short
=	O
11	int
;	O
break	O
;	O
case	O
B4800	int
:	O
ospeed	short
=	O
12	int
;	O
break	O
;	O
case	O
B9600	int
:	O
ospeed	short
=	O
13	int
;	O
break	O
;	O
case	O
EXTA	O
:	O
ospeed	short
=	O
14	int
;	O
break	O
;	O
case	O
EXTB	O
:	O
ospeed	short
=	O
15	int
;	O
break	O
;	O
case	O
B57600	int
:	O
ospeed	short
=	O
16	int
;	O
break	O
;	O
case	O
B115200	int
:	O
ospeed	short
=	O
17	int
;	O
break	O
;	O
default	O
:	O
;	O
}	O
}	O
static	O
int	O
outchar	(int)->(int)
(	O
ch	int
)	O
int	O
ch	int
;	O
{	O
return	O
(	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
ch	int
,	O
fp_outchar	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
;	O
}	O
static	O
Bool	int
get_termcap_hls	(*(int),*(int))->(int)
(	O
hls1_set	*(int)
,	O
hls2_set	*(int)
)	O
Bool	int
*	O
hls1_set	*(int)
;	O
Bool	int
*	O
hls2_set	*(int)
;	O
{	O
register	O
int	O
i	int
=	O
(	O
*	O
hls1_set	*(int)
)	O
?	O
2	int
:	O
0	int
;	O
register	O
int	O
j	int
=	O
(	O
*	O
hls2_set	*(int)
)	O
?	O
TC_MC_MAX	int
-	O
2	int
:	O
TC_MC_MAX	int
;	O
static	O
char	O
*	O
tc	array(*(char))
[	O
TC_MC_MAX	int
]	O
=	O
{	O
TC_MC_HL1S	*(char)
,	O
TC_MC_HL1E	*(char)
,	O
TC_MC_HL2S	*(char)
,	O
TC_MC_HL2E	*(char)
}	O
;	O
static	O
char	O
*	O
padding	*(char)
;	O
static	O
char	O
*	O
area	*(char)
;	O
auto	O
char	O
*	O
ptr_char	*(char)
;	O
auto	O
char	O
*	O
ptr_area	*(char)
;	O
static	O
Bool	int
func_accessed	int
=	O
FALSE	O
;	O
auto	O
Bool	int
is_error	int
=	O
FALSE	O
;	O
if	O
(	O
!	O
func_accessed	int
)	O
{	O
func_accessed	int
=	O
TRUE	O
;	O
area	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
TC_BUFLEN	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"area"	*(char)
,	O
0	int
)	O
;	O
ptr_area	*(char)
=	O
area	*(char)
;	O
padding	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"pc"	*(char)
,	O
&	O
ptr_area	*(char)
)	O
;	O
PC	char
=	O
(	O
padding	*(char)
)	O
?	O
*	O
padding	*(char)
:	O
'\0'	O
;	O
get_ospeed	()->(void)
(	O
)	O
;	O
for	O
(	O
;	O
(	O
i	int
<	O
j	int
)	O
&&	O
!	O
is_error	int
;	O
i	int
++	O
)	O
{	O
ptr_char	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
tc	array(*(char))
[	O
i	int
]	O
,	O
&	O
ptr_area	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
switch	O
(	O
i	int
)	O
{	O
case	O
0	int
:	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
=	O
ptr_char	*(char)
;	O
break	O
;	O
case	O
1	int
:	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
=	O
ptr_char	*(char)
;	O
*	O
hls1_set	*(int)
=	O
TRUE	O
;	O
break	O
;	O
case	O
2	int
:	O
ehls2s	struct(*(char),int)
.	O
seq	*(char)
=	O
ptr_char	*(char)
;	O
break	O
;	O
case	O
3	int
:	O
ehls2e	struct(*(char),int)
.	O
seq	*(char)
=	O
ptr_char	*(char)
;	O
*	O
hls2_set	*(int)
=	O
TRUE	O
;	O
break	O
;	O
default	O
:	O
is_error	int
=	O
TRUE	O
;	O
}	O
}	O
else	O
is_error	int
=	O
TRUE	O
;	O
}	O
}	O
return	O
(	O
(	O
Bool	int
)	O
!	O
is_error	int
)	O
;	O
}	O
static	O
Bool	int
get_termcap_scr_attrib	(*(int),*(int))->(int)
(	O
rows	*(int)
,	O
cols	*(int)
)	O
int	O
*	O
rows	*(int)
;	O
int	O
*	O
cols	*(int)
;	O
{	O
static	O
Bool	int
func_accessed	int
=	O
FALSE	O
;	O
if	O
(	O
!	O
func_accessed	int
)	O
{	O
func_accessed	int
=	O
TRUE	O
;	O
if	O
(	O
tgetnum	(*(char))->(int)
(	O
"li"	*(char)
)	O
==	O
SPECIAL_VALUE	O
||	O
tgetnum	(*(char))->(int)
(	O
"co"	*(char)
)	O
==	O
SPECIAL_VALUE	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
else	O
{	O
*	O
rows	*(int)
=	O
tgetnum	(*(char))->(int)
(	O
"li"	*(char)
)	O
;	O
*	O
cols	*(int)
=	O
tgetnum	(*(char))->(int)
(	O
"co"	*(char)
)	O
;	O
tty_am	int
=	O
tgetflag	(*(char))->(int)
(	O
"am"	*(char)
)	O
;	O
tty_xn	int
=	O
tgetflag	(*(char))->(int)
(	O
"xn"	*(char)
)	O
;	O
}	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
static	O
void	O
get_hl_seq	(*(char),*(int),*(int))->(void)
(	O
sequence_str	*(char)
,	O
hls1_set	*(int)
,	O
hls2_set	*(int)
)	O
const	O
char	O
*	O
sequence_str	*(char)
;	O
Bool	int
*	O
hls1_set	*(int)
;	O
Bool	int
*	O
hls2_set	*(int)
;	O
{	O
register	O
int	O
i	int
=	O
0	int
;	O
register	O
int	O
n	long
;	O
register	O
int	O
j	int
;	O
register	O
int	O
k	int
;	O
register	O
int	O
diff	int
;	O
register	O
int	O
seq_no	int
=	O
0	int
;	O
static	O
char	O
*	O
buf_hls	array(*(char))
[	O
TC_MC_MAX	int
]	O
;	O
auto	O
const	O
char	O
*	O
ptr_char	*(char)
=	O
sequence_str	*(char)
;	O
auto	O
char	O
*	O
ptr_err	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
char	O
str4	array(char)
[	O
5	int
]	O
;	O
auto	O
Bool	int
is_error	int
=	O
FALSE	O
;	O
auto	O
Bool	int
is_hex	int
;	O
auto	O
Bool	int
is_oct	int
;	O
auto	O
Bool	int
is_esc	int
;	O
(	O
*	O
hls1_set	*(int)
)	O
=	O
(	O
*	O
hls2_set	*(int)
)	O
=	O
FALSE	O
;	O
while	O
(	O
*	O
ptr_char	*(char)
&&	O
!	O
is_error	int
&&	O
(	O
seq_no	int
<	O
TC_MC_MAX	int
)	O
)	O
{	O
while	O
(	O
*	O
ptr_char	*(char)
&&	O
(	O
*	O
ptr_char	*(char)
!=	O
*	O
SEP	*(char)
)	O
)	O
{	O
if	O
(	O
(	O
Uint	int
)	O
i	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
s1	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
ptr_char	*(char)
++	O
;	O
}	O
if	O
(	O
(	O
Uint	int
)	O
i	int
==	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
i	int
)	O
{	O
s1	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
i	int
=	O
n	long
=	O
0	int
;	O
while	O
(	O
s1	*(char)
[	O
i	int
+	O
n	long
]	O
)	O
{	O
is_hex	int
=	O
is_oct	int
=	O
is_esc	int
=	O
FALSE	O
;	O
diff	int
=	O
0	int
;	O
if	O
(	O
s1	*(char)
[	O
i	int
+	O
n	long
]	O
==	O
'\\'	O
)	O
{	O
is_esc	int
=	O
(	O
Bool	int
)	O
(	O
tolower	(int)->(int)
(	O
s1	*(char)
[	O
i	int
+	O
n	long
+	O
1	int
]	O
)	O
==	O
'e'	O
)	O
;	O
is_hex	int
=	O
(	O
Bool	int
)	O
(	O
tolower	(int)->(int)
(	O
s1	*(char)
[	O
i	int
+	O
n	long
+	O
1	int
]	O
)	O
==	O
'x'	O
)	O
;	O
is_oct	int
=	O
(	O
Bool	int
)	O
isdigit	(int)->(int)
(	O
s1	*(char)
[	O
i	int
+	O
n	long
+	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
is_esc	int
)	O
{	O
s1	*(char)
[	O
i	int
]	O
=	O
'\033'	O
;	O
n	long
++	O
;	O
}	O
else	O
if	O
(	O
is_hex	int
||	O
is_oct	int
)	O
{	O
k	int
=	O
0	int
;	O
if	O
(	O
is_hex	int
)	O
{	O
str4	array(char)
[	O
k	int
++	O
]	O
=	O
'0'	O
;	O
str4	array(char)
[	O
k	int
++	O
]	O
=	O
'x'	O
;	O
}	O
else	O
{	O
if	O
(	O
s1	*(char)
[	O
i	int
+	O
n	long
+	O
1	int
]	O
!=	O
'0'	O
)	O
str4	array(char)
[	O
k	int
++	O
]	O
=	O
'0'	O
;	O
else	O
diff	int
=	O
1	int
;	O
str4	array(char)
[	O
k	int
++	O
]	O
=	O
s1	*(char)
[	O
i	int
+	O
n	long
+	O
1	int
]	O
;	O
}	O
j	int
=	O
i	int
+	O
n	long
+	O
2	int
;	O
while	O
(	O
s1	*(char)
[	O
j	int
]	O
&&	O
(	O
s1	*(char)
[	O
j	int
]	O
!=	O
*	O
SEP	*(char)
)	O
&&	O
(	O
k	int
<	O
4	int
-	O
diff	int
)	O
)	O
str4	array(char)
[	O
k	int
++	O
]	O
=	O
s1	*(char)
[	O
j	int
++	O
]	O
;	O
str4	array(char)
[	O
k	int
]	O
=	O
'\0'	O
;	O
j	int
=	O
(	O
int	O
)	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
str4	array(char)
,	O
&	O
ptr_err	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
j	int
==	O
-	O
1	int
||	O
*	O
ptr_err	*(char)
)	O
{	O
is_error	int
=	O
TRUE	O
;	O
break	O
;	O
}	O
s1	*(char)
[	O
i	int
]	O
=	O
(	O
char	O
)	O
j	int
;	O
n	long
+=	O
(	O
k	int
-	O
2	int
+	O
diff	int
)	O
+	O
1	int
;	O
}	O
i	int
++	O
;	O
s1	*(char)
[	O
i	int
]	O
=	O
s1	*(char)
[	O
i	int
+	O
n	long
]	O
;	O
}	O
if	O
(	O
!	O
is_error	int
)	O
{	O
n	long
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
s1	*(char)
)	O
;	O
buf_hls	array(*(char))
[	O
seq_no	int
]	O
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
n	long
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"buf_hls[seq_no]"	*(char)
,	O
seq_no	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf_hls	array(*(char))
[	O
seq_no	int
]	O
,	O
s1	*(char)
)	O
;	O
switch	O
(	O
seq_no	int
)	O
{	O
case	O
0	int
:	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
=	O
buf_hls	array(*(char))
[	O
seq_no	int
]	O
;	O
ehls1s	struct(*(char),int)
.	O
len	int
=	O
n	long
;	O
break	O
;	O
case	O
1	int
:	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
=	O
buf_hls	array(*(char))
[	O
seq_no	int
]	O
;	O
ehls1e	struct(*(char),int)
.	O
len	int
=	O
n	long
;	O
*	O
hls1_set	*(int)
=	O
TRUE	O
;	O
break	O
;	O
case	O
2	int
:	O
ehls2s	struct(*(char),int)
.	O
seq	*(char)
=	O
buf_hls	array(*(char))
[	O
seq_no	int
]	O
;	O
ehls2s	struct(*(char),int)
.	O
len	int
=	O
n	long
;	O
break	O
;	O
case	O
3	int
:	O
ehls2e	struct(*(char),int)
.	O
seq	*(char)
=	O
buf_hls	array(*(char))
[	O
seq_no	int
]	O
;	O
ehls2e	struct(*(char),int)
.	O
len	int
=	O
n	long
;	O
*	O
hls2_set	*(int)
=	O
TRUE	O
;	O
break	O
;	O
default	O
:	O
;	O
}	O
}	O
}	O
i	int
=	O
0	int
;	O
seq_no	int
++	O
;	O
}	O
if	O
(	O
*	O
hls1_set	*(int)
)	O
if	O
(	O
(	O
(	O
ehls1s	struct(*(char),int)
.	O
len	int
==	O
1	int
)	O
&&	O
(	O
ehls1e	struct(*(char),int)
.	O
len	int
!=	O
1	int
)	O
)	O
||	O
(	O
(	O
ehls1s	struct(*(char),int)
.	O
len	int
!=	O
1	int
)	O
&&	O
(	O
ehls1e	struct(*(char),int)
.	O
len	int
==	O
1	int
)	O
)	O
)	O
*	O
hls1_set	*(int)
=	O
FALSE	O
;	O
if	O
(	O
*	O
hls2_set	*(int)
)	O
if	O
(	O
(	O
(	O
ehls2s	struct(*(char),int)
.	O
len	int
==	O
1	int
)	O
&&	O
(	O
ehls2e	struct(*(char),int)
.	O
len	int
!=	O
1	int
)	O
)	O
||	O
(	O
(	O
ehls2s	struct(*(char),int)
.	O
len	int
!=	O
1	int
)	O
&&	O
(	O
ehls2e	struct(*(char),int)
.	O
len	int
==	O
1	int
)	O
)	O
)	O
*	O
hls2_set	*(int)
=	O
FALSE	O
;	O
if	O
(	O
*	O
hls1_set	*(int)
)	O
{	O
if	O
(	O
(	O
ehls1s	struct(*(char),int)
.	O
len	int
==	O
1	int
)	O
&&	O
(	O
ehls1e	struct(*(char),int)
.	O
len	int
==	O
1	int
)	O
)	O
{	O
if	O
(	O
*	O
hls2_set	*(int)
)	O
{	O
if	O
(	O
(	O
ehls2s	struct(*(char),int)
.	O
len	int
==	O
1	int
)	O
&&	O
(	O
ehls2e	struct(*(char),int)
.	O
len	int
==	O
1	int
)	O
)	O
emu_hls	int
=	O
TRUE	O
;	O
else	O
{	O
if	O
(	O
emu_hls	int
)	O
*	O
hls2_set	*(int)
=	O
FALSE	O
;	O
else	O
*	O
hls1_set	*(int)
=	O
FALSE	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
emu_hls	int
)	O
*	O
hls1_set	*(int)
=	O
FALSE	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
hls2_set	*(int)
)	O
{	O
if	O
(	O
(	O
ehls2s	struct(*(char),int)
.	O
len	int
!=	O
1	int
)	O
&&	O
(	O
ehls2e	struct(*(char),int)
.	O
len	int
!=	O
1	int
)	O
)	O
;	O
else	O
{	O
if	O
(	O
emu_hls	int
)	O
*	O
hls1_set	*(int)
=	O
FALSE	O
;	O
else	O
*	O
hls2_set	*(int)
=	O
FALSE	O
;	O
}	O
}	O
else	O
if	O
(	O
emu_hls	int
)	O
*	O
hls1_set	*(int)
=	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
!	O
*	O
hls1_set	*(int)
&&	O
*	O
hls2_set	*(int)
)	O
{	O
if	O
(	O
(	O
ehls2s	struct(*(char),int)
.	O
len	int
==	O
1	int
)	O
&&	O
(	O
ehls2e	struct(*(char),int)
.	O
len	int
==	O
1	int
)	O
)	O
{	O
if	O
(	O
!	O
emu_hls	int
)	O
*	O
hls2_set	*(int)
=	O
FALSE	O
;	O
}	O
else	O
if	O
(	O
emu_hls	int
)	O
*	O
hls2_set	*(int)
=	O
FALSE	O
;	O
}	O
if	O
(	O
*	O
hls1_set	*(int)
&&	O
*	O
hls2_set	*(int)
)	O
if	O
(	O
emu_hls	int
&&	O
(	O
ehls1s	struct(*(char),int)
.	O
len	int
>	O
1	int
)	O
&&	O
(	O
ehls2s	struct(*(char),int)
.	O
len	int
>	O
1	int
)	O
)	O
(	O
*	O
hls1_set	*(int)
)	O
=	O
(	O
*	O
hls2_set	*(int)
)	O
=	O
FALSE	O
;	O
}	O
