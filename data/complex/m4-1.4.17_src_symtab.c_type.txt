symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
*	O
symtab	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
;	O
void	O
symtab_init	()->(void)
(	O
void	O
)	O
{	O
size_t	long
i	long
;	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
*	O
s	long
;	O
s	long
=	O
symtab	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
=	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
*	O
)	O
xnmalloc	(long,long)->(*(void))
(	O
hash_table_size	long
,	O
sizeof	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
hash_table_size	long
;	O
i	long
++	O
)	O
s	long
[	O
i	long
]	O
=	O
NULL	O
;	O
}	O
static	O
size_t	long
M4_GNUC_PURE	O
hash	(*(char))->(long)
(	O
const	O
char	O
*	O
s	long
)	O
{	O
register	O
size_t	long
val	array(int)
=	O
0	int
;	O
register	O
const	O
char	O
*	O
ptr	*(char)
=	O
s	long
;	O
register	O
char	O
ch	char
;	O
while	O
(	O
(	O
ch	char
=	O
*	O
ptr	*(char)
++	O
)	O
!=	O
'\0'	O
)	O
val	array(int)
=	O
(	O
val	array(int)
<<	O
7	int
)	O
+	O
(	O
val	array(int)
>>	O
(	O
sizeof	O
(	O
val	array(int)
)	O
*	O
CHAR_BIT	O
-	O
7	int
)	O
)	O
+	O
ch	char
;	O
return	O
val	array(int)
;	O
}	O
void	O
free_symbol	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
if	O
(	O
SYMBOL_PENDING_EXPANSIONS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
>	O
0	int
)	O
SYMBOL_DELETED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
true	int
;	O
else	O
{	O
free	(*(void))->(void)
(	O
SYMBOL_NAME	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
;	O
if	O
(	O
SYMBOL_TYPE	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
==	O
TOKEN_TEXT	int
)	O
free	(*(void))->(void)
(	O
SYMBOL_TEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
;	O
free	(*(void))->(void)
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
}	O
}	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
lookup_symbol	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
const	O
char	O
*	O
name	*(char)
,	O
symbol_lookup	enum(int,int,int,int,int)
mode	int
)	O
{	O
size_t	long
h	long
;	O
int	O
cmp	int
=	O
1	int
;	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
*	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
*	O
spp	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
;	O
h	long
=	O
hash	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
symtab	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
[	O
h	long
%	O
hash_table_size	long
]	O
;	O
for	O
(	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
NULL	O
;	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
!=	O
NULL	O
;	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
->	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
cmp	int
=	O
strcmp	(*(char),*(char))->(int)
(	O
SYMBOL_NAME	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
cmp	int
>=	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
mode	int
==	O
SYMBOL_LOOKUP	int
)	O
return	O
cmp	int
==	O
0	int
?	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
:	O
NULL	O
;	O
spp	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
=	O
(	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
!=	O
NULL	O
)	O
?	O
&	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
:	O
&	O
symtab	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
[	O
h	long
%	O
hash_table_size	long
]	O
;	O
switch	O
(	O
mode	int
)	O
{	O
case	O
SYMBOL_INSERT	int
:	O
if	O
(	O
cmp	int
==	O
0	int
&&	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
!=	O
NULL	O
)	O
{	O
if	O
(	O
SYMBOL_PENDING_EXPANSIONS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
>	O
0	int
)	O
{	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
old	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
SYMBOL_DELETED	O
(	O
old	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
true	int
;	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
)	O
)	O
;	O
SYMBOL_TYPE	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
TOKEN_VOID	int
;	O
SYMBOL_TRACED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
SYMBOL_TRACED	O
(	O
old	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
SYMBOL_NAME	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
xstrdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
SYMBOL_SHADOWED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
false	int
;	O
SYMBOL_MACRO_ARGS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
false	int
;	O
SYMBOL_BLIND_NO_ARGS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
false	int
;	O
SYMBOL_DELETED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
false	int
;	O
SYMBOL_PENDING_EXPANSIONS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
0	int
;	O
SYMBOL_NEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
SYMBOL_NEXT	O
(	O
old	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
SYMBOL_NEXT	O
(	O
old	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
NULL	O
;	O
(	O
*	O
spp	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
)	O
=	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
}	O
return	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
}	O
case	O
SYMBOL_PUSHDEF	int
:	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
)	O
)	O
;	O
SYMBOL_TYPE	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
TOKEN_VOID	int
;	O
SYMBOL_TRACED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
false	int
;	O
SYMBOL_NAME	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
xstrdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
SYMBOL_SHADOWED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
false	int
;	O
SYMBOL_MACRO_ARGS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
false	int
;	O
SYMBOL_BLIND_NO_ARGS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
false	int
;	O
SYMBOL_DELETED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
false	int
;	O
SYMBOL_PENDING_EXPANSIONS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
0	int
;	O
SYMBOL_NEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
*	O
spp	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
;	O
(	O
*	O
spp	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
)	O
=	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
if	O
(	O
mode	int
==	O
SYMBOL_PUSHDEF	int
&&	O
cmp	int
==	O
0	int
)	O
{	O
SYMBOL_SHADOWED	O
(	O
SYMBOL_NEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
=	O
true	int
;	O
SYMBOL_TRACED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
SYMBOL_TRACED	O
(	O
SYMBOL_NEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
;	O
}	O
return	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
case	O
SYMBOL_DELETE	int
:	O
case	O
SYMBOL_POPDEF	int
:	O
if	O
(	O
cmp	int
!=	O
0	int
||	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
{	O
bool	bool
traced	bool
=	O
false	int
;	O
if	O
(	O
SYMBOL_NEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
!=	O
NULL	O
&&	O
SYMBOL_SHADOWED	O
(	O
SYMBOL_NEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
&&	O
mode	int
==	O
SYMBOL_POPDEF	int
)	O
{	O
SYMBOL_SHADOWED	O
(	O
SYMBOL_NEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
=	O
false	int
;	O
SYMBOL_TRACED	O
(	O
SYMBOL_NEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
=	O
SYMBOL_TRACED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
}	O
else	O
traced	bool
=	O
SYMBOL_TRACED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
do	O
{	O
*	O
spp	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
=	O
SYMBOL_NEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
free_symbol	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
*	O
spp	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
;	O
}	O
while	O
(	O
*	O
spp	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
!=	O
NULL	O
&&	O
SYMBOL_SHADOWED	O
(	O
*	O
spp	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
)	O
&&	O
mode	int
==	O
SYMBOL_DELETE	int
)	O
;	O
if	O
(	O
traced	bool
)	O
{	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
)	O
)	O
;	O
SYMBOL_TYPE	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
TOKEN_VOID	int
;	O
SYMBOL_TRACED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
true	int
;	O
SYMBOL_NAME	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
xstrdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
SYMBOL_SHADOWED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
false	int
;	O
SYMBOL_MACRO_ARGS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
false	int
;	O
SYMBOL_BLIND_NO_ARGS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
false	int
;	O
SYMBOL_DELETED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
false	int
;	O
SYMBOL_PENDING_EXPANSIONS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
0	int
;	O
SYMBOL_NEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
*	O
spp	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
;	O
(	O
*	O
spp	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
)	O
=	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
}	O
}	O
return	O
NULL	O
;	O
case	O
SYMBOL_LOOKUP	int
:	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: invalid mode to symbol_lookup ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
void	O
hack_all_symbols	(*((*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),*(void))->(void)),*(void))->(void)
(	O
hack_symbol	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),*(void))->(void)
*	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
,	O
void	O
*	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
{	O
size_t	long
h	long
;	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
for	O
(	O
h	long
=	O
0	int
;	O
h	long
<	O
hash_table_size	long
;	O
h	long
++	O
)	O
{	O
for	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
symtab	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
[	O
h	long
]	O
;	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
!=	O
NULL	O
;	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
SYMBOL_NEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
func	*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int)))))->(void))
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
data	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
;	O
}	O
}	O
}	O
