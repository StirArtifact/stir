static	O
char	O
*	O
get_syscall_name	(int)->(*(char))
(	O
int	O
num	int
)	O
{	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
get_rpc_name	(int)->(*(char))
(	O
mach_msg_id_t	O
it	int
)	O
{	O
return	O
0	int
;	O
}	O
typedef	O
void	O
(	O
*	O
vf	*(()->(void))
)	O
(	O
)	O
;	O
static	O
int	O
ps_get_pid	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_pid	()->(int)
(	O
ps	*(struct)
)	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_pid_getter	struct
=	O
{	O
"pid"	*(char)
,	O
PSTAT_PID	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_pid	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_thread_index	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_thread_index	()->(int)
(	O
ps	*(struct)
)	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_thread_index_getter	struct
=	O
{	O
"thread_index"	*(char)
,	O
PSTAT_THREAD	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_thread_index	(*(struct))->(int)
}	O
;	O
static	O
struct	O
ps_user	O
*	O
ps_get_owner	(*(struct))->(*(struct))
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_owner	()->(int)
(	O
ps	*(struct)
)	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_owner_getter	struct
=	O
{	O
"owner"	*(char)
,	O
PSTAT_OWNER	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_owner	(*(struct))->(*(struct))
}	O
;	O
static	O
int	O
ps_get_owner_uid	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_owner_uid	()->(int)
(	O
ps	*(struct)
)	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_owner_uid_getter	struct
=	O
{	O
"uid"	*(char)
,	O
PSTAT_OWNER_UID	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_owner_uid	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_ppid	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_proc_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
ppid	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_ppid_getter	struct
=	O
{	O
"ppid"	*(char)
,	O
PSTAT_PROC_INFO	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_ppid	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_pgrp	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_proc_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
pgrp	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_pgrp_getter	struct
=	O
{	O
"pgrp"	*(char)
,	O
PSTAT_PROC_INFO	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_pgrp	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_session	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_proc_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
session	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_session_getter	struct
=	O
{	O
"session"	*(char)
,	O
PSTAT_PROC_INFO	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_session	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_login_col	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_proc_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
logincollection	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_login_col_getter	struct
=	O
{	O
"login_col"	*(char)
,	O
PSTAT_PROC_INFO	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_login_col	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_num_threads	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_num_threads	()->(int)
(	O
ps	*(struct)
)	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_num_threads_getter	struct
=	O
{	O
"num_threads"	*(char)
,	O
PSTAT_NUM_THREADS	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_num_threads	(*(struct))->(int)
}	O
;	O
static	O
void	O
ps_get_args	(*(struct),*(*(char)),*(int))->(void)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
char	O
*	O
*	O
args_p	*(*(char))
,	O
int	O
*	O
args_len_p	*(int)
)	O
{	O
*	O
args_p	*(*(char))
=	O
proc_stat_args	()->(int)
(	O
ps	*(struct)
)	O
;	O
*	O
args_len_p	*(int)
=	O
proc_stat_args_len	()->(int)
(	O
ps	*(struct)
)	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_args_getter	struct
=	O
{	O
"args"	*(char)
,	O
PSTAT_ARGS	O
,	O
ps_get_args	(*(struct),*(*(char)),*(int))->(void)
}	O
;	O
static	O
void	O
ps_get_env	(*(struct),*(*(char)),*(int))->(void)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
char	O
*	O
*	O
env_p	*(*(char))
,	O
int	O
*	O
env_len_p	*(int)
)	O
{	O
*	O
env_p	*(*(char))
=	O
proc_stat_env	()->(int)
(	O
ps	*(struct)
)	O
;	O
*	O
env_len_p	*(int)
=	O
proc_stat_env_len	()->(int)
(	O
ps	*(struct)
)	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_env_getter	struct
=	O
{	O
"env"	*(char)
,	O
PSTAT_ENV	O
,	O
ps_get_env	(*(struct),*(*(char)),*(int))->(void)
}	O
;	O
static	O
int	O
ps_get_state	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_state	()->(int)
(	O
ps	*(struct)
)	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_state_getter	struct
=	O
{	O
"state"	*(char)
,	O
PSTAT_STATE	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_state	(*(struct))->(int)
}	O
;	O
static	O
void	O
ps_get_wait	(*(struct),*(*(char)),*(int))->(void)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
char	O
*	O
*	O
wait	*(*(char))
,	O
int	O
*	O
rpc	*(int)
)	O
{	O
*	O
wait	*(*(char))
=	O
ps	*(struct)
->	O
thread_wait	O
;	O
*	O
rpc	*(int)
=	O
ps	*(struct)
->	O
thread_rpc	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_wait_getter	struct
=	O
{	O
"wait"	*(char)
,	O
PSTAT_THREAD_WAIT	O
,	O
ps_get_wait	(*(struct),*(*(char)),*(int))->(void)
}	O
;	O
static	O
size_t	long
ps_get_vsize	(*(struct))->(long)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_task_basic_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
virtual_size	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_vsize_getter	struct
=	O
{	O
"vsize"	*(char)
,	O
PSTAT_TASK_BASIC	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_vsize	(*(struct))->(long)
}	O
;	O
static	O
size_t	long
ps_get_rsize	(*(struct))->(long)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_task_basic_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
resident_size	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_rsize_getter	struct
=	O
{	O
"rsize"	*(char)
,	O
PSTAT_TASK_BASIC	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_rsize	(*(struct))->(long)
}	O
;	O
static	O
int	O
ps_get_cur_priority	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_thread_basic_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
cur_priority	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_cur_priority_getter	struct
=	O
{	O
"cur_priority"	*(char)
,	O
PSTAT_THREAD_BASIC	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_cur_priority	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_base_priority	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_thread_basic_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
base_priority	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_base_priority_getter	struct
=	O
{	O
"base_priority"	*(char)
,	O
PSTAT_THREAD_BASIC	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_base_priority	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_max_priority	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_thread_sched_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
max_priority	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_max_priority_getter	struct
=	O
{	O
"max_priority"	*(char)
,	O
PSTAT_THREAD_SCHED	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_max_priority	(*(struct))->(int)
}	O
;	O
static	O
void	O
ps_get_usr_time	(*(struct),*(struct))->(void)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
timeval	O
*	O
tv	*(struct)
)	O
{	O
time_value_t	O
tvt	O
=	O
proc_stat_thread_basic_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
user_time	O
;	O
tv	*(struct)
->	O
tv_sec	O
=	O
tvt	O
.	O
seconds	O
;	O
tv	*(struct)
->	O
tv_usec	O
=	O
tvt	O
.	O
microseconds	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_usr_time_getter	struct
=	O
{	O
"usr_time"	*(char)
,	O
PSTAT_TIMES	O
,	O
ps_get_usr_time	(*(struct),*(struct))->(void)
}	O
;	O
static	O
void	O
ps_get_sys_time	(*(struct),*(struct))->(void)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
timeval	O
*	O
tv	*(struct)
)	O
{	O
time_value_t	O
tvt	O
=	O
proc_stat_thread_basic_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
system_time	O
;	O
tv	*(struct)
->	O
tv_sec	O
=	O
tvt	O
.	O
seconds	O
;	O
tv	*(struct)
->	O
tv_usec	O
=	O
tvt	O
.	O
microseconds	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_sys_time_getter	struct
=	O
{	O
"sys_time"	*(char)
,	O
PSTAT_TIMES	O
,	O
ps_get_sys_time	(*(struct),*(struct))->(void)
}	O
;	O
static	O
void	O
ps_get_tot_time	(*(struct),*(struct))->(void)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
timeval	O
*	O
tv	*(struct)
)	O
{	O
time_value_t	O
tvt	O
=	O
proc_stat_thread_basic_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
user_time	O
;	O
time_value_add	()->(int)
(	O
&	O
tvt	O
,	O
&	O
proc_stat_thread_basic_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
system_time	O
)	O
;	O
tv	*(struct)
->	O
tv_sec	O
=	O
tvt	O
.	O
seconds	O
;	O
tv	*(struct)
->	O
tv_usec	O
=	O
tvt	O
.	O
microseconds	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_tot_time_getter	struct
=	O
{	O
"tot_time"	*(char)
,	O
PSTAT_TIMES	O
,	O
ps_get_tot_time	(*(struct),*(struct))->(void)
}	O
;	O
static	O
void	O
ps_get_start_time	(*(struct),*(struct))->(void)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
timeval	O
*	O
tv	*(struct)
)	O
{	O
time_value_t	O
*	O
const	O
tvt	O
=	O
&	O
proc_stat_task_basic_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
creation_time	O
;	O
tv	*(struct)
->	O
tv_sec	O
=	O
tvt	O
->	O
seconds	O
;	O
tv	*(struct)
->	O
tv_usec	O
=	O
tvt	O
->	O
microseconds	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_start_time_getter	struct
=	O
{	O
"start_time"	*(char)
,	O
PSTAT_TASK_BASIC	O
,	O
ps_get_start_time	(*(struct),*(struct))->(void)
}	O
;	O
static	O
float	O
ps_get_rmem_frac	(*(struct))->(float)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
static	O
size_t	long
mem_size	long
=	O
0	int
;	O
if	O
(	O
mem_size	long
==	O
0	int
)	O
{	O
host_basic_info_t	O
info	O
;	O
error_t	O
err	O
=	O
ps_host_basic_info	O
(	O
&	O
info	O
)	O
;	O
if	O
(	O
err	O
==	O
0	int
)	O
mem_size	long
=	O
info	O
->	O
memory_size	O
;	O
}	O
if	O
(	O
mem_size	long
>	O
0	int
)	O
return	O
(	O
float	O
)	O
proc_stat_task_basic_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
resident_size	O
/	O
(	O
float	O
)	O
mem_size	long
;	O
else	O
return	O
0.0	int
;	O
}	O
const	O
struct	O
ps_getter	O
ps_rmem_frac_getter	struct
=	O
{	O
"rmem_frac"	*(char)
,	O
PSTAT_TASK_BASIC	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_rmem_frac	(*(struct))->(float)
}	O
;	O
static	O
float	O
ps_get_cpu_frac	(*(struct))->(float)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
(	O
float	O
)	O
proc_stat_thread_basic_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
cpu_usage	O
/	O
(	O
float	O
)	O
TH_USAGE_SCALE	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_cpu_frac_getter	struct
=	O
{	O
"cpu_frac"	*(char)
,	O
PSTAT_THREAD_BASIC	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_cpu_frac	(*(struct))->(float)
}	O
;	O
static	O
int	O
ps_get_sleep	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_thread_basic_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
sleep_time	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_sleep_getter	struct
=	O
{	O
"sleep"	*(char)
,	O
PSTAT_THREAD_BASIC	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_sleep	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_susp_count	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_suspend_count	()->(int)
(	O
ps	*(struct)
)	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_susp_count_getter	struct
=	O
{	O
"susp_count"	*(char)
,	O
PSTAT_SUSPEND_COUNT	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_susp_count	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_proc_susp_count	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_task_basic_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
suspend_count	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_proc_susp_count_getter	struct
=	O
{	O
"proc_susp_count"	*(char)
,	O
PSTAT_TASK_BASIC	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_proc_susp_count	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_thread_susp_count	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_thread_basic_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
suspend_count	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_thread_susp_count_getter	struct
=	O
{	O
"thread_susp_count"	*(char)
,	O
PSTAT_SUSPEND_COUNT	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_thread_susp_count	(*(struct))->(int)
}	O
;	O
static	O
struct	O
ps_tty	O
*	O
ps_get_tty	(*(struct))->(*(struct))
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_tty	()->(int)
(	O
ps	*(struct)
)	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_tty_getter	struct
=	O
{	O
"tty"	*(char)
,	O
PSTAT_TTY	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_tty	(*(struct))->(*(struct))
}	O
;	O
static	O
int	O
ps_get_page_faults	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_task_events_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
faults	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_page_faults_getter	struct
=	O
{	O
"page_faults"	*(char)
,	O
PSTAT_TASK_EVENTS	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_page_faults	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_cow_faults	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_task_events_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
cow_faults	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_cow_faults_getter	struct
=	O
{	O
"cow_faults"	*(char)
,	O
PSTAT_TASK_EVENTS	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_cow_faults	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_pageins	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_task_events_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
pageins	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_pageins_getter	struct
=	O
{	O
"pageins"	*(char)
,	O
PSTAT_TASK_EVENTS	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_pageins	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_msgs_sent	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_task_events_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
messages_sent	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_msgs_sent_getter	struct
=	O
{	O
"msgs_sent"	*(char)
,	O
PSTAT_TASK_EVENTS	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_msgs_sent	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_msgs_rcvd	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_task_events_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
messages_received	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_msgs_rcvd_getter	struct
=	O
{	O
"msgs_rcvd"	*(char)
,	O
PSTAT_TASK_EVENTS	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_msgs_rcvd	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_zero_fills	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_task_events_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
zero_fills	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_zero_fills_getter	struct
=	O
{	O
"zero_fills"	*(char)
,	O
PSTAT_TASK_EVENTS	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_zero_fills	(*(struct))->(int)
}	O
;	O
static	O
int	O
ps_get_num_ports	(*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
return	O
proc_stat_num_ports	()->(int)
(	O
ps	*(struct)
)	O
;	O
}	O
const	O
struct	O
ps_getter	O
ps_num_ports_getter	struct
=	O
{	O
"num_ports"	*(char)
,	O
PSTAT_NUM_PORTS	O
,	O
(	O
vf	*(()->(void))
)	O
ps_get_num_ports	(*(struct))->(int)
}	O
;	O
error_t	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
return	O
ps_stream_write_int_field	()->(int)
(	O
stream	*(struct)
,	O
FG	O
(	O
field	*(struct)
,	O
int	O
)	O
(	O
ps	*(struct)
)	O
,	O
field	*(struct)
->	O
width	int
)	O
;	O
}	O
error_t	O
ps_emit_nz_int	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
int	O
value	int
=	O
FG	O
(	O
field	*(struct)
,	O
int	O
)	O
(	O
ps	*(struct)
)	O
;	O
if	O
(	O
value	int
)	O
return	O
ps_stream_write_int_field	()->(int)
(	O
stream	*(struct)
,	O
value	int
,	O
field	*(struct)
->	O
width	int
)	O
;	O
else	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
"-"	*(char)
,	O
field	*(struct)
->	O
width	int
)	O
;	O
}	O
error_t	O
ps_emit_priority	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
return	O
ps_stream_write_int_field	()->(int)
(	O
stream	*(struct)
,	O
MACH_PRIORITY_TO_NICE	()->(int)
(	O
FG	O
(	O
field	*(struct)
,	O
int	O
)	O
(	O
ps	*(struct)
)	O
)	O
,	O
field	*(struct)
->	O
width	int
)	O
;	O
}	O
error_t	O
ps_emit_num_blocks	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
char	O
buf	array(char)
[	O
20	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
"%d"	*(char)
,	O
FG	O
(	O
field	*(struct)
,	O
int	O
)	O
(	O
ps	*(struct)
)	O
/	O
1024	int
)	O
;	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
buf	array(char)
,	O
field	*(struct)
->	O
width	int
)	O
;	O
}	O
size_t	long
sprint_frac_value	(*(char),long,int,long,int,int)->(long)
(	O
char	O
*	O
buf	array(char)
,	O
size_t	long
value	int
,	O
int	O
min_value_len	int
,	O
size_t	long
frac	long
,	O
int	O
frac_scale	int
,	O
int	O
width	int
)	O
{	O
int	O
value_len	int
=	O
0	int
;	O
int	O
frac_len	int
=	O
0	int
;	O
if	O
(	O
value	int
>=	O
1000	int
)	O
value_len	int
=	O
4	int
;	O
else	O
if	O
(	O
value	int
>=	O
100	int
)	O
value_len	int
=	O
3	int
;	O
else	O
if	O
(	O
value	int
>=	O
10	int
)	O
value_len	int
=	O
2	int
;	O
else	O
value_len	int
=	O
1	int
;	O
while	O
(	O
value_len	int
<	O
min_value_len	int
--	O
)	O
*	O
buf	array(char)
++	O
=	O
'0'	O
;	O
for	O
(	O
frac_len	int
=	O
frac_scale	int
;	O
frac_len	int
>	O
0	int
&&	O
(	O
width	int
<	O
value_len	int
+	O
1	int
+	O
frac_len	int
||	O
frac	long
%	O
10	int
==	O
0	int
)	O
;	O
frac_len	int
--	O
)	O
frac	long
/=	O
10	int
;	O
if	O
(	O
frac_len	int
>	O
0	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
"%zd.%0*zd"	*(char)
,	O
value	int
,	O
frac_len	int
,	O
frac	long
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
"%zd"	*(char)
,	O
value	int
)	O
;	O
return	O
strlen	O
(	O
buf	array(char)
)	O
;	O
}	O
error_t	O
ps_emit_percent	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
char	O
buf	array(char)
[	O
20	int
]	O
;	O
int	O
width	int
=	O
field	*(struct)
->	O
width	int
;	O
float	O
perc	float
=	O
FG	O
(	O
field	*(struct)
,	O
float	O
)	O
(	O
ps	*(struct)
)	O
*	O
100	int
;	O
if	O
(	O
width	int
==	O
0	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
"%g"	*(char)
,	O
perc	float
)	O
;	O
else	O
if	O
(	O
ABS	()->(int)
(	O
width	int
)	O
>	O
3	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
"%.*f"	*(char)
,	O
ABS	()->(int)
(	O
width	int
)	O
-	O
3	int
,	O
perc	float
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
"%d"	*(char)
,	O
(	O
int	O
)	O
perc	float
)	O
;	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
buf	array(char)
,	O
width	int
)	O
;	O
}	O
error_t	O
ps_emit_nice_size_t	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
char	O
buf	array(char)
[	O
20	int
]	O
;	O
size_t	long
value	int
=	O
FG	O
(	O
field	*(struct)
,	O
size_t	long
)	O
(	O
ps	*(struct)
)	O
;	O
char	O
*	O
sfx	*(char)
=	O
" KMG"	*(char)
;	O
size_t	long
frac	long
=	O
0	int
;	O
while	O
(	O
value	int
>=	O
1024	int
)	O
{	O
frac	long
=	O
(	O
(	O
value	int
&	O
0x3FF	int
)	O
*	O
1000	int
)	O
>>	O
10	int
;	O
value	int
>>=	O
10	int
;	O
sfx	*(char)
++	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
+	O
sprint_frac_value	(*(char),long,int,long,int,int)->(long)
(	O
buf	array(char)
,	O
value	int
,	O
1	int
,	O
frac	long
,	O
3	int
,	O
ABS	()->(int)
(	O
field	*(struct)
->	O
width	int
)	O
-	O
1	int
)	O
,	O
"%c"	*(char)
,	O
*	O
sfx	*(char)
)	O
;	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
buf	array(char)
,	O
field	*(struct)
->	O
width	int
)	O
;	O
}	O
error_t	O
ps_emit_seconds	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
char	O
buf	array(char)
[	O
20	int
]	O
;	O
struct	O
timeval	O
tv	*(struct)
;	O
int	O
width	int
=	O
field	*(struct)
->	O
width	int
,	O
prec	int
=	O
field	*(struct)
->	O
precision	O
;	O
FG	O
(	O
field	*(struct)
,	O
void	O
)	O
(	O
ps	*(struct)
,	O
&	O
tv	*(struct)
)	O
;	O
if	O
(	O
(	O
field	*(struct)
->	O
flags	O
&	O
PS_FMT_FIELD_COLON_MOD	O
)	O
&&	O
tv	*(struct)
.	O
tv_sec	O
==	O
0	int
)	O
strcpy	O
(	O
buf	array(char)
,	O
"-"	*(char)
)	O
;	O
else	O
fmt_seconds	()->(int)
(	O
&	O
tv	*(struct)
,	O
!	O
(	O
field	*(struct)
->	O
flags	O
&	O
PS_FMT_FIELD_AT_MOD	O
)	O
,	O
prec	int
,	O
ABS	()->(int)
(	O
width	int
)	O
,	O
buf	array(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
)	O
;	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
buf	array(char)
,	O
width	int
)	O
;	O
}	O
error_t	O
ps_emit_minutes	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
char	O
buf	array(char)
[	O
20	int
]	O
;	O
struct	O
timeval	O
tv	*(struct)
;	O
int	O
width	int
=	O
field	*(struct)
->	O
width	int
;	O
FG	O
(	O
field	*(struct)
,	O
void	O
)	O
(	O
ps	*(struct)
,	O
&	O
tv	*(struct)
)	O
;	O
if	O
(	O
(	O
field	*(struct)
->	O
flags	O
&	O
PS_FMT_FIELD_COLON_MOD	O
)	O
&&	O
tv	*(struct)
.	O
tv_sec	O
<	O
60	int
)	O
strcpy	O
(	O
buf	array(char)
,	O
"-"	*(char)
)	O
;	O
else	O
fmt_minutes	()->(int)
(	O
&	O
tv	*(struct)
,	O
!	O
(	O
field	*(struct)
->	O
flags	O
&	O
PS_FMT_FIELD_AT_MOD	O
)	O
,	O
ABS	()->(int)
(	O
width	int
)	O
,	O
buf	array(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
)	O
;	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
buf	array(char)
,	O
width	int
)	O
;	O
}	O
error_t	O
ps_emit_past_time	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
static	O
struct	O
timeval	O
now	struct
;	O
char	O
buf	array(char)
[	O
20	int
]	O
;	O
struct	O
timeval	O
tv	*(struct)
;	O
int	O
width	int
=	O
field	*(struct)
->	O
width	int
;	O
FG	O
(	O
field	*(struct)
,	O
void	O
)	O
(	O
ps	*(struct)
,	O
&	O
tv	*(struct)
)	O
;	O
if	O
(	O
now	struct
.	O
tv_sec	O
==	O
0	int
&&	O
gettimeofday	()->(int)
(	O
&	O
now	struct
,	O
0	int
)	O
<	O
0	int
)	O
return	O
errno	O
;	O
fmt_past_time	()->(int)
(	O
&	O
tv	*(struct)
,	O
&	O
now	struct
,	O
ABS	()->(int)
(	O
width	int
)	O
,	O
buf	array(char)
,	O
sizeof	O
buf	array(char)
)	O
;	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
buf	array(char)
,	O
width	int
)	O
;	O
}	O
error_t	O
ps_emit_uid	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
int	O
uid	int
=	O
FG	O
(	O
field	*(struct)
,	O
int	O
)	O
(	O
ps	*(struct)
)	O
;	O
if	O
(	O
uid	int
<	O
0	int
)	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
"-"	*(char)
,	O
field	*(struct)
->	O
width	int
)	O
;	O
else	O
return	O
ps_stream_write_int_field	()->(int)
(	O
stream	*(struct)
,	O
uid	int
,	O
field	*(struct)
->	O
width	int
)	O
;	O
}	O
error_t	O
ps_emit_uname	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
int	O
width	int
=	O
field	*(struct)
->	O
width	int
;	O
struct	O
ps_user	O
*	O
u	*(struct)
=	O
FG	O
(	O
field	*(struct)
,	O
struct	O
ps_user	O
*	O
)	O
(	O
ps	*(struct)
)	O
;	O
if	O
(	O
u	*(struct)
)	O
{	O
struct	O
passwd	O
*	O
pw	*(struct)
=	O
ps_user_passwd	()->(int)
(	O
u	*(struct)
)	O
;	O
if	O
(	O
pw	*(struct)
==	O
NULL	O
)	O
return	O
ps_stream_write_int_field	()->(int)
(	O
stream	*(struct)
,	O
ps_user_uid	()->(int)
(	O
u	*(struct)
)	O
,	O
width	int
)	O
;	O
else	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
pw	*(struct)
->	O
pw_name	O
,	O
width	int
)	O
;	O
}	O
else	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
"-"	*(char)
,	O
width	int
)	O
;	O
}	O
error_t	O
ps_emit_user_name	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
int	O
width	int
=	O
field	*(struct)
->	O
width	int
;	O
struct	O
ps_user	O
*	O
u	*(struct)
=	O
FG	O
(	O
field	*(struct)
,	O
struct	O
ps_user	O
*	O
)	O
(	O
ps	*(struct)
)	O
;	O
if	O
(	O
u	*(struct)
)	O
{	O
struct	O
passwd	O
*	O
pw	*(struct)
=	O
ps_user_passwd	()->(int)
(	O
u	*(struct)
)	O
;	O
if	O
(	O
pw	*(struct)
==	O
NULL	O
)	O
{	O
char	O
buf	array(char)
[	O
20	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
"(UID %d)"	*(char)
,	O
u	*(struct)
->	O
uid	int
)	O
;	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
buf	array(char)
,	O
width	int
)	O
;	O
}	O
else	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
pw	*(struct)
->	O
pw_gecos	O
,	O
width	int
)	O
;	O
}	O
else	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
"-"	*(char)
,	O
width	int
)	O
;	O
}	O
error_t	O
ps_emit_args	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
char	O
*	O
s0	*(char)
,	O
*	O
p	*(char)
,	O
*	O
q	*(char)
;	O
int	O
s0len	int
;	O
int	O
width	int
=	O
field	*(struct)
->	O
width	int
;	O
int	O
fwidth	int
=	O
ABS	()->(int)
(	O
width	int
)	O
;	O
char	O
static_buf	array(char)
[	O
200	int
]	O
;	O
char	O
*	O
buf	array(char)
=	O
static_buf	array(char)
;	O
FG	O
(	O
field	*(struct)
,	O
void	O
)	O
(	O
ps	*(struct)
,	O
&	O
s0	*(char)
,	O
&	O
s0len	int
)	O
;	O
if	O
(	O
!	O
s0	*(char)
||	O
s0len	int
==	O
0	int
)	O
strcpy	O
(	O
buf	array(char)
,	O
"-"	*(char)
)	O
;	O
else	O
{	O
if	O
(	O
s0len	int
>	O
sizeof	O
static_buf	array(char)
)	O
{	O
buf	array(char)
=	O
malloc	O
(	O
s0len	int
+	O
1	int
)	O
;	O
if	O
(	O
buf	array(char)
==	O
NULL	O
)	O
return	O
ENOMEM	O
;	O
}	O
if	O
(	O
fwidth	int
==	O
0	int
||	O
fwidth	int
>	O
s0len	int
)	O
fwidth	int
=	O
s0len	int
;	O
for	O
(	O
p	*(char)
=	O
buf	array(char)
,	O
q	*(char)
=	O
s0	*(char)
;	O
fwidth	int
--	O
>	O
0	int
;	O
p	*(char)
++	O
,	O
q	*(char)
++	O
)	O
{	O
int	O
ch	int
=	O
*	O
q	*(char)
;	O
*	O
p	*(char)
=	O
(	O
ch	int
==	O
'\0'	O
?	O
' '	O
:	O
ch	int
)	O
;	O
}	O
if	O
(	O
q	*(char)
>	O
s0	*(char)
&&	O
*	O
(	O
q	*(char)
-	O
1	int
)	O
==	O
'\0'	O
)	O
*	O
--	O
p	*(char)
=	O
'\0'	O
;	O
else	O
*	O
p	*(char)
=	O
'\0'	O
;	O
}	O
{	O
error_t	O
err	O
=	O
ps_stream_write_trunc_field	()->(int)
(	O
stream	*(struct)
,	O
buf	array(char)
,	O
width	int
)	O
;	O
if	O
(	O
buf	array(char)
!=	O
static_buf	array(char)
)	O
free	()->(int)
(	O
buf	array(char)
)	O
;	O
return	O
err	O
;	O
}	O
}	O
error_t	O
ps_emit_string	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
char	O
*	O
str	*(char)
;	O
int	O
len	int
;	O
FG	O
(	O
field	*(struct)
,	O
void	O
)	O
(	O
ps	*(struct)
,	O
&	O
str	*(char)
,	O
&	O
len	int
)	O
;	O
if	O
(	O
!	O
str	*(char)
||	O
len	int
==	O
0	int
)	O
str	*(char)
=	O
"-"	*(char)
;	O
return	O
ps_stream_write_trunc_field	()->(int)
(	O
stream	*(struct)
,	O
str	*(char)
,	O
field	*(struct)
->	O
width	int
)	O
;	O
}	O
error_t	O
ps_emit_tty_name	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
const	O
char	O
*	O
name	*(char)
=	O
"-"	*(char)
;	O
struct	O
ps_tty	O
*	O
tty	*(struct)
=	O
FG	O
(	O
field	*(struct)
,	O
struct	O
ps_tty	O
*	O
)	O
(	O
ps	*(struct)
)	O
;	O
if	O
(	O
tty	*(struct)
)	O
{	O
name	*(char)
=	O
ps_tty_short_name	()->(int)
(	O
tty	*(struct)
)	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
||	O
*	O
name	*(char)
==	O
'\0'	O
)	O
name	*(char)
=	O
"?"	*(char)
;	O
}	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
name	*(char)
,	O
field	*(struct)
->	O
width	int
)	O
;	O
}	O
struct	O
state_shadow	struct(int,int)
{	O
int	O
states	int
;	O
int	O
shadow	int
;	O
}	O
;	O
static	O
const	O
struct	O
state_shadow	struct(int,int)
state_shadows	array(struct(int,int))
[	O
]	O
=	O
{	O
{	O
PSTAT_STATE_P_NOPARENT	O
,	O
(	O
PSTAT_STATE_P_ATTRS	O
&	O
~	O
PSTAT_STATE_P_NOPARENT	O
)	O
}	O
,	O
{	O
PSTAT_STATE_T_RUN	O
|	O
PSTAT_STATE_P_STOP	O
,	O
PSTAT_STATE_T_SLEEP	O
|	O
PSTAT_STATE_T_IDLE	O
|	O
PSTAT_STATE_T_WAIT	O
}	O
,	O
{	O
PSTAT_STATE_T_IDLE	O
,	O
PSTAT_STATE_T_SLEEP	O
|	O
PSTAT_STATE_T_WAIT	O
}	O
,	O
{	O
PSTAT_STATE_T_SLEEP	O
,	O
PSTAT_STATE_T_WAIT	O
}	O
,	O
{	O
PSTAT_STATE_T_STATES	O
&	O
~	O
PSTAT_STATE_T_HALT	O
,	O
PSTAT_STATE_T_HALT	O
|	O
PSTAT_STATE_T_UNCLEAN	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
error_t	O
ps_emit_state	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
char	O
*	O
tags	*(char)
;	O
int	O
raw_state	int
=	O
FG	O
(	O
field	*(struct)
,	O
int	O
)	O
(	O
ps	*(struct)
)	O
;	O
int	O
state	int
=	O
raw_state	int
;	O
char	O
buf	array(char)
[	O
20	int
]	O
,	O
*	O
p	*(char)
=	O
buf	array(char)
;	O
const	O
struct	O
state_shadow	struct(int,int)
*	O
shadow	int
=	O
state_shadows	array(struct(int,int))
;	O
while	O
(	O
shadow	int
->	O
states	int
)	O
{	O
if	O
(	O
raw_state	int
&	O
shadow	int
->	O
states	int
)	O
state	int
&=	O
~	O
shadow	int
->	O
shadow	int
;	O
shadow	int
++	O
;	O
}	O
for	O
(	O
tags	*(char)
=	O
proc_stat_state_tags	O
;	O
state	int
!=	O
0	int
&&	O
*	O
tags	*(char)
!=	O
'\0'	O
;	O
state	int
>>=	O
1	int
,	O
tags	*(char)
++	O
)	O
if	O
(	O
state	int
&	O
1	int
)	O
*	O
p	*(char)
++	O
=	O
*	O
tags	*(char)
;	O
*	O
p	*(char)
=	O
'\0'	O
;	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
buf	array(char)
,	O
field	*(struct)
->	O
width	int
)	O
;	O
}	O
error_t	O
ps_emit_wait	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
struct	O
ps_fmt_field	O
*	O
field	*(struct)
,	O
struct	O
ps_stream	O
*	O
stream	*(struct)
)	O
{	O
int	O
rpc	*(int)
;	O
char	O
*	O
wait	*(*(char))
;	O
char	O
buf	array(char)
[	O
80	int
]	O
;	O
FG	O
(	O
field	*(struct)
,	O
void	O
)	O
(	O
ps	*(struct)
,	O
&	O
wait	*(*(char))
,	O
&	O
rpc	*(int)
)	O
;	O
if	O
(	O
wait	*(*(char))
==	O
0	int
)	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
"?"	*(char)
,	O
field	*(struct)
->	O
width	int
)	O
;	O
else	O
if	O
(	O
*	O
wait	*(*(char))
==	O
0	int
)	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
"-"	*(char)
,	O
field	*(struct)
->	O
width	int
)	O
;	O
else	O
if	O
(	O
strcmp	O
(	O
wait	*(*(char))
,	O
"kernel"	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
name	*(char)
=	O
get_syscall_name	(int)->(*(char))
(	O
rpc	*(int)
)	O
;	O
if	O
(	O
!	O
name	*(char)
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
"syscall:%d"	*(char)
,	O
-	O
rpc	*(int)
)	O
;	O
name	*(char)
=	O
buf	array(char)
;	O
}	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
name	*(char)
,	O
field	*(struct)
->	O
width	int
)	O
;	O
}	O
else	O
if	O
(	O
rpc	*(int)
)	O
{	O
char	O
port_name_buf	array(char)
[	O
20	int
]	O
;	O
char	O
*	O
name	*(char)
=	O
get_rpc_name	(int)->(*(char))
(	O
rpc	*(int)
)	O
;	O
if	O
(	O
strcmp	O
(	O
wait	*(*(char))
,	O
"init#0"	*(char)
)	O
==	O
0	int
)	O
wait	*(*(char))
=	O
"cwd"	*(char)
;	O
else	O
if	O
(	O
strcmp	O
(	O
wait	*(*(char))
,	O
"init#1"	*(char)
)	O
==	O
0	int
)	O
wait	*(*(char))
=	O
"root"	*(char)
;	O
else	O
if	O
(	O
strcmp	O
(	O
wait	*(*(char))
,	O
"init#2"	*(char)
)	O
==	O
0	int
)	O
wait	*(*(char))
=	O
"auth"	*(char)
;	O
else	O
if	O
(	O
strcmp	O
(	O
wait	*(*(char))
,	O
"init#3"	*(char)
)	O
==	O
0	int
)	O
wait	*(*(char))
=	O
"proc"	*(char)
;	O
else	O
if	O
(	O
strcmp	O
(	O
wait	*(*(char))
,	O
"init#4"	*(char)
)	O
==	O
0	int
)	O
wait	*(*(char))
=	O
"cttyid"	*(char)
;	O
else	O
if	O
(	O
strcmp	O
(	O
wait	*(*(char))
,	O
"init#5"	*(char)
)	O
==	O
0	int
)	O
wait	*(*(char))
=	O
"boot"	*(char)
;	O
else	O
{	O
char	O
*	O
abbrev	*(char)
=	O
0	int
,	O
*	O
num	int
=	O
0	int
;	O
if	O
(	O
strncmp	O
(	O
wait	*(*(char))
,	O
"fd#"	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
abbrev	*(char)
=	O
"fd"	*(char)
,	O
num	int
=	O
wait	*(*(char))
+	O
3	int
;	O
else	O
if	O
(	O
strncmp	O
(	O
wait	*(*(char))
,	O
"bgfd#"	*(char)
,	O
5	int
)	O
==	O
0	int
)	O
abbrev	*(char)
=	O
"bg"	*(char)
,	O
num	int
=	O
wait	*(*(char))
+	O
5	int
;	O
else	O
if	O
(	O
strncmp	O
(	O
wait	*(*(char))
,	O
"port#"	*(char)
,	O
5	int
)	O
==	O
0	int
)	O
abbrev	*(char)
=	O
""	*(char)
,	O
num	int
=	O
wait	*(*(char))
+	O
5	int
;	O
if	O
(	O
abbrev	*(char)
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
port_name_buf	array(char)
,	O
sizeof	O
port_name_buf	array(char)
,	O
"%s%s"	*(char)
,	O
abbrev	*(char)
,	O
num	int
)	O
;	O
wait	*(*(char))
=	O
port_name_buf	array(char)
;	O
}	O
}	O
if	O
(	O
name	*(char)
)	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	array(char)
,	O
sizeof	O
buf	array(char)
,	O
"%s:%s"	*(char)
,	O
wait	*(*(char))
,	O
name	*(char)
)	O
;	O
else	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	array(char)
,	O
sizeof	O
buf	array(char)
,	O
"%s:%d"	*(char)
,	O
wait	*(*(char))
,	O
rpc	*(int)
)	O
;	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
buf	array(char)
,	O
field	*(struct)
->	O
width	int
)	O
;	O
}	O
else	O
return	O
ps_stream_write_field	()->(int)
(	O
stream	*(struct)
,	O
wait	*(*(char))
,	O
field	*(struct)
->	O
width	int
)	O
;	O
}	O
int	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps1	*(struct)
,	O
struct	O
proc_stat	O
*	O
ps2	*(struct)
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
)	O
{	O
int	O
(	O
*	O
gf	*(()->(int))
)	O
(	O
)	O
=	O
G	O
(	O
getter	*(struct)
,	O
int	O
)	O
;	O
int	O
v1	int
=	O
gf	*(()->(int))
(	O
ps1	*(struct)
)	O
,	O
v2	int
=	O
gf	*(()->(int))
(	O
ps2	*(struct)
)	O
;	O
return	O
v1	int
==	O
v2	int
?	O
0	int
:	O
v1	int
<	O
v2	int
?	O
-	O
1	int
:	O
1	int
;	O
}	O
int	O
ps_cmp_floats	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps1	*(struct)
,	O
struct	O
proc_stat	O
*	O
ps2	*(struct)
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
)	O
{	O
float	O
(	O
*	O
gf	*(()->(int))
)	O
(	O
)	O
=	O
G	O
(	O
getter	*(struct)
,	O
float	O
)	O
;	O
float	O
v1	int
=	O
gf	*(()->(int))
(	O
ps1	*(struct)
)	O
,	O
v2	int
=	O
gf	*(()->(int))
(	O
ps2	*(struct)
)	O
;	O
return	O
v1	int
==	O
v2	int
?	O
0	int
:	O
v1	int
<	O
v2	int
?	O
-	O
1	int
:	O
1	int
;	O
}	O
int	O
ps_cmp_size_ts	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps1	*(struct)
,	O
struct	O
proc_stat	O
*	O
ps2	*(struct)
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
)	O
{	O
size_t	long
(	O
*	O
gf	*(()->(int))
)	O
(	O
)	O
=	O
G	O
(	O
getter	*(struct)
,	O
size_t	long
)	O
;	O
size_t	long
v1	int
=	O
gf	*(()->(int))
(	O
ps1	*(struct)
)	O
,	O
v2	int
=	O
gf	*(()->(int))
(	O
ps2	*(struct)
)	O
;	O
return	O
v1	int
==	O
v2	int
?	O
0	int
:	O
v1	int
<	O
v2	int
?	O
-	O
1	int
:	O
1	int
;	O
}	O
int	O
ps_cmp_uids	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps1	*(struct)
,	O
struct	O
proc_stat	O
*	O
ps2	*(struct)
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
)	O
{	O
struct	O
ps_user	O
*	O
(	O
*	O
gf	*(()->(int))
)	O
(	O
)	O
=	O
G	O
(	O
getter	*(struct)
,	O
struct	O
ps_user	O
*	O
)	O
;	O
struct	O
ps_user	O
*	O
u1	*(struct)
=	O
gf	*(()->(int))
(	O
ps1	*(struct)
)	O
,	O
*	O
u2	*(struct)
=	O
gf	*(()->(int))
(	O
ps2	*(struct)
)	O
;	O
return	O
(	O
u1	*(struct)
?	O
ps_user_uid	()->(int)
(	O
u1	*(struct)
)	O
:	O
-	O
1	int
)	O
-	O
(	O
u2	*(struct)
?	O
ps_user_uid	()->(int)
(	O
u2	*(struct)
)	O
:	O
-	O
1	int
)	O
;	O
}	O
int	O
ps_cmp_unames	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps1	*(struct)
,	O
struct	O
proc_stat	O
*	O
ps2	*(struct)
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
)	O
{	O
struct	O
ps_user	O
*	O
(	O
*	O
gf	*(()->(int))
)	O
(	O
)	O
=	O
G	O
(	O
getter	*(struct)
,	O
struct	O
ps_user	O
*	O
)	O
;	O
struct	O
ps_user	O
*	O
u1	*(struct)
=	O
gf	*(()->(int))
(	O
ps1	*(struct)
)	O
,	O
*	O
u2	*(struct)
=	O
gf	*(()->(int))
(	O
ps2	*(struct)
)	O
;	O
struct	O
passwd	O
*	O
pw1	*(struct)
=	O
u1	*(struct)
?	O
ps_user_passwd	()->(int)
(	O
u1	*(struct)
)	O
:	O
0	int
;	O
struct	O
passwd	O
*	O
pw2	*(struct)
=	O
u2	*(struct)
?	O
ps_user_passwd	()->(int)
(	O
u2	*(struct)
)	O
:	O
0	int
;	O
return	O
GUARDED_CMP	O
(	O
pw1	*(struct)
,	O
pw2	*(struct)
,	O
strcmp	O
(	O
pw1	*(struct)
->	O
pw_name	O
,	O
pw2	*(struct)
->	O
pw_name	O
)	O
)	O
;	O
}	O
int	O
ps_cmp_strings	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps1	*(struct)
,	O
struct	O
proc_stat	O
*	O
ps2	*(struct)
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
)	O
{	O
void	O
(	O
*	O
gf	*(()->(int))
)	O
(	O
)	O
=	O
G	O
(	O
getter	*(struct)
,	O
void	O
)	O
;	O
char	O
*	O
s1	*(char)
,	O
*	O
s2	*(char)
;	O
int	O
s1len	int
,	O
s2len	int
;	O
gf	*(()->(int))
(	O
ps1	*(struct)
,	O
&	O
s1	*(char)
,	O
&	O
s1len	int
)	O
;	O
gf	*(()->(int))
(	O
ps2	*(struct)
,	O
&	O
s2	*(char)
,	O
&	O
s2len	int
)	O
;	O
return	O
GUARDED_CMP	O
(	O
s1	*(char)
,	O
s2	*(char)
,	O
strncmp	O
(	O
s1	*(char)
,	O
s2	*(char)
,	O
MIN	()->(int)
(	O
s1len	int
,	O
s2len	int
)	O
)	O
)	O
;	O
}	O
int	O
ps_cmp_times	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps1	*(struct)
,	O
struct	O
proc_stat	O
*	O
ps2	*(struct)
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
)	O
{	O
void	O
(	O
*	O
g	*(()->(void))
)	O
(	O
)	O
=	O
G	O
(	O
getter	*(struct)
,	O
void	O
)	O
;	O
struct	O
timeval	O
tv1	struct
,	O
tv2	struct
;	O
g	*(()->(void))
(	O
ps1	*(struct)
,	O
&	O
tv1	struct
)	O
;	O
g	*(()->(void))
(	O
ps2	*(struct)
,	O
&	O
tv2	struct
)	O
;	O
return	O
tv1	struct
.	O
tv_sec	O
>	O
tv2	struct
.	O
tv_sec	O
?	O
1	int
:	O
tv1	struct
.	O
tv_sec	O
<	O
tv2	struct
.	O
tv_sec	O
?	O
-	O
1	int
:	O
tv1	struct
.	O
tv_usec	O
>	O
tv2	struct
.	O
tv_usec	O
?	O
1	int
:	O
tv2	struct
.	O
tv_usec	O
<	O
tv2	struct
.	O
tv_usec	O
?	O
-	O
1	int
:	O
0	int
;	O
}	O
int	O
ps_nominal_zint	(*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
)	O
{	O
return	O
G	O
(	O
getter	*(struct)
,	O
int	O
)	O
(	O
ps	*(struct)
)	O
==	O
0	int
;	O
}	O
int	O
ps_nominal_string	(*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
)	O
{	O
char	O
*	O
str	*(char)
;	O
size_t	long
len	int
;	O
G	O
(	O
getter	*(struct)
,	O
char	O
*	O
)	O
(	O
ps	*(struct)
,	O
&	O
str	*(char)
,	O
&	O
len	int
)	O
;	O
return	O
!	O
str	*(char)
||	O
len	int
==	O
0	int
||	O
(	O
len	int
==	O
1	int
&&	O
*	O
str	*(char)
==	O
'-'	O
)	O
;	O
}	O
int	O
ps_nominal_pri	(*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
)	O
{	O
return	O
MACH_PRIORITY_TO_NICE	()->(int)
(	O
G	O
(	O
getter	*(struct)
,	O
int	O
)	O
(	O
ps	*(struct)
)	O
)	O
==	O
0	int
;	O
}	O
int	O
ps_nominal_nth	(*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
)	O
{	O
return	O
G	O
(	O
getter	*(struct)
,	O
int	O
)	O
(	O
ps	*(struct)
)	O
==	O
2	int
;	O
}	O
static	O
int	O
own_uid	int
=	O
-	O
2	int
;	O
int	O
ps_nominal_user	(*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
)	O
{	O
struct	O
ps_user	O
*	O
u	*(struct)
=	O
G	O
(	O
getter	*(struct)
,	O
struct	O
ps_user	O
*	O
)	O
(	O
ps	*(struct)
)	O
;	O
if	O
(	O
own_uid	int
==	O
-	O
2	int
)	O
own_uid	int
=	O
getuid	()->(int)
(	O
)	O
;	O
return	O
own_uid	int
>=	O
0	int
&&	O
u	*(struct)
&&	O
u	*(struct)
->	O
uid	int
==	O
own_uid	int
;	O
}	O
int	O
ps_nominal_uid	(*(struct),*(struct))->(int)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
const	O
struct	O
ps_getter	O
*	O
getter	*(struct)
)	O
{	O
uid_t	O
uid	int
=	O
G	O
(	O
getter	*(struct)
,	O
uid_t	O
)	O
(	O
ps	*(struct)
)	O
;	O
if	O
(	O
own_uid	int
==	O
-	O
2	int
)	O
own_uid	int
=	O
getuid	()->(int)
(	O
)	O
;	O
return	O
own_uid	int
>=	O
0	int
&&	O
uid	int
==	O
own_uid	int
;	O
}	O
static	O
const	O
struct	O
ps_fmt_spec	O
*	O
specv_find	(*(struct),*(char),*(*(char)))->(*(struct))
(	O
const	O
struct	O
ps_fmt_spec	O
*	O
specs	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
*	O
aliased_to	*(*(char))
)	O
{	O
while	O
(	O
!	O
ps_fmt_spec_is_end	()->(int)
(	O
specs	*(struct)
)	O
)	O
{	O
char	O
*	O
alias	*(char)
=	O
index	O
(	O
specs	*(struct)
->	O
name	*(char)
,	O
'='	O
)	O
;	O
if	O
(	O
alias	*(char)
)	O
{	O
unsigned	O
name_len	int
=	O
strlen	O
(	O
name	*(char)
)	O
;	O
if	O
(	O
name_len	int
==	O
alias	*(char)
-	O
specs	*(struct)
->	O
name	*(char)
&&	O
strncasecmp	O
(	O
name	*(char)
,	O
specs	*(struct)
->	O
name	*(char)
,	O
name_len	int
)	O
==	O
0	int
)	O
{	O
*	O
aliased_to	*(*(char))
=	O
alias	*(char)
+	O
1	int
;	O
return	O
specs	*(struct)
;	O
}	O
}	O
else	O
if	O
(	O
strcasecmp	O
(	O
specs	*(struct)
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
specs	*(struct)
;	O
specs	*(struct)
++	O
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
ps_fmt_spec_block	struct(*(struct(*(struct(*(struct`),int)),int)),int)
{	O
struct	O
ps_fmt_spec_block	struct(*(struct(*(struct(*(struct`),int)),int)),int)
*	O
next	*(struct(*(struct(*(struct`),int)),int))
;	O
struct	O
ps_fmt_spec	O
specs	*(struct)
[	O
EXP_BLOCK_SIZE	int
]	O
;	O
}	O
;	O
struct	O
ps_fmt_spec	O
*	O
specs_add_alias	(*(struct),*(struct),*(struct))->(*(struct))
(	O
struct	O
ps_fmt_specs	O
*	O
specs	*(struct)
,	O
const	O
struct	O
ps_fmt_spec	O
*	O
alias	*(char)
,	O
const	O
struct	O
ps_fmt_spec	O
*	O
src	*(struct)
)	O
{	O
struct	O
ps_fmt_spec	O
*	O
exp	*(struct)
;	O
struct	O
ps_fmt_spec_block	struct(*(struct(*(struct(*(struct`),int)),int)),int)
*	O
block	*(struct(*(struct(*(struct`),int)),int))
;	O
char	O
*	O
name_end	*(char)
=	O
index	O
(	O
alias	*(char)
->	O
name	*(char)
,	O
'='	O
)	O
;	O
size_t	long
name_len	int
=	O
name_end	*(char)
?	O
name_end	*(char)
-	O
alias	*(char)
->	O
name	*(char)
:	O
strlen	O
(	O
alias	*(char)
->	O
name	*(char)
)	O
;	O
for	O
(	O
block	*(struct(*(struct(*(struct`),int)),int))
=	O
specs	*(struct)
->	O
expansions	O
;	O
block	*(struct(*(struct(*(struct`),int)),int))
;	O
block	*(struct(*(struct(*(struct`),int)),int))
=	O
block	*(struct(*(struct(*(struct`),int)),int))
->	O
next	*(struct(*(struct(*(struct`),int)),int))
)	O
{	O
exp	*(struct)
=	O
block	*(struct(*(struct(*(struct`),int)),int))
->	O
specs	*(struct)
;	O
while	O
(	O
!	O
ps_fmt_spec_is_end	()->(int)
(	O
exp	*(struct)
)	O
)	O
exp	*(struct)
++	O
;	O
if	O
(	O
exp	*(struct)
+	O
1	int
<	O
block	*(struct(*(struct(*(struct`),int)),int))
->	O
specs	*(struct)
+	O
EXP_BLOCK_SIZE	int
)	O
break	O
;	O
}	O
if	O
(	O
!	O
block	*(struct(*(struct(*(struct`),int)),int))
)	O
{	O
block	*(struct(*(struct(*(struct`),int)),int))
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
ps_fmt_spec_block	struct(*(struct(*(struct(*(struct`),int)),int)),int)
)	O
)	O
;	O
if	O
(	O
!	O
block	*(struct(*(struct(*(struct`),int)),int))
)	O
return	O
0	int
;	O
block	*(struct(*(struct(*(struct`),int)),int))
->	O
next	*(struct(*(struct(*(struct`),int)),int))
=	O
specs	*(struct)
->	O
expansions	O
;	O
specs	*(struct)
->	O
expansions	O
=	O
block	*(struct(*(struct(*(struct`),int)),int))
;	O
exp	*(struct)
=	O
block	*(struct(*(struct(*(struct`),int)),int))
->	O
specs	*(struct)
;	O
}	O
exp	*(struct)
->	O
name	*(char)
=	O
malloc	O
(	O
name_len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
exp	*(struct)
->	O
name	*(char)
)	O
return	O
0	int
;	O
bcopy	()->(int)
(	O
(	O
char	O
*	O
)	O
alias	*(char)
->	O
name	*(char)
,	O
(	O
char	O
*	O
)	O
exp	*(struct)
->	O
name	*(char)
,	O
name_len	int
)	O
;	O
(	O
(	O
char	O
*	O
)	O
exp	*(struct)
->	O
name	*(char)
)	O
[	O
name_len	int
]	O
=	O
'\0'	O
;	O
exp	*(struct)
->	O
title	O
=	O
alias	*(char)
->	O
title	O
?	O
:	O
src	*(struct)
->	O
title	O
;	O
exp	*(struct)
->	O
width	int
=	O
alias	*(char)
->	O
width	int
?	O
:	O
src	*(struct)
->	O
width	int
;	O
exp	*(struct)
->	O
precision	O
=	O
alias	*(char)
->	O
precision	O
>=	O
0	int
?	O
alias	*(char)
->	O
precision	O
:	O
src	*(struct)
->	O
precision	O
;	O
exp	*(struct)
->	O
flags	O
=	O
src	*(struct)
->	O
flags	O
^	O
alias	*(char)
->	O
flags	O
;	O
exp	*(struct)
->	O
getter	*(struct)
=	O
alias	*(char)
->	O
getter	*(struct)
?	O
:	O
src	*(struct)
->	O
getter	*(struct)
;	O
exp	*(struct)
->	O
output_fn	O
=	O
alias	*(char)
->	O
output_fn	O
?	O
:	O
src	*(struct)
->	O
output_fn	O
;	O
exp	*(struct)
->	O
cmp_fn	O
=	O
alias	*(char)
->	O
cmp_fn	O
?	O
:	O
src	*(struct)
->	O
cmp_fn	O
;	O
exp	*(struct)
->	O
nominal_fn	O
=	O
alias	*(char)
->	O
nominal_fn	O
?	O
:	O
src	*(struct)
->	O
nominal_fn	O
;	O
memset	O
(	O
exp	*(struct)
+	O
1	int
,	O
0	int
,	O
sizeof	O
(	O
*	O
exp	*(struct)
)	O
)	O
;	O
return	O
exp	*(struct)
;	O
}	O
const	O
struct	O
ps_fmt_spec	O
*	O
ps_fmt_specs_find	(*(struct),*(char))->(*(struct))
(	O
struct	O
ps_fmt_specs	O
*	O
specs	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
specs	*(struct)
)	O
{	O
struct	O
ps_fmt_spec_block	struct(*(struct(*(struct(*(struct`),int)),int)),int)
*	O
block	*(struct(*(struct(*(struct`),int)),int))
;	O
char	O
*	O
aliased_to	*(*(char))
=	O
0	int
;	O
const	O
struct	O
ps_fmt_spec	O
*	O
s	*(struct)
=	O
0	int
;	O
for	O
(	O
block	*(struct(*(struct(*(struct`),int)),int))
=	O
specs	*(struct)
->	O
expansions	O
;	O
block	*(struct(*(struct(*(struct`),int)),int))
&&	O
!	O
s	*(struct)
;	O
block	*(struct(*(struct(*(struct`),int)),int))
=	O
block	*(struct(*(struct(*(struct`),int)),int))
->	O
next	*(struct(*(struct(*(struct`),int)),int))
)	O
s	*(struct)
=	O
specv_find	(*(struct),*(char),*(*(char)))->(*(struct))
(	O
block	*(struct(*(struct(*(struct`),int)),int))
->	O
specs	*(struct)
,	O
name	*(char)
,	O
&	O
aliased_to	*(*(char))
)	O
;	O
if	O
(	O
!	O
s	*(struct)
)	O
s	*(struct)
=	O
specv_find	(*(struct),*(char),*(*(char)))->(*(struct))
(	O
specs	*(struct)
->	O
specs	*(struct)
,	O
name	*(char)
,	O
&	O
aliased_to	*(*(char))
)	O
;	O
if	O
(	O
s	*(struct)
)	O
{	O
if	O
(	O
aliased_to	*(*(char))
)	O
{	O
const	O
struct	O
ps_fmt_spec	O
*	O
src	*(struct)
;	O
if	O
(	O
strcasecmp	O
(	O
name	*(char)
,	O
aliased_to	*(*(char))
)	O
==	O
0	int
)	O
src	*(struct)
=	O
ps_fmt_specs_find	(*(struct),*(char))->(*(struct))
(	O
specs	*(struct)
->	O
parent	O
,	O
aliased_to	*(*(char))
)	O
;	O
else	O
src	*(struct)
=	O
ps_fmt_specs_find	(*(struct),*(char))->(*(struct))
(	O
specs	*(struct)
,	O
aliased_to	*(*(char))
)	O
;	O
if	O
(	O
!	O
src	*(struct)
)	O
return	O
0	int
;	O
s	*(struct)
=	O
specs_add_alias	(*(struct),*(struct),*(struct))->(*(struct))
(	O
specs	*(struct)
,	O
s	*(struct)
,	O
src	*(struct)
)	O
;	O
}	O
}	O
else	O
s	*(struct)
=	O
ps_fmt_specs_find	(*(struct),*(char))->(*(struct))
(	O
specs	*(struct)
->	O
parent	O
,	O
name	*(char)
)	O
;	O
return	O
s	*(struct)
;	O
}	O
else	O
return	O
0	int
;	O
}	O
static	O
const	O
struct	O
ps_fmt_spec	O
specs	*(struct)
[	O
]	O
=	O
{	O
{	O
"PID"	*(char)
,	O
0	int
,	O
-	O
5	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_pid_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
"TH"	*(char)
,	O
"TH#"	*(char)
,	O
-	O
2	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_thread_index_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
"PPID"	*(char)
,	O
0	int
,	O
-	O
5	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_ppid_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
"UID"	*(char)
,	O
0	int
,	O
-	O
4	int
,	O
-	O
1	int
,	O
PS_FMT_FIELD_KEEP	O
,	O
&	O
ps_owner_uid_getter	struct
,	O
ps_emit_uid	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_uid	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"User"	*(char)
,	O
0	int
,	O
8	int
,	O
-	O
1	int
,	O
PS_FMT_FIELD_KEEP	O
,	O
&	O
ps_owner_getter	struct
,	O
ps_emit_uname	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_unames	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_user	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"NTh"	*(char)
,	O
0	int
,	O
-	O
2	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_num_threads_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_nth	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"PGrp"	*(char)
,	O
0	int
,	O
-	O
5	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_pgrp_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
"Sess"	*(char)
,	O
0	int
,	O
-	O
5	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_session_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
"LColl"	*(char)
,	O
0	int
,	O
-	O
5	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_login_col_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
"Args"	*(char)
,	O
0	int
,	O
0	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_args_getter	struct
,	O
ps_emit_args	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_strings	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_string	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"Arg0"	*(char)
,	O
0	int
,	O
0	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_args_getter	struct
,	O
ps_emit_string	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_strings	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_string	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"Env"	*(char)
,	O
0	int
,	O
0	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_env_getter	struct
,	O
ps_emit_args	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_strings	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_string	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"Start"	*(char)
,	O
0	int
,	O
-	O
7	int
,	O
1	int
,	O
0	int
,	O
&	O
ps_start_time_getter	struct
,	O
ps_emit_past_time	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_times	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
"Time"	*(char)
,	O
0	int
,	O
-	O
8	int
,	O
2	int
,	O
0	int
,	O
&	O
ps_tot_time_getter	struct
,	O
ps_emit_seconds	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_times	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
"UTime"	*(char)
,	O
0	int
,	O
-	O
8	int
,	O
2	int
,	O
0	int
,	O
&	O
ps_usr_time_getter	struct
,	O
ps_emit_seconds	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_times	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
"STime"	*(char)
,	O
0	int
,	O
-	O
8	int
,	O
2	int
,	O
0	int
,	O
&	O
ps_sys_time_getter	struct
,	O
ps_emit_seconds	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_times	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
"VSize"	*(char)
,	O
0	int
,	O
-	O
5	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_vsize_getter	struct
,	O
ps_emit_nice_size_t	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_size_ts	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
"RSize"	*(char)
,	O
0	int
,	O
-	O
5	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_rsize_getter	struct
,	O
ps_emit_nice_size_t	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_size_ts	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
"Pri"	*(char)
,	O
0	int
,	O
-	O
3	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_cur_priority_getter	struct
,	O
ps_emit_priority	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_pri	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"BPri"	*(char)
,	O
0	int
,	O
-	O
3	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_base_priority_getter	struct
,	O
ps_emit_priority	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_pri	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"MPri"	*(char)
,	O
0	int
,	O
-	O
3	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_max_priority_getter	struct
,	O
ps_emit_priority	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_pri	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"Mem"	*(char)
,	O
"%Mem"	*(char)
,	O
-	O
4	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_rmem_frac_getter	struct
,	O
ps_emit_percent	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_floats	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
"CPU"	*(char)
,	O
"%CPU"	*(char)
,	O
-	O
4	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_cpu_frac_getter	struct
,	O
ps_emit_percent	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_floats	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
"State"	*(char)
,	O
0	int
,	O
4	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_state_getter	struct
,	O
ps_emit_state	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"Wait"	*(char)
,	O
0	int
,	O
10	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_wait_getter	struct
,	O
ps_emit_wait	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"Sleep"	*(char)
,	O
0	int
,	O
-	O
2	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_sleep_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_zint	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"Susp"	*(char)
,	O
0	int
,	O
-	O
2	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_susp_count_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_zint	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"PSusp"	*(char)
,	O
0	int
,	O
-	O
2	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_proc_susp_count_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_zint	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"TSusp"	*(char)
,	O
0	int
,	O
-	O
2	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_thread_susp_count_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_zint	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"TTY"	*(char)
,	O
0	int
,	O
-	O
2	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_tty_getter	struct
,	O
ps_emit_tty_name	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_strings	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
"PgFlts"	*(char)
,	O
0	int
,	O
-	O
5	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_page_faults_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_zint	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"COWFlts"	*(char)
,	O
0	int
,	O
-	O
5	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_cow_faults_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_zint	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"PgIns"	*(char)
,	O
0	int
,	O
-	O
5	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_pageins_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_zint	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"MsgIn"	*(char)
,	O
0	int
,	O
-	O
5	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_msgs_rcvd_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_zint	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"MsgOut"	*(char)
,	O
0	int
,	O
-	O
5	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_msgs_sent_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_zint	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"ZFills"	*(char)
,	O
0	int
,	O
-	O
5	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_zero_fills_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
ps_nominal_zint	(*(struct),*(struct))->(int)
}	O
,	O
{	O
"Ports"	*(char)
,	O
0	int
,	O
-	O
5	int
,	O
-	O
1	int
,	O
0	int
,	O
&	O
ps_num_ports_getter	struct
,	O
ps_emit_int	(*(struct),*(struct),*(struct))->(int)
,	O
ps_cmp_ints	(*(struct),*(struct),*(struct))->(int)
,	O
0	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
struct	O
ps_fmt_specs	O
ps_std_fmt_specs	struct
=	O
{	O
specs	*(struct)
,	O
0	int
}	O
;	O
