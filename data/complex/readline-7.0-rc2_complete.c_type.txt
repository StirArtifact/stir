typedef	O
int	O
QSFUNC	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
;	O
extern	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
getpwent	()->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
rl_compdisp_func_t	(*(*(char)),int,int)->(void)
*	O
rl_completion_display_matches_hook	*((*(*(char)),int,int)->(void))
=	O
(	O
rl_compdisp_func_t	(*(*(char)),int,int)->(void)
*	O
)	O
NULL	O
;	O
static	O
int	O
stat_char	(*(char))->(int)
PARAMS	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
colored_stat_start	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
colored_stat_end	()->(void)
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
colored_prefix_start	()->(int)
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
colored_prefix_end	()->(void)
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
path_isdir	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
rl_quote_filename	(*(char),int,*(char))->(*(char))
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
_rl_complete_sigcleanup	(int,*(void))->(void)
PARAMS	O
(	O
(	O
int	O
,	O
void	O
*	O
)	O
)	O
;	O
static	O
void	O
set_completion_defaults	(int)->(void)
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
get_y_or_n	(int)->(int)
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
_rl_internal_pager	(int)->(int)
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
char	O
*	O
printable_part	(*(char))->(*(char))
PARAMS	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
fnwidth	(*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
fnprint	(*(char),int,*(char))->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
,	O
int	O
,	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
print_filename	(*(char),*(char),int)->(int)
PARAMS	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
char	O
*	O
*	O
gen_completion_matches	(*(char),int,int,*((*(char),int)->(*(char))),int,int)->(*(*(char)))
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
,	O
rl_compentry_func_t	(*(char),int)->(*(char))
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
char	O
*	O
*	O
remove_duplicate_matches	(*(*(char)))->(*(*(char)))
PARAMS	O
(	O
(	O
char	O
*	O
*	O
)	O
)	O
;	O
static	O
void	O
insert_match	(*(char),int,int,*(char))->(void)
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
append_to_match	(*(char),int,int,int)->(int)
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
insert_all_matches	(*(*(char)),int,*(char))->(void)
PARAMS	O
(	O
(	O
char	O
*	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
complete_fncmp	(*(char),int,*(char),int)->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
,	O
int	O
,	O
const	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
display_matches	(*(*(char)))->(void)
PARAMS	O
(	O
(	O
char	O
*	O
*	O
)	O
)	O
;	O
static	O
int	O
compute_lcd_of_matches	(*(*(char)),int,*(char))->(int)
PARAMS	O
(	O
(	O
char	O
*	O
*	O
,	O
int	O
,	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
postprocess_matches	(*(*(*(char))),int)->(int)
PARAMS	O
(	O
(	O
char	O
*	O
*	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
complete_get_screenwidth	()->(int)
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
char	O
*	O
make_quoted_replacement	(*(char),int,*(char))->(*(char))
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
int	O
_rl_complete_show_all	int
=	O
0	int
;	O
int	O
_rl_complete_show_unmodified	int
=	O
0	int
;	O
int	O
_rl_complete_mark_directories	int
=	O
1	int
;	O
int	O
_rl_complete_mark_symlink_dirs	int
=	O
0	int
;	O
int	O
_rl_print_completions_horizontally	int
;	O
int	O
_rl_completion_case_fold	int
=	O
0	int
;	O
int	O
_rl_completion_case_map	int
=	O
0	int
;	O
int	O
_rl_match_hidden_files	int
=	O
1	int
;	O
int	O
_rl_completion_prefix_display_length	int
=	O
0	int
;	O
int	O
_rl_completion_columns	int
=	O
-	O
1	int
;	O
int	O
rl_visible_stats	int
=	O
0	int
;	O
int	O
_rl_colored_stats	int
=	O
0	int
;	O
int	O
_rl_colored_completion_prefix	int
=	O
0	int
;	O
int	O
_rl_skip_completed_text	int
=	O
0	int
;	O
int	O
_rl_menu_complete_prefix_first	int
=	O
0	int
;	O
rl_icppfunc_t	(*(*(char)))->(int)
*	O
rl_directory_completion_hook	*((*(*(char)))->(int))
=	O
(	O
rl_icppfunc_t	(*(*(char)))->(int)
*	O
)	O
NULL	O
;	O
rl_icppfunc_t	(*(*(char)))->(int)
*	O
rl_directory_rewrite_hook	*((*(*(char)))->(int))
=	O
(	O
rl_icppfunc_t	(*(*(char)))->(int)
*	O
)	O
NULL	O
;	O
rl_icppfunc_t	(*(*(char)))->(int)
*	O
rl_filename_stat_hook	*((*(*(char)))->(int))
=	O
(	O
rl_icppfunc_t	(*(*(char)))->(int)
*	O
)	O
NULL	O
;	O
rl_dequote_func_t	(*(char),int)->(*(char))
*	O
rl_filename_rewrite_hook	*((*(char),int)->(*(char)))
=	O
(	O
rl_dequote_func_t	(*(char),int)->(*(char))
*	O
)	O
NULL	O
;	O
int	O
rl_complete_with_tilde_expansion	int
=	O
0	int
;	O
rl_compentry_func_t	(*(char),int)->(*(char))
*	O
rl_completion_entry_function	*((*(char),int)->(*(char)))
=	O
(	O
rl_compentry_func_t	(*(char),int)->(*(char))
*	O
)	O
NULL	O
;	O
rl_compentry_func_t	(*(char),int)->(*(char))
*	O
rl_menu_completion_entry_function	*((*(char),int)->(*(char)))
=	O
(	O
rl_compentry_func_t	(*(char),int)->(*(char))
*	O
)	O
NULL	O
;	O
rl_completion_func_t	(*(char),int,int)->(*(*(char)))
*	O
rl_attempted_completion_function	*((*(char),int,int)->(*(*(char))))
=	O
(	O
rl_completion_func_t	(*(char),int,int)->(*(*(char)))
*	O
)	O
NULL	O
;	O
int	O
rl_attempted_completion_over	int
=	O
0	int
;	O
int	O
rl_completion_type	int
=	O
0	int
;	O
int	O
rl_completion_query_items	int
=	O
100	int
;	O
int	O
_rl_page_completions	int
=	O
1	int
;	O
const	O
char	O
*	O
rl_basic_word_break_characters	*(char)
=	O
" \t\n\"\\'`@$><=;|&{("	*(char)
;	O
const	O
char	O
*	O
rl_basic_quote_characters	*(char)
=	O
"\"'"	*(char)
;	O
char	O
*	O
rl_completer_word_break_characters	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
rl_cpvfunc_t	()->(*(char))
*	O
rl_completion_word_break_hook	*(()->(*(char)))
=	O
(	O
rl_cpvfunc_t	()->(*(char))
*	O
)	O
NULL	O
;	O
const	O
char	O
*	O
rl_completer_quote_characters	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
NULL	O
;	O
const	O
char	O
*	O
rl_filename_quote_characters	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
NULL	O
;	O
const	O
char	O
*	O
rl_special_prefixes	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
NULL	O
;	O
int	O
rl_ignore_completion_duplicates	int
=	O
1	int
;	O
int	O
rl_filename_completion_desired	int
=	O
0	int
;	O
int	O
rl_filename_quoting_desired	int
=	O
1	int
;	O
rl_compignore_func_t	(*(*(char)))->(int)
*	O
rl_ignore_some_completions_function	*((*(*(char)))->(int))
=	O
(	O
rl_compignore_func_t	(*(*(char)))->(int)
*	O
)	O
NULL	O
;	O
rl_quote_func_t	(*(char),int,*(char))->(*(char))
*	O
rl_filename_quoting_function	*((*(char),int,*(char))->(*(char)))
=	O
rl_quote_filename	(*(char),int,*(char))->(*(char))
;	O
rl_dequote_func_t	(*(char),int)->(*(char))
*	O
rl_filename_dequoting_function	*((*(char),int)->(*(char)))
=	O
(	O
rl_dequote_func_t	(*(char),int)->(*(char))
*	O
)	O
NULL	O
;	O
rl_linebuf_func_t	(*(char),int)->(int)
*	O
rl_char_is_quoted_p	*((*(char),int)->(int))
=	O
(	O
rl_linebuf_func_t	(*(char),int)->(int)
*	O
)	O
NULL	O
;	O
int	O
rl_completion_suppress_append	int
=	O
0	int
;	O
int	O
rl_completion_append_character	int
=	O
' '	O
;	O
int	O
rl_completion_suppress_quote	int
=	O
0	int
;	O
int	O
rl_completion_quote_character	int
;	O
int	O
rl_completion_found_quote	int
;	O
int	O
rl_completion_mark_symlink_dirs	int
;	O
int	O
rl_inhibit_completion	int
;	O
int	O
rl_completion_invoking_key	int
;	O
int	O
rl_sort_completion_matches	int
=	O
1	int
;	O
static	O
int	O
completion_changed_buffer	int
;	O
static	O
int	O
completion_y_or_n	int
;	O
static	O
int	O
_rl_complete_display_matches_interrupt	int
=	O
0	int
;	O
int	O
rl_complete	(int,int)->(int)
(	O
ignore	int
,	O
invoking_key	int
)	O
int	O
ignore	int
,	O
invoking_key	int
;	O
{	O
rl_completion_invoking_key	int
=	O
invoking_key	int
;	O
if	O
(	O
rl_inhibit_completion	int
)	O
return	O
(	O
_rl_insert_char	(int,int)->(int)
(	O
ignore	int
,	O
invoking_key	int
)	O
)	O
;	O
else	O
if	O
(	O
rl_last_func	*((int,int)->(int))
==	O
rl_complete	(int,int)->(int)
&&	O
!	O
completion_changed_buffer	int
)	O
return	O
(	O
rl_complete_internal	(int)->(int)
(	O
'?'	O
)	O
)	O
;	O
else	O
if	O
(	O
_rl_complete_show_all	int
)	O
return	O
(	O
rl_complete_internal	(int)->(int)
(	O
'!'	O
)	O
)	O
;	O
else	O
if	O
(	O
_rl_complete_show_unmodified	int
)	O
return	O
(	O
rl_complete_internal	(int)->(int)
(	O
'@'	O
)	O
)	O
;	O
else	O
return	O
(	O
rl_complete_internal	(int)->(int)
(	O
TAB	char
)	O
)	O
;	O
}	O
int	O
rl_possible_completions	(int,int)->(int)
(	O
ignore	int
,	O
invoking_key	int
)	O
int	O
ignore	int
,	O
invoking_key	int
;	O
{	O
rl_completion_invoking_key	int
=	O
invoking_key	int
;	O
return	O
(	O
rl_complete_internal	(int)->(int)
(	O
'?'	O
)	O
)	O
;	O
}	O
int	O
rl_insert_completions	(int,int)->(int)
(	O
ignore	int
,	O
invoking_key	int
)	O
int	O
ignore	int
,	O
invoking_key	int
;	O
{	O
rl_completion_invoking_key	int
=	O
invoking_key	int
;	O
return	O
(	O
rl_complete_internal	(int)->(int)
(	O
'*'	O
)	O
)	O
;	O
}	O
int	O
rl_completion_mode	(*((int,int)->(int)))->(int)
(	O
cfunc	*((int,int)->(int))
)	O
rl_command_func_t	(int,int)->(int)
*	O
cfunc	*((int,int)->(int))
;	O
{	O
if	O
(	O
rl_last_func	*((int,int)->(int))
==	O
cfunc	*((int,int)->(int))
&&	O
!	O
completion_changed_buffer	int
)	O
return	O
'?'	O
;	O
else	O
if	O
(	O
_rl_complete_show_all	int
)	O
return	O
'!'	O
;	O
else	O
if	O
(	O
_rl_complete_show_unmodified	int
)	O
return	O
'@'	O
;	O
else	O
return	O
TAB	char
;	O
}	O
void	O
_rl_reset_completion_state	()->(void)
(	O
)	O
{	O
rl_completion_found_quote	int
=	O
0	int
;	O
rl_completion_quote_character	int
=	O
0	int
;	O
}	O
static	O
void	O
_rl_complete_sigcleanup	(int,*(void))->(void)
(	O
sig	int
,	O
ptr	*(void)
)	O
int	O
sig	int
;	O
void	O
*	O
ptr	*(void)
;	O
{	O
if	O
(	O
sig	int
==	O
SIGINT	int
)	O
{	O
_rl_free_match_list	(*(*(char)))->(void)
(	O
(	O
char	O
*	O
*	O
)	O
ptr	*(void)
)	O
;	O
_rl_complete_display_matches_interrupt	int
=	O
1	int
;	O
}	O
}	O
static	O
void	O
set_completion_defaults	(int)->(void)
(	O
what_to_do	int
)	O
int	O
what_to_do	int
;	O
{	O
rl_filename_completion_desired	int
=	O
0	int
;	O
rl_filename_quoting_desired	int
=	O
1	int
;	O
rl_completion_type	int
=	O
what_to_do	int
;	O
rl_completion_suppress_append	int
=	O
rl_completion_suppress_quote	int
=	O
0	int
;	O
rl_completion_append_character	int
=	O
' '	O
;	O
rl_completion_mark_symlink_dirs	int
=	O
_rl_complete_mark_symlink_dirs	int
;	O
_rl_complete_display_matches_interrupt	int
=	O
0	int
;	O
}	O
static	O
int	O
get_y_or_n	(int)->(int)
(	O
for_pager	int
)	O
int	O
for_pager	int
;	O
{	O
int	O
c	int
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
return	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
c	int
=	O
rl_read_key	()->(int)
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
if	O
(	O
c	int
==	O
'y'	O
||	O
c	int
==	O
'Y'	O
||	O
c	int
==	O
' '	O
)	O
return	O
(	O
1	int
)	O
;	O
if	O
(	O
c	int
==	O
'n'	O
||	O
c	int
==	O
'N'	O
||	O
c	int
==	O
RUBOUT	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
c	int
==	O
ABORT_CHAR	O
||	O
c	int
<	O
0	int
)	O
_rl_abort_internal	()->(int)
(	O
)	O
;	O
if	O
(	O
for_pager	int
&&	O
(	O
c	int
==	O
NEWLINE	char
||	O
c	int
==	O
RETURN	O
)	O
)	O
return	O
(	O
2	int
)	O
;	O
if	O
(	O
for_pager	int
&&	O
(	O
c	int
==	O
'q'	O
||	O
c	int
==	O
'Q'	O
)	O
)	O
return	O
(	O
0	int
)	O
;	O
rl_ding	()->(int)
(	O
)	O
;	O
}	O
}	O
static	O
int	O
_rl_internal_pager	(int)->(int)
(	O
lines	*(*(char))
)	O
int	O
lines	*(*(char))
;	O
{	O
int	O
i	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"--More--"	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
i	int
=	O
get_y_or_n	(int)->(int)
(	O
1	int
)	O
;	O
_rl_erase_entire_line	()->(void)
(	O
)	O
;	O
if	O
(	O
i	int
==	O
0	int
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
i	int
==	O
2	int
)	O
return	O
(	O
lines	*(*(char))
-	O
1	int
)	O
;	O
else	O
return	O
0	int
;	O
}	O
static	O
int	O
path_isdir	(*(char))->(int)
(	O
filename	*(char)
)	O
const	O
char	O
*	O
filename	*(char)
;	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
return	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
filename	*(char)
,	O
&	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
&&	O
S_ISDIR	O
(	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
;	O
}	O
static	O
int	O
stat_char	(*(char))->(int)
(	O
filename	*(char)
)	O
char	O
*	O
filename	*(char)
;	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
character	int
,	O
r	int
;	O
char	O
*	O
f	*(char)
;	O
const	O
char	O
*	O
fn	*(char)
;	O
f	*(char)
=	O
0	int
;	O
if	O
(	O
rl_filename_stat_hook	*((*(*(char)))->(int))
)	O
{	O
f	*(char)
=	O
savestring	O
(	O
filename	*(char)
)	O
;	O
(	O
*	O
rl_filename_stat_hook	*((*(*(char)))->(int))
)	O
(	O
&	O
f	*(char)
)	O
;	O
fn	*(char)
=	O
f	*(char)
;	O
}	O
else	O
fn	*(char)
=	O
filename	*(char)
;	O
r	int
=	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fn	*(char)
,	O
&	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
r	int
==	O
-	O
1	int
)	O
return	O
(	O
0	int
)	O
;	O
character	int
=	O
0	int
;	O
if	O
(	O
S_ISDIR	O
(	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
character	int
=	O
'/'	O
;	O
else	O
if	O
(	O
S_ISCHR	O
(	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
character	int
=	O
'%'	O
;	O
else	O
if	O
(	O
S_ISBLK	O
(	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
character	int
=	O
'#'	O
;	O
else	O
if	O
(	O
S_ISLNK	O
(	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
character	int
=	O
'@'	O
;	O
else	O
if	O
(	O
S_ISSOCK	O
(	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
character	int
=	O
'='	O
;	O
else	O
if	O
(	O
S_ISFIFO	O
(	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
character	int
=	O
'|'	O
;	O
else	O
if	O
(	O
S_ISREG	O
(	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
access	(*(char),int)->(int)
(	O
filename	*(char)
,	O
X_OK	int
)	O
==	O
0	int
)	O
character	int
=	O
'*'	O
;	O
}	O
xfree	(*(void))->(void)
(	O
f	*(char)
)	O
;	O
return	O
(	O
character	int
)	O
;	O
}	O
static	O
int	O
colored_stat_start	(*(char))->(int)
(	O
filename	*(char)
)	O
const	O
char	O
*	O
filename	*(char)
;	O
{	O
_rl_set_normal_color	()->(void)
(	O
)	O
;	O
return	O
(	O
_rl_print_color_indicator	(*(char))->(bool)
(	O
filename	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
colored_stat_end	()->(void)
(	O
)	O
{	O
_rl_prep_non_filename_text	()->(void)
(	O
)	O
;	O
_rl_put_indicator	(*(struct(long,*(char))))->(void)
(	O
&	O
_rl_color_indicator	array(struct(long,*(char)))
[	O
C_CLR_TO_EOL	int
]	O
)	O
;	O
}	O
static	O
int	O
colored_prefix_start	()->(int)
(	O
)	O
{	O
_rl_set_normal_color	()->(void)
(	O
)	O
;	O
return	O
(	O
_rl_print_prefix_color	()->(bool)
(	O
)	O
)	O
;	O
}	O
static	O
void	O
colored_prefix_end	()->(void)
(	O
)	O
{	O
colored_stat_end	()->(void)
(	O
)	O
;	O
}	O
static	O
char	O
*	O
printable_part	(*(char))->(*(char))
(	O
pathname	*(char)
)	O
char	O
*	O
pathname	*(char)
;	O
{	O
char	O
*	O
temp	*(char)
,	O
*	O
x	*(char)
;	O
if	O
(	O
rl_filename_completion_desired	int
==	O
0	int
)	O
return	O
(	O
pathname	*(char)
)	O
;	O
temp	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
pathname	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
temp	*(char)
==	O
0	int
||	O
*	O
temp	*(char)
==	O
'\0'	O
)	O
return	O
(	O
pathname	*(char)
)	O
;	O
else	O
if	O
(	O
temp	*(char)
[	O
1	int
]	O
==	O
0	int
&&	O
temp	*(char)
==	O
pathname	*(char)
)	O
return	O
(	O
pathname	*(char)
)	O
;	O
else	O
if	O
(	O
temp	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
for	O
(	O
x	*(char)
=	O
temp	*(char)
-	O
1	int
;	O
x	*(char)
>	O
pathname	*(char)
;	O
x	*(char)
--	O
)	O
if	O
(	O
*	O
x	*(char)
==	O
'/'	O
)	O
break	O
;	O
return	O
(	O
(	O
*	O
x	*(char)
==	O
'/'	O
)	O
?	O
x	*(char)
+	O
1	int
:	O
pathname	*(char)
)	O
;	O
}	O
else	O
return	O
++	O
temp	*(char)
;	O
}	O
static	O
int	O
fnwidth	(*(char))->(int)
(	O
string	*(char)
)	O
const	O
char	O
*	O
string	*(char)
;	O
{	O
int	O
width	int
,	O
pos	int
;	O
mbstate_t	struct(int,union(int,array(char)))
ps	struct(int,union(int,array(char)))
;	O
int	O
left	int
,	O
w	int
;	O
size_t	long
clen	long
;	O
wchar_t	int
wc	int
;	O
left	int
=	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
+	O
1	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
width	int
=	O
pos	int
=	O
0	int
;	O
while	O
(	O
string	*(char)
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
CTRL_CHAR	O
(	O
string	*(char)
[	O
pos	int
]	O
)	O
||	O
string	*(char)
[	O
pos	int
]	O
==	O
RUBOUT	int
)	O
{	O
width	int
+=	O
2	int
;	O
pos	int
++	O
;	O
}	O
else	O
{	O
clen	long
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc	int
,	O
string	*(char)
+	O
pos	int
,	O
left	int
-	O
pos	int
,	O
&	O
ps	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
MB_INVALIDCH	O
(	O
clen	long
)	O
)	O
{	O
width	int
++	O
;	O
pos	int
++	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
}	O
else	O
if	O
(	O
MB_NULLWCH	O
(	O
clen	long
)	O
)	O
break	O
;	O
else	O
{	O
pos	int
+=	O
clen	long
;	O
w	int
=	O
WCWIDTH	O
(	O
wc	int
)	O
;	O
width	int
+=	O
(	O
w	int
>=	O
0	int
)	O
?	O
w	int
:	O
1	int
;	O
}	O
}	O
}	O
return	O
width	int
;	O
}	O
static	O
int	O
fnprint	(*(char),int,*(char))->(int)
(	O
to_print	*(char)
,	O
prefix_bytes	int
,	O
real_pathname	*(char)
)	O
const	O
char	O
*	O
to_print	*(char)
;	O
int	O
prefix_bytes	int
;	O
const	O
char	O
*	O
real_pathname	*(char)
;	O
{	O
int	O
printed_len	int
,	O
w	int
;	O
const	O
char	O
*	O
s	*(char)
;	O
int	O
common_prefix_len	int
,	O
print_len	int
;	O
mbstate_t	struct(int,union(int,array(char)))
ps	struct(int,union(int,array(char)))
;	O
const	O
char	O
*	O
end	int
;	O
size_t	long
tlen	long
;	O
int	O
width	int
;	O
wchar_t	int
wc	int
;	O
print_len	int
=	O
strlen	(*(char))->(long)
(	O
to_print	*(char)
)	O
;	O
end	int
=	O
to_print	*(char)
+	O
print_len	int
+	O
1	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
printed_len	int
=	O
common_prefix_len	int
=	O
0	int
;	O
if	O
(	O
_rl_completion_prefix_display_length	int
>	O
0	int
&&	O
prefix_bytes	int
>=	O
print_len	int
)	O
prefix_bytes	int
=	O
0	int
;	O
if	O
(	O
_rl_colored_stats	int
&&	O
(	O
prefix_bytes	int
==	O
0	int
||	O
_rl_colored_completion_prefix	int
<=	O
0	int
)	O
)	O
colored_stat_start	(*(char))->(int)
(	O
real_pathname	*(char)
)	O
;	O
if	O
(	O
prefix_bytes	int
&&	O
_rl_completion_prefix_display_length	int
>	O
0	int
)	O
{	O
char	O
ellipsis	char
;	O
ellipsis	char
=	O
(	O
to_print	*(char)
[	O
prefix_bytes	int
]	O
==	O
'.'	O
)	O
?	O
'_'	O
:	O
'.'	O
;	O
for	O
(	O
w	int
=	O
0	int
;	O
w	int
<	O
ELLIPSIS_LEN	int
;	O
w	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
ellipsis	char
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
printed_len	int
=	O
ELLIPSIS_LEN	int
;	O
}	O
else	O
if	O
(	O
prefix_bytes	int
&&	O
_rl_colored_completion_prefix	int
>	O
0	int
)	O
{	O
common_prefix_len	int
=	O
prefix_bytes	int
;	O
prefix_bytes	int
=	O
0	int
;	O
colored_prefix_start	()->(int)
(	O
)	O
;	O
}	O
s	*(char)
=	O
to_print	*(char)
+	O
prefix_bytes	int
;	O
while	O
(	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
CTRL_CHAR	O
(	O
*	O
s	*(char)
)	O
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'^'	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
UNCTRL	O
(	O
*	O
s	*(char)
)	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
printed_len	int
+=	O
2	int
;	O
s	*(char)
++	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
s	*(char)
==	O
RUBOUT	int
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'^'	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'?'	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
printed_len	int
+=	O
2	int
;	O
s	*(char)
++	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
}	O
else	O
{	O
tlen	long
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc	int
,	O
s	*(char)
,	O
end	int
-	O
s	*(char)
,	O
&	O
ps	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
MB_INVALIDCH	O
(	O
tlen	long
)	O
)	O
{	O
tlen	long
=	O
1	int
;	O
width	int
=	O
1	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
}	O
else	O
if	O
(	O
MB_NULLWCH	O
(	O
tlen	long
)	O
)	O
break	O
;	O
else	O
{	O
w	int
=	O
WCWIDTH	O
(	O
wc	int
)	O
;	O
width	int
=	O
(	O
w	int
>=	O
0	int
)	O
?	O
w	int
:	O
1	int
;	O
}	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
s	*(char)
,	O
1	int
,	O
tlen	long
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
s	*(char)
+=	O
tlen	long
;	O
printed_len	int
+=	O
width	int
;	O
}	O
if	O
(	O
common_prefix_len	int
>	O
0	int
&&	O
(	O
s	*(char)
-	O
to_print	*(char)
)	O
>=	O
common_prefix_len	int
)	O
{	O
colored_prefix_end	()->(void)
(	O
)	O
;	O
if	O
(	O
_rl_colored_stats	int
)	O
colored_stat_start	(*(char))->(int)
(	O
real_pathname	*(char)
)	O
;	O
common_prefix_len	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
_rl_colored_stats	int
)	O
colored_stat_end	()->(void)
(	O
)	O
;	O
return	O
printed_len	int
;	O
}	O
static	O
int	O
print_filename	(*(char),*(char),int)->(int)
(	O
to_print	*(char)
,	O
full_pathname	*(char)
,	O
prefix_bytes	int
)	O
char	O
*	O
to_print	*(char)
,	O
*	O
full_pathname	*(char)
;	O
int	O
prefix_bytes	int
;	O
{	O
int	O
printed_len	int
,	O
extension_char	int
,	O
slen	int
,	O
tlen	long
;	O
char	O
*	O
s	*(char)
,	O
c	int
,	O
*	O
new_full_pathname	*(char)
,	O
*	O
dn	*(char)
;	O
extension_char	int
=	O
0	int
;	O
if	O
(	O
_rl_colored_stats	int
==	O
0	int
||	O
rl_filename_completion_desired	int
==	O
0	int
)	O
printed_len	int
=	O
fnprint	(*(char),int,*(char))->(int)
(	O
to_print	*(char)
,	O
prefix_bytes	int
,	O
to_print	*(char)
)	O
;	O
if	O
(	O
rl_filename_completion_desired	int
&&	O
(	O
rl_visible_stats	int
||	O
_rl_colored_stats	int
||	O
_rl_complete_mark_directories	int
)	O
)	O
{	O
if	O
(	O
to_print	*(char)
!=	O
full_pathname	*(char)
)	O
{	O
c	int
=	O
to_print	*(char)
[	O
-	O
1	int
]	O
;	O
to_print	*(char)
[	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
full_pathname	*(char)
==	O
0	int
||	O
*	O
full_pathname	*(char)
==	O
0	int
)	O
dn	*(char)
=	O
"/"	*(char)
;	O
else	O
if	O
(	O
full_pathname	*(char)
[	O
0	int
]	O
!=	O
'/'	O
)	O
dn	*(char)
=	O
full_pathname	*(char)
;	O
else	O
if	O
(	O
full_pathname	*(char)
[	O
1	int
]	O
==	O
0	int
)	O
dn	*(char)
=	O
"//"	*(char)
;	O
else	O
if	O
(	O
full_pathname	*(char)
[	O
1	int
]	O
==	O
'/'	O
&&	O
full_pathname	*(char)
[	O
2	int
]	O
==	O
0	int
)	O
dn	*(char)
=	O
"/"	*(char)
;	O
else	O
dn	*(char)
=	O
full_pathname	*(char)
;	O
s	*(char)
=	O
tilde_expand	(*(char))->(*(char))
(	O
dn	*(char)
)	O
;	O
if	O
(	O
rl_directory_completion_hook	*((*(*(char)))->(int))
)	O
(	O
*	O
rl_directory_completion_hook	*((*(*(char)))->(int))
)	O
(	O
&	O
s	*(char)
)	O
;	O
slen	int
=	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
;	O
tlen	long
=	O
strlen	(*(char))->(long)
(	O
to_print	*(char)
)	O
;	O
new_full_pathname	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
slen	int
+	O
tlen	long
+	O
2	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
new_full_pathname	*(char)
,	O
s	*(char)
)	O
;	O
if	O
(	O
s	*(char)
[	O
slen	int
-	O
1	int
]	O
==	O
'/'	O
)	O
slen	int
--	O
;	O
else	O
new_full_pathname	*(char)
[	O
slen	int
]	O
=	O
'/'	O
;	O
new_full_pathname	*(char)
[	O
slen	int
]	O
=	O
'/'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
new_full_pathname	*(char)
+	O
slen	int
+	O
1	int
,	O
to_print	*(char)
)	O
;	O
if	O
(	O
rl_visible_stats	int
)	O
extension_char	int
=	O
stat_char	(*(char))->(int)
(	O
new_full_pathname	*(char)
)	O
;	O
else	O
if	O
(	O
_rl_complete_mark_directories	int
)	O
{	O
dn	*(char)
=	O
0	int
;	O
if	O
(	O
rl_directory_completion_hook	*((*(*(char)))->(int))
==	O
0	int
&&	O
rl_filename_stat_hook	*((*(*(char)))->(int))
)	O
{	O
dn	*(char)
=	O
savestring	O
(	O
new_full_pathname	*(char)
)	O
;	O
(	O
*	O
rl_filename_stat_hook	*((*(*(char)))->(int))
)	O
(	O
&	O
dn	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
new_full_pathname	*(char)
)	O
;	O
new_full_pathname	*(char)
=	O
dn	*(char)
;	O
}	O
if	O
(	O
path_isdir	(*(char))->(int)
(	O
new_full_pathname	*(char)
)	O
)	O
extension_char	int
=	O
'/'	O
;	O
}	O
if	O
(	O
_rl_colored_stats	int
)	O
printed_len	int
=	O
fnprint	(*(char),int,*(char))->(int)
(	O
to_print	*(char)
,	O
prefix_bytes	int
,	O
new_full_pathname	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
new_full_pathname	*(char)
)	O
;	O
to_print	*(char)
[	O
-	O
1	int
]	O
=	O
c	int
;	O
}	O
else	O
{	O
s	*(char)
=	O
tilde_expand	(*(char))->(*(char))
(	O
full_pathname	*(char)
)	O
;	O
if	O
(	O
rl_visible_stats	int
)	O
extension_char	int
=	O
stat_char	(*(char))->(int)
(	O
s	*(char)
)	O
;	O
else	O
if	O
(	O
_rl_complete_mark_directories	int
&&	O
path_isdir	(*(char))->(int)
(	O
s	*(char)
)	O
)	O
extension_char	int
=	O
'/'	O
;	O
if	O
(	O
_rl_colored_stats	int
)	O
printed_len	int
=	O
fnprint	(*(char),int,*(char))->(int)
(	O
to_print	*(char)
,	O
prefix_bytes	int
,	O
s	*(char)
)	O
;	O
}	O
xfree	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
if	O
(	O
extension_char	int
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
extension_char	int
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
printed_len	int
++	O
;	O
}	O
}	O
return	O
printed_len	int
;	O
}	O
static	O
char	O
*	O
rl_quote_filename	(*(char),int,*(char))->(*(char))
(	O
s	*(char)
,	O
rtype	int
,	O
qcp	*(char)
)	O
char	O
*	O
s	*(char)
;	O
int	O
rtype	int
;	O
char	O
*	O
qcp	*(char)
;	O
{	O
char	O
*	O
r	int
;	O
r	int
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
+	O
2	int
)	O
;	O
*	O
r	int
=	O
*	O
rl_completer_quote_characters	*(char)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
r	int
+	O
1	int
,	O
s	*(char)
)	O
;	O
if	O
(	O
qcp	*(char)
)	O
*	O
qcp	*(char)
=	O
*	O
rl_completer_quote_characters	*(char)
;	O
return	O
r	int
;	O
}	O
char	O
_rl_find_completion_word	(*(int),*(int))->(char)
(	O
fp	*(int)
,	O
dp	*(int)
)	O
int	O
*	O
fp	*(int)
,	O
*	O
dp	*(int)
;	O
{	O
int	O
scan	int
,	O
end	int
,	O
found_quote	int
,	O
delimiter	int
,	O
pass_next	int
,	O
isbrk	int
;	O
char	O
quote_char	char
,	O
*	O
brkchars	*(char)
;	O
end	int
=	O
rl_point	int
;	O
found_quote	int
=	O
delimiter	int
=	O
0	int
;	O
quote_char	char
=	O
'\0'	O
;	O
brkchars	*(char)
=	O
0	int
;	O
if	O
(	O
rl_completion_word_break_hook	*(()->(*(char)))
)	O
brkchars	*(char)
=	O
(	O
*	O
rl_completion_word_break_hook	*(()->(*(char)))
)	O
(	O
)	O
;	O
if	O
(	O
brkchars	*(char)
==	O
0	int
)	O
brkchars	*(char)
=	O
rl_completer_word_break_characters	*(char)
;	O
if	O
(	O
rl_completer_quote_characters	*(char)
)	O
{	O
for	O
(	O
scan	int
=	O
pass_next	int
=	O
0	int
;	O
scan	int
<	O
end	int
;	O
scan	int
=	O
MB_NEXTCHAR	O
(	O
rl_line_buffer	*(char)
,	O
scan	int
,	O
1	int
,	O
MB_FIND_ANY	int
)	O
)	O
{	O
if	O
(	O
pass_next	int
)	O
{	O
pass_next	int
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
quote_char	char
!=	O
'\''	O
&&	O
rl_line_buffer	*(char)
[	O
scan	int
]	O
==	O
'\\'	O
)	O
{	O
pass_next	int
=	O
1	int
;	O
found_quote	int
|=	O
RL_QF_BACKSLASH	int
;	O
continue	O
;	O
}	O
if	O
(	O
quote_char	char
!=	O
'\0'	O
)	O
{	O
if	O
(	O
rl_line_buffer	*(char)
[	O
scan	int
]	O
==	O
quote_char	char
)	O
{	O
quote_char	char
=	O
'\0'	O
;	O
rl_point	int
=	O
end	int
;	O
}	O
}	O
else	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
rl_completer_quote_characters	*(char)
,	O
rl_line_buffer	*(char)
[	O
scan	int
]	O
)	O
)	O
{	O
quote_char	char
=	O
rl_line_buffer	*(char)
[	O
scan	int
]	O
;	O
rl_point	int
=	O
scan	int
+	O
1	int
;	O
if	O
(	O
quote_char	char
==	O
'\''	O
)	O
found_quote	int
|=	O
RL_QF_SINGLE_QUOTE	int
;	O
else	O
if	O
(	O
quote_char	char
==	O
'"'	O
)	O
found_quote	int
|=	O
RL_QF_DOUBLE_QUOTE	int
;	O
else	O
found_quote	int
|=	O
RL_QF_OTHER_QUOTE	int
;	O
}	O
}	O
}	O
if	O
(	O
rl_point	int
==	O
end	int
&&	O
quote_char	char
==	O
'\0'	O
)	O
{	O
while	O
(	O
rl_point	int
=	O
MB_PREVCHAR	O
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
MB_FIND_ANY	int
)	O
)	O
{	O
scan	int
=	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
brkchars	*(char)
,	O
scan	int
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
rl_char_is_quoted_p	*((*(char),int)->(int))
&&	O
found_quote	int
&&	O
(	O
*	O
rl_char_is_quoted_p	*((*(char),int)->(int))
)	O
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
)	O
)	O
continue	O
;	O
break	O
;	O
}	O
}	O
scan	int
=	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
;	O
if	O
(	O
scan	int
)	O
{	O
if	O
(	O
rl_char_is_quoted_p	*((*(char),int)->(int))
)	O
isbrk	int
=	O
(	O
found_quote	int
==	O
0	int
||	O
(	O
*	O
rl_char_is_quoted_p	*((*(char),int)->(int))
)	O
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
)	O
==	O
0	int
)	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
brkchars	*(char)
,	O
scan	int
)	O
!=	O
0	int
;	O
else	O
isbrk	int
=	O
strchr	(*(char),int)->(*(char))
(	O
brkchars	*(char)
,	O
scan	int
)	O
!=	O
0	int
;	O
if	O
(	O
isbrk	int
)	O
{	O
if	O
(	O
rl_basic_quote_characters	*(char)
&&	O
strchr	(*(char),int)->(*(char))
(	O
rl_basic_quote_characters	*(char)
,	O
scan	int
)	O
&&	O
(	O
end	int
-	O
rl_point	int
)	O
>	O
1	int
)	O
delimiter	int
=	O
scan	int
;	O
if	O
(	O
rl_special_prefixes	*(char)
==	O
0	int
||	O
strchr	(*(char),int)->(*(char))
(	O
rl_special_prefixes	*(char)
,	O
scan	int
)	O
==	O
0	int
)	O
rl_point	int
++	O
;	O
}	O
}	O
if	O
(	O
fp	*(int)
)	O
*	O
fp	*(int)
=	O
found_quote	int
;	O
if	O
(	O
dp	*(int)
)	O
*	O
dp	*(int)
=	O
delimiter	int
;	O
return	O
(	O
quote_char	char
)	O
;	O
}	O
static	O
char	O
*	O
*	O
gen_completion_matches	(*(char),int,int,*((*(char),int)->(*(char))),int,int)->(*(*(char)))
(	O
text	*(char)
,	O
start	int
,	O
end	int
,	O
our_func	*((*(char),int)->(*(char)))
,	O
found_quote	int
,	O
quote_char	char
)	O
char	O
*	O
text	*(char)
;	O
int	O
start	int
,	O
end	int
;	O
rl_compentry_func_t	(*(char),int)->(*(char))
*	O
our_func	*((*(char),int)->(*(char)))
;	O
int	O
found_quote	int
,	O
quote_char	char
;	O
{	O
char	O
*	O
*	O
matches	*(*(char))
;	O
rl_completion_found_quote	int
=	O
found_quote	int
;	O
rl_completion_quote_character	int
=	O
quote_char	char
;	O
if	O
(	O
rl_attempted_completion_function	*((*(char),int,int)->(*(*(char))))
)	O
{	O
matches	*(*(char))
=	O
(	O
*	O
rl_attempted_completion_function	*((*(char),int,int)->(*(*(char))))
)	O
(	O
text	*(char)
,	O
start	int
,	O
end	int
)	O
;	O
if	O
(	O
RL_SIG_RECEIVED	O
(	O
)	O
)	O
{	O
_rl_free_match_list	(*(*(char)))->(void)
(	O
matches	*(*(char))
)	O
;	O
matches	*(*(char))
=	O
0	int
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
}	O
if	O
(	O
matches	*(*(char))
||	O
rl_attempted_completion_over	int
)	O
{	O
rl_attempted_completion_over	int
=	O
0	int
;	O
return	O
(	O
matches	*(*(char))
)	O
;	O
}	O
}	O
matches	*(*(char))
=	O
rl_completion_matches	(*(char),*((*(char),int)->(*(char))))->(*(*(char)))
(	O
text	*(char)
,	O
our_func	*((*(char),int)->(*(char)))
)	O
;	O
if	O
(	O
RL_SIG_RECEIVED	O
(	O
)	O
)	O
{	O
_rl_free_match_list	(*(*(char)))->(void)
(	O
matches	*(*(char))
)	O
;	O
matches	*(*(char))
=	O
0	int
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
}	O
return	O
matches	*(*(char))
;	O
}	O
static	O
char	O
*	O
*	O
remove_duplicate_matches	(*(*(char)))->(*(*(char)))
(	O
matches	*(*(char))
)	O
char	O
*	O
*	O
matches	*(*(char))
;	O
{	O
char	O
*	O
lowest_common	*(char)
;	O
int	O
i	int
,	O
j	int
,	O
newlen	int
;	O
char	O
dead_slot	char
;	O
char	O
*	O
*	O
temp_array	*(*(char))
;	O
for	O
(	O
i	int
=	O
0	int
;	O
matches	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
i	int
&&	O
rl_sort_completion_matches	int
)	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
matches	*(*(char))
+	O
1	int
,	O
i	int
-	O
1	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
(	O
QSFUNC	(*(void),*(void))->(int)
*	O
)	O
_rl_qsort_string_compare	(*(*(char)),*(*(char)))->(int)
)	O
;	O
lowest_common	*(char)
=	O
savestring	O
(	O
matches	*(*(char))
[	O
0	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
newlen	int
=	O
0	int
;	O
matches	*(*(char))
[	O
i	int
+	O
1	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
matches	*(*(char))
[	O
i	int
]	O
,	O
matches	*(*(char))
[	O
i	int
+	O
1	int
]	O
)	O
==	O
0	int
)	O
{	O
xfree	(*(void))->(void)
(	O
matches	*(*(char))
[	O
i	int
]	O
)	O
;	O
matches	*(*(char))
[	O
i	int
]	O
=	O
(	O
char	O
*	O
)	O
&	O
dead_slot	char
;	O
}	O
else	O
newlen	int
++	O
;	O
}	O
temp_array	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
(	O
3	int
+	O
newlen	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
j	int
=	O
1	int
;	O
matches	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
matches	*(*(char))
[	O
i	int
]	O
!=	O
(	O
char	O
*	O
)	O
&	O
dead_slot	char
)	O
temp_array	*(*(char))
[	O
j	int
++	O
]	O
=	O
matches	*(*(char))
[	O
i	int
]	O
;	O
}	O
temp_array	*(*(char))
[	O
j	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
if	O
(	O
matches	*(*(char))
[	O
0	int
]	O
!=	O
(	O
char	O
*	O
)	O
&	O
dead_slot	char
)	O
xfree	(*(void))->(void)
(	O
matches	*(*(char))
[	O
0	int
]	O
)	O
;	O
temp_array	*(*(char))
[	O
0	int
]	O
=	O
lowest_common	*(char)
;	O
if	O
(	O
j	int
==	O
2	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
temp_array	*(*(char))
[	O
0	int
]	O
,	O
temp_array	*(*(char))
[	O
1	int
]	O
)	O
==	O
0	int
)	O
{	O
xfree	(*(void))->(void)
(	O
temp_array	*(*(char))
[	O
1	int
]	O
)	O
;	O
temp_array	*(*(char))
[	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
return	O
(	O
temp_array	*(*(char))
)	O
;	O
}	O
static	O
int	O
compute_lcd_of_matches	(*(*(char)),int,*(char))->(int)
(	O
match_list	*(*(char))
,	O
matches	*(*(char))
,	O
text	*(char)
)	O
char	O
*	O
*	O
match_list	*(*(char))
;	O
int	O
matches	*(*(char))
;	O
const	O
char	O
*	O
text	*(char)
;	O
{	O
register	O
int	O
i	int
,	O
c1	int
,	O
c2	int
,	O
si	int
;	O
int	O
low	int
;	O
int	O
lx	int
;	O
char	O
*	O
dtext	*(char)
;	O
int	O
v	int
;	O
size_t	long
v1	long
,	O
v2	long
;	O
mbstate_t	struct(int,union(int,array(char)))
ps1	struct(int,union(int,array(char)))
,	O
ps2	struct(int,union(int,array(char)))
;	O
wchar_t	int
wc1	int
,	O
wc2	int
;	O
if	O
(	O
matches	*(*(char))
==	O
1	int
)	O
{	O
match_list	*(*(char))
[	O
0	int
]	O
=	O
match_list	*(*(char))
[	O
1	int
]	O
;	O
match_list	*(*(char))
[	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
i	int
=	O
1	int
,	O
low	int
=	O
100000	int
;	O
i	int
<	O
matches	*(*(char))
;	O
i	int
++	O
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps1	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps2	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
}	O
if	O
(	O
_rl_completion_case_fold	int
)	O
{	O
for	O
(	O
si	int
=	O
0	int
;	O
(	O
c1	int
=	O
_rl_to_lower	(int)->(int)
(	O
match_list	*(*(char))
[	O
i	int
]	O
[	O
si	int
]	O
)	O
)	O
&&	O
(	O
c2	int
=	O
_rl_to_lower	(int)->(int)
(	O
match_list	*(*(char))
[	O
i	int
+	O
1	int
]	O
[	O
si	int
]	O
)	O
)	O
;	O
si	int
++	O
)	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
v1	long
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc1	int
,	O
match_list	*(*(char))
[	O
i	int
]	O
+	O
si	int
,	O
strlen	(*(char))->(long)
(	O
match_list	*(*(char))
[	O
i	int
]	O
+	O
si	int
)	O
,	O
&	O
ps1	struct(int,union(int,array(char)))
)	O
;	O
v2	long
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc2	int
,	O
match_list	*(*(char))
[	O
i	int
+	O
1	int
]	O
+	O
si	int
,	O
strlen	(*(char))->(long)
(	O
match_list	*(*(char))
[	O
i	int
+	O
1	int
]	O
+	O
si	int
)	O
,	O
&	O
ps2	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
MB_INVALIDCH	O
(	O
v1	long
)	O
||	O
MB_INVALIDCH	O
(	O
v2	long
)	O
)	O
{	O
if	O
(	O
c1	int
!=	O
c2	int
)	O
break	O
;	O
continue	O
;	O
}	O
wc1	int
=	O
towlower	(int)->(int)
(	O
wc1	int
)	O
;	O
wc2	int
=	O
towlower	(int)->(int)
(	O
wc2	int
)	O
;	O
if	O
(	O
wc1	int
!=	O
wc2	int
)	O
break	O
;	O
else	O
if	O
(	O
v1	long
>	O
1	int
)	O
si	int
+=	O
v1	long
-	O
1	int
;	O
}	O
else	O
if	O
(	O
c1	int
!=	O
c2	int
)	O
break	O
;	O
}	O
else	O
{	O
for	O
(	O
si	int
=	O
0	int
;	O
(	O
c1	int
=	O
match_list	*(*(char))
[	O
i	int
]	O
[	O
si	int
]	O
)	O
&&	O
(	O
c2	int
=	O
match_list	*(*(char))
[	O
i	int
+	O
1	int
]	O
[	O
si	int
]	O
)	O
;	O
si	int
++	O
)	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
mbstate_t	struct(int,union(int,array(char)))
ps_back	struct(int,union(int,array(char)))
;	O
ps_back	struct(int,union(int,array(char)))
=	O
ps1	struct(int,union(int,array(char)))
;	O
if	O
(	O
!	O
_rl_compare_chars	(*(char),int,*(struct(int,union(int,array(char)))),*(char),int,*(struct(int,union(int,array(char)))))->(int)
(	O
match_list	*(*(char))
[	O
i	int
]	O
,	O
si	int
,	O
&	O
ps1	struct(int,union(int,array(char)))
,	O
match_list	*(*(char))
[	O
i	int
+	O
1	int
]	O
,	O
si	int
,	O
&	O
ps2	struct(int,union(int,array(char)))
)	O
)	O
break	O
;	O
else	O
if	O
(	O
(	O
v	int
=	O
_rl_get_char_len	(*(char),*(struct(int,union(int,array(char)))))->(int)
(	O
&	O
match_list	*(*(char))
[	O
i	int
]	O
[	O
si	int
]	O
,	O
&	O
ps_back	struct(int,union(int,array(char)))
)	O
)	O
>	O
1	int
)	O
si	int
+=	O
v	int
-	O
1	int
;	O
}	O
else	O
if	O
(	O
c1	int
!=	O
c2	int
)	O
break	O
;	O
}	O
if	O
(	O
low	int
>	O
si	int
)	O
low	int
=	O
si	int
;	O
}	O
if	O
(	O
low	int
==	O
0	int
&&	O
text	*(char)
&&	O
*	O
text	*(char)
)	O
{	O
match_list	*(*(char))
[	O
0	int
]	O
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
match_list	*(*(char))
[	O
0	int
]	O
,	O
text	*(char)
)	O
;	O
}	O
else	O
{	O
match_list	*(*(char))
[	O
0	int
]	O
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
low	int
+	O
1	int
)	O
;	O
if	O
(	O
_rl_completion_case_fold	int
)	O
{	O
dtext	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
if	O
(	O
rl_filename_completion_desired	int
&&	O
rl_filename_dequoting_function	*((*(char),int)->(*(char)))
&&	O
rl_completion_found_quote	int
&&	O
rl_filename_quoting_desired	int
)	O
{	O
dtext	*(char)
=	O
(	O
*	O
rl_filename_dequoting_function	*((*(char),int)->(*(char)))
)	O
(	O
(	O
char	O
*	O
)	O
text	*(char)
,	O
rl_completion_quote_character	int
)	O
;	O
text	*(char)
=	O
dtext	*(char)
;	O
}	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
match_list	*(*(char))
+	O
1	int
,	O
matches	*(*(char))
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
(	O
QSFUNC	(*(void),*(void))->(int)
*	O
)	O
_rl_qsort_string_compare	(*(*(char)),*(*(char)))->(int)
)	O
;	O
si	int
=	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
;	O
lx	int
=	O
(	O
si	int
<=	O
low	int
)	O
?	O
si	int
:	O
low	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
matches	*(*(char))
;	O
i	int
++	O
)	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
match_list	*(*(char))
[	O
i	int
]	O
,	O
text	*(char)
,	O
lx	int
)	O
==	O
0	int
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
match_list	*(*(char))
[	O
0	int
]	O
,	O
match_list	*(*(char))
[	O
i	int
]	O
,	O
low	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
i	int
>	O
matches	*(*(char))
)	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
match_list	*(*(char))
[	O
0	int
]	O
,	O
match_list	*(*(char))
[	O
1	int
]	O
,	O
low	int
)	O
;	O
FREE	O
(	O
dtext	*(char)
)	O
;	O
}	O
else	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
match_list	*(*(char))
[	O
0	int
]	O
,	O
match_list	*(*(char))
[	O
1	int
]	O
,	O
low	int
)	O
;	O
match_list	*(*(char))
[	O
0	int
]	O
[	O
low	int
]	O
=	O
'\0'	O
;	O
}	O
return	O
matches	*(*(char))
;	O
}	O
static	O
int	O
postprocess_matches	(*(*(*(char))),int)->(int)
(	O
matchesp	*(*(*(char)))
,	O
matching_filenames	int
)	O
char	O
*	O
*	O
*	O
matchesp	*(*(*(char)))
;	O
int	O
matching_filenames	int
;	O
{	O
char	O
*	O
t	*(char)
,	O
*	O
*	O
matches	*(*(char))
,	O
*	O
*	O
temp_matches	*(*(char))
;	O
int	O
nmatch	int
,	O
i	int
;	O
matches	*(*(char))
=	O
*	O
matchesp	*(*(*(char)))
;	O
if	O
(	O
matches	*(*(char))
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
rl_ignore_completion_duplicates	int
)	O
{	O
temp_matches	*(*(char))
=	O
remove_duplicate_matches	(*(*(char)))->(*(*(char)))
(	O
matches	*(*(char))
)	O
;	O
xfree	(*(void))->(void)
(	O
matches	*(*(char))
)	O
;	O
matches	*(*(char))
=	O
temp_matches	*(*(char))
;	O
}	O
if	O
(	O
rl_ignore_some_completions_function	*((*(*(char)))->(int))
&&	O
matching_filenames	int
)	O
{	O
for	O
(	O
nmatch	int
=	O
1	int
;	O
matches	*(*(char))
[	O
nmatch	int
]	O
;	O
nmatch	int
++	O
)	O
;	O
(	O
void	O
)	O
(	O
*	O
rl_ignore_some_completions_function	*((*(*(char)))->(int))
)	O
(	O
matches	*(*(char))
)	O
;	O
if	O
(	O
matches	*(*(char))
==	O
0	int
||	O
matches	*(*(char))
[	O
0	int
]	O
==	O
0	int
)	O
{	O
FREE	O
(	O
matches	*(*(char))
)	O
;	O
*	O
matchesp	*(*(*(char)))
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
return	O
0	int
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
matches	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
i	int
>	O
1	int
&&	O
i	int
<	O
nmatch	int
)	O
{	O
t	*(char)
=	O
matches	*(*(char))
[	O
0	int
]	O
;	O
compute_lcd_of_matches	(*(*(char)),int,*(char))->(int)
(	O
matches	*(*(char))
,	O
i	int
-	O
1	int
,	O
t	*(char)
)	O
;	O
FREE	O
(	O
t	*(char)
)	O
;	O
}	O
}	O
}	O
*	O
matchesp	*(*(*(char)))
=	O
matches	*(*(char))
;	O
return	O
(	O
1	int
)	O
;	O
}	O
static	O
int	O
complete_get_screenwidth	()->(int)
(	O
)	O
{	O
int	O
cols	int
;	O
char	O
*	O
envcols	*(char)
;	O
cols	int
=	O
_rl_completion_columns	int
;	O
if	O
(	O
cols	int
>=	O
0	int
&&	O
cols	int
<=	O
_rl_screenwidth	int
)	O
return	O
cols	int
;	O
envcols	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"COLUMNS"	*(char)
)	O
;	O
if	O
(	O
envcols	*(char)
&&	O
*	O
envcols	*(char)
)	O
cols	int
=	O
atoi	(*(char))->(int)
(	O
envcols	*(char)
)	O
;	O
if	O
(	O
cols	int
>=	O
0	int
&&	O
cols	int
<=	O
_rl_screenwidth	int
)	O
return	O
cols	int
;	O
return	O
_rl_screenwidth	int
;	O
}	O
void	O
rl_display_match_list	(*(*(char)),int,int)->(void)
(	O
matches	*(*(char))
,	O
len	long
,	O
max	int
)	O
char	O
*	O
*	O
matches	*(*(char))
;	O
int	O
len	long
,	O
max	int
;	O
{	O
int	O
count	int
,	O
limit	int
,	O
printed_len	int
,	O
lines	*(*(char))
,	O
cols	int
;	O
int	O
i	int
,	O
j	int
,	O
k	int
,	O
l	int
,	O
common_length	int
,	O
sind	int
;	O
char	O
*	O
temp	*(char)
,	O
*	O
t	*(char)
;	O
common_length	int
=	O
sind	int
=	O
0	int
;	O
if	O
(	O
_rl_completion_prefix_display_length	int
>	O
0	int
)	O
{	O
t	*(char)
=	O
printable_part	(*(char))->(*(char))
(	O
matches	*(*(char))
[	O
0	int
]	O
)	O
;	O
temp	*(char)
=	O
rl_filename_completion_desired	int
?	O
strrchr	(*(char),int)->(*(char))
(	O
t	*(char)
,	O
'/'	O
)	O
:	O
0	int
;	O
common_length	int
=	O
temp	*(char)
?	O
fnwidth	(*(char))->(int)
(	O
temp	*(char)
)	O
:	O
fnwidth	(*(char))->(int)
(	O
t	*(char)
)	O
;	O
sind	int
=	O
temp	*(char)
?	O
strlen	(*(char))->(long)
(	O
temp	*(char)
)	O
:	O
strlen	(*(char))->(long)
(	O
t	*(char)
)	O
;	O
if	O
(	O
common_length	int
>	O
max	int
||	O
sind	int
>	O
max	int
)	O
common_length	int
=	O
sind	int
=	O
0	int
;	O
if	O
(	O
common_length	int
>	O
_rl_completion_prefix_display_length	int
&&	O
common_length	int
>	O
ELLIPSIS_LEN	int
)	O
max	int
-=	O
common_length	int
-	O
ELLIPSIS_LEN	int
;	O
else	O
common_length	int
=	O
sind	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
_rl_colored_completion_prefix	int
>	O
0	int
)	O
{	O
t	*(char)
=	O
printable_part	(*(char))->(*(char))
(	O
matches	*(*(char))
[	O
0	int
]	O
)	O
;	O
temp	*(char)
=	O
rl_filename_completion_desired	int
?	O
strrchr	(*(char),int)->(*(char))
(	O
t	*(char)
,	O
'/'	O
)	O
:	O
0	int
;	O
common_length	int
=	O
temp	*(char)
?	O
fnwidth	(*(char))->(int)
(	O
temp	*(char)
)	O
:	O
fnwidth	(*(char))->(int)
(	O
t	*(char)
)	O
;	O
sind	int
=	O
temp	*(char)
?	O
RL_STRLEN	O
(	O
temp	*(char)
+	O
1	int
)	O
:	O
RL_STRLEN	O
(	O
t	*(char)
)	O
;	O
if	O
(	O
common_length	int
>	O
max	int
||	O
sind	int
>	O
max	int
)	O
common_length	int
=	O
sind	int
=	O
0	int
;	O
}	O
cols	int
=	O
complete_get_screenwidth	()->(int)
(	O
)	O
;	O
max	int
+=	O
2	int
;	O
limit	int
=	O
cols	int
/	O
max	int
;	O
if	O
(	O
limit	int
!=	O
1	int
&&	O
(	O
limit	int
*	O
max	int
==	O
cols	int
)	O
)	O
limit	int
--	O
;	O
if	O
(	O
cols	int
<	O
_rl_screenwidth	int
&&	O
limit	int
<	O
0	int
)	O
limit	int
=	O
1	int
;	O
if	O
(	O
limit	int
==	O
0	int
)	O
limit	int
=	O
1	int
;	O
count	int
=	O
(	O
len	long
+	O
(	O
limit	int
-	O
1	int
)	O
)	O
/	O
limit	int
;	O
if	O
(	O
rl_ignore_completion_duplicates	int
==	O
0	int
&&	O
rl_sort_completion_matches	int
)	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
matches	*(*(char))
+	O
1	int
,	O
len	long
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
(	O
QSFUNC	(*(void),*(void))->(int)
*	O
)	O
_rl_qsort_string_compare	(*(*(char)),*(*(char)))->(int)
)	O
;	O
rl_crlf	()->(int)
(	O
)	O
;	O
lines	*(*(char))
=	O
0	int
;	O
if	O
(	O
_rl_print_completions_horizontally	int
==	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
count	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
,	O
l	int
=	O
i	int
;	O
j	int
<	O
limit	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
l	int
>	O
len	long
||	O
matches	*(*(char))
[	O
l	int
]	O
==	O
0	int
)	O
break	O
;	O
else	O
{	O
temp	*(char)
=	O
printable_part	(*(char))->(*(char))
(	O
matches	*(*(char))
[	O
l	int
]	O
)	O
;	O
printed_len	int
=	O
print_filename	(*(char),*(char),int)->(int)
(	O
temp	*(char)
,	O
matches	*(*(char))
[	O
l	int
]	O
,	O
sind	int
)	O
;	O
if	O
(	O
j	int
+	O
1	int
<	O
limit	int
)	O
{	O
if	O
(	O
max	int
<=	O
printed_len	int
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
max	int
-	O
printed_len	int
;	O
k	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
l	int
+=	O
count	int
;	O
}	O
rl_crlf	()->(int)
(	O
)	O
;	O
if	O
(	O
RL_SIG_RECEIVED	O
(	O
)	O
&&	O
RL_SIGWINCH_RECEIVED	O
(	O
)	O
==	O
0	int
)	O
return	O
;	O
lines	*(*(char))
++	O
;	O
if	O
(	O
_rl_page_completions	int
&&	O
lines	*(*(char))
>=	O
(	O
_rl_screenheight	int
-	O
1	int
)	O
&&	O
i	int
<	O
count	int
)	O
{	O
lines	*(*(char))
=	O
_rl_internal_pager	(int)->(int)
(	O
lines	*(*(char))
)	O
;	O
if	O
(	O
lines	*(*(char))
<	O
0	int
)	O
return	O
;	O
}	O
}	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
matches	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
temp	*(char)
=	O
printable_part	(*(char))->(*(char))
(	O
matches	*(*(char))
[	O
i	int
]	O
)	O
;	O
printed_len	int
=	O
print_filename	(*(char),*(char),int)->(int)
(	O
temp	*(char)
,	O
matches	*(*(char))
[	O
i	int
]	O
,	O
sind	int
)	O
;	O
if	O
(	O
RL_SIG_RECEIVED	O
(	O
)	O
&&	O
RL_SIGWINCH_RECEIVED	O
(	O
)	O
==	O
0	int
)	O
return	O
;	O
if	O
(	O
matches	*(*(char))
[	O
i	int
+	O
1	int
]	O
)	O
{	O
if	O
(	O
limit	int
==	O
1	int
||	O
(	O
i	int
&&	O
(	O
limit	int
>	O
1	int
)	O
&&	O
(	O
i	int
%	O
limit	int
)	O
==	O
0	int
)	O
)	O
{	O
rl_crlf	()->(int)
(	O
)	O
;	O
lines	*(*(char))
++	O
;	O
if	O
(	O
_rl_page_completions	int
&&	O
lines	*(*(char))
>=	O
_rl_screenheight	int
-	O
1	int
)	O
{	O
lines	*(*(char))
=	O
_rl_internal_pager	(int)->(int)
(	O
lines	*(*(char))
)	O
;	O
if	O
(	O
lines	*(*(char))
<	O
0	int
)	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
max	int
<=	O
printed_len	int
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
max	int
-	O
printed_len	int
;	O
k	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
rl_crlf	()->(int)
(	O
)	O
;	O
}	O
}	O
static	O
void	O
display_matches	(*(*(char)))->(void)
(	O
matches	*(*(char))
)	O
char	O
*	O
*	O
matches	*(*(char))
;	O
{	O
int	O
len	long
,	O
max	int
,	O
i	int
;	O
char	O
*	O
temp	*(char)
;	O
_rl_move_vert	(int)->(void)
(	O
_rl_vis_botlin	int
)	O
;	O
if	O
(	O
matches	*(*(char))
[	O
1	int
]	O
==	O
0	int
)	O
{	O
temp	*(char)
=	O
printable_part	(*(char))->(*(char))
(	O
matches	*(*(char))
[	O
0	int
]	O
)	O
;	O
rl_crlf	()->(int)
(	O
)	O
;	O
print_filename	(*(char),*(char),int)->(int)
(	O
temp	*(char)
,	O
matches	*(*(char))
[	O
0	int
]	O
,	O
0	int
)	O
;	O
rl_crlf	()->(int)
(	O
)	O
;	O
rl_forced_update_display	()->(int)
(	O
)	O
;	O
rl_display_fixed	int
=	O
1	int
;	O
return	O
;	O
}	O
for	O
(	O
max	int
=	O
0	int
,	O
i	int
=	O
1	int
;	O
matches	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
temp	*(char)
=	O
printable_part	(*(char))->(*(char))
(	O
matches	*(*(char))
[	O
i	int
]	O
)	O
;	O
len	long
=	O
fnwidth	(*(char))->(int)
(	O
temp	*(char)
)	O
;	O
if	O
(	O
len	long
>	O
max	int
)	O
max	int
=	O
len	long
;	O
}	O
len	long
=	O
i	int
-	O
1	int
;	O
if	O
(	O
rl_completion_display_matches_hook	*((*(*(char)),int,int)->(void))
)	O
{	O
(	O
*	O
rl_completion_display_matches_hook	*((*(*(char)),int,int)->(void))
)	O
(	O
matches	*(*(char))
,	O
len	long
,	O
max	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
rl_completion_query_items	int
>	O
0	int
&&	O
len	long
>=	O
rl_completion_query_items	int
)	O
{	O
rl_crlf	()->(int)
(	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Display all %d possibilities? (y or n)"	*(char)
,	O
len	long
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
(	O
completion_y_or_n	int
=	O
get_y_or_n	(int)->(int)
(	O
0	int
)	O
)	O
==	O
0	int
)	O
{	O
rl_crlf	()->(int)
(	O
)	O
;	O
rl_forced_update_display	()->(int)
(	O
)	O
;	O
rl_display_fixed	int
=	O
1	int
;	O
return	O
;	O
}	O
}	O
rl_display_match_list	(*(*(char)),int,int)->(void)
(	O
matches	*(*(char))
,	O
len	long
,	O
max	int
)	O
;	O
rl_forced_update_display	()->(int)
(	O
)	O
;	O
rl_display_fixed	int
=	O
1	int
;	O
}	O
static	O
char	O
*	O
make_quoted_replacement	(*(char),int,*(char))->(*(char))
(	O
match	*(char)
,	O
mtype	int
,	O
qc	*(char)
)	O
char	O
*	O
match	*(char)
;	O
int	O
mtype	int
;	O
char	O
*	O
qc	*(char)
;	O
{	O
int	O
should_quote	int
,	O
do_replace	int
;	O
char	O
*	O
replacement	*(char)
;	O
replacement	*(char)
=	O
match	*(char)
;	O
should_quote	int
=	O
match	*(char)
&&	O
rl_completer_quote_characters	*(char)
&&	O
rl_filename_completion_desired	int
&&	O
rl_filename_quoting_desired	int
;	O
if	O
(	O
should_quote	int
)	O
should_quote	int
=	O
should_quote	int
&&	O
(	O
!	O
qc	*(char)
||	O
!	O
*	O
qc	*(char)
||	O
(	O
rl_completer_quote_characters	*(char)
&&	O
strchr	(*(char),int)->(*(char))
(	O
rl_completer_quote_characters	*(char)
,	O
*	O
qc	*(char)
)	O
)	O
)	O
;	O
if	O
(	O
should_quote	int
)	O
{	O
should_quote	int
=	O
rl_filename_quote_characters	*(char)
?	O
(	O
_rl_strpbrk	O
(	O
match	*(char)
,	O
rl_filename_quote_characters	*(char)
)	O
!=	O
0	int
)	O
:	O
0	int
;	O
do_replace	int
=	O
should_quote	int
?	O
mtype	int
:	O
NO_MATCH	int
;	O
if	O
(	O
do_replace	int
!=	O
NO_MATCH	int
&&	O
rl_filename_quoting_function	*((*(char),int,*(char))->(*(char)))
)	O
replacement	*(char)
=	O
(	O
*	O
rl_filename_quoting_function	*((*(char),int,*(char))->(*(char)))
)	O
(	O
match	*(char)
,	O
do_replace	int
,	O
qc	*(char)
)	O
;	O
}	O
return	O
(	O
replacement	*(char)
)	O
;	O
}	O
static	O
void	O
insert_match	(*(char),int,int,*(char))->(void)
(	O
match	*(char)
,	O
start	int
,	O
mtype	int
,	O
qc	*(char)
)	O
char	O
*	O
match	*(char)
;	O
int	O
start	int
,	O
mtype	int
;	O
char	O
*	O
qc	*(char)
;	O
{	O
char	O
*	O
replacement	*(char)
,	O
*	O
r	int
;	O
char	O
oqc	char
;	O
int	O
end	int
,	O
rlen	int
;	O
oqc	char
=	O
qc	*(char)
?	O
*	O
qc	*(char)
:	O
'\0'	O
;	O
replacement	*(char)
=	O
make_quoted_replacement	(*(char),int,*(char))->(*(char))
(	O
match	*(char)
,	O
mtype	int
,	O
qc	*(char)
)	O
;	O
if	O
(	O
replacement	*(char)
)	O
{	O
rlen	int
=	O
strlen	(*(char))->(long)
(	O
replacement	*(char)
)	O
;	O
if	O
(	O
qc	*(char)
&&	O
*	O
qc	*(char)
&&	O
start	int
&&	O
rl_line_buffer	*(char)
[	O
start	int
-	O
1	int
]	O
==	O
*	O
qc	*(char)
&&	O
replacement	*(char)
[	O
0	int
]	O
==	O
*	O
qc	*(char)
)	O
start	int
--	O
;	O
else	O
if	O
(	O
qc	*(char)
&&	O
(	O
*	O
qc	*(char)
!=	O
oqc	char
)	O
&&	O
start	int
&&	O
rl_line_buffer	*(char)
[	O
start	int
-	O
1	int
]	O
==	O
oqc	char
&&	O
replacement	*(char)
[	O
0	int
]	O
!=	O
oqc	char
)	O
start	int
--	O
;	O
end	int
=	O
rl_point	int
-	O
1	int
;	O
if	O
(	O
qc	*(char)
&&	O
*	O
qc	*(char)
&&	O
end	int
&&	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
==	O
*	O
qc	*(char)
&&	O
replacement	*(char)
[	O
rlen	int
-	O
1	int
]	O
==	O
*	O
qc	*(char)
)	O
end	int
++	O
;	O
if	O
(	O
_rl_skip_completed_text	int
)	O
{	O
r	int
=	O
replacement	*(char)
;	O
while	O
(	O
start	int
<	O
rl_end	int
&&	O
*	O
r	int
&&	O
rl_line_buffer	*(char)
[	O
start	int
]	O
==	O
*	O
r	int
)	O
{	O
start	int
++	O
;	O
r	int
++	O
;	O
}	O
if	O
(	O
start	int
<=	O
end	int
||	O
*	O
r	int
)	O
_rl_replace_text	(*(char),int,int)->(int)
(	O
r	int
,	O
start	int
,	O
end	int
)	O
;	O
rl_point	int
=	O
start	int
+	O
strlen	(*(char))->(long)
(	O
r	int
)	O
;	O
}	O
else	O
_rl_replace_text	(*(char),int,int)->(int)
(	O
replacement	*(char)
,	O
start	int
,	O
end	int
)	O
;	O
if	O
(	O
replacement	*(char)
!=	O
match	*(char)
)	O
xfree	(*(void))->(void)
(	O
replacement	*(char)
)	O
;	O
}	O
}	O
static	O
int	O
append_to_match	(*(char),int,int,int)->(int)
(	O
text	*(char)
,	O
delimiter	int
,	O
quote_char	char
,	O
nontrivial_match	int
)	O
char	O
*	O
text	*(char)
;	O
int	O
delimiter	int
,	O
quote_char	char
,	O
nontrivial_match	int
;	O
{	O
char	O
temp_string	array(char)
[	O
4	int
]	O
,	O
*	O
filename	*(char)
,	O
*	O
fn	*(char)
;	O
int	O
temp_string_index	int
,	O
s	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
temp_string_index	int
=	O
0	int
;	O
if	O
(	O
quote_char	char
&&	O
rl_point	int
&&	O
rl_completion_suppress_quote	int
==	O
0	int
&&	O
rl_line_buffer	*(char)
[	O
rl_point	int
-	O
1	int
]	O
!=	O
quote_char	char
)	O
temp_string	array(char)
[	O
temp_string_index	int
++	O
]	O
=	O
quote_char	char
;	O
if	O
(	O
delimiter	int
)	O
temp_string	array(char)
[	O
temp_string_index	int
++	O
]	O
=	O
delimiter	int
;	O
else	O
if	O
(	O
rl_completion_suppress_append	int
==	O
0	int
&&	O
rl_completion_append_character	int
)	O
temp_string	array(char)
[	O
temp_string_index	int
++	O
]	O
=	O
rl_completion_append_character	int
;	O
temp_string	array(char)
[	O
temp_string_index	int
++	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
rl_filename_completion_desired	int
)	O
{	O
filename	*(char)
=	O
tilde_expand	(*(char))->(*(char))
(	O
text	*(char)
)	O
;	O
if	O
(	O
rl_filename_stat_hook	*((*(*(char)))->(int))
)	O
{	O
fn	*(char)
=	O
savestring	O
(	O
filename	*(char)
)	O
;	O
(	O
*	O
rl_filename_stat_hook	*((*(*(char)))->(int))
)	O
(	O
&	O
fn	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
filename	*(char)
=	O
fn	*(char)
;	O
}	O
s	*(char)
=	O
(	O
nontrivial_match	int
&&	O
rl_completion_mark_symlink_dirs	int
==	O
0	int
)	O
?	O
LSTAT	O
(	O
filename	*(char)
,	O
&	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
:	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
filename	*(char)
,	O
&	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
s	*(char)
==	O
0	int
&&	O
S_ISDIR	O
(	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
_rl_complete_mark_directories	int
)	O
{	O
if	O
(	O
rl_point	int
&&	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
==	O
'\0'	O
&&	O
rl_line_buffer	*(char)
[	O
rl_point	int
-	O
1	int
]	O
==	O
'/'	O
)	O
;	O
else	O
if	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
!=	O
'/'	O
)	O
rl_insert_text	(*(char))->(int)
(	O
"/"	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
s	*(char)
==	O
0	int
&&	O
S_ISLNK	O
(	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
&&	O
path_isdir	(*(char))->(int)
(	O
filename	*(char)
)	O
)	O
;	O
else	O
{	O
if	O
(	O
rl_point	int
==	O
rl_end	int
&&	O
temp_string_index	int
)	O
rl_insert_text	(*(char))->(int)
(	O
temp_string	array(char)
)	O
;	O
}	O
xfree	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
rl_point	int
==	O
rl_end	int
&&	O
temp_string_index	int
)	O
rl_insert_text	(*(char))->(int)
(	O
temp_string	array(char)
)	O
;	O
}	O
return	O
(	O
temp_string_index	int
)	O
;	O
}	O
static	O
void	O
insert_all_matches	(*(*(char)),int,*(char))->(void)
(	O
matches	*(*(char))
,	O
point	int
,	O
qc	*(char)
)	O
char	O
*	O
*	O
matches	*(*(char))
;	O
int	O
point	int
;	O
char	O
*	O
qc	*(char)
;	O
{	O
int	O
i	int
;	O
char	O
*	O
rp	*(char)
;	O
rl_begin_undo_group	()->(int)
(	O
)	O
;	O
if	O
(	O
qc	*(char)
&&	O
*	O
qc	*(char)
&&	O
point	int
&&	O
rl_line_buffer	*(char)
[	O
point	int
-	O
1	int
]	O
==	O
*	O
qc	*(char)
)	O
point	int
--	O
;	O
rl_delete_text	(int,int)->(int)
(	O
point	int
,	O
rl_point	int
)	O
;	O
rl_point	int
=	O
point	int
;	O
if	O
(	O
matches	*(*(char))
[	O
1	int
]	O
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
matches	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
rp	*(char)
=	O
make_quoted_replacement	(*(char),int,*(char))->(*(char))
(	O
matches	*(*(char))
[	O
i	int
]	O
,	O
SINGLE_MATCH	int
,	O
qc	*(char)
)	O
;	O
rl_insert_text	(*(char))->(int)
(	O
rp	*(char)
)	O
;	O
rl_insert_text	(*(char))->(int)
(	O
" "	*(char)
)	O
;	O
if	O
(	O
rp	*(char)
!=	O
matches	*(*(char))
[	O
i	int
]	O
)	O
xfree	(*(void))->(void)
(	O
rp	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
rp	*(char)
=	O
make_quoted_replacement	(*(char),int,*(char))->(*(char))
(	O
matches	*(*(char))
[	O
0	int
]	O
,	O
SINGLE_MATCH	int
,	O
qc	*(char)
)	O
;	O
rl_insert_text	(*(char))->(int)
(	O
rp	*(char)
)	O
;	O
rl_insert_text	(*(char))->(int)
(	O
" "	*(char)
)	O
;	O
if	O
(	O
rp	*(char)
!=	O
matches	*(*(char))
[	O
0	int
]	O
)	O
xfree	(*(void))->(void)
(	O
rp	*(char)
)	O
;	O
}	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
}	O
void	O
_rl_free_match_list	(*(*(char)))->(void)
(	O
matches	*(*(char))
)	O
char	O
*	O
*	O
matches	*(*(char))
;	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
matches	*(*(char))
==	O
0	int
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
matches	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
xfree	(*(void))->(void)
(	O
matches	*(*(char))
[	O
i	int
]	O
)	O
;	O
xfree	(*(void))->(void)
(	O
matches	*(*(char))
)	O
;	O
}	O
int	O
rl_complete_internal	(int)->(int)
(	O
what_to_do	int
)	O
int	O
what_to_do	int
;	O
{	O
char	O
*	O
*	O
matches	*(*(char))
;	O
rl_compentry_func_t	(*(char),int)->(*(char))
*	O
our_func	*((*(char),int)->(*(char)))
;	O
int	O
start	int
,	O
end	int
,	O
delimiter	int
,	O
found_quote	int
,	O
i	int
,	O
nontrivial_lcd	int
;	O
char	O
*	O
text	*(char)
,	O
*	O
saved_line_buffer	*(char)
;	O
char	O
quote_char	char
;	O
int	O
tlen	long
,	O
mlen	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
set_completion_defaults	(int)->(void)
(	O
what_to_do	int
)	O
;	O
saved_line_buffer	*(char)
=	O
rl_line_buffer	*(char)
?	O
savestring	O
(	O
rl_line_buffer	*(char)
)	O
:	O
(	O
char	O
*	O
)	O
NULL	O
;	O
our_func	*((*(char),int)->(*(char)))
=	O
rl_completion_entry_function	*((*(char),int)->(*(char)))
?	O
rl_completion_entry_function	*((*(char),int)->(*(char)))
:	O
rl_filename_completion_function	(*(char),int)->(*(char))
;	O
end	int
=	O
rl_point	int
;	O
found_quote	int
=	O
delimiter	int
=	O
0	int
;	O
quote_char	char
=	O
'\0'	O
;	O
if	O
(	O
rl_point	int
)	O
quote_char	char
=	O
_rl_find_completion_word	(*(int),*(int))->(char)
(	O
&	O
found_quote	int
,	O
&	O
delimiter	int
)	O
;	O
start	int
=	O
rl_point	int
;	O
rl_point	int
=	O
end	int
;	O
text	*(char)
=	O
rl_copy_text	(int,int)->(*(char))
(	O
start	int
,	O
end	int
)	O
;	O
matches	*(*(char))
=	O
gen_completion_matches	(*(char),int,int,*((*(char),int)->(*(char))),int,int)->(*(*(char)))
(	O
text	*(char)
,	O
start	int
,	O
end	int
,	O
our_func	*((*(char),int)->(*(char)))
,	O
found_quote	int
,	O
quote_char	char
)	O
;	O
nontrivial_lcd	int
=	O
matches	*(*(char))
&&	O
strcmp	(*(char),*(char))->(int)
(	O
text	*(char)
,	O
matches	*(*(char))
[	O
0	int
]	O
)	O
!=	O
0	int
;	O
if	O
(	O
what_to_do	int
==	O
'!'	O
||	O
what_to_do	int
==	O
'@'	O
)	O
tlen	long
=	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
text	*(char)
)	O
;	O
if	O
(	O
matches	*(*(char))
==	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
FREE	O
(	O
saved_line_buffer	*(char)
)	O
;	O
completion_changed_buffer	int
=	O
0	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
_rl_reset_completion_state	()->(void)
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
i	int
=	O
rl_filename_completion_desired	int
;	O
if	O
(	O
postprocess_matches	(*(*(*(char))),int)->(int)
(	O
&	O
matches	*(*(char))
,	O
i	int
)	O
==	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
FREE	O
(	O
saved_line_buffer	*(char)
)	O
;	O
completion_changed_buffer	int
=	O
0	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
_rl_reset_completion_state	()->(void)
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
switch	O
(	O
what_to_do	int
)	O
{	O
case	O
TAB	char
:	O
case	O
'!'	O
:	O
case	O
'@'	O
:	O
if	O
(	O
what_to_do	int
==	O
TAB	char
)	O
{	O
if	O
(	O
*	O
matches	*(*(char))
[	O
0	int
]	O
)	O
insert_match	(*(char),int,int,*(char))->(void)
(	O
matches	*(*(char))
[	O
0	int
]	O
,	O
start	int
,	O
matches	*(*(char))
[	O
1	int
]	O
?	O
MULT_MATCH	int
:	O
SINGLE_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
}	O
else	O
if	O
(	O
*	O
matches	*(*(char))
[	O
0	int
]	O
&&	O
matches	*(*(char))
[	O
1	int
]	O
==	O
0	int
)	O
insert_match	(*(char),int,int,*(char))->(void)
(	O
matches	*(*(char))
[	O
0	int
]	O
,	O
start	int
,	O
matches	*(*(char))
[	O
1	int
]	O
?	O
MULT_MATCH	int
:	O
SINGLE_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
else	O
if	O
(	O
*	O
matches	*(*(char))
[	O
0	int
]	O
)	O
{	O
mlen	int
=	O
*	O
matches	*(*(char))
[	O
0	int
]	O
?	O
strlen	(*(char))->(long)
(	O
matches	*(*(char))
[	O
0	int
]	O
)	O
:	O
0	int
;	O
if	O
(	O
mlen	int
>=	O
tlen	long
)	O
insert_match	(*(char),int,int,*(char))->(void)
(	O
matches	*(*(char))
[	O
0	int
]	O
,	O
start	int
,	O
matches	*(*(char))
[	O
1	int
]	O
?	O
MULT_MATCH	int
:	O
SINGLE_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
}	O
if	O
(	O
matches	*(*(char))
[	O
1	int
]	O
)	O
{	O
if	O
(	O
what_to_do	int
==	O
'!'	O
)	O
{	O
display_matches	(*(*(char)))->(void)
(	O
matches	*(*(char))
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
what_to_do	int
==	O
'@'	O
)	O
{	O
if	O
(	O
nontrivial_lcd	int
==	O
0	int
)	O
display_matches	(*(*(char)))->(void)
(	O
matches	*(*(char))
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
rl_editing_mode	int
!=	O
vi_mode	int
)	O
rl_ding	()->(int)
(	O
)	O
;	O
}	O
else	O
append_to_match	(*(char),int,int,int)->(int)
(	O
matches	*(*(char))
[	O
0	int
]	O
,	O
delimiter	int
,	O
quote_char	char
,	O
nontrivial_lcd	int
)	O
;	O
break	O
;	O
case	O
'*'	O
:	O
insert_all_matches	(*(*(char)),int,*(char))->(void)
(	O
matches	*(*(char))
,	O
start	int
,	O
&	O
quote_char	char
)	O
;	O
break	O
;	O
case	O
'?'	O
:	O
if	O
(	O
rl_completion_display_matches_hook	*((*(*(char)),int,int)->(void))
==	O
0	int
)	O
{	O
_rl_sigcleanup	*((int,*(void))->(void))
=	O
_rl_complete_sigcleanup	(int,*(void))->(void)
;	O
_rl_sigcleanarg	*(void)
=	O
matches	*(*(char))
;	O
_rl_complete_display_matches_interrupt	int
=	O
0	int
;	O
}	O
display_matches	(*(*(char)))->(void)
(	O
matches	*(*(char))
)	O
;	O
if	O
(	O
_rl_complete_display_matches_interrupt	int
)	O
{	O
matches	*(*(char))
=	O
0	int
;	O
_rl_complete_display_matches_interrupt	int
=	O
0	int
;	O
if	O
(	O
rl_signal_event_hook	*(()->(int))
)	O
(	O
*	O
rl_signal_event_hook	*(()->(int))
)	O
(	O
)	O
;	O
}	O
_rl_sigcleanup	*((int,*(void))->(void))
=	O
0	int
;	O
_rl_sigcleanarg	*(void)
=	O
0	int
;	O
break	O
;	O
default	O
:	O
_rl_ttymsg	(*(char))->(void)
(	O
"bad value %d for what_to_do in rl_complete"	*(char)
,	O
what_to_do	int
)	O
;	O
rl_ding	()->(int)
(	O
)	O
;	O
FREE	O
(	O
saved_line_buffer	*(char)
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
_rl_free_match_list	(*(*(char)))->(void)
(	O
matches	*(*(char))
)	O
;	O
_rl_reset_completion_state	()->(void)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
_rl_free_match_list	(*(*(char)))->(void)
(	O
matches	*(*(char))
)	O
;	O
if	O
(	O
saved_line_buffer	*(char)
)	O
{	O
completion_changed_buffer	int
=	O
strcmp	(*(char),*(char))->(int)
(	O
rl_line_buffer	*(char)
,	O
saved_line_buffer	*(char)
)	O
!=	O
0	int
;	O
xfree	(*(void))->(void)
(	O
saved_line_buffer	*(char)
)	O
;	O
}	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
_rl_reset_completion_state	()->(void)
(	O
)	O
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
*	O
rl_completion_matches	(*(char),*((*(char),int)->(*(char))))->(*(*(char)))
(	O
text	*(char)
,	O
entry_function	*((*(char),int)->(*(char)))
)	O
const	O
char	O
*	O
text	*(char)
;	O
rl_compentry_func_t	(*(char),int)->(*(char))
*	O
entry_function	*((*(char),int)->(*(char)))
;	O
{	O
register	O
int	O
i	int
;	O
int	O
match_list_size	int
;	O
char	O
*	O
*	O
match_list	*(*(char))
;	O
int	O
matches	*(*(char))
;	O
char	O
*	O
string	*(char)
;	O
matches	*(*(char))
=	O
0	int
;	O
match_list_size	int
=	O
10	int
;	O
match_list	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
(	O
match_list_size	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
match_list	*(*(char))
[	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
while	O
(	O
string	*(char)
=	O
(	O
*	O
entry_function	*((*(char),int)->(*(char)))
)	O
(	O
text	*(char)
,	O
matches	*(*(char))
)	O
)	O
{	O
if	O
(	O
RL_SIG_RECEIVED	O
(	O
)	O
)	O
{	O
if	O
(	O
entry_function	*((*(char),int)->(*(char)))
==	O
rl_filename_completion_function	(*(char),int)->(*(char))
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
match_list	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
xfree	(*(void))->(void)
(	O
match_list	*(*(char))
[	O
i	int
]	O
)	O
;	O
}	O
xfree	(*(void))->(void)
(	O
match_list	*(*(char))
)	O
;	O
match_list	*(*(char))
=	O
0	int
;	O
match_list_size	int
=	O
0	int
;	O
matches	*(*(char))
=	O
0	int
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
}	O
if	O
(	O
matches	*(*(char))
+	O
1	int
>=	O
match_list_size	int
)	O
match_list	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
match_list	*(*(char))
,	O
(	O
(	O
match_list_size	int
+=	O
10	int
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
match_list	*(*(char))
==	O
0	int
)	O
return	O
(	O
match_list	*(*(char))
)	O
;	O
match_list	*(*(char))
[	O
++	O
matches	*(*(char))
]	O
=	O
string	*(char)
;	O
match_list	*(*(char))
[	O
matches	*(*(char))
+	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
matches	*(*(char))
)	O
compute_lcd_of_matches	(*(*(char)),int,*(char))->(int)
(	O
match_list	*(*(char))
,	O
matches	*(*(char))
,	O
text	*(char)
)	O
;	O
else	O
{	O
xfree	(*(void))->(void)
(	O
match_list	*(*(char))
)	O
;	O
match_list	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
NULL	O
;	O
}	O
return	O
(	O
match_list	*(*(char))
)	O
;	O
}	O
char	O
*	O
rl_username_completion_function	(*(char),int)->(*(char))
(	O
text	*(char)
,	O
state	*(int)
)	O
const	O
char	O
*	O
text	*(char)
;	O
int	O
state	*(int)
;	O
{	O
static	O
char	O
*	O
username	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
entry	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
static	O
int	O
namelen	int
,	O
first_char	int
,	O
first_char_loc	int
;	O
char	O
*	O
value	*(char)
;	O
if	O
(	O
state	*(int)
==	O
0	int
)	O
{	O
FREE	O
(	O
username	*(char)
)	O
;	O
first_char	int
=	O
*	O
text	*(char)
;	O
first_char_loc	int
=	O
first_char	int
==	O
'~'	O
;	O
username	*(char)
=	O
savestring	O
(	O
&	O
text	*(char)
[	O
first_char_loc	int
]	O
)	O
;	O
namelen	int
=	O
strlen	(*(char))->(long)
(	O
username	*(char)
)	O
;	O
setpwent	()->(void)
(	O
)	O
;	O
}	O
while	O
(	O
entry	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwent	()->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
)	O
)	O
{	O
if	O
(	O
namelen	int
==	O
0	int
||	O
(	O
STREQN	O
(	O
username	*(char)
,	O
entry	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_name	*(char)
,	O
namelen	int
)	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
entry	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
==	O
0	int
)	O
{	O
endpwent	()->(void)
(	O
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
else	O
{	O
value	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
2	int
+	O
strlen	(*(char))->(long)
(	O
entry	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_name	*(char)
)	O
)	O
;	O
*	O
value	*(char)
=	O
*	O
text	*(char)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
value	*(char)
+	O
first_char_loc	int
,	O
entry	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_name	*(char)
)	O
;	O
if	O
(	O
first_char	int
==	O
'~'	O
)	O
rl_filename_completion_desired	int
=	O
1	int
;	O
return	O
(	O
value	*(char)
)	O
;	O
}	O
}	O
static	O
int	O
complete_fncmp	(*(char),int,*(char),int)->(int)
(	O
convfn	*(char)
,	O
convlen	int
,	O
filename	*(char)
,	O
filename_len	int
)	O
const	O
char	O
*	O
convfn	*(char)
;	O
int	O
convlen	int
;	O
const	O
char	O
*	O
filename	*(char)
;	O
int	O
filename_len	int
;	O
{	O
register	O
char	O
*	O
s1	*(char)
,	O
*	O
s2	*(char)
;	O
int	O
d	int
,	O
len	long
;	O
size_t	long
v1	long
,	O
v2	long
;	O
mbstate_t	struct(int,union(int,array(char)))
ps1	struct(int,union(int,array(char)))
,	O
ps2	struct(int,union(int,array(char)))
;	O
wchar_t	int
wc1	int
,	O
wc2	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps1	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps2	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
if	O
(	O
filename_len	int
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
convlen	int
<	O
filename_len	int
)	O
return	O
0	int
;	O
len	long
=	O
filename_len	int
;	O
s1	*(char)
=	O
(	O
char	O
*	O
)	O
convfn	*(char)
;	O
s2	*(char)
=	O
(	O
char	O
*	O
)	O
filename	*(char)
;	O
if	O
(	O
_rl_completion_case_fold	int
&&	O
_rl_completion_case_map	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
do	O
{	O
v1	long
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc1	int
,	O
s1	*(char)
,	O
convlen	int
,	O
&	O
ps1	struct(int,union(int,array(char)))
)	O
;	O
v2	long
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc2	int
,	O
s2	*(char)
,	O
filename_len	int
,	O
&	O
ps2	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
v1	long
==	O
0	int
&&	O
v2	long
==	O
0	int
)	O
return	O
1	int
;	O
else	O
if	O
(	O
MB_INVALIDCH	O
(	O
v1	long
)	O
||	O
MB_INVALIDCH	O
(	O
v2	long
)	O
)	O
{	O
if	O
(	O
*	O
s1	*(char)
!=	O
*	O
s2	*(char)
)	O
return	O
0	int
;	O
else	O
if	O
(	O
(	O
*	O
s1	*(char)
==	O
'-'	O
||	O
*	O
s1	*(char)
==	O
'_'	O
)	O
&&	O
(	O
*	O
s2	*(char)
==	O
'-'	O
||	O
*	O
s2	*(char)
==	O
'_'	O
)	O
)	O
return	O
0	int
;	O
s1	*(char)
++	O
;	O
s2	*(char)
++	O
;	O
len	long
--	O
;	O
continue	O
;	O
}	O
wc1	int
=	O
towlower	(int)->(int)
(	O
wc1	int
)	O
;	O
wc2	int
=	O
towlower	(int)->(int)
(	O
wc2	int
)	O
;	O
s1	*(char)
+=	O
v1	long
;	O
s2	*(char)
+=	O
v1	long
;	O
len	long
-=	O
v1	long
;	O
if	O
(	O
(	O
wc1	int
==	O
L'-'	O
||	O
wc1	int
==	O
L'_'	O
)	O
&&	O
(	O
wc2	int
==	O
L'-'	O
||	O
wc2	int
==	O
L'_'	O
)	O
)	O
continue	O
;	O
if	O
(	O
wc1	int
!=	O
wc2	int
)	O
return	O
0	int
;	O
}	O
while	O
(	O
len	long
!=	O
0	int
)	O
;	O
}	O
else	O
{	O
do	O
{	O
d	int
=	O
_rl_to_lower	(int)->(int)
(	O
*	O
s1	*(char)
)	O
-	O
_rl_to_lower	(int)->(int)
(	O
*	O
s2	*(char)
)	O
;	O
if	O
(	O
(	O
*	O
s1	*(char)
==	O
'-'	O
||	O
*	O
s1	*(char)
==	O
'_'	O
)	O
&&	O
(	O
*	O
s2	*(char)
==	O
'-'	O
||	O
*	O
s2	*(char)
==	O
'_'	O
)	O
)	O
d	int
=	O
0	int
;	O
if	O
(	O
d	int
!=	O
0	int
)	O
return	O
0	int
;	O
s1	*(char)
++	O
;	O
s2	*(char)
++	O
;	O
}	O
while	O
(	O
--	O
len	long
!=	O
0	int
)	O
;	O
}	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
_rl_completion_case_fold	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
do	O
{	O
v1	long
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc1	int
,	O
s1	*(char)
,	O
convlen	int
,	O
&	O
ps1	struct(int,union(int,array(char)))
)	O
;	O
v2	long
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc2	int
,	O
s2	*(char)
,	O
filename_len	int
,	O
&	O
ps2	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
v1	long
==	O
0	int
&&	O
v2	long
==	O
0	int
)	O
return	O
1	int
;	O
else	O
if	O
(	O
MB_INVALIDCH	O
(	O
v1	long
)	O
||	O
MB_INVALIDCH	O
(	O
v2	long
)	O
)	O
{	O
if	O
(	O
*	O
s1	*(char)
!=	O
*	O
s2	*(char)
)	O
return	O
0	int
;	O
s1	*(char)
++	O
;	O
s2	*(char)
++	O
;	O
len	long
--	O
;	O
continue	O
;	O
}	O
wc1	int
=	O
towlower	(int)->(int)
(	O
wc1	int
)	O
;	O
wc2	int
=	O
towlower	(int)->(int)
(	O
wc2	int
)	O
;	O
if	O
(	O
wc1	int
!=	O
wc2	int
)	O
return	O
0	int
;	O
s1	*(char)
+=	O
v1	long
;	O
s2	*(char)
+=	O
v1	long
;	O
len	long
-=	O
v1	long
;	O
}	O
while	O
(	O
len	long
!=	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
_rl_to_lower	(int)->(int)
(	O
convfn	*(char)
[	O
0	int
]	O
)	O
==	O
_rl_to_lower	(int)->(int)
(	O
filename	*(char)
[	O
0	int
]	O
)	O
)	O
&&	O
(	O
convlen	int
>=	O
filename_len	int
)	O
&&	O
(	O
_rl_strnicmp	O
(	O
filename	*(char)
,	O
convfn	*(char)
,	O
filename_len	int
)	O
==	O
0	int
)	O
)	O
return	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
convfn	*(char)
[	O
0	int
]	O
==	O
filename	*(char)
[	O
0	int
]	O
)	O
&&	O
(	O
convlen	int
>=	O
filename_len	int
)	O
&&	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
filename	*(char)
,	O
convfn	*(char)
,	O
filename_len	int
)	O
==	O
0	int
)	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
char	O
*	O
rl_filename_completion_function	(*(char),int)->(*(char))
(	O
text	*(char)
,	O
state	*(int)
)	O
const	O
char	O
*	O
text	*(char)
;	O
int	O
state	*(int)
;	O
{	O
static	O
DIR	struct
*	O
directory	int
=	O
(	O
DIR	struct
*	O
)	O
NULL	O
;	O
static	O
char	O
*	O
filename	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
char	O
*	O
dirname	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
char	O
*	O
users_dirname	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
int	O
filename_len	int
;	O
char	O
*	O
temp	*(char)
,	O
*	O
dentry	*(char)
,	O
*	O
convfn	*(char)
;	O
int	O
dirlen	int
,	O
dentlen	int
,	O
convlen	int
;	O
int	O
tilde_dirname	int
;	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
entry	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
if	O
(	O
state	*(int)
==	O
0	int
)	O
{	O
if	O
(	O
directory	int
)	O
{	O
closedir	(*(struct))->(int)
(	O
directory	int
)	O
;	O
directory	int
=	O
(	O
DIR	struct
*	O
)	O
NULL	O
;	O
}	O
FREE	O
(	O
dirname	*(char)
)	O
;	O
FREE	O
(	O
filename	*(char)
)	O
;	O
FREE	O
(	O
users_dirname	*(char)
)	O
;	O
filename	*(char)
=	O
savestring	O
(	O
text	*(char)
)	O
;	O
if	O
(	O
*	O
text	*(char)
==	O
0	int
)	O
text	*(char)
=	O
"."	*(char)
;	O
dirname	*(char)
=	O
savestring	O
(	O
text	*(char)
)	O
;	O
temp	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
dirname	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
temp	*(char)
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
filename	*(char)
,	O
++	O
temp	*(char)
)	O
;	O
*	O
temp	*(char)
=	O
'\0'	O
;	O
}	O
else	O
{	O
dirname	*(char)
[	O
0	int
]	O
=	O
'.'	O
;	O
dirname	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
rl_completion_found_quote	int
&&	O
rl_filename_dequoting_function	*((*(char),int)->(*(char)))
)	O
users_dirname	*(char)
=	O
(	O
*	O
rl_filename_dequoting_function	*((*(char),int)->(*(char)))
)	O
(	O
dirname	*(char)
,	O
rl_completion_quote_character	int
)	O
;	O
else	O
users_dirname	*(char)
=	O
savestring	O
(	O
dirname	*(char)
)	O
;	O
tilde_dirname	int
=	O
0	int
;	O
if	O
(	O
*	O
dirname	*(char)
==	O
'~'	O
)	O
{	O
temp	*(char)
=	O
tilde_expand	(*(char))->(*(char))
(	O
dirname	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
dirname	*(char)
)	O
;	O
dirname	*(char)
=	O
temp	*(char)
;	O
tilde_dirname	int
=	O
1	int
;	O
}	O
if	O
(	O
rl_directory_rewrite_hook	*((*(*(char)))->(int))
)	O
(	O
*	O
rl_directory_rewrite_hook	*((*(*(char)))->(int))
)	O
(	O
&	O
dirname	*(char)
)	O
;	O
else	O
if	O
(	O
rl_directory_completion_hook	*((*(*(char)))->(int))
&&	O
(	O
*	O
rl_directory_completion_hook	*((*(*(char)))->(int))
)	O
(	O
&	O
dirname	*(char)
)	O
)	O
{	O
xfree	(*(void))->(void)
(	O
users_dirname	*(char)
)	O
;	O
users_dirname	*(char)
=	O
savestring	O
(	O
dirname	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
tilde_dirname	int
==	O
0	int
&&	O
rl_completion_found_quote	int
&&	O
rl_filename_dequoting_function	*((*(char),int)->(*(char)))
)	O
{	O
xfree	(*(void))->(void)
(	O
dirname	*(char)
)	O
;	O
dirname	*(char)
=	O
savestring	O
(	O
users_dirname	*(char)
)	O
;	O
}	O
directory	int
=	O
opendir	(*(char))->(*(struct))
(	O
dirname	*(char)
)	O
;	O
if	O
(	O
*	O
filename	*(char)
&&	O
rl_completion_found_quote	int
&&	O
rl_filename_dequoting_function	*((*(char),int)->(*(char)))
)	O
{	O
temp	*(char)
=	O
(	O
*	O
rl_filename_dequoting_function	*((*(char),int)->(*(char)))
)	O
(	O
filename	*(char)
,	O
rl_completion_quote_character	int
)	O
;	O
xfree	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
filename	*(char)
=	O
temp	*(char)
;	O
}	O
filename_len	int
=	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
;	O
rl_filename_completion_desired	int
=	O
1	int
;	O
}	O
entry	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
(	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
)	O
NULL	O
;	O
while	O
(	O
directory	int
&&	O
(	O
entry	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
directory	int
)	O
)	O
)	O
{	O
convfn	*(char)
=	O
dentry	*(char)
=	O
entry	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
d_name	array(char)
;	O
convlen	int
=	O
dentlen	int
=	O
D_NAMLEN	O
(	O
entry	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
)	O
;	O
if	O
(	O
rl_filename_rewrite_hook	*((*(char),int)->(*(char)))
)	O
{	O
convfn	*(char)
=	O
(	O
*	O
rl_filename_rewrite_hook	*((*(char),int)->(*(char)))
)	O
(	O
dentry	*(char)
,	O
dentlen	int
)	O
;	O
convlen	int
=	O
(	O
convfn	*(char)
==	O
dentry	*(char)
)	O
?	O
dentlen	int
:	O
strlen	(*(char))->(long)
(	O
convfn	*(char)
)	O
;	O
}	O
if	O
(	O
filename_len	int
==	O
0	int
)	O
{	O
if	O
(	O
_rl_match_hidden_files	int
==	O
0	int
&&	O
HIDDEN_FILE	O
(	O
convfn	*(char)
)	O
)	O
continue	O
;	O
if	O
(	O
convfn	*(char)
[	O
0	int
]	O
!=	O
'.'	O
||	O
(	O
convfn	*(char)
[	O
1	int
]	O
&&	O
(	O
convfn	*(char)
[	O
1	int
]	O
!=	O
'.'	O
||	O
convfn	*(char)
[	O
2	int
]	O
)	O
)	O
)	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
complete_fncmp	(*(char),int,*(char),int)->(int)
(	O
convfn	*(char)
,	O
convlen	int
,	O
filename	*(char)
,	O
filename_len	int
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
entry	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
==	O
0	int
)	O
{	O
if	O
(	O
directory	int
)	O
{	O
closedir	(*(struct))->(int)
(	O
directory	int
)	O
;	O
directory	int
=	O
(	O
DIR	struct
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
dirname	*(char)
)	O
{	O
xfree	(*(void))->(void)
(	O
dirname	*(char)
)	O
;	O
dirname	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
filename	*(char)
)	O
{	O
xfree	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
filename	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
users_dirname	*(char)
)	O
{	O
xfree	(*(void))->(void)
(	O
users_dirname	*(char)
)	O
;	O
users_dirname	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
dirname	*(char)
&&	O
(	O
dirname	*(char)
[	O
0	int
]	O
!=	O
'.'	O
||	O
dirname	*(char)
[	O
1	int
]	O
)	O
)	O
{	O
if	O
(	O
rl_complete_with_tilde_expansion	int
&&	O
*	O
users_dirname	*(char)
==	O
'~'	O
)	O
{	O
dirlen	int
=	O
strlen	(*(char))->(long)
(	O
dirname	*(char)
)	O
;	O
temp	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
2	int
+	O
dirlen	int
+	O
D_NAMLEN	O
(	O
entry	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
temp	*(char)
,	O
dirname	*(char)
)	O
;	O
if	O
(	O
dirname	*(char)
[	O
dirlen	int
-	O
1	int
]	O
!=	O
'/'	O
)	O
{	O
temp	*(char)
[	O
dirlen	int
++	O
]	O
=	O
'/'	O
;	O
temp	*(char)
[	O
dirlen	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
else	O
{	O
dirlen	int
=	O
strlen	(*(char))->(long)
(	O
users_dirname	*(char)
)	O
;	O
temp	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
2	int
+	O
dirlen	int
+	O
D_NAMLEN	O
(	O
entry	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
temp	*(char)
,	O
users_dirname	*(char)
)	O
;	O
if	O
(	O
users_dirname	*(char)
[	O
dirlen	int
-	O
1	int
]	O
!=	O
'/'	O
)	O
temp	*(char)
[	O
dirlen	int
++	O
]	O
=	O
'/'	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
temp	*(char)
+	O
dirlen	int
,	O
convfn	*(char)
)	O
;	O
}	O
else	O
temp	*(char)
=	O
savestring	O
(	O
convfn	*(char)
)	O
;	O
if	O
(	O
convfn	*(char)
!=	O
dentry	*(char)
)	O
xfree	(*(void))->(void)
(	O
convfn	*(char)
)	O
;	O
return	O
(	O
temp	*(char)
)	O
;	O
}	O
}	O
int	O
rl_old_menu_complete	(int,int)->(int)
(	O
count	int
,	O
invoking_key	int
)	O
int	O
count	int
,	O
invoking_key	int
;	O
{	O
rl_compentry_func_t	(*(char),int)->(*(char))
*	O
our_func	*((*(char),int)->(*(char)))
;	O
int	O
matching_filenames	int
,	O
found_quote	int
;	O
static	O
char	O
*	O
orig_text	*(char)
;	O
static	O
char	O
*	O
*	O
matches	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
static	O
int	O
match_list_index	int
=	O
0	int
;	O
static	O
int	O
match_list_size	int
=	O
0	int
;	O
static	O
int	O
orig_start	int
,	O
orig_end	int
;	O
static	O
char	O
quote_char	char
;	O
static	O
int	O
delimiter	int
;	O
if	O
(	O
rl_last_func	*((int,int)->(int))
!=	O
rl_old_menu_complete	(int,int)->(int)
)	O
{	O
FREE	O
(	O
orig_text	*(char)
)	O
;	O
if	O
(	O
matches	*(*(char))
)	O
_rl_free_match_list	(*(*(char)))->(void)
(	O
matches	*(*(char))
)	O
;	O
match_list_index	int
=	O
match_list_size	int
=	O
0	int
;	O
matches	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
NULL	O
;	O
rl_completion_invoking_key	int
=	O
invoking_key	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
set_completion_defaults	(int)->(void)
(	O
'%'	O
)	O
;	O
our_func	*((*(char),int)->(*(char)))
=	O
rl_menu_completion_entry_function	*((*(char),int)->(*(char)))
;	O
if	O
(	O
our_func	*((*(char),int)->(*(char)))
==	O
0	int
)	O
our_func	*((*(char),int)->(*(char)))
=	O
rl_completion_entry_function	*((*(char),int)->(*(char)))
?	O
rl_completion_entry_function	*((*(char),int)->(*(char)))
:	O
rl_filename_completion_function	(*(char),int)->(*(char))
;	O
orig_end	int
=	O
rl_point	int
;	O
found_quote	int
=	O
delimiter	int
=	O
0	int
;	O
quote_char	char
=	O
'\0'	O
;	O
if	O
(	O
rl_point	int
)	O
quote_char	char
=	O
_rl_find_completion_word	(*(int),*(int))->(char)
(	O
&	O
found_quote	int
,	O
&	O
delimiter	int
)	O
;	O
orig_start	int
=	O
rl_point	int
;	O
rl_point	int
=	O
orig_end	int
;	O
orig_text	*(char)
=	O
rl_copy_text	(int,int)->(*(char))
(	O
orig_start	int
,	O
orig_end	int
)	O
;	O
matches	*(*(char))
=	O
gen_completion_matches	(*(char),int,int,*((*(char),int)->(*(char))),int,int)->(*(*(char)))
(	O
orig_text	*(char)
,	O
orig_start	int
,	O
orig_end	int
,	O
our_func	*((*(char),int)->(*(char)))
,	O
found_quote	int
,	O
quote_char	char
)	O
;	O
matching_filenames	int
=	O
rl_filename_completion_desired	int
;	O
if	O
(	O
matches	*(*(char))
==	O
0	int
||	O
postprocess_matches	(*(*(*(char))),int)->(int)
(	O
&	O
matches	*(*(char))
,	O
matching_filenames	int
)	O
==	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
FREE	O
(	O
matches	*(*(char))
)	O
;	O
matches	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
FREE	O
(	O
orig_text	*(char)
)	O
;	O
orig_text	*(char)
=	O
(	O
char	O
*	O
)	O
0	int
;	O
completion_changed_buffer	int
=	O
0	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
for	O
(	O
match_list_size	int
=	O
0	int
;	O
matches	*(*(char))
[	O
match_list_size	int
]	O
;	O
match_list_size	int
++	O
)	O
;	O
if	O
(	O
match_list_size	int
>	O
1	int
&&	O
_rl_complete_show_all	int
)	O
display_matches	(*(*(char)))->(void)
(	O
matches	*(*(char))
)	O
;	O
}	O
if	O
(	O
matches	*(*(char))
==	O
0	int
||	O
match_list_size	int
==	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
FREE	O
(	O
matches	*(*(char))
)	O
;	O
matches	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
completion_changed_buffer	int
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
match_list_index	int
+=	O
count	int
;	O
if	O
(	O
match_list_index	int
<	O
0	int
)	O
{	O
while	O
(	O
match_list_index	int
<	O
0	int
)	O
match_list_index	int
+=	O
match_list_size	int
;	O
}	O
else	O
match_list_index	int
%=	O
match_list_size	int
;	O
if	O
(	O
match_list_index	int
==	O
0	int
&&	O
match_list_size	int
>	O
1	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
insert_match	(*(char),int,int,*(char))->(void)
(	O
orig_text	*(char)
,	O
orig_start	int
,	O
MULT_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
}	O
else	O
{	O
insert_match	(*(char),int,int,*(char))->(void)
(	O
matches	*(*(char))
[	O
match_list_index	int
]	O
,	O
orig_start	int
,	O
SINGLE_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
append_to_match	(*(char),int,int,int)->(int)
(	O
matches	*(*(char))
[	O
match_list_index	int
]	O
,	O
delimiter	int
,	O
quote_char	char
,	O
strcmp	(*(char),*(char))->(int)
(	O
orig_text	*(char)
,	O
matches	*(*(char))
[	O
match_list_index	int
]	O
)	O
)	O
;	O
}	O
completion_changed_buffer	int
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_menu_complete	(int,int)->(int)
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
rl_compentry_func_t	(*(char),int)->(*(char))
*	O
our_func	*((*(char),int)->(*(char)))
;	O
int	O
matching_filenames	int
,	O
found_quote	int
;	O
static	O
char	O
*	O
orig_text	*(char)
;	O
static	O
char	O
*	O
*	O
matches	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
static	O
int	O
match_list_index	int
=	O
0	int
;	O
static	O
int	O
match_list_size	int
=	O
0	int
;	O
static	O
int	O
nontrivial_lcd	int
=	O
0	int
;	O
static	O
int	O
full_completion	int
=	O
0	int
;	O
static	O
int	O
orig_start	int
,	O
orig_end	int
;	O
static	O
char	O
quote_char	char
;	O
static	O
int	O
delimiter	int
,	O
cstate	int
;	O
if	O
(	O
(	O
rl_last_func	*((int,int)->(int))
!=	O
rl_menu_complete	(int,int)->(int)
&&	O
rl_last_func	*((int,int)->(int))
!=	O
rl_backward_menu_complete	(int,int)->(int)
)	O
||	O
full_completion	int
)	O
{	O
FREE	O
(	O
orig_text	*(char)
)	O
;	O
if	O
(	O
matches	*(*(char))
)	O
_rl_free_match_list	(*(*(char)))->(void)
(	O
matches	*(*(char))
)	O
;	O
match_list_index	int
=	O
match_list_size	int
=	O
0	int
;	O
matches	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
NULL	O
;	O
full_completion	int
=	O
0	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
set_completion_defaults	(int)->(void)
(	O
'%'	O
)	O
;	O
our_func	*((*(char),int)->(*(char)))
=	O
rl_menu_completion_entry_function	*((*(char),int)->(*(char)))
;	O
if	O
(	O
our_func	*((*(char),int)->(*(char)))
==	O
0	int
)	O
our_func	*((*(char),int)->(*(char)))
=	O
rl_completion_entry_function	*((*(char),int)->(*(char)))
?	O
rl_completion_entry_function	*((*(char),int)->(*(char)))
:	O
rl_filename_completion_function	(*(char),int)->(*(char))
;	O
orig_end	int
=	O
rl_point	int
;	O
found_quote	int
=	O
delimiter	int
=	O
0	int
;	O
quote_char	char
=	O
'\0'	O
;	O
if	O
(	O
rl_point	int
)	O
quote_char	char
=	O
_rl_find_completion_word	(*(int),*(int))->(char)
(	O
&	O
found_quote	int
,	O
&	O
delimiter	int
)	O
;	O
orig_start	int
=	O
rl_point	int
;	O
rl_point	int
=	O
orig_end	int
;	O
orig_text	*(char)
=	O
rl_copy_text	(int,int)->(*(char))
(	O
orig_start	int
,	O
orig_end	int
)	O
;	O
matches	*(*(char))
=	O
gen_completion_matches	(*(char),int,int,*((*(char),int)->(*(char))),int,int)->(*(*(char)))
(	O
orig_text	*(char)
,	O
orig_start	int
,	O
orig_end	int
,	O
our_func	*((*(char),int)->(*(char)))
,	O
found_quote	int
,	O
quote_char	char
)	O
;	O
nontrivial_lcd	int
=	O
matches	*(*(char))
&&	O
strcmp	(*(char),*(char))->(int)
(	O
orig_text	*(char)
,	O
matches	*(*(char))
[	O
0	int
]	O
)	O
!=	O
0	int
;	O
matching_filenames	int
=	O
rl_filename_completion_desired	int
;	O
if	O
(	O
matches	*(*(char))
==	O
0	int
||	O
postprocess_matches	(*(*(*(char))),int)->(int)
(	O
&	O
matches	*(*(char))
,	O
matching_filenames	int
)	O
==	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
FREE	O
(	O
matches	*(*(char))
)	O
;	O
matches	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
FREE	O
(	O
orig_text	*(char)
)	O
;	O
orig_text	*(char)
=	O
(	O
char	O
*	O
)	O
0	int
;	O
completion_changed_buffer	int
=	O
0	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
for	O
(	O
match_list_size	int
=	O
0	int
;	O
matches	*(*(char))
[	O
match_list_size	int
]	O
;	O
match_list_size	int
++	O
)	O
;	O
if	O
(	O
match_list_size	int
==	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
FREE	O
(	O
matches	*(*(char))
)	O
;	O
matches	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
match_list_index	int
=	O
0	int
;	O
completion_changed_buffer	int
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
*	O
matches	*(*(char))
[	O
0	int
]	O
)	O
{	O
insert_match	(*(char),int,int,*(char))->(void)
(	O
matches	*(*(char))
[	O
0	int
]	O
,	O
orig_start	int
,	O
matches	*(*(char))
[	O
1	int
]	O
?	O
MULT_MATCH	int
:	O
SINGLE_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
orig_end	int
=	O
orig_start	int
+	O
strlen	(*(char))->(long)
(	O
matches	*(*(char))
[	O
0	int
]	O
)	O
;	O
completion_changed_buffer	int
=	O
STREQ	O
(	O
orig_text	*(char)
,	O
matches	*(*(char))
[	O
0	int
]	O
)	O
==	O
0	int
;	O
}	O
if	O
(	O
match_list_size	int
>	O
1	int
&&	O
_rl_complete_show_all	int
)	O
{	O
display_matches	(*(*(char)))->(void)
(	O
matches	*(*(char))
)	O
;	O
if	O
(	O
rl_completion_query_items	int
>	O
0	int
&&	O
match_list_size	int
>=	O
rl_completion_query_items	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
FREE	O
(	O
matches	*(*(char))
)	O
;	O
matches	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
full_completion	int
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
_rl_menu_complete_prefix_first	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
match_list_size	int
<=	O
1	int
)	O
{	O
append_to_match	(*(char),int,int,int)->(int)
(	O
matches	*(*(char))
[	O
0	int
]	O
,	O
delimiter	int
,	O
quote_char	char
,	O
nontrivial_lcd	int
)	O
;	O
full_completion	int
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
_rl_menu_complete_prefix_first	int
&&	O
match_list_size	int
>	O
1	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
matches	*(*(char))
==	O
0	int
||	O
match_list_size	int
==	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
FREE	O
(	O
matches	*(*(char))
)	O
;	O
matches	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
completion_changed_buffer	int
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
match_list_index	int
+=	O
count	int
;	O
if	O
(	O
match_list_index	int
<	O
0	int
)	O
{	O
while	O
(	O
match_list_index	int
<	O
0	int
)	O
match_list_index	int
+=	O
match_list_size	int
;	O
}	O
else	O
match_list_index	int
%=	O
match_list_size	int
;	O
if	O
(	O
match_list_index	int
==	O
0	int
&&	O
match_list_size	int
>	O
1	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
insert_match	(*(char),int,int,*(char))->(void)
(	O
matches	*(*(char))
[	O
0	int
]	O
,	O
orig_start	int
,	O
MULT_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
}	O
else	O
{	O
insert_match	(*(char),int,int,*(char))->(void)
(	O
matches	*(*(char))
[	O
match_list_index	int
]	O
,	O
orig_start	int
,	O
SINGLE_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
append_to_match	(*(char),int,int,int)->(int)
(	O
matches	*(*(char))
[	O
match_list_index	int
]	O
,	O
delimiter	int
,	O
quote_char	char
,	O
strcmp	(*(char),*(char))->(int)
(	O
orig_text	*(char)
,	O
matches	*(*(char))
[	O
match_list_index	int
]	O
)	O
)	O
;	O
}	O
completion_changed_buffer	int
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_backward_menu_complete	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_menu_complete	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
}	O
