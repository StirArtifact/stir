int	O
number_zerop	(int)->(int)
(	O
object	O
x	int
)	O
{	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
if	O
(	O
fix	()->(int)
(	O
x	int
)	O
==	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
return	O
(	O
0	int
)	O
;	O
case	O
t_shortfloat	O
:	O
if	O
(	O
sf	()->(int)
(	O
x	int
)	O
==	O
0.0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_longfloat	O
:	O
if	O
(	O
lf	()->(int)
(	O
x	int
)	O
==	O
0.0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_complex	O
:	O
return	O
(	O
number_zerop	(int)->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
)	O
&&	O
number_zerop	(int)->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
)	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
int	O
number_plusp	(int)->(int)
(	O
object	O
x	int
)	O
{	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
if	O
(	O
fix	()->(int)
(	O
x	int
)	O
>	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_bignum	O
:	O
if	O
(	O
big_sign	()->(int)
(	O
x	int
)	O
>	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_ratio	O
:	O
if	O
(	O
number_plusp	(int)->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
)	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_shortfloat	O
:	O
if	O
(	O
sf	()->(int)
(	O
x	int
)	O
>	O
0.0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_longfloat	O
:	O
if	O
(	O
lf	()->(int)
(	O
x	int
)	O
>	O
0.0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
TSor_rational_float	O
,	O
x	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
int	O
number_minusp	(int)->(int)
(	O
object	O
x	int
)	O
{	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
if	O
(	O
fix	()->(int)
(	O
x	int
)	O
<	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_bignum	O
:	O
if	O
(	O
big_sign	()->(int)
(	O
x	int
)	O
<	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_ratio	O
:	O
if	O
(	O
number_minusp	(int)->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
)	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_shortfloat	O
:	O
if	O
(	O
sf	()->(int)
(	O
x	int
)	O
<	O
0.0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_longfloat	O
:	O
if	O
(	O
lf	()->(int)
(	O
x	int
)	O
<	O
0.0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
TSor_rational_float	O
,	O
x	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
int	O
number_oddp	(int)->(int)
(	O
object	O
x	int
)	O
{	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_fixnum	O
)	O
i	int
=	O
fix	()->(int)
(	O
x	int
)	O
;	O
else	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_bignum	O
)	O
i	int
=	O
MP_LOW	()->(int)
(	O
MP	()->(int)
(	O
x	int
)	O
,	O
lgef	()->(int)
(	O
MP	()->(int)
(	O
x	int
)	O
)	O
)	O
;	O
else	O
FEwrong_type_argument	()->(int)
(	O
sLinteger	O
,	O
x	int
)	O
;	O
return	O
(	O
i	int
&	O
1	int
)	O
;	O
}	O
int	O
number_evenp	(int)->(int)
(	O
object	O
x	int
)	O
{	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_fixnum	O
)	O
i	int
=	O
fix	()->(int)
(	O
x	int
)	O
;	O
else	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_bignum	O
)	O
i	int
=	O
MP_LOW	()->(int)
(	O
MP	()->(int)
(	O
x	int
)	O
,	O
lgef	()->(int)
(	O
MP	()->(int)
(	O
x	int
)	O
)	O
)	O
;	O
else	O
FEwrong_type_argument	()->(int)
(	O
sLinteger	O
,	O
x	int
)	O
;	O
return	O
(	O
~	O
i	int
&	O
1	int
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lzerop	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
number_zerop	(int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
LFD	(int)->(int)
(	O
Lplusp	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_or_rational_float	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
number_plusp	(int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
LFD	(int)->(int)
(	O
Lminusp	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_or_rational_float	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
number_minusp	(int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
LFD	(int)->(int)
(	O
Loddp	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_integer	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
number_oddp	(int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
LFD	(int)->(int)
(	O
Levenp	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_integer	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
number_evenp	(int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
void	O
gcl_init_num_pred	()->(void)
(	O
void	O
)	O
{	O
big_register_1	O
=	O
new_bignum	()->(int)
(	O
)	O
;	O
ZERO_BIG	()->(int)
(	O
big_register_1	O
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
big_register_1	O
)	O
;	O
make_function	()->(int)
(	O
"ZEROP"	*(char)
,	O
Lzerop	int
)	O
;	O
make_function	()->(int)
(	O
"PLUSP"	*(char)
,	O
Lplusp	int
)	O
;	O
make_function	()->(int)
(	O
"MINUSP"	*(char)
,	O
Lminusp	int
)	O
;	O
make_function	()->(int)
(	O
"ODDP"	*(char)
,	O
Loddp	int
)	O
;	O
make_function	()->(int)
(	O
"EVENP"	*(char)
,	O
Levenp	int
)	O
;	O
}	O
