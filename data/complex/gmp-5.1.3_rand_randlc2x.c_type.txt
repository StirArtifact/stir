typedef	O
struct	O
{	O
mpz_t	array(struct(int,int,*(long)))
_mp_seed	array(struct(int,int,*(long)))
;	O
mpz_t	array(struct(int,int,*(long)))
_mp_a	array(struct(int,int,*(long)))
;	O
mp_size_t	long
_cn	long
;	O
mp_limb_t	long
_cp	array(long)
[	O
LIMBS_PER_ULONG	int
]	O
;	O
unsigned	O
long	O
_mp_m2exp	long
;	O
}	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
;	O
static	O
unsigned	O
long	O
int	O
lc	(*(long),array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))))->(long)
(	O
mp_ptr	*(long)
rp	*(long)
,	O
gmp_randstate_t	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
rstate	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
{	O
mp_ptr	*(long)
tp	*(long)
,	O
seedp	*(long)
,	O
ap	*(long)
;	O
mp_size_t	long
ta	long
;	O
mp_size_t	long
tn	long
,	O
seedn	long
,	O
an	long
;	O
unsigned	O
long	O
int	O
m2exp	long
;	O
unsigned	O
long	O
int	O
bits	int
;	O
int	O
cy	int
;	O
mp_size_t	long
xn	long
;	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
*	O
p	*(char)
;	O
TMP_DECL	O
;	O
p	*(char)
=	O
(	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
*	O
)	O
RNG_STATE	O
(	O
rstate	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
;	O
m2exp	long
=	O
p	*(char)
->	O
_mp_m2exp	long
;	O
seedp	*(long)
=	O
PTR	O
(	O
p	*(char)
->	O
_mp_seed	array(struct(int,int,*(long)))
)	O
;	O
seedn	long
=	O
SIZ	O
(	O
p	*(char)
->	O
_mp_seed	array(struct(int,int,*(long)))
)	O
;	O
ap	*(long)
=	O
PTR	O
(	O
p	*(char)
->	O
_mp_a	array(struct(int,int,*(long)))
)	O
;	O
an	long
=	O
SIZ	O
(	O
p	*(char)
->	O
_mp_a	array(struct(int,int,*(long)))
)	O
;	O
TMP_MARK	O
;	O
ta	long
=	O
an	long
+	O
seedn	long
+	O
1	int
;	O
tn	long
=	O
BITS_TO_LIMBS	O
(	O
m2exp	long
)	O
;	O
if	O
(	O
ta	long
<=	O
tn	long
)	O
{	O
mp_size_t	long
tmp	long
=	O
an	long
+	O
seedn	long
;	O
ta	long
=	O
tn	long
+	O
1	int
;	O
tp	*(long)
=	O
TMP_ALLOC_LIMBS	O
(	O
ta	long
)	O
;	O
MPN_ZERO	O
(	O
&	O
tp	*(long)
[	O
tmp	long
]	O
,	O
ta	long
-	O
tmp	long
)	O
;	O
}	O
else	O
tp	*(long)
=	O
TMP_ALLOC_LIMBS	O
(	O
ta	long
)	O
;	O
ASSERT	O
(	O
seedn	long
>=	O
an	long
&&	O
an	long
>	O
0	int
)	O
;	O
mpn_mul	O
(	O
tp	*(long)
,	O
seedp	*(long)
,	O
seedn	long
,	O
ap	*(long)
,	O
an	long
)	O
;	O
ASSERT	O
(	O
tn	long
>=	O
p	*(char)
->	O
_cn	long
)	O
;	O
__GMPN_ADD	O
(	O
cy	int
,	O
tp	*(long)
,	O
tp	*(long)
,	O
tn	long
,	O
p	*(char)
->	O
_cp	array(long)
,	O
p	*(char)
->	O
_cn	long
)	O
;	O
tp	*(long)
[	O
m2exp	long
/	O
GMP_NUMB_BITS	O
]	O
&=	O
(	O
CNST_LIMB	O
(	O
1	int
)	O
<<	O
m2exp	long
%	O
GMP_NUMB_BITS	O
)	O
-	O
1	int
;	O
MPN_COPY	O
(	O
PTR	O
(	O
p	*(char)
->	O
_mp_seed	array(struct(int,int,*(long)))
)	O
,	O
tp	*(long)
,	O
tn	long
)	O
;	O
bits	int
=	O
m2exp	long
/	O
2	int
;	O
xn	long
=	O
bits	int
/	O
GMP_NUMB_BITS	O
;	O
tn	long
-=	O
xn	long
;	O
if	O
(	O
tn	long
>	O
0	int
)	O
{	O
unsigned	O
int	O
cnt	int
=	O
bits	int
%	O
GMP_NUMB_BITS	O
;	O
if	O
(	O
cnt	int
!=	O
0	int
)	O
{	O
mpn_rshift	O
(	O
tp	*(long)
,	O
tp	*(long)
+	O
xn	long
,	O
tn	long
,	O
cnt	int
)	O
;	O
MPN_COPY_INCR	O
(	O
rp	*(long)
,	O
tp	*(long)
,	O
xn	long
+	O
1	int
)	O
;	O
}	O
else	O
MPN_COPY_INCR	O
(	O
rp	*(long)
,	O
tp	*(long)
+	O
xn	long
,	O
tn	long
)	O
;	O
}	O
TMP_FREE	O
;	O
return	O
(	O
m2exp	long
+	O
1	int
)	O
/	O
2	int
;	O
}	O
static	O
void	O
randget_lc	(array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))),*(long),long)->(void)
(	O
gmp_randstate_t	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
rstate	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
,	O
mp_ptr	*(long)
rp	*(long)
,	O
unsigned	O
long	O
int	O
nbits	long
)	O
{	O
unsigned	O
long	O
int	O
rbitpos	long
;	O
int	O
chunk_nbits	int
;	O
mp_ptr	*(long)
tp	*(long)
;	O
mp_size_t	long
tn	long
;	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
*	O
p	*(char)
;	O
TMP_DECL	O
;	O
p	*(char)
=	O
(	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
*	O
)	O
RNG_STATE	O
(	O
rstate	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
;	O
TMP_MARK	O
;	O
chunk_nbits	int
=	O
p	*(char)
->	O
_mp_m2exp	long
/	O
2	int
;	O
tn	long
=	O
BITS_TO_LIMBS	O
(	O
chunk_nbits	int
)	O
;	O
tp	*(long)
=	O
TMP_ALLOC_LIMBS	O
(	O
tn	long
)	O
;	O
rbitpos	long
=	O
0	int
;	O
while	O
(	O
rbitpos	long
+	O
chunk_nbits	int
<=	O
nbits	long
)	O
{	O
mp_ptr	*(long)
r2p	*(long)
=	O
rp	*(long)
+	O
rbitpos	long
/	O
GMP_NUMB_BITS	O
;	O
if	O
(	O
rbitpos	long
%	O
GMP_NUMB_BITS	O
!=	O
0	int
)	O
{	O
mp_limb_t	long
savelimb	long
,	O
rcy	long
;	O
lc	(*(long),array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))))->(long)
(	O
tp	*(long)
,	O
rstate	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
;	O
savelimb	long
=	O
r2p	*(long)
[	O
0	int
]	O
;	O
rcy	long
=	O
mpn_lshift	O
(	O
r2p	*(long)
,	O
tp	*(long)
,	O
tn	long
,	O
rbitpos	long
%	O
GMP_NUMB_BITS	O
)	O
;	O
r2p	*(long)
[	O
0	int
]	O
|=	O
savelimb	long
;	O
if	O
(	O
(	O
chunk_nbits	int
%	O
GMP_NUMB_BITS	O
+	O
rbitpos	long
%	O
GMP_NUMB_BITS	O
)	O
>	O
GMP_NUMB_BITS	O
)	O
r2p	*(long)
[	O
tn	long
]	O
=	O
rcy	long
;	O
}	O
else	O
{	O
lc	(*(long),array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))))->(long)
(	O
r2p	*(long)
,	O
rstate	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
;	O
}	O
rbitpos	long
+=	O
chunk_nbits	int
;	O
}	O
if	O
(	O
rbitpos	long
!=	O
nbits	long
)	O
{	O
mp_ptr	*(long)
r2p	*(long)
=	O
rp	*(long)
+	O
rbitpos	long
/	O
GMP_NUMB_BITS	O
;	O
int	O
last_nbits	int
=	O
nbits	long
-	O
rbitpos	long
;	O
tn	long
=	O
BITS_TO_LIMBS	O
(	O
last_nbits	int
)	O
;	O
lc	(*(long),array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))))->(long)
(	O
tp	*(long)
,	O
rstate	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
;	O
if	O
(	O
rbitpos	long
%	O
GMP_NUMB_BITS	O
!=	O
0	int
)	O
{	O
mp_limb_t	long
savelimb	long
,	O
rcy	long
;	O
savelimb	long
=	O
r2p	*(long)
[	O
0	int
]	O
;	O
rcy	long
=	O
mpn_lshift	O
(	O
r2p	*(long)
,	O
tp	*(long)
,	O
tn	long
,	O
rbitpos	long
%	O
GMP_NUMB_BITS	O
)	O
;	O
r2p	*(long)
[	O
0	int
]	O
|=	O
savelimb	long
;	O
if	O
(	O
rbitpos	long
+	O
tn	long
*	O
GMP_NUMB_BITS	O
-	O
rbitpos	long
%	O
GMP_NUMB_BITS	O
<	O
nbits	long
)	O
r2p	*(long)
[	O
tn	long
]	O
=	O
rcy	long
;	O
}	O
else	O
{	O
MPN_COPY	O
(	O
r2p	*(long)
,	O
tp	*(long)
,	O
tn	long
)	O
;	O
}	O
if	O
(	O
nbits	long
%	O
GMP_NUMB_BITS	O
!=	O
0	int
)	O
rp	*(long)
[	O
nbits	long
/	O
GMP_NUMB_BITS	O
]	O
&=	O
~	O
(	O
~	O
CNST_LIMB	O
(	O
0	int
)	O
<<	O
nbits	long
%	O
GMP_NUMB_BITS	O
)	O
;	O
}	O
TMP_FREE	O
;	O
}	O
static	O
void	O
randseed_lc	(array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))),*(struct(int,int,*(long))))->(void)
(	O
gmp_randstate_t	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
rstate	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
,	O
mpz_srcptr	*(struct(int,int,*(long)))
seed	*(struct(int,int,*(long)))
)	O
{	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
*	O
p	*(char)
=	O
(	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
*	O
)	O
RNG_STATE	O
(	O
rstate	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
;	O
mpz_ptr	*(struct(int,int,*(long)))
seedz	*(struct(int,int,*(long)))
=	O
p	*(char)
->	O
_mp_seed	array(struct(int,int,*(long)))
;	O
mp_size_t	long
seedn	long
=	O
BITS_TO_LIMBS	O
(	O
p	*(char)
->	O
_mp_m2exp	long
)	O
;	O
mpz_fdiv_r_2exp	O
(	O
seedz	*(struct(int,int,*(long)))
,	O
seed	*(struct(int,int,*(long)))
,	O
p	*(char)
->	O
_mp_m2exp	long
)	O
;	O
MPN_ZERO	O
(	O
&	O
PTR	O
(	O
seedz	*(struct(int,int,*(long)))
)	O
[	O
SIZ	O
(	O
seedz	*(struct(int,int,*(long)))
)	O
]	O
,	O
seedn	long
-	O
SIZ	O
(	O
seedz	*(struct(int,int,*(long)))
)	O
)	O
;	O
SIZ	O
(	O
seedz	*(struct(int,int,*(long)))
)	O
=	O
seedn	long
;	O
}	O
static	O
void	O
randclear_lc	(array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))))->(void)
(	O
gmp_randstate_t	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
rstate	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
{	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
*	O
p	*(char)
=	O
(	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
*	O
)	O
RNG_STATE	O
(	O
rstate	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
;	O
mpz_clear	O
(	O
p	*(char)
->	O
_mp_seed	array(struct(int,int,*(long)))
)	O
;	O
mpz_clear	O
(	O
p	*(char)
->	O
_mp_a	array(struct(int,int,*(long)))
)	O
;	O
(	O
*	O
__gmp_free_func	*((*(void),long)->(void))
)	O
(	O
p	*(char)
,	O
sizeof	O
(	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
)	O
)	O
;	O
}	O
static	O
void	O
randiset_lc	(*(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))),*(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))))->(void)
(	O
gmp_randstate_ptr	*(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
,	O
gmp_randstate_srcptr	*(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
;	O
static	O
const	O
gmp_randfnptr_t	struct(*((array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))),*(struct(int,int,*`)))->(void)),*((array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))),*(long),long)->(void)),*((array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))))->(void)),*((*(struct(array(struct(int,int,*(long))),enum(int,int),union`)),*(struct(array(struct(int,int,*(long))),enum(int,int),union`)))->(void)))
Linear_Congruential_Generator	struct(*((array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))),*(struct(int,int,*`)))->(void)),*((array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))),*(long),long)->(void)),*((array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))))->(void)),*((*(struct(array(struct(int,int,*(long))),enum(int,int),union`)),*(struct(array(struct(int,int,*(long))),enum(int,int),union`)))->(void)))
=	O
{	O
randseed_lc	(array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))),*(struct(int,int,*(long))))->(void)
,	O
randget_lc	(array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))),*(long),long)->(void)
,	O
randclear_lc	(array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))))->(void)
,	O
randiset_lc	(*(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))),*(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))))->(void)
}	O
;	O
static	O
void	O
randiset_lc	(*(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))),*(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))))->(void)
(	O
gmp_randstate_ptr	*(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
dst	*(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
,	O
gmp_randstate_srcptr	*(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
src	*(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
{	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
*	O
dstp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
,	O
*	O
srcp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
;	O
srcp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
=	O
(	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
*	O
)	O
RNG_STATE	O
(	O
src	*(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
;	O
dstp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
=	O
(	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
*	O
)	O
(	O
*	O
__gmp_allocate_func	*((long)->(*(void)))
)	O
(	O
sizeof	O
(	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
)	O
)	O
;	O
RNG_STATE	O
(	O
dst	*(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
=	O
(	O
mp_limb_t	long
*	O
)	O
(	O
void	O
*	O
)	O
dstp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
;	O
RNG_FNPTR	O
(	O
dst	*(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
=	O
(	O
void	O
*	O
)	O
&	O
Linear_Congruential_Generator	struct(*((array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))),*(struct(int,int,*`)))->(void)),*((array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))),*(long),long)->(void)),*((array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))))->(void)),*((*(struct(array(struct(int,int,*(long))),enum(int,int),union`)),*(struct(array(struct(int,int,*(long))),enum(int,int),union`)))->(void)))
;	O
mpz_init_set	O
(	O
dstp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
->	O
_mp_seed	array(struct(int,int,*(long)))
,	O
srcp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
->	O
_mp_seed	array(struct(int,int,*(long)))
)	O
;	O
mpz_init_set	O
(	O
dstp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
->	O
_mp_a	array(struct(int,int,*(long)))
,	O
srcp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
->	O
_mp_a	array(struct(int,int,*(long)))
)	O
;	O
dstp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
->	O
_cn	long
=	O
srcp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
->	O
_cn	long
;	O
dstp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
->	O
_cp	array(long)
[	O
0	int
]	O
=	O
srcp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
->	O
_cp	array(long)
[	O
0	int
]	O
;	O
if	O
(	O
LIMBS_PER_ULONG	int
>	O
1	int
)	O
dstp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
->	O
_cp	array(long)
[	O
1	int
]	O
=	O
srcp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
->	O
_cp	array(long)
[	O
1	int
]	O
;	O
if	O
(	O
LIMBS_PER_ULONG	int
>	O
2	int
)	O
MPN_COPY	O
(	O
dstp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
->	O
_cp	array(long)
+	O
2	int
,	O
srcp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
->	O
_cp	array(long)
+	O
2	int
,	O
LIMBS_PER_ULONG	int
-	O
2	int
)	O
;	O
dstp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
->	O
_mp_m2exp	long
=	O
srcp	*(struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long))
->	O
_mp_m2exp	long
;	O
}	O
void	O
gmp_randinit_lc_2exp	O
(	O
gmp_randstate_t	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
rstate	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
,	O
mpz_srcptr	*(struct(int,int,*(long)))
a	int
,	O
unsigned	O
long	O
int	O
c	long
,	O
mp_bitcnt_t	long
m2exp	long
)	O
{	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
*	O
p	*(char)
;	O
mp_size_t	long
seedn	long
=	O
BITS_TO_LIMBS	O
(	O
m2exp	long
)	O
;	O
ASSERT_ALWAYS	O
(	O
m2exp	long
!=	O
0	int
)	O
;	O
p	*(char)
=	O
__GMP_ALLOCATE_FUNC_TYPE	O
(	O
1	int
,	O
gmp_rand_lc_struct	struct(array(struct(int,int,*(long))),array(struct(int,int,*(long))),long,array(long),long)
)	O
;	O
RNG_STATE	O
(	O
rstate	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
=	O
(	O
mp_limb_t	long
*	O
)	O
(	O
void	O
*	O
)	O
p	*(char)
;	O
RNG_FNPTR	O
(	O
rstate	array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void))))
)	O
=	O
(	O
void	O
*	O
)	O
&	O
Linear_Congruential_Generator	struct(*((array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))),*(struct(int,int,*`)))->(void)),*((array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))),*(long),long)->(void)),*((array(struct(array(struct(int,int,*(long))),enum(int,int),union(*(void)))))->(void)),*((*(struct(array(struct(int,int,*(long))),enum(int,int),union`)),*(struct(array(struct(int,int,*(long))),enum(int,int),union`)))->(void)))
;	O
mpz_init2	O
(	O
p	*(char)
->	O
_mp_seed	array(struct(int,int,*(long)))
,	O
m2exp	long
)	O
;	O
MPN_ZERO	O
(	O
PTR	O
(	O
p	*(char)
->	O
_mp_seed	array(struct(int,int,*(long)))
)	O
,	O
seedn	long
)	O
;	O
SIZ	O
(	O
p	*(char)
->	O
_mp_seed	array(struct(int,int,*(long)))
)	O
=	O
seedn	long
;	O
PTR	O
(	O
p	*(char)
->	O
_mp_seed	array(struct(int,int,*(long)))
)	O
[	O
0	int
]	O
=	O
1	int
;	O
mpz_init	O
(	O
p	*(char)
->	O
_mp_a	array(struct(int,int,*(long)))
)	O
;	O
mpz_fdiv_r_2exp	O
(	O
p	*(char)
->	O
_mp_a	array(struct(int,int,*(long)))
,	O
a	int
,	O
m2exp	long
)	O
;	O
if	O
(	O
SIZ	O
(	O
p	*(char)
->	O
_mp_a	array(struct(int,int,*(long)))
)	O
==	O
0	int
)	O
{	O
SIZ	O
(	O
p	*(char)
->	O
_mp_a	array(struct(int,int,*(long)))
)	O
=	O
1	int
;	O
PTR	O
(	O
p	*(char)
->	O
_mp_a	array(struct(int,int,*(long)))
)	O
[	O
0	int
]	O
=	O
CNST_LIMB	O
(	O
0	int
)	O
;	O
}	O
MPN_SET_UI	O
(	O
p	*(char)
->	O
_cp	array(long)
,	O
p	*(char)
->	O
_cn	long
,	O
c	long
)	O
;	O
if	O
(	O
seedn	long
<	O
p	*(char)
->	O
_cn	long
)	O
p	*(char)
->	O
_cn	long
=	O
(	O
p	*(char)
->	O
_cp	array(long)
[	O
0	int
]	O
!=	O
0	int
)	O
;	O
p	*(char)
->	O
_mp_m2exp	long
=	O
m2exp	long
;	O
}	O
