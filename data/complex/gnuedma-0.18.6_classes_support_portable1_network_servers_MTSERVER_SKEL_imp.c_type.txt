typedef	O
struct	O
{	O
EUint32	long
Port	long
;	O
EUint32	long
BackLog	long
;	O
OBJID	int
Channel	int
;	O
ESint32	int
MaxClients	int
;	O
EDMAT_BUFFER	struct(long,long,*(void))
Data	struct(long,long,*(void))
;	O
ESint32	int
n	int
;	O
pthread_mutex_t	union(struct(int,int,int,int,int,union(struct(short,short),struct(*(struct`)))),array(char),long)
*	O
smutex	*(union(struct(int,int,int,int,int,union(struct(short,short),struct(*`))),array(char),long))
;	O
}	O
DtMTSERVER_SKEL	struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))
;	O
typedef	O
struct	O
{	O
pthread_t	long
tid	long
;	O
OBJID	int
server	int
;	O
OBJID	int
id	int
;	O
time_t	long
tstart	long
;	O
time_t	long
tend	long
;	O
}	O
CLIENT	struct(long,int,int,long,long)
;	O
void	O
*	O
service	(*(void))->(*(void))
(	O
void	O
*	O
)	O
;	O
ESint32	int
EDMAPROC	O
MTSERVER_SKELinitZS32rS32	(int,*(char),int)->(int)
(	O
OBJID	int
IdObj	int
,	O
EPChar	*(char)
res	*(char)
,	O
ESint32	int
n	int
)	O
{	O
DtMTSERVER_SKEL	struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))
*	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
;	O
ESint32	int
i	int
,	O
r	int
;	O
CLIENT	struct(long,int,int,long,long)
*	O
ci	*(struct(long,int,int,long,long))
;	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
=	O
(	O
DtMTSERVER_SKEL	struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
if	O
(	O
(	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
Channel	int
=	O
edma_new_obj	(*(char))->(int)
(	O
"CHANNEL"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"%s"	*(char)
,	O
"[ERROR] Can't create 'CHANNEL' object"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
r	int
=	O
(	O
ESint32	int
)	O
edma_met3	(int,*(char))->(int)
(	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
Channel	int
,	O
"open"	*(char)
,	O
res	*(char)
)	O
;	O
if	O
(	O
r	int
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"%s"	*(char)
,	O
"[ERROR] Can't open '%s'"	*(char)
,	O
res	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"[INFO] Initializing %d client data structs"	*(char)
,	O
n	int
)	O
;	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
MaxClients	int
=	O
n	int
;	O
if	O
(	O
(	O
edma_buffer_alloc	(*(struct(long,long,*(void))),long)->(int)
(	O
&	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
Data	struct(long,long,*(void))
,	O
sizeof	O
(	O
CLIENT	struct(long,int,int,long,long)
)	O
*	O
n	int
)	O
)	O
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"%s"	*(char)
,	O
"[ERROR] Can't allocate mt client table"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
ci	*(struct(long,int,int,long,long))
=	O
(	O
CLIENT	struct(long,int,int,long,long)
*	O
)	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
Data	struct(long,long,*(void))
.	O
dat	*(void)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
ci	*(struct(long,int,int,long,long))
[	O
i	int
]	O
.	O
id	int
=	O
-	O
1	int
;	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
n	int
=	O
0	int
;	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
smutex	*(union(struct(int,int,int,int,int,union(struct(short,short),struct(*`))),array(char),long))
=	O
(	O
pthread_mutex_t	union(struct(int,int,int,int,int,union(struct(short,short),struct(*(struct`)))),array(char),long)
*	O
)	O
malloc	(int)->(*(void))
(	O
sizeof	O
(	O
pthread_mutex_t	union(struct(int,int,int,int,int,union(struct(short,short),struct(*(struct`)))),array(char),long)
)	O
)	O
;	O
if	O
(	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
smutex	*(union(struct(int,int,int,int,int,union(struct(short,short),struct(*`))),array(char),long))
==	O
NULL	O
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"%s"	*(char)
,	O
"[ERROR] Can't allocate mutex"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pthread_mutex_init	(*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)),*(union(array(char),int)))->(int)
(	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
smutex	*(union(struct(int,int,int,int,int,union(struct(short,short),struct(*`))),array(char),long))
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
MTSERVER_SKELrunrS32	(int)->(int)
(	O
OBJID	int
IdObj	int
)	O
{	O
DtMTSERVER_SKEL	struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))
*	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
;	O
OBJID	int
id	int
;	O
CLIENT	struct(long,int,int,long,long)
*	O
ci	*(struct(long,int,int,long,long))
;	O
ESint32	int
i	int
;	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
=	O
(	O
DtMTSERVER_SKEL	struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
ci	*(struct(long,int,int,long,long))
=	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
Data	struct(long,long,*(void))
.	O
dat	*(void)
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
(	O
edma_met3	(int,*(char))->(int)
(	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
Channel	int
,	O
"wait"	*(char)
,	O
&	O
id	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"%s"	*(char)
,	O
"wait error..."	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
id	int
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"%s"	*(char)
,	O
"wait error...."	*(char)
)	O
;	O
continue	O
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))->(int)
(	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
smutex	*(union(struct(int,int,int,int,int,union(struct(short,short),struct(*`))),array(char),long))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
MaxClients	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
ci	*(struct(long,int,int,long,long))
[	O
i	int
]	O
.	O
id	int
==	O
-	O
1	int
)	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
MaxClients	int
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"%s"	*(char)
,	O
"[ERROR] Can't accept more connections"	*(char)
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Clossing connection with object %d"	*(char)
,	O
id	int
)	O
;	O
edma_met3	(int,*(char))->(int)
(	O
id	int
,	O
"Close"	*(char)
)	O
;	O
edma_free_obj	(int)->(long)
(	O
id	int
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))->(int)
(	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
smutex	*(union(struct(int,int,int,int,int,union(struct(short,short),struct(*`))),array(char),long))
)	O
;	O
continue	O
;	O
}	O
ci	*(struct(long,int,int,long,long))
[	O
i	int
]	O
.	O
id	int
=	O
id	int
;	O
ci	*(struct(long,int,int,long,long))
[	O
i	int
]	O
.	O
server	int
=	O
IdObj	int
;	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
n	int
++	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))->(int)
(	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
->	O
smutex	*(union(struct(int,int,int,int,int,union(struct(short,short),struct(*`))),array(char),long))
)	O
;	O
time	(*(long))->(long)
(	O
&	O
ci	*(struct(long,int,int,long,long))
[	O
i	int
]	O
.	O
tstart	long
)	O
;	O
pthread_create	(*(long),*(union(array(char),long)),*((*(void))->(*(void))),*(void))->(int)
(	O
&	O
ci	*(struct(long,int,int,long,long))
[	O
i	int
]	O
.	O
tid	long
,	O
NULL	O
,	O
service	(*(void))->(*(void))
,	O
&	O
ci	*(struct(long,int,int,long,long))
[	O
i	int
]	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
MTSERVER_SKELonRequestOrS32	(int,int)->(int)
(	O
OBJID	int
IdObj	int
,	O
OBJID	int
id	int
)	O
{	O
DtMTSERVER_SKEL	struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))
*	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
;	O
EChar	char
remote	array(char)
[	O
1024	int
]	O
;	O
m	*(struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union`),array(char),long))))
=	O
(	O
DtMTSERVER_SKEL	struct(long,long,int,int,struct(long,long,*(void)),int,*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"%s"	*(char)
,	O
"[Warnning] You haven't override this method for managing requests"	*(char)
)	O
;	O
edma_rprop3	(int,*(char))->(int)
(	O
id	int
,	O
"Resource"	*(char)
,	O
remote	array(char)
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"[Warnning] Request arrived from: %s"	*(char)
,	O
remote	array(char)
)	O
;	O
return	O
0	int
;	O
}	O
void	O
*	O
service	(*(void))->(*(void))
(	O
void	O
*	O
data	*(void)
)	O
{	O
CLIENT	struct(long,int,int,long,long)
*	O
ci	*(struct(long,int,int,long,long))
;	O
ESint32	int
n	int
;	O
pthread_mutex_t	union(struct(int,int,int,int,int,union(struct(short,short),struct(*(struct`)))),array(char),long)
*	O
the_mutex	*(union(struct(int,int,int,int,int,union(struct(short,short),struct(*`))),array(char),long))
;	O
edma_thread_register	()->(int)
(	O
)	O
;	O
ci	*(struct(long,int,int,long,long))
=	O
(	O
CLIENT	struct(long,int,int,long,long)
*	O
)	O
data	*(void)
;	O
edma_met3	(int,*(char))->(int)
(	O
ci	*(struct(long,int,int,long,long))
->	O
server	int
,	O
"onRequest"	*(char)
,	O
ci	*(struct(long,int,int,long,long))
->	O
id	int
)	O
;	O
time	(*(long))->(long)
(	O
&	O
ci	*(struct(long,int,int,long,long))
->	O
tend	long
)	O
;	O
edma_met3	(int,*(char))->(int)
(	O
ci	*(struct(long,int,int,long,long))
->	O
id	int
,	O
"Close"	*(char)
)	O
;	O
edma_rprop3	(int,*(char))->(int)
(	O
ci	*(struct(long,int,int,long,long))
->	O
server	int
,	O
"smutex"	*(char)
,	O
&	O
the_mutex	*(union(struct(int,int,int,int,int,union(struct(short,short),struct(*`))),array(char),long))
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))->(int)
(	O
the_mutex	*(union(struct(int,int,int,int,int,union(struct(short,short),struct(*`))),array(char),long))
)	O
;	O
edma_free_obj	(int)->(long)
(	O
ci	*(struct(long,int,int,long,long))
->	O
id	int
)	O
;	O
edma_rprop3	(int,*(char))->(int)
(	O
ci	*(struct(long,int,int,long,long))
->	O
server	int
,	O
"n"	*(char)
,	O
&	O
n	int
)	O
;	O
n	int
--	O
;	O
edma_wprop3	(int,*(char))->(int)
(	O
ci	*(struct(long,int,int,long,long))
->	O
server	int
,	O
"n"	*(char)
,	O
n	int
)	O
;	O
ci	*(struct(long,int,int,long,long))
->	O
id	int
=	O
-	O
1	int
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))->(int)
(	O
the_mutex	*(union(struct(int,int,int,int,int,union(struct(short,short),struct(*`))),array(char),long))
)	O
;	O
edma_thread_unregister	()->(int)
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
