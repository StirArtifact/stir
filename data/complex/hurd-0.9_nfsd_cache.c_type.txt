static	O
struct	O
idspec	O
*	O
idhashtable	array(*(struct))
[	O
IDHASH_TABLE_SIZE	int
]	O
;	O
pthread_spinlock_t	int
idhashlock	int
=	O
PTHREAD_SPINLOCK_INITIALIZER	O
;	O
static	O
int	O
nfreeids	int
;	O
static	O
int	O
leastidlastuse	int
;	O
static	O
int	O
idspec_compare	(*(struct),int,int,*(int),*(int))->(int)
(	O
struct	O
idspec	O
*	O
i	*(struct)
,	O
int	O
nuids	int
,	O
int	O
ngids	int
,	O
int	O
*	O
uids	*(int)
,	O
int	O
*	O
gids	*(int)
)	O
{	O
if	O
(	O
i	*(struct)
->	O
nuids	int
!=	O
nuids	int
||	O
i	*(struct)
->	O
ngids	int
!=	O
ngids	int
)	O
return	O
0	int
;	O
assert	O
(	O
sizeof	O
(	O
int	O
)	O
==	O
sizeof	O
(	O
uid_t	O
)	O
)	O
;	O
if	O
(	O
bcmp	(*(void),*(void),long)->(int)
(	O
i	*(struct)
->	O
uids	*(int)
,	O
uids	*(int)
,	O
nuids	int
*	O
sizeof	O
(	O
uid_t	O
)	O
)	O
||	O
bcmp	(*(void),*(void),long)->(int)
(	O
i	*(struct)
->	O
gids	*(int)
,	O
gids	*(int)
,	O
ngids	int
*	O
sizeof	O
(	O
gid_t	O
)	O
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
idspec_hash	(int,int,*(int),*(int))->(int)
(	O
int	O
nuids	int
,	O
int	O
ngids	int
,	O
int	O
*	O
uids	*(int)
,	O
int	O
*	O
gids	*(int)
)	O
{	O
int	O
hash	int
,	O
n	int
;	O
hash	int
=	O
nuids	int
+	O
ngids	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
ngids	int
;	O
n	int
++	O
)	O
hash	int
+=	O
gids	*(int)
[	O
n	int
]	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
nuids	int
;	O
n	int
++	O
)	O
hash	int
+=	O
uids	*(int)
[	O
n	int
]	O
;	O
hash	int
%=	O
IDHASH_TABLE_SIZE	int
;	O
return	O
hash	int
;	O
}	O
static	O
struct	O
idspec	O
*	O
idspec_lookup	(int,int,*(int),*(int))->(*(struct))
(	O
int	O
nuids	int
,	O
int	O
ngids	int
,	O
int	O
*	O
uids	*(int)
,	O
int	O
*	O
gids	*(int)
)	O
{	O
int	O
hash	int
;	O
struct	O
idspec	O
*	O
i	*(struct)
;	O
hash	int
=	O
idspec_hash	(int,int,*(int),*(int))->(int)
(	O
nuids	int
,	O
ngids	int
,	O
uids	*(int)
,	O
gids	*(int)
)	O
;	O
pthread_spin_lock	(*(int))->(int)
(	O
&	O
idhashlock	int
)	O
;	O
for	O
(	O
i	*(struct)
=	O
idhashtable	array(*(struct))
[	O
hash	int
]	O
;	O
i	*(struct)
;	O
i	*(struct)
=	O
i	*(struct)
->	O
next	O
)	O
if	O
(	O
idspec_compare	(*(struct),int,int,*(int),*(int))->(int)
(	O
i	*(struct)
,	O
nuids	int
,	O
ngids	int
,	O
uids	*(int)
,	O
gids	*(int)
)	O
)	O
{	O
i	*(struct)
->	O
references	O
++	O
;	O
if	O
(	O
i	*(struct)
->	O
references	O
==	O
1	int
)	O
nfreeids	int
--	O
;	O
pthread_spin_unlock	(*(int))->(int)
(	O
&	O
idhashlock	int
)	O
;	O
return	O
i	*(struct)
;	O
}	O
assert	O
(	O
sizeof	O
(	O
uid_t	O
)	O
==	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
i	*(struct)
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
idspec	O
)	O
)	O
;	O
i	*(struct)
->	O
nuids	int
=	O
nuids	int
;	O
i	*(struct)
->	O
ngids	int
=	O
ngids	int
;	O
i	*(struct)
->	O
uids	*(int)
=	O
malloc	O
(	O
nuids	int
*	O
sizeof	O
(	O
uid_t	O
)	O
)	O
;	O
i	*(struct)
->	O
gids	*(int)
=	O
malloc	O
(	O
ngids	int
*	O
sizeof	O
(	O
gid_t	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
i	*(struct)
->	O
uids	*(int)
,	O
uids	*(int)
,	O
nuids	int
*	O
sizeof	O
(	O
uid_t	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
i	*(struct)
->	O
gids	*(int)
,	O
gids	*(int)
,	O
ngids	int
*	O
sizeof	O
(	O
gid_t	O
)	O
)	O
;	O
i	*(struct)
->	O
references	O
=	O
1	int
;	O
i	*(struct)
->	O
next	O
=	O
idhashtable	array(*(struct))
[	O
hash	int
]	O
;	O
if	O
(	O
idhashtable	array(*(struct))
[	O
hash	int
]	O
)	O
idhashtable	array(*(struct))
[	O
hash	int
]	O
->	O
prevp	O
=	O
&	O
i	*(struct)
->	O
next	O
;	O
i	*(struct)
->	O
prevp	O
=	O
&	O
idhashtable	array(*(struct))
[	O
hash	int
]	O
;	O
idhashtable	array(*(struct))
[	O
hash	int
]	O
=	O
i	*(struct)
;	O
pthread_spin_unlock	(*(int))->(int)
(	O
&	O
idhashlock	int
)	O
;	O
return	O
i	*(struct)
;	O
}	O
int	O
*	O
process_cred	(*(int),*(*(struct)))->(*(int))
(	O
int	O
*	O
p	*(int)
,	O
struct	O
idspec	O
*	O
*	O
credp	*(*(struct))
)	O
{	O
int	O
type	int
;	O
int	O
len	int
;	O
int	O
*	O
uid	*(int)
;	O
int	O
*	O
gids	*(int)
;	O
int	O
ngids	int
;	O
int	O
firstgid	int
;	O
int	O
i	*(struct)
;	O
type	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
type	int
!=	O
AUTH_UNIX	O
)	O
{	O
int	O
size	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
*	O
credp	*(*(struct))
=	O
idspec_lookup	(int,int,*(int),*(int))->(*(struct))
(	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
p	*(int)
+=	O
INTSIZE	()->(int)
(	O
size	int
)	O
;	O
}	O
else	O
{	O
p	*(int)
++	O
;	O
p	*(int)
++	O
;	O
len	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
p	*(int)
+=	O
INTSIZE	()->(int)
(	O
len	int
)	O
;	O
uid	*(int)
=	O
p	*(int)
++	O
;	O
*	O
uid	*(int)
=	O
ntohl	()->(int)
(	O
*	O
uid	*(int)
)	O
;	O
firstgid	int
=	O
*	O
(	O
p	*(int)
++	O
)	O
;	O
gids	*(int)
=	O
p	*(int)
;	O
ngids	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
*	O
gids	*(int)
=	O
firstgid	int
;	O
ngids	int
++	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
ngids	int
;	O
i	*(struct)
++	O
)	O
gids	*(int)
[	O
i	*(struct)
]	O
=	O
ntohl	()->(int)
(	O
gids	*(int)
[	O
i	*(struct)
]	O
)	O
;	O
p	*(int)
+=	O
ngids	int
-	O
1	int
;	O
*	O
credp	*(*(struct))
=	O
idspec_lookup	(int,int,*(int),*(int))->(*(struct))
(	O
1	int
,	O
ngids	int
,	O
uid	*(int)
,	O
gids	*(int)
)	O
;	O
}	O
p	*(int)
++	O
;	O
len	int
=	O
htonl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
p	*(int)
+=	O
INTSIZE	()->(int)
(	O
len	int
)	O
;	O
return	O
p	*(int)
;	O
}	O
void	O
cred_rele	(*(struct))->(void)
(	O
struct	O
idspec	O
*	O
i	*(struct)
)	O
{	O
pthread_spin_lock	(*(int))->(int)
(	O
&	O
idhashlock	int
)	O
;	O
i	*(struct)
->	O
references	O
--	O
;	O
if	O
(	O
i	*(struct)
->	O
references	O
==	O
0	int
)	O
{	O
i	*(struct)
->	O
lastuse	O
=	O
mapped_time	O
->	O
seconds	O
;	O
if	O
(	O
i	*(struct)
->	O
lastuse	O
<	O
leastidlastuse	int
||	O
nfreeids	int
==	O
0	int
)	O
leastidlastuse	int
=	O
i	*(struct)
->	O
lastuse	O
;	O
nfreeids	int
++	O
;	O
}	O
pthread_spin_unlock	(*(int))->(int)
(	O
&	O
idhashlock	int
)	O
;	O
}	O
void	O
cred_ref	(*(struct))->(void)
(	O
struct	O
idspec	O
*	O
i	*(struct)
)	O
{	O
pthread_spin_lock	(*(int))->(int)
(	O
&	O
idhashlock	int
)	O
;	O
assert	O
(	O
i	*(struct)
->	O
references	O
)	O
;	O
i	*(struct)
->	O
references	O
++	O
;	O
pthread_spin_unlock	(*(int))->(int)
(	O
&	O
idhashlock	int
)	O
;	O
}	O
void	O
scan_creds	()->(void)
(	O
)	O
{	O
int	O
n	int
;	O
int	O
newleast	int
=	O
mapped_time	O
->	O
seconds	O
;	O
pthread_spin_lock	(*(int))->(int)
(	O
&	O
idhashlock	int
)	O
;	O
if	O
(	O
mapped_time	O
->	O
seconds	O
-	O
leastidlastuse	int
>	O
ID_KEEP_TIMEOUT	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
IDHASH_TABLE_SIZE	int
&&	O
nfreeids	int
;	O
n	int
++	O
)	O
{	O
struct	O
idspec	O
*	O
i	*(struct)
=	O
idhashtable	array(*(struct))
[	O
n	int
]	O
;	O
while	O
(	O
i	*(struct)
&&	O
nfreeids	int
)	O
{	O
struct	O
idspec	O
*	O
next_i	*(struct)
=	O
i	*(struct)
->	O
next	O
;	O
if	O
(	O
!	O
i	*(struct)
->	O
references	O
&&	O
mapped_time	O
->	O
seconds	O
-	O
i	*(struct)
->	O
lastuse	O
>	O
ID_KEEP_TIMEOUT	O
)	O
{	O
nfreeids	int
--	O
;	O
*	O
i	*(struct)
->	O
prevp	O
=	O
i	*(struct)
->	O
next	O
;	O
if	O
(	O
i	*(struct)
->	O
next	O
)	O
i	*(struct)
->	O
next	O
->	O
prevp	O
=	O
i	*(struct)
->	O
prevp	O
;	O
free	()->(int)
(	O
i	*(struct)
->	O
uids	*(int)
)	O
;	O
free	()->(int)
(	O
i	*(struct)
->	O
gids	*(int)
)	O
;	O
free	()->(int)
(	O
i	*(struct)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
i	*(struct)
->	O
references	O
&&	O
newleast	int
>	O
i	*(struct)
->	O
lastuse	O
)	O
newleast	int
=	O
i	*(struct)
->	O
lastuse	O
;	O
i	*(struct)
=	O
next_i	*(struct)
;	O
}	O
}	O
if	O
(	O
nfreeids	int
)	O
leastidlastuse	int
=	O
newleast	int
;	O
}	O
pthread_spin_unlock	(*(int))->(int)
(	O
&	O
idhashlock	int
)	O
;	O
}	O
static	O
struct	O
cache_handle	O
*	O
fhhashtable	array(*(struct))
[	O
FHHASH_TABLE_SIZE	int
]	O
;	O
pthread_mutex_t	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
fhhashlock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
static	O
int	O
nfreefh	int
;	O
static	O
int	O
leastfhlastuse	int
;	O
static	O
int	O
fh_hash	(*(char),*(struct))->(int)
(	O
char	O
*	O
fhandle	*(char)
,	O
struct	O
idspec	O
*	O
i	*(struct)
)	O
{	O
int	O
hash	int
=	O
0	int
,	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
NFS2_FHSIZE	O
;	O
n	int
++	O
)	O
hash	int
+=	O
fhandle	*(char)
[	O
n	int
]	O
;	O
hash	int
+=	O
(	O
intptr_t	O
)	O
i	*(struct)
>>	O
6	int
;	O
return	O
hash	int
%	O
FHHASH_TABLE_SIZE	int
;	O
}	O
int	O
*	O
lookup_cache_handle	(*(int),*(*(struct)),*(struct))->(*(int))
(	O
int	O
*	O
p	*(int)
,	O
struct	O
cache_handle	O
*	O
*	O
cp	*(*(struct))
,	O
struct	O
idspec	O
*	O
i	*(struct)
)	O
{	O
int	O
hash	int
;	O
struct	O
cache_handle	O
*	O
c	*(struct)
;	O
fsys_t	O
fsys	O
;	O
file_t	O
port	O
;	O
hash	int
=	O
fh_hash	(*(char),*(struct))->(int)
(	O
(	O
char	O
*	O
)	O
p	*(int)
,	O
i	*(struct)
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fhhashlock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
for	O
(	O
c	*(struct)
=	O
fhhashtable	array(*(struct))
[	O
hash	int
]	O
;	O
c	*(struct)
;	O
c	*(struct)
=	O
c	*(struct)
->	O
next	O
)	O
if	O
(	O
c	*(struct)
->	O
ids	O
==	O
i	*(struct)
&&	O
!	O
bcmp	(*(void),*(void),long)->(int)
(	O
c	*(struct)
->	O
handle	O
.	O
array	O
,	O
p	*(int)
,	O
NFS2_FHSIZE	O
)	O
)	O
{	O
if	O
(	O
c	*(struct)
->	O
references	O
==	O
0	int
)	O
nfreefh	int
--	O
;	O
c	*(struct)
->	O
references	O
++	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fhhashlock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
*	O
cp	*(*(struct))
=	O
c	*(struct)
;	O
return	O
p	*(int)
+	O
NFS2_FHSIZE	O
/	O
sizeof	O
(	O
int	O
)	O
;	O
}	O
fsys	O
=	O
lookup_filesystem	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
if	O
(	O
fsys	O
==	O
MACH_PORT_NULL	O
||	O
fsys_getfile	()->(int)
(	O
fsys	O
,	O
i	*(struct)
->	O
uids	*(int)
,	O
i	*(struct)
->	O
nuids	int
,	O
i	*(struct)
->	O
gids	*(int)
,	O
i	*(struct)
->	O
ngids	int
,	O
(	O
char	O
*	O
)	O
(	O
p	*(int)
+	O
1	int
)	O
,	O
NFS2_FHSIZE	O
-	O
sizeof	O
(	O
int	O
)	O
,	O
&	O
port	O
)	O
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fhhashlock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
*	O
cp	*(*(struct))
=	O
0	int
;	O
return	O
p	*(int)
+	O
NFS2_FHSIZE	O
/	O
sizeof	O
(	O
int	O
)	O
;	O
}	O
c	*(struct)
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
cache_handle	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
c	*(struct)
->	O
handle	O
.	O
array	O
,	O
p	*(int)
,	O
NFS2_FHSIZE	O
)	O
;	O
cred_ref	(*(struct))->(void)
(	O
i	*(struct)
)	O
;	O
c	*(struct)
->	O
ids	O
=	O
i	*(struct)
;	O
c	*(struct)
->	O
port	O
=	O
port	O
;	O
c	*(struct)
->	O
references	O
=	O
1	int
;	O
c	*(struct)
->	O
next	O
=	O
fhhashtable	array(*(struct))
[	O
hash	int
]	O
;	O
if	O
(	O
c	*(struct)
->	O
next	O
)	O
c	*(struct)
->	O
next	O
->	O
prevp	O
=	O
&	O
c	*(struct)
->	O
next	O
;	O
c	*(struct)
->	O
prevp	O
=	O
&	O
fhhashtable	array(*(struct))
[	O
hash	int
]	O
;	O
fhhashtable	array(*(struct))
[	O
hash	int
]	O
=	O
c	*(struct)
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fhhashlock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
*	O
cp	*(*(struct))
=	O
c	*(struct)
;	O
return	O
p	*(int)
+	O
NFS2_FHSIZE	O
/	O
sizeof	O
(	O
int	O
)	O
;	O
}	O
void	O
cache_handle_rele	(*(struct))->(void)
(	O
struct	O
cache_handle	O
*	O
c	*(struct)
)	O
{	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fhhashlock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
c	*(struct)
->	O
references	O
--	O
;	O
if	O
(	O
c	*(struct)
->	O
references	O
==	O
0	int
)	O
{	O
c	*(struct)
->	O
lastuse	O
=	O
mapped_time	O
->	O
seconds	O
;	O
if	O
(	O
c	*(struct)
->	O
lastuse	O
<	O
leastfhlastuse	int
||	O
nfreefh	int
==	O
0	int
)	O
leastfhlastuse	int
=	O
c	*(struct)
->	O
lastuse	O
;	O
nfreefh	int
++	O
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fhhashlock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
}	O
void	O
scan_fhs	()->(void)
(	O
)	O
{	O
int	O
n	int
;	O
int	O
newleast	int
=	O
mapped_time	O
->	O
seconds	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fhhashlock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
mapped_time	O
->	O
seconds	O
-	O
leastfhlastuse	int
>	O
FH_KEEP_TIMEOUT	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
FHHASH_TABLE_SIZE	int
&&	O
nfreefh	int
;	O
n	int
++	O
)	O
{	O
struct	O
cache_handle	O
*	O
c	*(struct)
=	O
fhhashtable	array(*(struct))
[	O
n	int
]	O
;	O
while	O
(	O
c	*(struct)
&&	O
nfreefh	int
)	O
{	O
struct	O
cache_handle	O
*	O
next_c	*(struct)
=	O
c	*(struct)
->	O
next	O
;	O
if	O
(	O
!	O
c	*(struct)
->	O
references	O
&&	O
mapped_time	O
->	O
seconds	O
-	O
c	*(struct)
->	O
lastuse	O
>	O
FH_KEEP_TIMEOUT	O
)	O
{	O
nfreefh	int
--	O
;	O
*	O
c	*(struct)
->	O
prevp	O
=	O
c	*(struct)
->	O
next	O
;	O
if	O
(	O
c	*(struct)
->	O
next	O
)	O
c	*(struct)
->	O
next	O
->	O
prevp	O
=	O
c	*(struct)
->	O
prevp	O
;	O
cred_rele	(*(struct))->(void)
(	O
c	*(struct)
->	O
ids	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
c	*(struct)
->	O
port	O
)	O
;	O
free	()->(int)
(	O
c	*(struct)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
c	*(struct)
->	O
references	O
&&	O
newleast	int
>	O
c	*(struct)
->	O
lastuse	O
)	O
newleast	int
=	O
c	*(struct)
->	O
lastuse	O
;	O
c	*(struct)
=	O
next_c	*(struct)
;	O
}	O
}	O
if	O
(	O
nfreefh	int
)	O
leastfhlastuse	int
=	O
newleast	int
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fhhashlock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
}	O
struct	O
cache_handle	O
*	O
create_cached_handle	(int,*(struct),int)->(*(struct))
(	O
int	O
fs	int
,	O
struct	O
cache_handle	O
*	O
credc	*(struct)
,	O
file_t	O
userport	int
)	O
{	O
union	O
cache_handle_array	O
fhandle	*(char)
;	O
error_t	O
err	O
;	O
struct	O
cache_handle	O
*	O
c	*(struct)
;	O
int	O
hash	int
;	O
char	O
*	O
bp	*(char)
=	O
fhandle	*(char)
.	O
array	O
+	O
sizeof	O
(	O
int	O
)	O
;	O
size_t	long
handlelen	long
=	O
NFS2_FHSIZE	O
-	O
sizeof	O
(	O
int	O
)	O
;	O
mach_port_t	O
newport	O
,	O
ref	O
;	O
ref	O
=	O
mach_reply_port	()->(int)
(	O
)	O
;	O
if	O
(	O
io_reauthenticate	()->(int)
(	O
userport	int
,	O
ref	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
||	O
auth_user_authenticate	()->(int)
(	O
authserver	O
,	O
ref	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
,	O
&	O
newport	O
)	O
)	O
{	O
newport	O
=	O
userport	int
;	O
}	O
else	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
userport	int
)	O
;	O
mach_port_destroy	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
ref	O
)	O
;	O
fhandle	*(char)
.	O
fs	int
=	O
fs	int
;	O
err	O
=	O
file_getfh	()->(int)
(	O
newport	O
,	O
&	O
bp	*(char)
,	O
&	O
handlelen	long
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
newport	O
)	O
;	O
if	O
(	O
err	O
||	O
handlelen	long
!=	O
NFS2_FHSIZE	O
-	O
sizeof	O
(	O
int	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
bp	*(char)
!=	O
fhandle	*(char)
.	O
array	O
+	O
sizeof	O
(	O
int	O
)	O
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
fhandle	*(char)
.	O
array	O
+	O
sizeof	O
(	O
int	O
)	O
,	O
bp	*(char)
,	O
NFS2_FHSIZE	O
-	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
munmap	(*(void),long)->(int)
(	O
bp	*(char)
,	O
handlelen	long
)	O
;	O
}	O
hash	int
=	O
fh_hash	(*(char),*(struct))->(int)
(	O
fhandle	*(char)
.	O
array	O
,	O
credc	*(struct)
->	O
ids	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fhhashlock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
for	O
(	O
c	*(struct)
=	O
fhhashtable	array(*(struct))
[	O
hash	int
]	O
;	O
c	*(struct)
;	O
c	*(struct)
=	O
c	*(struct)
->	O
next	O
)	O
if	O
(	O
c	*(struct)
->	O
ids	O
==	O
credc	*(struct)
->	O
ids	O
&&	O
!	O
bcmp	(*(void),*(void),long)->(int)
(	O
fhandle	*(char)
.	O
array	O
,	O
c	*(struct)
->	O
handle	O
.	O
array	O
,	O
NFS2_FHSIZE	O
)	O
)	O
{	O
if	O
(	O
c	*(struct)
->	O
references	O
==	O
0	int
)	O
nfreefh	int
--	O
;	O
c	*(struct)
->	O
references	O
++	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fhhashlock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
c	*(struct)
;	O
}	O
err	O
=	O
fsys_getfile	()->(int)
(	O
lookup_filesystem	()->(int)
(	O
fs	int
)	O
,	O
credc	*(struct)
->	O
ids	O
->	O
uids	*(int)
,	O
credc	*(struct)
->	O
ids	O
->	O
nuids	int
,	O
credc	*(struct)
->	O
ids	O
->	O
gids	*(int)
,	O
credc	*(struct)
->	O
ids	O
->	O
ngids	int
,	O
fhandle	*(char)
.	O
array	O
+	O
sizeof	O
(	O
int	O
)	O
,	O
NFS2_FHSIZE	O
-	O
sizeof	O
(	O
int	O
)	O
,	O
&	O
newport	O
)	O
;	O
if	O
(	O
err	O
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fhhashlock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
0	int
;	O
}	O
c	*(struct)
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
cache_handle	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
c	*(struct)
->	O
handle	O
.	O
array	O
,	O
fhandle	*(char)
.	O
array	O
,	O
NFS2_FHSIZE	O
)	O
;	O
cred_ref	(*(struct))->(void)
(	O
credc	*(struct)
->	O
ids	O
)	O
;	O
c	*(struct)
->	O
ids	O
=	O
credc	*(struct)
->	O
ids	O
;	O
c	*(struct)
->	O
port	O
=	O
newport	O
;	O
c	*(struct)
->	O
references	O
=	O
1	int
;	O
c	*(struct)
->	O
next	O
=	O
fhhashtable	array(*(struct))
[	O
hash	int
]	O
;	O
if	O
(	O
c	*(struct)
->	O
next	O
)	O
c	*(struct)
->	O
next	O
->	O
prevp	O
=	O
&	O
c	*(struct)
->	O
next	O
;	O
c	*(struct)
->	O
prevp	O
=	O
&	O
fhhashtable	array(*(struct))
[	O
hash	int
]	O
;	O
fhhashtable	array(*(struct))
[	O
hash	int
]	O
=	O
c	*(struct)
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
fhhashlock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
c	*(struct)
;	O
}	O
static	O
struct	O
cached_reply	O
*	O
replyhashtable	array(*(struct))
[	O
REPLYHASH_TABLE_SIZE	int
]	O
;	O
static	O
pthread_spinlock_t	int
replycachelock	int
=	O
PTHREAD_SPINLOCK_INITIALIZER	O
;	O
static	O
int	O
nfreereplies	int
;	O
static	O
int	O
leastreplylastuse	int
;	O
struct	O
cached_reply	O
*	O
check_cached_replies	(int,*(struct))->(*(struct))
(	O
int	O
xid	int
,	O
struct	O
sockaddr_in	O
*	O
sender	*(struct)
)	O
{	O
struct	O
cached_reply	O
*	O
cr	*(struct)
;	O
int	O
hash	int
;	O
hash	int
=	O
abs	O
(	O
xid	int
%	O
REPLYHASH_TABLE_SIZE	int
)	O
;	O
pthread_spin_lock	(*(int))->(int)
(	O
&	O
replycachelock	int
)	O
;	O
for	O
(	O
cr	*(struct)
=	O
replyhashtable	array(*(struct))
[	O
hash	int
]	O
;	O
cr	*(struct)
;	O
cr	*(struct)
=	O
cr	*(struct)
->	O
next	O
)	O
if	O
(	O
cr	*(struct)
->	O
xid	int
==	O
xid	int
&&	O
!	O
bcmp	(*(void),*(void),long)->(int)
(	O
sender	*(struct)
,	O
&	O
cr	*(struct)
->	O
source	O
,	O
sizeof	O
(	O
struct	O
sockaddr_in	O
)	O
)	O
)	O
{	O
cr	*(struct)
->	O
references	O
++	O
;	O
if	O
(	O
cr	*(struct)
->	O
references	O
==	O
1	int
)	O
nfreereplies	int
--	O
;	O
pthread_spin_unlock	(*(int))->(int)
(	O
&	O
replycachelock	int
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
cr	*(struct)
->	O
lock	O
)	O
;	O
return	O
cr	*(struct)
;	O
}	O
cr	*(struct)
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
cached_reply	O
)	O
)	O
;	O
pthread_mutex_init	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)),*(union(array(char),int)))->(int)
(	O
&	O
cr	*(struct)
->	O
lock	O
,	O
NULL	O
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
cr	*(struct)
->	O
lock	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
cr	*(struct)
->	O
source	O
,	O
sender	*(struct)
,	O
sizeof	O
(	O
struct	O
sockaddr_in	O
)	O
)	O
;	O
cr	*(struct)
->	O
xid	int
=	O
xid	int
;	O
cr	*(struct)
->	O
data	O
=	O
0	int
;	O
cr	*(struct)
->	O
references	O
=	O
1	int
;	O
cr	*(struct)
->	O
next	O
=	O
replyhashtable	array(*(struct))
[	O
hash	int
]	O
;	O
if	O
(	O
replyhashtable	array(*(struct))
[	O
hash	int
]	O
)	O
replyhashtable	array(*(struct))
[	O
hash	int
]	O
->	O
prevp	O
=	O
&	O
cr	*(struct)
->	O
next	O
;	O
cr	*(struct)
->	O
prevp	O
=	O
&	O
replyhashtable	array(*(struct))
[	O
hash	int
]	O
;	O
replyhashtable	array(*(struct))
[	O
hash	int
]	O
=	O
cr	*(struct)
;	O
pthread_spin_unlock	(*(int))->(int)
(	O
&	O
replycachelock	int
)	O
;	O
return	O
cr	*(struct)
;	O
}	O
void	O
release_cached_reply	(*(struct))->(void)
(	O
struct	O
cached_reply	O
*	O
cr	*(struct)
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
cr	*(struct)
->	O
lock	O
)	O
;	O
pthread_spin_lock	(*(int))->(int)
(	O
&	O
replycachelock	int
)	O
;	O
cr	*(struct)
->	O
references	O
--	O
;	O
if	O
(	O
cr	*(struct)
->	O
references	O
==	O
0	int
)	O
{	O
cr	*(struct)
->	O
lastuse	O
=	O
mapped_time	O
->	O
seconds	O
;	O
if	O
(	O
cr	*(struct)
->	O
lastuse	O
<	O
leastreplylastuse	int
||	O
nfreereplies	int
==	O
0	int
)	O
leastreplylastuse	int
=	O
cr	*(struct)
->	O
lastuse	O
;	O
nfreereplies	int
++	O
;	O
}	O
pthread_spin_unlock	(*(int))->(int)
(	O
&	O
replycachelock	int
)	O
;	O
}	O
void	O
scan_replies	()->(void)
(	O
)	O
{	O
int	O
n	int
;	O
int	O
newleast	int
=	O
mapped_time	O
->	O
seconds	O
;	O
pthread_spin_lock	(*(int))->(int)
(	O
&	O
replycachelock	int
)	O
;	O
if	O
(	O
mapped_time	O
->	O
seconds	O
-	O
leastreplylastuse	int
>	O
REPLY_KEEP_TIMEOUT	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
REPLYHASH_TABLE_SIZE	int
&&	O
nfreereplies	int
;	O
n	int
++	O
)	O
{	O
struct	O
cached_reply	O
*	O
cr	*(struct)
=	O
replyhashtable	array(*(struct))
[	O
n	int
]	O
;	O
while	O
(	O
cr	*(struct)
&&	O
nfreereplies	int
)	O
{	O
struct	O
cached_reply	O
*	O
next_cr	*(struct)
=	O
cr	*(struct)
->	O
next	O
;	O
if	O
(	O
!	O
cr	*(struct)
->	O
references	O
&&	O
mapped_time	O
->	O
seconds	O
-	O
cr	*(struct)
->	O
lastuse	O
>	O
REPLY_KEEP_TIMEOUT	O
)	O
{	O
nfreereplies	int
--	O
;	O
*	O
cr	*(struct)
->	O
prevp	O
=	O
cr	*(struct)
->	O
next	O
;	O
if	O
(	O
cr	*(struct)
->	O
next	O
)	O
cr	*(struct)
->	O
next	O
->	O
prevp	O
=	O
cr	*(struct)
->	O
prevp	O
;	O
if	O
(	O
cr	*(struct)
->	O
data	O
)	O
free	()->(int)
(	O
cr	*(struct)
->	O
data	O
)	O
;	O
free	()->(int)
(	O
cr	*(struct)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
cr	*(struct)
->	O
references	O
&&	O
newleast	int
>	O
cr	*(struct)
->	O
lastuse	O
)	O
newleast	int
=	O
cr	*(struct)
->	O
lastuse	O
;	O
cr	*(struct)
=	O
next_cr	*(struct)
;	O
}	O
}	O
if	O
(	O
nfreereplies	int
)	O
leastreplylastuse	int
=	O
newleast	int
;	O
}	O
pthread_spin_unlock	(*(int))->(int)
(	O
&	O
replycachelock	int
)	O
;	O
}	O
