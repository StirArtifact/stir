static	O
error_t	O
get_boottime	(*(struct),*(struct))->(int)
(	O
struct	O
ps_context	O
*	O
pc	*(struct)
,	O
struct	O
timeval	O
*	O
tv	*(struct)
)	O
{	O
struct	O
proc_stat	O
*	O
ps	*(struct)
;	O
error_t	O
err	O
;	O
err	O
=	O
_proc_stat_create	()->(int)
(	O
opt_kernel_pid	O
,	O
pc	*(struct)
,	O
&	O
ps	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
err	O
=	O
proc_stat_set_flags	()->(int)
(	O
ps	*(struct)
,	O
PSTAT_TASK_BASIC	O
)	O
;	O
if	O
(	O
err	O
||	O
!	O
(	O
proc_stat_flags	()->(int)
(	O
ps	*(struct)
)	O
&	O
PSTAT_TASK_BASIC	O
)	O
)	O
err	O
=	O
EIO	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
task_basic_info_t	O
tbi	O
=	O
proc_stat_task_basic_info	O
(	O
ps	*(struct)
)	O
;	O
tv	*(struct)
->	O
tv_sec	O
=	O
tbi	O
->	O
creation_time	O
.	O
seconds	O
;	O
tv	*(struct)
->	O
tv_usec	O
=	O
tbi	O
->	O
creation_time	O
.	O
microseconds	O
;	O
}	O
_proc_stat_free	()->(int)
(	O
ps	*(struct)
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
get_idletime	(*(struct),*(struct))->(int)
(	O
struct	O
ps_context	O
*	O
pc	*(struct)
,	O
struct	O
timeval	O
*	O
tv	*(struct)
)	O
{	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
*	O
pst	*(struct)
;	O
thread_basic_info_t	O
tbi	O
;	O
error_t	O
err	O
;	O
int	O
i	int
;	O
err	O
=	O
_proc_stat_create	()->(int)
(	O
opt_kernel_pid	O
,	O
pc	*(struct)
,	O
&	O
ps	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
pst	*(struct)
=	O
NULL	O
,	O
tbi	O
=	O
NULL	O
;	O
err	O
=	O
proc_stat_set_flags	()->(int)
(	O
ps	*(struct)
,	O
PSTAT_NUM_THREADS	O
)	O
;	O
if	O
(	O
err	O
||	O
!	O
(	O
proc_stat_flags	()->(int)
(	O
ps	*(struct)
)	O
&	O
PSTAT_NUM_THREADS	O
)	O
)	O
{	O
err	O
=	O
EIO	O
;	O
goto	O
out	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
!	O
tbi	O
||	O
!	O
(	O
tbi	O
->	O
flags	O
&	O
TH_FLAGS_IDLE	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
pst	*(struct)
)	O
_proc_stat_free	()->(int)
(	O
pst	*(struct)
)	O
;	O
pst	*(struct)
=	O
NULL	O
,	O
tbi	O
=	O
NULL	O
;	O
if	O
(	O
i	int
>=	O
proc_stat_num_threads	()->(int)
(	O
ps	*(struct)
)	O
)	O
{	O
err	O
=	O
ESRCH	O
;	O
goto	O
out	O
;	O
}	O
err	O
=	O
proc_stat_thread_create	()->(int)
(	O
ps	*(struct)
,	O
i	int
,	O
&	O
pst	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
continue	O
;	O
err	O
=	O
proc_stat_set_flags	()->(int)
(	O
pst	*(struct)
,	O
PSTAT_THREAD_BASIC	O
)	O
;	O
if	O
(	O
err	O
||	O
!	O
(	O
proc_stat_flags	()->(int)
(	O
pst	*(struct)
)	O
&	O
PSTAT_THREAD_BASIC	O
)	O
)	O
continue	O
;	O
tbi	O
=	O
proc_stat_thread_basic_info	()->(int)
(	O
pst	*(struct)
)	O
;	O
}	O
tv	*(struct)
->	O
tv_sec	O
=	O
tbi	O
->	O
system_time	O
.	O
seconds	O
;	O
tv	*(struct)
->	O
tv_usec	O
=	O
tbi	O
->	O
system_time	O
.	O
microseconds	O
;	O
err	O
=	O
0	int
;	O
out	O
:	O
if	O
(	O
pst	*(struct)
)	O
_proc_stat_free	()->(int)
(	O
pst	*(struct)
)	O
;	O
_proc_stat_free	()->(int)
(	O
ps	*(struct)
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
get_swapinfo	(*(int))->(int)
(	O
default_pager_info_t	O
*	O
info	*(int)
)	O
{	O
mach_port_t	O
defpager	O
;	O
error_t	O
err	O
;	O
defpager	O
=	O
file_name_lookup	()->(int)
(	O
_SERVERS_DEFPAGER	O
,	O
O_READ	O
,	O
0	int
)	O
;	O
if	O
(	O
defpager	O
==	O
MACH_PORT_NULL	O
)	O
return	O
errno	O
;	O
err	O
=	O
default_pager_info	()->(int)
(	O
defpager	O
,	O
info	*(int)
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
defpager	O
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
rootdir_gc_version	(*(void),*(*(char)),*(int))->(int)
(	O
void	O
*	O
hook	*(void)
,	O
char	O
*	O
*	O
contents	*(*(char))
,	O
ssize_t	O
*	O
contents_len	*(int)
)	O
{	O
struct	O
utsname	O
uts	struct
;	O
int	O
r	int
;	O
r	int
=	O
uname	()->(int)
(	O
&	O
uts	struct
)	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
return	O
errno	O
;	O
*	O
contents_len	*(int)
=	O
asprintf	()->(int)
(	O
contents	*(*(char))
,	O
"Linux version 2.6.1 (%s %s %s %s)\n"	*(char)
,	O
uts	struct
.	O
sysname	O
,	O
uts	struct
.	O
release	O
,	O
uts	struct
.	O
version	O
,	O
uts	struct
.	O
machine	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
rootdir_gc_uptime	(*(void),*(*(char)),*(int))->(int)
(	O
void	O
*	O
hook	*(void)
,	O
char	O
*	O
*	O
contents	*(*(char))
,	O
ssize_t	O
*	O
contents_len	*(int)
)	O
{	O
struct	O
timeval	O
time	struct
,	O
boottime	struct
,	O
idletime	struct
;	O
double	O
up_secs	double
,	O
idle_secs	double
;	O
error_t	O
err	O
;	O
err	O
=	O
gettimeofday	()->(int)
(	O
&	O
time	struct
,	O
NULL	O
)	O
;	O
if	O
(	O
err	O
<	O
0	int
)	O
return	O
errno	O
;	O
err	O
=	O
get_boottime	(*(struct),*(struct))->(int)
(	O
hook	*(void)
,	O
&	O
boottime	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
err	O
=	O
get_idletime	(*(struct),*(struct))->(int)
(	O
hook	*(void)
,	O
&	O
idletime	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
timersub	()->(int)
(	O
&	O
time	struct
,	O
&	O
boottime	struct
,	O
&	O
time	struct
)	O
;	O
up_secs	double
=	O
(	O
time	struct
.	O
tv_sec	O
*	O
1000000.	int
+	O
time	struct
.	O
tv_usec	O
)	O
/	O
1000000.	int
;	O
idle_secs	double
=	O
(	O
idletime	struct
.	O
tv_sec	O
*	O
1000000.	int
+	O
idletime	struct
.	O
tv_usec	O
)	O
/	O
1000000.	int
;	O
*	O
contents_len	*(int)
=	O
asprintf	()->(int)
(	O
contents	*(*(char))
,	O
"%.2lf %.2lf\n"	*(char)
,	O
up_secs	double
,	O
idle_secs	double
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
rootdir_gc_stat	(*(void),*(*(char)),*(int))->(int)
(	O
void	O
*	O
hook	*(void)
,	O
char	O
*	O
*	O
contents	*(*(char))
,	O
ssize_t	O
*	O
contents_len	*(int)
)	O
{	O
struct	O
timeval	O
boottime	struct
,	O
time	struct
,	O
idletime	struct
;	O
struct	O
vm_statistics	()->(int)
vmstats	struct
;	O
unsigned	O
long	O
up_ticks	long
,	O
idle_ticks	long
;	O
error_t	O
err	O
;	O
err	O
=	O
gettimeofday	()->(int)
(	O
&	O
time	struct
,	O
NULL	O
)	O
;	O
if	O
(	O
err	O
<	O
0	int
)	O
return	O
errno	O
;	O
err	O
=	O
get_boottime	(*(struct),*(struct))->(int)
(	O
hook	*(void)
,	O
&	O
boottime	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
err	O
=	O
get_idletime	(*(struct),*(struct))->(int)
(	O
hook	*(void)
,	O
&	O
idletime	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
err	O
=	O
vm_statistics	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
&	O
vmstats	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
EIO	O
;	O
timersub	()->(int)
(	O
&	O
time	struct
,	O
&	O
boottime	struct
,	O
&	O
time	struct
)	O
;	O
up_ticks	long
=	O
opt_clk_tck	O
*	O
(	O
time	struct
.	O
tv_sec	O
*	O
1000000.	int
+	O
time	struct
.	O
tv_usec	O
)	O
/	O
1000000.	int
;	O
idle_ticks	long
=	O
opt_clk_tck	O
*	O
(	O
idletime	struct
.	O
tv_sec	O
*	O
1000000.	int
+	O
idletime	struct
.	O
tv_usec	O
)	O
/	O
1000000.	int
;	O
*	O
contents_len	*(int)
=	O
asprintf	()->(int)
(	O
contents	*(*(char))
,	O
"cpu  %lu 0 0 %lu 0 0 0 0 0\n"	*(char)
"cpu0 %lu 0 0 %lu 0 0 0 0 0\n"	*(char)
"intr 0\n"	*(char)
"page %d %d\n"	*(char)
"btime %lu\n"	*(char)
,	O
up_ticks	long
-	O
idle_ticks	long
,	O
idle_ticks	long
,	O
up_ticks	long
-	O
idle_ticks	long
,	O
idle_ticks	long
,	O
vmstats	struct
.	O
pageins	O
,	O
vmstats	struct
.	O
pageouts	O
,	O
boottime	struct
.	O
tv_sec	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
rootdir_gc_loadavg	(*(void),*(*(char)),*(int))->(int)
(	O
void	O
*	O
hook	*(void)
,	O
char	O
*	O
*	O
contents	*(*(char))
,	O
ssize_t	O
*	O
contents_len	*(int)
)	O
{	O
host_load_info_data_t	O
hli	O
;	O
mach_msg_type_number_t	O
cnt	O
;	O
error_t	O
err	O
;	O
cnt	O
=	O
HOST_LOAD_INFO_COUNT	O
;	O
err	O
=	O
host_info	()->(int)
(	O
mach_host_self	()->(int)
(	O
)	O
,	O
HOST_LOAD_INFO	O
,	O
(	O
host_info_t	O
)	O
&	O
hli	O
,	O
&	O
cnt	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
assert	()->(int)
(	O
cnt	O
==	O
HOST_LOAD_INFO_COUNT	O
)	O
;	O
*	O
contents_len	*(int)
=	O
asprintf	()->(int)
(	O
contents	*(*(char))
,	O
"%.2f %.2f %.2f 1/0 0\n"	*(char)
,	O
hli	O
.	O
avenrun	O
[	O
0	int
]	O
/	O
(	O
double	O
)	O
LOAD_SCALE	O
,	O
hli	O
.	O
avenrun	O
[	O
1	int
]	O
/	O
(	O
double	O
)	O
LOAD_SCALE	O
,	O
hli	O
.	O
avenrun	O
[	O
2	int
]	O
/	O
(	O
double	O
)	O
LOAD_SCALE	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
rootdir_gc_meminfo	(*(void),*(*(char)),*(int))->(int)
(	O
void	O
*	O
hook	*(void)
,	O
char	O
*	O
*	O
contents	*(*(char))
,	O
ssize_t	O
*	O
contents_len	*(int)
)	O
{	O
host_basic_info_data_t	O
hbi	O
;	O
mach_msg_type_number_t	O
cnt	O
;	O
struct	O
vm_statistics	()->(int)
vmstats	struct
;	O
struct	O
vm_cache_statistics	()->(int)
cache_stats	struct
;	O
default_pager_info_t	O
swap	O
;	O
FILE	O
*	O
m	O
;	O
error_t	O
err	O
;	O
m	O
=	O
open_memstream	()->(int)
(	O
contents	*(*(char))
,	O
(	O
size_t	O
*	O
)	O
contents_len	*(int)
)	O
;	O
if	O
(	O
m	O
==	O
NULL	O
)	O
{	O
err	O
=	O
ENOMEM	O
;	O
goto	O
out	O
;	O
}	O
err	O
=	O
vm_statistics	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
&	O
vmstats	struct
)	O
;	O
if	O
(	O
err	O
)	O
{	O
err	O
=	O
EIO	O
;	O
goto	O
out	O
;	O
}	O
err	O
=	O
vm_cache_statistics	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
&	O
cache_stats	struct
)	O
;	O
if	O
(	O
err	O
)	O
{	O
err	O
=	O
EIO	O
;	O
goto	O
out	O
;	O
}	O
cnt	O
=	O
HOST_BASIC_INFO_COUNT	O
;	O
err	O
=	O
host_info	()->(int)
(	O
mach_host_self	()->(int)
(	O
)	O
,	O
HOST_BASIC_INFO	O
,	O
(	O
host_info_t	O
)	O
&	O
hbi	O
,	O
&	O
cnt	O
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
out	O
;	O
assert	()->(int)
(	O
cnt	O
==	O
HOST_BASIC_INFO_COUNT	O
)	O
;	O
fprintf	()->(int)
(	O
m	O
,	O
"MemTotal: %14lu kB\n"	*(char)
"MemFree:  %14lu kB\n"	*(char)
"Buffers:  %14lu kB\n"	*(char)
"Cached:   %14lu kB\n"	*(char)
"Active:   %14lu kB\n"	*(char)
"Inactive: %14lu kB\n"	*(char)
"Mlocked:  %14lu kB\n"	*(char)
,	O
(	O
long	O
unsigned	O
)	O
hbi	O
.	O
memory_size	O
/	O
1024	int
,	O
(	O
long	O
unsigned	O
)	O
vmstats	struct
.	O
free_count	O
*	O
PAGE_SIZE	O
/	O
1024	int
,	O
0UL	int
,	O
(	O
long	O
unsigned	O
)	O
cache_stats	struct
.	O
cache_count	O
*	O
PAGE_SIZE	O
/	O
1024	int
,	O
(	O
long	O
unsigned	O
)	O
vmstats	struct
.	O
active_count	O
*	O
PAGE_SIZE	O
/	O
1024	int
,	O
(	O
long	O
unsigned	O
)	O
vmstats	struct
.	O
inactive_count	O
*	O
PAGE_SIZE	O
/	O
1024	int
,	O
(	O
long	O
unsigned	O
)	O
vmstats	struct
.	O
wire_count	O
*	O
PAGE_SIZE	O
/	O
1024	int
)	O
;	O
err	O
=	O
get_swapinfo	(*(int))->(int)
(	O
&	O
swap	O
)	O
;	O
if	O
(	O
err	O
)	O
err	O
=	O
0	int
;	O
else	O
fprintf	()->(int)
(	O
m	O
,	O
"SwapTotal:%14lu kB\n"	*(char)
"SwapFree: %14lu kB\n"	*(char)
,	O
(	O
long	O
unsigned	O
)	O
swap	O
.	O
dpi_total_space	O
/	O
1024	int
,	O
(	O
long	O
unsigned	O
)	O
swap	O
.	O
dpi_free_space	O
/	O
1024	int
)	O
;	O
out	O
:	O
fclose	()->(int)
(	O
m	O
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
rootdir_gc_vmstat	(*(void),*(*(char)),*(int))->(int)
(	O
void	O
*	O
hook	*(void)
,	O
char	O
*	O
*	O
contents	*(*(char))
,	O
ssize_t	O
*	O
contents_len	*(int)
)	O
{	O
host_basic_info_data_t	O
hbi	O
;	O
mach_msg_type_number_t	O
cnt	O
;	O
struct	O
vm_statistics	()->(int)
vmstats	struct
;	O
error_t	O
err	O
;	O
err	O
=	O
vm_statistics	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
&	O
vmstats	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
EIO	O
;	O
cnt	O
=	O
HOST_BASIC_INFO_COUNT	O
;	O
err	O
=	O
host_info	()->(int)
(	O
mach_host_self	()->(int)
(	O
)	O
,	O
HOST_BASIC_INFO	O
,	O
(	O
host_info_t	O
)	O
&	O
hbi	O
,	O
&	O
cnt	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
assert	()->(int)
(	O
cnt	O
==	O
HOST_BASIC_INFO_COUNT	O
)	O
;	O
*	O
contents_len	*(int)
=	O
asprintf	()->(int)
(	O
contents	*(*(char))
,	O
"nr_free_pages %lu\n"	*(char)
"nr_inactive_anon %lu\n"	*(char)
"nr_active_anon %lu\n"	*(char)
"nr_inactive_file %lu\n"	*(char)
"nr_active_file %lu\n"	*(char)
"nr_unevictable %lu\n"	*(char)
"nr_mlock %lu\n"	*(char)
"pgpgin %lu\n"	*(char)
"pgpgout %lu\n"	*(char)
"pgfault %lu\n"	*(char)
,	O
(	O
long	O
unsigned	O
)	O
vmstats	struct
.	O
free_count	O
,	O
(	O
long	O
unsigned	O
)	O
vmstats	struct
.	O
inactive_count	O
,	O
(	O
long	O
unsigned	O
)	O
vmstats	struct
.	O
active_count	O
,	O
(	O
long	O
unsigned	O
)	O
0	int
,	O
(	O
long	O
unsigned	O
)	O
0	int
,	O
(	O
long	O
unsigned	O
)	O
vmstats	struct
.	O
wire_count	O
,	O
(	O
long	O
unsigned	O
)	O
vmstats	struct
.	O
wire_count	O
,	O
(	O
long	O
unsigned	O
)	O
vmstats	struct
.	O
pageins	O
,	O
(	O
long	O
unsigned	O
)	O
vmstats	struct
.	O
pageouts	O
,	O
(	O
long	O
unsigned	O
)	O
vmstats	struct
.	O
faults	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
rootdir_gc_cmdline	(*(void),*(*(char)),*(int))->(int)
(	O
void	O
*	O
hook	*(void)
,	O
char	O
*	O
*	O
contents	*(*(char))
,	O
ssize_t	O
*	O
contents_len	*(int)
)	O
{	O
struct	O
ps_context	O
*	O
pc	*(struct)
=	O
hook	*(void)
;	O
struct	O
proc_stat	O
*	O
ps	*(struct)
;	O
error_t	O
err	O
;	O
err	O
=	O
_proc_stat_create	()->(int)
(	O
opt_kernel_pid	O
,	O
pc	*(struct)
,	O
&	O
ps	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
return	O
EIO	O
;	O
err	O
=	O
proc_stat_set_flags	()->(int)
(	O
ps	*(struct)
,	O
PSTAT_ARGS	O
)	O
;	O
if	O
(	O
err	O
||	O
!	O
(	O
proc_stat_flags	()->(int)
(	O
ps	*(struct)
)	O
&	O
PSTAT_ARGS	O
)	O
)	O
{	O
err	O
=	O
EIO	O
;	O
goto	O
out	O
;	O
}	O
*	O
contents_len	*(int)
=	O
proc_stat_args_len	()->(int)
(	O
ps	*(struct)
)	O
;	O
*	O
contents	*(*(char))
=	O
malloc	O
(	O
*	O
contents_len	*(int)
)	O
;	O
if	O
(	O
!	O
*	O
contents	*(*(char))
)	O
{	O
err	O
=	O
ENOMEM	O
;	O
goto	O
out	O
;	O
}	O
memcpy	O
(	O
*	O
contents	*(*(char))
,	O
proc_stat_args	()->(int)
(	O
ps	*(struct)
)	O
,	O
*	O
contents_len	*(int)
)	O
;	O
argz_stringify	()->(int)
(	O
*	O
contents	*(*(char))
,	O
*	O
contents_len	*(int)
,	O
' '	O
)	O
;	O
(	O
*	O
contents	*(*(char))
)	O
[	O
*	O
contents_len	*(int)
-	O
1	int
]	O
=	O
'\n'	O
;	O
out	O
:	O
_proc_stat_free	()->(int)
(	O
ps	*(struct)
)	O
;	O
return	O
err	O
;	O
}	O
static	O
int	O
rootdir_fakeself_exists	(*(void),*(void))->(int)
(	O
void	O
*	O
dir_hook	*(void)
,	O
const	O
void	O
*	O
entry_hook	*(void)
)	O
{	O
return	O
opt_fake_self	O
>=	O
0	int
;	O
}	O
static	O
error_t	O
rootdir_gc_fakeself	(*(void),*(*(char)),*(int))->(int)
(	O
void	O
*	O
hook	*(void)
,	O
char	O
*	O
*	O
contents	*(*(char))
,	O
ssize_t	O
*	O
contents_len	*(int)
)	O
{	O
*	O
contents_len	*(int)
=	O
asprintf	()->(int)
(	O
contents	*(*(char))
,	O
"%d"	*(char)
,	O
opt_fake_self	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
node	O
*	O
rootdir_mounts_node	*(struct)
;	O
static	O
error_t	O
rootdir_gc_slabinfo	(*(void),*(*(char)),*(int))->(int)
(	O
void	O
*	O
hook	*(void)
,	O
char	O
*	O
*	O
contents	*(*(char))
,	O
ssize_t	O
*	O
contents_len	*(int)
)	O
{	O
error_t	O
err	O
;	O
FILE	O
*	O
m	O
;	O
const	O
char	O
header	array(char)
[	O
]	O
=	O
"cache                          obj slab  bufs   objs   bufs"	*(char)
"    total reclaimable\n"	*(char)
"name                  flags   size size /slab  usage  count"	*(char)
"   memory      memory\n"	*(char)
;	O
cache_info_array_t	O
cache_info	O
;	O
size_t	O
mem_usage	O
,	O
mem_reclaimable	O
,	O
mem_total	O
,	O
mem_total_reclaimable	O
;	O
mach_msg_type_number_t	O
cache_info_count	O
;	O
int	O
i	int
;	O
cache_info	O
=	O
NULL	O
;	O
cache_info_count	O
=	O
0	int
;	O
err	O
=	O
host_slab_info	()->(int)
(	O
mach_host_self	()->(int)
(	O
)	O
,	O
&	O
cache_info	O
,	O
&	O
cache_info_count	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
m	O
=	O
open_memstream	()->(int)
(	O
contents	*(*(char))
,	O
(	O
size_t	O
*	O
)	O
contents_len	*(int)
)	O
;	O
if	O
(	O
m	O
==	O
NULL	O
)	O
{	O
err	O
=	O
ENOMEM	O
;	O
goto	O
out	O
;	O
}	O
fprintf	()->(int)
(	O
m	O
,	O
"%s"	*(char)
,	O
header	array(char)
)	O
;	O
mem_total	O
=	O
0	int
;	O
mem_total_reclaimable	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
cache_info_count	O
;	O
i	int
++	O
)	O
{	O
mem_usage	O
=	O
(	O
cache_info	O
[	O
i	int
]	O
.	O
nr_slabs	O
*	O
cache_info	O
[	O
i	int
]	O
.	O
slab_size	O
)	O
>>	O
10	int
;	O
mem_total	O
+=	O
mem_usage	O
;	O
mem_reclaimable	O
=	O
(	O
cache_info	O
[	O
i	int
]	O
.	O
nr_free_slabs	O
*	O
cache_info	O
[	O
i	int
]	O
.	O
slab_size	O
)	O
>>	O
10	int
;	O
mem_total_reclaimable	O
+=	O
mem_reclaimable	O
;	O
fprintf	()->(int)
(	O
m	O
,	O
"%-21s %04x %7zu %3zuk  %4lu %6lu %6lu %7zuk %10zuk\n"	*(char)
,	O
cache_info	O
[	O
i	int
]	O
.	O
name	*(char)
,	O
cache_info	O
[	O
i	int
]	O
.	O
flags	O
,	O
cache_info	O
[	O
i	int
]	O
.	O
obj_size	O
,	O
cache_info	O
[	O
i	int
]	O
.	O
slab_size	O
>>	O
10	int
,	O
cache_info	O
[	O
i	int
]	O
.	O
bufs_per_slab	O
,	O
cache_info	O
[	O
i	int
]	O
.	O
nr_objs	O
,	O
cache_info	O
[	O
i	int
]	O
.	O
nr_bufs	O
,	O
mem_usage	O
,	O
mem_reclaimable	O
)	O
;	O
}	O
fprintf	()->(int)
(	O
m	O
,	O
"total: %zuk, reclaimable: %zuk\n"	*(char)
,	O
mem_total	O
,	O
mem_total_reclaimable	O
)	O
;	O
fclose	()->(int)
(	O
m	O
)	O
;	O
out	O
:	O
vm_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
(	O
vm_address_t	O
)	O
cache_info	O
,	O
cache_info_count	O
*	O
sizeof	O
*	O
cache_info	O
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
rootdir_gc_filesystems	(*(void),*(*(char)),*(int))->(int)
(	O
void	O
*	O
hook	*(void)
,	O
char	O
*	O
*	O
contents	*(*(char))
,	O
ssize_t	O
*	O
contents_len	*(int)
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
size_t	O
i	int
;	O
int	O
glob_ret	int
;	O
glob_t	O
matches	O
;	O
FILE	O
*	O
m	O
;	O
m	O
=	O
open_memstream	()->(int)
(	O
contents	*(*(char))
,	O
(	O
size_t	O
*	O
)	O
contents_len	*(int)
)	O
;	O
if	O
(	O
m	O
==	O
NULL	O
)	O
return	O
errno	O
;	O
glob_ret	int
=	O
glob	()->(int)
(	O
_HURD	O
"*fs"	*(char)
,	O
0	int
,	O
NULL	O
,	O
&	O
matches	O
)	O
;	O
switch	O
(	O
glob_ret	int
)	O
{	O
case	O
0	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
matches	O
.	O
gl_pathc	O
;	O
i	int
++	O
)	O
{	O
char	O
*	O
name	*(char)
=	O
&	O
matches	O
.	O
gl_pathv	O
[	O
i	int
]	O
[	O
sizeof	O
_HURD	O
-	O
1	int
]	O
;	O
if	O
(	O
strncmp	O
(	O
name	*(char)
,	O
"ext"	*(char)
,	O
3	int
)	O
==	O
0	int
||	O
strcmp	O
(	O
name	*(char)
,	O
"procfs"	*(char)
)	O
==	O
0	int
)	O
name	*(char)
[	O
strlen	O
(	O
name	*(char)
)	O
-	O
2	int
]	O
=	O
0	int
;	O
fprintf	()->(int)
(	O
m	O
,	O
"\t%s\n"	*(char)
,	O
name	*(char)
)	O
;	O
}	O
globfree	()->(int)
(	O
&	O
matches	O
)	O
;	O
break	O
;	O
case	O
GLOB_NOMATCH	O
:	O
break	O
;	O
case	O
GLOB_NOSPACE	O
:	O
err	O
=	O
ENOMEM	O
;	O
break	O
;	O
default	O
:	O
err	O
=	O
EGRATUITOUS	O
;	O
}	O
fclose	()->(int)
(	O
m	O
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
rootdir_gc_swaps	(*(void),*(*(char)),*(int))->(int)
(	O
void	O
*	O
hook	*(void)
,	O
char	O
*	O
*	O
contents	*(*(char))
,	O
ssize_t	O
*	O
contents_len	*(int)
)	O
{	O
mach_port_t	O
defpager	O
;	O
error_t	O
err	O
=	O
0	int
;	O
FILE	O
*	O
m	O
;	O
vm_size_t	O
*	O
free	O
=	O
NULL	O
;	O
size_t	O
nfree	O
=	O
0	int
;	O
vm_size_t	O
*	O
size	O
=	O
NULL	O
;	O
size_t	O
nsize	O
=	O
0	int
;	O
char	O
*	O
names	*(char)
=	O
NULL	O
,	O
*	O
name	*(char)
;	O
size_t	O
names_len	O
=	O
0	int
;	O
size_t	O
i	int
;	O
m	O
=	O
open_memstream	()->(int)
(	O
contents	*(*(char))
,	O
(	O
size_t	O
*	O
)	O
contents_len	*(int)
)	O
;	O
if	O
(	O
m	O
==	O
NULL	O
)	O
return	O
errno	O
;	O
defpager	O
=	O
file_name_lookup	()->(int)
(	O
_SERVERS_DEFPAGER	O
,	O
O_READ	O
,	O
0	int
)	O
;	O
if	O
(	O
defpager	O
==	O
MACH_PORT_NULL	O
)	O
{	O
err	O
=	O
errno	O
;	O
goto	O
out_fclose	O
;	O
}	O
err	O
=	O
default_pager_storage_info	()->(int)
(	O
defpager	O
,	O
&	O
size	O
,	O
&	O
nsize	O
,	O
&	O
free	O
,	O
&	O
nfree	O
,	O
&	O
names	*(char)
,	O
&	O
names_len	O
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
out	O
;	O
fprintf	()->(int)
(	O
m	O
,	O
"Filename\tType\t\tSize\tUsed\tPriority\n"	*(char)
)	O
;	O
name	*(char)
=	O
names	*(char)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nfree	O
;	O
i	int
++	O
)	O
{	O
fprintf	()->(int)
(	O
m	O
,	O
"%s\tpartition\t%zu\t%zu\t-1\n"	*(char)
,	O
name	*(char)
,	O
size	O
[	O
i	int
]	O
>>	O
10	int
,	O
(	O
size	O
[	O
i	int
]	O
-	O
free	O
[	O
i	int
]	O
)	O
>>	O
10	int
)	O
;	O
name	*(char)
=	O
argz_next	()->(int)
(	O
names	*(char)
,	O
names_len	O
,	O
name	*(char)
)	O
;	O
}	O
vm_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
(	O
vm_offset_t	O
)	O
free	O
,	O
nfree	O
*	O
sizeof	O
(	O
*	O
free	O
)	O
)	O
;	O
vm_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
(	O
vm_offset_t	O
)	O
size	O
,	O
nsize	O
*	O
sizeof	O
(	O
*	O
size	O
)	O
)	O
;	O
vm_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
(	O
vm_offset_t	O
)	O
names	*(char)
,	O
names_len	O
)	O
;	O
out	O
:	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
defpager	O
)	O
;	O
out_fclose	O
:	O
fclose	()->(int)
(	O
m	O
)	O
;	O
return	O
err	O
;	O
}	O
static	O
struct	O
node	O
*	O
rootdir_file_make_node	(*(void),*(void))->(*(struct))
(	O
void	O
*	O
dir_hook	*(void)
,	O
const	O
void	O
*	O
entry_hook	*(void)
)	O
{	O
return	O
procfs_make_node	()->(int)
(	O
entry_hook	*(void)
,	O
dir_hook	*(void)
)	O
;	O
}	O
static	O
struct	O
node	O
*	O
rootdir_symlink_make_node	(*(void),*(void))->(*(struct))
(	O
void	O
*	O
dir_hook	*(void)
,	O
const	O
void	O
*	O
entry_hook	*(void)
)	O
{	O
struct	O
node	O
*	O
np	*(struct)
=	O
procfs_make_node	()->(int)
(	O
entry_hook	*(void)
,	O
dir_hook	*(void)
)	O
;	O
if	O
(	O
np	*(struct)
)	O
procfs_node_chtype	()->(int)
(	O
np	*(struct)
,	O
S_IFLNK	O
)	O
;	O
return	O
np	*(struct)
;	O
}	O
static	O
pthread_spinlock_t	O
rootdir_translated_node_lock	int
=	O
PTHREAD_SPINLOCK_INITIALIZER	O
;	O
struct	O
procfs_translated_node_ops	struct(struct,*(*(struct)),*(char),int)
{	O
struct	O
procfs_node_ops	O
node_ops	struct
;	O
struct	O
node	O
*	O
*	O
npp	*(*(struct))
;	O
char	O
*	O
argz	*(char)
;	O
size_t	O
argz_len	int
;	O
}	O
;	O
static	O
struct	O
node	O
*	O
rootdir_make_translated_node	(*(void),*(void))->(*(struct))
(	O
void	O
*	O
dir_hook	*(void)
,	O
const	O
void	O
*	O
entry_hook	*(void)
)	O
{	O
const	O
struct	O
procfs_translated_node_ops	struct(struct,*(*(struct)),*(char),int)
*	O
ops	*(struct(struct,*(*(struct)),*(char),int))
=	O
entry_hook	*(void)
;	O
struct	O
node	O
*	O
np	*(struct)
,	O
*	O
prev	*(struct)
;	O
pthread_spin_lock	()->(int)
(	O
&	O
rootdir_translated_node_lock	int
)	O
;	O
np	*(struct)
=	O
*	O
ops	*(struct(struct,*(*(struct)),*(char),int))
->	O
npp	*(*(struct))
;	O
pthread_spin_unlock	()->(int)
(	O
&	O
rootdir_translated_node_lock	int
)	O
;	O
if	O
(	O
np	*(struct)
!=	O
NULL	O
)	O
{	O
netfs_nref	()->(int)
(	O
np	*(struct)
)	O
;	O
return	O
np	*(struct)
;	O
}	O
np	*(struct)
=	O
procfs_make_node	()->(int)
(	O
entry_hook	*(void)
,	O
(	O
void	O
*	O
)	O
entry_hook	*(void)
)	O
;	O
if	O
(	O
np	*(struct)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
procfs_node_chtype	()->(int)
(	O
np	*(struct)
,	O
S_IFREG	O
|	O
S_IPTRANS	O
)	O
;	O
procfs_node_chmod	()->(int)
(	O
np	*(struct)
,	O
0444	int
)	O
;	O
pthread_spin_lock	()->(int)
(	O
&	O
rootdir_translated_node_lock	int
)	O
;	O
prev	*(struct)
=	O
*	O
ops	*(struct(struct,*(*(struct)),*(char),int))
->	O
npp	*(*(struct))
;	O
if	O
(	O
*	O
ops	*(struct(struct,*(*(struct)),*(char),int))
->	O
npp	*(*(struct))
==	O
NULL	O
)	O
*	O
ops	*(struct(struct,*(*(struct)),*(char),int))
->	O
npp	*(*(struct))
=	O
np	*(struct)
;	O
pthread_spin_unlock	()->(int)
(	O
&	O
rootdir_translated_node_lock	int
)	O
;	O
if	O
(	O
prev	*(struct)
!=	O
NULL	O
)	O
{	O
procfs_cleanup	()->(int)
(	O
np	*(struct)
)	O
;	O
np	*(struct)
=	O
prev	*(struct)
;	O
}	O
return	O
np	*(struct)
;	O
}	O
static	O
error_t	O
rootdir_translated_node_get_translator	(*(void),*(*(char)),*(int))->(int)
(	O
void	O
*	O
hook	*(void)
,	O
char	O
*	O
*	O
argz	*(char)
,	O
size_t	O
*	O
argz_len	int
)	O
{	O
const	O
struct	O
procfs_translated_node_ops	struct(struct,*(*(struct)),*(char),int)
*	O
ops	*(struct(struct,*(*(struct)),*(char),int))
=	O
hook	*(void)
;	O
*	O
argz	*(char)
=	O
malloc	O
(	O
ops	*(struct(struct,*(*(struct)),*(char),int))
->	O
argz_len	int
)	O
;	O
if	O
(	O
!	O
*	O
argz	*(char)
)	O
return	O
ENOMEM	O
;	O
memcpy	O
(	O
*	O
argz	*(char)
,	O
ops	*(struct(struct,*(*(struct)),*(char),int))
->	O
argz	*(char)
,	O
ops	*(struct(struct,*(*(struct)),*(char),int))
->	O
argz_len	int
)	O
;	O
*	O
argz_len	int
=	O
ops	*(struct(struct,*(*(struct)),*(char),int))
->	O
argz_len	int
;	O
return	O
0	int
;	O
}	O
static	O
const	O
struct	O
procfs_dir_entry	O
rootdir_entries	int
[	O
]	O
=	O
{	O
{	O
.	O
name	*(char)
=	O
"self"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
procfs_node_ops	O
)	O
{	O
.	O
get_contents	O
=	O
rootdir_gc_fakeself	(*(void),*(*(char)),*(int))->(int)
,	O
.	O
cleanup_contents	O
=	O
procfs_cleanup_contents_with_free	O
,	O
}	O
,	O
.	O
ops	*(struct(struct,*(*(struct)),*(char),int))
=	O
{	O
.	O
make_node	O
=	O
rootdir_symlink_make_node	(*(void),*(void))->(*(struct))
,	O
.	O
exists	O
=	O
rootdir_fakeself_exists	(*(void),*(void))->(int)
,	O
}	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"version"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
procfs_node_ops	O
)	O
{	O
.	O
get_contents	O
=	O
rootdir_gc_version	(*(void),*(*(char)),*(int))->(int)
,	O
.	O
cleanup_contents	O
=	O
procfs_cleanup_contents_with_free	O
,	O
}	O
,	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"uptime"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
procfs_node_ops	O
)	O
{	O
.	O
get_contents	O
=	O
rootdir_gc_uptime	(*(void),*(*(char)),*(int))->(int)
,	O
.	O
cleanup_contents	O
=	O
procfs_cleanup_contents_with_free	O
,	O
}	O
,	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"stat"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
procfs_node_ops	O
)	O
{	O
.	O
get_contents	O
=	O
rootdir_gc_stat	(*(void),*(*(char)),*(int))->(int)
,	O
.	O
cleanup_contents	O
=	O
procfs_cleanup_contents_with_free	O
,	O
}	O
,	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"loadavg"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
procfs_node_ops	O
)	O
{	O
.	O
get_contents	O
=	O
rootdir_gc_loadavg	(*(void),*(*(char)),*(int))->(int)
,	O
.	O
cleanup_contents	O
=	O
procfs_cleanup_contents_with_free	O
,	O
}	O
,	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"meminfo"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
procfs_node_ops	O
)	O
{	O
.	O
get_contents	O
=	O
rootdir_gc_meminfo	(*(void),*(*(char)),*(int))->(int)
,	O
.	O
cleanup_contents	O
=	O
procfs_cleanup_contents_with_free	O
,	O
}	O
,	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"vmstat"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
procfs_node_ops	O
)	O
{	O
.	O
get_contents	O
=	O
rootdir_gc_vmstat	(*(void),*(*(char)),*(int))->(int)
,	O
.	O
cleanup_contents	O
=	O
procfs_cleanup_contents_with_free	O
,	O
}	O
,	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"cmdline"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
procfs_node_ops	O
)	O
{	O
.	O
get_contents	O
=	O
rootdir_gc_cmdline	(*(void),*(*(char)),*(int))->(int)
,	O
.	O
cleanup_contents	O
=	O
procfs_cleanup_contents_with_free	O
,	O
}	O
,	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"mounts"	*(char)
,	O
.	O
hook	*(void)
=	O
ROOTDIR_DEFINE_TRANSLATED_NODE	O
(	O
&	O
rootdir_mounts_node	*(struct)
,	O
_HURD_MTAB	O
"\0/"	*(char)
)	O
,	O
.	O
ops	*(struct(struct,*(*(struct)),*(char),int))
=	O
{	O
.	O
make_node	O
=	O
rootdir_make_translated_node	(*(void),*(void))->(*(struct))
,	O
}	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"slabinfo"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
procfs_node_ops	O
)	O
{	O
.	O
get_contents	O
=	O
rootdir_gc_slabinfo	(*(void),*(*(char)),*(int))->(int)
,	O
.	O
cleanup_contents	O
=	O
procfs_cleanup_contents_with_free	O
,	O
}	O
,	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"filesystems"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
procfs_node_ops	O
)	O
{	O
.	O
get_contents	O
=	O
rootdir_gc_filesystems	(*(void),*(*(char)),*(int))->(int)
,	O
.	O
cleanup_contents	O
=	O
procfs_cleanup_contents_with_free	O
,	O
}	O
,	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"swaps"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
procfs_node_ops	O
)	O
{	O
.	O
get_contents	O
=	O
rootdir_gc_swaps	(*(void),*(*(char)),*(int))->(int)
,	O
.	O
cleanup_contents	O
=	O
procfs_cleanup_contents_with_free	O
,	O
}	O
,	O
}	O
,	O
{	O
}	O
}	O
;	O
struct	O
node	O
*	O
rootdir_make_node	(*(struct))->(*(struct))
(	O
struct	O
ps_context	O
*	O
pc	*(struct)
)	O
{	O
static	O
const	O
struct	O
procfs_dir_ops	O
ops	*(struct(struct,*(*(struct)),*(char),int))
=	O
{	O
.	O
entries	O
=	O
rootdir_entries	int
,	O
.	O
entry_ops	O
=	O
{	O
.	O
make_node	O
=	O
rootdir_file_make_node	(*(void),*(void))->(*(struct))
,	O
}	O
,	O
}	O
;	O
return	O
procfs_dir_make_node	()->(int)
(	O
&	O
ops	*(struct(struct,*(*(struct)),*(char),int))
,	O
pc	*(struct)
)	O
;	O
}	O
