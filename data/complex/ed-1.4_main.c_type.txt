static	O
const	O
char	O
*	O
invocation_name	*(char)
=	O
0	int
;	O
static	O
const	O
char	O
*	O
const	O
Program_name	*(char)
=	O
"GNU Ed"	*(char)
;	O
static	O
const	O
char	O
*	O
const	O
program_name	*(char)
=	O
"ed"	*(char)
;	O
static	O
const	O
char	O
*	O
const	O
program_year	*(char)
=	O
"2009"	*(char)
;	O
static	O
char	O
restricted_	char
=	O
0	int
;	O
static	O
char	O
scripted_	char
=	O
0	int
;	O
static	O
char	O
traditional_	char
=	O
0	int
;	O
char	O
restricted	()->(char)
(	O
void	O
)	O
{	O
return	O
restricted_	char
;	O
}	O
char	O
scripted	()->(char)
(	O
void	O
)	O
{	O
return	O
scripted_	char
;	O
}	O
char	O
traditional	()->(char)
(	O
void	O
)	O
{	O
return	O
traditional_	char
;	O
}	O
static	O
void	O
show_help	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%s - The GNU line editor.\n"	*(char)
,	O
Program_name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\nUsage: %s [options] [file]\n"	*(char)
,	O
invocation_name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\nOptions:\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"  -h, --help                 display this help and exit\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"  -V, --version              output version information and exit\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"  -G, --traditional          run in compatibility mode\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"  -l, --loose-exit-status    exit with 0 status even if a command fails\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"  -p, --prompt=STRING        use STRING as an interactive prompt\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"  -s, --quiet, --silent      suppress diagnostics\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"  -v, --verbose              be verbose\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Start edit by reading in `file' if given. Read output of shell command\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"if `file' begins with a `!'.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\nReport bugs to <bug-ed@gnu.org>.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Ed home page: http://www.gnu.org/software/ed/ed.html\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"General help using GNU software: http://www.gnu.org/gethelp\n"	*(char)
)	O
;	O
}	O
static	O
void	O
show_version	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%s %s\n"	*(char)
,	O
Program_name	*(char)
,	O
PROGVERSION	int
)	O
;	O
printf	(*(char))->(int)
(	O
"Copyright (C) 1994 Andrew L. Moore, %s Antonio Diaz Diaz.\n"	*(char)
,	O
program_year	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"This is free software: you are free to change and redistribute it.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"There is NO WARRANTY, to the extent permitted by law.\n"	*(char)
)	O
;	O
}	O
void	O
show_strerror	(*(char),int)->(void)
(	O
const	O
char	O
*	O
filename	*(char)
,	O
int	O
errcode	int
)	O
{	O
if	O
(	O
!	O
scripted_	char
)	O
{	O
if	O
(	O
filename	*(char)
&&	O
filename	*(char)
[	O
0	int
]	O
!=	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: "	*(char)
,	O
filename	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errcode	int
)	O
)	O
;	O
}	O
}	O
static	O
void	O
show_error	(*(char),int,char)->(void)
(	O
const	O
char	O
*	O
msg	*(char)
,	O
const	O
int	O
errcode	int
,	O
const	O
char	O
help	char
)	O
{	O
if	O
(	O
msg	*(char)
&&	O
msg	*(char)
[	O
0	int
]	O
!=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s"	*(char)
,	O
program_name	*(char)
,	O
msg	*(char)
)	O
;	O
if	O
(	O
errcode	int
>	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
": %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errcode	int
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
if	O
(	O
help	char
&&	O
invocation_name	*(char)
&&	O
invocation_name	*(char)
[	O
0	int
]	O
!=	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Try `%s --help' for more information.\n"	*(char)
,	O
invocation_name	*(char)
)	O
;	O
}	O
char	O
is_regular_file	(int)->(char)
(	O
int	O
fd	int
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
return	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fd	int
,	O
&	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
||	O
S_ISREG	O
(	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
;	O
}	O
char	O
may_access_filename	(*(char))->(char)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
restricted_	char
&&	O
(	O
*	O
name	*(char)
==	O
'!'	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
".."	*(char)
)	O
||	O
strchr	(*(char),int)->(*(char))
(	O
name	*(char)
,	O
'/'	O
)	O
)	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Shell access restricted"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
const	O
int	O
argc	int
,	O
const	O
char	O
*	O
argv	array(*(char))
[	O
]	O
)	O
{	O
int	O
n	int
=	O
strlen	(*(char))->(long)
(	O
argv	array(*(char))
[	O
0	int
]	O
)	O
;	O
char	O
loose	char
=	O
0	int
;	O
const	O
ap_Option	struct(int,*(char),enum(int,int,int))
options	array(struct(int,*(char),enum(int,int,int)))
[	O
]	O
=	O
{	O
{	O
'G'	O
,	O
"traditional"	*(char)
,	O
ap_no	int
}	O
,	O
{	O
'h'	O
,	O
"help"	*(char)
,	O
ap_no	int
}	O
,	O
{	O
'l'	O
,	O
"loose-exit-status"	*(char)
,	O
ap_no	int
}	O
,	O
{	O
'p'	O
,	O
"prompt"	*(char)
,	O
ap_yes	int
}	O
,	O
{	O
's'	O
,	O
"quiet"	*(char)
,	O
ap_no	int
}	O
,	O
{	O
's'	O
,	O
"silent"	*(char)
,	O
ap_no	int
}	O
,	O
{	O
'v'	O
,	O
"verbose"	*(char)
,	O
ap_no	int
}	O
,	O
{	O
'V'	O
,	O
"version"	*(char)
,	O
ap_no	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
ap_no	int
}	O
}	O
;	O
Arg_parser	struct(*(struct(int,*(char))),*(char),int,int)
parser	struct(*(struct(int,*(char))),*(char),int,int)
;	O
int	O
argind	int
;	O
if	O
(	O
!	O
ap_init	(*(struct(*(struct(int,*`)),*(char),int,int)),int,array(*(char)),array(struct(int,*(char),enum(int,int,int))),char)->(char)
(	O
&	O
parser	struct(*(struct(int,*(char))),*(char),int,int)
,	O
argc	int
,	O
argv	array(*(char))
,	O
options	array(struct(int,*(char),enum(int,int,int)))
,	O
0	int
)	O
)	O
{	O
show_error	(*(char),int,char)->(void)
(	O
"Memory exhausted"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
ap_error	(*(struct(*(struct(int,*`)),*(char),int,int)))->(*(char))
(	O
&	O
parser	struct(*(struct(int,*(char))),*(char),int,int)
)	O
)	O
{	O
show_error	(*(char),int,char)->(void)
(	O
ap_error	(*(struct(*(struct(int,*`)),*(char),int,int)))->(*(char))
(	O
&	O
parser	struct(*(struct(int,*(char))),*(char),int,int)
)	O
,	O
0	int
,	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
invocation_name	*(char)
=	O
argv	array(*(char))
[	O
0	int
]	O
;	O
restricted_	char
=	O
(	O
n	int
>	O
2	int
&&	O
argv	array(*(char))
[	O
0	int
]	O
[	O
n	int
-	O
3	int
]	O
==	O
'r'	O
)	O
;	O
for	O
(	O
argind	int
=	O
0	int
;	O
argind	int
<	O
ap_arguments	(*(struct(*(struct(int,*`)),*(char),int,int)))->(int)
(	O
&	O
parser	struct(*(struct(int,*(char))),*(char),int,int)
)	O
;	O
++	O
argind	int
)	O
{	O
const	O
int	O
code	int
=	O
ap_code	(*(struct(*(struct(int,*`)),*(char),int,int)),int)->(int)
(	O
&	O
parser	struct(*(struct(int,*(char))),*(char),int,int)
,	O
argind	int
)	O
;	O
const	O
char	O
*	O
arg	*(char)
=	O
ap_argument	(*(struct(*(struct(int,*`)),*(char),int,int)),int)->(*(char))
(	O
&	O
parser	struct(*(struct(int,*(char))),*(char),int,int)
,	O
argind	int
)	O
;	O
if	O
(	O
!	O
code	int
)	O
break	O
;	O
switch	O
(	O
code	int
)	O
{	O
case	O
'G'	O
:	O
traditional_	char
=	O
1	int
;	O
break	O
;	O
case	O
'h'	O
:	O
show_help	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
case	O
'l'	O
:	O
loose	char
=	O
1	int
;	O
break	O
;	O
case	O
'p'	O
:	O
set_prompt	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
scripted_	char
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
set_verbose	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
'V'	O
:	O
show_version	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
default	O
:	O
show_error	(*(char),int,char)->(void)
(	O
"internal_error: uncaught option"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
return	O
3	int
;	O
}	O
}	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
if	O
(	O
!	O
init_buffers	()->(char)
(	O
)	O
)	O
return	O
1	int
;	O
while	O
(	O
argind	int
<	O
ap_arguments	(*(struct(*(struct(int,*`)),*(char),int,int)))->(int)
(	O
&	O
parser	struct(*(struct(int,*(char))),*(char),int,int)
)	O
)	O
{	O
const	O
char	O
*	O
arg	*(char)
=	O
ap_argument	(*(struct(*(struct(int,*`)),*(char),int,int)),int)->(*(char))
(	O
&	O
parser	struct(*(struct(int,*(char))),*(char),int,int)
,	O
argind	int
)	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
arg	*(char)
,	O
"-"	*(char)
)	O
)	O
{	O
scripted_	char
=	O
1	int
;	O
++	O
argind	int
;	O
continue	O
;	O
}	O
if	O
(	O
may_access_filename	(*(char))->(char)
(	O
arg	*(char)
)	O
)	O
{	O
if	O
(	O
read_file	(*(char),int)->(int)
(	O
arg	*(char)
,	O
0	int
)	O
<	O
0	int
&&	O
is_regular_file	(int)->(char)
(	O
0	int
)	O
)	O
return	O
2	int
;	O
else	O
if	O
(	O
arg	*(char)
[	O
0	int
]	O
!=	O
'!'	O
)	O
set_def_filename	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
}	O
else	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"?\n"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
arg	*(char)
[	O
0	int
]	O
)	O
set_error_msg	(*(char))->(void)
(	O
"Invalid filename"	*(char)
)	O
;	O
if	O
(	O
is_regular_file	(int)->(char)
(	O
0	int
)	O
)	O
return	O
2	int
;	O
}	O
break	O
;	O
}	O
ap_free	(*(struct(*(struct(int,*`)),*(char),int,int)))->(void)
(	O
&	O
parser	struct(*(struct(int,*(char))),*(char),int,int)
)	O
;	O
return	O
main_loop	(char)->(int)
(	O
loose	char
)	O
;	O
}	O
