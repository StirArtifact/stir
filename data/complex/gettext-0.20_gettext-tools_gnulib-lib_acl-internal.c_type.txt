int	O
acl_access_nontrivial	(*(struct))->(int)
(	O
acl_t	*(struct)
acl	*(struct)
)	O
{	O
acl_entry_t	*(struct)
ace	*(struct)
;	O
int	O
got_one	int
;	O
for	O
(	O
got_one	int
=	O
acl_get_entry	(*(struct),int,*(*(struct)))->(int)
(	O
acl	*(struct)
,	O
ACL_FIRST_ENTRY	int
,	O
&	O
ace	*(struct)
)	O
;	O
got_one	int
>	O
0	int
;	O
got_one	int
=	O
acl_get_entry	(*(struct),int,*(*(struct)))->(int)
(	O
acl	*(struct)
,	O
ACL_NEXT_ENTRY	int
,	O
&	O
ace	*(struct)
)	O
)	O
{	O
acl_tag_t	int
tag	int
;	O
if	O
(	O
acl_get_tag_type	(*(struct),*(int))->(int)
(	O
ace	*(struct)
,	O
&	O
tag	int
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
(	O
tag	int
==	O
ACL_USER_OBJ	O
||	O
tag	int
==	O
ACL_GROUP_OBJ	O
||	O
tag	int
==	O
ACL_OTHER	O
)	O
)	O
return	O
1	int
;	O
}	O
return	O
got_one	int
;	O
}	O
int	O
acl_default_nontrivial	(*(struct))->(int)
(	O
acl_t	*(struct)
acl	*(struct)
)	O
{	O
return	O
(	O
acl_entries	(*(struct))->(int)
(	O
acl	*(struct)
)	O
>	O
0	int
)	O
;	O
}	O
void	O
free_permission_context	(*(struct(int,*(struct),*(struct),bool)))->(void)
(	O
struct	O
permission_context	struct(int,*(struct),*(struct),bool)
*	O
ctx	*(struct(int,*(struct),*(struct),bool))
)	O
{	O
if	O
(	O
ctx	*(struct(int,*(struct),*(struct),bool))
->	O
acl	*(struct)
)	O
acl_free	(*(void))->(int)
(	O
ctx	*(struct(int,*(struct),*(struct),bool))
->	O
acl	*(struct)
)	O
;	O
if	O
(	O
ctx	*(struct(int,*(struct),*(struct),bool))
->	O
default_acl	*(struct)
)	O
acl_free	(*(void))->(int)
(	O
ctx	*(struct(int,*(struct),*(struct),bool))
->	O
default_acl	*(struct)
)	O
;	O
}	O
