static	O
struct	O
dict_connection	struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))))
*	O
conn	*(struct)
;	O
int	O
set_bool	(*(int),*(char))->(int)
(	O
int	O
*	O
pval	*(int)
,	O
char	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"yes"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"on"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"true"	*(char)
)	O
==	O
0	int
)	O
*	O
pval	*(int)
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"no"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"off"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"false"	*(char)
)	O
==	O
0	int
)	O
*	O
pval	*(int)
=	O
0	int
;	O
else	O
{	O
script_error	(*(char))->(void)
(	O
_	O
(	O
"Expected boolean value"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
ds_silent_close	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
conn	*(struct)
)	O
{	O
stream_printf	(*(struct),*(char))->(int)
(	O
conn	*(struct)
->	O
str	*(char)
,	O
"QUIT\r\n"	*(char)
)	O
;	O
dict_read_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
;	O
dict_conn_close	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(void)
(	O
conn	*(struct)
)	O
;	O
conn	*(struct)
=	O
NULL	O
;	O
}	O
}	O
static	O
int	O
get_list	(*(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`)))),*(char),*(char))->(int)
(	O
struct	O
dict_result	struct(*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char)))))
*	O
*	O
pres	*(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))
,	O
char	O
*	O
cmd	*(char)
,	O
char	O
*	O
code	int
)	O
{	O
if	O
(	O
conn	*(struct)
&&	O
*	O
pres	*(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))
==	O
NULL	O
)	O
{	O
stream_printf	(*(struct),*(char))->(int)
(	O
conn	*(struct)
->	O
str	*(char)
,	O
"%s\r\n"	*(char)
,	O
cmd	*(char)
)	O
;	O
dict_read_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
;	O
if	O
(	O
dict_status_p	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char))->(int)
(	O
conn	*(struct)
,	O
code	int
)	O
)	O
{	O
unsigned	O
long	O
count	long
;	O
char	O
*	O
p	*(void)
;	O
count	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
conn	*(struct)
->	O
buf	*(void)
+	O
3	int
,	O
&	O
p	*(void)
,	O
10	int
)	O
;	O
dict_multiline_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
;	O
dict_result_create	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),enum(int,int,int),long,*(char))->(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))
(	O
conn	*(struct)
,	O
dict_result_match	int
,	O
count	long
,	O
obstack_finish	O
(	O
&	O
conn	*(struct)
->	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
)	O
)	O
;	O
dict_read_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
;	O
*	O
pres	*(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))
=	O
dict_conn_last_result	O
(	O
conn	*(struct)
)	O
;	O
}	O
else	O
{	O
script_error	(*(char))->(void)
(	O
_	O
(	O
"Cannot get listing: %s"	*(char)
)	O
,	O
conn	*(struct)
->	O
buf	*(void)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
void	O
check_disconnect	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
conn	*(struct)
)	O
{	O
int	O
rc	int
;	O
fd_set	struct(array(long))
rd	struct(array(long))
,	O
wr	struct(array(long))
,	O
ex	struct(array(long))
;	O
FD_ZERO	O
(	O
&	O
rd	struct(array(long))
)	O
;	O
FD_SET	O
(	O
conn	*(struct)
->	O
fd	int
,	O
&	O
rd	struct(array(long))
)	O
;	O
FD_ZERO	O
(	O
&	O
wr	struct(array(long))
)	O
;	O
FD_SET	O
(	O
conn	*(struct)
->	O
fd	int
,	O
&	O
wr	struct(array(long))
)	O
;	O
FD_ZERO	O
(	O
&	O
ex	struct(array(long))
)	O
;	O
FD_SET	O
(	O
conn	*(struct)
->	O
fd	int
,	O
&	O
ex	struct(array(long))
)	O
;	O
do	O
rc	int
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
conn	*(struct)
->	O
fd	int
+	O
1	int
,	O
&	O
rd	struct(array(long))
,	O
&	O
wr	struct(array(long))
,	O
&	O
ex	struct(array(long))
,	O
NULL	O
)	O
;	O
while	O
(	O
rc	int
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
;	O
if	O
(	O
rc	int
<	O
0	int
||	O
FD_ISSET	O
(	O
conn	*(struct)
->	O
fd	int
,	O
&	O
rd	struct(array(long))
)	O
)	O
{	O
dict_conn_close	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(void)
(	O
conn	*(struct)
)	O
;	O
conn	*(struct)
=	O
NULL	O
;	O
}	O
}	O
}	O
int	O
ensure_connection	()->(int)
(	O
void	O
)	O
{	O
check_disconnect	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
conn	*(struct)
)	O
{	O
if	O
(	O
!	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
host	*(char)
&&	O
!	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
path	*(char)
)	O
{	O
script_error	(*(char))->(void)
(	O
_	O
(	O
"Please specify server name or IP address"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
dict_connect	(*(*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))))->(int)
(	O
&	O
conn	*(struct)
,	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
)	O
)	O
{	O
script_error	(*(char))->(void)
(	O
_	O
(	O
"Cannot connect to the server"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
XDICO_DEBUG	O
(	O
1	int
,	O
_	O
(	O
"Getting list of databases\n"	*(char)
)	O
)	O
;	O
get_list	(*(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`)))),*(char),*(char))->(int)
(	O
&	O
conn	*(struct)
->	O
db_result	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
,	O
"SHOW DATABASES"	*(char)
,	O
"110"	*(char)
)	O
;	O
XDICO_DEBUG	O
(	O
1	int
,	O
_	O
(	O
"Getting list of strategies\n"	*(char)
)	O
)	O
;	O
get_list	(*(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`)))),*(char),*(char))->(int)
(	O
&	O
conn	*(struct)
->	O
strat_result	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
,	O
"SHOW STRATEGIES"	*(char)
,	O
"111"	*(char)
)	O
;	O
XDICO_DEBUG	O
(	O
1	int
,	O
_	O
(	O
"Finished getting server information\n"	*(char)
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
ds_open	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
argc	int
>	O
1	int
)	O
{	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
string	*(*(char))
,	O
NULL	O
)	O
;	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
host	*(char)
,	O
NULL	O
)	O
;	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
port	*(char)
,	O
NULL	O
)	O
;	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
path	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
}	O
else	O
{	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
host	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
port	*(char)
,	O
argc	int
==	O
3	int
?	O
argv	*(*(char))
[	O
2	int
]	O
:	O
DICO_DICT_PORT_STR	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
!	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
host	*(char)
&&	O
!	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
path	*(char)
)	O
{	O
script_error	(*(char))->(void)
(	O
_	O
(	O
"Please specify server name or IP address"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
ds_silent_close	()->(void)
(	O
)	O
;	O
ensure_connection	()->(int)
(	O
)	O
;	O
}	O
void	O
ds_close	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
!	O
conn	*(struct)
)	O
script_error	(*(char))->(void)
(	O
_	O
(	O
"Nothing to close"	*(char)
)	O
)	O
;	O
else	O
ds_silent_close	()->(void)
(	O
)	O
;	O
}	O
void	O
ds_autologin	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
if	O
(	O
!	O
autologin_file	*(char)
)	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
_	O
(	O
"No autologin file."	*(char)
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
autologin_file	*(char)
)	O
;	O
}	O
else	O
{	O
char	O
*	O
str	*(char)
;	O
if	O
(	O
ds_tilde_expand	(*(char),*(*(char)))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
str	*(char)
)	O
)	O
{	O
free	(*(void))->(void)
(	O
autologin_file	*(char)
)	O
;	O
autologin_file	*(char)
=	O
str	*(char)
;	O
}	O
else	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
autologin_file	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
}	O
}	O
void	O
ds_sasl	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
sasl_enabled_p	()->(int)
(	O
)	O
?	O
_	O
(	O
"on"	*(char)
)	O
:	O
_	O
(	O
"off"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
int	O
val	array(int)
;	O
if	O
(	O
set_bool	(*(int),*(char))->(int)
(	O
&	O
val	array(int)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
==	O
0	int
)	O
sasl_enable	(int)->(void)
(	O
val	array(int)
)	O
;	O
}	O
}	O
void	O
ds_database	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
database	*(char)
?	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
database	*(char)
:	O
"!"	*(char)
)	O
;	O
}	O
else	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
database	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
}	O
static	O
char	O
*	O
result_generator	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))),*(char),int)->(*(char))
(	O
struct	O
dict_result	struct(*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`))))),*(struct),enum(int,int,int),long,*(char),union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char)))))
*	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
,	O
const	O
char	O
*	O
text	*(char)
,	O
int	O
state	*(int)
)	O
{	O
static	O
int	O
i	long
,	O
len	long
;	O
if	O
(	O
!	O
state	*(int)
)	O
{	O
i	long
=	O
0	int
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
;	O
}	O
while	O
(	O
i	long
<	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
count	long
)	O
{	O
char	O
*	O
s	long
=	O
res	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
->	O
set	union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char))))
.	O
mat	*(struct(*(char),*(char)))
[	O
i	long
]	O
.	O
database	*(char)
;	O
i	long
++	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
s	long
,	O
text	*(char)
,	O
len	long
)	O
==	O
0	int
)	O
return	O
strdup	(*(char))->(*(char))
(	O
s	long
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
db_generator	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
text	*(char)
,	O
int	O
state	*(int)
)	O
{	O
return	O
result_generator	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))),*(char),int)->(*(char))
(	O
conn	*(struct)
->	O
db_result	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
,	O
text	*(char)
,	O
state	*(int)
)	O
;	O
}	O
char	O
*	O
*	O
ds_compl_database	(int,*(*(char)),int)->(*(*(char)))
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
)	O
{	O
return	O
dict_completion_matches	(int,*(*(char)),int,*((*(char),int)->(*(char))))->(*(*(char)))
(	O
argc	int
,	O
argv	*(*(char))
,	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
,	O
db_generator	(*(char),int)->(*(char))
)	O
;	O
}	O
void	O
ds_strategy	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
strategy	*(char)
)	O
;	O
}	O
else	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
strategy	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
}	O
static	O
char	O
*	O
strat_generator	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
text	*(char)
,	O
int	O
state	*(int)
)	O
{	O
return	O
result_generator	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))),*(char),int)->(*(char))
(	O
conn	*(struct)
->	O
strat_result	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
,	O
text	*(char)
,	O
state	*(int)
)	O
;	O
}	O
char	O
*	O
*	O
ds_compl_strategy	(int,*(*(char)),int)->(*(*(char)))
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
)	O
{	O
return	O
dict_completion_matches	(int,*(*(char)),int,*((*(char),int)->(*(char))))->(*(*(char)))
(	O
argc	int
,	O
argv	*(*(char))
,	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
,	O
strat_generator	(*(char),int)->(*(char))
)	O
;	O
}	O
void	O
ds_verbose	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
argc	int
==	O
1	int
)	O
printf	(*(char))->(int)
(	O
"%d\n"	*(char)
,	O
debug_level	int
)	O
;	O
else	O
{	O
char	O
*	O
p	*(void)
;	O
int	O
n	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
p	*(void)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(void)
)	O
script_error	(*(char))->(void)
(	O
_	O
(	O
"invalid number"	*(char)
)	O
)	O
;	O
else	O
debug_level	int
=	O
n	long
;	O
}	O
}	O
void	O
ds_transcript	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
argc	int
==	O
1	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"transcript is %s\n"	*(char)
)	O
,	O
transcript	int
?	O
_	O
(	O
"on"	*(char)
)	O
:	O
_	O
(	O
"off"	*(char)
)	O
)	O
;	O
else	O
{	O
set_bool	(*(int),*(char))->(int)
(	O
&	O
transcript	int
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
conn	*(struct)
)	O
dict_transcript	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),int)->(void)
(	O
conn	*(struct)
,	O
transcript	int
)	O
;	O
}	O
}	O
void	O
ds_define	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
ensure_connection	()->(int)
(	O
)	O
)	O
return	O
;	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
type	enum(int,int,int)
=	O
DICO_REQUEST_DEFINE	int
;	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
word	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
dict_lookup	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))))->(int)
(	O
conn	*(struct)
,	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
)	O
;	O
}	O
void	O
ds_match	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
ensure_connection	()->(int)
(	O
)	O
)	O
return	O
;	O
if	O
(	O
argc	int
==	O
2	int
&&	O
argv	*(*(char))
[	O
1	int
]	O
[	O
0	int
]	O
)	O
{	O
dict_result_free	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))->(void)
(	O
conn	*(struct)
->	O
match_result	struct(*(char),*(char))
)	O
;	O
conn	*(struct)
->	O
match_result	struct(*(char),*(char))
=	O
NULL	O
;	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
type	enum(int,int,int)
=	O
DICO_REQUEST_MATCH	int
;	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
word	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
rc	int
=	O
dict_match	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char),*(char),*(char))->(int)
(	O
conn	*(struct)
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
0	int
,	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
database	*(char)
)	O
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
1	int
,	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
strategy	*(char)
)	O
,	O
quotearg_n	(int,*(char))->(*(char))
(	O
2	int
,	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
word	*(char)
)	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
conn	*(struct)
->	O
match_result	struct(*(char),*(char))
=	O
dict_conn_last_result	O
(	O
conn	*(struct)
)	O
;	O
else	O
{	O
print_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(void)
(	O
conn	*(struct)
)	O
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
conn	*(struct)
->	O
match_result	struct(*(char),*(char))
)	O
{	O
script_error	(*(char))->(void)
(	O
_	O
(	O
"No previous match"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
print_match_result	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))->(void)
(	O
conn	*(struct)
->	O
match_result	struct(*(char),*(char))
)	O
;	O
}	O
void	O
ds_define_nth	(long)->(void)
(	O
size_t	long
num	int
)	O
{	O
struct	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
=	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
;	O
if	O
(	O
ensure_connection	()->(int)
(	O
)	O
)	O
return	O
;	O
if	O
(	O
!	O
conn	*(struct)
->	O
match_result	struct(*(char),*(char))
)	O
{	O
script_error	(*(char))->(void)
(	O
_	O
(	O
"No previous match"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
num	int
>=	O
conn	*(struct)
->	O
match_result	struct(*(char),*(char))
->	O
count	long
)	O
{	O
script_error	(*(char))->(void)
(	O
_	O
(	O
"Invalid match number.  Type / to see the matches."	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
type	enum(int,int,int)
=	O
DICO_REQUEST_DEFINE	int
;	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
database	*(char)
=	O
conn	*(struct)
->	O
match_result	struct(*(char),*(char))
->	O
set	union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char))))
.	O
mat	*(struct(*(char),*(char)))
[	O
num	int
]	O
.	O
database	*(char)
;	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
word	*(char)
=	O
conn	*(struct)
->	O
match_result	struct(*(char),*(char))
->	O
set	union(*(struct(*(char),*(char),*(char),*(char),long)),*(struct(*(char),*(char))))
.	O
mat	*(struct(*(char),*(char)))
[	O
num	int
]	O
.	O
word	*(char)
;	O
dict_lookup	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))))->(int)
(	O
conn	*(struct)
,	O
&	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
)	O
;	O
}	O
void	O
ds_distance	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
if	O
(	O
conn	*(struct)
)	O
{	O
if	O
(	O
!	O
dict_capa	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char))->(int)
(	O
conn	*(struct)
,	O
"xlev"	*(char)
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Server does not support XLEV extension"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
stream_printf	(*(struct),*(char))->(int)
(	O
conn	*(struct)
->	O
str	*(char)
,	O
"XLEV TELL\r\n"	*(char)
)	O
;	O
dict_read_reply	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))))->(int)
(	O
conn	*(struct)
)	O
;	O
if	O
(	O
dict_status_p	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char))->(int)
(	O
conn	*(struct)
,	O
"280"	*(char)
)	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Reported Levenshtein distance:%s\n"	*(char)
)	O
,	O
conn	*(struct)
->	O
buf	*(void)
+	O
3	int
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
_	O
(	O
"Cannot query Levenshtein distance.  Server responded:"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
conn	*(struct)
->	O
buf	*(void)
)	O
;	O
}	O
}	O
if	O
(	O
levenshtein_threshold	int
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"No distance configured\n"	*(char)
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Configured Levenshtein distance: %u\n"	*(char)
)	O
,	O
levenshtein_threshold	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
p	*(void)
;	O
levenshtein_threshold	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
p	*(void)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(void)
)	O
script_error	(*(char))->(void)
(	O
_	O
(	O
"invalid number"	*(char)
)	O
)	O
;	O
}	O
}	O
void	O
ds_show_db	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
ensure_connection	()->(int)
(	O
)	O
)	O
return	O
;	O
print_result	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))->(void)
(	O
conn	*(struct)
->	O
db_result	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
;	O
}	O
void	O
ds_show_strat	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
ensure_connection	()->(int)
(	O
)	O
)	O
return	O
;	O
print_result	(*(struct(*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(int,*`,int,int,*`,*`,*`,long,long,long,struct`,*`,*`,*`,*`)),enum(int,int,int),long,*(char),union(*(struct`),*(struct`)))))->(void)
(	O
conn	*(struct)
->	O
strat_result	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),long,*(char),union(*`,*`))),*(struct(int,*(struct`),int,int,*(*`),*(char),*(char),long,long,long,struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,*(char),union(*(struct(*`,*`,*`,*`,long)),*(struct(*`,*`)))))
)	O
;	O
}	O
void	O
ds_show_info	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
const	O
char	O
*	O
dbname	*(char)
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
dbname	*(char)
=	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
database	*(char)
?	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
database	*(char)
:	O
"!"	*(char)
;	O
else	O
dbname	*(char)
=	O
argv	*(*(char))
[	O
1	int
]	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
dbname	*(char)
,	O
"!"	*(char)
)	O
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Search all of the databases until a match is found,\n"	*(char)
"and display all matches in that database.\n"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
dbname	*(char)
,	O
"*"	*(char)
)	O
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Search all of the databases and display all matches."	*(char)
)	O
)	O
;	O
else	O
{	O
if	O
(	O
ensure_connection	()->(int)
(	O
)	O
)	O
return	O
;	O
dict_run_single_command	(*(struct(int,*(struct),int,int,*(*(char)),*(char),*(char),long,long,long,struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)),*(struct(*`,*`,enum(int,int,int),long,*`,union`)))),*(char),*(char),*(char))->(void)
(	O
conn	*(struct)
,	O
"SHOW INFO"	*(char)
,	O
dbname	*(char)
,	O
"112"	*(char)
)	O
;	O
}	O
}	O
void	O
ds_version	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
PACKAGE_STRING	*(char)
)	O
;	O
}	O
