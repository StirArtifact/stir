struct	O
_mu_acl_entry	struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char)))
{	O
mu_acl_action_t	enum(int,int,int,int,int)
action	enum(int,int,int,int,int)
;	O
void	O
*	O
arg	*(char)
;	O
struct	O
mu_cidr	struct(int,int,array(char),array(char))
cidr	*(struct(int,int,array(char),array(char)))
;	O
}	O
;	O
struct	O
_mu_acl	struct(*(struct),*(*(char)),long,long)
{	O
mu_list_t	*(struct)
aclist	*(struct)
;	O
char	O
*	O
*	O
envv	*(*(char))
;	O
size_t	long
envc	long
;	O
size_t	long
envn	long
;	O
}	O
;	O
struct	O
run_closure	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
{	O
unsigned	O
idx	int
;	O
struct	O
mu_cidr	struct(int,int,array(char),array(char))
addr	int
;	O
char	O
*	O
*	O
env	*(*(char))
;	O
char	O
ipstr	array(char)
[	O
40	int
]	O
;	O
char	O
*	O
addrstr	*(char)
;	O
mu_acl_result_t	enum(int,int,int)
*	O
result	*(enum(int,int,int))
;	O
}	O
;	O
static	O
void	O
_destroy_acl_entry	(*(void))->(void)
(	O
void	O
*	O
item	*(void)
)	O
{	O
struct	O
_mu_acl_entry	struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char)))
*	O
p	*(char)
=	O
item	*(void)
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
}	O
int	O
mu_acl_entry_create	(*(*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))),enum(int,int,int,int,int),*(void),*(struct(int,int,array(char),array(char))))->(int)
(	O
struct	O
_mu_acl_entry	struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char)))
*	O
*	O
pent	*(*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char)))))
,	O
mu_acl_action_t	enum(int,int,int,int,int)
action	enum(int,int,int,int,int)
,	O
void	O
*	O
data	*(void)
,	O
struct	O
mu_cidr	struct(int,int,array(char),array(char))
*	O
cidr	*(struct(int,int,array(char),array(char)))
)	O
{	O
struct	O
_mu_acl_entry	struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char)))
*	O
p	*(char)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
p	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
return	O
EINVAL	int
;	O
p	*(char)
->	O
action	enum(int,int,int,int,int)
=	O
action	enum(int,int,int,int,int)
;	O
p	*(char)
->	O
arg	*(char)
=	O
data	*(void)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
p	*(char)
->	O
cidr	*(struct(int,int,array(char),array(char)))
,	O
cidr	*(struct(int,int,array(char),array(char)))
,	O
sizeof	O
(	O
p	*(char)
->	O
cidr	*(struct(int,int,array(char),array(char)))
)	O
)	O
;	O
*	O
pent	*(*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char)))))
=	O
p	*(char)
;	O
return	O
0	int
;	O
}	O
int	O
mu_acl_create	(*(*(struct)))->(int)
(	O
mu_acl_t	*(struct)
*	O
pacl	*(*(struct(*(struct),*(*(char)),long,long)))
)	O
{	O
int	O
rc	int
;	O
mu_acl_t	*(struct)
acl	*(*(struct))
;	O
acl	*(*(struct))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
acl	*(*(struct))
)	O
)	O
;	O
if	O
(	O
!	O
acl	*(*(struct))
)	O
return	O
errno	O
;	O
rc	int
=	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
acl	*(*(struct))
->	O
aclist	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
free	(*(void))->(void)
(	O
acl	*(*(struct))
)	O
;	O
else	O
*	O
pacl	*(*(struct(*(struct),*(*(char)),long,long)))
=	O
acl	*(*(struct))
;	O
mu_list_set_destroy_item	(*(struct),*((*(void))->(void)))->(*((*(void))->(void)))
(	O
acl	*(*(struct))
->	O
aclist	*(struct)
,	O
_destroy_acl_entry	(*(void))->(void)
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_acl_count	(*(struct),*(long))->(int)
(	O
mu_acl_t	*(struct)
acl	*(*(struct))
,	O
size_t	long
*	O
pcount	*(long)
)	O
{	O
if	O
(	O
!	O
acl	*(*(struct))
)	O
return	O
EINVAL	int
;	O
return	O
mu_list_count	(*(struct),*(long))->(int)
(	O
acl	*(*(struct))
->	O
aclist	*(struct)
,	O
pcount	*(long)
)	O
;	O
}	O
int	O
mu_acl_destroy	(*(*(struct)))->(int)
(	O
mu_acl_t	*(struct)
*	O
pacl	*(*(struct(*(struct),*(*(char)),long,long)))
)	O
{	O
size_t	long
i	long
;	O
mu_acl_t	*(struct)
acl	*(*(struct))
;	O
if	O
(	O
!	O
pacl	*(*(struct(*(struct),*(*(char)),long,long)))
||	O
!	O
*	O
pacl	*(*(struct(*(struct),*(*(char)),long,long)))
)	O
return	O
EINVAL	int
;	O
acl	*(*(struct))
=	O
*	O
pacl	*(*(struct(*(struct),*(*(char)),long,long)))
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
acl	*(*(struct))
->	O
aclist	*(struct)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
acl	*(*(struct))
->	O
envc	long
&&	O
acl	*(*(struct))
->	O
envv	*(*(char))
[	O
i	long
]	O
;	O
i	long
++	O
)	O
free	(*(void))->(void)
(	O
acl	*(*(struct))
->	O
envv	*(*(char))
[	O
i	long
]	O
)	O
;	O
free	(*(void))->(void)
(	O
acl	*(*(struct))
->	O
envv	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
acl	*(*(struct))
)	O
;	O
*	O
pacl	*(*(struct(*(struct),*(*(char)),long,long)))
=	O
acl	*(*(struct))
;	O
return	O
0	int
;	O
}	O
int	O
mu_acl_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
mu_acl_t	*(struct)
acl	*(*(struct))
,	O
mu_iterator_t	*(struct)
*	O
pitr	*(*(struct))
)	O
{	O
if	O
(	O
!	O
acl	*(*(struct))
)	O
return	O
EINVAL	int
;	O
return	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
acl	*(*(struct))
->	O
aclist	*(struct)
,	O
pitr	*(*(struct))
)	O
;	O
}	O
int	O
mu_acl_append	(*(struct),enum(int,int,int,int,int),*(void),*(struct))->(int)
(	O
mu_acl_t	*(struct)
acl	*(*(struct))
,	O
mu_acl_action_t	enum(int,int,int,int,int)
act	enum(int,int,int,int,int)
,	O
void	O
*	O
data	*(void)
,	O
struct	O
mu_cidr	struct(int,int,array(char),array(char))
*	O
cidr	*(struct(int,int,array(char),array(char)))
)	O
{	O
int	O
rc	int
;	O
struct	O
_mu_acl_entry	struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char)))
*	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
;	O
if	O
(	O
!	O
acl	*(*(struct))
)	O
return	O
EINVAL	int
;	O
rc	int
=	O
mu_acl_entry_create	(*(*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))),enum(int,int,int,int,int),*(void),*(struct(int,int,array(char),array(char))))->(int)
(	O
&	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
,	O
act	enum(int,int,int,int,int)
,	O
data	*(void)
,	O
cidr	*(struct(int,int,array(char),array(char)))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Cannot allocate ACL entry: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
rc	int
=	O
mu_list_append	(*(struct),*(void))->(int)
(	O
acl	*(*(struct))
->	O
aclist	*(struct)
,	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Cannot append ACL entry: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_acl_prepend	(*(struct),enum(int,int,int,int,int),*(void),*(struct))->(int)
(	O
mu_acl_t	*(struct)
acl	*(*(struct))
,	O
mu_acl_action_t	enum(int,int,int,int,int)
act	enum(int,int,int,int,int)
,	O
void	O
*	O
data	*(void)
,	O
struct	O
mu_cidr	struct(int,int,array(char),array(char))
*	O
cidr	*(struct(int,int,array(char),array(char)))
)	O
{	O
int	O
rc	int
;	O
struct	O
_mu_acl_entry	struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char)))
*	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
;	O
if	O
(	O
!	O
acl	*(*(struct))
)	O
return	O
EINVAL	int
;	O
rc	int
=	O
mu_acl_entry_create	(*(*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))),enum(int,int,int,int,int),*(void),*(struct(int,int,array(char),array(char))))->(int)
(	O
&	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
,	O
act	enum(int,int,int,int,int)
,	O
data	*(void)
,	O
cidr	*(struct(int,int,array(char),array(char)))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Cannot allocate ACL entry: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
rc	int
=	O
mu_list_prepend	(*(struct),*(void))->(int)
(	O
acl	*(*(struct))
->	O
aclist	*(struct)
,	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Cannot prepend ACL entry: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_acl_insert	(*(struct),long,int,enum(int,int,int,int,int),*(void),*(struct))->(int)
(	O
mu_acl_t	*(struct)
acl	*(*(struct))
,	O
size_t	long
pos	long
,	O
int	O
before	int
,	O
mu_acl_action_t	enum(int,int,int,int,int)
act	enum(int,int,int,int,int)
,	O
void	O
*	O
data	*(void)
,	O
struct	O
mu_cidr	struct(int,int,array(char),array(char))
*	O
cidr	*(struct(int,int,array(char),array(char)))
)	O
{	O
int	O
rc	int
;	O
void	O
*	O
ptr	*(*(void))
;	O
struct	O
_mu_acl_entry	struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char)))
*	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
;	O
if	O
(	O
!	O
acl	*(*(struct))
)	O
return	O
EINVAL	int
;	O
rc	int
=	O
mu_list_get	(*(struct),long,*(*(void)))->(int)
(	O
acl	*(*(struct))
->	O
aclist	*(struct)
,	O
pos	long
,	O
&	O
ptr	*(*(void))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"No such entry %lu"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
pos	long
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_acl_entry_create	(*(*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))),enum(int,int,int,int,int),*(void),*(struct(int,int,array(char),array(char))))->(int)
(	O
&	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
,	O
act	enum(int,int,int,int,int)
,	O
data	*(void)
,	O
cidr	*(struct(int,int,array(char),array(char)))
)	O
;	O
if	O
(	O
!	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Cannot allocate ACL entry: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
rc	int
=	O
mu_list_insert	(*(struct),*(void),*(void),int)->(int)
(	O
acl	*(*(struct))
->	O
aclist	*(struct)
,	O
ptr	*(*(void))
,	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
,	O
before	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Cannot insert ACL entry: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
mu_kwd_t	struct
action_tab	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"accept"	*(char)
,	O
mu_acl_accept	int
}	O
,	O
{	O
"deny"	*(char)
,	O
mu_acl_deny	int
}	O
,	O
{	O
"log"	*(char)
,	O
mu_acl_log	int
}	O
,	O
{	O
"exec"	*(char)
,	O
mu_acl_exec	int
}	O
,	O
{	O
"ifexec"	*(char)
,	O
mu_acl_ifexec	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
mu_acl_action_to_string	(enum(int,int,int,int,int),*(*(char)))->(int)
(	O
mu_acl_action_t	enum(int,int,int,int,int)
act	enum(int,int,int,int,int)
,	O
const	O
char	O
*	O
*	O
pstr	*(*(char))
)	O
{	O
return	O
mu_kwd_xlat_tok	(*(struct(*(char),int)),int,*(*(char)))->(int)
(	O
action_tab	array(struct(*(char),int))
,	O
act	enum(int,int,int,int,int)
,	O
pstr	*(*(char))
)	O
;	O
}	O
int	O
mu_acl_string_to_action	(*(char),*(enum(int,int,int,int,int)))->(int)
(	O
const	O
char	O
*	O
str	*(struct(int,*(char),*(char),*(char),*(char)))
,	O
mu_acl_action_t	enum(int,int,int,int,int)
*	O
pres	*(enum(int,int,int))
)	O
{	O
int	O
x	int
;	O
int	O
rc	int
=	O
mu_kwd_xlat_name	(*(struct(*(char),int)),*(char),*(int))->(int)
(	O
action_tab	array(struct(*(char),int))
,	O
str	*(struct(int,*(char),*(char),*(char),*(char)))
,	O
&	O
x	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
*	O
pres	*(enum(int,int,int))
=	O
x	int
;	O
return	O
rc	int
;	O
}	O
int	O
_acl_match	(*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char)))),*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))))->(int)
(	O
struct	O
_mu_acl_entry	struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char)))
*	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
,	O
struct	O
run_closure	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
*	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
)	O
{	O
if	O
(	O
mu_debug_level_p	(int,int)->(int)
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_TRACE9	int
)	O
)	O
{	O
char	O
*	O
s	*(char)
=	O
NULL	O
;	O
int	O
rc	int
;	O
if	O
(	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
->	O
cidr	*(struct(int,int,array(char),array(char)))
.	O
len	long
&&	O
(	O
rc	int
=	O
mu_cidr_format	(*(struct(int,int,array(char),array(char))),int,*(*(char)))->(int)
(	O
&	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
->	O
cidr	*(struct(int,int,array(char),array(char)))
,	O
0	int
,	O
&	O
s	*(char)
)	O
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"mu_cidr_format: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
addrstr	*(char)
)	O
mu_cidr_format	(*(struct(int,int,array(char),array(char))),int,*(*(char)))->(int)
(	O
&	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
addr	int
,	O
MU_CIDR_FMT_ADDRONLY	int
,	O
&	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
addrstr	*(char)
)	O
;	O
mu_debug_log_begin	(*(char))->(void)
(	O
"Does %s match %s? "	*(char)
,	O
s	*(char)
?	O
s	*(char)
:	O
"any"	*(char)
,	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
addrstr	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
}	O
if	O
(	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
->	O
cidr	*(struct(int,int,array(char),array(char)))
.	O
len	long
>	O
0	int
&&	O
mu_cidr_match	(*(struct(int,int,array(char),array(char))),*(struct(int,int,array(char),array(char))))->(int)
(	O
&	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
->	O
cidr	*(struct(int,int,array(char),array(char)))
,	O
&	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
addr	int
)	O
)	O
{	O
RESMATCH	O
(	O
"no"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
RESMATCH	O
(	O
"yes"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
acl_getvar	(*(*(char)),*(char),long,*(void))->(int)
(	O
char	O
*	O
*	O
ret	*(*(char))
,	O
const	O
char	O
*	O
name	*(char)
,	O
size_t	long
nlen	long
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
run_closure	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
*	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
=	O
data	*(void)
;	O
if	O
(	O
SEQ	O
(	O
"aclno"	*(char)
,	O
name	*(char)
,	O
nlen	long
)	O
)	O
{	O
if	O
(	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
ret	*(*(char))
,	O
"%u"	*(char)
,	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
idx	int
)	O
)	O
return	O
MU_WRDSE_NOSPACE	O
;	O
return	O
MU_WRDSE_OK	O
;	O
}	O
else	O
if	O
(	O
SEQ	O
(	O
"address"	*(char)
,	O
name	*(char)
,	O
nlen	long
)	O
)	O
{	O
if	O
(	O
mu_cidr_format	(*(struct(int,int,array(char),array(char))),int,*(*(char)))->(int)
(	O
&	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
addr	int
,	O
MU_CIDR_FMT_ADDRONLY	int
,	O
ret	*(*(char))
)	O
)	O
return	O
MU_WRDSE_NOSPACE	O
;	O
return	O
MU_WRDSE_OK	O
;	O
}	O
else	O
if	O
(	O
SEQ	O
(	O
"family"	*(char)
,	O
name	*(char)
,	O
nlen	long
)	O
)	O
{	O
char	O
*	O
s	*(char)
;	O
switch	O
(	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
addr	int
.	O
family	int
)	O
{	O
case	O
AF_INET	O
:	O
s	*(char)
=	O
"AF_INET"	*(char)
;	O
break	O
;	O
case	O
AF_INET6	O
:	O
s	*(char)
=	O
"AF_INET6"	*(char)
;	O
break	O
;	O
case	O
AF_UNIX	O
:	O
s	*(char)
=	O
"AF_UNIX"	*(char)
;	O
break	O
;	O
default	O
:	O
return	O
MU_WRDSE_UNDEF	O
;	O
}	O
*	O
ret	*(*(char))
=	O
strdup	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
if	O
(	O
!	O
*	O
ret	*(*(char))
)	O
return	O
MU_WRDSE_NOSPACE	O
;	O
return	O
MU_WRDSE_OK	O
;	O
}	O
return	O
MU_WRDSE_UNDEF	O
;	O
}	O
static	O
int	O
expand_arg	(*(char),*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))),*(*(char)))->(int)
(	O
const	O
char	O
*	O
cmdline	*(char)
,	O
struct	O
run_closure	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
*	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
,	O
char	O
*	O
*	O
s	*(char)
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
int	O
envflag	int
=	O
0	int
;	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_TRACE	O
,	O
(	O
"Expanding \"%s\""	*(char)
,	O
cmdline	*(char)
)	O
)	O
;	O
if	O
(	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
env	*(*(char))
)	O
{	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_env	*(*(char))
=	O
(	O
const	O
char	O
*	O
*	O
)	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
env	*(*(char))
;	O
envflag	int
=	O
MU_WRDSF_ENV	O
;	O
}	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_getvar	*((*(*(char)),*(char),long,*(void))->(int))
=	O
acl_getvar	(*(*(char)),*(char),long,*(void))->(int)
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_closure	*(void)
=	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
;	O
rc	int
=	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
cmdline	*(char)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
MU_WRDSF_NOSPLIT	O
|	O
MU_WRDSF_NOCMD	O
|	O
envflag	int
|	O
MU_WRDSF_ENV_KV	O
|	O
MU_WRDSF_GETVAR	O
|	O
MU_WRDSF_CLOSURE	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
*	O
s	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
)	O
;	O
mu_wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
if	O
(	O
!	O
*	O
s	*(char)
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"failed: not enough memory."	*(char)
)	O
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_TRACE	O
,	O
(	O
"Expansion: \"%s\". "	*(char)
,	O
*	O
s	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"failed: %s"	*(char)
,	O
mu_wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
)	O
;	O
rc	int
=	O
errno	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
spawn_prog	(*(char),*(int),*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))))->(int)
(	O
const	O
char	O
*	O
cmdline	*(char)
,	O
int	O
*	O
pstatus	*(int)
,	O
struct	O
run_closure	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
*	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
)	O
{	O
char	O
*	O
s	*(char)
;	O
pid_t	int
pid	int
;	O
if	O
(	O
expand_arg	(*(char),*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))),*(*(char)))->(int)
(	O
cmdline	*(char)
,	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
,	O
&	O
s	*(char)
)	O
)	O
{	O
s	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
cmdline	*(char)
)	O
;	O
if	O
(	O
!	O
s	*(char)
)	O
return	O
ENOMEM	int
;	O
}	O
pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
int	O
i	long
;	O
struct	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
if	O
(	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
s	*(char)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
MU_WRDSF_DEFFLAGS	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot split line `%s': %s"	*(char)
)	O
,	O
s	*(char)
,	O
mu_wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
;	O
_exit	(int)->(void)
(	O
127	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
mu_getmaxfd	()->(int)
(	O
)	O
;	O
i	long
>	O
2	int
;	O
i	long
--	O
)	O
close	(int)->(int)
(	O
i	long
)	O
;	O
execvp	(*(char),array(*(char)))->(int)
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
,	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
)	O
;	O
_exit	(int)->(void)
(	O
127	int
)	O
;	O
}	O
free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
if	O
(	O
pid	int
==	O
(	O
pid_t	int
)	O
-	O
1	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"cannot fork: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
errno	O
;	O
}	O
if	O
(	O
pstatus	*(int)
)	O
{	O
int	O
status	int
;	O
waitpid	(int,*(int),int)->(int)
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
{	O
status	int
=	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_TRACE	O
,	O
(	O
"Program finished with code %d."	*(char)
,	O
status	int
)	O
)	O
;	O
*	O
pstatus	*(int)
=	O
status	int
;	O
}	O
else	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Program terminated on signal %d."	*(char)
,	O
WTERMSIG	O
(	O
status	int
)	O
)	O
)	O
;	O
return	O
MU_ERR_PROCESS_SIGNALED	O
;	O
}	O
else	O
return	O
MU_ERR_PROCESS_UNKNOWN_FAILURE	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
_run_entry	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
int	O
status	int
=	O
0	int
;	O
struct	O
_mu_acl_entry	struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char)))
*	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
=	O
item	*(void)
;	O
struct	O
run_closure	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
*	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
=	O
data	*(void)
;	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
idx	int
++	O
;	O
if	O
(	O
mu_debug_level_p	(int,int)->(int)
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_TRACE9	int
)	O
)	O
{	O
const	O
char	O
*	O
s	*(char)
=	O
"undefined"	*(char)
;	O
mu_acl_action_to_string	(enum(int,int,int,int,int),*(*(char)))->(int)
(	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
->	O
action	enum(int,int,int,int,int)
,	O
&	O
s	*(char)
)	O
;	O
mu_debug_log_begin	(*(char))->(void)
(	O
"%d:%s: "	*(char)
,	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
idx	int
,	O
s	*(char)
)	O
;	O
}	O
if	O
(	O
_acl_match	(*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char)))),*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))))->(int)
(	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
,	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
)	O
==	O
0	int
)	O
{	O
switch	O
(	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
->	O
action	enum(int,int,int,int,int)
)	O
{	O
case	O
mu_acl_accept	int
:	O
*	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
result	*(enum(int,int,int))
=	O
mu_acl_result_accept	int
;	O
status	int
=	O
MU_ERR_USER0	O
;	O
break	O
;	O
case	O
mu_acl_deny	int
:	O
*	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
result	*(enum(int,int,int))
=	O
mu_acl_result_deny	int
;	O
status	int
=	O
MU_ERR_USER0	O
;	O
break	O
;	O
case	O
mu_acl_log	int
:	O
{	O
char	O
*	O
s	*(char)
;	O
if	O
(	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
->	O
arg	*(char)
&&	O
expand_arg	(*(char),*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))),*(*(char)))->(int)
(	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
->	O
arg	*(char)
,	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
,	O
&	O
s	*(char)
)	O
==	O
0	int
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
"%s"	*(char)
,	O
s	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
addrstr	*(char)
)	O
mu_cidr_format	(*(struct(int,int,array(char),array(char))),int,*(*(char)))->(int)
(	O
&	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
addr	int
,	O
MU_CIDR_FMT_ADDRONLY	int
,	O
&	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
addrstr	*(char)
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
"%s"	*(char)
,	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
addrstr	*(char)
)	O
;	O
}	O
}	O
break	O
;	O
case	O
mu_acl_exec	int
:	O
spawn_prog	(*(char),*(int),*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))))->(int)
(	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
->	O
arg	*(char)
,	O
NULL	O
,	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
)	O
;	O
break	O
;	O
case	O
mu_acl_ifexec	int
:	O
{	O
int	O
prog_status	int
;	O
int	O
rc	int
=	O
spawn_prog	(*(char),*(int),*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))))->(int)
(	O
ent	*(struct(enum(int,int,int,int,int),*(void),struct(int,int,array(char),array(char))))
->	O
arg	*(char)
,	O
&	O
prog_status	int
,	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
switch	O
(	O
prog_status	int
)	O
{	O
case	O
0	int
:	O
*	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
result	*(enum(int,int,int))
=	O
mu_acl_result_accept	int
;	O
status	int
=	O
MU_ERR_USER0	O
;	O
break	O
;	O
case	O
1	int
:	O
*	O
rp	*(struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int))))
->	O
result	*(enum(int,int,int))
=	O
mu_acl_result_deny	int
;	O
status	int
=	O
MU_ERR_USER0	O
;	O
}	O
}	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
mu_debug_level_p	(int,int)->(int)
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_TRACE9	int
)	O
)	O
mu_stream_flush	(*(struct))->(int)
(	O
mu_strerr	*(struct)
)	O
;	O
return	O
status	int
;	O
}	O
int	O
mu_acl_check_sockaddr	(*(struct),*(struct(short,array(char))),int,*(enum(int,int,int)))->(int)
(	O
mu_acl_t	*(struct)
acl	*(*(struct))
,	O
const	O
struct	O
sockaddr	struct(short,array(char))
*	O
sa	*(struct(short,array(char)))
,	O
int	O
salen	int
,	O
mu_acl_result_t	enum(int,int,int)
*	O
pres	*(enum(int,int,int))
)	O
{	O
int	O
rc	int
;	O
struct	O
run_closure	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
r	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
;	O
if	O
(	O
!	O
acl	*(*(struct))
)	O
return	O
EINVAL	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
r	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
,	O
0	int
,	O
sizeof	O
(	O
r	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
)	O
)	O
;	O
if	O
(	O
sa	*(struct(short,array(char)))
->	O
sa_family	short
==	O
AF_UNIX	O
)	O
{	O
*	O
pres	*(enum(int,int,int))
=	O
mu_acl_result_accept	int
;	O
return	O
0	int
;	O
}	O
rc	int
=	O
mu_cidr_from_sockaddr	(*(struct(int,int,array(char),array(char))),*(struct(short,array(char))))->(int)
(	O
&	O
r	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
.	O
addr	int
,	O
sa	*(struct(short,array(char)))
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
mu_debug_level_p	(int,int)->(int)
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_TRACE9	int
)	O
)	O
{	O
mu_cidr_format	(*(struct(int,int,array(char),array(char))),int,*(*(char)))->(int)
(	O
&	O
r	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
.	O
addr	int
,	O
MU_CIDR_FMT_ADDRONLY	int
,	O
&	O
r	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
.	O
addrstr	*(char)
)	O
;	O
mu_debug_log_begin	(*(char))->(void)
(	O
"Checking sockaddr %s"	*(char)
,	O
r	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
.	O
addrstr	*(char)
)	O
;	O
mu_debug_log_nl	()->(void)
(	O
)	O
;	O
}	O
r	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
.	O
idx	int
=	O
0	int
;	O
r	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
.	O
result	*(enum(int,int,int))
=	O
pres	*(enum(int,int,int))
;	O
r	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
.	O
env	*(*(char))
=	O
acl	*(*(struct))
->	O
envv	*(*(char))
;	O
*	O
r	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
.	O
result	*(enum(int,int,int))
=	O
mu_acl_result_undefined	int
;	O
rc	int
=	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
acl	*(*(struct))
->	O
aclist	*(struct)
,	O
_run_entry	(*(void),*(void))->(int)
,	O
&	O
r	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
)	O
;	O
free	(*(void))->(void)
(	O
r	struct(int,struct(int,int,array(char),array(char)),*(*(char)),array(char),*(char),*(enum(int,int,int)))
.	O
addrstr	*(char)
)	O
;	O
if	O
(	O
rc	int
==	O
MU_ERR_USER0	O
)	O
rc	int
=	O
0	int
;	O
return	O
rc	int
;	O
}	O
int	O
mu_acl_check_inaddr	(*(struct),*(struct(int)),*(enum(int,int,int)))->(int)
(	O
mu_acl_t	*(struct)
acl	*(*(struct))
,	O
const	O
struct	O
in_addr	struct(int)
*	O
inp	*(struct(int))
,	O
mu_acl_result_t	enum(int,int,int)
*	O
pres	*(enum(int,int,int))
)	O
{	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
cs	short
;	O
int	O
len	long
=	O
sizeof	O
cs	short
;	O
cs	short
.	O
sin_family	short
=	O
AF_INET	O
;	O
cs	short
.	O
sin_addr	struct(int)
=	O
*	O
inp	*(struct(int))
;	O
cs	short
.	O
sin_addr	struct(int)
.	O
s_addr	int
=	O
ntohl	(int)->(int)
(	O
cs	short
.	O
sin_addr	struct(int)
.	O
s_addr	int
)	O
;	O
return	O
mu_acl_check_sockaddr	(*(struct),*(struct(short,array(char))),int,*(enum(int,int,int)))->(int)
(	O
acl	*(*(struct))
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
cs	short
,	O
len	long
,	O
pres	*(enum(int,int,int))
)	O
;	O
}	O
int	O
mu_acl_check_ipv4	(*(struct),int,*(enum(int,int,int)))->(int)
(	O
mu_acl_t	*(struct)
acl	*(*(struct))
,	O
unsigned	O
int	O
addr	int
,	O
mu_acl_result_t	enum(int,int,int)
*	O
pres	*(enum(int,int,int))
)	O
{	O
struct	O
in_addr	struct(int)
in	*(struct)
;	O
in	*(struct)
.	O
s_addr	int
=	O
addr	int
;	O
return	O
mu_acl_check_inaddr	(*(struct),*(struct(int)),*(enum(int,int,int)))->(int)
(	O
acl	*(*(struct))
,	O
&	O
in	*(struct)
,	O
pres	*(enum(int,int,int))
)	O
;	O
}	O
int	O
mu_acl_check_fd	(*(struct),int,*(enum(int,int,int)))->(int)
(	O
mu_acl_t	*(struct)
acl	*(*(struct))
,	O
int	O
fd	int
,	O
mu_acl_result_t	enum(int,int,int)
*	O
pres	*(enum(int,int,int))
)	O
{	O
union	O
{	O
struct	O
sockaddr	struct(short,array(char))
sa	*(struct(short,array(char)))
;	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
in	*(struct)
;	O
struct	O
sockaddr_in6	struct(short,short,int,struct(union(array(char),array(short),array(int))),int)
in6	struct(short,short,int,struct(union(array(char),array(short),array(int))),int)
;	O
}	O
addr	int
;	O
socklen_t	int
len	long
=	O
sizeof	O
addr	int
;	O
if	O
(	O
getpeername	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(int)
(	O
fd	int
,	O
&	O
addr	int
.	O
sa	*(struct(short,array(char)))
,	O
&	O
len	long
)	O
<	O
0	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Cannot obtain IP address of client: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
MU_ERR_FAILURE	O
;	O
}	O
return	O
mu_acl_check_sockaddr	(*(struct),*(struct(short,array(char))),int,*(enum(int,int,int)))->(int)
(	O
acl	*(*(struct))
,	O
&	O
addr	int
.	O
sa	*(struct(short,array(char)))
,	O
len	long
,	O
pres	*(enum(int,int,int))
)	O
;	O
}	O
static	O
int	O
_acl_getenv	(*(struct(*(struct),*(*(char)),long,long)),*(char),*(long))->(int)
(	O
mu_acl_t	*(struct)
acl	*(*(struct))
,	O
const	O
char	O
*	O
name	*(char)
,	O
size_t	long
*	O
pres	*(enum(int,int,int))
)	O
{	O
size_t	long
i	long
;	O
if	O
(	O
!	O
acl	*(*(struct))
->	O
envv	*(*(char))
)	O
return	O
MU_ERR_NOENT	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
acl	*(*(struct))
->	O
envc	long
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
acl	*(*(struct))
->	O
envv	*(*(char))
[	O
i	long
]	O
,	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
*	O
pres	*(enum(int,int,int))
=	O
i	long
;	O
return	O
0	int
;	O
}	O
return	O
MU_ERR_NOENT	O
;	O
}	O
const	O
char	O
*	O
mu_acl_getenv	(*(struct),*(char))->(*(char))
(	O
mu_acl_t	*(struct)
acl	*(*(struct))
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
size_t	long
i	long
;	O
if	O
(	O
_acl_getenv	(*(struct(*(struct),*(*(char)),long,long)),*(char),*(long))->(int)
(	O
acl	*(*(struct))
,	O
name	*(char)
,	O
&	O
i	long
)	O
==	O
0	int
)	O
{	O
return	O
acl	*(*(struct))
->	O
envv	*(*(char))
[	O
i	long
+	O
1	int
]	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
_acl_env_store	(*(struct(*(struct),*(*(char)),long,long)),int,*(char))->(int)
(	O
mu_acl_t	*(struct)
acl	*(*(struct))
,	O
int	O
i	long
,	O
const	O
char	O
*	O
val	array(int)
)	O
{	O
char	O
*	O
copy	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
val	array(int)
)	O
;	O
if	O
(	O
!	O
copy	*(char)
)	O
return	O
ENOMEM	int
;	O
free	(*(void))->(void)
(	O
acl	*(*(struct))
->	O
envv	*(*(char))
[	O
i	long
]	O
)	O
;	O
acl	*(*(struct))
->	O
envv	*(*(char))
[	O
i	long
]	O
=	O
copy	*(char)
;	O
return	O
0	int
;	O
}	O
int	O
mu_acl_setenv	(*(struct),*(char),*(char))->(int)
(	O
mu_acl_t	*(struct)
acl	*(*(struct))
,	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
val	array(int)
)	O
{	O
size_t	long
i	long
;	O
if	O
(	O
_acl_getenv	(*(struct(*(struct),*(*(char)),long,long)),*(char),*(long))->(int)
(	O
acl	*(*(struct))
,	O
name	*(char)
,	O
&	O
i	long
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
val	array(int)
)	O
{	O
free	(*(void))->(void)
(	O
acl	*(*(struct))
->	O
envv	*(*(char))
[	O
i	long
]	O
)	O
;	O
free	(*(void))->(void)
(	O
acl	*(*(struct))
->	O
envv	*(*(char))
[	O
i	long
+	O
1	int
]	O
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
acl	*(*(struct))
->	O
envv	*(*(char))
+	O
i	long
,	O
acl	*(*(struct))
->	O
envv	*(*(char))
+	O
i	long
+	O
3	int
,	O
(	O
acl	*(*(struct))
->	O
envn	long
+	O
1	int
-	O
(	O
i	long
+	O
3	int
)	O
)	O
*	O
sizeof	O
(	O
acl	*(*(struct))
->	O
envv	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
acl	*(*(struct))
->	O
envn	long
-=	O
2	int
;	O
return	O
0	int
;	O
}	O
return	O
_acl_env_store	(*(struct(*(struct),*(*(char)),long,long)),int,*(char))->(int)
(	O
acl	*(*(struct))
,	O
i	long
+	O
1	int
,	O
val	array(int)
)	O
;	O
}	O
if	O
(	O
!	O
acl	*(*(struct))
->	O
envv	*(*(char))
||	O
acl	*(*(struct))
->	O
envn	long
+	O
1	int
==	O
acl	*(*(struct))
->	O
envc	long
)	O
{	O
char	O
*	O
*	O
p	*(char)
;	O
if	O
(	O
!	O
val	array(int)
)	O
return	O
0	int
;	O
if	O
(	O
acl	*(*(struct))
->	O
envv	*(*(char))
==	O
NULL	O
)	O
p	*(char)
=	O
calloc	(long,long)->(*(void))
(	O
3	int
,	O
sizeof	O
(	O
acl	*(*(struct))
->	O
envv	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
else	O
{	O
p	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
acl	*(*(struct))
->	O
envv	*(*(char))
,	O
(	O
acl	*(*(struct))
->	O
envc	long
+	O
3	int
)	O
*	O
sizeof	O
(	O
acl	*(*(struct))
->	O
envv	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
return	O
ENOMEM	int
;	O
p	*(char)
[	O
acl	*(*(struct))
->	O
envc	long
]	O
=	O
NULL	O
;	O
}	O
acl	*(*(struct))
->	O
envv	*(*(char))
=	O
p	*(char)
;	O
acl	*(*(struct))
->	O
envc	long
+=	O
3	int
;	O
}	O
if	O
(	O
_acl_env_store	(*(struct(*(struct),*(*(char)),long,long)),int,*(char))->(int)
(	O
acl	*(*(struct))
,	O
acl	*(*(struct))
->	O
envn	long
,	O
name	*(char)
)	O
)	O
return	O
ENOMEM	int
;	O
if	O
(	O
_acl_env_store	(*(struct(*(struct),*(*(char)),long,long)),int,*(char))->(int)
(	O
acl	*(*(struct))
,	O
acl	*(*(struct))
->	O
envn	long
+	O
1	int
,	O
val	array(int)
)	O
)	O
{	O
free	(*(void))->(void)
(	O
acl	*(*(struct))
->	O
envv	*(*(char))
[	O
acl	*(*(struct))
->	O
envn	long
]	O
)	O
;	O
acl	*(*(struct))
->	O
envv	*(*(char))
[	O
acl	*(*(struct))
->	O
envn	long
]	O
=	O
NULL	O
;	O
return	O
ENOMEM	int
;	O
}	O
acl	*(*(struct))
->	O
envn	long
+=	O
2	int
;	O
return	O
0	int
;	O
}	O
