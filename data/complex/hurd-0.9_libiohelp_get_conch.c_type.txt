void	O
iohelp_get_conch	(*(struct(*(int),int,*(void),*(struct))))->(void)
(	O
struct	O
conch	struct(*(int),int,*(void),*(struct))
*	O
c	*(struct(*(int),int,*(void),*(struct)))
)	O
{	O
struct	O
shared_io	O
*	O
user_sh	*(struct)
;	O
again	O
:	O
user_sh	*(struct)
=	O
c	*(struct(*(int),int,*(void),*(struct)))
->	O
holder_shared_page	*(struct)
;	O
if	O
(	O
user_sh	*(struct)
)	O
{	O
pthread_spin_lock	()->(int)
(	O
&	O
user_sh	*(struct)
->	O
lock	*(int)
)	O
;	O
switch	O
(	O
user_sh	*(struct)
->	O
conch_status	O
)	O
{	O
case	O
USER_HAS_CONCH	O
:	O
user_sh	*(struct)
->	O
conch_status	O
=	O
USER_RELEASE_CONCH	O
;	O
case	O
USER_RELEASE_CONCH	O
:	O
pthread_spin_unlock	()->(int)
(	O
&	O
user_sh	*(struct)
->	O
lock	*(int)
)	O
;	O
pthread_cond_wait	()->(int)
(	O
&	O
c	*(struct(*(int),int,*(void),*(struct)))
->	O
wait	int
,	O
c	*(struct(*(int),int,*(void),*(struct)))
->	O
lock	*(int)
)	O
;	O
goto	O
again	O
;	O
case	O
USER_COULD_HAVE_CONCH	O
:	O
user_sh	*(struct)
->	O
conch_status	O
=	O
USER_HAS_NOT_CONCH	O
;	O
pthread_spin_unlock	()->(int)
(	O
&	O
user_sh	*(struct)
->	O
lock	*(int)
)	O
;	O
iohelp_fetch_shared_data	(*(void))->(void)
(	O
c	*(struct(*(int),int,*(void),*(struct)))
->	O
holder	*(void)
)	O
;	O
break	O
;	O
case	O
USER_HAS_NOT_CONCH	O
:	O
pthread_spin_unlock	()->(int)
(	O
&	O
user_sh	*(struct)
->	O
lock	*(int)
)	O
;	O
break	O
;	O
}	O
}	O
c	*(struct(*(int),int,*(void),*(struct)))
->	O
holder	*(void)
=	O
0	int
;	O
c	*(struct(*(int),int,*(void),*(struct)))
->	O
holder_shared_page	*(struct)
=	O
0	int
;	O
}	O
