static	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
prim_print	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
___P	O
(	O
(	O
char	O
*	O
prim_name	*(char)
,	O
List	struct(*(struct(*(struct(*`,*`)),*(void))),*(struct(*(struct(*`,*`)),*(void))))
*	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
,	O
Environment	struct(*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
*	O
env	*(struct(*(struct(*(struct`),*(char),*(struct`))),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`)))))
,	O
char	O
*	O
filename	*(char)
,	O
unsigned	O
int	O
linenum	int
)	O
)	O
;	O
static	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
match_arg	(*(char),int,*(*(struct(*(struct`),*(void)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
prim_name	*(char)
,	O
type	enum(int,int,int,int,int,int,int)
,	O
argp	*(*(struct(*(struct(*`,*`)),*(void))))
,	O
env	*(struct(*(struct(*(struct`),*(char),*(struct`))),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`)))))
,	O
filename	*(char)
,	O
linenum	int
)	O
char	O
*	O
prim_name	*(char)
;	O
NodeType	enum(int,int,int,int,int,int,int)
type	enum(int,int,int,int,int,int,int)
;	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
*	O
argp	*(*(struct(*(struct(*`,*`)),*(void))))
;	O
Environment	struct(*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
*	O
env	*(struct(*(struct(*(struct`),*(char),*(struct`))),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`)))))
;	O
char	O
*	O
filename	*(char)
;	O
unsigned	O
int	O
linenum	int
;	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
*	O
argp	*(*(struct(*(struct(*`,*`)),*(void))))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
n	long
;	O
NEED_ARG	O
(	O
)	O
;	O
n	long
=	O
eval_expr	(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct`),*(struct`),struct(*`,*`),struct(*`,*`),struct(*`,*`,*`),struct(*`,*`),struct(*`,*`,*`),struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
(	O
Expr	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`))),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*`,*`,struct`,struct`,struct`,struct`,struct`,struct`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(*`,*`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)))))
*	O
)	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
data	*(void)
,	O
env	*(struct(*(struct(*(struct`),*(char),*(struct`))),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`)))))
)	O
;	O
if	O
(	O
type	enum(int,int,int,int,int,int,int)
!=	O
nVOID	int
&&	O
n	long
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
type	enum(int,int,int,int,int,int,int)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: illegal argument type\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
*	O
argp	*(*(struct(*(struct(*`,*`)),*(void))))
=	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_call	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Expr	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`))),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*`,*`,struct`,struct`,struct`,struct`,struct`,struct`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(*`,*`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)))))
*	O
e	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)))))
;	O
char	O
*	O
cp	*(char)
;	O
e	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)))))
=	O
(	O
Expr	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`))),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*`,*`,struct`,struct`,struct`,struct`,struct`,struct`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(*`,*`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)))))
*	O
)	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
data	*(void)
;	O
if	O
(	O
e	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)))))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
eSYMBOL	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: illegal argument type\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
cp	*(char)
=	O
e	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
node	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
sym	*(char)
;	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
LAST_ARG	O
(	O
)	O
;	O
return	O
execute_state	(*(char))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
cp	*(char)
)	O
;	O
}	O
DEFUN	O
(	O
prim_calln	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
n	long
;	O
char	O
*	O
cp	*(char)
;	O
n	long
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
cp	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
cp	*(char)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
cp	*(char)
[	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
]	O
=	O
'\0'	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
n	long
)	O
;	O
n	long
=	O
execute_state	(*(char))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
cp	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
cp	*(char)
)	O
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_check_namerules	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Cons	struct(*(void),*(void))
*	O
c	*(struct(*(void),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
n	long
;	O
LAST_ARG	O
(	O
)	O
;	O
if	O
(	O
start_state	*(char)
)	O
goto	O
return_false	O
;	O
for	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
namerules	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
)	O
{	O
c	*(struct(*(void),*(void)))
=	O
(	O
Cons	struct(*(void),*(void))
*	O
)	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
data	*(void)
;	O
n	long
=	O
(	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
)	O
c	*(struct(*(void),*(void)))
->	O
car	*(void)
;	O
if	O
(	O
re_search	(*(struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int,int,int,*(struct(int,*(int),*(int))))->(int)
(	O
REGEXP	O
(	O
n	long
)	O
,	O
current_fname	*(char)
,	O
strlen	(*(char))->(long)
(	O
current_fname	*(char)
)	O
,	O
0	int
,	O
strlen	(*(char))->(long)
(	O
current_fname	*(char)
)	O
,	O
NULL	O
)	O
>=	O
0	int
)	O
{	O
n	long
=	O
(	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
)	O
c	*(struct(*(void),*(void)))
->	O
cdr	*(void)
;	O
start_state	*(char)
=	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
sym	*(char)
;	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
=	O
1	int
;	O
return	O
n	long
;	O
}	O
}	O
return_false	O
:	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
=	O
0	int
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_check_startrules	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Cons	struct(*(void),*(void))
*	O
c	*(struct(*(void),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
n	long
;	O
LAST_ARG	O
(	O
)	O
;	O
if	O
(	O
start_state	*(char)
)	O
goto	O
return_false	O
;	O
for	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
startrules	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
)	O
{	O
c	*(struct(*(void),*(void)))
=	O
(	O
Cons	struct(*(void),*(void))
*	O
)	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
data	*(void)
;	O
n	long
=	O
(	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
)	O
c	*(struct(*(void),*(void)))
->	O
car	*(void)
;	O
if	O
(	O
re_search	(*(struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int,int,int,*(struct(int,*(int),*(int))))->(int)
(	O
REGEXP	O
(	O
n	long
)	O
,	O
inbuf	*(char)
,	O
data_in_buffer	int
,	O
0	int
,	O
data_in_buffer	int
,	O
NULL	O
)	O
>=	O
0	int
)	O
{	O
n	long
=	O
(	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
)	O
c	*(struct(*(void),*(void)))
->	O
cdr	*(void)
;	O
start_state	*(char)
=	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
sym	*(char)
;	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
=	O
1	int
;	O
return	O
n	long
;	O
}	O
}	O
return_false	O
:	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
=	O
0	int
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_concat	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
n	long
;	O
int	O
len	int
=	O
0	int
;	O
char	O
*	O
data	*(void)
=	O
NULL	O
;	O
NEED_ARG	O
(	O
)	O
;	O
for	O
(	O
;	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
)	O
{	O
n	long
=	O
eval_expr	(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct`),*(struct`),struct(*`,*`),struct(*`,*`),struct(*`,*`,*`),struct(*`,*`),struct(*`,*`,*`),struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
(	O
Expr	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`))),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*`,*`,struct`,struct`,struct`,struct`,struct`,struct`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(*`,*`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)))))
*	O
)	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
data	*(void)
,	O
env	*(struct(*(struct(*(struct`),*(char),*(struct`))),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`)))))
)	O
;	O
if	O
(	O
n	long
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
nSTRING	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: illegal argument type\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
>	O
0	int
)	O
{	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
data	*(void)
,	O
len	int
+	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
data	*(void)
+	O
len	int
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
len	int
+=	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
;	O
}	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
n	long
)	O
;	O
}	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nSTRING	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
data	*(void)
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
len	int
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_float	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
n	long
,	O
*	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
char	O
buf	array(char)
[	O
512	int
]	O
;	O
n	long
=	O
MATCH_ARG	O
(	O
nVOID	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nREAL	int
)	O
;	O
switch	O
(	O
n	long
->	O
type	enum(int,int,int,int,int,int,int)
)	O
{	O
case	O
nVOID	int
:	O
case	O
nREGEXP	int
:	O
case	O
nSYMBOL	int
:	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
real	double
=	O
0.0	int
;	O
break	O
;	O
case	O
nARRAY	int
:	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
real	double
=	O
(	O
double	O
)	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
len	int
;	O
break	O
;	O
case	O
nSTRING	int
:	O
if	O
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
>	O
sizeof	O
(	O
buf	array(char)
)	O
-	O
1	int
)	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
real	double
=	O
0.0	int
;	O
else	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	array(char)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
buf	array(char)
[	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
]	O
=	O
'\0'	O
;	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
real	double
=	O
atof	(*(char))->(double)
(	O
buf	array(char)
)	O
;	O
}	O
break	O
;	O
case	O
nINTEGER	int
:	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
real	double
=	O
(	O
double	O
)	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
;	O
break	O
;	O
case	O
nREAL	int
:	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
real	double
=	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
real	double
;	O
break	O
;	O
}	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
n	long
)	O
;	O
return	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
}	O
DEFUN	O
(	O
prim_getenv	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
var	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
,	O
*	O
n	long
;	O
char	O
*	O
key	*(char)
;	O
char	O
*	O
cp	*(char)
;	O
var	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
key	*(char)
=	O
(	O
char	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
var	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
key	*(char)
,	O
var	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
var	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
cp	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
key	*(char)
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
var	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
xfree	(*(void))->(void)
(	O
key	*(char)
)	O
;	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nSTRING	int
)	O
;	O
if	O
(	O
cp	*(char)
==	O
NULL	O
)	O
{	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
1	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
0	int
;	O
}	O
else	O
{	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
xstrdup	(*(char))->(*(char))
(	O
cp	*(char)
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
strlen	(*(char))->(long)
(	O
cp	*(char)
)	O
;	O
}	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_int	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
n	long
,	O
*	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
char	O
buf	array(char)
[	O
512	int
]	O
;	O
n	long
=	O
MATCH_ARG	O
(	O
nVOID	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nINTEGER	int
)	O
;	O
switch	O
(	O
n	long
->	O
type	enum(int,int,int,int,int,int,int)
)	O
{	O
case	O
nVOID	int
:	O
case	O
nREGEXP	int
:	O
case	O
nSYMBOL	int
:	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
=	O
0	int
;	O
break	O
;	O
case	O
nARRAY	int
:	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
=	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
len	int
;	O
break	O
;	O
case	O
nSTRING	int
:	O
if	O
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
>	O
sizeof	O
(	O
buf	array(char)
)	O
-	O
1	int
)	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
=	O
0	int
;	O
else	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	array(char)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
buf	array(char)
[	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
]	O
=	O
'\0'	O
;	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
=	O
atoi	(*(char))->(int)
(	O
buf	array(char)
)	O
;	O
}	O
break	O
;	O
case	O
nINTEGER	int
:	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
=	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
;	O
break	O
;	O
case	O
nREAL	int
:	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
=	O
(	O
int	O
)	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
real	double
;	O
break	O
;	O
}	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
n	long
)	O
;	O
return	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
}	O
DEFUN	O
(	O
prim_length	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
n	long
;	O
int	O
result	int
=	O
0	int
;	O
NEED_ARG	O
(	O
)	O
;	O
for	O
(	O
;	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
)	O
{	O
n	long
=	O
eval_expr	(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct`),*(struct`),struct(*`,*`),struct(*`,*`),struct(*`,*`,*`),struct(*`,*`),struct(*`,*`,*`),struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
(	O
Expr	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`))),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*`,*`,struct`,struct`,struct`,struct`,struct`,struct`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(*`,*`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)))))
*	O
)	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
data	*(void)
,	O
env	*(struct(*(struct(*(struct`),*(char),*(struct`))),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`)))))
)	O
;	O
switch	O
(	O
n	long
->	O
type	enum(int,int,int,int,int,int,int)
)	O
{	O
case	O
nSTRING	int
:	O
result	int
+=	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
;	O
break	O
;	O
case	O
nARRAY	int
:	O
result	int
+=	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
len	int
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: illegal argument type\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
break	O
;	O
}	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
n	long
)	O
;	O
}	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
=	O
result	int
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_list	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
unsigned	O
int	O
len	int
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
n	long
;	O
for	O
(	O
len	int
=	O
0	int
;	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
len	int
++	O
,	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
)	O
;	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nARRAY	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
=	O
(	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
len	int
+	O
1	int
,	O
sizeof	O
(	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
)	O
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
allocated	long
=	O
len	int
+	O
1	int
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
len	int
=	O
len	int
;	O
for	O
(	O
len	int
=	O
0	int
;	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
len	int
++	O
,	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
)	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
[	O
len	int
]	O
=	O
eval_expr	(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct`),*(struct`),struct(*`,*`),struct(*`,*`),struct(*`,*`,*`),struct(*`,*`),struct(*`,*`,*`),struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
(	O
Expr	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`))),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*`,*`,struct`,struct`,struct`,struct`,struct`,struct`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(*`,*`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)))))
*	O
)	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
data	*(void)
,	O
env	*(struct(*(struct(*(struct`),*(char),*(struct`))),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`)))))
)	O
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_panic	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: panic: "	*(char)
)	O
,	O
program	*(char)
)	O
;	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
prim_print	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
prim_name	*(char)
,	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
,	O
env	*(struct(*(struct(*(struct`),*(char),*(struct`))),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`)))))
,	O
filename	*(char)
,	O
linenum	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
return	O
nvoid	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
}	O
DEFUN	O
(	O
prim_prereq	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
s	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
int	O
over	array(int)
[	O
3	int
]	O
;	O
int	O
rver	array(int)
[	O
3	int
]	O
;	O
char	O
*	O
cp	*(char)
;	O
int	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
s	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
sscanf	(*(char),*(char))->(int)
(	O
VERSION	*(char)
,	O
"%d.%d.%d"	*(char)
,	O
&	O
over	array(int)
[	O
0	int
]	O
,	O
&	O
over	array(int)
[	O
1	int
]	O
,	O
&	O
over	array(int)
[	O
2	int
]	O
)	O
;	O
cp	*(char)
=	O
(	O
char	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
s	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
cp	*(char)
,	O
s	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
s	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
cp	*(char)
,	O
"%d.%d.%d"	*(char)
,	O
&	O
rver	array(int)
[	O
0	int
]	O
,	O
&	O
rver	array(int)
[	O
1	int
]	O
,	O
&	O
rver	array(int)
[	O
2	int
]	O
)	O
!=	O
3	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: malformed version string `%s'\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
,	O
cp	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
0	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
<	O
3	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
++	O
)	O
{	O
if	O
(	O
over	array(int)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
>	O
rver	array(int)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
)	O
break	O
;	O
if	O
(	O
over	array(int)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
<	O
rver	array(int)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: FATAL ERROR: States version %s or higher is required for this script\n"	*(char)
)	O
,	O
program	*(char)
,	O
cp	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
xfree	(*(void))->(void)
(	O
cp	*(char)
)	O
;	O
return	O
nvoid	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
}	O
static	O
void	O
print_node	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
n	long
)	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
n	long
;	O
{	O
unsigned	O
int	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
switch	O
(	O
n	long
->	O
type	enum(int,int,int,int,int,int,int)
)	O
{	O
case	O
nVOID	int
:	O
break	O
;	O
case	O
nSTRING	int
:	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
,	O
1	int
,	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
nREGEXP	int
:	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'/'	O
,	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
.	O
data	*(void)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
.	O
len	int
,	O
1	int
,	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'/'	O
,	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
nINTEGER	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d"	*(char)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
)	O
;	O
break	O
;	O
case	O
nREAL	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%f"	*(char)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
real	double
)	O
;	O
break	O
;	O
case	O
nSYMBOL	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
sym	*(char)
)	O
;	O
break	O
;	O
case	O
nARRAY	int
:	O
for	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
0	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
<	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
len	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
++	O
)	O
{	O
print_node	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
)	O
;	O
if	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
+	O
1	int
<	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
len	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" "	*(char)
)	O
;	O
}	O
}	O
}	O
DEFUN	O
(	O
prim_print	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
n	long
;	O
NEED_ARG	O
(	O
)	O
;	O
for	O
(	O
;	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
)	O
{	O
n	long
=	O
eval_expr	(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct`),*(struct`),struct(*`,*`),struct(*`,*`),struct(*`,*`,*`),struct(*`,*`),struct(*`,*`,*`),struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
(	O
Expr	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`))),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*`,*`,struct`,struct`,struct`,struct`,struct`,struct`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(*`,*`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)))))
*	O
)	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
data	*(void)
,	O
env	*(struct(*(struct(*(struct`),*(char),*(struct`))),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`)))))
)	O
;	O
print_node	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
n	long
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
n	long
)	O
;	O
}	O
return	O
nvoid	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
}	O
DEFUN	O
(	O
prim_range	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
from	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
,	O
*	O
start	*(int)
,	O
*	O
end	*(int)
,	O
*	O
n	long
;	O
int	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
NEED_ARG	O
(	O
)	O
;	O
from	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
eval_expr	(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct`),*(struct`),struct(*`,*`),struct(*`,*`),struct(*`,*`,*`),struct(*`,*`),struct(*`,*`,*`),struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
(	O
Expr	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`))),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*`,*`,struct`,struct`,struct`,struct`,struct`,struct`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(*`,*`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)))))
*	O
)	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
data	*(void)
,	O
env	*(struct(*(struct(*(struct`),*(char),*(struct`))),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`)))))
)	O
;	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
start	*(int)
=	O
MATCH_ARG	O
(	O
nINTEGER	int
)	O
;	O
end	*(int)
=	O
MATCH_ARG	O
(	O
nINTEGER	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
if	O
(	O
start	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
>	O
end	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: start offset is bigger than end offset\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
from	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
type	enum(int,int,int,int,int,int,int)
==	O
nSTRING	int
)	O
{	O
if	O
(	O
end	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
>	O
from	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: offset out of range\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nSTRING	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
end	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
-	O
start	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
from	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
+	O
start	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
}	O
else	O
if	O
(	O
from	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
type	enum(int,int,int,int,int,int,int)
==	O
nARRAY	int
)	O
{	O
if	O
(	O
end	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
>	O
from	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
len	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: offset out of range\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nARRAY	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
len	int
=	O
end	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
-	O
start	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
allocated	long
=	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
len	int
+	O
1	int
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
=	O
(	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
allocated	long
,	O
sizeof	O
(	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
)	O
)	O
;	O
for	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
0	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
<	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
len	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
++	O
)	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
=	O
node_copy	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
from	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
+	O
start	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
]	O
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: illegal argument\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
from	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
start	*(int)
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
end	*(int)
)	O
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_regexp	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
str	struct(*(char),int)
,	O
*	O
n	long
;	O
str	struct(*(char),int)
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nREGEXP	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
.	O
data	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
+	O
1	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
.	O
len	int
=	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
.	O
data	*(void)
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
.	O
data	*(void)
[	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
]	O
=	O
'\0'	O
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_regexp_syntax	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
ch	char
,	O
*	O
st	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
char	O
syntax	long
;	O
ch	char
=	O
MATCH_ARG	O
(	O
nINTEGER	int
)	O
;	O
st	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
MATCH_ARG	O
(	O
nINTEGER	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
syntax	long
=	O
(	O
char	O
)	O
st	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
;	O
if	O
(	O
syntax	long
!=	O
'w'	O
&&	O
syntax	long
!=	O
' '	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: illegal regexp character syntax: %c\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
,	O
syntax	long
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
re_set_character_syntax	(char,char)->(void)
(	O
(	O
unsigned	O
char	O
)	O
ch	char
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
,	O
syntax	long
)	O
;	O
return	O
nvoid	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
}	O
DEFUN	O
(	O
prim_regmatch	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
str	struct(*(char),int)
,	O
*	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
,	O
*	O
n	long
;	O
static	O
struct	O
re_registers	struct(int,*(int),*(int))
matches	struct(int,*(int),*(int))
=	O
{	O
0	int
,	O
NULL	O
,	O
NULL	O
}	O
;	O
static	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
current_match_node	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
NULL	O
;	O
int	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
str	struct(*(char),int)
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
=	O
MATCH_ARG	O
(	O
nREGEXP	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
re_search	(*(struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int,int,int,*(struct(int,*(int),*(int))))->(int)
(	O
REGEXP	O
(	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
)	O
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
,	O
0	int
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
,	O
&	O
matches	struct(int,*(int),*(int))
)	O
;	O
if	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
<	O
0	int
)	O
{	O
current_match	*(struct(int,*(int),*(int)))
=	O
NULL	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
str	struct(*(char),int)
)	O
;	O
}	O
else	O
{	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
current_match_node	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
current_match_node	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
str	struct(*(char),int)
;	O
current_match	*(struct(int,*(int),*(int)))
=	O
&	O
matches	struct(int,*(int),*(int))
;	O
current_match_buf	*(char)
=	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
;	O
}	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
)	O
;	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
=	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
>=	O
0	int
)	O
;	O
return	O
n	long
;	O
}	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
do_regsubsts	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
str	struct(*(char),int)
,	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
,	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
,	O
allp	int
)	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
str	struct(*(char),int)
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
int	O
allp	int
;	O
{	O
int	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
,	O
pos	int
,	O
j	int
;	O
static	O
struct	O
re_registers	struct(int,*(int),*(int))
matches	struct(int,*(int),*(int))
=	O
{	O
0	int
,	O
NULL	O
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
result	int
=	O
NULL	O
;	O
static	O
unsigned	O
int	O
result_len	int
=	O
0	int
;	O
unsigned	O
int	O
result_pos	int
=	O
0	int
;	O
int	O
num_matches	int
=	O
0	int
;	O
int	O
do_expansions_in_substs	int
=	O
0	int
;	O
for	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
0	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
<	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
++	O
)	O
if	O
(	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
==	O
'$'	O
)	O
{	O
do_expansions_in_substs	int
=	O
1	int
;	O
break	O
;	O
}	O
pos	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
re_search	(*(struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int,int,int,*(struct(int,*(int),*(int))))->(int)
(	O
REGEXP	O
(	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
)	O
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
,	O
pos	int
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
-	O
pos	int
,	O
&	O
matches	struct(int,*(int),*(int))
)	O
;	O
if	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
<	O
0	int
)	O
goto	O
out	O
;	O
num_matches	int
++	O
;	O
APPEND	O
(	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
+	O
pos	int
,	O
matches	struct(int,*(int),*(int))
.	O
start	*(int)
[	O
0	int
]	O
-	O
pos	int
)	O
;	O
if	O
(	O
!	O
do_expansions_in_substs	int
)	O
APPEND	O
(	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
else	O
{	O
for	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
0	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
<	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
++	O
)	O
if	O
(	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
==	O
'$'	O
&&	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
+	O
1	int
<	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
{	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
++	O
;	O
switch	O
(	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
)	O
{	O
case	O
'$'	O
:	O
APPEND	O
(	O
"$"	*(char)
,	O
1	int
)	O
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
j	int
=	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
-	O
'0'	O
;	O
if	O
(	O
matches	struct(int,*(int),*(int))
.	O
start	*(int)
[	O
j	int
]	O
>=	O
0	int
)	O
APPEND	O
(	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
+	O
matches	struct(int,*(int),*(int))
.	O
start	*(int)
[	O
j	int
]	O
,	O
matches	struct(int,*(int),*(int))
.	O
end	*(int)
[	O
j	int
]	O
-	O
matches	struct(int,*(int),*(int))
.	O
start	*(int)
[	O
j	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
APPEND	O
(	O
"$"	*(char)
,	O
1	int
)	O
;	O
APPEND	O
(	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
+	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
,	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
APPEND	O
(	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
+	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
,	O
1	int
)	O
;	O
}	O
pos	int
=	O
matches	struct(int,*(int),*(int))
.	O
end	*(int)
[	O
0	int
]	O
;	O
if	O
(	O
!	O
allp	int
)	O
break	O
;	O
}	O
out	O
:	O
if	O
(	O
num_matches	int
==	O
0	int
)	O
{	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
return	O
str	struct(*(char),int)
;	O
}	O
APPEND	O
(	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
+	O
pos	int
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
-	O
pos	int
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
str	struct(*(char),int)
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
str	struct(*(char),int)
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nSTRING	int
)	O
;	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
result_pos	int
;	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
result_pos	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
result	int
,	O
result_pos	int
)	O
;	O
return	O
str	struct(*(char),int)
;	O
}	O
DEFUN	O
(	O
prim_regsub	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
str	struct(*(char),int)
,	O
*	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
,	O
*	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
str	struct(*(char),int)
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
=	O
MATCH_ARG	O
(	O
nREGEXP	int
)	O
;	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
return	O
do_regsubsts	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
str	struct(*(char),int)
,	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
,	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
,	O
0	int
)	O
;	O
}	O
DEFUN	O
(	O
prim_regsuball	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
str	struct(*(char),int)
,	O
*	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
,	O
*	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
str	struct(*(char),int)
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
=	O
MATCH_ARG	O
(	O
nREGEXP	int
)	O
;	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
return	O
do_regsubsts	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
str	struct(*(char),int)
,	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
,	O
subst	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
,	O
1	int
)	O
;	O
}	O
DEFUN	O
(	O
prim_require_state	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Expr	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`))),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*`,*`,struct`,struct`,struct`,struct`,struct`,struct`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(*`,*`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)))))
*	O
e	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)))))
;	O
char	O
*	O
cp	*(char)
;	O
State	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))))
*	O
state	*(int)
;	O
e	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)))))
=	O
(	O
Expr	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`))),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*`,*`,struct`,struct`,struct`,struct`,struct`,struct`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(*`,*`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)))))
*	O
)	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
data	*(void)
;	O
if	O
(	O
e	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)))))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
eSYMBOL	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: illegal argument type\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
cp	*(char)
=	O
e	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)),struct(*(struct`),*(struct`),*(struct`)),struct(*(struct`),*(struct`)))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
node	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
sym	*(char)
;	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
LAST_ARG	O
(	O
)	O
;	O
state	*(int)
=	O
lookup_state	(*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`,*`)),*(struct(*`,*`)))))
(	O
cp	*(char)
)	O
;	O
if	O
(	O
state	*(int)
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: couldn't define state `%s'\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
,	O
cp	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
return	O
nvoid	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
}	O
DEFUN	O
(	O
prim_split	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
,	O
*	O
str	struct(*(char),int)
,	O
*	O
n	long
,	O
*	O
n2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
int	O
pos	int
,	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
=	O
MATCH_ARG	O
(	O
nREGEXP	int
)	O
;	O
str	struct(*(char),int)
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nARRAY	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
allocated	long
=	O
100	int
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
=	O
(	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
allocated	long
,	O
sizeof	O
(	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
0	int
;	O
pos	int
<	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
;	O
)	O
{	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
re_search	(*(struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int,int,int,*(struct(int,*(int),*(int))))->(int)
(	O
REGEXP	O
(	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
)	O
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
,	O
pos	int
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
-	O
pos	int
,	O
&	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
.	O
matches	struct(int,*(int),*(int))
)	O
;	O
if	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
<	O
0	int
)	O
break	O
;	O
n2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nSTRING	int
)	O
;	O
n2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
-	O
pos	int
;	O
n2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
n2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
n2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
+	O
pos	int
,	O
n2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
pos	int
=	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
re	struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)))
.	O
matches	struct(int,*(int),*(int))
.	O
end	*(int)
[	O
0	int
]	O
;	O
if	O
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
len	int
+	O
1	int
>=	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
allocated	long
)	O
{	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
allocated	long
+=	O
100	int
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
=	O
(	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
allocated	long
*	O
sizeof	O
(	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
)	O
)	O
;	O
}	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
[	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
len	int
++	O
]	O
=	O
n2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
}	O
n2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nSTRING	int
)	O
;	O
n2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
-	O
pos	int
;	O
n2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
n2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
n2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
+	O
pos	int
,	O
n2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
[	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
array	*(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char))))
.	O
len	int
++	O
]	O
=	O
n2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_sprintf	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
fmt	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
,	O
*	O
n	long
;	O
char	O
buf	array(char)
[	O
512	int
]	O
;	O
char	O
ifmt	array(char)
[	O
256	int
]	O
;	O
char	O
ifmtopts	array(char)
[	O
256	int
]	O
;	O
char	O
*	O
result	int
=	O
NULL	O
;	O
unsigned	O
int	O
result_pos	int
=	O
0	int
;	O
unsigned	O
int	O
result_len	int
=	O
0	int
;	O
int	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
,	O
j	int
;	O
int	O
argument_count	int
=	O
0	int
;	O
char	O
*	O
cp	*(char)
;	O
fmt	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
cp	*(char)
=	O
fmt	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
;	O
for	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
0	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
<	O
fmt	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
++	O
)	O
{	O
if	O
(	O
cp	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
==	O
'%'	O
&&	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
+	O
1	int
>=	O
fmt	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
||	O
cp	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
+	O
1	int
]	O
==	O
'%'	O
)	O
)	O
{	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
++	O
;	O
APPEND	O
(	O
cp	*(char)
+	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
cp	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
==	O
'%'	O
)	O
{	O
argument_count	int
++	O
;	O
if	O
(	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: primitive `%s': too few arguments for format\n"	*(char)
)	O
,	O
program	*(char)
,	O
prim_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
n	long
=	O
eval_expr	(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct`),*(struct`),struct(*`,*`),struct(*`,*`),struct(*`,*`,*`),struct(*`,*`),struct(*`,*`,*`),struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
(	O
Expr	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`))),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(char),union(*`,*`,struct`,struct`,struct`,struct`,struct`,struct`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(*`,*`))),struct(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`))),struct(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,union`)))))
*	O
)	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
data	*(void)
,	O
env	*(struct(*(struct(*(struct`),*(char),*(struct`))),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`)))))
)	O
;	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
for	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
++	O
,	O
j	int
=	O
0	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
<	O
fmt	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
&&	O
FMTSPECIAL	O
(	O
cp	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
)	O
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
++	O
,	O
j	int
++	O
)	O
ifmtopts	array(char)
[	O
j	int
]	O
=	O
cp	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
;	O
ifmtopts	array(char)
[	O
j	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
>=	O
fmt	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
{	O
APPEND	O
(	O
"%"	*(char)
,	O
1	int
)	O
;	O
APPEND	O
(	O
ifmtopts	array(char)
,	O
j	int
)	O
;	O
continue	O
;	O
}	O
switch	O
(	O
cp	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
)	O
{	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
case	O
'd'	O
:	O
if	O
(	O
n	long
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
nINTEGER	int
)	O
{	O
no_match	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: argument %d doesn't match format\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
,	O
argument_count	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
ifmt	array(char)
,	O
"%%%s%c"	*(char)
,	O
ifmtopts	array(char)
,	O
cp	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
ifmt	array(char)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
)	O
;	O
APPEND	O
(	O
buf	array(char)
,	O
strlen	(*(char))->(long)
(	O
buf	array(char)
)	O
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
if	O
(	O
n	long
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
nINTEGER	int
)	O
goto	O
no_match	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
ifmt	array(char)
,	O
"%%%s%c"	*(char)
,	O
ifmtopts	array(char)
,	O
cp	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
ifmt	array(char)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
)	O
;	O
APPEND	O
(	O
buf	array(char)
,	O
strlen	(*(char))->(long)
(	O
buf	array(char)
)	O
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
case	O
'g'	O
:	O
case	O
'e'	O
:	O
case	O
'E'	O
:	O
if	O
(	O
n	long
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
nREAL	int
)	O
goto	O
no_match	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
ifmt	array(char)
,	O
"%%%s%c"	*(char)
,	O
ifmtopts	array(char)
,	O
cp	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
ifmt	array(char)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
real	double
)	O
;	O
APPEND	O
(	O
buf	array(char)
,	O
strlen	(*(char))->(long)
(	O
buf	array(char)
)	O
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
n	long
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
nSTRING	int
)	O
goto	O
no_match	O
;	O
if	O
(	O
ifmtopts	array(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: no extra options can be specified for %%s\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
APPEND	O
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: illegal type specifier `%c'\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
,	O
cp	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
APPEND	O
(	O
cp	*(char)
+	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
,	O
1	int
)	O
;	O
}	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
fmt	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nSTRING	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
result_pos	int
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
result	int
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_strcmp	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
s1	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
,	O
*	O
s2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
n	long
;	O
int	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
,	O
result	int
;	O
char	O
*	O
cp1	*(char)
,	O
*	O
cp2	*(char)
;	O
s1	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
s2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
cp1	*(char)
=	O
s1	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
;	O
cp2	*(char)
=	O
s2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
;	O
for	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
0	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
<	O
s1	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
&&	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
<	O
s2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
++	O
)	O
{	O
if	O
(	O
cp1	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
<	O
cp2	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
)	O
{	O
result	int
=	O
-	O
1	int
;	O
goto	O
out	O
;	O
}	O
if	O
(	O
cp1	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
>	O
cp2	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
)	O
{	O
result	int
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
}	O
if	O
(	O
s1	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
<	O
s2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
result	int
=	O
-	O
1	int
;	O
else	O
if	O
(	O
s1	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
>	O
s2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
result	int
=	O
1	int
;	O
else	O
result	int
=	O
0	int
;	O
out	O
:	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
s1	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
s2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
=	O
result	int
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_string	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
n	long
,	O
*	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
char	O
buf	array(char)
[	O
512	int
]	O
;	O
n	long
=	O
MATCH_ARG	O
(	O
nVOID	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nSTRING	int
)	O
;	O
switch	O
(	O
n	long
->	O
type	enum(int,int,int,int,int,int,int)
)	O
{	O
case	O
nVOID	int
:	O
case	O
nREGEXP	int
:	O
case	O
nARRAY	int
:	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
1	int
)	O
;	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
0	int
;	O
break	O
;	O
case	O
nSYMBOL	int
:	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
strlen	(*(char))->(long)
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
sym	*(char)
)	O
;	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
sym	*(char)
,	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
break	O
;	O
case	O
nSTRING	int
:	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
;	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
break	O
;	O
case	O
nINTEGER	int
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
"%d"	*(char)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
)	O
;	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
strlen	(*(char))->(long)
(	O
buf	array(char)
)	O
;	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
buf	array(char)
,	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
break	O
;	O
case	O
nREAL	int
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
"%f"	*(char)
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
real	double
)	O
;	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
strlen	(*(char))->(long)
(	O
buf	array(char)
)	O
;	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
buf	array(char)
,	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
break	O
;	O
}	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
n	long
)	O
;	O
return	O
r	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
;	O
}	O
DEFUN	O
(	O
prim_strncmp	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
s1	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
,	O
*	O
s2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
,	O
*	O
len	int
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
n	long
;	O
int	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
,	O
result	int
;	O
char	O
*	O
cp1	*(char)
,	O
*	O
cp2	*(char)
;	O
s1	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
s2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
len	int
=	O
MATCH_ARG	O
(	O
nINTEGER	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
cp1	*(char)
=	O
s1	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
;	O
cp2	*(char)
=	O
s2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
;	O
for	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
0	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
<	O
s1	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
&&	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
<	O
s2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
&&	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
<	O
len	int
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
++	O
)	O
{	O
if	O
(	O
cp1	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
<	O
cp2	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
)	O
{	O
result	int
=	O
-	O
1	int
;	O
goto	O
out	O
;	O
}	O
if	O
(	O
cp1	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
>	O
cp2	*(char)
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
)	O
{	O
result	int
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
}	O
if	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
>=	O
len	int
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
)	O
{	O
result	int
=	O
0	int
;	O
goto	O
out	O
;	O
}	O
if	O
(	O
s1	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
<	O
s2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
result	int
=	O
-	O
1	int
;	O
else	O
if	O
(	O
s1	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
>	O
s2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
result	int
=	O
1	int
;	O
else	O
result	int
=	O
0	int
;	O
out	O
:	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
s1	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
s2	*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),struct(int,*`,*`)),int,double,*(char),struct(*(*`),int,int))))
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
len	int
)	O
;	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
=	O
result	int
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_substring	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
str	struct(*(char),int)
,	O
*	O
start	*(int)
,	O
*	O
end	*(int)
,	O
*	O
n	long
;	O
str	struct(*(char),int)
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
start	*(int)
=	O
MATCH_ARG	O
(	O
nINTEGER	int
)	O
;	O
end	*(int)
=	O
MATCH_ARG	O
(	O
nINTEGER	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
if	O
(	O
start	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
>	O
end	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: start offset is bigger than end offset\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
end	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
>	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s: offset out of range\n"	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
,	O
prim_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nSTRING	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
=	O
end	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
-	O
start	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
+	O
start	*(int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
,	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
str	struct(*(char),int)
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
start	*(int)
)	O
;	O
node_free	(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))->(void)
(	O
end	*(int)
)	O
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_system	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
)	O
{	O
ListItem	struct(*(struct(*(struct(*`,*`)),*(void))),*(void))
*	O
arg	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
args	*(struct(*(struct(*(struct`),*(void))),*(struct(*(struct`),*(void)))))
->	O
head	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
Node	struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct`)),int,int)))
*	O
str	struct(*(char),int)
,	O
*	O
n	long
;	O
char	O
*	O
cmd	*(char)
;	O
int	O
result	int
;	O
str	struct(*(char),int)
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
cmd	*(char)
=	O
(	O
char	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
cmd	*(char)
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
data	*(void)
,	O
str	struct(*(char),int)
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
str	struct(*(char),int)
.	O
len	int
)	O
;	O
result	int
=	O
system	(*(char))->(int)
(	O
cmd	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
cmd	*(char)
)	O
;	O
n	long
=	O
node_alloc	(enum(int,int,int,int,int,int,int))->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union(struct(*(char),int),struct(*(char),int,int,struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int))),int,double,*(char),struct(*(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))),int,int))
.	O
integer	int
=	O
result	int
;	O
return	O
n	long
;	O
}	O
static	O
struct	O
{	O
char	O
*	O
name	*(char)
;	O
Primitive	*((*(char),*(struct(*(struct`),*(struct`))),*(struct(*(struct`),*(char),*(struct`))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`)))))
prim	*((*(char),*(struct(*(struct`),*(struct`))),*(struct(*(struct`),*(char),*(struct`))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`)))))
;	O
}	O
prims	array(struct(*(char),*((*(char),*(struct(*`,*`)),*(struct(*`,*`,*`)),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))))))
[	O
]	O
=	O
{	O
{	O
"call"	*(char)
,	O
prim_call	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"calln"	*(char)
,	O
prim_calln	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"check_namerules"	*(char)
,	O
prim_check_namerules	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"check_startrules"	*(char)
,	O
prim_check_startrules	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"concat"	*(char)
,	O
prim_concat	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"float"	*(char)
,	O
prim_float	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"getenv"	*(char)
,	O
prim_getenv	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"int"	*(char)
,	O
prim_int	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"length"	*(char)
,	O
prim_length	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"list"	*(char)
,	O
prim_list	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"panic"	*(char)
,	O
prim_panic	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"prereq"	*(char)
,	O
prim_prereq	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"print"	*(char)
,	O
prim_print	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"range"	*(char)
,	O
prim_range	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"regexp"	*(char)
,	O
prim_regexp	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"regexp_syntax"	*(char)
,	O
prim_regexp_syntax	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"regmatch"	*(char)
,	O
prim_regmatch	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"regsub"	*(char)
,	O
prim_regsub	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"regsuball"	*(char)
,	O
prim_regsuball	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"require_state"	*(char)
,	O
prim_require_state	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"split"	*(char)
,	O
prim_split	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"sprintf"	*(char)
,	O
prim_sprintf	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"strcmp"	*(char)
,	O
prim_strcmp	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"string"	*(char)
,	O
prim_string	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"strncmp"	*(char)
,	O
prim_strncmp	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"substring"	*(char)
,	O
prim_substring	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
"system"	*(char)
,	O
prim_system	(*(char),*(struct(*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`,*`)),*(char),*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`)))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct(*`,int),struct(*`,int,int,struct`,struct`),int,double,*(char),struct(*`,int,int)))))
}	O
,	O
{	O
NULL	O
,	O
NULL	O
}	O
,	O
}	O
;	O
void	O
init_primitives	()->(void)
(	O
)	O
{	O
void	O
*	O
old	*(void)
;	O
int	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
;	O
for	O
(	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
0	int
;	O
prims	array(struct(*(char),*((*(char),*(struct(*`,*`)),*(struct(*`,*`,*`)),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))))))
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
.	O
name	*(char)
;	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
++	O
)	O
if	O
(	O
!	O
strhash_put	(*(struct),*(char),int,*(void),*(*(void)))->(int)
(	O
ns_prims	*(struct)
,	O
prims	array(struct(*(char),*((*(char),*(struct(*`,*`)),*(struct(*`,*`,*`)),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))))))
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
.	O
name	*(char)
,	O
strlen	(*(char))->(long)
(	O
prims	array(struct(*(char),*((*(char),*(struct(*`,*`)),*(struct(*`,*`,*`)),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))))))
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
.	O
name	*(char)
)	O
,	O
(	O
void	O
*	O
)	O
prims	array(struct(*(char),*((*(char),*(struct(*`,*`)),*(struct(*`,*`,*`)),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*`,union`))))))
[	O
i	*(struct(*(struct(*(struct`),*(void))),*(void)))
]	O
.	O
prim	*((*(char),*(struct(*(struct`),*(struct`))),*(struct(*(struct`),*(char),*(struct`))),*(char),int)->(*(struct(enum(int,int,int,int,int,int,int),int,int,*(char),union(struct`,struct`,int,double,*`,struct`)))))
,	O
&	O
old	*(void)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: out of memory\n"	*(char)
)	O
,	O
program	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
