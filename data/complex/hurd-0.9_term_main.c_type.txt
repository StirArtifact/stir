const	O
char	O
*	O
argp_program_version	*(char)
=	O
STANDARD_HURD_VERSION	()->(int)
(	O
term	O
)	O
;	O
int	O
trivfs_fstype	int
=	O
FSTYPE_TERM	O
;	O
int	O
trivfs_fsid	int
=	O
0	int
;	O
int	O
trivfs_support_read	int
=	O
1	int
;	O
int	O
trivfs_support_write	int
=	O
1	int
;	O
int	O
trivfs_support_exec	int
=	O
0	int
;	O
int	O
trivfs_allow_open	int
=	O
O_READ	O
|	O
O_WRITE	O
;	O
enum	O
tty_type	enum(int,int,int,int,int)
{	O
T_NONE	int
=	O
0	int
,	O
T_DEVICE	int
,	O
T_HURDIO	int
,	O
T_PTYMASTER	int
,	O
T_PTYSLAVE	int
}	O
;	O
static	O
const	O
char	O
*	O
const	O
tty_type_names	array(*(char))
[	O
]	O
=	O
{	O
[	O
T_DEVICE	int
]	O
=	O
"device"	*(char)
,	O
[	O
T_HURDIO	int
]	O
=	O
"hurdio"	*(char)
,	O
[	O
T_PTYMASTER	int
]	O
=	O
"pty-master"	*(char)
,	O
[	O
T_PTYSLAVE	int
]	O
=	O
"pty-slave"	*(char)
,	O
}	O
;	O
char	O
*	O
tty_name	*(char)
;	O
enum	O
tty_type	enum(int,int,int,int,int)
tty_type	enum(int,int,int,int,int)
;	O
char	O
*	O
tty_arg	*(char)
;	O
dev_t	long
rdev	long
;	O
int	O
demuxer	(*(int),*(int))->(int)
(	O
mach_msg_header_t	O
*	O
inp	*(int)
,	O
mach_msg_header_t	O
*	O
outp	*(int)
)	O
{	O
mig_routine_t	O
routine	O
;	O
if	O
(	O
(	O
routine	O
=	O
NULL	O
,	O
trivfs_demuxer	()->(int)
(	O
inp	*(int)
,	O
outp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
term_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
tioctl_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
device_reply_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
)	O
{	O
if	O
(	O
routine	O
)	O
(	O
*	O
routine	O
)	O
(	O
inp	*(int)
,	O
outp	*(int)
)	O
;	O
return	O
TRUE	O
;	O
}	O
else	O
return	O
FALSE	O
;	O
}	O
static	O
struct	O
argp_option	O
options	int
[	O
]	O
=	O
{	O
{	O
"rdev"	*(char)
,	O
'n'	O
,	O
"ID"	*(char)
,	O
0	int
,	O
"The stat rdev number for this node; may be either a"	*(char)
" single integer, or of the form MAJOR,MINOR"	*(char)
}	O
,	O
{	O
"name"	*(char)
,	O
'N'	O
,	O
"NAME"	*(char)
,	O
0	int
,	O
"The name of this node, to be returned by term_get_nodename."	*(char)
}	O
,	O
{	O
"type"	*(char)
,	O
'T'	O
,	O
"TYPE"	*(char)
,	O
0	int
,	O
"Backend type, see below.  This determines the meaning of the argument."	*(char)
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
error_t	int
parse_opt	(int,*(char),*(struct))->(int)
(	O
int	O
opt	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	O
*	O
state	*(struct)
)	O
{	O
struct	O
{	O
dev_t	long
rdev	long
;	O
int	O
rdev_set	int
;	O
enum	O
tty_type	enum(int,int,int,int,int)
type	enum(int,int,int,int)
;	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
arg	*(char)
;	O
}	O
*	O
const	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
=	O
state	*(struct)
->	O
hook	O
;	O
switch	O
(	O
opt	int
)	O
{	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
case	O
ARGP_KEY_INIT	O
:	O
state	*(struct)
->	O
hook	O
=	O
calloc	O
(	O
1	int
,	O
sizeof	O
*	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
)	O
;	O
break	O
;	O
case	O
ARGP_KEY_FINI	O
:	O
free	()->(int)
(	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
)	O
;	O
state	*(struct)
->	O
hook	O
=	O
0	int
;	O
break	O
;	O
case	O
'n'	O
:	O
{	O
char	O
*	O
start	*(char)
=	O
arg	*(char)
;	O
char	O
*	O
end	*(char)
;	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
rdev	long
=	O
strtoumax	()->(int)
(	O
start	*(char)
,	O
&	O
end	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
end	*(char)
==	O
','	O
)	O
{	O
start	*(char)
=	O
end	*(char)
;	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
rdev	long
=	O
(	O
rdev	long
<<	O
8	int
)	O
+	O
strtoul	O
(	O
start	*(char)
,	O
&	O
end	*(char)
,	O
0	int
)	O
;	O
}	O
if	O
(	O
end	*(char)
==	O
start	*(char)
||	O
*	O
end	*(char)
!=	O
'\0'	O
)	O
{	O
argp_error	()->(int)
(	O
state	*(struct)
,	O
"%s: Invalid argument to --rdev"	*(char)
,	O
arg	*(char)
)	O
;	O
return	O
EINVAL	int
;	O
}	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
rdev_set	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
'N'	O
:	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
name	*(char)
=	O
arg	*(char)
;	O
break	O
;	O
case	O
ARGP_KEY_ARG	O
:	O
if	O
(	O
!	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
name	*(char)
&&	O
state	*(struct)
->	O
input	O
==	O
0	int
)	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
name	*(char)
=	O
arg	*(char)
;	O
else	O
if	O
(	O
!	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
type	enum(int,int,int,int)
&&	O
state	*(struct)
->	O
input	O
==	O
0	int
)	O
{	O
case	O
'T'	O
:	O
if	O
(	O
!	O
strcmp	O
(	O
arg	*(char)
,	O
"device"	*(char)
)	O
)	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
type	enum(int,int,int,int)
=	O
T_DEVICE	int
;	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
arg	*(char)
,	O
"hurdio"	*(char)
)	O
)	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
type	enum(int,int,int,int)
=	O
T_HURDIO	int
;	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
arg	*(char)
,	O
"pty-master"	*(char)
)	O
)	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
type	enum(int,int,int,int)
=	O
T_PTYMASTER	int
;	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
arg	*(char)
,	O
"pty-slave"	*(char)
)	O
)	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
type	enum(int,int,int,int)
=	O
T_PTYSLAVE	int
;	O
else	O
{	O
argp_error	()->(int)
(	O
state	*(struct)
,	O
"Invalid terminal type"	*(char)
)	O
;	O
return	O
EINVAL	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
arg	*(char)
)	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
arg	*(char)
=	O
arg	*(char)
;	O
else	O
{	O
argp_error	()->(int)
(	O
state	*(struct)
,	O
"Too many arguments"	*(char)
)	O
;	O
return	O
EINVAL	int
;	O
}	O
break	O
;	O
case	O
ARGP_KEY_END	O
:	O
if	O
(	O
(	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
type	enum(int,int,int,int)
&&	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
type	enum(int,int,int,int)
!=	O
T_HURDIO	int
&&	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
arg	*(char)
==	O
0	int
)	O
||	O
(	O
state	*(struct)
->	O
input	O
==	O
0	int
&&	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
name	*(char)
==	O
0	int
)	O
)	O
{	O
argp_error	()->(int)
(	O
state	*(struct)
,	O
"Too few arguments"	*(char)
)	O
;	O
return	O
EINVAL	int
;	O
}	O
break	O
;	O
case	O
ARGP_KEY_SUCCESS	O
:	O
if	O
(	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
rdev_set	int
)	O
rdev	long
=	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
rdev	long
;	O
if	O
(	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
name	*(char)
)	O
{	O
free	()->(int)
(	O
tty_name	*(char)
)	O
;	O
tty_name	*(char)
=	O
strdup	O
(	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
name	*(char)
)	O
;	O
}	O
if	O
(	O
state	*(struct)
->	O
input	O
==	O
0	int
)	O
{	O
tty_type	enum(int,int,int,int,int)
=	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
type	enum(int,int,int,int)
?	O
:	O
T_HURDIO	int
;	O
tty_arg	*(char)
=	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
arg	*(char)
?	O
strdup	O
(	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
arg	*(char)
)	O
:	O
0	int
;	O
}	O
else	O
if	O
(	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
type	enum(int,int,int,int)
||	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
arg	*(char)
)	O
{	O
if	O
(	O
!	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
type	enum(int,int,int,int)
)	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
type	enum(int,int,int,int)
=	O
T_HURDIO	int
;	O
switch	O
(	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
T_PTYMASTER	int
:	O
case	O
T_PTYSLAVE	int
:	O
return	O
EINVAL	int
;	O
default	O
:	O
break	O
;	O
}	O
switch	O
(	O
tty_type	enum(int,int,int,int,int)
)	O
{	O
case	O
T_PTYMASTER	int
:	O
case	O
T_PTYSLAVE	int
:	O
return	O
EINVAL	int
;	O
default	O
:	O
break	O
;	O
}	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
fini	*(()->(int))
)	O
(	O
)	O
;	O
tty_type	enum(int,int,int,int,int)
=	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
type	enum(int,int,int,int)
;	O
switch	O
(	O
tty_type	enum(int,int,int,int,int)
)	O
{	O
case	O
T_DEVICE	int
:	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
=	O
&	O
devio_bottom	struct(enum,*(()->(int)),*(()->(int)),*((*(struct))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct))->(int)),*((int,int)->(int)),*((*(int))->(int)))
;	O
break	O
;	O
case	O
T_HURDIO	int
:	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
=	O
&	O
hurdio_bottom	struct(enum,*(()->(int)),*(()->(int)),*((*(struct))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct))->(int)),*((int,int)->(int)),*((*(int))->(int)))
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
!	O
"impossible type"	*(char)
)	O
;	O
break	O
;	O
}	O
free	()->(int)
(	O
tty_arg	*(char)
)	O
;	O
tty_arg	*(char)
=	O
strdup	O
(	O
v	*(struct(long,int,enum(int,int,int,int,int),*(char),*(char)))
->	O
arg	*(char)
)	O
;	O
error_t	int
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
init	*(()->(int))
)	O
(	O
)	O
;	O
if	O
(	O
err	int
==	O
0	int
&&	O
(	O
termflags	long
&	O
TTY_OPEN	int
)	O
)	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
assert_dtr	*(()->(int))
)	O
(	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
err	int
;	O
}	O
break	O
;	O
case	O
ARGP_KEY_ERROR	O
:	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	O
term_argp	struct
=	O
{	O
options	int
,	O
parse_opt	(int,*(char),*(struct))->(int)
,	O
"NAME TYPE ARG"	*(char)
,	O
"A translator that implements POSIX termios discipline.\v"	*(char)
"Possible values for TYPE:\n"	*(char)
"  device      Use Mach device ARG for underlying i/o.\n"	*(char)
"  hurdio      Use file ARG for i/o, underlying node if no ARG.\n"	*(char)
"  pty-master  Master for slave at ARG.\n"	*(char)
"  pty-slave   Slave for master at ARG.\n"	*(char)
"\n"	*(char)
"The default type is `hurdio', so no arguments uses the underlying node.\n"	*(char)
"The filename of the node that the translator is attached to should be\n"	*(char)
"supplied in NAME.\n"	*(char)
}	O
;	O
struct	O
argp	O
*	O
trivfs_runtime_argp	*(struct)
=	O
&	O
term_argp	struct
;	O
error_t	int
trivfs_append_args	(*(struct),*(*(char)),*(long))->(int)
(	O
struct	O
trivfs_control	O
*	O
fsys	*(struct)
,	O
char	O
*	O
*	O
argz	*(*(char))
,	O
size_t	long
*	O
argz_len	*(long)
)	O
{	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
rdev	long
)	O
{	O
char	O
buf	array(char)
[	O
64	int
]	O
;	O
snprintf	O
(	O
buf	array(char)
,	O
sizeof	O
buf	array(char)
,	O
"--rdev=%#jx"	*(char)
,	O
(	O
uintmax_t	O
)	O
rdev	long
)	O
;	O
err	int
=	O
argz_add	()->(int)
(	O
argz	*(*(char))
,	O
argz_len	*(long)
,	O
buf	array(char)
)	O
;	O
}	O
if	O
(	O
!	O
err	int
&&	O
tty_name	*(char)
)	O
err	int
=	O
argz_add	()->(int)
(	O
argz	*(*(char))
,	O
argz_len	*(long)
,	O
"--name"	*(char)
)	O
?	O
:	O
argz_add	()->(int)
(	O
argz	*(*(char))
,	O
argz_len	*(long)
,	O
tty_name	*(char)
)	O
;	O
if	O
(	O
!	O
err	int
&&	O
tty_type	enum(int,int,int,int,int)
!=	O
T_HURDIO	int
)	O
err	int
=	O
argz_add	()->(int)
(	O
argz	*(*(char))
,	O
argz_len	*(long)
,	O
"--type"	*(char)
)	O
?	O
:	O
argz_add	()->(int)
(	O
argz	*(*(char))
,	O
argz_len	*(long)
,	O
tty_type_names	array(*(char))
[	O
tty_type	enum(int,int,int,int,int)
]	O
)	O
;	O
if	O
(	O
!	O
err	int
&&	O
tty_arg	*(char)
)	O
err	int
=	O
argz_add	()->(int)
(	O
argz	*(*(char))
,	O
argz_len	*(long)
,	O
tty_arg	*(char)
)	O
;	O
return	O
err	int
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
struct	O
port_class	O
*	O
ourclass	*(struct)
,	O
*	O
ourcntlclass	*(struct)
;	O
struct	O
port_class	O
*	O
peerclass	*(struct)
,	O
*	O
peercntlclass	*(struct)
;	O
struct	O
trivfs_control	O
*	O
*	O
ourcntl	*(*(struct))
,	O
*	O
*	O
peercntl	*(*(struct))
;	O
mach_port_t	int
bootstrap	O
,	O
right	O
;	O
struct	O
stat	O
st	struct
;	O
error_t	int
err	int
;	O
int	O
openmode	int
;	O
term_bucket	*(struct)
=	O
ports_create_bucket	()->(int)
(	O
)	O
;	O
trivfs_add_control_port_class	()->(int)
(	O
&	O
tty_cntl_class	*(struct)
)	O
;	O
trivfs_add_control_port_class	()->(int)
(	O
&	O
pty_cntl_class	*(struct)
)	O
;	O
trivfs_add_protid_port_class	()->(int)
(	O
&	O
tty_class	*(struct)
)	O
;	O
trivfs_add_protid_port_class	()->(int)
(	O
&	O
pty_class	*(struct)
)	O
;	O
cttyid_class	*(struct)
=	O
ports_create_class	()->(int)
(	O
0	int
,	O
0	int
)	O
;	O
init_users	()->(void)
(	O
)	O
;	O
argp_parse	()->(int)
(	O
&	O
term_argp	struct
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
switch	O
(	O
tty_type	enum(int,int,int,int,int)
)	O
{	O
case	O
T_DEVICE	int
:	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
=	O
&	O
devio_bottom	struct(enum,*(()->(int)),*(()->(int)),*((*(struct))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct))->(int)),*((int,int)->(int)),*((*(int))->(int)))
;	O
ourclass	*(struct)
=	O
tty_class	*(struct)
;	O
ourcntlclass	*(struct)
=	O
tty_cntl_class	*(struct)
;	O
ourcntl	*(*(struct))
=	O
&	O
termctl	*(struct)
;	O
peerclass	*(struct)
=	O
0	int
;	O
peercntlclass	*(struct)
=	O
0	int
;	O
peercntl	*(*(struct))
=	O
0	int
;	O
openmode	int
=	O
0	int
;	O
break	O
;	O
case	O
T_HURDIO	int
:	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
=	O
&	O
hurdio_bottom	struct(enum,*(()->(int)),*(()->(int)),*((*(struct))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct))->(int)),*((int,int)->(int)),*((*(int))->(int)))
;	O
ourclass	*(struct)
=	O
tty_class	*(struct)
;	O
ourcntlclass	*(struct)
=	O
tty_cntl_class	*(struct)
;	O
ourcntl	*(*(struct))
=	O
&	O
termctl	*(struct)
;	O
peerclass	*(struct)
=	O
0	int
;	O
peercntlclass	*(struct)
=	O
0	int
;	O
peercntl	*(*(struct))
=	O
0	int
;	O
openmode	int
=	O
O_RDWR	int
;	O
break	O
;	O
case	O
T_PTYMASTER	int
:	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
=	O
&	O
ptyio_bottom	struct(enum,*(()->(int)),*(()->(int)),*((*(struct))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct))->(int)),*((int,int)->(int)),*((*(int))->(int)))
;	O
ourclass	*(struct)
=	O
pty_class	*(struct)
;	O
ourcntlclass	*(struct)
=	O
pty_cntl_class	*(struct)
;	O
ourcntl	*(*(struct))
=	O
&	O
ptyctl	*(struct)
;	O
peerclass	*(struct)
=	O
tty_class	*(struct)
;	O
peercntlclass	*(struct)
=	O
tty_cntl_class	*(struct)
;	O
peercntl	*(*(struct))
=	O
&	O
termctl	*(struct)
;	O
openmode	int
=	O
0	int
;	O
break	O
;	O
case	O
T_PTYSLAVE	int
:	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
=	O
&	O
ptyio_bottom	struct(enum,*(()->(int)),*(()->(int)),*((*(struct))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct))->(int)),*((int,int)->(int)),*((*(int))->(int)))
;	O
ourclass	*(struct)
=	O
tty_class	*(struct)
;	O
ourcntlclass	*(struct)
=	O
tty_cntl_class	*(struct)
;	O
ourcntl	*(*(struct))
=	O
&	O
termctl	*(struct)
;	O
peerclass	*(struct)
=	O
pty_class	*(struct)
;	O
peercntlclass	*(struct)
=	O
pty_cntl_class	*(struct)
;	O
peercntl	*(*(struct))
=	O
&	O
ptyctl	*(struct)
;	O
openmode	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
error	()->(int)
(	O
1	int
,	O
0	int
,	O
"Unknown terminal type"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
task_get_bootstrap_port	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
&	O
bootstrap	O
)	O
;	O
if	O
(	O
bootstrap	O
==	O
MACH_PORT_NULL	O
)	O
error	()->(int)
(	O
1	int
,	O
0	int
,	O
"Must be started as a translator"	*(char)
)	O
;	O
err	int
=	O
trivfs_startup	()->(int)
(	O
bootstrap	O
,	O
openmode	int
,	O
ourcntlclass	*(struct)
,	O
term_bucket	*(struct)
,	O
ourclass	*(struct)
,	O
term_bucket	*(struct)
,	O
ourcntl	*(*(struct))
)	O
;	O
if	O
(	O
err	int
)	O
error	()->(int)
(	O
1	int
,	O
err	int
,	O
"Starting translator"	*(char)
)	O
;	O
(	O
*	O
ourcntl	*(*(struct))
)	O
->	O
hook	O
=	O
tty_name	*(char)
;	O
if	O
(	O
peerclass	*(struct)
)	O
{	O
char	O
*	O
peer_name	*(char)
=	O
tty_arg	*(char)
;	O
file_t	O
file	O
=	O
file_name_lookup	O
(	O
peer_name	*(char)
,	O
O_CREAT	int
|	O
O_NOTRANS	O
,	O
0666	int
)	O
;	O
if	O
(	O
file	O
==	O
MACH_PORT_NULL	O
)	O
err	int
=	O
errno	O
;	O
if	O
(	O
!	O
err	int
)	O
err	int
=	O
trivfs_create_control	()->(int)
(	O
file	O
,	O
peercntlclass	*(struct)
,	O
term_bucket	*(struct)
,	O
peerclass	*(struct)
,	O
term_bucket	*(struct)
,	O
peercntl	*(*(struct))
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
right	O
=	O
ports_get_send_right	()->(int)
(	O
*	O
peercntl	*(*(struct))
)	O
;	O
err	int
=	O
file_set_translator	()->(int)
(	O
file	O
,	O
0	int
,	O
FS_TRANS_EXCL	O
|	O
FS_TRANS_SET	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
right	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
right	O
)	O
;	O
}	O
if	O
(	O
err	int
)	O
error	()->(int)
(	O
1	int
,	O
err	int
,	O
"%s"	*(char)
,	O
peer_name	*(char)
)	O
;	O
(	O
*	O
peercntl	*(*(struct))
)	O
->	O
hook	O
=	O
peer_name	*(char)
;	O
ports_port_deref	()->(int)
(	O
*	O
peercntl	*(*(struct))
)	O
;	O
}	O
memset	O
(	O
&	O
termstate	struct
,	O
0	int
,	O
sizeof	O
(	O
termstate	struct
)	O
)	O
;	O
termflags	long
=	O
NO_CARRIER	int
|	O
NO_OWNER	int
;	O
pthread_mutex_init	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)),*(union(array(char),int)))->(int)
(	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
,	O
NULL	O
)	O
;	O
err	int
=	O
io_stat	()->(int)
(	O
(	O
*	O
ourcntl	*(*(struct))
)	O
->	O
underlying	O
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	int
)	O
{	O
term_owner	int
=	O
term_group	int
=	O
0	int
;	O
term_mode	int
=	O
(	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
==	O
&	O
ptyio_bottom	struct(enum,*(()->(int)),*(()->(int)),*((*(struct))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct))->(int)),*((int,int)->(int)),*((*(int))->(int)))
?	O
DEFFILEMODE	O
:	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
;	O
}	O
else	O
{	O
term_owner	int
=	O
st	struct
.	O
st_uid	O
;	O
term_group	int
=	O
st	struct
.	O
st_gid	O
;	O
term_mode	int
=	O
(	O
st	struct
.	O
st_mode	O
&	O
ACCESSPERMS	O
)	O
;	O
}	O
term_mode	int
|=	O
S_IFCHR	O
|	O
S_IROOT	O
;	O
inputq	*(struct)
=	O
create_queue	(int,int,int)->(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
(	O
256	int
,	O
QUEUE_LOWAT	int
,	O
QUEUE_HIWAT	int
)	O
;	O
rawq	*(struct)
=	O
create_queue	(int,int,int)->(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
(	O
256	int
,	O
QUEUE_LOWAT	int
,	O
QUEUE_HIWAT	int
)	O
;	O
outputq	*(struct)
=	O
create_queue	(int,int,int)->(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
(	O
256	int
,	O
QUEUE_LOWAT	int
,	O
QUEUE_HIWAT	int
)	O
;	O
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
init	*(()->(int))
)	O
(	O
)	O
;	O
if	O
(	O
err	int
)	O
error	()->(int)
(	O
1	int
,	O
err	int
,	O
"Initializing bottom handler"	*(char)
)	O
;	O
pthread_cond_init	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)),*(union(array(char),int)))->(int)
(	O
&	O
carrier_alert	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
,	O
NULL	O
)	O
;	O
pthread_cond_init	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)),*(union(array(char),int)))->(int)
(	O
&	O
select_alert	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
,	O
NULL	O
)	O
;	O
ports_manage_port_operations_multithread	()->(int)
(	O
term_bucket	*(struct)
,	O
demuxer	(*(int),*(int))->(int)
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
