struct	O
dirdata	struct(long,*(*(char)),*(char))
{	O
size_t	long
nnames	long
;	O
char	O
const	O
*	O
*	O
names	*(*(char))
;	O
char	O
*	O
data	*(char)
;	O
}	O
;	O
static	O
bool	bool
locale_specific_sorting	bool
;	O
static	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
failed_locale_specific_sorting	array(struct(array(long),int,struct(array(long))))
;	O
static	O
bool	bool
dir_loop	(*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*`)))),int)->(bool)
(	O
struct	O
comparison	struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`))))))
const	O
*	O
,	O
int	O
)	O
;	O
static	O
int	O
compare_names_for_qsort	(*(void),*(void))->(int)
(	O
void	O
const	O
*	O
,	O
void	O
const	O
*	O
)	O
;	O
static	O
bool	bool
dir_read	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(long,*(*(char)),*(char))))->(bool)
(	O
struct	O
file_data	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)
const	O
*	O
dir	*(char)
,	O
struct	O
dirdata	struct(long,*(*(char)),*(char))
*	O
dirdata	struct(long,*(*(char)),*(char))
)	O
{	O
register	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
next	*(struct(long,long,short,char,array(char)))
;	O
register	O
size_t	long
i	long
;	O
char	O
const	O
*	O
*	O
names	*(*(char))
;	O
size_t	long
nnames	long
;	O
char	O
*	O
data	*(char)
;	O
size_t	long
data_alloc	long
,	O
data_used	long
;	O
dirdata	struct(long,*(*(char)),*(char))
->	O
names	*(*(char))
=	O
0	int
;	O
dirdata	struct(long,*(*(char)),*(char))
->	O
data	*(char)
=	O
0	int
;	O
nnames	long
=	O
0	int
;	O
data	*(char)
=	O
0	int
;	O
if	O
(	O
dir	*(char)
->	O
desc	int
!=	O
-	O
1	int
)	O
{	O
register	O
DIR	struct
*	O
reading	*(struct)
=	O
opendir	(*(char))->(*(struct))
(	O
dir	*(char)
->	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
reading	*(struct)
)	O
return	O
false	int
;	O
data_alloc	long
=	O
512	int
;	O
data_used	long
=	O
0	int
;	O
dirdata	struct(long,*(*(char)),*(char))
->	O
data	*(char)
=	O
data	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
data_alloc	long
)	O
;	O
while	O
(	O
(	O
errno	O
=	O
0	int
,	O
(	O
next	*(struct(long,long,short,char,array(char)))
=	O
readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
reading	*(struct)
)	O
)	O
!=	O
0	int
)	O
)	O
{	O
char	O
*	O
d_name	array(char)
=	O
next	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
;	O
size_t	long
d_size	long
=	O
_D_EXACT_NAMLEN	O
(	O
next	*(struct(long,long,short,char,array(char)))
)	O
+	O
1	int
;	O
if	O
(	O
d_name	array(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
(	O
d_name	array(char)
[	O
1	int
]	O
==	O
0	int
||	O
(	O
d_name	array(char)
[	O
1	int
]	O
==	O
'.'	O
&&	O
d_name	array(char)
[	O
2	int
]	O
==	O
0	int
)	O
)	O
)	O
continue	O
;	O
if	O
(	O
excluded_file_name	(*(struct),*(char))->(bool)
(	O
excluded	*(struct)
,	O
d_name	array(char)
)	O
)	O
continue	O
;	O
while	O
(	O
data_alloc	long
<	O
data_used	long
+	O
d_size	long
)	O
{	O
if	O
(	O
PTRDIFF_MAX	O
/	O
2	int
<=	O
data_alloc	long
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
dirdata	struct(long,*(*(char)),*(char))
->	O
data	*(char)
=	O
data	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
data	*(char)
,	O
data_alloc	long
*=	O
2	int
)	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
data	*(char)
+	O
data_used	long
,	O
d_name	array(char)
,	O
d_size	long
)	O
;	O
data_used	long
+=	O
d_size	long
;	O
nnames	long
++	O
;	O
}	O
if	O
(	O
errno	O
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
closedir	(*(struct))->(int)
(	O
reading	*(struct)
)	O
;	O
errno	O
=	O
e	int
;	O
return	O
false	int
;	O
}	O
if	O
(	O
closedir	(*(struct))->(int)
(	O
reading	*(struct)
)	O
!=	O
0	int
)	O
return	O
false	int
;	O
}	O
if	O
(	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
names	*(*(char))
-	O
1	int
<=	O
nnames	long
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
dirdata	struct(long,*(*(char)),*(char))
->	O
names	*(*(char))
=	O
names	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
(	O
nnames	long
+	O
1	int
)	O
*	O
sizeof	O
*	O
names	*(*(char))
)	O
;	O
dirdata	struct(long,*(*(char)),*(char))
->	O
nnames	long
=	O
nnames	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nnames	long
;	O
i	long
++	O
)	O
{	O
names	*(*(char))
[	O
i	long
]	O
=	O
data	*(char)
;	O
data	*(char)
+=	O
strlen	(*(char))->(long)
(	O
data	*(char)
)	O
+	O
1	int
;	O
}	O
names	*(*(char))
[	O
nnames	long
]	O
=	O
0	int
;	O
return	O
true	int
;	O
}	O
static	O
int	O
compare_names	(*(char),*(char))->(int)
(	O
char	O
const	O
*	O
name1	*(char)
,	O
char	O
const	O
*	O
name2	*(char)
)	O
{	O
if	O
(	O
locale_specific_sorting	bool
)	O
{	O
int	O
r	int
;	O
errno	O
=	O
0	int
;	O
if	O
(	O
ignore_file_name_case	bool
)	O
r	int
=	O
strcasecoll	O
(	O
name1	*(char)
,	O
name2	*(char)
)	O
;	O
else	O
r	int
=	O
strcoll	(*(char),*(char))->(int)
(	O
name1	*(char)
,	O
name2	*(char)
)	O
;	O
if	O
(	O
errno	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot compare file names `%s' and `%s'"	*(char)
)	O
,	O
name1	*(char)
,	O
name2	*(char)
)	O
;	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
failed_locale_specific_sorting	array(struct(array(long),int,struct(array(long))))
,	O
1	int
)	O
;	O
}	O
return	O
r	int
;	O
}	O
return	O
file_name_cmp	O
(	O
name1	*(char)
,	O
name2	*(char)
)	O
;	O
}	O
static	O
int	O
compare_names_for_qsort	(*(void),*(void))->(int)
(	O
void	O
const	O
*	O
file1	*(void)
,	O
void	O
const	O
*	O
file2	*(void)
)	O
{	O
char	O
const	O
*	O
const	O
*	O
f1	*(*(char))
=	O
file1	*(void)
;	O
char	O
const	O
*	O
const	O
*	O
f2	*(*(char))
=	O
file2	*(void)
;	O
int	O
diff	int
=	O
compare_names	(*(char),*(char))->(int)
(	O
*	O
f1	*(*(char))
,	O
*	O
f2	*(*(char))
)	O
;	O
return	O
diff	int
?	O
diff	int
:	O
file_name_cmp	O
(	O
*	O
f1	*(*(char))
,	O
*	O
f2	*(*(char))
)	O
;	O
}	O
int	O
diff_dirs	(*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*`)))),*((*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*`)),*(char),*(char))->(int)))->(int)
(	O
struct	O
comparison	struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`))))))
const	O
*	O
cmp	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
,	O
int	O
(	O
*	O
handle_file	*((*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`))),*(char),*(char))->(int))
)	O
(	O
struct	O
comparison	struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`))))))
const	O
*	O
,	O
char	O
const	O
*	O
,	O
char	O
const	O
*	O
)	O
)	O
{	O
struct	O
dirdata	struct(long,*(*(char)),*(char))
dirdata	struct(long,*(*(char)),*(char))
[	O
2	int
]	O
;	O
int	O
volatile	O
val	array(int)
=	O
EXIT_SUCCESS	int
;	O
int	O
i	long
;	O
if	O
(	O
(	O
cmp	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
->	O
file	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
desc	int
==	O
-	O
1	int
||	O
dir_loop	(*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*`)))),int)->(bool)
(	O
cmp	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
,	O
0	int
)	O
)	O
&&	O
(	O
cmp	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
->	O
file	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
desc	int
==	O
-	O
1	int
||	O
dir_loop	(*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*`)))),int)->(bool)
(	O
cmp	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
,	O
1	int
)	O
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s: recursive directory loop"	*(char)
)	O
,	O
cmp	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
->	O
file	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
cmp	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
->	O
file	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
desc	int
==	O
-	O
1	int
]	O
.	O
name	*(char)
)	O
;	O
return	O
EXIT_TROUBLE	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
2	int
;	O
i	long
++	O
)	O
if	O
(	O
!	O
dir_read	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(long,*(*(char)),*(char))))->(bool)
(	O
&	O
cmp	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
->	O
file	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
i	long
]	O
,	O
&	O
dirdata	struct(long,*(*(char)),*(char))
[	O
i	long
]	O
)	O
)	O
{	O
perror_with_name	(*(char))->(void)
(	O
cmp	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
->	O
file	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
i	long
]	O
.	O
name	*(char)
)	O
;	O
val	array(int)
=	O
EXIT_TROUBLE	int
;	O
}	O
if	O
(	O
val	array(int)
==	O
EXIT_SUCCESS	int
)	O
{	O
char	O
const	O
*	O
*	O
volatile	O
names	*(*(char))
[	O
2	int
]	O
;	O
names	*(*(char))
[	O
0	int
]	O
=	O
dirdata	struct(long,*(*(char)),*(char))
[	O
0	int
]	O
.	O
names	*(*(char))
;	O
names	*(*(char))
[	O
1	int
]	O
=	O
dirdata	struct(long,*(*(char)),*(char))
[	O
1	int
]	O
.	O
names	*(*(char))
;	O
locale_specific_sorting	bool
=	O
true	int
;	O
if	O
(	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
failed_locale_specific_sorting	array(struct(array(long),int,struct(array(long))))
)	O
)	O
locale_specific_sorting	bool
=	O
false	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
2	int
;	O
i	long
++	O
)	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
names	*(*(char))
[	O
i	long
]	O
,	O
dirdata	struct(long,*(*(char)),*(char))
[	O
i	long
]	O
.	O
nnames	long
,	O
sizeof	O
*	O
dirdata	struct(long,*(*(char)),*(char))
[	O
i	long
]	O
.	O
names	*(*(char))
,	O
compare_names_for_qsort	(*(void),*(void))->(int)
)	O
;	O
if	O
(	O
starting_file	*(char)
&&	O
!	O
cmp	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
->	O
parent	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
)	O
{	O
while	O
(	O
*	O
names	*(*(char))
[	O
0	int
]	O
&&	O
compare_names	(*(char),*(char))->(int)
(	O
*	O
names	*(*(char))
[	O
0	int
]	O
,	O
starting_file	*(char)
)	O
<	O
0	int
)	O
names	*(*(char))
[	O
0	int
]	O
++	O
;	O
while	O
(	O
*	O
names	*(*(char))
[	O
1	int
]	O
&&	O
compare_names	(*(char),*(char))->(int)
(	O
*	O
names	*(*(char))
[	O
1	int
]	O
,	O
starting_file	*(char)
)	O
<	O
0	int
)	O
names	*(*(char))
[	O
1	int
]	O
++	O
;	O
}	O
while	O
(	O
*	O
names	*(*(char))
[	O
0	int
]	O
||	O
*	O
names	*(*(char))
[	O
1	int
]	O
)	O
{	O
int	O
nameorder	int
=	O
(	O
!	O
*	O
names	*(*(char))
[	O
0	int
]	O
?	O
1	int
:	O
!	O
*	O
names	*(*(char))
[	O
1	int
]	O
?	O
-	O
1	int
:	O
compare_names	(*(char),*(char))->(int)
(	O
*	O
names	*(*(char))
[	O
0	int
]	O
,	O
*	O
names	*(*(char))
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
nameorder	int
==	O
0	int
)	O
{	O
int	O
raw_order	int
=	O
file_name_cmp	O
(	O
*	O
names	*(*(char))
[	O
0	int
]	O
,	O
*	O
names	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
raw_order	int
!=	O
0	int
)	O
{	O
int	O
greater_side	int
=	O
raw_order	int
<	O
0	int
;	O
int	O
lesser_side	int
=	O
1	int
-	O
greater_side	int
;	O
char	O
const	O
*	O
*	O
lesser	*(*(char))
=	O
names	*(*(char))
[	O
lesser_side	int
]	O
;	O
char	O
const	O
*	O
greater_name	*(char)
=	O
*	O
names	*(*(char))
[	O
greater_side	int
]	O
;	O
char	O
const	O
*	O
*	O
p	*(void)
;	O
for	O
(	O
p	*(void)
=	O
lesser	*(*(char))
+	O
1	int
;	O
*	O
p	*(void)
&&	O
compare_names	(*(char),*(char))->(int)
(	O
*	O
p	*(void)
,	O
greater_name	*(char)
)	O
==	O
0	int
;	O
p	*(void)
++	O
)	O
{	O
int	O
c	int
=	O
file_name_cmp	O
(	O
*	O
p	*(void)
,	O
greater_name	*(char)
)	O
;	O
if	O
(	O
0	int
<=	O
c	int
)	O
{	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
lesser	*(*(char))
+	O
1	int
,	O
lesser	*(*(char))
,	O
(	O
char	O
*	O
)	O
p	*(void)
-	O
(	O
char	O
*	O
)	O
lesser	*(*(char))
)	O
;	O
*	O
lesser	*(*(char))
=	O
greater_name	*(char)
;	O
}	O
break	O
;	O
}	O
}	O
}	O
}	O
int	O
v1	int
=	O
(	O
*	O
handle_file	*((*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`))),*(char),*(char))->(int))
)	O
(	O
cmp	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
,	O
0	int
<	O
nameorder	int
?	O
0	int
:	O
*	O
names	*(*(char))
[	O
0	int
]	O
++	O
,	O
nameorder	int
<	O
0	int
?	O
0	int
:	O
*	O
names	*(*(char))
[	O
1	int
]	O
++	O
)	O
;	O
if	O
(	O
val	array(int)
<	O
v1	int
)	O
val	array(int)
=	O
v1	int
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
2	int
;	O
i	long
++	O
)	O
{	O
free	(*(void))->(void)
(	O
dirdata	struct(long,*(*(char)),*(char))
[	O
i	long
]	O
.	O
names	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
dirdata	struct(long,*(*(char)),*(char))
[	O
i	long
]	O
.	O
data	*(char)
)	O
;	O
}	O
return	O
val	array(int)
;	O
}	O
static	O
bool	bool
dir_loop	(*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*`)))),int)->(bool)
(	O
struct	O
comparison	struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`))))))
const	O
*	O
cmp	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
,	O
int	O
i	long
)	O
{	O
struct	O
comparison	struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`))))))
const	O
*	O
p	*(void)
=	O
cmp	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
;	O
while	O
(	O
(	O
p	*(void)
=	O
p	*(void)
->	O
parent	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
)	O
)	O
if	O
(	O
0	int
<	O
same_file	O
(	O
&	O
p	*(void)
->	O
file	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
i	long
]	O
.	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
&	O
cmp	*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct`)))))
->	O
file	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
i	long
]	O
.	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
return	O
true	int
;	O
return	O
false	int
;	O
}	O
char	O
*	O
find_dir_file_pathname	(*(char),*(char))->(*(char))
(	O
char	O
const	O
*	O
dir	*(char)
,	O
char	O
const	O
*	O
file	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
)	O
{	O
char	O
*	O
val	array(int)
;	O
char	O
const	O
*	O
match	*(char)
=	O
file	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
;	O
struct	O
dirdata	struct(long,*(*(char)),*(char))
dirdata	struct(long,*(*(char)),*(char))
;	O
dirdata	struct(long,*(*(char)),*(char))
.	O
names	*(*(char))
=	O
NULL	O
;	O
dirdata	struct(long,*(*(char)),*(char))
.	O
data	*(char)
=	O
NULL	O
;	O
if	O
(	O
ignore_file_name_case	bool
)	O
{	O
struct	O
file_data	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)
filedata	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)
;	O
filedata	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)
.	O
name	*(char)
=	O
dir	*(char)
;	O
filedata	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)
.	O
desc	int
=	O
0	int
;	O
if	O
(	O
dir_read	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),*(struct(long,*(*(char)),*(char))))->(bool)
(	O
&	O
filedata	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)
,	O
&	O
dirdata	struct(long,*(*(char)),*(char))
)	O
)	O
{	O
locale_specific_sorting	bool
=	O
true	int
;	O
if	O
(	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
failed_locale_specific_sorting	array(struct(array(long),int,struct(array(long))))
)	O
)	O
match	*(char)
=	O
file	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
;	O
else	O
{	O
for	O
(	O
char	O
const	O
*	O
*	O
p	*(void)
=	O
dirdata	struct(long,*(*(char)),*(char))
.	O
names	*(*(char))
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
if	O
(	O
compare_names	(*(char),*(char))->(int)
(	O
*	O
p	*(void)
,	O
file	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
)	O
==	O
0	int
)	O
{	O
if	O
(	O
file_name_cmp	O
(	O
*	O
p	*(void)
,	O
file	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
)	O
==	O
0	int
)	O
{	O
match	*(char)
=	O
*	O
p	*(void)
;	O
break	O
;	O
}	O
if	O
(	O
match	*(char)
==	O
file	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
)	O
match	*(char)
=	O
*	O
p	*(void)
;	O
}	O
}	O
}	O
}	O
val	array(int)
=	O
file_name_concat	(*(char),*(char),*(*(char)))->(*(char))
(	O
dir	*(char)
,	O
match	*(char)
,	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
dirdata	struct(long,*(*(char)),*(char))
.	O
names	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
dirdata	struct(long,*(*(char)),*(char))
.	O
data	*(char)
)	O
;	O
return	O
val	array(int)
;	O
}	O
