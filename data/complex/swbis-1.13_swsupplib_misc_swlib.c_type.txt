static	O
int	O
verbose_levelG	int
;	O
static	O
int	O
verbose_swbis_event_thresholdG	int
=	O
SWC_VERBOSE_4	int
;	O
static	O
uintmax_t	long
*	O
g_pstatbytes	*(long)
=	O
NULL	O
;	O
static	O
struct	O
timespec	struct(long,long)
*	O
io_req	*(struct(long,long))
=	O
(	O
struct	O
timespec	struct(long,long)
*	O
)	O
NULL	O
;	O
static	O
int	O
g_burst_adjust	int
=	O
65000	int
;	O
static	O
pid_t	int
g_pax_header_pidG	int
=	O
0	int
;	O
void	O
swlib_set_pax_header_pid	(int)->(void)
(	O
pid_t	int
n	long
)	O
{	O
g_pax_header_pidG	int
=	O
n	long
;	O
}	O
pid_t	int
swlib_get_pax_header_pid	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
g_pax_header_pidG	int
==	O
0	int
)	O
{	O
g_pax_header_pidG	int
=	O
getpid	()->(int)
(	O
)	O
;	O
}	O
return	O
g_pax_header_pidG	int
;	O
}	O
static	O
ssize_t	long
synct_i_no_null_write	(int,*(char),int)->(long)
(	O
int	O
fd	int
,	O
char	O
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
int	O
sz	int
)	O
{	O
int	O
ret	int
;	O
int	O
remains	int
;	O
int	O
excl_region	int
;	O
int	O
amount	long
;	O
int	O
retval	int
;	O
char	O
*	O
p	*(char)
;	O
char	O
*	O
x	*(char)
;	O
remains	int
=	O
sz	int
;	O
p	*(char)
=	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
;	O
retval	int
=	O
0	int
;	O
while	O
(	O
remains	int
>	O
0	int
)	O
{	O
amount	long
=	O
0	int
;	O
x	*(char)
=	O
p	*(char)
;	O
while	O
(	O
(	O
int	O
)	O
(	O
x	*(char)
-	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
<	O
sz	int
&&	O
*	O
x	*(char)
)	O
{	O
amount	long
++	O
;	O
x	*(char)
++	O
;	O
}	O
if	O
(	O
amount	long
>	O
sz	int
)	O
amount	long
=	O
sz	int
;	O
excl_region	int
=	O
remains	int
-	O
amount	long
;	O
E_DEBUG3	O
(	O
"amount=%d excl_region=%d"	*(char)
,	O
amount	long
,	O
excl_region	int
)	O
;	O
ret	int
=	O
atomicio	(*((int,*(void),long)->(long)),int,*(void),long)->(long)
(	O
uxfio_write	(int,*(void),long)->(long)
,	O
fd	int
,	O
p	*(char)
,	O
amount	long
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ret	int
!=	O
amount	long
)	O
return	O
-	O
2	int
;	O
p	*(char)
+=	O
ret	int
;	O
remains	int
-=	O
ret	int
;	O
retval	int
+=	O
ret	int
;	O
while	O
(	O
excl_region	int
>	O
0	int
&&	O
*	O
p	*(char)
==	O
'\0'	O
)	O
{	O
excl_region	int
--	O
;	O
remains	int
--	O
;	O
p	*(char)
++	O
;	O
}	O
}	O
return	O
retval	int
;	O
}	O
static	O
ssize_t	long
synct_i_read_block	(*(struct(int,int,*(char),*(char),*(char),int,*(char))),*((int,*(void),long)->(long)),int,*(char))->(long)
(	O
SYNCT	struct(int,int,*(char),*(char),*(char),int,*(char))
*	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
,	O
ssize_t	long
(	O
*	O
iof	*((int,*(void),long)->(long))
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
,	O
int	O
fd	int
,	O
char	O
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
ssize_t	long
ret	int
;	O
E_DEBUG2	O
(	O
"fd=%d"	*(char)
,	O
fd	int
)	O
;	O
ret	int
=	O
(	O
iof	*((int,*(void),long)->(long))
)	O
(	O
fd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
;	O
if	O
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
debugfdM	int
>	O
0	int
)	O
write	*((*(void),*(char),long)->(long))
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
debugfdM	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
ret	int
)	O
;	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
if	O
(	O
ret	int
!=	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: synct_i_read_block() error: ret=%d\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
(	O
int	O
)	O
ret	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
-	O
ret	int
;	O
}	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
countM	int
++	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
synct_check_for_possible_eof	(*(struct(int,int,*(char),*(char),*(char),int,*(char))))->(int)
(	O
SYNCT	struct(int,int,*(char),*(char),*(char),int,*(char))
*	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
)	O
{	O
unsigned	O
char	O
*	O
ibuf	*(char)
;	O
unsigned	O
char	O
*	O
pos	*(char)
;	O
int	O
i	int
;	O
ibuf	*(char)
=	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
bufM	*(char)
;	O
pos	*(char)
=	O
ibuf	*(char)
;	O
i	int
=	O
0	int
;	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
while	O
(	O
(	O
int	O
)	O
(	O
pos	*(char)
-	O
ibuf	*(char)
)	O
<	O
SWLIB_SYNCT_BLOCKSIZE	int
&&	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
mtM	*(char)
[	O
i	int
]	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
*	O
pos	*(char)
&&	O
*	O
pos	*(char)
==	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
mtM	*(char)
[	O
i	int
]	O
)	O
{	O
E_DEBUG	O
(	O
"finding trailer string, so far so good"	*(char)
)	O
;	O
i	int
++	O
;	O
}	O
else	O
if	O
(	O
*	O
pos	*(char)
==	O
'\0'	O
&&	O
i	int
>	O
11	int
)	O
{	O
return	O
SYNCT_EOF_CONDITION_2	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"reset, bad match of trailer string"	*(char)
)	O
;	O
return	O
SYNCT_EOF_CONDITION_0	int
;	O
}	O
pos	*(char)
++	O
;	O
}	O
if	O
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
mtM	*(char)
[	O
i	int
]	O
==	O
'\0'	O
)	O
{	O
E_DEBUG	O
(	O
"found trailer"	*(char)
)	O
;	O
return	O
SYNCT_EOF_CONDITION_1	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"not found"	*(char)
)	O
;	O
return	O
SYNCT_EOF_CONDITION_0	int
;	O
}	O
}	O
void	O
swlib_set_swbis_verbose_threshold	(int)->(void)
(	O
int	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
verbose_swbis_event_thresholdG	int
=	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
}	O
int	O
swlib_get_nopen	()->(int)
(	O
void	O
)	O
{	O
int	O
nopen	int
=	O
0	int
;	O
int	O
ret	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
200	int
)	O
;	O
++	O
i	int
)	O
{	O
ret	int
=	O
fcntl	(int,int)->(int)
(	O
i	int
,	O
F_GETFL	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
&&	O
errno	O
==	O
EBADF	int
)	O
{	O
;	O
}	O
else	O
{	O
nopen	int
++	O
;	O
}	O
}	O
return	O
nopen	int
;	O
}	O
void	O
e_msg	(*(char),*(char),*(char),int,*(char))->(void)
(	O
char	O
*	O
class	*(char)
,	O
char	O
*	O
reason	*(char)
,	O
char	O
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
line	*(char)
,	O
char	O
*	O
function	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s: %s: at %s:%d\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
class	*(char)
,	O
reason	*(char)
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
line	*(char)
)	O
;	O
}	O
static	O
int	O
convert_hex_seq	(int,int)->(int)
(	O
int	O
d1	int
,	O
int	O
d2	int
)	O
{	O
int	O
n	long
;	O
n	long
=	O
d1	int
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
n	long
)	O
==	O
0	int
&&	O
(	O
n	long
<	O
'\x41'	O
||	O
n	long
>	O
'\x46'	O
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
isdigit	(int)->(int)
(	O
n	long
)	O
==	O
0	int
)	O
d1	int
-=	O
7	int
;	O
n	long
=	O
d2	int
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
n	long
)	O
==	O
0	int
&&	O
(	O
n	long
<	O
'\x41'	O
||	O
n	long
>	O
'\x46'	O
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
isdigit	(int)->(int)
(	O
n	long
)	O
==	O
0	int
)	O
d2	int
-=	O
7	int
;	O
return	O
(	O
16	int
*	O
(	O
d1	int
-	O
48	int
)	O
)	O
+	O
(	O
d2	int
-	O
48	int
)	O
;	O
}	O
static	O
char	O
*	O
does_have_hex_escape	(*(char),*(int))->(*(char))
(	O
char	O
*	O
src	*(char)
,	O
int	O
*	O
value	long
)	O
{	O
char	O
*	O
t	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
char	O
*	O
seq	*(char)
;	O
int	O
d1	int
;	O
int	O
d2	int
;	O
*	O
value	long
=	O
0	int
;	O
t	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
=	O
strstr	(*(char),*(char))->(*(char))
(	O
src	*(char)
,	O
"\\x"	*(char)
)	O
;	O
if	O
(	O
t	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
&&	O
(	O
t	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
==	O
src	*(char)
||	O
*	O
(	O
t	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
-	O
1	int
)	O
!=	O
'\\'	O
)	O
)	O
{	O
seq	*(char)
=	O
t	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
+	O
2	int
;	O
if	O
(	O
*	O
seq	*(char)
==	O
'\0'	O
)	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
if	O
(	O
*	O
(	O
seq	*(char)
+	O
1	int
)	O
==	O
'\0'	O
)	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
d1	int
=	O
toupper	(int)->(int)
(	O
(	O
int	O
)	O
(	O
*	O
seq	*(char)
)	O
)	O
;	O
d2	int
=	O
toupper	(int)->(int)
(	O
(	O
int	O
)	O
(	O
*	O
(	O
seq	*(char)
+	O
1	int
)	O
)	O
)	O
;	O
*	O
value	long
=	O
convert_hex_seq	(int,int)->(int)
(	O
d1	int
,	O
d2	int
)	O
;	O
if	O
(	O
*	O
value	long
<	O
0	int
)	O
{	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
else	O
{	O
return	O
t	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
}	O
}	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
static	O
void	O
process_all_hex_escapes	(*(char))->(void)
(	O
char	O
*	O
src	*(char)
)	O
{	O
unsigned	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
unsigned	O
char	O
*	O
r	*(char)
;	O
int	O
value	long
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
(	O
unsigned	O
char	O
*	O
)	O
src	*(char)
;	O
while	O
(	O
(	O
r	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
does_have_hex_escape	(*(char),*(int))->(*(char))
(	O
(	O
char	O
*	O
)	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
&	O
value	long
)	O
)	O
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
(	O
void	O
*	O
)	O
(	O
r	*(char)
+	O
1	int
)	O
,	O
(	O
void	O
*	O
)	O
(	O
r	*(char)
+	O
4	int
)	O
,	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
(	O
r	*(char)
+	O
4	int
)	O
)	O
+	O
1	int
)	O
;	O
*	O
r	*(char)
=	O
(	O
unsigned	O
char	O
)	O
(	O
value	long
)	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
(	O
r	*(char)
+	O
1	int
)	O
;	O
}	O
}	O
int	O
swlib_doif_writeap	(int,*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(array(struct(int,int,*(void),*(void)))))->(int)
(	O
int	O
fd	int
,	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
buffer	array(char)
,	O
char	O
*	O
format	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
*	O
pap	*(array(struct(int,int,*(void),*(void))))
)	O
{	O
int	O
ret	int
;	O
int	O
aret	int
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
0	int
;	O
ret	int
=	O
strob_vsprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
buffer	array(char)
,	O
1	int
,	O
format	*(char)
,	O
*	O
pap	*(array(struct(int,int,*(void),*(void))))
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
ret	int
=	O
strob_strlen	(*(struct(*(char),*(char),int,int,int,char,int)))->(long)
(	O
buffer	array(char)
)	O
;	O
aret	int
=	O
atomicio	(*((int,*(void),long)->(long)),int,*(void),long)->(long)
(	O
uxfio_write	(int,*(void),long)->(long)
,	O
fd	int
,	O
(	O
void	O
*	O
)	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
buffer	array(char)
)	O
,	O
strob_strlen	(*(struct(*(char),*(char),int,int,int,char,int)))->(long)
(	O
buffer	array(char)
)	O
)	O
;	O
if	O
(	O
aret	int
!=	O
ret	int
)	O
return	O
-	O
1	int
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
nano_nanosleep	(long)->(int)
(	O
long	O
nsec	long
)	O
{	O
struct	O
timespec	struct(long,long)
tt	struct(long,long)
;	O
tt	struct(long,long)
.	O
tv_sec	long
=	O
0	int
;	O
tt	struct(long,long)
.	O
tv_nsec	long
=	O
nsec	long
;	O
return	O
nanosleep	(*(struct(long,long)),*(struct(long,long)))->(int)
(	O
&	O
tt	struct(long,long)
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
delay_sleep_pattern2	(*(struct(long,long)),*(int),int,int)->(void)
(	O
struct	O
timespec	struct(long,long)
*	O
io_req	*(struct(long,long))
,	O
int	O
*	O
sleepbytes	*(int)
,	O
int	O
c_amount	int
,	O
int	O
byteswritten	int
)	O
{	O
static	O
int	O
doneone	int
=	O
0	int
;	O
const	O
int	O
leaddiv	int
=	O
0	int
;	O
int	O
openssh_rcvd_adjust	int
=	O
g_burst_adjust	int
;	O
if	O
(	O
*	O
sleepbytes	*(int)
>	O
openssh_rcvd_adjust	int
&&	O
(	O
leaddiv	int
==	O
0	int
||	O
(	O
byteswritten	int
>	O
(	O
c_amount	int
/	O
leaddiv	int
)	O
&&	O
byteswritten	int
<	O
(	O
c_amount	int
-	O
c_amount	int
/	O
leaddiv	int
)	O
)	O
)	O
)	O
{	O
if	O
(	O
(	O
verbose_levelG	int
>=	O
SWC_VERBOSE_3	int
&&	O
!	O
doneone	int
)	O
||	O
(	O
verbose_levelG	int
>=	O
SWC_VERBOSE_8	int
)	O
)	O
{	O
doneone	int
=	O
1	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: sshd efd race delay: sleeping %d microseconds every %d bytes\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
(	O
int	O
)	O
(	O
io_req	*(struct(long,long))
->	O
tv_nsec	long
)	O
/	O
1000	int
,	O
g_burst_adjust	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: sshd efd race delay: is not needed for openssh >=5.1\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
)	O
;	O
}	O
nano_nanosleep	(long)->(int)
(	O
io_req	*(struct(long,long))
->	O
tv_nsec	long
)	O
;	O
*	O
sleepbytes	*(int)
=	O
0	int
;	O
}	O
}	O
static	O
int	O
form_abspath	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(int)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
sb1	*(struct(*(char),*(char),int,int,int,char,int))
,	O
char	O
*	O
s1	*(char)
,	O
char	O
*	O
pcwd	*(char)
)	O
{	O
char	O
cwd	short
[	O
200	int
]	O
;	O
if	O
(	O
*	O
s1	*(char)
==	O
'/'	O
)	O
return	O
1	int
;	O
if	O
(	O
pcwd	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
getcwd	(*(char),long)->(*(char))
(	O
cwd	short
,	O
sizeof	O
(	O
cwd	short
)	O
-	O
2	int
)	O
==	O
NULL	O
)	O
{	O
SWLIB_FATAL	O
(	O
"path too long"	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
cwd	short
,	O
pcwd	*(char)
,	O
sizeof	O
(	O
cwd	short
)	O
-	O
2	int
)	O
;	O
}	O
cwd	short
[	O
sizeof	O
(	O
cwd	short
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
sb1	*(struct(*(char),*(char),int,int,int,char,int))
,	O
cwd	short
)	O
;	O
swlib_unix_dircat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(int)
(	O
sb1	*(struct(*(char),*(char),int,int,int,char,int))
,	O
s1	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
intmax_t	long
swlib_i_digs_copy	(int,int,long,*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short)),int,*((int,*(void),long)->(long)))->(long)
(	O
int	O
ofd	int
,	O
int	O
ifd	int
,	O
intmax_t	long
count	long
,	O
FILE_DIGS	struct(int,array(char),short,array(char),short,array(char),short,array(char),short)
*	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
,	O
int	O
adjunct_ofd	int
,	O
ssize_t	long
(	O
*	O
f	*((int)->(int))
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
{	O
intmax_t	long
n	long
;	O
intmax_t	long
am	long
;	O
intmax_t	long
wr	long
;	O
unsigned	O
char	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
[	O
SHA_BLOCKSIZE	int
]	O
;	O
intmax_t	long
blocksize	long
=	O
SHA_BLOCKSIZE	int
;	O
intmax_t	long
amount	long
;	O
intmax_t	long
readamount	long
;	O
intmax_t	long
ret	int
;	O
intmax_t	long
retval	int
=	O
0	int
;	O
int	O
i	int
;	O
char	O
*	O
p5	*(char)
;	O
char	O
*	O
p	*(char)
;	O
MD5_CTX	struct(array(int),array(int),array(char),int)
md5ctx	struct(array(int),array(int),array(char),int)
;	O
int	O
digest_hex_bytes	int
=	O
40	int
;	O
int	O
sha512digest_hex_bytes	int
=	O
128	int
;	O
unsigned	O
char	O
res_sha1	array(char)
[	O
21	int
]	O
;	O
unsigned	O
char	O
res_sha512	array(char)
[	O
65	int
]	O
;	O
unsigned	O
char	O
sha1ctx	array(char)
[	O
512	int
]	O
;	O
unsigned	O
char	O
sha512ctx	array(char)
[	O
512	int
]	O
;	O
int	O
sleepbytes	*(int)
=	O
0	int
;	O
int	O
timebytes	int
=	O
0	int
;	O
time_t	long
newt	long
;	O
time_t	long
oldt	long
;	O
oldt	long
=	O
newt	long
=	O
time	struct(long,long)
(	O
NULL	O
)	O
;	O
if	O
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
&&	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_md5	short
==	O
DIGS_ENABLE_ON	int
)	O
swlib_md5_from_memblocks	(*(void),*(char),*(char),int)->(int)
(	O
&	O
md5ctx	struct(array(int),array(int),array(char),int)
,	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
md5	array(char)
,	O
(	O
unsigned	O
char	O
*	O
)	O
NULL	O
,	O
-	O
1	int
)	O
;	O
if	O
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
&&	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_sha1	short
==	O
DIGS_ENABLE_ON	int
)	O
sha_block	(*(void),*(void),*(char),int)->(int)
(	O
(	O
void	O
*	O
)	O
sha1ctx	array(char)
,	O
res_sha1	array(char)
,	O
NULL	O
,	O
-	O
1	int
)	O
;	O
if	O
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
&&	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_sha512	short
==	O
DIGS_ENABLE_ON	int
)	O
sha512_block	(*(void),*(void),*(char),int)->(int)
(	O
(	O
void	O
*	O
)	O
sha512ctx	array(char)
,	O
res_sha512	array(char)
,	O
NULL	O
,	O
-	O
1	int
)	O
;	O
do	O
{	O
if	O
(	O
count	long
>=	O
0	int
)	O
readamount	long
=	O
(	O
count	long
-	O
retval	int
)	O
>	O
blocksize	long
?	O
blocksize	long
:	O
(	O
count	long
-	O
retval	int
)	O
;	O
else	O
readamount	long
=	O
blocksize	long
;	O
n	long
=	O
(	O
*	O
f	*((int)->(int))
)	O
(	O
ifd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
readamount	long
)	O
;	O
if	O
(	O
n	long
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
n	long
)	O
{	O
if	O
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
&&	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_md5	short
==	O
DIGS_ENABLE_ON	int
)	O
{	O
p5	*(char)
=	O
(	O
char	O
*	O
)	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
;	O
am	long
=	O
n	long
;	O
while	O
(	O
am	long
>	O
0	int
)	O
{	O
amount	long
=	O
am	long
>	O
1024	int
?	O
1024	int
:	O
am	long
;	O
swlib_md5_from_memblocks	(*(void),*(char),*(char),int)->(int)
(	O
&	O
md5ctx	struct(array(int),array(int),array(char),int)
,	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
md5	array(char)
,	O
(	O
unsigned	O
char	O
*	O
)	O
p5	*(char)
,	O
amount	long
)	O
;	O
p5	*(char)
+=	O
amount	long
;	O
am	long
-=	O
amount	long
;	O
}	O
}	O
if	O
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
&&	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_sha1	short
==	O
DIGS_ENABLE_ON	int
)	O
sha_block	(*(void),*(void),*(char),int)->(int)
(	O
(	O
void	O
*	O
)	O
sha1ctx	array(char)
,	O
res_sha1	array(char)
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
n	long
)	O
;	O
if	O
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
&&	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_sha512	short
==	O
DIGS_ENABLE_ON	int
)	O
sha512_block	(*(void),*(void),*(char),int)->(int)
(	O
(	O
void	O
*	O
)	O
sha512ctx	array(char)
,	O
res_sha512	array(char)
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
n	long
)	O
;	O
if	O
(	O
ofd	int
>	O
0	int
)	O
{	O
wr	long
=	O
(	O
intmax_t	long
)	O
atomicio	(*((int,*(void),long)->(long)),int,*(void),long)->(long)
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
(	O
uxfio_write	(int,*(void),long)->(long)
)	O
,	O
ofd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
n	long
)	O
;	O
if	O
(	O
wr	long
<	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
wr	long
=	O
n	long
;	O
}	O
retval	int
+=	O
wr	long
;	O
if	O
(	O
adjunct_ofd	int
>	O
0	int
)	O
{	O
ret	int
=	O
atomicio	(*((int,*(void),long)->(long)),int,*(void),long)->(long)
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
(	O
uxfio_write	(int,*(void),long)->(long)
)	O
,	O
adjunct_ofd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
n	long
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
timebytes	int
+=	O
wr	long
;	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
if	O
(	O
io_req	*(struct(long,long))
&&	O
io_req	*(struct(long,long))
->	O
tv_nsec	long
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
sleepbytes	*(int)
+=	O
wr	long
;	O
delay_sleep_pattern2	(*(struct(long,long)),*(int),int,int)->(void)
(	O
io_req	*(struct(long,long))
,	O
&	O
sleepbytes	*(int)
,	O
count	long
,	O
retval	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
if	O
(	O
g_pstatbytes	*(long)
&&	O
timebytes	int
>	O
10000	int
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
if	O
(	O
(	O
newt	long
=	O
time	struct(long,long)
(	O
NULL	O
)	O
)	O
>	O
oldt	long
)	O
{	O
timebytes	int
=	O
0	int
;	O
oldt	long
=	O
newt	long
;	O
*	O
g_pstatbytes	*(long)
=	O
retval	int
;	O
(	O
void	O
)	O
update_progress_meter	(int)->(void)
(	O
SIGALRM	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
n	long
==	O
0	int
)	O
break	O
;	O
}	O
while	O
(	O
retval	int
<	O
count	long
||	O
count	long
<	O
0	int
)	O
;	O
if	O
(	O
n	long
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
&&	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_md5	short
==	O
DIGS_ENABLE_ON	int
)	O
{	O
swlib_md5_from_memblocks	(*(void),*(char),*(char),int)->(int)
(	O
&	O
md5ctx	struct(array(int),array(int),array(char),int)
,	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
md5	array(char)
,	O
(	O
unsigned	O
char	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
md5	array(char)
[	O
32	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
&&	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_sha1	short
==	O
DIGS_ENABLE_ON	int
)	O
sha_block	(*(void),*(void),*(char),int)->(int)
(	O
(	O
void	O
*	O
)	O
sha1ctx	array(char)
,	O
res_sha1	array(char)
,	O
(	O
unsigned	O
char	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
&&	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_sha512	short
==	O
DIGS_ENABLE_ON	int
)	O
sha512_block	(*(void),*(void),*(char),int)->(int)
(	O
(	O
void	O
*	O
)	O
sha512ctx	array(char)
,	O
res_sha512	array(char)
,	O
(	O
unsigned	O
char	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
&&	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_size	short
)	O
{	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
ubuf	*(struct(*(char),*(char),int,int,int,char,int))
;	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
24	int
)	O
;	O
ubuf	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
24	int
)	O
;	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
0	int
,	O
"%s"	*(char)
,	O
swlib_imaxtostr	(long,*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
retval	int
,	O
ubuf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
;	O
swlib_strncpy	(*(char),*(char),long)->(*(char))
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
size	array(char)
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
,	O
sizeof	O
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
size	array(char)
)	O
)	O
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
ubuf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
if	O
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
&&	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_sha1	short
==	O
DIGS_ENABLE_ON	int
)	O
{	O
p	*(char)
=	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
sha1	array(char)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
digest_hex_bytes	int
/	O
2	int
)	O
;	O
++	O
i	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(char)
,	O
"%02x"	*(char)
,	O
res_sha1	array(char)
[	O
i	int
]	O
)	O
;	O
p	*(char)
+=	O
2	int
;	O
}	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
sha1	array(char)
[	O
digest_hex_bytes	int
]	O
=	O
'\0'	O
;	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
sha1	array(char)
[	O
40	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
&&	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_sha512	short
==	O
DIGS_ENABLE_ON	int
)	O
{	O
p	*(char)
=	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
sha512	array(char)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
sha512digest_hex_bytes	int
/	O
2	int
)	O
;	O
++	O
i	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(char)
,	O
"%02x"	*(char)
,	O
res_sha512	array(char)
[	O
i	int
]	O
)	O
;	O
p	*(char)
+=	O
2	int
;	O
}	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
sha512	array(char)
[	O
sha512digest_hex_bytes	int
]	O
=	O
'\0'	O
;	O
}	O
return	O
retval	int
;	O
}	O
int	O
squash_trailing_char	(*(char),char,int)->(int)
(	O
char	O
*	O
path	*(char)
,	O
char	O
ch	int
,	O
int	O
min_len	int
)	O
{	O
if	O
(	O
path	*(char)
&&	O
(	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
path	*(char)
)	O
>	O
min_len	int
)	O
&&	O
(	O
*	O
(	O
path	*(char)
+	O
strlen	(*(char))->(long)
(	O
path	*(char)
)	O
-	O
1	int
)	O
)	O
==	O
(	O
int	O
)	O
ch	int
)	O
{	O
(	O
*	O
(	O
path	*(char)
+	O
strlen	(*(char))->(long)
(	O
path	*(char)
)	O
-	O
1	int
)	O
)	O
=	O
'\0'	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
return	O
1	int
;	O
}	O
}	O
int	O
swlib_atoi	(*(char),*(int))->(int)
(	O
const	O
char	O
*	O
nptr	*(char)
,	O
int	O
*	O
result	*(int)
)	O
{	O
return	O
swlib_atoi2	(*(char),*(*(char)),*(int))->(int)
(	O
nptr	*(char)
,	O
(	O
char	O
*	O
*	O
)	O
(	O
NULL	O
)	O
,	O
result	*(int)
)	O
;	O
}	O
int	O
swlib_atoi2	(*(char),*(*(char)),*(int))->(int)
(	O
const	O
char	O
*	O
nptr	*(char)
,	O
char	O
*	O
*	O
fp_endptr	*(*(char))
,	O
int	O
*	O
result	*(int)
)	O
{	O
long	O
ret	int
;	O
char	O
*	O
endptr	*(*(char))
;	O
char	O
*	O
*	O
a_endptr	*(*(char))
;	O
if	O
(	O
fp_endptr	*(*(char))
)	O
a_endptr	*(*(char))
=	O
fp_endptr	*(*(char))
;	O
else	O
a_endptr	*(*(char))
=	O
&	O
endptr	*(*(char))
;	O
ret	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
nptr	*(char)
,	O
a_endptr	*(*(char))
,	O
10	int
)	O
;	O
if	O
(	O
result	*(int)
)	O
*	O
result	*(int)
=	O
0	int
;	O
if	O
(	O
(	O
*	O
a_endptr	*(*(char))
==	O
nptr	*(char)
&&	O
ret	int
==	O
0	int
)	O
||	O
(	O
(	O
ret	int
==	O
LONG_MIN	O
||	O
ret	int
==	O
LONG_MAX	O
)	O
&&	O
errno	O
==	O
ERANGE	int
)	O
)	O
{	O
if	O
(	O
result	*(int)
)	O
{	O
*	O
result	*(int)
=	O
1	int
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: strtol error when converting [%s]\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
nptr	*(char)
)	O
;	O
}	O
return	O
(	O
int	O
)	O
ret	int
;	O
}	O
unsigned	O
long	O
int	O
swlib_atoul	(*(char),*(int),*(*(char)))->(long)
(	O
const	O
char	O
*	O
nptr	*(char)
,	O
int	O
*	O
result	*(int)
,	O
char	O
*	O
*	O
fp_endptr	*(*(char))
)	O
{	O
unsigned	O
long	O
int	O
ret	int
;	O
char	O
*	O
endptr	*(*(char))
;	O
char	O
*	O
*	O
p_endptr	*(*(char))
;	O
if	O
(	O
fp_endptr	*(*(char))
==	O
NULL	O
)	O
p_endptr	*(*(char))
=	O
&	O
endptr	*(*(char))
;	O
else	O
p_endptr	*(*(char))
=	O
fp_endptr	*(*(char))
;	O
ret	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
nptr	*(char)
,	O
p_endptr	*(*(char))
,	O
10	int
)	O
;	O
if	O
(	O
result	*(int)
)	O
*	O
result	*(int)
=	O
0	int
;	O
if	O
(	O
(	O
endptr	*(*(char))
==	O
nptr	*(char)
&&	O
ret	int
==	O
0	int
)	O
||	O
(	O
(	O
ret	int
==	O
ULONG_MAX	O
)	O
&&	O
errno	O
==	O
ERANGE	int
)	O
)	O
{	O
if	O
(	O
result	*(int)
)	O
{	O
*	O
result	*(int)
=	O
1	int
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: strtoul error when converting [%s]\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
nptr	*(char)
)	O
;	O
}	O
return	O
ret	int
;	O
}	O
uintmax_t	long
*	O
*	O
swlib_pump_get_ppstatbytes	()->(*(*(long)))
(	O
void	O
)	O
{	O
return	O
&	O
g_pstatbytes	*(long)
;	O
}	O
intmax_t	long
swlib_pump_amount8	(int,int,long,int,*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short)))->(long)
(	O
int	O
ofd	int
,	O
int	O
ifd	int
,	O
intmax_t	long
amount	long
,	O
int	O
adjunct_ofd	int
,	O
FILE_DIGS	struct(int,array(char),short,array(char),short,array(char),short,array(char),short)
*	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
)	O
{	O
intmax_t	long
n	long
;	O
n	long
=	O
swlib_i_digs_copy	(int,int,long,*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short)),int,*((int,*(void),long)->(long)))->(long)
(	O
ofd	int
,	O
ifd	int
,	O
amount	long
,	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
,	O
adjunct_ofd	int
,	O
taru_tape_buffered_read	(int,*(void),long)->(long)
)	O
;	O
return	O
n	long
;	O
}	O
struct	O
timespec	struct(long,long)
*	O
swlib_get_io_req	()->(*(struct(long,long)))
(	O
void	O
)	O
{	O
return	O
io_req	*(struct(long,long))
;	O
}	O
int	O
*	O
swlib_burst_adjust_p	()->(*(int))
(	O
void	O
)	O
{	O
return	O
&	O
g_burst_adjust	int
;	O
}	O
struct	O
timespec	struct(long,long)
*	O
*	O
swlib_get_io_req_p	()->(*(*(struct(long,long))))
(	O
void	O
)	O
{	O
return	O
&	O
io_req	*(struct(long,long))
;	O
}	O
int	O
swlib_test_verbose	(*(struct(*(char),int,int,*(char),int,int)),int,int,int,int,int)->(int)
(	O
struct	O
swEvents	struct(*(char),int,int,*(char),int,int)
*	O
ev	*(char)
,	O
int	O
verbose_level	int
,	O
int	O
swbis_event	int
,	O
int	O
is_swi_event	int
,	O
int	O
event_status	int
,	O
int	O
is_posix_event	int
)	O
{	O
if	O
(	O
(	O
ev	*(char)
&&	O
(	O
verbose_level	int
>=	O
ev	*(char)
->	O
verbose_threshholdM	int
)	O
)	O
||	O
(	O
verbose_level	int
>=	O
SWC_VERBOSE_1	int
&&	O
event_status	int
!=	O
0	int
)	O
||	O
(	O
verbose_level	int
>=	O
SWC_VERBOSE_3	int
&&	O
is_posix_event	int
)	O
||	O
(	O
verbose_level	int
>=	O
verbose_swbis_event_thresholdG	int
&&	O
swbis_event	int
)	O
||	O
(	O
verbose_level	int
>=	O
SWC_VERBOSE_6	int
&&	O
is_swi_event	int
)	O
||	O
(	O
verbose_level	int
>=	O
verbose_swbis_event_thresholdG	int
&&	O
!	O
is_swi_event	int
)	O
)	O
{	O
return	O
1	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
int	O
swlib_get_verbose_level	()->(int)
(	O
void	O
)	O
{	O
return	O
verbose_levelG	int
;	O
}	O
void	O
swlib_set_verbose_level	(int)->(void)
(	O
int	O
n	long
)	O
{	O
verbose_levelG	int
=	O
n	long
;	O
}	O
intmax_t	long
swlib_i_pipe_pump	(int,int,*(long),int,*(struct(*(char),*(char),int,int,int,char,int)),*((int,*(void),long)->(long)))->(long)
(	O
int	O
suction_fd	int
,	O
int	O
discharge_fd	int
,	O
intmax_t	long
*	O
amount	long
,	O
int	O
adjunct_ofd	int
,	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
obuf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
ssize_t	long
(	O
*	O
thisfpread	*((int,*(void),long)->(long))
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
{	O
int	O
commandFailed	int
=	O
0	int
;	O
int	O
pumpDead	int
=	O
0	int
;	O
int	O
bytes	int
;	O
int	O
ibytes	int
;	O
intmax_t	long
byteswritten	int
=	O
0	int
;	O
intmax_t	long
remains	int
;	O
intmax_t	long
c_amount	int
;	O
char	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
[	O
SWLIB_PIPE_BUF	int
]	O
;	O
int	O
sleepbytes	*(int)
=	O
0	int
;	O
if	O
(	O
obuf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
obuf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
""	*(char)
)	O
;	O
}	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
c_amount	int
=	O
*	O
amount	long
;	O
if	O
(	O
c_amount	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
do	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
bytes	int
=	O
(	O
*	O
thisfpread	*((int,*(void),long)->(long))
)	O
(	O
suction_fd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
sizeof	O
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
;	O
if	O
(	O
bytes	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
commandFailed	int
=	O
1	int
;	O
pumpDead	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
bytes	int
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
pumpDead	int
=	O
1	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
if	O
(	O
discharge_fd	int
>=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
if	O
(	O
uxfio_write	(int,*(void),long)->(long)
(	O
discharge_fd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
bytes	int
)	O
!=	O
bytes	int
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
commandFailed	int
=	O
2	int
;	O
pumpDead	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
adjunct_ofd	int
>=	O
0	int
)	O
{	O
if	O
(	O
uxfio_write	(int,*(void),long)->(long)
(	O
adjunct_ofd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
bytes	int
)	O
!=	O
bytes	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
commandFailed	int
=	O
3	int
;	O
pumpDead	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
obuf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
strob_memcpy_at	(*(struct(*(char),*(char),int,int,int,char,int)),long,*(void),long)->(*(void))
(	O
obuf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
(	O
size_t	long
)	O
byteswritten	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
(	O
size_t	long
)	O
(	O
bytes	int
)	O
)	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
byteswritten	int
+=	O
bytes	int
;	O
if	O
(	O
io_req	*(struct(long,long))
&&	O
io_req	*(struct(long,long))
->	O
tv_nsec	long
)	O
{	O
sleepbytes	*(int)
+=	O
bytes	int
;	O
delay_sleep_pattern2	(*(struct(long,long)),*(int),int,int)->(void)
(	O
io_req	*(struct(long,long))
,	O
&	O
sleepbytes	*(int)
,	O
c_amount	int
,	O
byteswritten	int
)	O
;	O
}	O
}	O
while	O
(	O
!	O
pumpDead	int
)	O
;	O
if	O
(	O
obuf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
strob_append_hidden_null	(*(struct(*(char),*(char),int,int,int,char,int)))->(void)
(	O
obuf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
*	O
amount	long
=	O
byteswritten	int
;	O
return	O
commandFailed	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
remains	int
=	O
sizeof	O
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
if	O
(	O
(	O
c_amount	int
-	O
byteswritten	int
)	O
<	O
remains	int
)	O
{	O
remains	int
=	O
c_amount	int
-	O
byteswritten	int
;	O
}	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
do	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
bytes	int
=	O
(	O
*	O
thisfpread	*((int,*(void),long)->(long))
)	O
(	O
suction_fd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
remains	int
)	O
;	O
if	O
(	O
bytes	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
commandFailed	int
=	O
1	int
;	O
pumpDead	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
bytes	int
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
pumpDead	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
bytes	int
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
if	O
(	O
discharge_fd	int
>=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
ibytes	int
=	O
uxfio_write	(int,*(void),long)->(long)
(	O
discharge_fd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
bytes	int
)	O
;	O
if	O
(	O
adjunct_ofd	int
>=	O
0	int
)	O
{	O
ibytes	int
=	O
uxfio_write	(int,*(void),long)->(long)
(	O
adjunct_ofd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
bytes	int
)	O
;	O
}	O
}	O
else	O
{	O
ibytes	int
=	O
bytes	int
;	O
}	O
if	O
(	O
obuf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
strob_memcpy_at	(*(struct(*(char),*(char),int,int,int,char,int)),long,*(void),long)->(*(void))
(	O
obuf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
(	O
size_t	long
)	O
byteswritten	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
(	O
size_t	long
)	O
(	O
bytes	int
)	O
)	O
;	O
}	O
if	O
(	O
ibytes	int
!=	O
bytes	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
commandFailed	int
=	O
2	int
;	O
pumpDead	int
=	O
1	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
byteswritten	int
+=	O
bytes	int
;	O
if	O
(	O
(	O
c_amount	int
-	O
byteswritten	int
)	O
<	O
remains	int
)	O
{	O
if	O
(	O
(	O
remains	int
=	O
c_amount	int
-	O
byteswritten	int
)	O
>	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
)	O
{	O
remains	int
=	O
sizeof	O
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
io_req	*(struct(long,long))
&&	O
io_req	*(struct(long,long))
->	O
tv_nsec	long
)	O
{	O
sleepbytes	*(int)
+=	O
bytes	int
;	O
delay_sleep_pattern2	(*(struct(long,long)),*(int),int,int)->(void)
(	O
io_req	*(struct(long,long))
,	O
&	O
sleepbytes	*(int)
,	O
c_amount	int
,	O
byteswritten	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
}	O
while	O
(	O
!	O
pumpDead	int
&&	O
remains	int
)	O
;	O
*	O
amount	long
=	O
byteswritten	int
;	O
if	O
(	O
obuf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
strob_append_hidden_null	(*(struct(*(char),*(char),int,int,int,char,int)))->(void)
(	O
obuf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
return	O
commandFailed	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
swlib_is_ascii_noaccept	(*(char),*(char),int)->(int)
(	O
char	O
*	O
str	*(char)
,	O
char	O
*	O
acc	*(char)
,	O
int	O
minlen	int
)	O
{	O
unsigned	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
int	O
ret	int
;	O
if	O
(	O
!	O
str	*(char)
||	O
(	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
<	O
minlen	int
)	O
)	O
return	O
1	int
;	O
ret	int
=	O
strpbrk	(*(char),*(char))->(*(char))
(	O
str	*(char)
,	O
acc	*(char)
)	O
?	O
1	int
:	O
0	int
;	O
if	O
(	O
ret	int
)	O
return	O
ret	int
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
(	O
unsigned	O
char	O
*	O
)	O
str	*(char)
;	O
while	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
&&	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
>	O
126	int
||	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
<	O
33	int
)	O
{	O
return	O
1	int
;	O
}	O
s	*(struct(*(char),*(char),int,int,int,char,int))
++	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
swlib_tr	(*(char),int,int)->(int)
(	O
char	O
*	O
src	*(char)
,	O
int	O
to	int
,	O
int	O
from	int
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
char	O
*	O
p1	*(char)
;	O
p1	*(char)
=	O
src	*(char)
;	O
while	O
(	O
*	O
(	O
p1	*(char)
++	O
)	O
)	O
{	O
if	O
(	O
*	O
(	O
p1	*(char)
-	O
1	int
)	O
==	O
from	int
)	O
{	O
*	O
(	O
p1	*(char)
-	O
1	int
)	O
=	O
to	int
;	O
ret	int
++	O
;	O
}	O
}	O
return	O
ret	int
;	O
}	O
int	O
swlib_check_safe_path	(*(char))->(int)
(	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
!	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
return	O
1	int
;	O
if	O
(	O
!	O
strlen	(*(char))->(long)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
return	O
5	int
;	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
".."	*(char)
)	O
)	O
return	O
6	int
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
' '	O
)	O
)	O
return	O
7	int
;	O
return	O
swlib_is_sh_tainted_string	(*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
int	O
swlib_check_clean_path	(*(char))->(int)
(	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
!	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
return	O
1	int
;	O
if	O
(	O
!	O
strlen	(*(char))->(long)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
return	O
2	int
;	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"//"	*(char)
)	O
)	O
return	O
3	int
;	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
".."	*(char)
)	O
)	O
return	O
4	int
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
' '	O
)	O
)	O
return	O
5	int
;	O
if	O
(	O
swlib_is_sh_tainted_string	(*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
return	O
6	int
;	O
return	O
strpbrk	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
SWBIS_WS_TAINTED_CHARS	*(char)
)	O
?	O
7	int
:	O
0	int
;	O
}	O
int	O
swlib_check_clean_absolute_path	(*(char))->(int)
(	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
!	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
return	O
1	int
;	O
if	O
(	O
!	O
strlen	(*(char))->(long)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
return	O
2	int
;	O
if	O
(	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
!=	O
'/'	O
)	O
return	O
3	int
;	O
return	O
swlib_check_clean_path	(*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
int	O
swlib_check_clean_relative_path	(*(char))->(int)
(	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
!	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
return	O
1	int
;	O
if	O
(	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
==	O
'/'	O
)	O
return	O
2	int
;	O
return	O
swlib_check_clean_path	(*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
int	O
swlib_check_legal_tag_value	(*(char))->(int)
(	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
!	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
return	O
0	int
;	O
return	O
strpbrk	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
":.,"	*(char)
)	O
?	O
1	int
:	O
0	int
;	O
}	O
int	O
swlib_is_sh_tainted_string	(*(char))->(int)
(	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
!	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
return	O
0	int
;	O
return	O
strpbrk	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
SWBIS_TAINTED_CHARS	*(char)
)	O
?	O
1	int
:	O
0	int
;	O
}	O
void	O
swlib_is_sh_tainted_string_fatal	(*(char))->(void)
(	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
!	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
return	O
;	O
if	O
(	O
strpbrk	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
SWBIS_TAINTED_CHARS	*(char)
)	O
?	O
1	int
:	O
0	int
)	O
{	O
SWLIB_FATAL	O
(	O
"tainted string"	*(char)
)	O
;	O
}	O
return	O
;	O
}	O
ssize_t	long
swlib_safe_read	(int,*(void),long)->(long)
(	O
int	O
fd	int
,	O
void	O
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
size_t	long
nbyte	long
)	O
{	O
int	O
n	long
=	O
0	int
,	O
nret	int
=	O
1	int
;	O
char	O
*	O
p	*(char)
=	O
(	O
char	O
*	O
)	O
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
while	O
(	O
n	long
<	O
(	O
int	O
)	O
nbyte	long
&&	O
nret	int
)	O
{	O
nret	int
=	O
uxfio_read	(int,*(void),long)->(long)
(	O
fd	int
,	O
p	*(char)
+	O
n	long
,	O
nbyte	long
-	O
n	long
)	O
;	O
if	O
(	O
nret	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
||	O
errno	O
==	O
EAGAIN	int
)	O
{	O
continue	O
;	O
}	O
return	O
nret	int
;	O
}	O
n	long
+=	O
nret	int
;	O
}	O
return	O
n	long
;	O
}	O
void	O
swlib_swprog_assert	(int,int,*(char),*(char),*(char),int,*(char))->(void)
(	O
int	O
error_code	int
,	O
int	O
status	int
,	O
char	O
*	O
reason	*(char)
,	O
char	O
*	O
version	array(char)
,	O
char	O
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
line	*(char)
,	O
char	O
*	O
function	*(char)
)	O
{	O
if	O
(	O
error_code	int
!=	O
0	int
&&	O
error_code	int
<	O
SWBIS_PROGS_USER_ERROR	int
&&	O
error_code	int
>=	O
SWBIS_PROGS_IMPLEMENTATION_ERROR	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: Error: code=[%d] : %s: version=[%s] file=[%s] line=[%d]\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
error_code	int
,	O
reason	*(char)
,	O
version	array(char)
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
line	*(char)
)	O
;	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
else	O
if	O
(	O
error_code	int
!=	O
0	int
&&	O
error_code	int
>=	O
SWBIS_PROGS_USER_ERROR	int
)	O
{	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
else	O
if	O
(	O
error_code	int
!=	O
0	int
&&	O
error_code	int
<	O
SWBIS_PROGS_IMPLEMENTATION_ERROR	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Internal Informative Warning: code=%d : %s version=[%s]"	*(char)
", file=[%s], line=[%d]\n"	*(char)
,	O
error_code	int
,	O
reason	*(char)
,	O
version	array(char)
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
line	*(char)
)	O
;	O
}	O
}	O
void	O
swlib_exception	(*(char),*(char),int,*(char))->(void)
(	O
char	O
*	O
reason	*(char)
,	O
char	O
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
line	*(char)
,	O
char	O
*	O
function	*(char)
)	O
{	O
e_msg	(*(char),*(char),*(char),int,*(char))->(void)
(	O
"program exception"	*(char)
,	O
reason	*(char)
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
line	*(char)
,	O
function	*(char)
)	O
;	O
}	O
void	O
swlib_internal_error	(*(char),*(char),int,*(char))->(void)
(	O
char	O
*	O
reason	*(char)
,	O
char	O
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
line	*(char)
,	O
char	O
*	O
function	*(char)
)	O
{	O
e_msg	(*(char),*(char),*(char),int,*(char))->(void)
(	O
"internal implementation error"	*(char)
,	O
reason	*(char)
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
line	*(char)
,	O
function	*(char)
)	O
;	O
}	O
void	O
swlib_resource	(*(char),*(char),int,*(char))->(void)
(	O
char	O
*	O
reason	*(char)
,	O
char	O
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
line	*(char)
,	O
char	O
*	O
function	*(char)
)	O
{	O
e_msg	(*(char),*(char),*(char),int,*(char))->(void)
(	O
"resource exception"	*(char)
,	O
reason	*(char)
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
line	*(char)
,	O
function	*(char)
)	O
;	O
}	O
void	O
swlib_fatal	(*(char),*(char),int,*(char))->(void)
(	O
char	O
*	O
reason	*(char)
,	O
char	O
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
line	*(char)
,	O
char	O
*	O
function	*(char)
)	O
{	O
e_msg	(*(char),*(char),*(char),int,*(char))->(void)
(	O
"fatal error"	*(char)
,	O
reason	*(char)
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
line	*(char)
,	O
function	*(char)
)	O
;	O
exit	(int)->(void)
(	O
252	int
)	O
;	O
}	O
void	O
swlib_assertion_fatal	(int,*(char),*(char),int,*(char))->(void)
(	O
int	O
assertion_result	int
,	O
char	O
*	O
reason	*(char)
,	O
char	O
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
line	*(char)
,	O
char	O
*	O
function	*(char)
)	O
{	O
if	O
(	O
assertion_result	int
==	O
0	int
)	O
swlib_fatal	(*(char),*(char),int,*(char))->(void)
(	O
reason	*(char)
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
line	*(char)
,	O
function	*(char)
)	O
;	O
}	O
int	O
swlib_squash_trailing_char	(*(char),char)->(int)
(	O
char	O
*	O
path	*(char)
,	O
char	O
ch	int
)	O
{	O
return	O
squash_trailing_char	(*(char),char,int)->(int)
(	O
path	*(char)
,	O
ch	int
,	O
0	int
)	O
;	O
}	O
void	O
swlib_squash_all_trailing_vnewline	(*(char))->(void)
(	O
char	O
*	O
path	*(char)
)	O
{	O
while	O
(	O
1	int
)	O
if	O
(	O
squash_trailing_char	(*(char),char,int)->(int)
(	O
path	*(char)
,	O
'\n'	O
,	O
0	int
)	O
==	O
0	int
)	O
{	O
squash_trailing_char	(*(char),char,int)->(int)
(	O
path	*(char)
,	O
'\r'	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
void	O
swlib_squash_trailing_vnewline	(*(char))->(void)
(	O
char	O
*	O
path	*(char)
)	O
{	O
squash_trailing_char	(*(char),char,int)->(int)
(	O
path	*(char)
,	O
'\r'	O
,	O
0	int
)	O
;	O
squash_trailing_char	(*(char),char,int)->(int)
(	O
path	*(char)
,	O
'\n'	O
,	O
0	int
)	O
;	O
}	O
void	O
swlib_squash_trailing_slash	(*(char))->(void)
(	O
char	O
*	O
path	*(char)
)	O
{	O
squash_trailing_char	(*(char),char,int)->(int)
(	O
path	*(char)
,	O
'/'	O
,	O
1	int
)	O
;	O
return	O
;	O
}	O
void	O
swlib_squash_embedded_dot_slash	(*(char))->(void)
(	O
char	O
*	O
path	*(char)
)	O
{	O
char	O
*	O
p1	*(char)
;	O
p1	*(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
path	*(char)
,	O
"/./"	*(char)
)	O
;	O
if	O
(	O
p1	*(char)
&&	O
p1	*(char)
!=	O
path	*(char)
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
p1	*(char)
+	O
1	int
,	O
p1	*(char)
+	O
3	int
,	O
strlen	(*(char))->(long)
(	O
p1	*(char)
+	O
2	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
p1	*(char)
&&	O
p1	*(char)
==	O
path	*(char)
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
p1	*(char)
+	O
1	int
,	O
p1	*(char)
+	O
3	int
,	O
strlen	(*(char))->(long)
(	O
p1	*(char)
+	O
2	int
)	O
)	O
;	O
}	O
}	O
void	O
swlib_squash_double_slash	(*(char))->(void)
(	O
char	O
*	O
path	*(char)
)	O
{	O
char	O
*	O
p1	*(char)
;	O
while	O
(	O
(	O
p1	*(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
path	*(char)
,	O
"//"	*(char)
)	O
)	O
!=	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
)	O
memmove	(*(void),*(void),long)->(*(void))
(	O
p1	*(char)
,	O
p1	*(char)
+	O
1	int
,	O
strlen	(*(char))->(long)
(	O
p1	*(char)
)	O
)	O
;	O
}	O
char	O
*	O
swlib_return_no_leading	(*(char))->(*(char))
(	O
char	O
*	O
path	*(char)
)	O
{	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
if	O
(	O
(	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strstr	(*(char),*(char))->(*(char))
(	O
path	*(char)
,	O
"/"	*(char)
)	O
)	O
==	O
path	*(char)
)	O
&&	O
1	int
)	O
return	O
++	O
path	*(char)
;	O
if	O
(	O
(	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strstr	(*(char),*(char))->(*(char))
(	O
path	*(char)
,	O
"./"	*(char)
)	O
)	O
==	O
path	*(char)
)	O
&&	O
1	int
)	O
return	O
path	*(char)
+=	O
2	int
;	O
return	O
path	*(char)
;	O
}	O
void	O
swlib_squash_all_dot_slash	(*(char))->(void)
(	O
char	O
*	O
path	*(char)
)	O
{	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
swlib_squash_leading_dot_slash	(*(char))->(void)
(	O
path	*(char)
)	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strstr	(*(char),*(char))->(*(char))
(	O
path	*(char)
,	O
"/./"	*(char)
)	O
;	O
while	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
swlib_squash_embedded_dot_slash	(*(char))->(void)
(	O
path	*(char)
)	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strstr	(*(char),*(char))->(*(char))
(	O
path	*(char)
,	O
"/./"	*(char)
)	O
;	O
}	O
}	O
void	O
swlib_squash_leading_dot_slash	(*(char))->(void)
(	O
char	O
*	O
path	*(char)
)	O
{	O
char	O
*	O
p1	*(char)
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
path	*(char)
)	O
>=	O
3	int
)	O
{	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
path	*(char)
,	O
"./"	*(char)
,	O
2	int
)	O
)	O
{	O
p1	*(char)
=	O
path	*(char)
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
p1	*(char)
,	O
p1	*(char)
+	O
2	int
,	O
strlen	(*(char))->(long)
(	O
p1	*(char)
+	O
1	int
)	O
)	O
;	O
}	O
}	O
}	O
void	O
swlib_toggle_trailing_slashdot	(*(char),*(char),*(int))->(void)
(	O
char	O
*	O
mode	array(char)
,	O
char	O
*	O
name	array(char)
,	O
int	O
*	O
pflag	*(int)
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
mode	array(char)
,	O
"drop"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
<	O
2	int
)	O
{	O
*	O
pflag	*(int)
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
name	array(char)
+	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
-	O
2	int
,	O
"/."	*(char)
)	O
==	O
0	int
)	O
{	O
*	O
(	O
name	array(char)
+	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
-	O
2	int
)	O
=	O
'\0'	O
;	O
*	O
pflag	*(int)
=	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
pflag	*(int)
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
name	array(char)
,	O
"/."	*(char)
)	O
;	O
*	O
pflag	*(int)
=	O
0	int
;	O
}	O
}	O
}	O
void	O
swlib_toggle_leading_dotslash	(*(char),*(char),*(int))->(void)
(	O
char	O
*	O
mode	array(char)
,	O
char	O
*	O
name	array(char)
,	O
int	O
*	O
pflag	*(int)
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
mode	array(char)
,	O
"drop"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
<	O
2	int
)	O
{	O
*	O
pflag	*(int)
=	O
0	int
;	O
return	O
;	O
}	O
else	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
name	array(char)
,	O
"./"	*(char)
,	O
2	int
)	O
==	O
0	int
&&	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
>	O
2	int
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
name	array(char)
,	O
name	array(char)
+	O
2	int
,	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
-	O
1	int
)	O
;	O
*	O
pflag	*(int)
=	O
1	int
;	O
}	O
else	O
{	O
*	O
pflag	*(int)
=	O
0	int
;	O
return	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
pflag	*(int)
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
name	array(char)
,	O
"."	*(char)
)	O
==	O
0	int
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
name	array(char)
,	O
"/"	*(char)
)	O
;	O
}	O
else	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
name	array(char)
+	O
2	int
,	O
name	array(char)
,	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
+	O
1	int
)	O
;	O
*	O
name	array(char)
=	O
'.'	O
;	O
*	O
(	O
name	array(char)
+	O
1	int
)	O
=	O
'/'	O
;	O
*	O
pflag	*(int)
=	O
0	int
;	O
}	O
}	O
}	O
}	O
void	O
swlib_toggle_trailing_slash	(*(char),*(char),*(int))->(void)
(	O
char	O
*	O
mode	array(char)
,	O
char	O
*	O
name	array(char)
,	O
int	O
*	O
pflag	*(int)
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
mode	array(char)
,	O
"drop"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
>	O
1	int
&&	O
name	array(char)
[	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
-	O
1	int
]	O
==	O
'/'	O
)	O
{	O
name	array(char)
[	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
*	O
pflag	*(int)
=	O
1	int
;	O
}	O
else	O
{	O
*	O
pflag	*(int)
=	O
0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
pflag	*(int)
)	O
{	O
name	array(char)
[	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
]	O
=	O
'/'	O
;	O
}	O
}	O
}	O
void	O
swlib_squash_leading_slash	(*(char))->(void)
(	O
char	O
*	O
name	array(char)
)	O
{	O
if	O
(	O
*	O
name	array(char)
==	O
'/'	O
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
name	array(char)
,	O
name	array(char)
+	O
1	int
,	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
)	O
;	O
}	O
}	O
char	O
*	O
swlib_return_relative_path	(*(char))->(*(char))
(	O
char	O
*	O
path	*(char)
)	O
{	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
path	*(char)
;	O
while	O
(	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
==	O
'/'	O
)	O
s	*(struct(*(char),*(char),int,int,int,char,int))
++	O
;	O
return	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
}	O
void	O
swlib_squash_all_leading_slash	(*(char))->(void)
(	O
char	O
*	O
name	array(char)
)	O
{	O
int	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
int	O
i	int
;	O
if	O
(	O
!	O
name	array(char)
)	O
return	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
;	O
i	int
=	O
(	O
*	O
name	array(char)
==	O
'/'	O
)	O
;	O
while	O
(	O
*	O
name	array(char)
==	O
'/'	O
)	O
swlib_squash_leading_slash	(*(char))->(void)
(	O
name	array(char)
)	O
;	O
if	O
(	O
i	int
&&	O
s	*(struct(*(char),*(char),int,int,int,char,int))
&&	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
==	O
0	int
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
name	array(char)
,	O
"."	*(char)
)	O
;	O
}	O
}	O
void	O
swlib_toggle_leading_slash	(*(char),*(char),*(int))->(void)
(	O
char	O
*	O
mode	array(char)
,	O
char	O
*	O
name	array(char)
,	O
int	O
*	O
pflag	*(int)
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
mode	array(char)
,	O
"drop"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
*	O
name	array(char)
==	O
'/'	O
&&	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
>	O
1	int
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
name	array(char)
,	O
name	array(char)
+	O
1	int
,	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
)	O
;	O
*	O
pflag	*(int)
=	O
1	int
;	O
}	O
else	O
{	O
*	O
pflag	*(int)
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
mode	array(char)
,	O
"restore"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
*	O
pflag	*(int)
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
name	array(char)
+	O
1	int
,	O
name	array(char)
,	O
strlen	(*(char))->(long)
(	O
name	array(char)
)	O
+	O
1	int
)	O
;	O
*	O
name	array(char)
=	O
'/'	O
;	O
*	O
pflag	*(int)
=	O
0	int
;	O
}	O
}	O
}	O
void	O
swlib_slashclean	(*(char))->(void)
(	O
char	O
*	O
path	*(char)
)	O
{	O
swlib_squash_double_slash	(*(char))->(void)
(	O
path	*(char)
)	O
;	O
swlib_squash_leading_dot_slash	(*(char))->(void)
(	O
path	*(char)
)	O
;	O
swlib_squash_trailing_slash	(*(char))->(void)
(	O
path	*(char)
)	O
;	O
return	O
;	O
}	O
int	O
swlib_process_hex_escapes	(*(char))->(int)
(	O
char	O
*	O
s1	*(char)
)	O
{	O
process_all_hex_escapes	(*(char))->(void)
(	O
s1	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swlib_compare_8859	(*(char),*(char))->(int)
(	O
char	O
*	O
s1	*(char)
,	O
char	O
*	O
s2	*(char)
)	O
{	O
int	O
ret	int
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
so1	*(struct(*(char),*(char),int,int,int,char,int))
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
so2	*(struct(*(char),*(char),int,int,int,char,int))
;	O
so1	*(struct(*(char),*(char),int,int,int,char,int))
=	O
NULL	O
;	O
so2	*(struct(*(char),*(char),int,int,int,char,int))
=	O
NULL	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
s1	*(char)
,	O
'\\'	O
)	O
!=	O
NULL	O
)	O
{	O
E_DEBUG2	O
(	O
"unexpanding S1 [%s]"	*(char)
,	O
s2	*(char)
)	O
;	O
so1	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
strlen	(*(char))->(long)
(	O
s1	*(char)
)	O
)	O
;	O
swlib_unexpand_escapes	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(int)
(	O
so1	*(struct(*(char),*(char),int,int,int,char,int))
,	O
s1	*(char)
)	O
;	O
s1	*(char)
=	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
so1	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
process_all_hex_escapes	(*(char))->(void)
(	O
s1	*(char)
)	O
;	O
}	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
s2	*(char)
,	O
'\\'	O
)	O
!=	O
NULL	O
)	O
{	O
E_DEBUG2	O
(	O
"unexpanding S2 [%s]"	*(char)
,	O
s2	*(char)
)	O
;	O
so2	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
strlen	(*(char))->(long)
(	O
s2	*(char)
)	O
)	O
;	O
swlib_unexpand_escapes	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(int)
(	O
so2	*(struct(*(char),*(char),int,int,int,char,int))
,	O
s2	*(char)
)	O
;	O
s2	*(char)
=	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
so2	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
process_all_hex_escapes	(*(char))->(void)
(	O
s2	*(char)
)	O
;	O
}	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
s1	*(char)
,	O
'#'	O
)	O
||	O
strchr	(*(char),int)->(*(char))
(	O
s2	*(char)
,	O
'#'	O
)	O
)	O
{	O
E_DEBUG3	O
(	O
"Comparing [%s] [%s]"	*(char)
,	O
s1	*(char)
,	O
s2	*(char)
)	O
;	O
}	O
ret	int
=	O
swlib_dir_compare	(*(char),*(char),int)->(int)
(	O
s1	*(char)
,	O
s2	*(char)
,	O
SWC_FC_NOAB	int
)	O
;	O
if	O
(	O
so1	*(struct(*(char),*(char),int,int,int,char,int))
)	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
so1	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
if	O
(	O
so2	*(struct(*(char),*(char),int,int,int,char,int))
)	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
so2	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_vrelpath_compare	(*(char),*(char),*(char))->(int)
(	O
char	O
*	O
s1	*(char)
,	O
char	O
*	O
s2	*(char)
,	O
char	O
*	O
cwd	short
)	O
{	O
if	O
(	O
(	O
(	O
*	O
s1	*(char)
!=	O
'/'	O
)	O
&&	O
(	O
*	O
s2	*(char)
!=	O
'/'	O
)	O
)	O
||	O
(	O
(	O
*	O
s1	*(char)
==	O
'/'	O
)	O
&&	O
(	O
*	O
s2	*(char)
==	O
'/'	O
)	O
)	O
)	O
{	O
return	O
swlib_dir_compare	(*(char),*(char),int)->(int)
(	O
s1	*(char)
,	O
s2	*(char)
,	O
SWC_FC_NOOP	int
)	O
;	O
}	O
else	O
{	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
100	int
)	O
;	O
if	O
(	O
form_abspath	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
s1	*(char)
,	O
cwd	short
)	O
==	O
0	int
)	O
{	O
return	O
swlib_dir_compare	(*(char),*(char),int)->(int)
(	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
,	O
s2	*(char)
,	O
SWC_FC_NOOP	int
)	O
;	O
}	O
else	O
if	O
(	O
form_abspath	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
s2	*(char)
,	O
cwd	short
)	O
==	O
0	int
)	O
{	O
return	O
swlib_dir_compare	(*(char),*(char),int)->(int)
(	O
s1	*(char)
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
,	O
SWC_FC_NOOP	int
)	O
;	O
}	O
else	O
{	O
SWLIB_ALLOC_ASSERT	O
(	O
0	int
)	O
;	O
;	O
}	O
}	O
SWLIB_ALLOC_ASSERT	O
(	O
0	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
int	O
swlib_basename_compare	(*(char),*(char))->(int)
(	O
char	O
*	O
s1	*(char)
,	O
char	O
*	O
s2	*(char)
)	O
{	O
char	O
*	O
s1b	*(char)
;	O
char	O
*	O
s2b	*(char)
;	O
int	O
ret	int
;	O
s1b	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
s1	*(char)
,	O
'/'	O
)	O
;	O
s2b	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
s2	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
s1b	*(char)
&&	O
strlen	(*(char))->(long)
(	O
s1	*(char)
)	O
&&	O
*	O
(	O
s1b	*(char)
+	O
1	int
)	O
)	O
{	O
s1	*(char)
=	O
s1b	*(char)
+	O
1	int
;	O
}	O
if	O
(	O
s2b	*(char)
&&	O
strlen	(*(char))->(long)
(	O
s2	*(char)
)	O
&&	O
*	O
(	O
s2b	*(char)
+	O
1	int
)	O
)	O
{	O
s2	*(char)
=	O
s2b	*(char)
+	O
1	int
;	O
}	O
ret	int
=	O
swlib_dir_compare	(*(char),*(char),int)->(int)
(	O
s1	*(char)
,	O
s2	*(char)
,	O
SWC_FC_NOOP	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_dir_compare	(*(char),*(char),int)->(int)
(	O
char	O
*	O
s1	*(char)
,	O
char	O
*	O
s2	*(char)
,	O
int	O
FC_compare_flag	int
)	O
{	O
int	O
ret	int
;	O
int	O
leading_p1	int
=	O
0	int
;	O
int	O
leading_p2	int
=	O
0	int
;	O
int	O
leading_d1	int
=	O
0	int
;	O
int	O
leading_d2	int
=	O
0	int
;	O
int	O
trailing_p1	int
=	O
0	int
;	O
int	O
trailing_d1	int
=	O
0	int
;	O
int	O
trailing_p2	int
=	O
0	int
;	O
int	O
trailing_d2	int
=	O
0	int
;	O
if	O
(	O
FC_compare_flag	int
==	O
SWC_FC_NOAB	int
)	O
{	O
swlib_toggle_leading_slash	(*(char),*(char),*(int))->(void)
(	O
"drop"	*(char)
,	O
s1	*(char)
,	O
&	O
leading_p1	int
)	O
;	O
swlib_toggle_leading_slash	(*(char),*(char),*(int))->(void)
(	O
"drop"	*(char)
,	O
s2	*(char)
,	O
&	O
leading_p2	int
)	O
;	O
}	O
else	O
if	O
(	O
FC_compare_flag	int
==	O
SWC_FC_NORE	int
)	O
{	O
;	O
}	O
else	O
{	O
;	O
}	O
swlib_toggle_trailing_slash	(*(char),*(char),*(int))->(void)
(	O
"drop"	*(char)
,	O
s1	*(char)
,	O
&	O
trailing_p1	int
)	O
;	O
swlib_toggle_trailing_slash	(*(char),*(char),*(int))->(void)
(	O
"drop"	*(char)
,	O
s2	*(char)
,	O
&	O
trailing_p2	int
)	O
;	O
swlib_toggle_trailing_slashdot	(*(char),*(char),*(int))->(void)
(	O
"drop"	*(char)
,	O
s1	*(char)
,	O
&	O
trailing_d1	int
)	O
;	O
swlib_toggle_trailing_slashdot	(*(char),*(char),*(int))->(void)
(	O
"drop"	*(char)
,	O
s2	*(char)
,	O
&	O
trailing_d2	int
)	O
;	O
swlib_toggle_leading_dotslash	(*(char),*(char),*(int))->(void)
(	O
"drop"	*(char)
,	O
s1	*(char)
,	O
&	O
leading_d1	int
)	O
;	O
swlib_toggle_leading_dotslash	(*(char),*(char),*(int))->(void)
(	O
"drop"	*(char)
,	O
s2	*(char)
,	O
&	O
leading_d2	int
)	O
;	O
ret	int
=	O
strcmp	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
s2	*(char)
)	O
;	O
swlib_toggle_leading_dotslash	(*(char),*(char),*(int))->(void)
(	O
"restore"	*(char)
,	O
s1	*(char)
,	O
&	O
leading_d1	int
)	O
;	O
swlib_toggle_leading_dotslash	(*(char),*(char),*(int))->(void)
(	O
"restore"	*(char)
,	O
s2	*(char)
,	O
&	O
leading_d2	int
)	O
;	O
swlib_toggle_trailing_slashdot	(*(char),*(char),*(int))->(void)
(	O
"restore"	*(char)
,	O
s1	*(char)
,	O
&	O
trailing_d1	int
)	O
;	O
swlib_toggle_trailing_slashdot	(*(char),*(char),*(int))->(void)
(	O
"restore"	*(char)
,	O
s2	*(char)
,	O
&	O
trailing_d2	int
)	O
;	O
swlib_toggle_trailing_slash	(*(char),*(char),*(int))->(void)
(	O
"restore"	*(char)
,	O
s1	*(char)
,	O
&	O
trailing_p1	int
)	O
;	O
swlib_toggle_trailing_slash	(*(char),*(char),*(int))->(void)
(	O
"restore"	*(char)
,	O
s2	*(char)
,	O
&	O
trailing_p2	int
)	O
;	O
if	O
(	O
FC_compare_flag	int
==	O
SWC_FC_NOAB	int
)	O
{	O
swlib_toggle_leading_slash	(*(char),*(char),*(int))->(void)
(	O
"restore"	*(char)
,	O
s1	*(char)
,	O
&	O
leading_p1	int
)	O
;	O
swlib_toggle_leading_slash	(*(char),*(char),*(int))->(void)
(	O
"restore"	*(char)
,	O
s2	*(char)
,	O
&	O
leading_p2	int
)	O
;	O
}	O
else	O
if	O
(	O
FC_compare_flag	int
==	O
SWC_FC_NORE	int
)	O
{	O
;	O
}	O
else	O
{	O
;	O
}	O
return	O
ret	int
;	O
}	O
char	O
*	O
swlib_dirname	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
,	O
char	O
*	O
source	*(char)
)	O
{	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
,	O
source	*(char)
)	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strrchr	(*(char),int)->(*(char))
(	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
)	O
,	O
'/'	O
)	O
;	O
if	O
(	O
!	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"."	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
!=	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
'\0'	O
;	O
else	O
*	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
+	O
1	int
)	O
=	O
'\0'	O
;	O
}	O
return	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
char	O
*	O
swlib_basename	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
,	O
char	O
*	O
source	*(char)
)	O
{	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
if	O
(	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
==	O
NULL	O
)	O
{	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strrchr	(*(char),int)->(*(char))
(	O
source	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
!	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
return	O
source	*(char)
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
++	O
;	O
while	O
(	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
==	O
'/'	O
)	O
s	*(struct(*(char),*(char),int,int,int,char,int))
++	O
;	O
if	O
(	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
==	O
'\0'	O
)	O
{	O
if	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
>	O
source	*(char)
)	O
return	O
s	*(struct(*(char),*(char),int,int,int,char,int))
-	O
1	int
;	O
return	O
source	*(char)
;	O
}	O
return	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
}	O
else	O
{	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
,	O
source	*(char)
)	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
swlib_basename	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
NULL	O
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
)	O
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
strlen	(*(char))->(long)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
+	O
1	int
)	O
;	O
return	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
}	O
int	O
swlib_unix_dirtrunc	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
swlib_squash_trailing_slash	(*(char))->(void)
(	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
;	O
swlib_squash_all_dot_slash	(*(char))->(void)
(	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strrchr	(*(char),int)->(*(char))
(	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
,	O
'/'	O
)	O
;	O
if	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
==	O
NULL	O
||	O
s	*(struct(*(char),*(char),int,int,int,char,int))
==	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
||	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
==	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
+	O
1	int
&&	O
(	O
int	O
)	O
(	O
*	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
==	O
'.'	O
)	O
||	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
'\0'	O
;	O
return	O
1	int
;	O
}	O
int	O
swlib_unix_dirtrunc_n	(*(struct(*(char),*(char),int,int,int,char,int)),int)->(int)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
int	O
n	long
)	O
{	O
int	O
i	int
;	O
int	O
ret	int
;	O
i	int
=	O
n	long
;	O
while	O
(	O
i	int
>	O
0	int
)	O
{	O
ret	int
=	O
swlib_unix_dirtrunc	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
break	O
;	O
i	int
--	O
;	O
}	O
return	O
n	long
-	O
i	int
;	O
}	O
int	O
swlib_unix_dircat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(int)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
,	O
char	O
*	O
dirname	*(char)
)	O
{	O
char	O
*	O
newp	*(char)
;	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
if	O
(	O
!	O
dirname	*(char)
||	O
strlen	(*(char))->(long)
(	O
dirname	*(char)
)	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
{	O
if	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
[	O
strlen	(*(char))->(long)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
-	O
1	int
]	O
!=	O
'/'	O
)	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"/"	*(char)
)	O
;	O
}	O
newp	*(char)
=	O
swlib_strdup	(*(char))->(*(char))
(	O
dirname	*(char)
)	O
;	O
SWLIB_ALLOC_ASSERT	O
(	O
newp	*(char)
!=	O
NULL	O
)	O
;	O
if	O
(	O
strob_strlen	(*(struct(*(char),*(char),int,int,int,char,int)))->(long)
(	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
swlib_squash_leading_dot_slash	(*(char))->(void)
(	O
newp	*(char)
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
,	O
newp	*(char)
)	O
;	O
swlib_squash_double_slash	(*(char))->(void)
(	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
dest	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
;	O
swbis_free	O
(	O
newp	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swlib_resolve_path	(*(char),*(int),*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
char	O
*	O
ppath	*(char)
,	O
int	O
*	O
depth	*(int)
,	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
resolved_path	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
;	O
int	O
startnames	int
=	O
0	int
;	O
int	O
count	long
=	O
0	int
;	O
int	O
numcomponents	int
=	O
0	int
;	O
char	O
*	O
path	*(char)
=	O
swlib_strdup	(*(char))->(*(char))
(	O
ppath	*(char)
)	O
;	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
swlib_slashclean	(*(char))->(void)
(	O
path	*(char)
)	O
;	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
10	int
)	O
;	O
if	O
(	O
resolved_path	*(struct(*(char),*(char),int,int,int,char,int))
)	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
resolved_path	*(struct(*(char),*(char),int,int,int,char,int))
,	O
""	*(char)
)	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
path	*(char)
,	O
"/"	*(char)
)	O
;	O
while	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
".."	*(char)
)	O
==	O
0	int
&&	O
!	O
startnames	int
)	O
{	O
count	long
++	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"."	*(char)
)	O
==	O
0	int
)	O
{	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
".."	*(char)
)	O
==	O
0	int
&&	O
startnames	int
)	O
{	O
count	long
--	O
;	O
}	O
else	O
{	O
count	long
++	O
;	O
startnames	int
=	O
1	int
;	O
}	O
if	O
(	O
resolved_path	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
resolved_path	*(struct(*(char),*(char),int,int,int,char,int))
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
resolved_path	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"/"	*(char)
)	O
;	O
}	O
numcomponents	int
++	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
NULL	O
,	O
"/"	*(char)
)	O
;	O
}	O
if	O
(	O
depth	*(int)
)	O
*	O
depth	*(int)
=	O
count	long
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
swbis_free	O
(	O
path	*(char)
)	O
;	O
return	O
numcomponents	int
;	O
}	O
int	O
swlib_exec_filter	(*(*(struct(*(char),*(char),*(struct`),*(*`),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*`),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int))),int,*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
SHCMD	struct(*(char),*(char),*(struct(*(*(char)),int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*(void))->(int)),*((int,int,*(void))->(int)),*(void),int,int,int,int)
*	O
*	O
cmd	int
,	O
int	O
src_fd	int
,	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
output	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
int	O
input_pipe	array(int)
[	O
2	int
]	O
;	O
int	O
ifd	int
,	O
ofd	int
,	O
i	int
=	O
0	int
;	O
int	O
childi	int
;	O
int	O
retval	int
;	O
int	O
status	int
;	O
int	O
cret	int
;	O
int	O
ret	int
;	O
retval	int
=	O
0	int
;	O
ifd	int
=	O
src_fd	int
;	O
while	O
(	O
cmd	int
[	O
i	int
]	O
)	O
i	int
++	O
;	O
ofd	int
=	O
shcmd_get_dstfd	(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)))->(int)
(	O
cmd	int
[	O
--	O
i	int
]	O
)	O
;	O
input_pipe	array(int)
[	O
0	int
]	O
=	O
-	O
1	int
;	O
input_pipe	array(int)
[	O
1	int
]	O
=	O
-	O
1	int
;	O
if	O
(	O
ifd	int
>=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
pipe	(array(int))->(int)
(	O
input_pipe	array(int)
)	O
;	O
childi	int
=	O
swfork	O
(	O
(	O
sigset_t	struct(array(long))
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
if	O
(	O
childi	int
==	O
0	int
)	O
{	O
int	O
ret	int
;	O
swgp_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGPIPE	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGINT	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGTERM	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGUSR1	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGUSR2	int
,	O
SIG_DFL	O
)	O
;	O
if	O
(	O
ifd	int
!=	O
0	int
)	O
close	*((*(void))->(int))
(	O
0	int
)	O
;	O
if	O
(	O
ifd	int
!=	O
1	int
)	O
close	*((*(void))->(int))
(	O
1	int
)	O
;	O
close	*((*(void))->(int))
(	O
input_pipe	array(int)
[	O
0	int
]	O
)	O
;	O
close	*((*(void))->(int))
(	O
ofd	int
)	O
;	O
retval	int
=	O
swlib_pump_amount	(int,int,long)->(long)
(	O
input_pipe	array(int)
[	O
1	int
]	O
,	O
ifd	int
,	O
-	O
1	int
)	O
;	O
if	O
(	O
retval	int
<	O
0	int
)	O
ret	int
=	O
1	int
;	O
else	O
ret	int
=	O
0	int
;	O
_exit	(int)->(void)
(	O
ret	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
if	O
(	O
childi	int
<	O
0	int
)	O
{	O
SWLIB_INTERNAL	O
(	O
"swlib_exec_filter: 0001."	*(char)
)	O
;	O
return	O
-	O
(	O
INT_MAX	O
)	O
;	O
}	O
close	*((*(void))->(int))
(	O
input_pipe	array(int)
[	O
1	int
]	O
)	O
;	O
shcmd_set_srcfd	(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)),int)->(void)
(	O
cmd	int
[	O
0	int
]	O
,	O
input_pipe	array(int)
[	O
0	int
]	O
)	O
;	O
if	O
(	O
output	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
swlib_shcmd_output_strob	(*(struct(*(char),*(char),int,int,int,char,int)),*(*(struct(*(char),*(char),*(struct`),*(*`),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*`),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int))))->(int)
(	O
output	*(struct(*(char),*(char),int,int,int,char,int))
,	O
cmd	int
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
shcmd_command	(*(*(struct(*(char),*(char),*(struct`),*(*`),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*`),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int))))->(int)
(	O
cmd	int
)	O
;	O
}	O
close	*((*(void))->(int))
(	O
input_pipe	array(int)
[	O
0	int
]	O
)	O
;	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
cret	int
=	O
126	int
;	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
ret	int
=	O
waitpid	(int,*(int),int)->(int)
(	O
childi	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
if	O
(	O
ret	int
==	O
childi	int
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
{	O
cret	int
=	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
if	O
(	O
cret	int
!=	O
0	int
)	O
{	O
SWLIB_ERROR	O
(	O
""	*(char)
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"child OK"	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
SWLIB_ERROR	O
(	O
""	*(char)
)	O
;	O
cret	int
=	O
127	int
;	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
SWLIB_ERROR2	O
(	O
"%s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
cret	int
=	O
0	int
;	O
if	O
(	O
output	*(struct(*(char),*(char),int,int,int,char,int))
)	O
swlib_shcmd_output_strob	(*(struct(*(char),*(char),int,int,int,char,int)),*(*(struct(*(char),*(char),*(struct`),*(*`),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*`),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int))))->(int)
(	O
output	*(struct(*(char),*(char),int,int,int,char,int))
,	O
cmd	int
)	O
;	O
else	O
shcmd_command	(*(*(struct(*(char),*(char),*(struct`),*(*`),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*`),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int))))->(int)
(	O
cmd	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
if	O
(	O
cret	int
==	O
127	int
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
retval	int
=	O
shcmd_wait	(*(*(struct(*(char),*(char),*(struct`),*(*`),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*`),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int))))->(int)
(	O
cmd	int
)	O
;	O
}	O
E_DEBUG2	O
(	O
"retval=%d"	*(char)
,	O
retval	int
)	O
;	O
E_DEBUG2	O
(	O
"cret=%d"	*(char)
,	O
cret	int
)	O
;	O
return	O
(	O
retval	int
||	O
cret	int
)	O
;	O
}	O
SYNCT	struct(int,int,*(char),*(char),*(char),int,*(char))
*	O
swlib_synct_create	()->(*(struct(int,int,*(char),*(char),*(char),int,*(char))))
(	O
void	O
)	O
{	O
SYNCT	struct(int,int,*(char),*(char),*(char),int,*(char))
*	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
=	O
(	O
SYNCT	struct(int,int,*(char),*(char),*(char),int,*(char))
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
SYNCT	struct(int,int,*(char),*(char),*(char),int,*(char))
)	O
)	O
;	O
int	O
len	int
;	O
len	int
=	O
(	O
3	int
*	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
+	O
1	int
;	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
bufM	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
(	O
size_t	long
)	O
len	int
)	O
;	O
if	O
(	O
!	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
bufM	*(char)
)	O
_exit	(int)->(void)
(	O
44	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
bufM	*(char)
,	O
(	O
int	O
)	O
(	O
'\0'	O
)	O
,	O
len	int
)	O
;	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
tailM	*(struct(*(char),int,long,*(struct(*(char),int,long,*(struct`),*(struct`),int)),*(struct(*(char),int,long,*(struct`),*(struct`),int)),int))
=	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
bufM	*(char)
+	O
SWLIB_SYNCT_BLOCKSIZE	int
;	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
countM	int
=	O
0	int
;	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
mtM	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
SWBIS_SYNCT_EOF	O
)	O
;	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
do_debugM	int
=	O
0	int
;	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
debugfdM	int
=	O
-	O
1	int
;	O
return	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
;	O
}	O
void	O
swlib_synct_delete	(*(struct(int,int,*(char),*(char),*(char),int,*(char))))->(void)
(	O
SYNCT	struct(int,int,*(char),*(char),*(char),int,*(char))
*	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
)	O
{	O
if	O
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
countM	int
%	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: Warning: swlib_synct_delete() block count error: %d\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
countM	int
)	O
;	O
}	O
if	O
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
debugfdM	int
>	O
0	int
)	O
close	*((*(void))->(int))
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
debugfdM	int
)	O
;	O
free	(*(void))->(void)
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
mtM	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
bufM	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
)	O
;	O
}	O
int	O
swlib_synct_read	(*(struct(int,int,*(char),*(char),*(char),int,*(char))),int,*(void))->(int)
(	O
SYNCT	struct(int,int,*(char),*(char),*(char),int,*(char))
*	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
,	O
int	O
fd	int
,	O
void	O
*	O
userbuf	*(void)
)	O
{	O
unsigned	O
char	O
*	O
ibuf	*(char)
;	O
unsigned	O
char	O
*	O
tbuf	*(char)
;	O
char	O
*	O
z	*(char)
;	O
int	O
ret	int
;	O
int	O
tret	int
;	O
int	O
check_ret	int
;	O
ibuf	*(char)
=	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
bufM	*(char)
;	O
tbuf	*(char)
=	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
->	O
tailM	*(struct(*(char),int,long,*(struct(*(char),int,long,*(struct`),*(struct`),int)),*(struct(*(char),int,long,*(struct`),*(struct`),int)),int))
;	O
E_DEBUG2	O
(	O
"fd = %d"	*(char)
,	O
fd	int
)	O
;	O
ret	int
=	O
synct_i_read_block	(*(struct(int,int,*(char),*(char),*(char),int,*(char))),*((int,*(void),long)->(long)),int,*(char))->(long)
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
,	O
uxfio_sfa_read	(int,*(void),long)->(long)
,	O
fd	int
,	O
(	O
char	O
*	O
)	O
ibuf	*(char)
)	O
;	O
E_DEBUG2	O
(	O
"synct_i_read_block() returned %d"	*(char)
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
return	O
0	int
;	O
check_ret	int
=	O
synct_check_for_possible_eof	(*(struct(int,int,*(char),*(char),*(char),int,*(char))))->(int)
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
)	O
;	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
if	O
(	O
check_ret	int
==	O
SYNCT_EOF_CONDITION_0	int
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
userbuf	*(void)
,	O
ibuf	*(char)
,	O
ret	int
)	O
;	O
return	O
(	O
int	O
)	O
SWLIB_SYNCT_BLOCKSIZE	int
;	O
}	O
else	O
{	O
E_DEBUG2	O
(	O
"fd = %d"	*(char)
,	O
fd	int
)	O
;	O
ret	int
=	O
synct_i_read_block	(*(struct(int,int,*(char),*(char),*(char),int,*(char))),*((int,*(void),long)->(long)),int,*(char))->(long)
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
,	O
uxfio_sfa_read	(int,*(void),long)->(long)
,	O
fd	int
,	O
(	O
char	O
*	O
)	O
tbuf	*(char)
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
2	int
;	O
z	*(char)
=	O
malloc	(long)->(*(void))
(	O
(	O
size_t	long
)	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
z	*(char)
,	O
'\0'	O
,	O
(	O
size_t	long
)	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
;	O
ret	int
=	O
memcmp	(*(void),*(void),long)->(int)
(	O
z	*(char)
,	O
tbuf	*(char)
,	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
;	O
free	(*(void))->(void)
(	O
z	*(char)
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
if	O
(	O
check_ret	int
==	O
SYNCT_EOF_CONDITION_2	int
)	O
{	O
tret	int
=	O
1	int
;	O
while	O
(	O
tret	int
>	O
0	int
)	O
tret	int
=	O
synct_i_read_block	(*(struct(int,int,*(char),*(char),*(char),int,*(char))),*((int,*(void),long)->(long)),int,*(char))->(long)
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
,	O
timed_atomic_read5	(int,*(void),long)->(long)
,	O
fd	int
,	O
(	O
char	O
*	O
)	O
tbuf	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
else	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
userbuf	*(void)
,	O
ibuf	*(char)
,	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
(	O
(	O
char	O
*	O
)	O
userbuf	*(void)
)	O
+	O
SWLIB_SYNCT_BLOCKSIZE	int
,	O
tbuf	*(char)
,	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
;	O
return	O
(	O
int	O
)	O
(	O
2	int
*	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
;	O
}	O
}	O
return	O
-	O
2	int
;	O
}	O
int	O
swlib_synct_suck	(int,int)->(int)
(	O
int	O
ofd	int
,	O
int	O
ifd	int
)	O
{	O
int	O
ret	int
;	O
int	O
wret	int
;	O
int	O
wtotal	int
=	O
0	int
;	O
char	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
[	O
SWLIB_SYNCT_BLOCKSIZE	int
+	O
SWLIB_SYNCT_BLOCKSIZE	int
+	O
1	int
]	O
;	O
SYNCT	struct(int,int,*(char),*(char),*(char),int,*(char))
*	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
;	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
=	O
swlib_synct_create	()->(*(struct(int,int,*(char),*(char),*(char),int,*(char))))
(	O
)	O
;	O
do	O
{	O
ret	int
=	O
swlib_synct_read	(*(struct(int,int,*(char),*(char),*(char),int,*(char))),int,*(void))->(int)
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
,	O
ifd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
E_DEBUG2	O
(	O
"swlib_synct_read returned %d"	*(char)
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
>	O
0	int
)	O
{	O
wret	int
=	O
synct_i_no_null_write	(int,*(char),int)->(long)
(	O
ofd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
ret	int
)	O
;	O
if	O
(	O
wret	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"error"	*(char)
)	O
;	O
return	O
-	O
2	int
;	O
}	O
wtotal	int
+=	O
wret	int
;	O
}	O
}	O
while	O
(	O
ret	int
>	O
0	int
)	O
;	O
swlib_synct_delete	(*(struct(int,int,*(char),*(char),*(char),int,*(char))))->(void)
(	O
synct	*(struct(int,int,*(char),*(char),*(char),int,*(char)))
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
ret	int
;	O
return	O
wtotal	int
;	O
}	O
int	O
swlib_read_amount	(int,long)->(int)
(	O
int	O
suction_fd	int
,	O
intmax_t	long
amount	long
)	O
{	O
return	O
swlib_pump_amount	(int,int,long)->(long)
(	O
-	O
1	int
,	O
suction_fd	int
,	O
amount	long
)	O
;	O
}	O
int	O
swlib_pipe_pump	(int,int)->(int)
(	O
int	O
ofd	int
,	O
int	O
ifd	int
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
return	O
swlib_pump_amount	(int,int,long)->(long)
(	O
ofd	int
,	O
ifd	int
,	O
-	O
1	int
)	O
;	O
}	O
intmax_t	long
swlib_pump_amount	(int,int,long)->(long)
(	O
int	O
discharge_fd	int
,	O
int	O
suction_fd	int
,	O
intmax_t	long
amount	long
)	O
{	O
intmax_t	long
i	int
=	O
amount	long
;	O
if	O
(	O
swlib_i_pipe_pump	(int,int,*(long),int,*(struct(*(char),*(char),int,int,int,char,int)),*((int,*(void),long)->(long)))->(long)
(	O
suction_fd	int
,	O
discharge_fd	int
,	O
&	O
i	int
,	O
-	O
1	int
,	O
NULL	O
,	O
uxfio_read	(int,*(void),long)->(long)
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
return	O
i	int
;	O
}	O
int	O
swlib_fork_to_make_unixfd	(int,*(struct(array(long))),*(struct(array(long))),*(int))->(int)
(	O
int	O
uxfio_fd	int
,	O
sigset_t	struct(array(long))
*	O
blockmask	*(struct(array(long)))
,	O
sigset_t	struct(array(long))
*	O
defaultmask	*(struct(array(long)))
,	O
int	O
*	O
ppid	*(int)
)	O
{	O
int	O
upipe	array(int)
[	O
2	int
]	O
;	O
pid_t	int
upid	int
;	O
if	O
(	O
ppid	*(int)
)	O
*	O
ppid	*(int)
=	O
(	O
int	O
)	O
0	int
;	O
if	O
(	O
uxfio_fd	int
<=	O
OPEN_MAX	int
)	O
return	O
uxfio_fd	int
;	O
if	O
(	O
pipe	(array(int))->(int)
(	O
upipe	array(int)
)	O
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
upid	int
=	O
swndfork	(*(struct(array(long))),*(struct(array(long))))->(int)
(	O
blockmask	*(struct(array(long)))
,	O
defaultmask	*(struct(array(long)))
)	O
)	O
>	O
0	int
)	O
{	O
uxfio_close	(int)->(int)
(	O
uxfio_fd	int
)	O
;	O
close	*((*(void))->(int))
(	O
upipe	array(int)
[	O
1	int
]	O
)	O
;	O
if	O
(	O
ppid	*(int)
)	O
*	O
ppid	*(int)
=	O
(	O
int	O
)	O
upid	int
;	O
return	O
upipe	array(int)
[	O
0	int
]	O
;	O
}	O
else	O
if	O
(	O
upid	int
==	O
0	int
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
close	*((*(void))->(int))
(	O
upipe	array(int)
[	O
0	int
]	O
)	O
;	O
ret	int
=	O
swlib_pipe_pump	(int,int)->(int)
(	O
upipe	array(int)
[	O
1	int
]	O
,	O
uxfio_fd	int
)	O
;	O
if	O
(	O
ret	int
>=	O
0	int
)	O
ret	int
=	O
0	int
;	O
else	O
ret	int
=	O
255	int
;	O
_exit	(int)->(void)
(	O
ret	int
)	O
;	O
}	O
else	O
{	O
SWLIB_RESOURCE	O
(	O
"fork failed"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
int	O
swlib_is_c701_escape	(int)->(int)
(	O
int	O
c	int
)	O
{	O
if	O
(	O
(	O
c	int
==	O
'\"'	O
)	O
||	O
(	O
c	int
==	O
'#'	O
)	O
||	O
(	O
c	int
==	O
'\\'	O
)	O
||	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
int	O
swlib_is_ansi_escape	(int)->(int)
(	O
int	O
c	int
)	O
{	O
if	O
(	O
(	O
c	int
==	O
'n'	O
)	O
||	O
(	O
c	int
==	O
't'	O
)	O
||	O
(	O
c	int
==	O
'v'	O
)	O
||	O
(	O
c	int
==	O
'b'	O
)	O
||	O
(	O
c	int
==	O
'r'	O
)	O
||	O
(	O
c	int
==	O
'f'	O
)	O
||	O
(	O
c	int
==	O
'x'	O
)	O
||	O
(	O
c	int
==	O
'a'	O
)	O
||	O
(	O
c	int
==	O
'\\'	O
)	O
||	O
(	O
c	int
==	O
'?'	O
)	O
||	O
(	O
c	int
==	O
'\''	O
)	O
||	O
(	O
c	int
==	O
'\"'	O
)	O
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
int	O
swlib_c701_escaped_value	(int,*(int))->(int)
(	O
int	O
src	*(char)
,	O
int	O
*	O
is_escape	*(int)
)	O
{	O
*	O
is_escape	*(int)
=	O
1	int
;	O
switch	O
(	O
src	*(char)
)	O
{	O
case	O
'\\'	O
:	O
return	O
(	O
int	O
)	O
'\\'	O
;	O
break	O
;	O
case	O
'#'	O
:	O
return	O
(	O
int	O
)	O
'#'	O
;	O
break	O
;	O
case	O
'\"'	O
:	O
return	O
(	O
int	O
)	O
'\"'	O
;	O
break	O
;	O
}	O
*	O
is_escape	*(int)
=	O
0	int
;	O
return	O
(	O
int	O
)	O
(	O
src	*(char)
)	O
;	O
}	O
int	O
swlib_ansi_escaped_value	(int,*(int))->(int)
(	O
int	O
src	*(char)
,	O
int	O
*	O
is_escape	*(int)
)	O
{	O
*	O
is_escape	*(int)
=	O
1	int
;	O
switch	O
(	O
src	*(char)
)	O
{	O
case	O
'\\'	O
:	O
return	O
(	O
int	O
)	O
'\\'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
return	O
(	O
int	O
)	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
return	O
(	O
int	O
)	O
'\r'	O
;	O
break	O
;	O
case	O
'v'	O
:	O
return	O
(	O
int	O
)	O
'\v'	O
;	O
break	O
;	O
case	O
'b'	O
:	O
return	O
(	O
int	O
)	O
'\b'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
return	O
(	O
int	O
)	O
'\f'	O
;	O
break	O
;	O
}	O
*	O
is_escape	*(int)
=	O
0	int
;	O
return	O
(	O
int	O
)	O
(	O
src	*(char)
)	O
;	O
}	O
o__inline__	O
char	O
*	O
swlib_strdup	(*(char))->(*(char))
(	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
return	O
strdup	(*(char))->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
char	O
*	O
swlib_strncpy	(*(char),*(char),long)->(*(char))
(	O
char	O
*	O
dst	*(char)
,	O
const	O
char	O
*	O
src	*(char)
,	O
size_t	long
n	long
)	O
{	O
char	O
*	O
p	*(char)
=	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
dst	*(char)
,	O
src	*(char)
,	O
n	long
-	O
1	int
)	O
;	O
dst	*(char)
[	O
n	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
p	*(char)
;	O
}	O
int	O
swlib_writef	(int,*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(int)
(	O
int	O
fd	int
,	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
buffer	array(char)
,	O
char	O
*	O
format	*(char)
,	O
...	O
)	O
{	O
int	O
ret	int
;	O
int	O
newret	int
;	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
format	*(char)
)	O
;	O
ret	int
=	O
strob_vsprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
buffer	array(char)
,	O
0	int
,	O
format	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
newret	int
=	O
atomicio	(*((int,*(void),long)->(long)),int,*(void),long)->(long)
(	O
uxfio_write	(int,*(void),long)->(long)
,	O
fd	int
,	O
(	O
void	O
*	O
)	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
buffer	array(char)
)	O
,	O
(	O
size_t	long
)	O
(	O
ret	int
)	O
)	O
;	O
if	O
(	O
newret	int
!=	O
ret	int
)	O
return	O
-	O
1	int
;	O
return	O
newret	int
;	O
}	O
int	O
swlib_write_OLDcatalog_stream	(*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*`,int,int,*`,*`,*`,*`,*`,*`,*`,int,int,int,array(struct(*(char),*(char),int)),*`,*`,int,int,*`,*`,*`,*`,int,*`,int,int,*`,int,long,long,int,int,int,int,*`,*`,*`,int)),*(struct(*`)),*(struct(int,int,*`)),*(struct(int,*`,*`)),*(struct(int,int,int,int,*`)),*(struct(int,int,int,int,*`)),int,int,int,*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)))),int)->(int)
(	O
XFORMAT	struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct(int,int,int,array(char),int,int,int,*`,array(int),int,int,*`,*`,struct`,struct`,int,int,array(int),int,*`,*`,*`,*`)),int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`)),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct(*`,int,long,*`,*`,int)),*(struct(*`,int,long,*`,*`,int)),*((*`,*`,*`)->(int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),int,int,*(struct(*`,int,long,*`,*`,int)),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct(int,int,*`)),*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),int)),*(struct(*(struct(short,long,long,long,long,long,long,long,long,long,long,long,long,long,*`,*`,*`,*`,char,char,char,char,int,int,*`,*`,long,long,long,long)))),*(struct(int,int,*(struct(*`,int,int,long,int)))),*(struct(int,*(struct(*`,*`)),*(void))),*(struct(int,int,int,int,*(struct(int,int,*`)))),*(struct(int,int,int,int,*(struct(int,int,*`)))),int,int,int,*(struct(char,*(struct(*`,*`,int,int,int,char,int)),int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),*(struct(int,*`,long)),*(struct(*`,*`,int,int,int,char,int)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)))
*	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
int	O
ofd	int
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
taruib_write_catalog_stream	(*(void),int,int,int)->(int)
(	O
(	O
void	O
*	O
)	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
ofd	int
,	O
0	int
,	O
0	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_write_catalog_stream	(*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*`,int,int,*`,*`,*`,*`,*`,*`,*`,int,int,int,array(struct(*(char),*(char),int)),*`,*`,int,int,*`,*`,*`,*`,int,*`,int,int,*`,int,long,long,int,int,int,int,*`,*`,*`,int)),*(struct(*`)),*(struct(int,int,*`)),*(struct(int,*`,*`)),*(struct(int,int,int,int,*`)),*(struct(int,int,int,int,*`)),int,int,int,*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)))),int)->(int)
(	O
XFORMAT	struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct(int,int,int,array(char),int,int,int,*`,array(int),int,int,*`,*`,struct`,struct`,int,int,array(int),int,*`,*`,*`,*`)),int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`)),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct(*`,int,long,*`,*`,int)),*(struct(*`,int,long,*`,*`,int)),*((*`,*`,*`)->(int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),int,int,*(struct(*`,int,long,*`,*`,int)),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct(int,int,*`)),*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),int)),*(struct(*(struct(short,long,long,long,long,long,long,long,long,long,long,long,long,long,*`,*`,*`,*`,char,char,char,char,int,int,*`,*`,long,long,long,long)))),*(struct(int,int,*(struct(*`,int,int,long,int)))),*(struct(int,*(struct(*`,*`)),*(void))),*(struct(int,int,int,int,*(struct(int,int,*`)))),*(struct(int,int,int,int,*(struct(int,int,*`)))),int,int,int,*(struct(char,*(struct(*`,*`,int,int,int,char,int)),int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),*(struct(int,*`,long)),*(struct(*`,*`,int,int,int,char,int)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)))
*	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
int	O
ofd	int
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
taruib_write_catalog_stream	(*(void),int,int,int)->(int)
(	O
(	O
void	O
*	O
)	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
ofd	int
,	O
1	int
,	O
0	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_write_OLDstorage_stream	(*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*`,int,int,*`,*`,*`,*`,*`,*`,*`,int,int,int,array(struct(*(char),*(char),int)),*`,*`,int,int,*`,*`,*`,*`,int,*`,int,int,*`,int,long,long,int,int,int,int,*`,*`,*`,int)),*(struct(*`)),*(struct(int,int,*`)),*(struct(int,*`,*`)),*(struct(int,int,int,int,*`)),*(struct(int,int,int,int,*`)),int,int,int,*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)))),int)->(int)
(	O
XFORMAT	struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct(int,int,int,array(char),int,int,int,*`,array(int),int,int,*`,*`,struct`,struct`,int,int,array(int),int,*`,*`,*`,*`)),int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`)),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct(*`,int,long,*`,*`,int)),*(struct(*`,int,long,*`,*`,int)),*((*`,*`,*`)->(int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),int,int,*(struct(*`,int,long,*`,*`,int)),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct(int,int,*`)),*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),int)),*(struct(*(struct(short,long,long,long,long,long,long,long,long,long,long,long,long,long,*`,*`,*`,*`,char,char,char,char,int,int,*`,*`,long,long,long,long)))),*(struct(int,int,*(struct(*`,int,int,long,int)))),*(struct(int,*(struct(*`,*`)),*(void))),*(struct(int,int,int,int,*(struct(int,int,*`)))),*(struct(int,int,int,int,*(struct(int,int,*`)))),int,int,int,*(struct(char,*(struct(*`,*`,int,int,int,char,int)),int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),*(struct(int,*`,long)),*(struct(*`,*`,int,int,int,char,int)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)))
*	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
int	O
ofd	int
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
taruib_write_storage_stream	(*(void),int,int,int,int,int)->(int)
(	O
(	O
void	O
*	O
)	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
ofd	int
,	O
0	int
,	O
-	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_write_storage_stream	(*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*`,int,int,*`,*`,*`,*`,*`,*`,*`,int,int,int,array(struct(*(char),*(char),int)),*`,*`,int,int,*`,*`,*`,*`,int,*`,int,int,*`,int,long,long,int,int,int,int,*`,*`,*`,int)),*(struct(*`)),*(struct(int,int,*`)),*(struct(int,*`,*`)),*(struct(int,int,int,int,*`)),*(struct(int,int,int,int,*`)),int,int,int,*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)))),int)->(int)
(	O
XFORMAT	struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct(int,int,int,array(char),int,int,int,*`,array(int),int,int,*`,*`,struct`,struct`,int,int,array(int),int,*`,*`,*`,*`)),int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`)),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct(*`,int,long,*`,*`,int)),*(struct(*`,int,long,*`,*`,int)),*((*`,*`,*`)->(int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),int,int,*(struct(*`,int,long,*`,*`,int)),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct(int,int,*`)),*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),int)),*(struct(*(struct(short,long,long,long,long,long,long,long,long,long,long,long,long,long,*`,*`,*`,*`,char,char,char,char,int,int,*`,*`,long,long,long,long)))),*(struct(int,int,*(struct(*`,int,int,long,int)))),*(struct(int,*(struct(*`,*`)),*(void))),*(struct(int,int,int,int,*(struct(int,int,*`)))),*(struct(int,int,int,int,*(struct(int,int,*`)))),int,int,int,*(struct(char,*(struct(*`,*`,int,int,int,char,int)),int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),*(struct(int,*`,long)),*(struct(*`,*`,int,int,int,char,int)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)))
*	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
int	O
ofd	int
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
taruib_write_storage_stream	(*(void),int,int,int,int,int)->(int)
(	O
(	O
void	O
*	O
)	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
ofd	int
,	O
1	int
,	O
-	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_write_signing_files	(*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*`,int,int,*`,*`,*`,*`,*`,*`,*`,int,int,int,array(struct(*(char),*(char),int)),*`,*`,int,int,*`,*`,*`,*`,int,*`,int,int,*`,int,long,long,int,int,int,int,*`,*`,*`,int)),*(struct(*`)),*(struct(int,int,*`)),*(struct(int,*`,*`)),*(struct(int,int,int,int,*`)),*(struct(int,int,int,int,*`)),int,int,int,*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)))),int,int,int)->(int)
(	O
XFORMAT	struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct(int,int,int,array(char),int,int,int,*`,array(int),int,int,*`,*`,struct`,struct`,int,int,array(int),int,*`,*`,*`,*`)),int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`)),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct(*`,int,long,*`,*`,int)),*(struct(*`,int,long,*`,*`,int)),*((*`,*`,*`)->(int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),int,int,*(struct(*`,int,long,*`,*`,int)),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct(int,int,*`)),*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),int)),*(struct(*(struct(short,long,long,long,long,long,long,long,long,long,long,long,long,long,*`,*`,*`,*`,char,char,char,char,int,int,*`,*`,long,long,long,long)))),*(struct(int,int,*(struct(*`,int,int,long,int)))),*(struct(int,*(struct(*`,*`)),*(void))),*(struct(int,int,int,int,*(struct(int,int,*`)))),*(struct(int,int,int,int,*(struct(int,int,*`)))),int,int,int,*(struct(char,*(struct(*`,*`,int,int,int,char,int)),int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),*(struct(int,*`,long)),*(struct(*`,*`,int,int,int,char,int)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)))
*	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
int	O
ofd	int
,	O
int	O
which_file	int
,	O
int	O
do_adjunct_md5	int
)	O
{	O
int	O
nullfd	int
;	O
int	O
ifd	int
=	O
xformat_get_ifd	(*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*`,int,int,*`,*`,*`,*`,*`,*`,*`,int,int,int,array(struct(*(char),*(char),int)),*`,*`,int,int,*`,*`,*`,*`,int,*`,int,int,*`,int,long,long,int,int,int,int,*`,*`,*`,int)),*(struct(*`)),*(struct(int,int,*`)),*(struct(int,*`,*`)),*(struct(int,int,int,int,*`)),*(struct(int,int,int,int,*`)),int,int,int,*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)))))->(int)
(	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
)	O
;	O
int	O
ret	int
;	O
int	O
bytesret	int
;	O
int	O
retval	int
=	O
0	int
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
namebuf	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
100	int
)	O
;	O
SWPATH	struct(int,int,int,int,*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),int,int,int)
*	O
swpath	*(struct(int,int,int,int,*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*(struct`),*(struct`))),int,int,int))
=	O
swpath_open	(*(char))->(*(struct(int,int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(char),*(char),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*`,*`)),int,int,int)))
(	O
""	*(char)
)	O
;	O
char	O
*	O
name	array(char)
;	O
char	O
nullblock	array(char)
[	O
512	int
]	O
;	O
int	O
writeit	int
;	O
int	O
do_trailer	int
=	O
0	int
;	O
int	O
format	*(char)
=	O
xformat_get_format	(*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*`,int,int,*`,*`,*`,*`,*`,*`,*`,int,int,int,array(struct(*(char),*(char),int)),*`,*`,int,int,*`,*`,*`,*`,int,*`,int,int,*`,int,long,long,int,int,int,int,*`,*`,*`,int)),*(struct(*`)),*(struct(int,int,*`)),*(struct(int,*`,*`)),*(struct(int,int,int,int,*`)),*(struct(int,int,int,int,*`)),int,int,int,*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)))))->(int)
(	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
)	O
;	O
long	O
int	O
bytes	int
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
nullblock	array(char)
,	O
'\0'	O
,	O
sizeof	O
(	O
nullblock	array(char)
)	O
)	O
;	O
if	O
(	O
!	O
swpath	*(struct(int,int,int,int,*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*(struct`),*(struct`))),int,int,int))
)	O
return	O
-	O
21	int
;	O
if	O
(	O
ifd	int
<	O
0	int
)	O
return	O
-	O
32	int
;	O
nullfd	int
=	O
swbis_devnull_open	O
(	O
"/dev/null"	*(char)
,	O
O_RDWR	int
,	O
0	int
)	O
;	O
if	O
(	O
nullfd	int
<	O
0	int
)	O
return	O
-	O
2	int
;	O
while	O
(	O
(	O
ret	int
=	O
xformat_read_header	(*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*`,int,int,*`,*`,*`,*`,*`,*`,*`,int,int,int,array(struct(*(char),*(char),int)),*`,*`,int,int,*`,*`,*`,*`,int,*`,int,int,*`,int,long,long,int,int,int,int,*`,*`,*`,int)),*(struct(*`)),*(struct(int,int,*`)),*(struct(int,*`,*`)),*(struct(int,int,int,int,*`)),*(struct(int,int,int,int,*`)),int,int,int,*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)))))->(int)
(	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
)	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
xformat_is_end_of_archive	(*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*`,int,int,*`,*`,*`,*`,*`,*`,*`,int,int,int,array(struct(*(char),*(char),int)),*`,*`,int,int,*`,*`,*`,*`,int,*`,int,int,*`,int,long,long,int,int,int,int,*`,*`,*`,int)),*(struct(*`)),*(struct(int,int,*`)),*(struct(int,*`,*`)),*(struct(int,int,int,int,*`)),*(struct(int,int,int,int,*`)),int,int,int,*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)))))->(int)
(	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
)	O
)	O
{	O
break	O
;	O
}	O
xformat_get_name	(*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*`,int,int,*`,*`,*`,*`,*`,*`,*`,int,int,int,array(struct(*(char),*(char),int)),*`,*`,int,int,*`,*`,*`,*`,int,*`,int,int,*`,int,long,long,int,int,int,int,*`,*`,*`,int)),*(struct(*`)),*(struct(int,int,*`)),*(struct(int,*`,*`)),*(struct(int,int,int,int,*`)),*(struct(int,int,int,int,*`)),int,int,int,*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)))),*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
namebuf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
name	array(char)
=	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
namebuf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
swpath_parse_path	(*(struct(int,int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(char),*(char),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*`,*`)),int,int,int)),*(char))->(int)
(	O
swpath	*(struct(int,int,int,int,*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*(struct`),*(struct`))),int,int,int))
,	O
name	array(char)
)	O
;	O
if	O
(	O
swpath_get_is_catalog	(*(struct(int,int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(char),*(char),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*`,*`)),int,int,int)))->(int)
(	O
swpath	*(struct(int,int,int,int,*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*(struct`),*(struct`))),int,int,int))
)	O
==	O
SWPATH_CTYPE_DIR	O
)	O
{	O
if	O
(	O
which_file	int
==	O
0	int
)	O
writeit	int
=	O
nullfd	int
;	O
else	O
writeit	int
=	O
ofd	int
;	O
}	O
else	O
if	O
(	O
swpath_get_is_catalog	(*(struct(int,int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(char),*(char),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*`,*`)),int,int,int)))->(int)
(	O
swpath	*(struct(int,int,int,int,*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*(struct`),*(struct`))),int,int,int))
)	O
==	O
SWPATH_CTYPE_CAT	int
)	O
{	O
if	O
(	O
which_file	int
==	O
0	int
)	O
writeit	int
=	O
ofd	int
;	O
else	O
writeit	int
=	O
nullfd	int
;	O
}	O
else	O
if	O
(	O
swpath_get_is_catalog	(*(struct(int,int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(char),*(char),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*`,*`)),int,int,int)))->(int)
(	O
swpath	*(struct(int,int,int,int,*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*(struct`),*(struct`))),int,int,int))
)	O
==	O
SWPATH_CTYPE_STORE	int
)	O
{	O
if	O
(	O
which_file	int
==	O
0	int
)	O
{	O
do_trailer	int
=	O
1	int
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
do_adjunct_md5	int
)	O
{	O
int	O
filetype	*(char)
=	O
xformat_get_tar_typeflag	(*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*`,int,int,*`,*`,*`,*`,*`,*`,*`,int,int,int,array(struct(*(char),*(char),int)),*`,*`,int,int,*`,*`,*`,*`,int,*`,int,int,*`,int,long,long,int,int,int,int,*`,*`,*`,int)),*(struct(*`)),*(struct(int,int,*`)),*(struct(int,*`,*`)),*(struct(int,int,int,int,*`)),*(struct(int,int,int,int,*`)),int,int,int,*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)))))->(char)
(	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
)	O
;	O
if	O
(	O
filetype	*(char)
!=	O
REGTYPE	char
&&	O
filetype	*(char)
!=	O
DIRTYPE	char
)	O
writeit	int
=	O
nullfd	int
;	O
else	O
writeit	int
=	O
ofd	int
;	O
}	O
else	O
{	O
writeit	int
=	O
ofd	int
;	O
}	O
}	O
}	O
else	O
{	O
SWLIB_INTERNAL	O
(	O
"internal error returned by swpath_get_is_catalog"	*(char)
)	O
;	O
retval	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
bytesret	int
=	O
0	int
;	O
xformat_set_ofd	(*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*`,int,int,*`,*`,*`,*`,*`,*`,*`,int,int,int,array(struct(*(char),*(char),int)),*`,*`,int,int,*`,*`,*`,*`,int,*`,int,int,*`,int,long,long,int,int,int,int,*`,*`,*`,int)),*(struct(*`)),*(struct(int,int,*`)),*(struct(int,*`,*`)),*(struct(int,int,int,int,*`)),*(struct(int,int,int,int,*`)),int,int,int,*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)))),int)->(void)
(	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
writeit	int
)	O
;	O
bytesret	int
+=	O
xformat_write_header	(*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*`,int,int,*`,*`,*`,*`,*`,*`,*`,int,int,int,array(struct(*(char),*(char),int)),*`,*`,int,int,*`,*`,*`,*`,int,*`,int,int,*`,int,long,long,int,int,int,int,*`,*`,*`,int)),*(struct(*`)),*(struct(int,int,*`)),*(struct(int,*`,*`)),*(struct(int,int,int,int,*`)),*(struct(int,int,int,int,*`)),int,int,int,*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)))))->(int)
(	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
)	O
;	O
bytesret	int
+=	O
xformat_copy_pass	(*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*`,int,int,*`,*`,*`,*`,*`,*`,*`,int,int,int,array(struct(*(char),*(char),int)),*`,*`,int,int,*`,*`,*`,*`,int,*`,int,int,*`,int,long,long,int,int,int,int,*`,*`,*`,int)),*(struct(*`)),*(struct(int,int,*`)),*(struct(int,*`,*`)),*(struct(int,int,int,int,*`)),*(struct(int,int,int,int,*`)),int,int,int,*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)))),int,int)->(long)
(	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
writeit	int
,	O
ifd	int
)	O
;	O
if	O
(	O
writeit	int
!=	O
nullfd	int
)	O
{	O
bytes	int
+=	O
bytesret	int
;	O
}	O
}	O
if	O
(	O
do_trailer	int
&&	O
(	O
format	*(char)
==	O
arf_ustar	int
||	O
format	*(char)
==	O
arf_tar	int
)	O
)	O
{	O
uxfio_write	(int,*(void),long)->(long)
(	O
ofd	int
,	O
nullblock	array(char)
,	O
512	int
)	O
;	O
uxfio_write	(int,*(void),long)->(long)
(	O
ofd	int
,	O
nullblock	array(char)
,	O
512	int
)	O
;	O
}	O
if	O
(	O
which_file	int
==	O
1	int
)	O
{	O
retval	int
+=	O
taru_write_archive_trailer	(*(struct(char,*(struct(*`,*`,int,int,int,char,int)),int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),int,*(struct(*`,*`,int,int,int,char,int)),*(struct(int,*`,long)),*(struct(*`,*`,int,int,int,char,int)))),enum(int,int,int,int,int,int,int,int,int,int),int,int,long,int)->(int)
(	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
->	O
taruM	*(void)
,	O
arf_ustar	int
,	O
ofd	int
,	O
512	int
,	O
(	O
int	O
)	O
bytes	int
,	O
xformat_get_tarheader_flags	(*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*`,int,int,*`,*`,*`,*`,*`,*`,*`,int,int,int,array(struct(*(char),*(char),int)),*`,*`,int,int,*`,*`,*`,*`,int,*`,int,int,*`,int,long,long,int,int,int,int,*`,*`,*`,int)),*(struct(*`)),*(struct(int,int,*`)),*(struct(int,*`,*`)),*(struct(int,int,int,int,*`)),*(struct(int,int,int,int,*`)),int,int,int,*(struct(char,*`,int,int,int,*`,*`,int,*`,int,int,int,*`,*`,int,*`,*`,*`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)))))->(int)
(	O
package	*(struct(int,int,enum(int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int),int,long,int,*(struct(*(struct`),int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,int,array(struct(*(char),*(char),int)),*(char),*(char),int,int,*(struct`),*(struct`),*((*`,*`,*`)->(int)),*(struct`),int,*(struct`),int,int,*(struct`),int,long,long,int,int,int,int,*((*`,*`)->(int)),*(struct`),*(struct`),int)),*(struct(*(struct`))),*(struct(int,int,*(struct`))),*(struct(int,*(struct`),*(void))),*(struct(int,int,int,int,*(struct`))),*(struct(int,int,int,int,*(struct`))),int,int,int,*(struct(char,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),int,int,int,*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int))))
)	O
)	O
;	O
}	O
swbis_devnull_close	O
(	O
nullfd	int
)	O
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
namebuf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
swpath_close	(*(struct(int,int,int,int,*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(char),*(char),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(struct(*`,*`,int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*`,*`)),int,int,int)))->(int)
(	O
swpath	*(struct(int,int,int,int,*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*(struct`),*(struct`))),int,int,int))
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swlib_kill_all_pids	(*(int),int,int,int)->(int)
(	O
pid_t	int
*	O
pid	int
,	O
int	O
num	int
,	O
int	O
signo	int
,	O
int	O
verbose_level	int
)	O
{	O
int	O
i	int
;	O
int	O
ret	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
pid	int
[	O
i	int
]	O
>	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
SWC_VERBOSE_SWIDB	int
,	O
(	O
NULL	O
)	O
,	O
STDERR_FILENO	int
,	O
"swlib_kill_all_pids: kill[%d] signo=%d\n"	*(char)
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
,	O
signo	int
)	O
;	O
E_DEBUG3	O
(	O
"killing pid %d with signal %d"	*(char)
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
,	O
signo	int
)	O
;	O
if	O
(	O
kill	(int,int)->(int)
(	O
pid	int
[	O
i	int
]	O
,	O
signo	int
)	O
<	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
SWC_VERBOSE_SWIDB	int
,	O
(	O
NULL	O
)	O
,	O
STDERR_FILENO	int
,	O
"kill[%d] signo=%d : error : %s\n"	*(char)
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
,	O
signo	int
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
ret	int
++	O
;	O
}	O
}	O
}	O
return	O
ret	int
;	O
}	O
int	O
swlib_update_pid_status	(int,int,*(int),*(int),int)->(int)
(	O
pid_t	int
keypid	int
,	O
int	O
value	long
,	O
pid_t	int
*	O
pid	int
,	O
int	O
*	O
status	int
,	O
int	O
len	int
)	O
{	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
len	int
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
pid	int
[	O
i	int
]	O
==	O
keypid	int
)	O
{	O
status	int
[	O
i	int
]	O
=	O
value	long
;	O
pid	int
[	O
i	int
]	O
=	O
-	O
pid	int
[	O
i	int
]	O
;	O
return	O
0	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
swlib_wait_on_all_pids	(*(int),int,*(int),int,int)->(int)
(	O
pid_t	int
*	O
pid	int
,	O
int	O
num	int
,	O
int	O
*	O
status	int
,	O
int	O
flags	int
,	O
int	O
verbose_level	int
)	O
{	O
return	O
swlib_wait_on_all_pids_with_timeout	(*(int),int,*(int),int,int,int)->(int)
(	O
pid	int
,	O
num	int
,	O
status	int
,	O
flags	int
,	O
verbose_level	int
,	O
0	int
)	O
;	O
}	O
int	O
swlib_wait_on_pid_with_timeout	(int,*(int),int,int,int)->(int)
(	O
pid_t	int
pid	int
,	O
int	O
*	O
status	int
,	O
int	O
flags	int
,	O
int	O
verbose_level	int
,	O
int	O
fp_tmo	int
)	O
{	O
pid_t	int
apid	int
;	O
int	O
ret	int
;	O
apid	int
=	O
pid	int
;	O
ret	int
=	O
swlib_wait_on_all_pids_with_timeout	(*(int),int,*(int),int,int,int)->(int)
(	O
&	O
apid	int
,	O
1	int
,	O
status	int
,	O
flags	int
,	O
verbose_level	int
,	O
fp_tmo	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_wait_on_all_pids_with_timeout	(*(int),int,*(int),int,int,int)->(int)
(	O
pid_t	int
*	O
pid	int
,	O
int	O
num	int
,	O
int	O
*	O
status	int
,	O
int	O
flags	int
,	O
int	O
verbose_level	int
,	O
int	O
fp_tmo	int
)	O
{	O
time_t	long
now	long
;	O
time_t	long
start	int
;	O
int	O
wret	int
=	O
-	O
99	int
;	O
int	O
done	int
=	O
0	int
;	O
int	O
i	int
=	O
0	int
;	O
int	O
got_one	int
=	O
0	int
;	O
int	O
tmo	int
;	O
int	O
do_kill	int
;	O
do_kill	int
=	O
0	int
;	O
if	O
(	O
fp_tmo	int
<	O
0	int
)	O
{	O
do_kill	int
=	O
1	int
;	O
tmo	int
=	O
-	O
fp_tmo	int
;	O
}	O
else	O
{	O
tmo	int
=	O
fp_tmo	int
;	O
}	O
if	O
(	O
num	int
==	O
0	int
)	O
return	O
0	int
;	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
start	int
=	O
time	struct(long,long)
(	O
NULL	O
)	O
;	O
now	long
=	O
start	int
;	O
while	O
(	O
!	O
done	int
&&	O
(	O
tmo	int
==	O
0	int
||	O
(	O
int	O
)	O
(	O
now	long
-	O
start	int
)	O
<	O
tmo	int
)	O
)	O
{	O
done	int
=	O
1	int
;	O
now	long
=	O
time	struct(long,long)
(	O
NULL	O
)	O
;	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
pid	int
[	O
i	int
]	O
>	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"pid=%d"	*(char)
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
)	O
;	O
wret	int
=	O
waitpid	(int,*(int),int)->(int)
(	O
pid	int
[	O
i	int
]	O
,	O
&	O
status	int
[	O
i	int
]	O
,	O
flags	int
)	O
;	O
E_DEBUG2	O
(	O
"wret=%d"	*(char)
,	O
wret	int
)	O
;	O
if	O
(	O
wret	int
<	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
SWC_VERBOSE_SWIDB	int
,	O
NULL	O
,	O
STDERR_FILENO	int
,	O
"swlib_wait_on_all_pids[%d]: error : %d %s\n"	*(char)
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
status	int
[	O
i	int
]	O
=	O
0	int
;	O
pid	int
[	O
i	int
]	O
=	O
-	O
pid	int
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
wret	int
==	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
SWC_VERBOSE_SWIDB	int
,	O
NULL	O
,	O
STDERR_FILENO	int
,	O
"swlib_wait_on_all_pids[%d]: returned zero waiting for process id %d\n"	*(char)
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
)	O
;	O
done	int
=	O
0	int
;	O
}	O
else	O
{	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
SWC_VERBOSE_SWIDB	int
,	O
NULL	O
,	O
STDERR_FILENO	int
,	O
"swlib_wait_on_all_pids[%d]: returned exitval=%d\n"	*(char)
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
,	O
WEXITSTATUS	O
(	O
status	int
[	O
i	int
]	O
)	O
)	O
;	O
got_one	int
=	O
1	int
;	O
pid	int
[	O
i	int
]	O
=	O
-	O
pid	int
[	O
i	int
]	O
;	O
}	O
}	O
else	O
{	O
E_DEBUG2	O
(	O
"already processed: pid=%d"	*(char)
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
)	O
;	O
;	O
}	O
}	O
if	O
(	O
flags	int
==	O
WNOHANG	int
)	O
done	int
=	O
1	int
;	O
}	O
if	O
(	O
do_kill	int
)	O
{	O
E_DEBUG	O
(	O
"killing pids SIGINT"	*(char)
)	O
;	O
swlib_kill_all_pids	(*(int),int,int,int)->(int)
(	O
pid	int
,	O
num	int
,	O
SIGINT	int
,	O
3	int
)	O
;	O
sleep	(int)->(int)
(	O
1	int
)	O
;	O
E_DEBUG	O
(	O
"killing pids SIGKILL"	*(char)
)	O
;	O
swlib_kill_all_pids	(*(int),int,int,int)->(int)
(	O
pid	int
,	O
num	int
,	O
SIGKILL	int
,	O
3	int
)	O
;	O
}	O
return	O
wret	int
;	O
}	O
int	O
swlib_sha1	(int,*(char))->(int)
(	O
int	O
uxfio_fd	int
,	O
char	O
*	O
digest	*(char)
)	O
{	O
int	O
i	int
;	O
int	O
ret	int
;	O
unsigned	O
char	O
resblock	*(void)
[	O
21	int
]	O
;	O
int	O
digest_hex_bytes	int
=	O
40	int
;	O
char	O
*	O
p	*(char)
;	O
ret	int
=	O
sha_stream	(int,*(void))->(int)
(	O
uxfio_fd	int
,	O
resblock	*(void)
)	O
;	O
p	*(char)
=	O
digest	*(char)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
digest_hex_bytes	int
/	O
2	int
)	O
;	O
++	O
i	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(char)
,	O
"%02x"	*(char)
,	O
resblock	*(void)
[	O
i	int
]	O
)	O
;	O
p	*(char)
+=	O
2	int
;	O
}	O
digest	*(char)
[	O
digest_hex_bytes	int
]	O
=	O
'\0'	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_digests	(int,*(char),*(char),*(char),*(char))->(int)
(	O
int	O
ifd	int
,	O
char	O
*	O
md5	array(char)
,	O
char	O
*	O
sha1	array(char)
,	O
char	O
*	O
size	array(char)
,	O
char	O
*	O
sha512	array(char)
)	O
{	O
intmax_t	long
im	long
;	O
FILE_DIGS	struct(int,array(char),short,array(char),short,array(char),short,array(char),short)
*	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
;	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
=	O
taru_digs_create	()->(*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short)))
(	O
)	O
;	O
if	O
(	O
md5	array(char)
)	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_md5	short
=	O
DIGS_ENABLE_ON	int
;	O
if	O
(	O
sha1	array(char)
)	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_sha1	short
=	O
DIGS_ENABLE_ON	int
;	O
if	O
(	O
sha512	array(char)
)	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_sha512	short
=	O
DIGS_ENABLE_ON	int
;	O
if	O
(	O
size	array(char)
)	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
do_size	short
=	O
DIGS_ENABLE_ON	int
;	O
im	long
=	O
swlib_digs_copy	(int,int,long,*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short)),int)->(long)
(	O
-	O
1	int
,	O
ifd	int
,	O
-	O
1	int
,	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
,	O
-	O
1	int
)	O
;	O
if	O
(	O
md5	array(char)
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
md5	array(char)
,	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
md5	array(char)
)	O
;	O
if	O
(	O
sha1	array(char)
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
sha1	array(char)
,	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
sha1	array(char)
)	O
;	O
if	O
(	O
sha512	array(char)
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
sha512	array(char)
,	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
sha512	array(char)
)	O
;	O
if	O
(	O
size	array(char)
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
size	array(char)
,	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
size	array(char)
)	O
;	O
taru_digs_delete	(*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short)))->(void)
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
)	O
;	O
if	O
(	O
im	long
>=	O
0	int
)	O
return	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
intmax_t	long
swlib_md5_copy	(int,long,*(char),int)->(long)
(	O
int	O
ifd	int
,	O
intmax_t	long
count	long
,	O
char	O
*	O
md5	array(char)
,	O
int	O
ofd	int
)	O
{	O
intmax_t	long
im	long
;	O
FILE_DIGS	struct(int,array(char),short,array(char),short,array(char),short,array(char),short)
*	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
;	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
=	O
taru_digs_create	()->(*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short)))
(	O
)	O
;	O
im	long
=	O
swlib_digs_copy	(int,int,long,*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short)),int)->(long)
(	O
ofd	int
,	O
ifd	int
,	O
count	long
,	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
,	O
-	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
md5	array(char)
,	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
->	O
md5	array(char)
)	O
;	O
taru_digs_delete	(*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short)))->(void)
(	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
)	O
;	O
return	O
im	long
;	O
}	O
intmax_t	long
swlib_digs_copy	(int,int,long,*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short)),int)->(long)
(	O
int	O
ofd	int
,	O
int	O
ifd	int
,	O
intmax_t	long
count	long
,	O
FILE_DIGS	struct(int,array(char),short,array(char),short,array(char),short,array(char),short)
*	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
,	O
int	O
adjunct_ofd	int
)	O
{	O
intmax_t	long
n	long
;	O
n	long
=	O
swlib_i_digs_copy	(int,int,long,*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short)),int,*((int,*(void),long)->(long)))->(long)
(	O
ofd	int
,	O
ifd	int
,	O
count	long
,	O
digs	*(struct(int,array(char),short,array(char),short,array(char),short,array(char),short))
,	O
adjunct_ofd	int
,	O
swlib_safe_read	(int,*(void),long)->(long)
)	O
;	O
return	O
n	long
;	O
}	O
int	O
swlib_shcmd_output_fd	(*(*(struct(*(char),*(char),*(struct`),*(*`),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*`),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int))))->(int)
(	O
SHCMD	struct(*(char),*(char),*(struct(*(*(char)),int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*(void))->(int)),*((int,int,*(void))->(int)),*(void),int,int,int,int)
*	O
*	O
cmdvec	*(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)))
)	O
{	O
int	O
status	int
;	O
SHCMD	struct(*(char),*(char),*(struct(*(*(char)),int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*(void))->(int)),*((int,int,*(void))->(int)),*(void),int,int,int,int)
*	O
*	O
vc	*(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)))
;	O
SHCMD	struct(*(char),*(char),*(struct(*(*(char)),int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*(void))->(int)),*((int,int,*(void))->(int)),*(void),int,int,int,int)
*	O
lastcmd	*(struct(*(char),*(char),*(struct(*(*`),int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*(void))->(int)),*((int,int,*(void))->(int)),*(void),int,int,int,int))
;	O
int	O
ot	array(int)
[	O
2	int
]	O
;	O
pid_t	int
pid	int
;	O
int	O
fd	int
;	O
vc	*(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)))
=	O
cmdvec	*(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)))
;	O
while	O
(	O
*	O
vc	*(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)))
)	O
vc	*(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)))
++	O
;	O
if	O
(	O
vc	*(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)))
==	O
cmdvec	*(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)))
)	O
return	O
-	O
1	int
;	O
vc	*(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)))
--	O
;	O
lastcmd	*(struct(*(char),*(char),*(struct(*(*`),int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*(void))->(int)),*((int,int,*(void))->(int)),*(void),int,int,int,int))
=	O
*	O
vc	*(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)))
;	O
fd	int
=	O
uxfio_open	(*(char),int,int)->(int)
(	O
""	*(char)
,	O
O_RDONLY	int
,	O
0	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
fd	int
;	O
uxfio_fcntl	(int,int,int)->(int)
(	O
fd	int
,	O
UXFIO_F_SET_BUFACTIVE	O
,	O
UXFIO_ON	int
)	O
;	O
uxfio_fcntl	(int,int,int)->(int)
(	O
fd	int
,	O
UXFIO_F_SET_BUFTYPE	O
,	O
UXFIO_BUFTYPE_DYNAMIC_MEM	int
)	O
;	O
pipe	(array(int))->(int)
(	O
ot	array(int)
)	O
;	O
pid	int
=	O
swfork	O
(	O
NULL	O
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
return	O
(	O
int	O
)	O
pid	int
;	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
swgp_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGPIPE	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGINT	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGTERM	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGUSR1	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGUSR2	int
,	O
SIG_DFL	O
)	O
;	O
close	*((*(void))->(int))
(	O
ot	array(int)
[	O
0	int
]	O
)	O
;	O
shcmd_set_dstfd	(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)),int)->(void)
(	O
lastcmd	*(struct(*(char),*(char),*(struct(*(*`),int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*(void))->(int)),*((int,int,*(void))->(int)),*(void),int,int,int,int))
,	O
ot	array(int)
[	O
1	int
]	O
)	O
;	O
shcmd_cmdvec_exec	(*(*(struct(*(char),*(char),*(struct`),*(*`),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*`),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int))))->(int)
(	O
cmdvec	*(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)))
)	O
;	O
shcmd_cmdvec_wait2	(*(*(struct(*(char),*(char),*(struct`),*(*`),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*`),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int))))->(int)
(	O
cmdvec	*(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)))
)	O
;	O
close	*((*(void))->(int))
(	O
ot	array(int)
[	O
1	int
]	O
)	O
;	O
_exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
close	*((*(void))->(int))
(	O
ot	array(int)
[	O
1	int
]	O
)	O
;	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
swlib_pipe_pump	(int,int)->(int)
(	O
fd	int
,	O
ot	array(int)
[	O
0	int
]	O
)	O
;	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
waitpid	(int,*(int),int)->(int)
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
uxfio_lseek	(int,long,int)->(long)
(	O
fd	int
,	O
(	O
off_t	long
)	O
(	O
0	int
)	O
,	O
SEEK_SET	int
)	O
;	O
close	*((*(void))->(int))
(	O
ot	array(int)
[	O
0	int
]	O
)	O
;	O
return	O
fd	int
;	O
}	O
int	O
swlib_shcmd_output_strob	(*(struct(*(char),*(char),int,int,int,char,int)),*(*(struct(*(char),*(char),*(struct`),*(*`),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*`),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int))))->(int)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
output	*(struct(*(char),*(char),int,int,int,char,int))
,	O
SHCMD	struct(*(char),*(char),*(struct(*(*(char)),int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*(void))->(int)),*((int,int,*(void))->(int)),*(void),int,int,int,int)
*	O
*	O
cmdvec	*(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)))
)	O
{	O
char	O
*	O
base	int
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
int	O
data_len	int
=	O
0	int
;	O
int	O
buffer_len	int
=	O
0	int
;	O
int	O
fd	int
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
output	*(struct(*(char),*(char),int,int,int,char,int))
,	O
""	*(char)
)	O
;	O
fd	int
=	O
swlib_shcmd_output_fd	(*(*(struct(*(char),*(char),*(struct`),*(*`),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*`),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int))))->(int)
(	O
cmdvec	*(*(struct(*(char),*(char),*(struct(*`,int,int,long,int)),*(*(char)),int,int,int,int,int,*(char),*(char),*(char),int,int,int,int,int,*(*(char)),array(char),array(char),int,array(int),*((*`)->(int)),*((int,int,*`)->(int)),*(void),int,int,int,int)))
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
uxfio_get_dynamic_buffer	(int,*(*(char)),*(int),*(int))->(int)
(	O
fd	int
,	O
&	O
base	int
,	O
&	O
buffer_len	int
,	O
&	O
data_len	int
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
strob_strncat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),long)->(*(char))
(	O
output	*(struct(*(char),*(char),int,int,int,char,int))
,	O
base	int
,	O
data_len	int
)	O
;	O
uxfio_close	(int)->(int)
(	O
fd	int
)	O
;	O
return	O
0	int
;	O
}	O
mode_t	int
swlib_apply_mode_umask	(char,int,int)->(int)
(	O
char	O
type	enum(int,int,int,int)
,	O
mode_t	int
umask	(int)->(int)
,	O
mode_t	int
mode	array(char)
)	O
{	O
if	O
(	O
mode	array(char)
==	O
0	int
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
==	O
SW_ITYPE_d	char
)	O
{	O
mode	array(char)
=	O
0777	int
;	O
}	O
else	O
{	O
mode	array(char)
=	O
0666	int
;	O
}	O
}	O
mode	array(char)
&=	O
~	O
umask	(int)->(int)
;	O
return	O
mode	array(char)
;	O
}	O
int	O
swlib_open_memfd	()->(int)
(	O
void	O
)	O
{	O
int	O
fd	int
;	O
fd	int
=	O
uxfio_open	(*(char),int,int)->(int)
(	O
""	*(char)
,	O
O_RDWR	int
,	O
0	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
fd	int
;	O
uxfio_fcntl	(int,int,int)->(int)
(	O
fd	int
,	O
UXFIO_F_SET_BUFACTIVE	O
,	O
UXFIO_ON	int
)	O
;	O
uxfio_fcntl	(int,int,int)->(int)
(	O
fd	int
,	O
UXFIO_F_SET_BUFTYPE	O
,	O
UXFIO_BUFTYPE_DYNAMIC_MEM	int
)	O
;	O
return	O
fd	int
;	O
}	O
int	O
swlib_close_memfd	(int)->(int)
(	O
int	O
fd	int
)	O
{	O
return	O
uxfio_close	(int)->(int)
(	O
fd	int
)	O
;	O
}	O
int	O
swlib_pad_amount	(int,int)->(int)
(	O
int	O
fd	int
,	O
int	O
amount	long
)	O
{	O
char	O
nullblock	array(char)
[	O
512	int
]	O
;	O
int	O
remains	int
=	O
amount	long
;	O
int	O
am	long
;	O
int	O
ret	int
;	O
int	O
count	long
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
nullblock	array(char)
,	O
'\0'	O
,	O
sizeof	O
(	O
nullblock	array(char)
)	O
)	O
;	O
while	O
(	O
remains	int
>	O
0	int
)	O
{	O
if	O
(	O
remains	int
>	O
512	int
)	O
am	long
=	O
512	int
;	O
else	O
am	long
=	O
remains	int
;	O
if	O
(	O
am	long
<=	O
0	int
)	O
break	O
;	O
ret	int
=	O
atomicio	(*((int,*(void),long)->(long)),int,*(void),long)->(long)
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
write	*((*(void),*(char),long)->(long))
,	O
fd	int
,	O
nullblock	array(char)
,	O
am	long
)	O
;	O
if	O
(	O
ret	int
<=	O
0	int
)	O
{	O
if	O
(	O
ret	int
<	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: write error: %s\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
else	O
SWLIB_INTERNAL	O
(	O
""	*(char)
)	O
;	O
if	O
(	O
count	long
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
-	O
count	long
;	O
}	O
count	long
+=	O
ret	int
;	O
remains	int
-=	O
ret	int
;	O
}	O
return	O
count	long
;	O
}	O
int	O
swlib_drop_root_privilege	()->(int)
(	O
void	O
)	O
{	O
int	O
ret	int
=	O
1	int
;	O
if	O
(	O
getuid	()->(int)
(	O
)	O
==	O
(	O
uid_t	int
)	O
(	O
0	int
)	O
)	O
{	O
uid_t	int
nob	int
;	O
if	O
(	O
taru_get_uid_by_name	(*(char),*(int))->(int)
(	O
AHS_USERNAME_NOBODY	*(char)
,	O
&	O
nob	int
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: Warning: the uname [%s] not found, not dropping privilege.\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
AHS_USERNAME_NOBODY	*(char)
)	O
;	O
ret	int
=	O
3	int
;	O
}	O
else	O
{	O
if	O
(	O
nob	int
<	O
10	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: User name 'nobody' has a uid of %d\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
(	O
int	O
)	O
(	O
nob	int
)	O
)	O
;	O
}	O
if	O
(	O
setuid	(int)->(int)
(	O
nob	int
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: setuid(uid=%d) failed at %s:%d: %s\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
(	O
int	O
)	O
nob	int
,	O
__FILE__	O
,	O
__LINE__	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
ret	int
=	O
2	int
;	O
}	O
else	O
{	O
ret	int
=	O
0	int
;	O
}	O
}	O
}	O
else	O
{	O
ret	int
=	O
0	int
;	O
}	O
return	O
ret	int
;	O
}	O
void	O
swlib_add_trailing_slash	(*(struct(*(char),*(char),int,int,int,char,int)))->(void)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
path	*(char)
)	O
{	O
char	O
*	O
p	*(char)
=	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
path	*(char)
)	O
;	O
if	O
(	O
!	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
)	O
{	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
path	*(char)
,	O
"/"	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
*	O
(	O
p	*(char)
+	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
-	O
1	int
)	O
!=	O
'/'	O
)	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
path	*(char)
,	O
"/"	*(char)
)	O
;	O
}	O
int	O
swlib_altfnmatch	(*(char),*(char))->(int)
(	O
char	O
*	O
s1	*(char)
,	O
char	O
*	O
s2	*(char)
)	O
{	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp1	*(struct(*(char),*(char),int,int,int,char,int))
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp2	*(struct(*(char),*(char),int,int,int,char,int))
;	O
char	O
*	O
t1	*(char)
;	O
char	O
*	O
t2	*(char)
;	O
tmp1	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
16	int
)	O
;	O
tmp2	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
16	int
)	O
;	O
t1	*(char)
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp1	*(struct(*(char),*(char),int,int,int,char,int))
,	O
s1	*(char)
,	O
"|\n\r"	*(char)
)	O
;	O
while	O
(	O
t1	*(char)
)	O
{	O
t2	*(char)
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp2	*(struct(*(char),*(char),int,int,int,char,int))
,	O
s2	*(char)
,	O
"|\n\r"	*(char)
)	O
;	O
while	O
(	O
t2	*(char)
)	O
{	O
if	O
(	O
fnmatch	(*(char),*(char),int)->(int)
(	O
t1	*(char)
,	O
t2	*(char)
,	O
0	int
)	O
!=	O
FNM_NOMATCH	int
)	O
{	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
tmp1	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
tmp2	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
return	O
0	int
;	O
}	O
t2	*(char)
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp2	*(struct(*(char),*(char),int,int,int,char,int))
,	O
NULL	O
,	O
"|\n\r"	*(char)
)	O
;	O
}	O
t1	*(char)
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp1	*(struct(*(char),*(char),int,int,int,char,int))
,	O
NULL	O
,	O
"|\n\r"	*(char)
)	O
;	O
}	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
tmp1	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
tmp2	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
return	O
1	int
;	O
}	O
int	O
swlib_unexpand_escapes	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(int)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
char	O
*	O
src	*(char)
)	O
{	O
int	O
n	long
;	O
int	O
k	int
;	O
char	O
*	O
lp	*(char)
;	O
int	O
retval	int
=	O
0	int
;	O
int	O
len	int
;	O
int	O
escaped_value	int
;	O
int	O
is_recognized	int
;	O
char	O
*	O
dst	*(char)
;	O
if	O
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
==	O
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
)	O
NULL	O
)	O
{	O
dst	*(char)
=	O
src	*(char)
;	O
}	O
else	O
{	O
strob_set_length	(*(struct(*(char),*(char),int,int,int,char,int)),int)->(void)
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
strlen	(*(char))->(long)
(	O
src	*(char)
)	O
)	O
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
""	*(char)
)	O
;	O
dst	*(char)
=	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
k	int
=	O
0	int
;	O
lp	*(char)
=	O
src	*(char)
;	O
len	int
=	O
0	int
;	O
n	long
=	O
strlen	(*(char))->(long)
(	O
src	*(char)
)	O
;	O
while	O
(	O
k	int
<	O
n	long
)	O
{	O
if	O
(	O
*	O
(	O
lp	*(char)
+	O
k	int
)	O
==	O
'\\'	O
&&	O
*	O
(	O
lp	*(char)
+	O
k	int
+	O
1	int
)	O
!=	O
'\0'	O
)	O
{	O
escaped_value	int
=	O
swlib_ansi_escaped_value	(int,*(int))->(int)
(	O
(	O
int	O
)	O
(	O
*	O
(	O
lp	*(char)
+	O
k	int
+	O
1	int
)	O
)	O
,	O
&	O
is_recognized	int
)	O
;	O
if	O
(	O
!	O
is_recognized	int
)	O
{	O
escaped_value	int
=	O
swlib_c701_escaped_value	(int,*(int))->(int)
(	O
(	O
int	O
)	O
(	O
*	O
(	O
lp	*(char)
+	O
k	int
+	O
1	int
)	O
)	O
,	O
&	O
is_recognized	int
)	O
;	O
}	O
if	O
(	O
escaped_value	int
<	O
0	int
)	O
{	O
dst	*(char)
[	O
len	int
]	O
=	O
'\0'	O
;	O
SWLIB_ASSERT	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
is_recognized	int
==	O
0	int
)	O
{	O
dst	*(char)
[	O
len	int
]	O
=	O
*	O
(	O
lp	*(char)
+	O
k	int
)	O
;	O
len	int
++	O
;	O
k	int
++	O
;	O
}	O
else	O
{	O
dst	*(char)
[	O
len	int
]	O
=	O
escaped_value	int
;	O
len	int
++	O
;	O
k	int
+=	O
2	int
;	O
}	O
}	O
else	O
{	O
dst	*(char)
[	O
len	int
]	O
=	O
*	O
(	O
lp	*(char)
+	O
k	int
)	O
;	O
len	int
++	O
;	O
k	int
++	O
;	O
}	O
}	O
dst	*(char)
[	O
len	int
]	O
=	O
'\0'	O
;	O
return	O
retval	int
;	O
}	O
int	O
swlib_unexpand_escapes2	(*(char))->(int)
(	O
char	O
*	O
src	*(char)
)	O
{	O
int	O
ret	int
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
dst	*(char)
;	O
dst	*(char)
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
10	int
)	O
;	O
ret	int
=	O
swlib_unexpand_escapes	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(int)
(	O
dst	*(char)
,	O
src	*(char)
)	O
;	O
if	O
(	O
ret	int
)	O
return	O
ret	int
;	O
if	O
(	O
strob_strlen	(*(struct(*(char),*(char),int,int,int,char,int)))->(long)
(	O
dst	*(char)
)	O
>	O
strlen	(*(char))->(long)
(	O
src	*(char)
)	O
)	O
return	O
-	O
1	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
src	*(char)
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
dst	*(char)
)	O
)	O
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
dst	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swlib_tee_to_file	(*(char),int,*(char),int,int)->(int)
(	O
char	O
*	O
filename	*(char)
,	O
int	O
ifd	int
,	O
char	O
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
int	O
len	int
,	O
int	O
do_append	int
)	O
{	O
int	O
ret	int
;	O
int	O
fd	int
;	O
int	O
res	int
;	O
int	O
flags	int
;	O
flags	int
=	O
O_RDWR	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
;	O
if	O
(	O
do_append	int
)	O
flags	int
=	O
O_RDWR	int
|	O
O_CREAT	int
|	O
O_APPEND	int
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
(	O
int	O
)	O
(	O
*	O
filename	*(char)
)	O
)	O
)	O
{	O
fd	int
=	O
swlib_atoi	(*(char),*(int))->(int)
(	O
filename	*(char)
,	O
&	O
res	int
)	O
;	O
if	O
(	O
res	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
filename	*(char)
,	O
flags	int
,	O
0644	int
)	O
;	O
}	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
fd	int
;	O
if	O
(	O
ifd	int
<	O
0	int
)	O
{	O
if	O
(	O
len	int
<	O
0	int
)	O
{	O
ret	int
=	O
uxfio_unix_safe_write	(int,*(void),int)->(long)
(	O
fd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
strlen	(*(char))->(long)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
;	O
if	O
(	O
ret	int
!=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
ret	int
=	O
uxfio_unix_safe_write	(int,*(void),int)->(long)
(	O
fd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
len	int
)	O
;	O
if	O
(	O
ret	int
!=	O
(	O
int	O
)	O
len	int
)	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
ret	int
=	O
swlib_pipe_pump	(int,int)->(int)
(	O
fd	int
,	O
ifd	int
)	O
;	O
}	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_expand_escapes	(*(*(char)),*(int),*(char),*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
char	O
*	O
*	O
pa	*(*(char))
,	O
int	O
*	O
newlen	*(int)
,	O
char	O
*	O
src	*(char)
,	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
ustore	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
int	O
n	long
=	O
strlen	(*(char))->(long)
(	O
src	*(char)
)	O
;	O
int	O
count	long
=	O
0	int
;	O
int	O
i	int
=	O
0	int
,	O
j	int
=	O
0	int
,	O
k	int
=	O
0	int
;	O
char	O
*	O
lp	*(char)
=	O
src	*(char)
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
store	*(struct(*(char),*(char),int,int,int,char,int))
;	O
if	O
(	O
ustore	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
store	*(struct(*(char),*(char),int,int,int,char,int))
=	O
ustore	*(struct(*(char),*(char),int,int,int,char,int))
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
""	*(char)
)	O
;	O
}	O
else	O
{	O
store	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
20	int
)	O
;	O
}	O
if	O
(	O
!	O
store	*(struct(*(char),*(char),int,int,int,char,int))
)	O
return	O
-	O
1	int
;	O
while	O
(	O
k	int
<	O
n	long
)	O
{	O
if	O
(	O
*	O
(	O
lp	*(char)
+	O
k	int
)	O
==	O
'\\'	O
)	O
{	O
count	long
++	O
;	O
if	O
(	O
count	long
%	O
2	int
&&	O
(	O
*	O
(	O
lp	*(char)
+	O
k	int
+	O
1	int
)	O
==	O
'n'	O
)	O
)	O
{	O
count	long
=	O
0	int
;	O
strob_chr_index	(*(struct(*(char),*(char),int,int,int,char,int)),int,int)->(void)
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
i	int
+	O
j	int
,	O
'\n'	O
)	O
;	O
k	int
++	O
;	O
}	O
else	O
{	O
strob_chr_index	(*(struct(*(char),*(char),int,int,int,char,int)),int,int)->(void)
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
i	int
+	O
j	int
,	O
*	O
(	O
lp	*(char)
+	O
k	int
)	O
)	O
;	O
if	O
(	O
count	long
%	O
2	int
)	O
{	O
if	O
(	O
!	O
swlib_is_ansi_escape	(int)->(int)
(	O
*	O
(	O
lp	*(char)
+	O
k	int
+	O
1	int
)	O
)	O
&&	O
!	O
swlib_is_c701_escape	(int)->(int)
(	O
*	O
(	O
lp	*(char)
+	O
k	int
+	O
1	int
)	O
)	O
)	O
{	O
j	int
++	O
;	O
strob_chr_index	(*(struct(*(char),*(char),int,int,int,char,int)),int,int)->(void)
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
i	int
+	O
j	int
,	O
*	O
(	O
lp	*(char)
+	O
k	int
)	O
)	O
;	O
}	O
else	O
{	O
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
*	O
(	O
lp	*(char)
+	O
k	int
)	O
<	O
(	O
int	O
)	O
7	int
&&	O
*	O
(	O
lp	*(char)
+	O
k	int
)	O
>	O
0	int
)	O
||	O
*	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
lp	*(char)
+	O
k	int
)	O
)	O
>=	O
127	int
)	O
{	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
1	int
,	O
"\\x%02X"	*(char)
,	O
*	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
lp	*(char)
+	O
k	int
)	O
)	O
)	O
;	O
j	int
+=	O
3	int
;	O
}	O
else	O
{	O
count	long
=	O
0	int
;	O
if	O
(	O
*	O
(	O
lp	*(char)
+	O
k	int
)	O
==	O
'#'	O
)	O
{	O
if	O
(	O
strob_get_char	(*(struct(*(char),*(char),int,int,int,char,int)),int)->(int)
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
i	int
+	O
j	int
-	O
1	int
)	O
!=	O
'\\'	O
)	O
{	O
strob_chr_index	(*(struct(*(char),*(char),int,int,int,char,int)),int,int)->(void)
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
i	int
+	O
j	int
,	O
'\\'	O
)	O
;	O
j	int
++	O
;	O
}	O
strob_chr_index	(*(struct(*(char),*(char),int,int,int,char,int)),int,int)->(void)
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
i	int
+	O
j	int
,	O
'#'	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
(	O
lp	*(char)
+	O
k	int
)	O
==	O
'\"'	O
)	O
{	O
if	O
(	O
strob_get_char	(*(struct(*(char),*(char),int,int,int,char,int)),int)->(int)
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
i	int
+	O
j	int
-	O
1	int
)	O
!=	O
'\\'	O
)	O
{	O
strob_chr_index	(*(struct(*(char),*(char),int,int,int,char,int)),int,int)->(void)
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
i	int
+	O
j	int
,	O
'\\'	O
)	O
;	O
j	int
++	O
;	O
}	O
strob_chr_index	(*(struct(*(char),*(char),int,int,int,char,int)),int,int)->(void)
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
i	int
+	O
j	int
,	O
'\"'	O
)	O
;	O
}	O
else	O
{	O
strob_chr_index	(*(struct(*(char),*(char),int,int,int,char,int)),int,int)->(void)
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
i	int
+	O
j	int
,	O
*	O
(	O
lp	*(char)
+	O
k	int
)	O
)	O
;	O
}	O
}	O
i	int
++	O
;	O
k	int
++	O
;	O
}	O
strob_chr_index	(*(struct(*(char),*(char),int,int,int,char,int)),int,int)->(void)
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
,	O
i	int
+	O
j	int
,	O
'\0'	O
)	O
;	O
if	O
(	O
!	O
ustore	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
pa	*(*(char))
)	O
*	O
pa	*(*(char))
=	O
strob_release	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pa	*(*(char))
)	O
*	O
pa	*(*(char))
=	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
store	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
if	O
(	O
newlen	*(int)
)	O
*	O
newlen	*(int)
=	O
i	int
+	O
j	int
;	O
return	O
0	int
;	O
}	O
char	O
*	O
swlib_imaxtostr	(long,*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
intmax_t	long
i	int
,	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
pbuf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
static	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
sbuf	*(struct(*(char),*(char),int,int,int,char,int))
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
;	O
char	O
*	O
ret	int
;	O
if	O
(	O
pbuf	*(struct(*(char),*(char),int,int,int,char,int))
==	O
NULL	O
)	O
{	O
if	O
(	O
sbuf	*(struct(*(char),*(char),int,int,int,char,int))
==	O
NULL	O
)	O
sbuf	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
32	int
)	O
;	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
=	O
sbuf	*(struct(*(char),*(char),int,int,int,char,int))
;	O
}	O
else	O
{	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
=	O
pbuf	*(struct(*(char),*(char),int,int,int,char,int))
;	O
}	O
strob_setlen	(*(struct(*(char),*(char),int,int,int,char,int)),int)->(int)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
UINTMAX_STRSIZE_BOUND	O
+	O
1	int
)	O
;	O
ret	int
=	O
imaxtostr	(long,*(char))->(*(char))
(	O
i	int
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
;	O
return	O
ret	int
;	O
}	O
char	O
*	O
swlib_umaxtostr	(long,*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
uintmax_t	long
i	int
,	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
pbuf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
static	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
;	O
char	O
*	O
ret	int
;	O
if	O
(	O
pbuf	*(struct(*(char),*(char),int,int,int,char,int))
==	O
NULL	O
)	O
{	O
if	O
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
==	O
NULL	O
)	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
32	int
)	O
;	O
}	O
else	O
{	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
=	O
pbuf	*(struct(*(char),*(char),int,int,int,char,int))
;	O
}	O
strob_setlen	(*(struct(*(char),*(char),int,int,int,char,int)),int)->(int)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
UINTMAX_STRSIZE_BOUND	O
+	O
1	int
)	O
;	O
ret	int
=	O
umaxtostr	(long,*(char))->(*(char))
(	O
i	int
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
;	O
return	O
ret	int
;	O
}	O
mode_t	int
swlib_get_umask	()->(int)
(	O
void	O
)	O
{	O
mode_t	int
mode	array(char)
=	O
0777	int
;	O
mode	array(char)
=	O
umask	(int)->(int)
(	O
mode	array(char)
)	O
;	O
umask	(int)->(int)
(	O
mode	array(char)
)	O
;	O
return	O
mode	array(char)
;	O
}	O
int	O
swlib_ascii_text_fd_to_buf	(*(struct(*(char),*(char),int,int,int,char,int)),int)->(int)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
pbuf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
int	O
ifd	int
)	O
{	O
intmax_t	long
amount	long
;	O
int	O
ret	int
;	O
amount	long
=	O
-	O
1	int
;	O
ret	int
=	O
swlib_i_pipe_pump	(int,int,*(long),int,*(struct(*(char),*(char),int,int,int,char,int)),*((int,*(void),long)->(long)))->(long)
(	O
ifd	int
,	O
-	O
1	int
,	O
(	O
intmax_t	long
*	O
)	O
&	O
amount	long
,	O
-	O
1	int
,	O
pbuf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
uxfio_read	(int,*(void),long)->(long)
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
||	O
(	O
int	O
)	O
amount	long
!=	O
(	O
int	O
)	O
strob_strlen	(*(struct(*(char),*(char),int,int,int,char,int)))->(long)
(	O
pbuf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"swlib_ascii_text_fd_to_buf: warning, size not equal to strlen\n"	*(char)
)	O
;	O
ret	int
=	O
-	O
1	int
;	O
}	O
return	O
ret	int
;	O
}	O
void	O
swlib_apply_location	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(char))->(void)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
relocated_path	*(struct(*(char),*(char),int,int,int,char,int))
,	O
char	O
*	O
path	*(char)
,	O
char	O
*	O
location	*(char)
,	O
char	O
*	O
directory	*(char)
)	O
{	O
char	O
*	O
prefix	array(char)
;	O
char	O
*	O
clean_directory	*(char)
;	O
char	O
*	O
clean_location	*(char)
;	O
char	O
*	O
clean_path	*(char)
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
relocated_path	*(struct(*(char),*(char),int,int,int,char,int))
,	O
""	*(char)
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
path	*(char)
)	O
==	O
0	int
)	O
return	O
;	O
clean_path	*(char)
=	O
swlib_return_no_leading	(*(char))->(*(char))
(	O
path	*(char)
)	O
;	O
clean_location	*(char)
=	O
swlib_return_no_leading	(*(char))->(*(char))
(	O
location	*(char)
)	O
;	O
clean_directory	*(char)
=	O
swlib_return_no_leading	(*(char))->(*(char))
(	O
directory	*(char)
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
clean_directory	*(char)
)	O
>	O
0	int
&&	O
strlen	(*(char))->(long)
(	O
clean_path	*(char)
)	O
>	O
0	int
)	O
{	O
prefix	array(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
clean_path	*(char)
,	O
clean_directory	*(char)
)	O
;	O
if	O
(	O
prefix	array(char)
!=	O
NULL	O
&&	O
prefix	array(char)
==	O
clean_path	*(char)
)	O
{	O
clean_path	*(char)
+=	O
strlen	(*(char))->(long)
(	O
clean_directory	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
;	O
}	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
relocated_path	*(struct(*(char),*(char),int,int,int,char,int))
,	O
location	*(char)
)	O
;	O
swlib_unix_dircat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(int)
(	O
relocated_path	*(struct(*(char),*(char),int,int,int,char,int))
,	O
clean_path	*(char)
)	O
;	O
return	O
;	O
}	O
char	O
*	O
swlib_attribute_check_default	(*(char),*(char),*(char))->(*(char))
(	O
char	O
*	O
object	*(char)
,	O
char	O
*	O
keyword	*(char)
,	O
char	O
*	O
value	long
)	O
{	O
char	O
*	O
d	*(char)
;	O
if	O
(	O
value	long
)	O
return	O
value	long
;	O
d	*(char)
=	O
swsdflt_get_default_value	(*(char),*(char))->(*(char))
(	O
object	*(char)
,	O
keyword	*(char)
)	O
;	O
if	O
(	O
d	*(char)
==	O
NULL	O
)	O
{	O
SWLIB_ERROR3	O
(	O
"no default value found for attribute: %s %s"	*(char)
,	O
object	*(char)
,	O
keyword	*(char)
)	O
;	O
return	O
""	*(char)
;	O
}	O
return	O
d	*(char)
;	O
}	O
int	O
swlib_is_option_true	(*(char))->(int)
(	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
!	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
return	O
0	int
;	O
return	O
swextopt_is_value_true	(*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
void	O
swlib_squash_illegal_tag_chars	(*(char))->(void)
(	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
while	O
(	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
!=	O
(	O
int	O
)	O
'\0'	O
)	O
{	O
if	O
(	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
==	O
'.'	O
)	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
'_'	O
;	O
if	O
(	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
==	O
','	O
)	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
'_'	O
;	O
if	O
(	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
==	O
':'	O
)	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
'_'	O
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
++	O
;	O
}	O
}	O
void	O
swlib_append_synct_eof	(*(struct(*(char),*(char),int,int,int,char,int)))->(void)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
1	int
,	O
") | dd ibs=%d obs=%d 2>/dev/null | dd ibs=%d obs=%d conv=sync 2>/dev/null |\n"	*(char)
"	(\n"	*(char)
"		dd bs=%d 2>/dev/null\n"	*(char)
"		( printf \""	*(char)
CPIO_INBAND_EOA_FILENAME	*(char)
"\\r\\n\\r\\n\"\n"	*(char)
"		) | dd ibs=%d obs=%d conv=sync 2>/dev/null\n"	*(char)
"	)\n"	*(char)
") | dd ibs=%d obs=%d conv=sync 2>/dev/null\n"	*(char)
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
3	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
3	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
2	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
2	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
2	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
2	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
2	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
2	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
2	int
)	O
;	O
return	O
;	O
}	O
