static	O
char	O
*	O
progname	*(char)
=	O
"install-info"	*(char)
;	O
static	O
char	O
*	O
default_section	*(char)
=	O
NULL	O
;	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
;	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
;	O
struct	O
line_data	struct(*(char),int,*(*(struct)),*(*(struct)),int,int)
*	O
findlines	(*(char),int,*(int))->(*(struct))
(	O
char	O
*	O
data	*(char)
,	O
int	O
size	int
,	O
int	O
*	O
nlinesp	*(int)
)	O
;	O
void	O
insert_entry_here	(*(struct),int,*(struct),int)->(void)
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entry	*(struct)
,	O
int	O
line_number	int
,	O
struct	O
line_data	struct(*(char),int,*(*(struct)),*(*(struct)),int,int)
*	O
dir_lines	*(struct)
,	O
int	O
n_entries	int
)	O
;	O
int	O
compare_section_names	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
s1	*(char)
,	O
const	O
void	O
*	O
s2	*(char)
)	O
;	O
int	O
compare_entries_text	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
e1	*(void)
,	O
const	O
void	O
*	O
e2	*(void)
)	O
;	O
struct	O
line_data	struct(*(char),int,*(*(struct)),*(*(struct)),int,int)
{	O
char	O
*	O
start	*(long)
;	O
int	O
size	int
;	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
*	O
add_entries_before	*(*(struct))
;	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
*	O
add_sections_before	*(*(struct))
;	O
int	O
num_sections_to_add	int
;	O
int	O
delete	int
;	O
}	O
;	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
{	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
char	O
*	O
name	*(char)
;	O
int	O
missing	int
;	O
}	O
;	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
{	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
char	O
*	O
text	*(char)
;	O
size_t	long
text_len	long
;	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
entry_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
entry_sections_tail	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
int	O
missing_name	int
;	O
int	O
missing_description	int
;	O
int	O
missing_basename	int
;	O
}	O
;	O
struct	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
{	O
struct	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
*	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
char	O
*	O
name	*(char)
;	O
int	O
start_line	int
;	O
int	O
end_line	int
;	O
char	O
*	O
menu_start	*(char)
;	O
struct	O
menu_section	struct(*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int)),*(char),int,int)
*	O
sections	*(struct)
;	O
struct	O
menu_section	struct(*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int)),*(char),int,int)
*	O
last_section	*(struct)
;	O
}	O
;	O
struct	O
menu_section	struct(*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int)),*(char),int,int)
{	O
struct	O
menu_section	struct(*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int)),*(char),int,int)
*	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
char	O
*	O
name	*(char)
;	O
int	O
start_line	int
;	O
int	O
end_line	int
;	O
}	O
;	O
struct	O
option	struct(*(char),int,*(int),int)
longopts	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"add-once"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'1'	O
}	O
,	O
{	O
"align"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'A'	O
}	O
,	O
{	O
"append-new-sections"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'a'	O
}	O
,	O
{	O
"calign"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'C'	O
}	O
,	O
{	O
"debug"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'g'	O
}	O
,	O
{	O
"delete"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"defentry"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'E'	O
}	O
,	O
{	O
"defsection"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'S'	O
}	O
,	O
{	O
"dir-file"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"entry"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"name"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
't'	O
}	O
,	O
{	O
"menuentry"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
't'	O
}	O
,	O
{	O
"description"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'c'	O
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"no-indent"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'I'	O
}	O
,	O
{	O
"infodir"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'D'	O
}	O
,	O
{	O
"info-dir"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'D'	O
}	O
,	O
{	O
"info-file"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"item"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"keep-old"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'k'	O
}	O
,	O
{	O
"maxwidth"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'W'	O
}	O
,	O
{	O
"max-width"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'W'	O
}	O
,	O
{	O
"quiet"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'q'	O
}	O
,	O
{	O
"remove"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"remove-exactly"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'x'	O
}	O
,	O
{	O
"section"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"regex"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'R'	O
}	O
,	O
{	O
"silent"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'q'	O
}	O
,	O
{	O
"test"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
{	O
"dry-run"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
*	O
psecreg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
=	O
NULL	O
;	O
int	O
remove_exactly	int
=	O
0	int
;	O
int	O
remove_empty_sections	int
=	O
1	int
;	O
int	O
add_entries_into_all_matching_sections	int
=	O
1	int
;	O
int	O
keep_old_flag	int
=	O
0	int
;	O
int	O
chicken_flag	int
=	O
0	int
;	O
int	O
indent_flag	int
=	O
1	int
;	O
int	O
order_new_sections_alphabetically_flag	int
=	O
1	int
;	O
void	O
vdiag	(*(char),*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
const	O
char	O
*	O
diagtype	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: "	*(char)
,	O
progname	*(char)
)	O
;	O
if	O
(	O
diagtype	*(char)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: "	*(char)
,	O
diagtype	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
void	O
error	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vdiag	(*(char),*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
fmt	*(char)
,	O
NULL	O
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
warning	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vdiag	(*(char),*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
fmt	*(char)
,	O
"warning"	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
fatal	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vdiag	(*(char),*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
fmt	*(char)
,	O
NULL	O
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
char	O
*	O
concat	(*(char),*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
s1	*(char)
,	O
const	O
char	O
*	O
s2	*(char)
,	O
const	O
char	O
*	O
s3	*(char)
)	O
{	O
int	O
len1	int
=	O
strlen	(*(char))->(long)
(	O
s1	*(char)
)	O
,	O
len2	int
=	O
strlen	(*(char))->(long)
(	O
s2	*(char)
)	O
,	O
len3	int
=	O
strlen	(*(char))->(long)
(	O
s3	*(char)
)	O
;	O
char	O
*	O
result	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
len1	int
+	O
len2	int
+	O
len3	int
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
result	*(char)
,	O
s1	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
result	*(char)
+	O
len1	int
,	O
s2	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
result	*(char)
+	O
len1	int
+	O
len2	int
,	O
s3	*(char)
)	O
;	O
*	O
(	O
result	*(char)
+	O
len1	int
+	O
len2	int
+	O
len3	int
)	O
=	O
0	int
;	O
return	O
result	*(char)
;	O
}	O
char	O
*	O
copy_string	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
string	*(char)
,	O
int	O
size	int
)	O
{	O
int	O
i	int
;	O
char	O
*	O
copy	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
size	int
+	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
copy	*(char)
[	O
i	int
]	O
=	O
string	*(char)
[	O
i	int
]	O
;	O
copy	*(char)
[	O
size	int
]	O
=	O
0	int
;	O
return	O
copy	*(char)
;	O
}	O
void	O
pfatal_with_name	(*(char))->(void)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
errno	O
==	O
0	int
)	O
fatal	(*(char))->(void)
(	O
_	O
(	O
"%s: empty file"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
fatal	(*(char))->(void)
(	O
_	O
(	O
"%s for %s"	*(char)
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
,	O
name	*(char)
)	O
;	O
}	O
static	O
int	O
menu_line_lessp	(*(char),int,*(char),int)->(int)
(	O
char	O
*	O
line1	*(char)
,	O
int	O
len1	int
,	O
char	O
*	O
line2	*(char)
,	O
int	O
len2	int
)	O
{	O
int	O
minlen	int
=	O
(	O
len1	int
<	O
len2	int
?	O
len1	int
:	O
len2	int
)	O
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
minlen	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
line1	*(char)
[	O
i	int
]	O
==	O
':'	O
&&	O
line2	*(char)
[	O
i	int
]	O
!=	O
':'	O
)	O
return	O
1	int
;	O
if	O
(	O
line2	*(char)
[	O
i	int
]	O
==	O
':'	O
&&	O
line1	*(char)
[	O
i	int
]	O
!=	O
':'	O
)	O
return	O
0	int
;	O
if	O
(	O
line1	*(char)
[	O
i	int
]	O
<	O
line2	*(char)
[	O
i	int
]	O
)	O
return	O
1	int
;	O
if	O
(	O
line1	*(char)
[	O
i	int
]	O
>	O
line2	*(char)
[	O
i	int
]	O
)	O
return	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
menu_line_equal	(*(char),int,*(char),int)->(int)
(	O
char	O
*	O
line1	*(char)
,	O
int	O
len1	int
,	O
char	O
*	O
line2	*(char)
,	O
int	O
len2	int
)	O
{	O
int	O
minlen	int
=	O
(	O
len1	int
<	O
len2	int
?	O
len1	int
:	O
len2	int
)	O
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
minlen	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
line1	*(char)
[	O
i	int
]	O
==	O
':'	O
&&	O
line2	*(char)
[	O
i	int
]	O
==	O
':'	O
)	O
return	O
1	int
;	O
if	O
(	O
line1	*(char)
[	O
i	int
]	O
!=	O
line2	*(char)
[	O
i	int
]	O
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
char	O
*	O
extract_menu_item_name	(*(char))->(*(char))
(	O
char	O
*	O
item_text	*(char)
)	O
{	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
*	O
item_text	*(char)
==	O
'*'	O
)	O
item_text	*(char)
++	O
;	O
while	O
(	O
*	O
item_text	*(char)
==	O
' '	O
)	O
item_text	*(char)
++	O
;	O
p	*(void)
=	O
item_text	*(char)
;	O
while	O
(	O
*	O
p	*(void)
&&	O
*	O
p	*(void)
!=	O
':'	O
)	O
p	*(void)
++	O
;	O
return	O
copy_string	(*(char),int)->(*(char))
(	O
item_text	*(char)
,	O
p	*(void)
-	O
item_text	*(char)
)	O
;	O
}	O
char	O
*	O
extract_menu_file_name	(*(char))->(*(char))
(	O
char	O
*	O
item_text	*(char)
)	O
{	O
char	O
*	O
p	*(void)
=	O
item_text	*(char)
;	O
if	O
(	O
*	O
p	*(void)
==	O
'*'	O
)	O
p	*(void)
++	O
;	O
while	O
(	O
*	O
p	*(void)
==	O
' '	O
)	O
p	*(void)
++	O
;	O
while	O
(	O
*	O
p	*(void)
&&	O
*	O
p	*(void)
!=	O
'\n'	O
&&	O
*	O
p	*(void)
!=	O
':'	O
)	O
p	*(void)
++	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
':'	O
)	O
p	*(void)
++	O
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
*	O
p	*(void)
==	O
'('	O
)	O
break	O
;	O
else	O
if	O
(	O
*	O
p	*(void)
==	O
' '	O
||	O
*	O
p	*(void)
==	O
'\t'	O
)	O
p	*(void)
++	O
;	O
else	O
return	O
"(none)"	*(char)
;	O
}	O
p	*(void)
++	O
;	O
item_text	*(char)
=	O
p	*(void)
;	O
while	O
(	O
*	O
p	*(void)
&&	O
*	O
p	*(void)
!=	O
'\n'	O
&&	O
*	O
p	*(void)
!=	O
')'	O
)	O
p	*(void)
++	O
;	O
if	O
(	O
*	O
p	*(void)
!=	O
')'	O
)	O
return	O
"(none)"	*(char)
;	O
return	O
copy_string	(*(char),int)->(*(char))
(	O
item_text	*(char)
,	O
p	*(void)
-	O
item_text	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
strip_info_suffix	(*(char))->(*(char))
(	O
char	O
*	O
fname	*(char)
)	O
{	O
char	O
*	O
ret	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
fname	*(char)
)	O
;	O
unsigned	O
len	int
=	O
strlen	(*(char))->(long)
(	O
ret	*(char)
)	O
;	O
if	O
(	O
len	int
>	O
3	int
&&	O
FILENAME_CMP	O
(	O
ret	*(char)
+	O
len	int
-	O
3	int
,	O
".gz"	*(char)
)	O
==	O
0	int
)	O
{	O
len	int
-=	O
3	int
;	O
ret	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
len	int
>	O
3	int
&&	O
FILENAME_CMP	O
(	O
ret	*(char)
+	O
len	int
-	O
3	int
,	O
".xz"	*(char)
)	O
==	O
0	int
)	O
{	O
len	int
-=	O
3	int
;	O
ret	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
len	int
>	O
4	int
&&	O
FILENAME_CMP	O
(	O
ret	*(char)
+	O
len	int
-	O
4	int
,	O
".bz2"	*(char)
)	O
==	O
0	int
)	O
{	O
len	int
-=	O
4	int
;	O
ret	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
len	int
>	O
3	int
&&	O
FILENAME_CMP	O
(	O
ret	*(char)
+	O
len	int
-	O
3	int
,	O
".lz"	*(char)
)	O
==	O
0	int
)	O
{	O
len	int
-=	O
3	int
;	O
ret	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
len	int
>	O
5	int
&&	O
FILENAME_CMP	O
(	O
ret	*(char)
+	O
len	int
-	O
5	int
,	O
".lzma"	*(char)
)	O
==	O
0	int
)	O
{	O
len	int
-=	O
5	int
;	O
ret	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
len	int
>	O
5	int
&&	O
FILENAME_CMP	O
(	O
ret	*(char)
+	O
len	int
-	O
5	int
,	O
".info"	*(char)
)	O
==	O
0	int
)	O
{	O
len	int
-=	O
5	int
;	O
ret	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
len	int
>	O
4	int
&&	O
FILENAME_CMP	O
(	O
ret	*(char)
+	O
len	int
-	O
4	int
,	O
".inf"	*(char)
)	O
==	O
0	int
)	O
{	O
len	int
-=	O
4	int
;	O
ret	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
}	O
return	O
ret	*(char)
;	O
}	O
static	O
int	O
menu_item_equal	(*(char),char,*(char))->(int)
(	O
const	O
char	O
*	O
item	*(char)
,	O
char	O
term_char	char
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
ret	*(char)
;	O
const	O
char	O
*	O
item_basename	*(char)
=	O
item	*(char)
;	O
unsigned	O
name_len	int
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
remove_exactly	int
)	O
{	O
while	O
(	O
*	O
item_basename	*(char)
&&	O
!	O
IS_SLASH	O
(	O
*	O
item_basename	*(char)
)	O
&&	O
*	O
item_basename	*(char)
!=	O
term_char	char
)	O
item_basename	*(char)
++	O
;	O
if	O
(	O
!	O
*	O
item_basename	*(char)
||	O
*	O
item_basename	*(char)
==	O
term_char	char
)	O
item_basename	*(char)
=	O
item	*(char)
;	O
else	O
item_basename	*(char)
++	O
;	O
}	O
ret	*(char)
=	O
mbsncasecmp	(*(char),*(char),long)->(int)
(	O
item_basename	*(char)
,	O
name	*(char)
,	O
name_len	int
)	O
==	O
0	int
;	O
if	O
(	O
ret	*(char)
)	O
{	O
static	O
char	O
*	O
suffixes	array(*(char))
[	O
]	O
=	O
{	O
""	*(char)
,	O
".info.gz"	*(char)
,	O
".info"	*(char)
,	O
".inf"	*(char)
,	O
".gz"	*(char)
,	O
NULL	O
}	O
;	O
unsigned	O
i	int
;	O
ret	*(char)
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
!	O
ret	*(char)
&&	O
suffixes	array(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
char	O
*	O
suffix	*(char)
=	O
suffixes	array(*(char))
[	O
i	int
]	O
;	O
unsigned	O
suffix_len	int
=	O
strlen	(*(char))->(long)
(	O
suffix	*(char)
)	O
;	O
ret	*(char)
=	O
mbsncasecmp	(*(char),*(char),long)->(int)
(	O
item_basename	*(char)
+	O
name_len	int
,	O
suffix	*(char)
,	O
suffix_len	int
)	O
==	O
0	int
&&	O
item_basename	*(char)
[	O
name_len	int
+	O
suffix_len	int
]	O
==	O
term_char	char
;	O
}	O
}	O
return	O
ret	*(char)
;	O
}	O
void	O
suggest_asking_for_help	()->(void)
(	O
void	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\tTry `%s --help' for a complete list of options.\n"	*(char)
)	O
,	O
progname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
void	O
print_help	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Usage: %s [OPTION]... [INFO-FILE [DIR-FILE]]\n"	*(char)
)	O
,	O
progname	*(char)
)	O
;	O
puts	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
"Add or remove entries in INFO-FILE from the Info directory DIR-FILE."	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
"INFO-FILE and DIR-FILE are required unless the --info-file\nor --dir-file (or --info-dir) options are given, respectively."	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
"Options:\n --add-once          add only to first matching section, not all.\n --align=COL         start description of new entries at column COL.\n --calign=COL        format second and subsequent description lines to\n                       start at column COL."	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
" --debug             report what is being done.\n --delete            delete existing entries for INFO-FILE from DIR-FILE;\n                      don't insert any new entries.\n --defsection=TEXT   like --section, but only use TEXT if no sections\n                      are present in INFO-FILE (replacing \"Miscellaneous\").\n --description=TEXT  the description of the entry is TEXT; used with\n                      the --name option to become synonymous with the\n                      --entry option.\n --dir-file=NAME     specify file name of Info directory file;\n                      equivalent to using the DIR-FILE argument.\n --dry-run           same as --test."	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
" --entry=TEXT        insert TEXT as an Info directory entry,\n                      overriding any corresponding entry from DIR-FILE.\n                      TEXT is written as an Info menu item line followed\n                       by zero or more extra lines starting with whitespace.\n                      If you specify more than one entry, all are added.\n                      If you don't specify any entries, they are determined\n                       from information in the Info file itself."	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
" --help              display this help and exit.\n --info-dir=DIR      same as --dir-file=DIR/dir.\n --info-file=FILE    specify Info file to install in the directory;\n                      equivalent to using the INFO-FILE argument.\n --item=TEXT         same as --entry=TEXT.\n --keep-old          do not replace entries, or remove empty sections."	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
" --maxwidth, --max-width=COL  wrap description at column COL.\n --menuentry=TEXT    same as --name=TEXT.\n --name=TEXT         the name of the entry is TEXT; used with --description\n                      to become synonymous with the --entry option.\n --no-indent         do not format new entries in the DIR file.\n --quiet             suppress warnings."	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
" --regex=R           put this file's entries in all sections that match the\n                      regular expression R (ignoring case).\n --remove            same as --delete.\n --remove-exactly    only remove if the info file name matches exactly;\n                      suffixes such as .info and .gz are not ignored.\n --section=SEC       put entries in section SEC of the directory.\n                      If you specify more than one section, all the entries\n                       are added in each of the sections.\n                      If you don't specify any sections, they are determined\n                       from information in the Info file itself;\n                       if nothing is available there, the --defsection\n                       value is used; if that is not specified, the\n                       final default is \"Miscellaneous\".\n --section R SEC     equivalent to --regex=R --section=SEC --add-once."	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
" --silent            suppress warnings.\n --test              suppress updating of DIR-FILE.\n --version           display version information and exit."	*(char)
)	O
)	O
;	O
puts	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
"Email bug reports to bug-texinfo@gnu.org,\ngeneral questions and discussion to help-texinfo@gnu.org.\nTexinfo home page: http://www.gnu.org/software/texinfo/"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
ensure_dirfile_exists	(*(char))->(void)
(	O
char	O
*	O
dirfile	*(char)
)	O
{	O
int	O
desc	int
;	O
if	O
(	O
chicken_flag	int
)	O
return	O
;	O
desc	int
=	O
open	(*(char),int)->(int)
(	O
dirfile	*(char)
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
desc	int
<	O
0	int
&&	O
errno	O
==	O
ENOENT	int
)	O
{	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
readerr	*(char)
=	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
dirfile	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"This is the file .../info/dir, which contains the\ntopmost node of the Info hierarchy, called (dir)Top.\nThe first time you invoke Info you start off looking at this node.\n%c\n%s\tThis is the top of the INFO tree\n\n  This (the Directory node) gives a menu of major topics.\n  Typing \"q\" exits, \"H\" lists all Info commands, \"d\" returns here,\n  \"h\" gives a primer for first-timers,\n  \"mEmacs<Return>\" visits the Emacs manual, etc.\n\n  In Emacs, you can click mouse button 2 on a menu item or cross reference\n  to select it.\n\n%s\n"	*(char)
)	O
,	O
'\x1f'	O
,	O
"File: dir,\tNode: Top"	*(char)
,	O
"* Menu:"	*(char)
)	O
;	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
<	O
0	int
)	O
pfatal_with_name	(*(char))->(void)
(	O
dirfile	*(char)
)	O
;	O
}	O
else	O
{	O
fatal	(*(char))->(void)
(	O
_	O
(	O
"%s: could not read (%s) and could not create (%s)"	*(char)
)	O
,	O
dirfile	*(char)
,	O
readerr	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
else	O
close	*((*(void))->(int))
(	O
desc	int
)	O
;	O
}	O
FILE	struct
*	O
open_possibly_compressed_file	(*(char),*((*(char))->(void)),*(*(char)),*(*(char)))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
char	O
*	O
filename	*(char)
,	O
void	O
(	O
*	O
create_callback	*((*(char))->(void))
)	O
(	O
char	O
*	O
)	O
,	O
char	O
*	O
*	O
opened_filename	*(*(char))
,	O
char	O
*	O
*	O
compression_program	*(*(char))
)	O
{	O
char	O
*	O
local_opened_filename	*(char)
,	O
*	O
local_compression_program	*(char)
;	O
int	O
nread	int
;	O
char	O
data	*(char)
[	O
13	int
]	O
;	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
if	O
(	O
!	O
opened_filename	*(*(char))
)	O
opened_filename	*(*(char))
=	O
&	O
local_opened_filename	*(char)
;	O
*	O
opened_filename	*(*(char))
=	O
filename	*(char)
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
*	O
opened_filename	*(*(char))
,	O
FOPEN_RBIN	*(char)
)	O
;	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
*	O
opened_filename	*(*(char))
=	O
concat	(*(char),*(char),*(char))->(*(char))
(	O
filename	*(char)
,	O
".gz"	*(char)
,	O
""	*(char)
)	O
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
*	O
opened_filename	*(*(char))
,	O
FOPEN_RBIN	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
free	(*(void))->(void)
(	O
*	O
opened_filename	*(*(char))
)	O
;	O
*	O
opened_filename	*(*(char))
=	O
concat	(*(char),*(char),*(char))->(*(char))
(	O
filename	*(char)
,	O
".xz"	*(char)
,	O
""	*(char)
)	O
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
*	O
opened_filename	*(*(char))
,	O
FOPEN_RBIN	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
free	(*(void))->(void)
(	O
*	O
opened_filename	*(*(char))
)	O
;	O
*	O
opened_filename	*(*(char))
=	O
concat	(*(char),*(char),*(char))->(*(char))
(	O
filename	*(char)
,	O
".bz2"	*(char)
,	O
""	*(char)
)	O
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
*	O
opened_filename	*(*(char))
,	O
FOPEN_RBIN	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
free	(*(void))->(void)
(	O
*	O
opened_filename	*(*(char))
)	O
;	O
*	O
opened_filename	*(*(char))
=	O
concat	(*(char),*(char),*(char))->(*(char))
(	O
filename	*(char)
,	O
".lz"	*(char)
,	O
""	*(char)
)	O
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
*	O
opened_filename	*(*(char))
,	O
FOPEN_RBIN	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
free	(*(void))->(void)
(	O
*	O
opened_filename	*(*(char))
)	O
;	O
*	O
opened_filename	*(*(char))
=	O
concat	(*(char),*(char),*(char))->(*(char))
(	O
filename	*(char)
,	O
".lzma"	*(char)
,	O
""	*(char)
)	O
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
*	O
opened_filename	*(*(char))
,	O
FOPEN_RBIN	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
free	(*(void))->(void)
(	O
*	O
opened_filename	*(*(char))
)	O
;	O
*	O
opened_filename	*(*(char))
=	O
filename	*(char)
;	O
if	O
(	O
create_callback	*((*(char))->(void))
)	O
{	O
(	O
*	O
create_callback	*((*(char))->(void))
)	O
(	O
filename	*(char)
)	O
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
*	O
opened_filename	*(*(char))
,	O
FOPEN_RBIN	*(char)
)	O
;	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
return	O
0	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
nread	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
data	*(char)
,	O
sizeof	O
(	O
data	*(char)
)	O
,	O
1	int
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
nread	int
!=	O
1	int
)	O
{	O
if	O
(	O
nread	int
==	O
0	int
)	O
{	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
&&	O
create_callback	*((*(char))->(void))
)	O
{	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
remove	(*(char))->(int)
(	O
filename	*(char)
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
(	O
*	O
create_callback	*((*(char))->(void))
)	O
(	O
filename	*(char)
)	O
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
*	O
opened_filename	*(*(char))
,	O
FOPEN_RBIN	*(char)
)	O
;	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
return	O
0	int
;	O
nread	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
data	*(char)
,	O
sizeof	O
(	O
data	*(char)
)	O
,	O
1	int
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
nread	int
==	O
0	int
)	O
return	O
0	int
;	O
goto	O
determine_file_type	O
;	O
}	O
}	O
errno	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
determine_file_type	O
:	O
if	O
(	O
!	O
compression_program	*(*(char))
)	O
compression_program	*(*(char))
=	O
&	O
local_compression_program	*(char)
;	O
if	O
(	O
data	*(char)
[	O
0	int
]	O
==	O
'\x1f'	O
&&	O
data	*(char)
[	O
1	int
]	O
==	O
'\x8b'	O
)	O
*	O
compression_program	*(*(char))
=	O
"gzip"	*(char)
;	O
else	O
if	O
(	O
data	*(char)
[	O
0	int
]	O
==	O
'\xFD'	O
&&	O
data	*(char)
[	O
1	int
]	O
==	O
'7'	O
&&	O
data	*(char)
[	O
2	int
]	O
==	O
'z'	O
&&	O
data	*(char)
[	O
3	int
]	O
==	O
'X'	O
&&	O
data	*(char)
[	O
4	int
]	O
==	O
'Z'	O
&&	O
data	*(char)
[	O
5	int
]	O
==	O
0	int
)	O
*	O
compression_program	*(*(char))
=	O
"xz"	*(char)
;	O
else	O
if	O
(	O
data	*(char)
[	O
0	int
]	O
==	O
'B'	O
&&	O
data	*(char)
[	O
1	int
]	O
==	O
'Z'	O
&&	O
data	*(char)
[	O
2	int
]	O
==	O
'h'	O
)	O
*	O
compression_program	*(*(char))
=	O
"bzip2"	*(char)
;	O
else	O
if	O
(	O
data	*(char)
[	O
0	int
]	O
==	O
'B'	O
&&	O
data	*(char)
[	O
1	int
]	O
==	O
'Z'	O
&&	O
data	*(char)
[	O
2	int
]	O
==	O
'0'	O
)	O
*	O
compression_program	*(*(char))
=	O
"bzip"	*(char)
;	O
else	O
if	O
(	O
data	*(char)
[	O
0	int
]	O
==	O
0x4C	int
&&	O
data	*(char)
[	O
1	int
]	O
==	O
0x5A	int
&&	O
data	*(char)
[	O
2	int
]	O
==	O
0x49	int
&&	O
data	*(char)
[	O
3	int
]	O
==	O
0x50	int
&&	O
data	*(char)
[	O
4	int
]	O
==	O
1	int
)	O
*	O
compression_program	*(*(char))
=	O
"lzip"	*(char)
;	O
else	O
if	O
(	O
(	O
data	*(char)
[	O
9	int
]	O
==	O
0x00	int
&&	O
data	*(char)
[	O
10	int
]	O
==	O
0x00	int
&&	O
data	*(char)
[	O
11	int
]	O
==	O
0x00	int
&&	O
data	*(char)
[	O
12	int
]	O
==	O
0x00	int
)	O
||	O
(	O
data	*(char)
[	O
5	int
]	O
==	O
'\xFF'	O
&&	O
data	*(char)
[	O
6	int
]	O
==	O
'\xFF'	O
&&	O
data	*(char)
[	O
7	int
]	O
==	O
'\xFF'	O
&&	O
data	*(char)
[	O
8	int
]	O
==	O
'\xFF'	O
&&	O
data	*(char)
[	O
9	int
]	O
==	O
'\xFF'	O
&&	O
data	*(char)
[	O
10	int
]	O
==	O
'\xFF'	O
&&	O
data	*(char)
[	O
11	int
]	O
==	O
'\xFF'	O
&&	O
data	*(char)
[	O
12	int
]	O
==	O
'\xFF'	O
)	O
||	O
(	O
data	*(char)
[	O
0	int
]	O
==	O
'\xFF'	O
&&	O
data	*(char)
[	O
1	int
]	O
==	O
'L'	O
&&	O
data	*(char)
[	O
2	int
]	O
==	O
'Z'	O
&&	O
data	*(char)
[	O
3	int
]	O
==	O
'M'	O
&&	O
data	*(char)
[	O
4	int
]	O
==	O
'A'	O
&&	O
data	*(char)
[	O
5	int
]	O
==	O
0x00	int
)	O
)	O
*	O
compression_program	*(*(char))
=	O
"lzma"	*(char)
;	O
else	O
*	O
compression_program	*(*(char))
=	O
NULL	O
;	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
0	int
,	O
0	int
)	O
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
*	O
compression_program	*(*(char))
)	O
{	O
char	O
*	O
command	*(char)
=	O
concat	(*(char),*(char),*(char))->(*(char))
(	O
*	O
compression_program	*(*(char))
,	O
" -d"	*(char)
,	O
""	*(char)
)	O
;	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
<	O
0	int
)	O
return	O
0	int
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
freopen	(*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
*	O
opened_filename	*(*(char))
,	O
FOPEN_RBIN	*(char)
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
return	O
0	int
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
command	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
*	O
opened_filename	*(*(char))
=	O
command	*(char)
;	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
}	O
return	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
char	O
*	O
readfile	(*(char),*(int),*((*(char))->(void)),*(*(char)),*(*(char)))->(*(char))
(	O
char	O
*	O
filename	*(char)
,	O
int	O
*	O
sizep	*(int)
,	O
void	O
(	O
*	O
create_callback	*((*(char))->(void))
)	O
(	O
char	O
*	O
)	O
,	O
char	O
*	O
*	O
opened_filename	*(*(char))
,	O
char	O
*	O
*	O
compression_program	*(*(char))
)	O
{	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
filled	int
=	O
0	int
;	O
int	O
data_size	int
=	O
8192	int
;	O
char	O
*	O
data	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
data_size	int
)	O
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
open_possibly_compressed_file	(*(char),*((*(char))->(void)),*(*(char)),*(*(char)))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
create_callback	*((*(char))->(void))
,	O
opened_filename	*(*(char))
,	O
compression_program	*(*(char))
)	O
;	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
return	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
nread	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
data	*(char)
+	O
filled	int
,	O
1	int
,	O
data_size	int
-	O
filled	int
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
nread	int
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
nread	int
==	O
0	int
)	O
break	O
;	O
filled	int
+=	O
nread	int
;	O
if	O
(	O
filled	int
==	O
data_size	int
)	O
{	O
data_size	int
+=	O
65536	int
;	O
data	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
data	*(char)
,	O
data_size	int
)	O
;	O
}	O
}	O
if	O
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
*	O
sizep	*(int)
=	O
filled	int
;	O
return	O
data	*(char)
;	O
}	O
static	O
void	O
output_dirfile	(*(char),int,*(struct(*(char),int,*(*(struct`)),*(*(struct`)),int,int)),int,*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)),*(struct(*(struct(*`,*`,int)),*(char),int)),*(char))->(void)
(	O
char	O
*	O
dirfile	*(char)
,	O
int	O
dir_nlines	int
,	O
struct	O
line_data	struct(*(char),int,*(*(struct)),*(*(struct)),int,int)
*	O
dir_lines	*(struct)
,	O
int	O
n_entries_to_add	int
,	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
,	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
,	O
char	O
*	O
compression_program	*(*(char))
)	O
{	O
int	O
n_entries_added	int
=	O
0	int
;	O
int	O
i	int
;	O
FILE	struct
*	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
if	O
(	O
compression_program	*(*(char))
)	O
{	O
char	O
*	O
command	*(char)
=	O
concat	(*(char),*(char),*(char))->(*(char))
(	O
compression_program	*(*(char))
,	O
">"	*(char)
,	O
dirfile	*(char)
)	O
;	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
command	*(char)
,	O
"w"	*(char)
)	O
;	O
}	O
else	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
dirfile	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
!	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
perror	(*(char))->(void)
(	O
dirfile	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
dir_nlines	int
;	O
i	int
++	O
)	O
{	O
int	O
j	int
;	O
if	O
(	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
add_entries_before	*(*(struct))
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
n_entries_to_add	int
;	O
j	int
++	O
)	O
{	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
this	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
=	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
add_entries_before	*(*(struct))
[	O
j	int
]	O
;	O
if	O
(	O
this	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
==	O
0	int
)	O
break	O
;	O
if	O
(	O
n_entries_added	int
>=	O
1	int
&&	O
!	O
add_entries_into_all_matching_sections	int
)	O
break	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
this	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
->	O
text	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
n_entries_added	int
++	O
;	O
}	O
if	O
(	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
add_sections_before	*(*(struct))
)	O
{	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entry	*(struct)
;	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
*	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
;	O
int	O
n_entries	int
=	O
0	int
;	O
if	O
(	O
n_entries_added	int
>=	O
1	int
&&	O
!	O
add_entries_into_all_matching_sections	int
)	O
break	O
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
add_sections_before	*(*(struct))
,	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
num_sections_to_add	int
,	O
sizeof	O
(	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
)	O
,	O
compare_section_names	(*(void),*(void))->(int)
)	O
;	O
for	O
(	O
entry	*(struct)
=	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
;	O
entry	*(struct)
;	O
entry	*(struct)
=	O
entry	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
n_entries	int
++	O
;	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
=	O
(	O
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
n_entries	int
*	O
sizeof	O
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
)	O
)	O
)	O
;	O
j	int
=	O
0	int
;	O
for	O
(	O
entry	*(struct)
=	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
;	O
entry	*(struct)
;	O
entry	*(struct)
=	O
entry	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
[	O
j	int
++	O
]	O
=	O
entry	*(struct)
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
,	O
n_entries	int
,	O
sizeof	O
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
)	O
,	O
compare_entries_text	(*(void),*(void))->(int)
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
num_sections_to_add	int
;	O
j	int
++	O
)	O
{	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
add_sections_before	*(*(struct))
[	O
j	int
]	O
;	O
if	O
(	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing	int
)	O
{	O
int	O
k	int
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n_entries	int
;	O
k	int
++	O
)	O
{	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
spec1	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
entry	*(struct)
=	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
[	O
k	int
]	O
;	O
for	O
(	O
spec1	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
entry	*(struct)
->	O
entry_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
spec1	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
&&	O
spec1	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
!=	O
entry	*(struct)
->	O
entry_sections_tail	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
spec1	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
spec1	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
spec1	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
,	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
)	O
)	O
break	O
;	O
}	O
if	O
(	O
spec1	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
&&	O
spec1	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
!=	O
entry	*(struct)
->	O
entry_sections_tail	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
entry	*(struct)
->	O
text	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
}	O
n_entries_added	int
++	O
;	O
free	(*(void))->(void)
(	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
)	O
;	O
}	O
if	O
(	O
i	int
<	O
dir_nlines	int
&&	O
!	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
delete	int
)	O
{	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
start	*(long)
,	O
1	int
,	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
size	int
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
if	O
(	O
compression_program	*(*(char))
)	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
int	O
parse_input	(*(struct(*(char),int,*(*(struct`)),*(*(struct`)),int,int)),int,*(*(struct(*(struct`),*(char),int))),*(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int))),int)->(int)
(	O
const	O
struct	O
line_data	struct(*(char),int,*(*(struct)),*(*(struct)),int,int)
*	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
,	O
int	O
nlines	int
,	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
*	O
sections	*(struct)
,	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
*	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
,	O
int	O
delete_flag	int
)	O
{	O
int	O
n_entries	int
=	O
0	int
;	O
int	O
prefix_length	int
=	O
strlen	(*(char))->(long)
(	O
"INFO-DIR-SECTION "	*(char)
)	O
;	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
head	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
*	O
sections	*(struct)
,	O
*	O
tail	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
NULL	O
;	O
int	O
reset_tail	int
=	O
0	int
;	O
char	O
*	O
start_of_this_entry	*(char)
=	O
0	int
;	O
int	O
ignore_sections	int
=	O
*	O
sections	*(struct)
!=	O
0	int
;	O
int	O
ignore_entries	int
=	O
delete_flag	int
?	O
0	int
:	O
*	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
!=	O
0	int
;	O
int	O
i	int
;	O
if	O
(	O
ignore_sections	int
&&	O
ignore_entries	int
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nlines	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
ignore_sections	int
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
"INFO-DIR-SECTION "	*(char)
,	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
,	O
prefix_length	int
)	O
)	O
{	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
(	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
)	O
)	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
=	O
copy_string	(*(char),int)->(*(char))
(	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
+	O
prefix_length	int
,	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
size	int
-	O
prefix_length	int
)	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
*	O
sections	*(struct)
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing	int
=	O
1	int
;	O
if	O
(	O
reset_tail	int
)	O
{	O
tail	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
*	O
sections	*(struct)
;	O
reset_tail	int
=	O
0	int
;	O
}	O
*	O
sections	*(struct)
=	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
head	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
*	O
sections	*(struct)
;	O
}	O
else	O
if	O
(	O
!	O
ignore_entries	int
)	O
{	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
"START-INFO-DIR-ENTRY"	*(char)
,	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
,	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
size	int
)	O
&&	O
sizeof	O
(	O
"START-INFO-DIR-ENTRY"	*(char)
)	O
-	O
1	int
==	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
size	int
)	O
{	O
if	O
(	O
!	O
*	O
sections	*(struct)
)	O
{	O
*	O
sections	*(struct)
=	O
(	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
)	O
)	O
;	O
(	O
*	O
sections	*(struct)
)	O
->	O
name	*(char)
=	O
"Miscellaneous"	*(char)
;	O
(	O
*	O
sections	*(struct)
)	O
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
0	int
;	O
(	O
*	O
sections	*(struct)
)	O
->	O
missing	int
=	O
1	int
;	O
head	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
*	O
sections	*(struct)
;	O
}	O
reset_tail	int
=	O
1	int
;	O
if	O
(	O
start_of_this_entry	*(char)
!=	O
0	int
)	O
fatal	(*(char))->(void)
(	O
_	O
(	O
"START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"	*(char)
)	O
)	O
;	O
start_of_this_entry	*(char)
=	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
+	O
1	int
]	O
.	O
start	*(long)
;	O
}	O
else	O
if	O
(	O
start_of_this_entry	*(char)
)	O
{	O
if	O
(	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
"* "	*(char)
,	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
,	O
2	int
)	O
&&	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
>	O
start_of_this_entry	*(char)
)	O
||	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
"END-INFO-DIR-ENTRY"	*(char)
,	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
,	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
size	int
)	O
&&	O
sizeof	O
(	O
"END-INFO-DIR-ENTRY"	*(char)
)	O
-	O
1	int
==	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
size	int
)	O
)	O
{	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
)	O
)	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text	*(char)
=	O
copy_string	(*(char),int)->(*(char))
(	O
start_of_this_entry	*(char)
,	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
-	O
start_of_this_entry	*(char)
)	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text_len	long
=	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
-	O
start_of_this_entry	*(char)
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
entry_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
head	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
entry_sections_tail	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
tail	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing_basename	int
=	O
0	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
*	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
;	O
*	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
=	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
n_entries	int
++	O
;	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
"END-INFO-DIR-ENTRY"	*(char)
,	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
,	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
size	int
)	O
&&	O
sizeof	O
(	O
"END-INFO-DIR-ENTRY"	*(char)
)	O
-	O
1	int
==	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
size	int
)	O
start_of_this_entry	*(char)
=	O
0	int
;	O
else	O
start_of_this_entry	*(char)
=	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
"END-INFO-DIR-ENTRY"	*(char)
,	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
,	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
size	int
)	O
&&	O
sizeof	O
(	O
"END-INFO-DIR-ENTRY"	*(char)
)	O
-	O
1	int
==	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
size	int
)	O
fatal	(*(char))->(void)
(	O
_	O
(	O
"END-INFO-DIR-ENTRY without matching START-INFO-DIR-ENTRY"	*(char)
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
start_of_this_entry	*(char)
!=	O
0	int
)	O
fatal	(*(char))->(void)
(	O
_	O
(	O
"START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"	*(char)
)	O
)	O
;	O
if	O
(	O
ignore_entries	int
&&	O
*	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
)	O
{	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entry	*(struct)
;	O
for	O
(	O
entry	*(struct)
=	O
*	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
;	O
entry	*(struct)
;	O
entry	*(struct)
=	O
entry	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
entry	*(struct)
->	O
entry_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
head	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
entry	*(struct)
->	O
entry_sections_tail	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
tail	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
}	O
}	O
return	O
n_entries	int
;	O
}	O
static	O
void	O
parse_dir_file	(*(struct(*(char),int,*(*(struct`)),*(*(struct`)),int,int)),int,*(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`)))))->(void)
(	O
struct	O
line_data	struct(*(char),int,*(*(struct)),*(*(struct)),int,int)
*	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
,	O
int	O
nlines	int
,	O
struct	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
*	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
)	O
{	O
int	O
node_header_flag	int
=	O
0	int
;	O
int	O
i	int
;	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nlines	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
node_header_flag	int
)	O
{	O
int	O
j	int
,	O
end	*(long)
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
size	int
;	O
j	int
++	O
)	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
"Node:"	*(char)
,	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
+	O
j	int
,	O
5	int
)	O
)	O
{	O
char	O
*	O
line	*(char)
=	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
;	O
j	int
+=	O
5	int
;	O
while	O
(	O
line	*(char)
[	O
j	int
]	O
==	O
' '	O
||	O
line	*(char)
[	O
j	int
]	O
==	O
'\t'	O
)	O
j	int
++	O
;	O
end	*(long)
=	O
j	int
;	O
while	O
(	O
line	*(char)
[	O
end	*(long)
]	O
!=	O
0	int
&&	O
line	*(char)
[	O
end	*(long)
]	O
!=	O
','	O
&&	O
line	*(char)
[	O
end	*(long)
]	O
!=	O
'\n'	O
&&	O
line	*(char)
[	O
end	*(long)
]	O
!=	O
'\t'	O
)	O
end	*(long)
++	O
;	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
)	O
->	O
name	*(char)
=	O
copy_string	(*(char),int)->(*(char))
(	O
line	*(char)
+	O
j	int
,	O
end	*(long)
-	O
j	int
)	O
;	O
}	O
node_header_flag	int
=	O
0	int
;	O
}	O
if	O
(	O
*	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
==	O
037	int
)	O
{	O
struct	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
*	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
(	O
struct	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
)	O
)	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
=	O
NULL	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
start_line	int
=	O
i	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
end_line	int
=	O
0	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
menu_start	*(char)
=	O
NULL	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
sections	*(struct)
=	O
NULL	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
last_section	*(struct)
=	O
NULL	O
;	O
if	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
!=	O
0	int
)	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
)	O
->	O
end_line	int
=	O
i	int
;	O
if	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
!=	O
0	int
&&	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
)	O
->	O
last_section	*(struct)
!=	O
0	int
)	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
)	O
->	O
last_section	*(struct)
->	O
end_line	int
=	O
i	int
;	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
=	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
node_header_flag	int
=	O
1	int
;	O
}	O
if	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
!=	O
0	int
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
"* Menu:"	*(char)
,	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
,	O
7	int
)	O
)	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
)	O
->	O
menu_start	*(char)
=	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
+	O
1	int
]	O
.	O
start	*(long)
;	O
if	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
!=	O
0	int
&&	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
)	O
->	O
menu_start	*(char)
!=	O
0	int
&&	O
*	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
!=	O
'\n'	O
&&	O
*	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
!=	O
'*'	O
&&	O
*	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
!=	O
' '	O
&&	O
*	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
!=	O
'\t'	O
)	O
{	O
struct	O
menu_section	struct(*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int)),*(char),int,int)
*	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
(	O
struct	O
menu_section	struct(*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int)),*(char),int,int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
menu_section	struct(*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int)),*(char),int,int)
)	O
)	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
start_line	int
=	O
i	int
+	O
1	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
0	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
end_line	int
=	O
0	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
=	O
copy_string	(*(char),int)->(*(char))
(	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
,	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
size	int
)	O
;	O
if	O
(	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
)	O
->	O
sections	*(struct)
)	O
{	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
)	O
->	O
last_section	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
)	O
->	O
last_section	*(struct)
->	O
end_line	int
=	O
i	int
;	O
}	O
else	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
)	O
->	O
sections	*(struct)
=	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
)	O
->	O
last_section	*(struct)
=	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
}	O
}	O
if	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
!=	O
0	int
)	O
{	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
)	O
->	O
end_line	int
=	O
nlines	int
;	O
if	O
(	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
)	O
->	O
last_section	*(struct)
!=	O
0	int
)	O
(	O
*	O
nodes	*(*(struct(*(struct(*`,*`,int,int,*`,*`,*`)),*(char),int,int,*(char),*(struct(*`,*`,int,int)),*(struct(*`,*`,int,int)))))
)	O
->	O
last_section	*(struct)
->	O
end_line	int
=	O
nlines	int
;	O
}	O
}	O
int	O
mark_entry_for_deletion	(*(struct(*(char),int,*(*(struct`)),*(*(struct`)),int,int)),int,*(char))->(int)
(	O
struct	O
line_data	struct(*(char),int,*(*(struct)),*(*(struct)),int,int)
*	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
,	O
int	O
nlines	int
,	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
something_deleted	int
=	O
0	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nlines	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
*	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
==	O
'*'	O
)	O
{	O
char	O
*	O
q	*(char)
;	O
char	O
*	O
p	*(void)
=	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
;	O
p	*(void)
++	O
;	O
while	O
(	O
*	O
p	*(void)
==	O
' '	O
)	O
p	*(void)
++	O
;	O
q	*(char)
=	O
p	*(void)
;	O
while	O
(	O
*	O
p	*(void)
!=	O
0	int
&&	O
*	O
p	*(void)
!=	O
':'	O
)	O
p	*(void)
++	O
;	O
p	*(void)
++	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
':'	O
)	O
{	O
if	O
(	O
menu_item_equal	(*(char),char,*(char))->(int)
(	O
q	*(char)
,	O
':'	O
,	O
name	*(char)
)	O
)	O
{	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
delete	int
=	O
1	int
;	O
something_deleted	int
=	O
1	int
;	O
}	O
}	O
else	O
{	O
while	O
(	O
*	O
p	*(void)
==	O
' '	O
)	O
p	*(void)
++	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'('	O
)	O
{	O
p	*(void)
++	O
;	O
if	O
(	O
menu_item_equal	(*(char),char,*(char))->(int)
(	O
p	*(void)
,	O
')'	O
,	O
name	*(char)
)	O
)	O
{	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
delete	int
=	O
1	int
;	O
something_deleted	int
=	O
1	int
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
i	int
>	O
0	int
&&	O
(	O
*	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
==	O
' '	O
||	O
*	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
start	*(long)
==	O
'\t'	O
)	O
)	O
{	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
]	O
.	O
delete	int
=	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
i	int
-	O
1	int
]	O
.	O
delete	int
;	O
}	O
}	O
return	O
something_deleted	int
;	O
}	O
static	O
size_t	long
adjust_column	(long,char)->(long)
(	O
size_t	long
column	long
,	O
char	O
c	int
)	O
{	O
if	O
(	O
c	int
==	O
'\b'	O
)	O
{	O
if	O
(	O
column	long
>	O
0	int
)	O
column	long
--	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\r'	O
)	O
column	long
=	O
0	int
;	O
else	O
if	O
(	O
c	int
==	O
'\t'	O
)	O
column	long
+=	O
TAB_WIDTH	int
-	O
column	long
%	O
TAB_WIDTH	int
;	O
else	O
column	long
++	O
;	O
return	O
column	long
;	O
}	O
static	O
int	O
format_entry	(*(char),long,*(char),long,int,int,long,*(*(char)),*(long))->(int)
(	O
char	O
*	O
name	*(char)
,	O
size_t	long
name_len	int
,	O
char	O
*	O
desc	int
,	O
size_t	long
desc_len	long
,	O
int	O
calign	int
,	O
int	O
align	int
,	O
size_t	long
width	long
,	O
char	O
*	O
*	O
outstr_out	*(*(char))
,	O
size_t	long
*	O
outstr_len	*(long)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
char	O
c	int
;	O
size_t	long
column	long
=	O
0	int
;	O
static	O
char	O
*	O
line_out	*(char)
=	O
NULL	O
;	O
size_t	long
offset_out	long
=	O
0	int
;	O
static	O
size_t	long
allocated_out	long
=	O
0	int
;	O
char	O
*	O
outstr	*(char)
;	O
if	O
(	O
!	O
desc	int
||	O
!	O
name	*(char)
)	O
return	O
1	int
;	O
outstr	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
width	long
+	O
(	O
desc_len	long
+	O
width	long
)	O
/	O
(	O
width	long
-	O
align	int
)	O
*	O
width	long
*	O
2	int
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
outstr	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
strncat	(*(char),*(char),long)->(*(char))
(	O
outstr	*(char)
,	O
name	*(char)
,	O
name_len	int
)	O
;	O
column	long
=	O
name_len	int
;	O
if	O
(	O
name_len	int
>	O
calign	int
-	O
2	int
)	O
{	O
if	O
(	O
desc_len	long
>	O
1	int
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
outstr	*(char)
,	O
"\n"	*(char)
)	O
;	O
column	long
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
calign	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
column	long
=	O
adjust_column	(long,char)->(long)
(	O
column	long
,	O
' '	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
outstr	*(char)
,	O
" "	*(char)
)	O
;	O
}	O
}	O
}	O
else	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
calign	int
-	O
name_len	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
desc_len	long
<=	O
2	int
)	O
break	O
;	O
column	long
=	O
adjust_column	(long,char)->(long)
(	O
column	long
,	O
' '	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
outstr	*(char)
,	O
" "	*(char)
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
desc_len	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
desc_len	long
<=	O
2	int
)	O
break	O
;	O
c	int
=	O
desc	int
[	O
i	int
]	O
;	O
if	O
(	O
offset_out	long
+	O
1	int
>=	O
allocated_out	long
)	O
{	O
allocated_out	long
=	O
offset_out	long
+	O
1	int
;	O
line_out	*(char)
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
(	O
void	O
*	O
)	O
line_out	*(char)
,	O
allocated_out	long
+	O
1	int
)	O
;	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
line_out	*(char)
[	O
offset_out	long
++	O
]	O
=	O
c	int
;	O
strncat	(*(char),*(char),long)->(*(char))
(	O
outstr	*(char)
,	O
line_out	*(char)
,	O
offset_out	long
)	O
;	O
column	long
=	O
offset_out	long
=	O
0	int
;	O
continue	O
;	O
}	O
rescan	O
:	O
column	long
=	O
adjust_column	(long,char)->(long)
(	O
column	long
,	O
c	int
)	O
;	O
if	O
(	O
column	long
>	O
width	long
)	O
{	O
int	O
found_blank	int
=	O
0	int
;	O
size_t	long
logical_end	long
=	O
offset_out	long
;	O
while	O
(	O
logical_end	long
)	O
{	O
--	O
logical_end	long
;	O
if	O
(	O
line_out	*(char)
[	O
logical_end	long
]	O
==	O
' '	O
||	O
line_out	*(char)
[	O
logical_end	long
]	O
==	O
'\t'	O
)	O
{	O
found_blank	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
found_blank	int
)	O
{	O
size_t	long
i	int
;	O
logical_end	long
++	O
;	O
strncat	(*(char),*(char),long)->(*(char))
(	O
outstr	*(char)
,	O
line_out	*(char)
,	O
logical_end	long
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
outstr	*(char)
,	O
"\n"	*(char)
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
align	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
column	long
=	O
adjust_column	(long,char)->(long)
(	O
column	long
,	O
' '	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
outstr	*(char)
,	O
" "	*(char)
)	O
;	O
}	O
memmove	(*(void),*(void),long)->(*(void))
(	O
line_out	*(char)
,	O
line_out	*(char)
+	O
logical_end	long
,	O
offset_out	long
-	O
logical_end	long
)	O
;	O
offset_out	long
-=	O
logical_end	long
;	O
for	O
(	O
column	long
=	O
i	int
=	O
0	int
;	O
i	int
<	O
offset_out	long
;	O
i	int
++	O
)	O
column	long
=	O
adjust_column	(long,char)->(long)
(	O
column	long
,	O
line_out	*(char)
[	O
i	int
]	O
)	O
;	O
goto	O
rescan	O
;	O
}	O
if	O
(	O
offset_out	long
==	O
0	int
)	O
{	O
line_out	*(char)
[	O
offset_out	long
++	O
]	O
=	O
c	int
;	O
continue	O
;	O
}	O
line_out	*(char)
[	O
offset_out	long
++	O
]	O
=	O
'\n'	O
;	O
strncat	(*(char),*(char),long)->(*(char))
(	O
outstr	*(char)
,	O
line_out	*(char)
,	O
offset_out	long
)	O
;	O
column	long
=	O
offset_out	long
=	O
0	int
;	O
goto	O
rescan	O
;	O
}	O
line_out	*(char)
[	O
offset_out	long
++	O
]	O
=	O
c	int
;	O
}	O
if	O
(	O
desc_len	long
<=	O
2	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
outstr	*(char)
,	O
"\n"	*(char)
)	O
;	O
if	O
(	O
offset_out	long
)	O
strncat	(*(char),*(char),long)->(*(char))
(	O
outstr	*(char)
,	O
line_out	*(char)
,	O
offset_out	long
)	O
;	O
*	O
outstr_out	*(*(char))
=	O
outstr	*(char)
;	O
*	O
outstr_len	*(long)
=	O
strlen	(*(char))->(long)
(	O
outstr	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
split_entry	(*(char),*(*(char)),*(long),*(*(char)),*(long))->(void)
(	O
const	O
char	O
*	O
entry	*(struct)
,	O
char	O
*	O
*	O
name	*(char)
,	O
size_t	long
*	O
name_len	int
,	O
char	O
*	O
*	O
description	*(*(char))
,	O
size_t	long
*	O
description_len	*(long)
)	O
{	O
char	O
*	O
endptr	*(char)
;	O
char	O
*	O
ptr	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
entry	*(struct)
,	O
'.'	O
)	O
;	O
while	O
(	O
ptr	*(char)
&&	O
ptr	*(char)
[	O
1	int
]	O
!=	O
' '	O
&&	O
ptr	*(char)
[	O
1	int
]	O
!=	O
'\t'	O
&&	O
ptr	*(char)
[	O
1	int
]	O
!=	O
'\n'	O
)	O
{	O
ptr	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
ptr	*(char)
+	O
1	int
,	O
'.'	O
)	O
;	O
}	O
if	O
(	O
!	O
ptr	*(char)
)	O
{	O
size_t	long
length	long
=	O
strlen	(*(char))->(long)
(	O
entry	*(struct)
)	O
;	O
if	O
(	O
length	long
==	O
0	int
)	O
return	O
;	O
*	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
entry	*(struct)
)	O
;	O
*	O
name_len	int
=	O
length	long
+	O
1	int
;	O
return	O
;	O
}	O
*	O
name_len	int
=	O
(	O
size_t	long
)	O
(	O
ptr	*(char)
-	O
entry	*(struct)
+	O
1	int
)	O
;	O
*	O
name	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
*	O
name_len	int
+	O
1	int
)	O
;	O
(	O
*	O
name	*(char)
)	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
strncat	(*(char),*(char),long)->(*(char))
(	O
*	O
name	*(char)
,	O
entry	*(struct)
,	O
*	O
name_len	int
)	O
;	O
ptr	*(char)
++	O
;	O
*	O
description	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
entry	*(struct)
)	O
)	O
;	O
(	O
*	O
description	*(*(char))
)	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
ptr	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
while	O
(	O
isspace	(int)->(int)
(	O
ptr	*(char)
[	O
0	int
]	O
)	O
)	O
ptr	*(char)
++	O
;	O
if	O
(	O
ptr	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
continue	O
;	O
endptr	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
ptr	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
endptr	*(char)
)	O
{	O
size_t	long
length	long
=	O
(	O
size_t	long
)	O
(	O
endptr	*(char)
-	O
ptr	*(char)
)	O
/	O
sizeof	O
(	O
char	O
)	O
;	O
strncat	(*(char),*(char),long)->(*(char))
(	O
*	O
description	*(*(char))
,	O
ptr	*(char)
,	O
length	long
)	O
;	O
ptr	*(char)
=	O
endptr	*(char)
;	O
ptr	*(char)
++	O
;	O
if	O
(	O
length	long
>	O
1	int
&&	O
strlen	(*(char))->(long)
(	O
ptr	*(char)
)	O
>	O
0	int
)	O
{	O
endptr	*(char)
--	O
;	O
if	O
(	O
*	O
endptr	*(char)
==	O
'.'	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
description	*(*(char))
,	O
"  "	*(char)
)	O
;	O
else	O
if	O
(	O
!	O
isspace	(int)->(int)
(	O
*	O
endptr	*(char)
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
description	*(*(char))
,	O
" "	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
size_t	long
length	long
=	O
strlen	(*(char))->(long)
(	O
ptr	*(char)
)	O
;	O
strncat	(*(char),*(char),long)->(*(char))
(	O
*	O
description	*(*(char))
,	O
ptr	*(char)
,	O
length	long
)	O
;	O
ptr	*(char)
+=	O
length	long
;	O
}	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
description	*(*(char))
,	O
"\n"	*(char)
)	O
;	O
*	O
description_len	*(long)
=	O
strlen	(*(char))->(long)
(	O
*	O
description	*(*(char))
)	O
;	O
}	O
static	O
void	O
reformat_new_entries	(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)),int,int,int)->(void)
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
,	O
int	O
calign_cli	int
,	O
int	O
align_cli	int
,	O
int	O
maxwidth_cli	int
)	O
{	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entry	*(struct)
;	O
for	O
(	O
entry	*(struct)
=	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
;	O
entry	*(struct)
;	O
entry	*(struct)
=	O
entry	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
int	O
calign	int
=	O
-	O
1	int
,	O
align	int
=	O
-	O
1	int
,	O
maxwidth	int
=	O
-	O
1	int
;	O
char	O
*	O
name	*(char)
=	O
NULL	O
,	O
*	O
desc	int
=	O
NULL	O
;	O
size_t	long
name_len	int
=	O
0	int
,	O
desc_len	long
=	O
0	int
;	O
split_entry	(*(char),*(*(char)),*(long),*(*(char)),*(long))->(void)
(	O
entry	*(struct)
->	O
text	*(char)
,	O
&	O
name	*(char)
,	O
&	O
name_len	int
,	O
&	O
desc	int
,	O
&	O
desc_len	long
)	O
;	O
free	(*(void))->(void)
(	O
entry	*(struct)
->	O
text	*(char)
)	O
;	O
if	O
(	O
calign_cli	int
==	O
-	O
1	int
||	O
align_cli	int
==	O
-	O
1	int
)	O
{	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
calign	int
=	O
calign_cli	int
;	O
align	int
=	O
align_cli	int
;	O
for	O
(	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
entry	*(struct)
->	O
entry_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
&&	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
!=	O
entry	*(struct)
->	O
entry_sections_tail	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
,	O
"Individual utilities"	*(char)
)	O
)	O
{	O
if	O
(	O
calign	int
==	O
-	O
1	int
)	O
calign	int
=	O
48	int
+	O
1	int
;	O
if	O
(	O
align	int
==	O
-	O
1	int
)	O
align	int
=	O
50	int
+	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
calign	int
==	O
-	O
1	int
)	O
calign	int
=	O
32	int
+	O
1	int
;	O
if	O
(	O
align	int
==	O
-	O
1	int
)	O
align	int
=	O
34	int
+	O
1	int
;	O
}	O
else	O
{	O
calign	int
=	O
calign_cli	int
;	O
align	int
=	O
align_cli	int
;	O
}	O
maxwidth	int
=	O
maxwidth_cli	int
==	O
-	O
1	int
?	O
79	int
:	O
maxwidth_cli	int
;	O
format_entry	(*(char),long,*(char),long,int,int,long,*(*(char)),*(long))->(int)
(	O
name	*(char)
,	O
name_len	int
,	O
desc	int
,	O
desc_len	long
,	O
calign	int
,	O
align	int
,	O
maxwidth	int
,	O
&	O
entry	*(struct)
->	O
text	*(char)
,	O
&	O
entry	*(struct)
->	O
text_len	long
)	O
;	O
}	O
}	O
void	O
add_missing_basenames	(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)),*(char))->(void)
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
,	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entry	*(struct)
;	O
for	O
(	O
entry	*(struct)
=	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
;	O
entry	*(struct)
;	O
entry	*(struct)
=	O
entry	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
if	O
(	O
entry	*(struct)
->	O
missing_basename	int
)	O
{	O
char	O
*	O
info	*(char)
,	O
*	O
rest	*(char)
,	O
*	O
text	*(char)
;	O
size_t	long
name_len	int
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
char	O
*	O
ptr	*(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
entry	*(struct)
->	O
text	*(char)
,	O
": (). "	*(char)
)	O
;	O
if	O
(	O
!	O
ptr	*(char)
)	O
return	O
;	O
ptr	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
rest	*(char)
=	O
ptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
": (). "	*(char)
)	O
;	O
info	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
name_len	int
+	O
7	int
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
info	*(char)
,	O
name_len	int
+	O
7	int
,	O
": (%s). "	*(char)
,	O
name	*(char)
)	O
;	O
text	*(char)
=	O
concat	(*(char),*(char),*(char))->(*(char))
(	O
entry	*(struct)
->	O
text	*(char)
,	O
info	*(char)
,	O
rest	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
info	*(char)
)	O
;	O
if	O
(	O
entry	*(struct)
->	O
text	*(char)
)	O
free	(*(void))->(void)
(	O
entry	*(struct)
->	O
text	*(char)
)	O
;	O
entry	*(struct)
->	O
text	*(char)
=	O
text	*(char)
;	O
entry	*(struct)
->	O
text_len	long
=	O
strlen	(*(char))->(long)
(	O
entry	*(struct)
->	O
text	*(char)
)	O
;	O
entry	*(struct)
->	O
missing_name	int
=	O
0	int
;	O
entry	*(struct)
->	O
missing_basename	int
=	O
0	int
;	O
}	O
}	O
}	O
void	O
add_missing_names	(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)),*(char))->(void)
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
,	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entry	*(struct)
;	O
for	O
(	O
entry	*(struct)
=	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
;	O
entry	*(struct)
;	O
entry	*(struct)
=	O
entry	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
if	O
(	O
entry	*(struct)
->	O
missing_name	int
)	O
{	O
char	O
*	O
text	*(char)
;	O
int	O
add_nl	int
=	O
1	int
;	O
if	O
(	O
entry	*(struct)
->	O
text	*(char)
)	O
if	O
(	O
entry	*(struct)
->	O
text	*(char)
[	O
entry	*(struct)
->	O
text_len	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
add_nl	int
=	O
0	int
;	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
==	O
'*'	O
)	O
text	*(char)
=	O
concat	(*(char),*(char),*(char))->(*(char))
(	O
name	*(char)
,	O
entry	*(struct)
->	O
text	*(char)
==	O
NULL	O
?	O
""	*(char)
:	O
entry	*(struct)
->	O
text	*(char)
,	O
add_nl	int
?	O
"\n"	*(char)
:	O
""	*(char)
)	O
;	O
else	O
{	O
size_t	long
full_name_len	long
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
*	O
2	int
+	O
9	int
;	O
char	O
*	O
full_name	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
full_name_len	long
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
full_name	*(char)
,	O
full_name_len	long
,	O
"* %s: (%s)."	*(char)
,	O
name	*(char)
,	O
name	*(char)
)	O
;	O
text	*(char)
=	O
concat	(*(char),*(char),*(char))->(*(char))
(	O
full_name	*(char)
,	O
entry	*(struct)
->	O
text	*(char)
==	O
NULL	O
?	O
""	*(char)
:	O
entry	*(struct)
->	O
text	*(char)
,	O
add_nl	int
?	O
"\n"	*(char)
:	O
""	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
full_name	*(char)
)	O
;	O
}	O
if	O
(	O
entry	*(struct)
->	O
text	*(char)
)	O
free	(*(void))->(void)
(	O
entry	*(struct)
->	O
text	*(char)
)	O
;	O
entry	*(struct)
->	O
text	*(char)
=	O
text	*(char)
;	O
entry	*(struct)
->	O
text_len	long
=	O
strlen	(*(char))->(long)
(	O
entry	*(struct)
->	O
text	*(char)
)	O
;	O
entry	*(struct)
->	O
missing_name	int
=	O
0	int
;	O
entry	*(struct)
->	O
missing_basename	int
=	O
0	int
;	O
}	O
}	O
}	O
void	O
add_missing_descriptions	(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)),*(char))->(void)
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
,	O
char	O
*	O
desc	int
)	O
{	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entry	*(struct)
;	O
for	O
(	O
entry	*(struct)
=	O
entries	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
;	O
entry	*(struct)
;	O
entry	*(struct)
=	O
entry	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
if	O
(	O
entry	*(struct)
->	O
missing_description	int
)	O
{	O
char	O
*	O
text	*(char)
;	O
int	O
add_nl	int
=	O
1	int
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
desc	int
)	O
>	O
1	int
)	O
if	O
(	O
desc	int
[	O
strlen	(*(char))->(long)
(	O
desc	int
)	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
add_nl	int
=	O
0	int
;	O
text	*(char)
=	O
concat	(*(char),*(char),*(char))->(*(char))
(	O
entry	*(struct)
->	O
text	*(char)
==	O
NULL	O
?	O
""	*(char)
:	O
entry	*(struct)
->	O
text	*(char)
,	O
desc	int
,	O
add_nl	int
?	O
"\n"	*(char)
:	O
""	*(char)
)	O
;	O
if	O
(	O
entry	*(struct)
->	O
text	*(char)
)	O
free	(*(void))->(void)
(	O
entry	*(struct)
->	O
text	*(char)
)	O
;	O
entry	*(struct)
->	O
text	*(char)
=	O
text	*(char)
;	O
entry	*(struct)
->	O
text_len	long
=	O
strlen	(*(char))->(long)
(	O
entry	*(struct)
->	O
text	*(char)
)	O
;	O
}	O
}	O
}	O
static	O
int	O
munge_old_style_debian_options	(int,*(*(char)),*(int),*(*(*(char))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
*	O
new_argc	*(int)
,	O
char	O
*	O
*	O
*	O
new_argv	*(*(*(char)))
)	O
{	O
char	O
*	O
opt	*(char)
=	O
NULL	O
;	O
int	O
i	int
,	O
err	int
;	O
char	O
*	O
argz	*(char)
=	O
NULL	O
;	O
size_t	long
argz_len	long
=	O
0	int
;	O
const	O
char	O
*	O
regex	*(char)
,	O
*	O
title	*(char)
;	O
int	O
munge	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--section"	*(char)
)	O
==	O
0	int
)	O
{	O
FILE	struct
*	O
fileptr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
if	O
(	O
i	int
+	O
1	int
<	O
argc	int
)	O
i	int
++	O
;	O
else	O
return	O
-	O
1	int
;	O
regex	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
if	O
(	O
i	int
+	O
1	int
<	O
argc	int
)	O
i	int
++	O
;	O
else	O
return	O
-	O
1	int
;	O
title	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
if	O
(	O
title	*(char)
[	O
0	int
]	O
==	O
'-'	O
)	O
break	O
;	O
fileptr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
title	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
fileptr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fileptr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
}	O
munge	int
=	O
1	int
;	O
opt	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
regex	*(char)
)	O
+	O
sizeof	O
(	O
"--regex="	*(char)
)	O
)	O
;	O
if	O
(	O
sprintf	(*(char),*(char))->(int)
(	O
opt	*(char)
,	O
"--regex=%s"	*(char)
,	O
regex	*(char)
)	O
==	O
-	O
1	int
)	O
err	int
=	O
1	int
;	O
if	O
(	O
!	O
err	int
)	O
err	int
=	O
argz_add	(*(*(char)),*(long),*(char))->(int)
(	O
&	O
argz	*(char)
,	O
&	O
argz_len	long
,	O
opt	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
opt	*(char)
)	O
;	O
opt	*(char)
=	O
NULL	O
;	O
opt	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
title	*(char)
)	O
+	O
sizeof	O
(	O
"--section="	*(char)
)	O
)	O
;	O
if	O
(	O
sprintf	(*(char),*(char))->(int)
(	O
opt	*(char)
,	O
"--section=%s"	*(char)
,	O
title	*(char)
)	O
==	O
-	O
1	int
)	O
err	int
=	O
1	int
;	O
if	O
(	O
!	O
err	int
)	O
err	int
=	O
argz_add	(*(*(char)),*(long),*(char))->(int)
(	O
&	O
argz	*(char)
,	O
&	O
argz_len	long
,	O
opt	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
opt	*(char)
)	O
;	O
opt	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
err	int
)	O
err	int
=	O
argz_add	(*(*(char)),*(long),*(char))->(int)
(	O
&	O
argz	*(char)
,	O
&	O
argz_len	long
,	O
"--add-once"	*(char)
)	O
;	O
}	O
else	O
err	int
=	O
argz_add	(*(*(char)),*(long),*(char))->(int)
(	O
&	O
argz	*(char)
,	O
&	O
argz_len	long
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
err	int
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
munge	int
)	O
{	O
*	O
new_argc	*(int)
=	O
argz_count	(*(char),long)->(long)
(	O
argz	*(char)
,	O
argz_len	long
)	O
;	O
*	O
new_argv	*(*(*(char)))
=	O
xmalloc	(long)->(*(void))
(	O
(	O
*	O
new_argc	*(int)
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
opt	*(char)
=	O
NULL	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
(	O
opt	*(char)
=	O
argz_next	(*(char),long,*(char))->(*(char))
(	O
argz	*(char)
,	O
argz_len	long
,	O
opt	*(char)
)	O
)	O
)	O
{	O
(	O
*	O
new_argv	*(*(*(char)))
)	O
[	O
i	int
]	O
=	O
xstrdup	(*(char))->(*(char))
(	O
opt	*(char)
)	O
;	O
i	int
++	O
;	O
}	O
(	O
*	O
new_argv	*(*(*(char)))
)	O
[	O
*	O
new_argc	*(int)
]	O
=	O
NULL	O
;	O
}	O
free	(*(void))->(void)
(	O
argz	*(char)
)	O
;	O
return	O
munge	int
;	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
char	O
*	O
opened_dirfilename	*(char)
;	O
char	O
*	O
compression_program	*(*(char))
;	O
char	O
*	O
infile_sans_info	*(char)
;	O
char	O
*	O
infile	*(char)
=	O
0	int
,	O
*	O
dirfile	*(char)
=	O
0	int
;	O
int	O
calign	int
=	O
-	O
1	int
;	O
int	O
align	int
=	O
-	O
1	int
;	O
int	O
maxwidth	int
=	O
-	O
1	int
;	O
char	O
*	O
input_data	*(char)
=	O
NULL	O
;	O
int	O
input_size	int
=	O
0	int
;	O
struct	O
line_data	struct(*(char),int,*(*(struct)),*(*(struct)),int,int)
*	O
input_lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
=	O
NULL	O
;	O
int	O
input_nlines	int
=	O
0	int
;	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
NULL	O
;	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
=	O
NULL	O
;	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entries_to_add_from_file	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
=	O
NULL	O
;	O
int	O
n_entries_to_add	int
=	O
0	int
;	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
default_entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
=	O
NULL	O
;	O
int	O
n_default_entries_to_add	int
=	O
0	int
;	O
char	O
*	O
dir_data	*(char)
;	O
int	O
dir_size	int
;	O
int	O
dir_nlines	int
;	O
struct	O
line_data	struct(*(char),int,*(*(struct)),*(*(struct)),int,int)
*	O
dir_lines	*(struct)
;	O
struct	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
*	O
dir_nodes	*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct(*(struct`),*(char),int,int)),*(struct(*(struct`),*(char),int,int))))
;	O
int	O
delete_flag	int
=	O
0	int
;	O
int	O
something_deleted	int
=	O
0	int
;	O
int	O
quiet_flag	int
=	O
0	int
;	O
int	O
debug_flag	int
=	O
0	int
;	O
int	O
i	int
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
if	O
(	O
!	O
freopen	(*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
NULL_DEVICE	*(char)
,	O
"r"	*(char)
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
pfatal_with_name	(*(char))->(void)
(	O
NULL_DEVICE	*(char)
)	O
;	O
munge_old_style_debian_options	(int,*(*(char)),*(int),*(*(*(char))))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
opt	*(char)
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"i:d:e:s:t:E:c:C:W:A:hHrk1Ia"	*(char)
,	O
longopts	array(struct(*(char),int,*(int),int))
,	O
0	int
)	O
;	O
if	O
(	O
opt	*(char)
==	O
EOF	O
)	O
break	O
;	O
switch	O
(	O
opt	*(char)
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
1	int
:	O
abort	()->(void)
(	O
)	O
;	O
case	O
'1'	O
:	O
add_entries_into_all_matching_sections	int
=	O
0	int
;	O
break	O
;	O
case	O
'a'	O
:	O
order_new_sections_alphabetically_flag	int
=	O
0	int
;	O
break	O
;	O
case	O
'A'	O
:	O
{	O
char	O
*	O
end	*(long)
=	O
NULL	O
;	O
unsigned	O
long	O
int	O
val	int
;	O
val	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
&	O
end	*(long)
,	O
0	int
)	O
;	O
if	O
(	O
end	*(long)
==	O
NULL	O
||	O
end	*(long)
==	O
optarg	*(char)
||	O
*	O
end	*(long)
!=	O
'\0'	O
)	O
suggest_asking_for_help	()->(void)
(	O
)	O
;	O
align	int
=	O
val	int
;	O
if	O
(	O
align	int
<=	O
0	int
)	O
suggest_asking_for_help	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
'c'	O
:	O
{	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
size_t	long
length	long
=	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
!	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
)	O
{	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
)	O
)	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text	*(char)
=	O
NULL	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text_len	long
=	O
0	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
entry_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
NULL	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
entry_sections_tail	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
NULL	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing_name	int
=	O
1	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing_basename	int
=	O
1	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
;	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
=	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
n_entries_to_add	int
++	O
;	O
}	O
else	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing_description	int
=	O
0	int
;	O
if	O
(	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text	*(char)
)	O
{	O
char	O
*	O
nl	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
nl	*(char)
)	O
nl	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text	*(char)
=	O
concat	(*(char),*(char),*(char))->(*(char))
(	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text	*(char)
?	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text	*(char)
:	O
" "	*(char)
,	O
optarg	*(char)
,	O
optarg	*(char)
[	O
length	long
-	O
1	int
]	O
==	O
'\n'	O
?	O
""	*(char)
:	O
"\n"	*(char)
)	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text_len	long
=	O
strlen	(*(char))->(long)
(	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
'C'	O
:	O
{	O
char	O
*	O
end	*(long)
=	O
NULL	O
;	O
unsigned	O
long	O
int	O
val	int
;	O
val	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
&	O
end	*(long)
,	O
0	int
)	O
;	O
if	O
(	O
end	*(long)
==	O
NULL	O
||	O
end	*(long)
==	O
optarg	*(char)
||	O
*	O
end	*(long)
!=	O
'\0'	O
)	O
suggest_asking_for_help	()->(void)
(	O
)	O
;	O
calign	int
=	O
val	int
;	O
if	O
(	O
calign	int
<=	O
0	int
)	O
suggest_asking_for_help	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
dirfile	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: already have dir file: %s\n"	*(char)
)	O
,	O
progname	*(char)
,	O
dirfile	*(char)
)	O
;	O
suggest_asking_for_help	()->(void)
(	O
)	O
;	O
}	O
dirfile	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
dirfile	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: already have dir file: %s\n"	*(char)
)	O
,	O
progname	*(char)
,	O
dirfile	*(char)
)	O
;	O
suggest_asking_for_help	()->(void)
(	O
)	O
;	O
}	O
dirfile	*(char)
=	O
concat	(*(char),*(char),*(char))->(*(char))
(	O
optarg	*(char)
,	O
""	*(char)
,	O
"/dir"	*(char)
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
{	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
)	O
)	O
;	O
size_t	long
length	long
;	O
if	O
(	O
optarg	*(char)
[	O
0	int
]	O
!=	O
'*'	O
)	O
{	O
length	long
=	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
+	O
9	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
length	long
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text	*(char)
,	O
length	long
,	O
"* %s: (). "	*(char)
,	O
optarg	*(char)
)	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing_basename	int
=	O
1	int
;	O
}	O
else	O
{	O
length	long
=	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
+	O
2	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
length	long
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text	*(char)
,	O
length	long
,	O
"%s "	*(char)
,	O
optarg	*(char)
)	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing_basename	int
=	O
0	int
;	O
}	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text_len	long
=	O
length	long
-	O
1	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
entry_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
NULL	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
entry_sections_tail	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
NULL	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing_name	int
=	O
0	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing_description	int
=	O
1	int
;	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
=	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
n_entries_to_add	int
++	O
;	O
}	O
break	O
;	O
case	O
'E'	O
:	O
case	O
'e'	O
:	O
{	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
)	O
)	O
;	O
int	O
olen	int
=	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
*	O
optarg	*(char)
!=	O
0	int
&&	O
optarg	*(char)
[	O
olen	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
)	O
{	O
optarg	*(char)
=	O
concat	(*(char),*(char),*(char))->(*(char))
(	O
optarg	*(char)
,	O
"\n"	*(char)
,	O
""	*(char)
)	O
;	O
olen	int
++	O
;	O
}	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text	*(char)
=	O
optarg	*(char)
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
text_len	long
=	O
olen	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
entry_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
NULL	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
entry_sections_tail	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
NULL	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing_name	int
=	O
0	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing_basename	int
=	O
0	int
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing_description	int
=	O
0	int
;	O
if	O
(	O
opt	*(char)
==	O
'e'	O
)	O
{	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
;	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
=	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
n_entries_to_add	int
++	O
;	O
}	O
else	O
{	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
default_entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
;	O
default_entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
=	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
n_default_entries_to_add	int
++	O
;	O
}	O
}	O
break	O
;	O
case	O
'g'	O
:	O
debug_flag	int
=	O
1	int
;	O
break	O
;	O
case	O
'h'	O
:	O
case	O
'H'	O
:	O
print_help	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
'i'	O
:	O
if	O
(	O
infile	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: Specify the Info file only once.\n"	*(char)
)	O
,	O
progname	*(char)
)	O
;	O
suggest_asking_for_help	()->(void)
(	O
)	O
;	O
}	O
infile	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'I'	O
:	O
indent_flag	int
=	O
0	int
;	O
break	O
;	O
case	O
'k'	O
:	O
keep_old_flag	int
=	O
1	int
;	O
break	O
;	O
case	O
'n'	O
:	O
chicken_flag	int
=	O
1	int
;	O
break	O
;	O
case	O
'q'	O
:	O
quiet_flag	int
=	O
1	int
;	O
break	O
;	O
case	O
'r'	O
:	O
delete_flag	int
=	O
1	int
;	O
break	O
;	O
case	O
'R'	O
:	O
{	O
int	O
error	(*(char))->(void)
;	O
if	O
(	O
psecreg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
)	O
{	O
warning	(*(char))->(void)
(	O
_	O
(	O
"Extra regular expression specified, ignoring `%s'"	*(char)
)	O
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
}	O
psecreg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
=	O
(	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
)	O
)	O
;	O
error	(*(char))->(void)
=	O
regcomp	O
(	O
psecreg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
optarg	*(char)
,	O
REG_ICASE	O
|	O
REG_NOSUB	O
)	O
;	O
if	O
(	O
error	(*(char))->(void)
!=	O
0	int
)	O
{	O
int	O
errbuf_size	int
=	O
regerror	O
(	O
error	(*(char))->(void)
,	O
psecreg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
NULL	O
,	O
0	int
)	O
;	O
char	O
*	O
errbuf	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
errbuf_size	int
)	O
;	O
regerror	O
(	O
error	(*(char))->(void)
,	O
psecreg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
errbuf	*(char)
,	O
errbuf_size	int
)	O
;	O
fatal	(*(char))->(void)
(	O
_	O
(	O
"Error in regular expression `%s': %s"	*(char)
)	O
,	O
optarg	*(char)
,	O
errbuf	*(char)
)	O
;	O
}	O
;	O
}	O
break	O
;	O
case	O
'S'	O
:	O
default_section	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
's'	O
:	O
{	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
(	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
)	O
)	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
=	O
optarg	*(char)
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing	int
=	O
1	int
;	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
}	O
break	O
;	O
case	O
'V'	O
:	O
printf	(*(char))->(int)
(	O
"install-info (GNU %s) %s\n"	*(char)
,	O
PACKAGE	*(char)
,	O
VERSION	*(char)
)	O
;	O
puts	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	*(char)
)	O
,	O
"2019"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
'W'	O
:	O
{	O
char	O
*	O
end	*(long)
=	O
NULL	O
;	O
unsigned	O
long	O
int	O
val	int
;	O
val	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
&	O
end	*(long)
,	O
0	int
)	O
;	O
if	O
(	O
end	*(long)
==	O
NULL	O
||	O
end	*(long)
==	O
optarg	*(char)
||	O
*	O
end	*(long)
!=	O
'\0'	O
)	O
suggest_asking_for_help	()->(void)
(	O
)	O
;	O
maxwidth	int
=	O
val	int
;	O
if	O
(	O
maxwidth	int
<=	O
0	int
)	O
suggest_asking_for_help	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
'x'	O
:	O
delete_flag	int
=	O
1	int
;	O
remove_exactly	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
suggest_asking_for_help	()->(void)
(	O
)	O
;	O
}	O
}	O
for	O
(	O
;	O
optind	int
<	O
argc	int
;	O
++	O
optind	int
)	O
{	O
if	O
(	O
infile	*(char)
==	O
0	int
)	O
infile	*(char)
=	O
argv	*(*(char))
[	O
optind	int
]	O
;	O
else	O
if	O
(	O
dirfile	*(char)
==	O
0	int
)	O
dirfile	*(char)
=	O
argv	*(*(char))
[	O
optind	int
]	O
;	O
else	O
error	(*(char))->(void)
(	O
_	O
(	O
"excess command line argument `%s'"	*(char)
)	O
,	O
argv	*(*(char))
[	O
optind	int
]	O
)	O
;	O
}	O
if	O
(	O
!	O
infile	*(char)
)	O
fatal	(*(char))->(void)
(	O
_	O
(	O
"No input file specified; try --help for more information."	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
dirfile	*(char)
)	O
fatal	(*(char))->(void)
(	O
_	O
(	O
"No dir file specified; try --help for more information."	*(char)
)	O
)	O
;	O
if	O
(	O
debug_flag	int
)	O
printf	(*(char))->(int)
(	O
"debug: reading dir file %s\n"	*(char)
,	O
dirfile	*(char)
)	O
;	O
if	O
(	O
!	O
delete_flag	int
)	O
{	O
dir_data	*(char)
=	O
readfile	(*(char),*(int),*((*(char))->(void)),*(*(char)),*(*(char)))->(*(char))
(	O
dirfile	*(char)
,	O
&	O
dir_size	int
,	O
ensure_dirfile_exists	(*(char))->(void)
,	O
&	O
opened_dirfilename	*(char)
,	O
&	O
compression_program	*(*(char))
)	O
;	O
if	O
(	O
!	O
dir_data	*(char)
)	O
pfatal_with_name	(*(char))->(void)
(	O
opened_dirfilename	*(char)
)	O
;	O
}	O
else	O
{	O
dir_data	*(char)
=	O
readfile	(*(char),*(int),*((*(char))->(void)),*(*(char)),*(*(char)))->(*(char))
(	O
dirfile	*(char)
,	O
&	O
dir_size	int
,	O
NULL	O
,	O
&	O
opened_dirfilename	*(char)
,	O
&	O
compression_program	*(*(char))
)	O
;	O
if	O
(	O
!	O
dir_data	*(char)
)	O
{	O
warning	(*(char))->(void)
(	O
_	O
(	O
"Could not read %s."	*(char)
)	O
,	O
opened_dirfilename	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
}	O
dir_lines	*(struct)
=	O
findlines	(*(char),int,*(int))->(*(struct))
(	O
dir_data	*(char)
,	O
dir_size	int
,	O
&	O
dir_nlines	int
)	O
;	O
parse_dir_file	(*(struct(*(char),int,*(*(struct`)),*(*(struct`)),int,int)),int,*(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`)))))->(void)
(	O
dir_lines	*(struct)
,	O
dir_nlines	int
,	O
&	O
dir_nodes	*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct(*(struct`),*(char),int,int)),*(struct(*(struct`),*(char),int,int))))
)	O
;	O
if	O
(	O
!	O
delete_flag	int
)	O
{	O
if	O
(	O
psecreg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
)	O
{	O
struct	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
*	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
;	O
struct	O
menu_section	struct(*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int)),*(char),int,int)
*	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
for	O
(	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
=	O
dir_nodes	*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct(*(struct`),*(char),int,int)),*(struct(*(struct`),*(char),int,int))))
;	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
;	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
=	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
for	O
(	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
->	O
sections	*(struct)
;	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
if	O
(	O
regexec	O
(	O
psecreg	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
==	O
0	int
)	O
{	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
(	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
)	O
)	O
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
=	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing	int
=	O
0	int
;	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
}	O
}	O
}	O
if	O
(	O
!	O
remove_exactly	int
)	O
{	O
char	O
*	O
infile_basename	*(char)
=	O
infile	*(char)
+	O
strlen	(*(char))->(long)
(	O
infile	*(char)
)	O
;	O
if	O
(	O
HAVE_DRIVE	O
(	O
infile	*(char)
)	O
)	O
infile	*(char)
+=	O
2	int
;	O
while	O
(	O
infile_basename	*(char)
>	O
infile	*(char)
&&	O
!	O
IS_SLASH	O
(	O
infile_basename	*(char)
[	O
-	O
1	int
]	O
)	O
)	O
infile_basename	*(char)
--	O
;	O
infile_sans_info	*(char)
=	O
strip_info_suffix	(*(char))->(*(char))
(	O
infile_basename	*(char)
)	O
;	O
}	O
else	O
infile_sans_info	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
infile	*(char)
)	O
;	O
if	O
(	O
!	O
remove_exactly	int
)	O
{	O
char	O
*	O
opened_infilename	*(char)
;	O
if	O
(	O
debug_flag	int
)	O
printf	(*(char))->(int)
(	O
"debug: reading input file %s\n"	*(char)
,	O
infile	*(char)
)	O
;	O
input_data	*(char)
=	O
readfile	(*(char),*(int),*((*(char))->(void)),*(*(char)),*(*(char)))->(*(char))
(	O
infile	*(char)
,	O
&	O
input_size	int
,	O
NULL	O
,	O
&	O
opened_infilename	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
input_data	*(char)
)	O
pfatal_with_name	(*(char))->(void)
(	O
opened_infilename	*(char)
)	O
;	O
input_lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
=	O
findlines	(*(char),int,*(int))->(*(struct))
(	O
input_data	*(char)
,	O
input_size	int
,	O
&	O
input_nlines	int
)	O
;	O
}	O
i	int
=	O
parse_input	(*(struct(*(char),int,*(*(struct`)),*(*(struct`)),int,int)),int,*(*(struct(*(struct`),*(char),int))),*(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int))),int)->(int)
(	O
input_lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
,	O
input_nlines	int
,	O
&	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
,	O
&	O
entries_to_add_from_file	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
,	O
delete_flag	int
)	O
;	O
if	O
(	O
!	O
delete_flag	int
)	O
{	O
if	O
(	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
==	O
NULL	O
)	O
{	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
=	O
entries_to_add_from_file	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
;	O
n_entries_to_add	int
=	O
i	int
;	O
}	O
else	O
if	O
(	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
)	O
{	O
if	O
(	O
entries_to_add_from_file	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
==	O
NULL	O
)	O
{	O
add_missing_names	(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)),*(char))->(void)
(	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
,	O
infile_sans_info	*(char)
)	O
;	O
}	O
else	O
{	O
char	O
*	O
desc	int
=	O
NULL	O
;	O
size_t	long
desc_len	long
=	O
0	int
;	O
char	O
*	O
name	*(char)
=	O
NULL	O
;	O
size_t	long
name_len	int
=	O
0	int
;	O
split_entry	(*(char),*(*(char)),*(long),*(*(char)),*(long))->(void)
(	O
entries_to_add_from_file	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
->	O
text	*(char)
,	O
&	O
name	*(char)
,	O
&	O
name_len	int
,	O
&	O
desc	int
,	O
&	O
desc_len	long
)	O
;	O
if	O
(	O
name	*(char)
)	O
{	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
!=	O
'*'	O
)	O
add_missing_names	(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)),*(char))->(void)
(	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
,	O
infile_sans_info	*(char)
)	O
;	O
else	O
add_missing_names	(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)),*(char))->(void)
(	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
,	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
}	O
if	O
(	O
desc	int
)	O
{	O
add_missing_descriptions	(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)),*(char))->(void)
(	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
,	O
desc	int
)	O
;	O
free	(*(void))->(void)
(	O
desc	int
)	O
;	O
}	O
}	O
}	O
add_missing_basenames	(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)),*(char))->(void)
(	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
,	O
infile_sans_info	*(char)
)	O
;	O
if	O
(	O
indent_flag	int
)	O
{	O
char	O
*	O
no_indent	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"INSTALL_INFO_NO_INDENT"	*(char)
)	O
;	O
if	O
(	O
!	O
no_indent	*(char)
)	O
reformat_new_entries	(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)),int,int,int)->(void)
(	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
,	O
calign	int
,	O
align	int
,	O
maxwidth	int
)	O
;	O
}	O
if	O
(	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
==	O
NULL	O
)	O
{	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
(	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
)	O
)	O
;	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
=	O
default_section	*(char)
?	O
default_section	*(char)
:	O
"Miscellaneous"	*(char)
;	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
NULL	O
;	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing	int
=	O
1	int
;	O
}	O
if	O
(	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
==	O
0	int
)	O
{	O
if	O
(	O
!	O
quiet_flag	int
)	O
warning	(*(char))->(void)
(	O
_	O
(	O
"no info dir entry in `%s'"	*(char)
)	O
,	O
infile	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
n_entries_to_add	int
>	O
0	int
&&	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
->	O
entry_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
==	O
NULL	O
)	O
{	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
ep	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
;	O
for	O
(	O
ep	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
=	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
;	O
ep	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
;	O
ep	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
=	O
ep	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
ep	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
->	O
entry_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
}	O
}	O
if	O
(	O
delete_flag	int
)	O
{	O
something_deleted	int
=	O
mark_entry_for_deletion	(*(struct(*(char),int,*(*(struct`)),*(*(struct`)),int,int)),int,*(char))->(int)
(	O
dir_lines	*(struct)
,	O
dir_nlines	int
,	O
infile_sans_info	*(char)
)	O
;	O
if	O
(	O
!	O
something_deleted	int
&&	O
!	O
remove_exactly	int
)	O
{	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entry	*(struct)
;	O
for	O
(	O
entry	*(struct)
=	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
;	O
entry	*(struct)
;	O
entry	*(struct)
=	O
entry	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
if	O
(	O
entry	*(struct)
->	O
entry_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
!=	O
NULL	O
)	O
{	O
char	O
*	O
name	*(char)
=	O
extract_menu_item_name	(*(char))->(*(char))
(	O
entry	*(struct)
->	O
text	*(char)
)	O
;	O
something_deleted	int
=	O
mark_entry_for_deletion	(*(struct(*(char),int,*(*(struct`)),*(*(struct`)),int,int)),int,*(char))->(int)
(	O
dir_lines	*(struct)
,	O
dir_nlines	int
,	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
!	O
something_deleted	int
)	O
{	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entry	*(struct)
;	O
for	O
(	O
entry	*(struct)
=	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
;	O
entry	*(struct)
;	O
entry	*(struct)
=	O
entry	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
if	O
(	O
entry	*(struct)
->	O
entry_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
==	O
NULL	O
)	O
something_deleted	int
=	O
mark_entry_for_deletion	(*(struct(*(char),int,*(*(struct`)),*(*(struct`)),int,int)),int,*(char))->(int)
(	O
dir_lines	*(struct)
,	O
dir_nlines	int
,	O
entry	*(struct)
->	O
text	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
delete_flag	int
&&	O
something_deleted	int
&&	O
!	O
keep_old_flag	int
)	O
{	O
struct	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
*	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
;	O
struct	O
menu_section	struct(*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int)),*(char),int,int)
*	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
int	O
section_empty	int
;	O
for	O
(	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
=	O
dir_nodes	*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct(*(struct`),*(char),int,int)),*(struct(*(struct`),*(char),int,int))))
;	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
;	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
=	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
for	O
(	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
->	O
sections	*(struct)
;	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
section_empty	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
end_line	int
;	O
i	int
>	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
start_line	int
;	O
i	int
--	O
)	O
{	O
if	O
(	O
dir_lines	*(struct)
[	O
i	int
-	O
1	int
]	O
.	O
delete	int
==	O
0	int
&&	O
dir_lines	*(struct)
[	O
i	int
-	O
1	int
]	O
.	O
size	int
!=	O
0	int
)	O
{	O
section_empty	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
section_empty	int
)	O
{	O
for	O
(	O
i	int
=	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
end_line	int
;	O
i	int
>=	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
start_line	int
;	O
i	int
--	O
)	O
dir_lines	*(struct)
[	O
i	int
-	O
1	int
]	O
.	O
delete	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
delete_flag	int
)	O
{	O
struct	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
*	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
;	O
struct	O
menu_section	struct(*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int)),*(char),int,int)
*	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
for	O
(	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
=	O
dir_nodes	*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct(*(struct`),*(char),int,int)),*(struct(*(struct`),*(char),int,int))))
;	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
;	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
=	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
for	O
(	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
->	O
sections	*(struct)
;	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
for	O
(	O
i	int
=	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
end_line	int
;	O
i	int
>	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
start_line	int
;	O
i	int
--	O
)	O
if	O
(	O
dir_lines	*(struct)
[	O
i	int
-	O
1	int
]	O
.	O
size	int
!=	O
0	int
)	O
break	O
;	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
end_line	int
=	O
i	int
;	O
for	O
(	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
,	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
)	O
)	O
break	O
;	O
if	O
(	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
int	O
add_at_line	int
=	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
end_line	int
;	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entry	*(struct)
;	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing	int
=	O
0	int
;	O
for	O
(	O
entry	*(struct)
=	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
;	O
entry	*(struct)
;	O
entry	*(struct)
=	O
entry	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
for	O
(	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
entry	*(struct)
->	O
entry_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
&&	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
!=	O
entry	*(struct)
->	O
entry_sections_tail	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
,	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
)	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
||	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
==	O
entry	*(struct)
->	O
entry_sections_tail	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
continue	O
;	O
for	O
(	O
i	int
=	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
end_line	int
-	O
1	int
;	O
i	int
>=	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
start_line	int
-	O
1	int
;	O
i	int
--	O
)	O
{	O
if	O
(	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
start	*(long)
[	O
0	int
]	O
==	O
'*'	O
&&	O
menu_line_equal	(*(char),int,*(char),int)->(int)
(	O
entry	*(struct)
->	O
text	*(char)
,	O
entry	*(struct)
->	O
text_len	long
,	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
start	*(long)
,	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
size	int
)	O
&&	O
!	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
delete	int
)	O
{	O
if	O
(	O
keep_old_flag	int
)	O
{	O
add_at_line	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
else	O
{	O
int	O
j	int
;	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
delete	int
=	O
1	int
;	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
end_line	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
dir_lines	*(struct)
[	O
j	int
]	O
.	O
start	*(long)
[	O
0	int
]	O
==	O
'*'	O
)	O
break	O
;	O
dir_lines	*(struct)
[	O
j	int
]	O
.	O
delete	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
start	*(long)
[	O
0	int
]	O
==	O
'*'	O
&&	O
menu_line_lessp	(*(char),int,*(char),int)->(int)
(	O
entry	*(struct)
->	O
text	*(char)
,	O
entry	*(struct)
->	O
text_len	long
,	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
start	*(long)
,	O
dir_lines	*(struct)
[	O
i	int
]	O
.	O
size	int
)	O
)	O
add_at_line	int
=	O
i	int
;	O
}	O
if	O
(	O
add_at_line	int
<	O
0	int
)	O
continue	O
;	O
insert_entry_here	(*(struct),int,*(struct),int)->(void)
(	O
entry	*(struct)
,	O
add_at_line	int
,	O
dir_lines	*(struct)
,	O
n_entries_to_add	int
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
delete_flag	int
)	O
{	O
struct	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
*	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
;	O
struct	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
*	O
top	*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct(*(struct`),*(char),int,int)),*(struct(*(struct`),*(char),int,int))))
=	O
NULL	O
;	O
for	O
(	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
=	O
dir_nodes	*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct(*(struct`),*(char),int,int)),*(struct(*(struct`),*(char),int,int))))
;	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
;	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
=	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
if	O
(	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
->	O
name	*(char)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
->	O
name	*(char)
,	O
"Top"	*(char)
)	O
==	O
0	int
)	O
top	*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct(*(struct`),*(char),int,int)),*(struct(*(struct`),*(char),int,int))))
=	O
node	struct(*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct),*(struct))),*(char),int,int,*(char),*(struct),*(struct))
;	O
if	O
(	O
top	*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct(*(struct`),*(char),int,int)),*(struct(*(struct`),*(char),int,int))))
)	O
{	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
int	O
found	int
=	O
0	int
;	O
struct	O
line_data	struct(*(char),int,*(*(struct)),*(*(struct)),int,int)
*	O
target_line	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
=	O
NULL	O
;	O
for	O
(	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
found	int
=	O
0	int
;	O
target_line	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
=	O
NULL	O
;	O
if	O
(	O
!	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
missing	int
)	O
continue	O
;	O
if	O
(	O
order_new_sections_alphabetically_flag	int
)	O
{	O
struct	O
menu_section	struct(*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int)),*(char),int,int)
*	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
struct	O
menu_section	struct(*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int)),*(char),int,int)
*	O
prev_section	*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int))
=	O
NULL	O
;	O
for	O
(	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
top	*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct(*(struct`),*(char),int,int)),*(struct(*(struct`),*(char),int,int))))
->	O
sections	*(struct)
;	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
found	int
=	O
(	O
mbscasecmp	(*(char),*(char))->(int)
(	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
,	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
name	*(char)
)	O
<	O
0	int
)	O
;	O
if	O
(	O
found	int
)	O
{	O
if	O
(	O
prev_section	*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int))
)	O
target_line	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
=	O
&	O
dir_lines	*(struct)
[	O
prev_section	*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int))
->	O
end_line	int
]	O
;	O
else	O
target_line	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
=	O
&	O
dir_lines	*(struct)
[	O
top	*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct(*(struct`),*(char),int,int)),*(struct(*(struct`),*(char),int,int))))
->	O
sections	*(struct)
->	O
start_line	int
-	O
2	int
]	O
;	O
break	O
;	O
}	O
prev_section	*(struct(*(struct(*(struct`),*(char),int,int)),*(char),int,int))
=	O
section	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
}	O
}	O
if	O
(	O
!	O
found	int
)	O
target_line	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
=	O
&	O
dir_lines	*(struct)
[	O
top	*(struct(*(struct(*(struct`),*(char),int,int,*(char),*(struct`),*(struct`))),*(char),int,int,*(char),*(struct(*(struct`),*(char),int,int)),*(struct(*(struct`),*(char),int,int))))
->	O
end_line	int
]	O
;	O
target_line	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
->	O
num_sections_to_add	int
++	O
;	O
target_line	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
->	O
add_sections_before	*(*(struct))
=	O
(	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
target_line	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
->	O
add_sections_before	*(*(struct))
,	O
(	O
target_line	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
->	O
num_sections_to_add	int
*	O
sizeof	O
(	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
)	O
)	O
)	O
;	O
i	int
=	O
target_line	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
->	O
num_sections_to_add	int
-	O
1	int
;	O
target_line	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
->	O
add_sections_before	*(*(struct))
[	O
i	int
]	O
=	O
spec	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
}	O
}	O
}	O
if	O
(	O
delete_flag	int
&&	O
!	O
something_deleted	int
&&	O
!	O
quiet_flag	int
)	O
warning	(*(char))->(void)
(	O
_	O
(	O
"no entries found for `%s'; nothing deleted"	*(char)
)	O
,	O
infile	*(char)
)	O
;	O
if	O
(	O
debug_flag	int
)	O
printf	(*(char))->(int)
(	O
"debug: writing dir file %s\n"	*(char)
,	O
opened_dirfilename	*(char)
)	O
;	O
if	O
(	O
chicken_flag	int
)	O
printf	(*(char))->(int)
(	O
"test mode, not updating dir file %s\n"	*(char)
,	O
opened_dirfilename	*(char)
)	O
;	O
else	O
output_dirfile	(*(char),int,*(struct(*(char),int,*(*(struct`)),*(*(struct`)),int,int)),int,*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)),*(struct(*(struct(*`,*`,int)),*(char),int)),*(char))->(void)
(	O
opened_dirfilename	*(char)
,	O
dir_nlines	int
,	O
dir_lines	*(struct)
,	O
n_entries_to_add	int
,	O
entries_to_add	*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int))
,	O
input_sections	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
,	O
compression_program	*(*(char))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
struct	O
line_data	struct(*(char),int,*(*(struct)),*(*(struct)),int,int)
*	O
findlines	(*(char),int,*(int))->(*(struct))
(	O
char	O
*	O
data	*(char)
,	O
int	O
size	int
,	O
int	O
*	O
nlinesp	*(int)
)	O
{	O
int	O
i	int
;	O
int	O
lineflag	int
=	O
1	int
;	O
int	O
lines_allocated	int
=	O
511	int
;	O
int	O
filled	int
=	O
0	int
;	O
struct	O
line_data	struct(*(char),int,*(*(struct)),*(*(struct)),int,int)
*	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
=	O
xmalloc	(long)->(*(void))
(	O
(	O
lines_allocated	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
struct	O
line_data	struct(*(char),int,*(*(struct)),*(*(struct)),int,int)
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
lineflag	int
)	O
{	O
if	O
(	O
filled	int
==	O
lines_allocated	int
)	O
{	O
lines_allocated	int
=	O
(	O
(	O
lines_allocated	int
+	O
1	int
)	O
*	O
2	int
)	O
-	O
1	int
;	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
,	O
(	O
lines_allocated	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
struct	O
line_data	struct(*(char),int,*(*(struct)),*(*(struct)),int,int)
)	O
)	O
;	O
}	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
]	O
.	O
start	*(long)
=	O
&	O
data	*(char)
[	O
i	int
]	O
;	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
]	O
.	O
add_entries_before	*(*(struct))
=	O
0	int
;	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
]	O
.	O
add_sections_before	*(*(struct))
=	O
NULL	O
;	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
]	O
.	O
num_sections_to_add	int
=	O
0	int
;	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
]	O
.	O
delete	int
=	O
0	int
;	O
if	O
(	O
filled	int
>	O
0	int
)	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
-	O
1	int
]	O
.	O
size	int
=	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
]	O
.	O
start	*(long)
-	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
-	O
1	int
]	O
.	O
start	*(long)
-	O
1	int
;	O
filled	int
++	O
;	O
}	O
lineflag	int
=	O
(	O
data	*(char)
[	O
i	int
]	O
==	O
'\n'	O
)	O
;	O
}	O
if	O
(	O
filled	int
>	O
0	int
)	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
-	O
1	int
]	O
.	O
size	int
=	O
&	O
data	*(char)
[	O
i	int
]	O
-	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
-	O
1	int
]	O
.	O
start	*(long)
-	O
lineflag	int
;	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
]	O
.	O
start	*(long)
=	O
NULL	O
;	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
]	O
.	O
add_entries_before	*(*(struct))
=	O
NULL	O
;	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
]	O
.	O
add_sections_before	*(*(struct))
=	O
NULL	O
;	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
]	O
.	O
num_sections_to_add	int
=	O
0	int
;	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
]	O
.	O
delete	int
=	O
0	int
;	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
[	O
filled	int
]	O
.	O
size	int
=	O
0	int
;	O
*	O
nlinesp	*(int)
=	O
filled	int
;	O
return	O
lines	*(struct(*(char),int,*(*(struct(*`,*`,long,*`,*`,int,int,int))),*(*(struct(*`,*`,int))),int,int))
;	O
}	O
int	O
compare_section_names	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
p1	*(void)
,	O
const	O
void	O
*	O
p2	*(void)
)	O
{	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
*	O
sec1	*(*(struct(*(struct(*`,*`,int)),*(char),int)))
=	O
(	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
*	O
)	O
p1	*(void)
;	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
*	O
sec2	*(*(struct(*(struct(*`,*`,int)),*(char),int)))
=	O
(	O
struct	O
spec_section	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
*	O
)	O
p2	*(void)
;	O
char	O
*	O
name1	*(char)
=	O
(	O
*	O
sec1	*(*(struct(*(struct(*`,*`,int)),*(char),int)))
)	O
->	O
name	*(char)
;	O
char	O
*	O
name2	*(char)
=	O
(	O
*	O
sec2	*(*(struct(*(struct(*`,*`,int)),*(char),int)))
)	O
->	O
name	*(char)
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
name1	*(char)
,	O
name2	*(char)
)	O
;	O
}	O
int	O
compare_entries_text	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
p1	*(void)
,	O
const	O
void	O
*	O
p2	*(void)
)	O
{	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
*	O
entry1	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
=	O
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
*	O
)	O
p1	*(void)
;	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
*	O
entry2	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
=	O
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
*	O
)	O
p2	*(void)
;	O
char	O
*	O
text1	*(char)
=	O
(	O
*	O
entry1	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
)	O
->	O
text	*(char)
;	O
char	O
*	O
text2	*(char)
=	O
(	O
*	O
entry2	*(*(struct(*(struct(*`,*`,long,*`,*`,int,int,int)),*(char),long,*(struct(*`,*`,int)),*(struct(*`,*`,int)),int,int,int)))
)	O
->	O
text	*(char)
;	O
char	O
*	O
colon1	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
text1	*(char)
,	O
':'	O
)	O
;	O
char	O
*	O
colon2	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
text2	*(char)
,	O
':'	O
)	O
;	O
int	O
len1	int
,	O
len2	int
;	O
if	O
(	O
!	O
colon1	*(char)
)	O
len1	int
=	O
strlen	(*(char))->(long)
(	O
text1	*(char)
)	O
;	O
else	O
len1	int
=	O
colon1	*(char)
-	O
text1	*(char)
;	O
if	O
(	O
!	O
colon2	*(char)
)	O
len2	int
=	O
strlen	(*(char))->(long)
(	O
text2	*(char)
)	O
;	O
else	O
len2	int
=	O
colon2	*(char)
-	O
text2	*(char)
;	O
return	O
mbsncasecmp	(*(char),*(char),long)->(int)
(	O
text1	*(char)
,	O
text2	*(char)
,	O
len1	int
<=	O
len2	int
?	O
len1	int
:	O
len2	int
)	O
;	O
}	O
void	O
insert_entry_here	(*(struct),int,*(struct),int)->(void)
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
entry	*(struct)
,	O
int	O
line_number	int
,	O
struct	O
line_data	struct(*(char),int,*(*(struct)),*(*(struct)),int,int)
*	O
dir_lines	*(struct)
,	O
int	O
n_entries	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
dir_lines	*(struct)
[	O
line_number	int
]	O
.	O
add_entries_before	*(*(struct))
==	O
0	int
)	O
{	O
dir_lines	*(struct)
[	O
line_number	int
]	O
.	O
add_entries_before	*(*(struct))
=	O
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
n_entries	int
*	O
sizeof	O
(	O
struct	O
spec_entry	struct(*(struct(*(struct(*(struct`),*(char),long,*(struct`),*(struct`),int,int,int)),*(char),long,*(struct(*(struct`),*(char),int)),*(struct(*(struct`),*(char),int)),int,int,int)),*(char),long,*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),int,int,int)
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_entries	int
;	O
i	int
++	O
)	O
dir_lines	*(struct)
[	O
line_number	int
]	O
.	O
add_entries_before	*(*(struct))
[	O
i	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_entries	int
;	O
i	int
++	O
)	O
if	O
(	O
dir_lines	*(struct)
[	O
line_number	int
]	O
.	O
add_entries_before	*(*(struct))
[	O
i	int
]	O
==	O
0	int
||	O
menu_line_lessp	(*(char),int,*(char),int)->(int)
(	O
entry	*(struct)
->	O
text	*(char)
,	O
strlen	(*(char))->(long)
(	O
entry	*(struct)
->	O
text	*(char)
)	O
,	O
dir_lines	*(struct)
[	O
line_number	int
]	O
.	O
add_entries_before	*(*(struct))
[	O
i	int
]	O
->	O
text	*(char)
,	O
strlen	(*(char))->(long)
(	O
dir_lines	*(struct)
[	O
line_number	int
]	O
.	O
add_entries_before	*(*(struct))
[	O
i	int
]	O
->	O
text	*(char)
)	O
)	O
)	O
break	O
;	O
if	O
(	O
i	int
==	O
n_entries	int
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
dir_lines	*(struct)
[	O
line_number	int
]	O
.	O
add_entries_before	*(*(struct))
[	O
i	int
]	O
!=	O
0	int
)	O
for	O
(	O
j	int
=	O
n_entries	int
-	O
1	int
;	O
j	int
>	O
i	int
;	O
j	int
--	O
)	O
dir_lines	*(struct)
[	O
line_number	int
]	O
.	O
add_entries_before	*(*(struct))
[	O
j	int
]	O
=	O
dir_lines	*(struct)
[	O
line_number	int
]	O
.	O
add_entries_before	*(*(struct))
[	O
j	int
-	O
1	int
]	O
;	O
dir_lines	*(struct)
[	O
line_number	int
]	O
.	O
add_entries_before	*(*(struct))
[	O
i	int
]	O
=	O
entry	*(struct)
;	O
}	O
