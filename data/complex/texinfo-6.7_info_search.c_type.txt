enum	O
search_result	enum(int,int,int)
search	(*(char),*(struct(*(char),long,long,int)),*(long))->(enum(int,int,int))
(	O
char	O
*	O
string	*(char)
,	O
SEARCH_BINDING	struct(*(char),long,long,int)
*	O
binding	*(struct(*(char),long,long,int))
,	O
long	O
*	O
poff	*(long)
)	O
{	O
enum	O
search_result	enum(int,int,int)
result	enum(int,int,int)
;	O
if	O
(	O
binding	*(struct(*(char),long,long,int))
->	O
start	*(long)
>	O
binding	*(struct(*(char),long,long,int))
->	O
end	*(long)
)	O
result	enum(int,int,int)
=	O
search_backward	(*(char),*(struct(*(char),long,long,int)),*(long))->(enum(int,int,int))
(	O
string	*(char)
,	O
binding	*(struct(*(char),long,long,int))
,	O
poff	*(long)
)	O
;	O
else	O
result	enum(int,int,int)
=	O
search_forward	(*(char),*(struct(*(char),long,long,int)),*(long))->(enum(int,int,int))
(	O
string	*(char)
,	O
binding	*(struct(*(char),long,long,int))
,	O
poff	*(long)
)	O
;	O
return	O
result	enum(int,int,int)
;	O
}	O
static	O
char	O
*	O
regexp_expand_newlines_and_tabs	(*(char))->(*(char))
(	O
char	O
*	O
regexp	*(char)
)	O
{	O
char	O
*	O
unescaped_regexp	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
1	int
+	O
strlen	(*(char))->(long)
(	O
regexp	*(char)
)	O
)	O
;	O
char	O
*	O
p	*(void)
,	O
*	O
q	*(char)
;	O
for	O
(	O
p	*(void)
=	O
regexp	*(char)
,	O
q	*(char)
=	O
unescaped_regexp	*(char)
;	O
*	O
p	*(void)
!=	O
'\0'	O
;	O
p	*(void)
++	O
,	O
q	*(char)
++	O
)	O
{	O
if	O
(	O
*	O
p	*(void)
==	O
'\\'	O
)	O
switch	O
(	O
*	O
++	O
p	*(void)
)	O
{	O
case	O
'n'	O
:	O
*	O
q	*(char)
=	O
'\n'	O
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
q	*(char)
=	O
'\t'	O
;	O
break	O
;	O
case	O
'\0'	O
:	O
*	O
q	*(char)
=	O
'\\'	O
;	O
p	*(void)
--	O
;	O
break	O
;	O
default	O
:	O
*	O
q	*(char)
++	O
=	O
'\\'	O
;	O
*	O
q	*(char)
=	O
*	O
p	*(void)
;	O
break	O
;	O
}	O
else	O
*	O
q	*(char)
=	O
*	O
p	*(void)
;	O
}	O
*	O
q	*(char)
=	O
'\0'	O
;	O
return	O
unescaped_regexp	*(char)
;	O
}	O
static	O
char	O
*	O
regexp_escape_string	(*(char))->(*(char))
(	O
char	O
*	O
search_string	*(char)
)	O
{	O
char	O
*	O
special_chars	*(char)
=	O
"\\[]^$.*(){}|+?"	*(char)
;	O
char	O
*	O
p	*(void)
,	O
*	O
q	*(char)
;	O
char	O
*	O
escaped_string	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
search_string	*(char)
)	O
*	O
2	int
+	O
1	int
)	O
;	O
for	O
(	O
p	*(void)
=	O
search_string	*(char)
,	O
q	*(char)
=	O
escaped_string	*(char)
;	O
*	O
p	*(void)
!=	O
'\0'	O
;	O
)	O
{	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
special_chars	*(char)
,	O
*	O
p	*(void)
)	O
)	O
{	O
*	O
q	*(char)
++	O
=	O
'\\'	O
;	O
}	O
*	O
q	*(char)
++	O
=	O
*	O
p	*(void)
++	O
;	O
}	O
*	O
q	*(char)
=	O
'\0'	O
;	O
return	O
escaped_string	*(char)
;	O
}	O
static	O
void	O
extend_matches	(*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)))->(void)
(	O
MATCH_STATE	struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)
*	O
state	*(int)
)	O
{	O
regmatch_t	struct(long,long)
*	O
matches	*(struct(long,long))
=	O
state	*(int)
->	O
matches	*(struct(long,long))
;	O
size_t	long
match_alloc	long
=	O
state	*(int)
->	O
match_alloc	long
;	O
size_t	long
match_count	long
=	O
state	*(int)
->	O
match_count	long
;	O
char	O
*	O
buffer	*(struct)
=	O
state	*(int)
->	O
buffer	*(struct)
;	O
size_t	long
buflen	long
=	O
state	*(int)
->	O
buflen	long
;	O
regoff_t	long
offset	long
=	O
0	int
;	O
char	O
saved_char	char
;	O
size_t	long
initial_match_count	long
=	O
match_count	long
;	O
if	O
(	O
state	*(int)
->	O
finished	int
)	O
return	O
;	O
saved_char	char
=	O
buffer	*(struct)
[	O
buflen	long
]	O
;	O
buffer	*(struct)
[	O
buflen	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
match_count	long
>	O
0	int
)	O
{	O
offset	long
=	O
matches	*(struct(long,long))
[	O
match_count	long
-	O
1	int
]	O
.	O
rm_eo	long
;	O
if	O
(	O
offset	long
==	O
matches	*(struct(long,long))
[	O
match_count	long
-	O
1	int
]	O
.	O
rm_so	long
)	O
offset	long
++	O
;	O
}	O
while	O
(	O
offset	long
<	O
buflen	long
&&	O
match_count	long
<	O
initial_match_count	long
+	O
5	int
)	O
{	O
int	O
result	enum(int,int,int)
=	O
0	int
;	O
regmatch_t	struct(long,long)
m	struct(long,long)
;	O
result	enum(int,int,int)
=	O
regexec	O
(	O
&	O
state	*(int)
->	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
&	O
buffer	*(struct)
[	O
offset	long
]	O
,	O
1	int
,	O
&	O
m	struct(long,long)
,	O
REG_NOTBOL	int
)	O
;	O
if	O
(	O
result	enum(int,int,int)
==	O
0	int
)	O
{	O
if	O
(	O
match_count	long
==	O
match_alloc	long
)	O
{	O
if	O
(	O
match_alloc	long
==	O
0	int
)	O
match_alloc	long
=	O
50	int
;	O
matches	*(struct(long,long))
=	O
x2nrealloc	(*(void),*(long),long)->(*(void))
(	O
matches	*(struct(long,long))
,	O
&	O
match_alloc	long
,	O
sizeof	O
matches	*(struct(long,long))
[	O
0	int
]	O
)	O
;	O
}	O
matches	*(struct(long,long))
[	O
match_count	long
]	O
=	O
m	struct(long,long)
;	O
matches	*(struct(long,long))
[	O
match_count	long
]	O
.	O
rm_so	long
+=	O
offset	long
;	O
matches	*(struct(long,long))
[	O
match_count	long
]	O
.	O
rm_eo	long
+=	O
offset	long
;	O
offset	long
=	O
matches	*(struct(long,long))
[	O
match_count	long
++	O
]	O
.	O
rm_eo	long
;	O
if	O
(	O
m	struct(long,long)
.	O
rm_eo	long
==	O
0	int
)	O
offset	long
++	O
;	O
}	O
else	O
{	O
state	*(int)
->	O
finished	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
buffer	*(struct)
[	O
buflen	long
]	O
=	O
saved_char	char
;	O
state	*(int)
->	O
matches	*(struct(long,long))
=	O
matches	*(struct(long,long))
;	O
state	*(int)
->	O
match_alloc	long
=	O
match_alloc	long
;	O
state	*(int)
->	O
match_count	long
=	O
match_count	long
;	O
}	O
enum	O
search_result	enum(int,int,int)
regexp_search	(*(char),int,int,*(char),long,*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)))->(enum(int,int,int))
(	O
char	O
*	O
regexp	*(char)
,	O
int	O
is_literal	int
,	O
int	O
is_insensitive	int
,	O
char	O
*	O
buffer	*(struct)
,	O
size_t	long
buflen	long
,	O
MATCH_STATE	struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)
*	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
)	O
{	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
preg	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
int	O
result	enum(int,int,int)
;	O
char	O
*	O
regexp_str	*(char)
;	O
if	O
(	O
!	O
is_literal	int
)	O
regexp_str	*(char)
=	O
regexp_expand_newlines_and_tabs	(*(char))->(*(char))
(	O
regexp	*(char)
)	O
;	O
else	O
regexp_str	*(char)
=	O
regexp_escape_string	(*(char))->(*(char))
(	O
regexp	*(char)
)	O
;	O
result	enum(int,int,int)
=	O
regcomp	O
(	O
&	O
preg	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
regexp_str	*(char)
,	O
REG_EXTENDED	int
|	O
REG_NEWLINE	O
|	O
(	O
is_insensitive	int
?	O
REG_ICASE	O
:	O
0	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
regexp_str	*(char)
)	O
;	O
if	O
(	O
result	enum(int,int,int)
!=	O
0	int
)	O
{	O
int	O
size	long
=	O
regerror	O
(	O
result	enum(int,int,int)
,	O
&	O
preg	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
NULL	O
,	O
0	int
)	O
;	O
char	O
*	O
buf	array(char)
=	O
xmalloc	(long)->(*(void))
(	O
size	long
)	O
;	O
regerror	O
(	O
result	enum(int,int,int)
,	O
&	O
preg	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
buf	array(char)
,	O
size	long
)	O
;	O
info_error	(*(char))->(void)
(	O
_	O
(	O
"regexp error: %s"	*(char)
)	O
,	O
buf	array(char)
)	O
;	O
free	(*(void))->(void)
(	O
buf	array(char)
)	O
;	O
return	O
search_invalid	int
;	O
}	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
->	O
matches	*(struct(long,long))
=	O
0	int
;	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
->	O
match_count	long
=	O
0	int
;	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
->	O
match_alloc	long
=	O
0	int
;	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
->	O
finished	int
=	O
0	int
;	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
->	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
=	O
preg	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
->	O
buffer	*(struct)
=	O
buffer	*(struct)
;	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
->	O
buflen	long
=	O
buflen	long
;	O
extend_matches	(*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)))->(void)
(	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
)	O
;	O
if	O
(	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
->	O
match_count	long
==	O
0	int
)	O
{	O
free_matches	(*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)))->(void)
(	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
)	O
;	O
return	O
search_not_found	int
;	O
}	O
else	O
return	O
search_success	int
;	O
}	O
enum	O
search_result	enum(int,int,int)
search_forward	(*(char),*(struct(*(char),long,long,int)),*(long))->(enum(int,int,int))
(	O
char	O
*	O
string	*(char)
,	O
SEARCH_BINDING	struct(*(char),long,long,int)
*	O
binding	*(struct(*(char),long,long,int))
,	O
long	O
*	O
poff	*(long)
)	O
{	O
register	O
int	O
c	int
,	O
i	int
,	O
len	long
;	O
register	O
char	O
*	O
buff	*(char)
,	O
*	O
end	*(long)
;	O
char	O
*	O
alternate	*(char)
=	O
NULL	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
;	O
if	O
(	O
binding	*(struct(*(char),long,long,int))
->	O
flags	int
&	O
S_FoldCase	int
)	O
{	O
alternate	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
string	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
islower	(int)->(int)
(	O
alternate	*(char)
[	O
i	int
]	O
)	O
)	O
alternate	*(char)
[	O
i	int
]	O
=	O
toupper	(int)->(int)
(	O
alternate	*(char)
[	O
i	int
]	O
)	O
;	O
else	O
if	O
(	O
isupper	(int)->(int)
(	O
alternate	*(char)
[	O
i	int
]	O
)	O
)	O
alternate	*(char)
[	O
i	int
]	O
=	O
tolower	(int)->(int)
(	O
alternate	*(char)
[	O
i	int
]	O
)	O
;	O
}	O
}	O
buff	*(char)
=	O
binding	*(struct(*(char),long,long,int))
->	O
buffer	*(struct)
+	O
binding	*(struct(*(char),long,long,int))
->	O
start	*(long)
;	O
end	*(long)
=	O
binding	*(struct(*(char),long,long,int))
->	O
buffer	*(struct)
+	O
binding	*(struct(*(char),long,long,int))
->	O
end	*(long)
+	O
1	int
;	O
while	O
(	O
buff	*(char)
<	O
(	O
end	*(long)
-	O
len	long
)	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	long
;	O
i	int
++	O
)	O
{	O
c	int
=	O
buff	*(char)
[	O
i	int
]	O
;	O
if	O
(	O
(	O
c	int
!=	O
string	*(char)
[	O
i	int
]	O
)	O
&&	O
(	O
!	O
alternate	*(char)
||	O
c	int
!=	O
alternate	*(char)
[	O
i	int
]	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
string	*(char)
[	O
i	int
]	O
)	O
{	O
if	O
(	O
alternate	*(char)
)	O
free	(*(void))->(void)
(	O
alternate	*(char)
)	O
;	O
if	O
(	O
binding	*(struct(*(char),long,long,int))
->	O
flags	int
&	O
S_SkipDest	int
)	O
buff	*(char)
+=	O
len	long
;	O
*	O
poff	*(long)
=	O
buff	*(char)
-	O
binding	*(struct(*(char),long,long,int))
->	O
buffer	*(struct)
;	O
return	O
search_success	int
;	O
}	O
buff	*(char)
++	O
;	O
}	O
if	O
(	O
alternate	*(char)
)	O
free	(*(void))->(void)
(	O
alternate	*(char)
)	O
;	O
return	O
search_not_found	int
;	O
}	O
enum	O
search_result	enum(int,int,int)
search_backward	(*(char),*(struct(*(char),long,long,int)),*(long))->(enum(int,int,int))
(	O
char	O
*	O
input_string	*(char)
,	O
SEARCH_BINDING	struct(*(char),long,long,int)
*	O
binding	*(struct(*(char),long,long,int))
,	O
long	O
*	O
poff	*(long)
)	O
{	O
register	O
int	O
c	int
,	O
i	int
,	O
len	long
;	O
register	O
char	O
*	O
buff	*(char)
,	O
*	O
end	*(long)
;	O
char	O
*	O
string	*(char)
;	O
char	O
*	O
alternate	*(char)
=	O
NULL	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
input_string	*(char)
)	O
;	O
string	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
1	int
+	O
len	long
)	O
;	O
for	O
(	O
c	int
=	O
0	int
,	O
i	int
=	O
len	long
-	O
1	int
;	O
input_string	*(char)
[	O
c	int
]	O
;	O
c	int
++	O
,	O
i	int
--	O
)	O
string	*(char)
[	O
i	int
]	O
=	O
input_string	*(char)
[	O
c	int
]	O
;	O
string	*(char)
[	O
c	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
binding	*(struct(*(char),long,long,int))
->	O
flags	int
&	O
S_FoldCase	int
)	O
{	O
alternate	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
string	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
islower	(int)->(int)
(	O
alternate	*(char)
[	O
i	int
]	O
)	O
)	O
alternate	*(char)
[	O
i	int
]	O
=	O
toupper	(int)->(int)
(	O
alternate	*(char)
[	O
i	int
]	O
)	O
;	O
else	O
if	O
(	O
isupper	(int)->(int)
(	O
alternate	*(char)
[	O
i	int
]	O
)	O
)	O
alternate	*(char)
[	O
i	int
]	O
=	O
tolower	(int)->(int)
(	O
alternate	*(char)
[	O
i	int
]	O
)	O
;	O
}	O
}	O
buff	*(char)
=	O
binding	*(struct(*(char),long,long,int))
->	O
buffer	*(struct)
+	O
binding	*(struct(*(char),long,long,int))
->	O
start	*(long)
-	O
1	int
;	O
end	*(long)
=	O
binding	*(struct(*(char),long,long,int))
->	O
buffer	*(struct)
+	O
binding	*(struct(*(char),long,long,int))
->	O
end	*(long)
;	O
while	O
(	O
buff	*(char)
>	O
(	O
end	*(long)
+	O
len	long
)	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	long
;	O
i	int
++	O
)	O
{	O
c	int
=	O
*	O
(	O
buff	*(char)
-	O
i	int
)	O
;	O
if	O
(	O
c	int
!=	O
string	*(char)
[	O
i	int
]	O
&&	O
(	O
!	O
alternate	*(char)
||	O
c	int
!=	O
alternate	*(char)
[	O
i	int
]	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
string	*(char)
[	O
i	int
]	O
)	O
{	O
free	(*(void))->(void)
(	O
string	*(char)
)	O
;	O
if	O
(	O
alternate	*(char)
)	O
free	(*(void))->(void)
(	O
alternate	*(char)
)	O
;	O
if	O
(	O
binding	*(struct(*(char),long,long,int))
->	O
flags	int
&	O
S_SkipDest	int
)	O
buff	*(char)
-=	O
len	long
;	O
*	O
poff	*(long)
=	O
1	int
+	O
buff	*(char)
-	O
binding	*(struct(*(char),long,long,int))
->	O
buffer	*(struct)
;	O
return	O
search_success	int
;	O
}	O
buff	*(char)
--	O
;	O
}	O
free	(*(void))->(void)
(	O
string	*(char)
)	O
;	O
if	O
(	O
alternate	*(char)
)	O
free	(*(void))->(void)
(	O
alternate	*(char)
)	O
;	O
return	O
search_not_found	int
;	O
}	O
int	O
string_in_line	(*(char),*(char))->(int)
(	O
char	O
*	O
string	*(char)
,	O
char	O
*	O
line	*(char)
)	O
{	O
register	O
int	O
end	*(long)
;	O
SEARCH_BINDING	struct(*(char),long,long,int)
binding	*(struct(*(char),long,long,int))
;	O
long	O
offset	long
;	O
for	O
(	O
end	*(long)
=	O
0	int
;	O
line	*(char)
[	O
end	*(long)
]	O
&&	O
line	*(char)
[	O
end	*(long)
]	O
!=	O
'\n'	O
;	O
end	*(long)
++	O
)	O
;	O
binding	*(struct(*(char),long,long,int))
.	O
buffer	*(struct)
=	O
line	*(char)
;	O
binding	*(struct(*(char),long,long,int))
.	O
start	*(long)
=	O
0	int
;	O
binding	*(struct(*(char),long,long,int))
.	O
end	*(long)
=	O
end	*(long)
;	O
binding	*(struct(*(char),long,long,int))
.	O
flags	int
=	O
S_FoldCase	int
|	O
S_SkipDest	int
;	O
if	O
(	O
search_forward	(*(char),*(struct(*(char),long,long,int)),*(long))->(enum(int,int,int))
(	O
string	*(char)
,	O
&	O
binding	*(struct(*(char),long,long,int))
,	O
&	O
offset	long
)	O
==	O
search_success	int
)	O
return	O
offset	long
;	O
return	O
-	O
1	int
;	O
}	O
int	O
looking_at	(*(char),*(struct(*(char),long,long,int)))->(int)
(	O
char	O
*	O
string	*(char)
,	O
SEARCH_BINDING	struct(*(char),long,long,int)
*	O
binding	*(struct(*(char),long,long,int))
)	O
{	O
long	O
search_end	long
;	O
if	O
(	O
search	(*(char),*(struct(*(char),long,long,int)),*(long))->(enum(int,int,int))
(	O
string	*(char)
,	O
binding	*(struct(*(char),long,long,int))
,	O
&	O
search_end	long
)	O
!=	O
search_success	int
)	O
return	O
0	int
;	O
return	O
search_end	long
==	O
binding	*(struct(*(char),long,long,int))
->	O
start	*(long)
;	O
}	O
int	O
looking_at_line	(*(char),*(char))->(int)
(	O
char	O
*	O
string	*(char)
,	O
char	O
*	O
pointer	*(char)
)	O
{	O
int	O
len	long
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
;	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
pointer	*(char)
,	O
string	*(char)
,	O
len	long
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
pointer	*(char)
+=	O
len	long
;	O
if	O
(	O
*	O
pointer	*(char)
==	O
'\n'	O
||	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
pointer	*(char)
,	O
"\r\n"	*(char)
,	O
2	int
)	O
||	O
*	O
pointer	*(char)
==	O
'\0'	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
enum	O
search_result	enum(int,int,int)
match_in_match_list	(*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)),long,long,int,*(int))->(enum(int,int,int))
(	O
MATCH_STATE	struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)
*	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
,	O
long	O
start	*(long)
,	O
long	O
end	*(long)
,	O
int	O
dir	int
,	O
int	O
*	O
match_index	*(int)
)	O
{	O
regmatch_t	struct(long,long)
*	O
matches	*(struct(long,long))
=	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
->	O
matches	*(struct(long,long))
;	O
size_t	long
match_count	long
=	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
->	O
match_count	long
;	O
int	O
i	int
;	O
int	O
index	(*(char),int)->(*(char))
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
match_count	long
||	O
!	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
->	O
finished	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
match_count	long
)	O
{	O
extend_matches	(*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)))->(void)
(	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
)	O
;	O
matches	*(struct(long,long))
=	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
->	O
matches	*(struct(long,long))
;	O
match_count	long
=	O
match_state	*(struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long))
->	O
match_count	long
;	O
if	O
(	O
i	int
==	O
match_count	long
)	O
break	O
;	O
}	O
if	O
(	O
matches	*(struct(long,long))
[	O
i	int
]	O
.	O
rm_so	long
>=	O
end	*(long)
)	O
break	O
;	O
if	O
(	O
matches	*(struct(long,long))
[	O
i	int
]	O
.	O
rm_so	long
>=	O
start	*(long)
)	O
{	O
index	(*(char),int)->(*(char))
=	O
i	int
;	O
if	O
(	O
dir	int
>	O
0	int
)	O
{	O
*	O
match_index	*(int)
=	O
index	(*(char),int)->(*(char))
;	O
return	O
search_success	int
;	O
}	O
}	O
}	O
if	O
(	O
index	(*(char),int)->(*(char))
!=	O
-	O
1	int
)	O
{	O
*	O
match_index	*(int)
=	O
index	(*(char),int)->(*(char))
;	O
return	O
search_success	int
;	O
}	O
return	O
search_not_found	int
;	O
}	O
regmatch_t	struct(long,long)
match_by_index	(*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)),int)->(struct(long,long))
(	O
MATCH_STATE	struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)
*	O
state	*(int)
,	O
int	O
index	(*(char),int)->(*(char))
)	O
{	O
while	O
(	O
state	*(int)
->	O
match_alloc	long
<=	O
index	(*(char),int)->(*(char))
)	O
extend_matches	(*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)))->(void)
(	O
state	*(int)
)	O
;	O
return	O
state	*(int)
->	O
matches	*(struct(long,long))
[	O
index	(*(char),int)->(*(char))
]	O
;	O
}	O
void	O
free_matches	(*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)))->(void)
(	O
MATCH_STATE	struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)
*	O
state	*(int)
)	O
{	O
free	(*(void))->(void)
(	O
state	*(int)
->	O
matches	*(struct(long,long))
)	O
;	O
state	*(int)
->	O
matches	*(struct(long,long))
=	O
0	int
;	O
state	*(int)
->	O
match_count	long
=	O
state	*(int)
->	O
match_alloc	long
=	O
state	*(int)
->	O
finished	int
=	O
0	int
;	O
state	*(int)
->	O
buffer	*(struct)
=	O
0	int
;	O
state	*(int)
->	O
buflen	long
=	O
0	int
;	O
regfree	O
(	O
&	O
state	*(int)
->	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
)	O
;	O
}	O
int	O
matches_ready	(*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)))->(int)
(	O
MATCH_STATE	struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)
*	O
state	*(int)
)	O
{	O
return	O
state	*(int)
->	O
matches	*(struct(long,long))
?	O
1	int
:	O
0	int
;	O
}	O
void	O
decide_if_in_match	(long,*(int),*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)),*(long))->(void)
(	O
long	O
off	long
,	O
int	O
*	O
in_match	*(int)
,	O
MATCH_STATE	struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)
*	O
matches	*(struct(long,long))
,	O
size_t	long
*	O
match_index	*(int)
)	O
{	O
size_t	long
i	int
=	O
*	O
match_index	*(int)
;	O
int	O
m	struct(long,long)
=	O
*	O
in_match	*(int)
;	O
for	O
(	O
;	O
!	O
at_end_of_matches	(*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)),int)->(int)
(	O
matches	*(struct(long,long))
,	O
i	int
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
match_by_index	(*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)),int)->(struct(long,long))
(	O
matches	*(struct(long,long))
,	O
i	int
)	O
.	O
rm_so	long
>	O
off	long
)	O
break	O
;	O
m	struct(long,long)
=	O
1	int
;	O
if	O
(	O
match_by_index	(*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)),int)->(struct(long,long))
(	O
matches	*(struct(long,long))
,	O
i	int
)	O
.	O
rm_eo	long
>	O
off	long
)	O
break	O
;	O
m	struct(long,long)
=	O
0	int
;	O
}	O
*	O
match_index	*(int)
=	O
i	int
;	O
*	O
in_match	*(int)
=	O
m	struct(long,long)
;	O
}	O
int	O
at_end_of_matches	(*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)),int)->(int)
(	O
MATCH_STATE	struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)
*	O
state	*(int)
,	O
int	O
index	(*(char),int)->(*(char))
)	O
{	O
if	O
(	O
index	(*(char),int)->(*(char))
<	O
state	*(int)
->	O
match_count	long
)	O
return	O
0	int
;	O
else	O
{	O
if	O
(	O
!	O
state	*(int)
->	O
finished	int
)	O
extend_matches	(*(struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long)))->(void)
(	O
state	*(int)
)	O
;	O
if	O
(	O
state	*(int)
->	O
finished	int
)	O
return	O
(	O
state	*(int)
->	O
match_count	long
==	O
index	(*(char),int)->(*(char))
)	O
?	O
1	int
:	O
0	int
;	O
else	O
return	O
0	int
;	O
}	O
}	O
int	O
skip_whitespace	(*(char))->(int)
(	O
char	O
*	O
string	*(char)
)	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
string	*(char)
&&	O
whitespace	O
(	O
string	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
return	O
i	int
;	O
}	O
int	O
skip_whitespace_and_newlines	(*(char))->(int)
(	O
char	O
*	O
string	*(char)
)	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
string	*(char)
&&	O
whitespace_or_newline	O
(	O
string	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
return	O
i	int
;	O
}	O
int	O
skip_non_whitespace	(*(char))->(int)
(	O
char	O
*	O
string	*(char)
)	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
string	*(char)
&&	O
string	*(char)
[	O
i	int
]	O
&&	O
!	O
whitespace	O
(	O
string	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
return	O
i	int
;	O
}	O
long	O
find_node_separator	(*(struct(*(char),long,long,int)))->(long)
(	O
SEARCH_BINDING	struct(*(char),long,long,int)
*	O
binding	*(struct(*(char),long,long,int))
)	O
{	O
register	O
long	O
i	int
;	O
char	O
*	O
body	*(char)
;	O
int	O
dir	int
;	O
body	*(char)
=	O
binding	*(struct(*(char),long,long,int))
->	O
buffer	*(struct)
;	O
dir	int
=	O
binding	*(struct(*(char),long,long,int))
->	O
start	*(long)
<	O
binding	*(struct(*(char),long,long,int))
->	O
end	*(long)
?	O
1	int
:	O
-	O
1	int
;	O
i	int
=	O
binding	*(struct(*(char),long,long,int))
->	O
start	*(long)
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
body	*(char)
[	O
i	int
]	O
==	O
INFO_COOKIE	char
)	O
{	O
int	O
j	int
=	O
i	int
+	O
1	int
;	O
if	O
(	O
body	*(char)
[	O
j	int
]	O
==	O
INFO_FF	char
)	O
j	int
++	O
;	O
if	O
(	O
body	*(char)
[	O
j	int
]	O
==	O
'\r'	O
)	O
j	int
++	O
;	O
if	O
(	O
body	*(char)
[	O
j	int
]	O
==	O
'\n'	O
)	O
return	O
i	int
;	O
}	O
if	O
(	O
i	int
==	O
binding	*(struct(*(char),long,long,int))
->	O
end	*(long)
)	O
break	O
;	O
i	int
+=	O
dir	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
skip_node_separator	(*(char))->(int)
(	O
char	O
*	O
body	*(char)
)	O
{	O
register	O
int	O
i	int
;	O
i	int
=	O
0	int
;	O
if	O
(	O
body	*(char)
[	O
i	int
]	O
==	O
INFO_FF	char
)	O
i	int
++	O
;	O
if	O
(	O
body	*(char)
[	O
i	int
++	O
]	O
!=	O
INFO_COOKIE	char
)	O
return	O
0	int
;	O
if	O
(	O
body	*(char)
[	O
i	int
]	O
==	O
INFO_FF	char
)	O
i	int
++	O
;	O
if	O
(	O
body	*(char)
[	O
i	int
]	O
==	O
'\r'	O
)	O
i	int
++	O
;	O
if	O
(	O
body	*(char)
[	O
i	int
++	O
]	O
!=	O
'\n'	O
)	O
return	O
0	int
;	O
return	O
i	int
;	O
}	O
long	O
find_file_section	(*(struct(*(char),long,long,int)),*(char))->(long)
(	O
SEARCH_BINDING	struct(*(char),long,long,int)
*	O
binding	*(struct(*(char),long,long,int))
,	O
char	O
*	O
label	*(char)
)	O
{	O
SEARCH_BINDING	struct(*(char),long,long,int)
s	*(char)
;	O
long	O
position	long
;	O
int	O
dir	int
;	O
s	*(char)
.	O
buffer	*(struct)
=	O
binding	*(struct(*(char),long,long,int))
->	O
buffer	*(struct)
;	O
s	*(char)
.	O
start	*(long)
=	O
binding	*(struct(*(char),long,long,int))
->	O
start	*(long)
;	O
s	*(char)
.	O
end	*(long)
=	O
binding	*(struct(*(char),long,long,int))
->	O
end	*(long)
;	O
s	*(char)
.	O
flags	int
=	O
S_FoldCase	int
;	O
dir	int
=	O
binding	*(struct(*(char),long,long,int))
->	O
start	*(long)
<	O
binding	*(struct(*(char),long,long,int))
->	O
end	*(long)
?	O
1	int
:	O
-	O
1	int
;	O
while	O
(	O
(	O
position	long
=	O
find_node_separator	(*(struct(*(char),long,long,int)))->(long)
(	O
&	O
s	*(char)
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
long	O
offset	long
=	O
position	long
;	O
offset	long
+=	O
skip_node_separator	(*(char))->(int)
(	O
s	*(char)
.	O
buffer	*(struct)
+	O
offset	long
)	O
;	O
if	O
(	O
looking_at_line	(*(char),*(char))->(int)
(	O
label	*(char)
,	O
s	*(char)
.	O
buffer	*(struct)
+	O
offset	long
)	O
)	O
return	O
position	long
;	O
if	O
(	O
dir	int
>	O
0	int
)	O
{	O
s	*(char)
.	O
start	*(long)
=	O
offset	long
;	O
if	O
(	O
s	*(char)
.	O
start	*(long)
>=	O
s	*(char)
.	O
end	*(long)
)	O
break	O
;	O
}	O
else	O
{	O
s	*(char)
.	O
start	*(long)
=	O
position	long
-	O
1	int
;	O
if	O
(	O
s	*(char)
.	O
start	*(long)
<=	O
s	*(char)
.	O
end	*(long)
)	O
break	O
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
long	O
find_node_in_binding	(*(char),*(struct(*(char),long,long,int)))->(long)
(	O
char	O
*	O
nodename	*(char)
,	O
SEARCH_BINDING	struct(*(char),long,long,int)
*	O
binding	*(struct(*(char),long,long,int))
)	O
{	O
long	O
position	long
;	O
int	O
offset	long
;	O
SEARCH_BINDING	struct(*(char),long,long,int)
s	*(char)
;	O
s	*(char)
.	O
buffer	*(struct)
=	O
binding	*(struct(*(char),long,long,int))
->	O
buffer	*(struct)
;	O
s	*(char)
.	O
start	*(long)
=	O
binding	*(struct(*(char),long,long,int))
->	O
start	*(long)
;	O
s	*(char)
.	O
end	*(long)
=	O
binding	*(struct(*(char),long,long,int))
->	O
end	*(long)
;	O
s	*(char)
.	O
flags	int
=	O
0	int
;	O
while	O
(	O
(	O
position	long
=	O
find_node_separator	(*(struct(*(char),long,long,int)))->(long)
(	O
&	O
s	*(char)
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
char	O
*	O
nodename_start	*(char)
;	O
char	O
*	O
read_nodename	*(char)
;	O
int	O
found	int
;	O
s	*(char)
.	O
start	*(long)
=	O
position	long
;	O
s	*(char)
.	O
start	*(long)
+=	O
skip_node_separator	(*(char))->(int)
(	O
s	*(char)
.	O
buffer	*(struct)
+	O
s	*(char)
.	O
start	*(long)
)	O
;	O
offset	long
=	O
string_in_line	(*(char),*(char))->(int)
(	O
INFO_NODE_LABEL	*(char)
,	O
s	*(char)
.	O
buffer	*(struct)
+	O
s	*(char)
.	O
start	*(long)
)	O
;	O
if	O
(	O
offset	long
==	O
-	O
1	int
)	O
continue	O
;	O
s	*(char)
.	O
start	*(long)
+=	O
offset	long
;	O
s	*(char)
.	O
start	*(long)
+=	O
skip_whitespace	(*(char))->(int)
(	O
s	*(char)
.	O
buffer	*(struct)
+	O
s	*(char)
.	O
start	*(long)
)	O
;	O
nodename_start	*(char)
=	O
s	*(char)
.	O
buffer	*(struct)
+	O
s	*(char)
.	O
start	*(long)
;	O
read_quoted_string	(*(char),*(char),int,*(*(char)))->(long)
(	O
nodename_start	*(char)
,	O
"\n\r\t,"	*(char)
,	O
0	int
,	O
&	O
read_nodename	*(char)
)	O
;	O
if	O
(	O
!	O
read_nodename	*(char)
)	O
return	O
-	O
1	int
;	O
found	int
=	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
read_nodename	*(char)
,	O
nodename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
read_nodename	*(char)
)	O
;	O
if	O
(	O
found	int
)	O
return	O
position	long
;	O
}	O
return	O
-	O
1	int
;	O
}	O
