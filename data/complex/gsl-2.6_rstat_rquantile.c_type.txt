static	O
double	O
calc_psq	(double,double,double,double,double,double,double)->(double)
(	O
const	O
double	O
qp1	double
,	O
const	O
double	O
q	*(struct(long,*(long)))
,	O
const	O
double	O
qm1	double
,	O
const	O
double	O
d	double
,	O
const	O
double	O
np1	double
,	O
const	O
double	O
n	int
,	O
const	O
double	O
nm1	double
)	O
;	O
gsl_rstat_quantile_workspace	struct(double,array(double),array(int),array(double),array(double),long)
*	O
gsl_rstat_quantile_alloc	(double)->(*(struct(double,array(double),array(int),array(double),array(double),long)))
(	O
const	O
double	O
p	*(struct(long,*(long)))
)	O
{	O
gsl_rstat_quantile_workspace	struct(double,array(double),array(int),array(double),array(double),long)
*	O
w	array(long double)
;	O
w	array(long double)
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
gsl_rstat_quantile_workspace	struct(double,array(double),array(int),array(double),array(double),long)
)	O
)	O
;	O
if	O
(	O
w	array(long double)
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for workspace"	*(char)
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
w	array(long double)
->	O
p	*(struct(long,*(long)))
=	O
p	*(struct(long,*(long)))
;	O
gsl_rstat_quantile_reset	(*(struct(double,array(double),array(int),array(double),array(double),long)))->(int)
(	O
w	array(long double)
)	O
;	O
return	O
w	array(long double)
;	O
}	O
void	O
gsl_rstat_quantile_free	(*(struct(double,array(double),array(int),array(double),array(double),long)))->(void)
(	O
gsl_rstat_quantile_workspace	struct(double,array(double),array(int),array(double),array(double),long)
*	O
w	array(long double)
)	O
{	O
free	(*(void))->(void)
(	O
w	array(long double)
)	O
;	O
}	O
int	O
gsl_rstat_quantile_reset	(*(struct(double,array(double),array(int),array(double),array(double),long)))->(int)
(	O
gsl_rstat_quantile_workspace	struct(double,array(double),array(int),array(double),array(double),long)
*	O
w	array(long double)
)	O
{	O
const	O
double	O
p	*(struct(long,*(long)))
=	O
w	array(long double)
->	O
p	*(struct(long,*(long)))
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
5	int
;	O
++	O
i	long
)	O
w	array(long double)
->	O
npos	array(int)
[	O
i	long
]	O
=	O
i	long
+	O
1	int
;	O
w	array(long double)
->	O
np	array(double)
[	O
0	int
]	O
=	O
1.0	int
;	O
w	array(long double)
->	O
np	array(double)
[	O
1	int
]	O
=	O
1.0	int
+	O
2.0	int
*	O
p	*(struct(long,*(long)))
;	O
w	array(long double)
->	O
np	array(double)
[	O
2	int
]	O
=	O
1.0	int
+	O
4.0	int
*	O
p	*(struct(long,*(long)))
;	O
w	array(long double)
->	O
np	array(double)
[	O
3	int
]	O
=	O
3.0	int
+	O
2.0	int
*	O
p	*(struct(long,*(long)))
;	O
w	array(long double)
->	O
np	array(double)
[	O
4	int
]	O
=	O
5.0	int
;	O
w	array(long double)
->	O
dnp	array(double)
[	O
0	int
]	O
=	O
0.0	int
;	O
w	array(long double)
->	O
dnp	array(double)
[	O
1	int
]	O
=	O
0.5	int
*	O
p	*(struct(long,*(long)))
;	O
w	array(long double)
->	O
dnp	array(double)
[	O
2	int
]	O
=	O
p	*(struct(long,*(long)))
;	O
w	array(long double)
->	O
dnp	array(double)
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
1.0	int
+	O
p	*(struct(long,*(long)))
)	O
;	O
w	array(long double)
->	O
dnp	array(double)
[	O
4	int
]	O
=	O
1.0	int
;	O
w	array(long double)
->	O
n	int
=	O
0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_rstat_quantile_add	(double,*(struct(double,array(double),array(int),array(double),array(double),long)))->(int)
(	O
const	O
double	O
x	double
,	O
gsl_rstat_quantile_workspace	struct(double,array(double),array(int),array(double),array(double),long)
*	O
w	array(long double)
)	O
{	O
if	O
(	O
w	array(long double)
->	O
n	int
<	O
5	int
)	O
{	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
[	O
w	array(long double)
->	O
n	int
]	O
=	O
x	double
;	O
}	O
else	O
{	O
int	O
i	long
;	O
int	O
k	long
=	O
-	O
1	int
;	O
if	O
(	O
w	array(long double)
->	O
n	int
==	O
5	int
)	O
{	O
gsl_sort	(*(double),long,long)->(void)
(	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
,	O
1	int
,	O
w	array(long double)
->	O
n	int
)	O
;	O
}	O
if	O
(	O
x	double
<	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
[	O
0	int
]	O
)	O
{	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
[	O
0	int
]	O
=	O
x	double
;	O
k	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
x	double
>=	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
[	O
4	int
]	O
)	O
{	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
[	O
4	int
]	O
=	O
x	double
;	O
k	long
=	O
3	int
;	O
}	O
else	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
3	int
;	O
++	O
i	long
)	O
{	O
if	O
(	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
[	O
i	long
]	O
<=	O
x	double
&&	O
x	double
<	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
[	O
i	long
+	O
1	int
]	O
)	O
{	O
k	long
=	O
i	long
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
k	long
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"invalid input argument x"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
k	long
+	O
1	int
;	O
i	long
<=	O
4	int
;	O
++	O
i	long
)	O
++	O
(	O
w	array(long double)
->	O
npos	array(int)
[	O
i	long
]	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
5	int
;	O
++	O
i	long
)	O
w	array(long double)
->	O
np	array(double)
[	O
i	long
]	O
+=	O
w	array(long double)
->	O
dnp	array(double)
[	O
i	long
]	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<=	O
3	int
;	O
++	O
i	long
)	O
{	O
double	O
ni	double
=	O
(	O
double	O
)	O
w	array(long double)
->	O
npos	array(int)
[	O
i	long
]	O
;	O
double	O
d	double
=	O
w	array(long double)
->	O
np	array(double)
[	O
i	long
]	O
-	O
ni	double
;	O
if	O
(	O
(	O
d	double
>=	O
1.0	int
&&	O
(	O
w	array(long double)
->	O
npos	array(int)
[	O
i	long
+	O
1	int
]	O
-	O
w	array(long double)
->	O
npos	array(int)
[	O
i	long
]	O
>	O
1	int
)	O
)	O
||	O
(	O
d	double
<=	O
-	O
1.0	int
&&	O
(	O
w	array(long double)
->	O
npos	array(int)
[	O
i	long
-	O
1	int
]	O
-	O
w	array(long double)
->	O
npos	array(int)
[	O
i	long
]	O
<	O
-	O
1	int
)	O
)	O
)	O
{	O
int	O
dsign	int
=	O
(	O
d	double
>	O
0.0	int
)	O
?	O
1	int
:	O
-	O
1	int
;	O
double	O
qp1	double
=	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
[	O
i	long
+	O
1	int
]	O
;	O
double	O
qi	double
=	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
[	O
i	long
]	O
;	O
double	O
qm1	double
=	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
[	O
i	long
-	O
1	int
]	O
;	O
double	O
np1	double
=	O
(	O
double	O
)	O
w	array(long double)
->	O
npos	array(int)
[	O
i	long
+	O
1	int
]	O
;	O
double	O
nm1	double
=	O
(	O
double	O
)	O
w	array(long double)
->	O
npos	array(int)
[	O
i	long
-	O
1	int
]	O
;	O
double	O
qp	double
=	O
calc_psq	(double,double,double,double,double,double,double)->(double)
(	O
qp1	double
,	O
qi	double
,	O
qm1	double
,	O
(	O
double	O
)	O
dsign	int
,	O
np1	double
,	O
ni	double
,	O
nm1	double
)	O
;	O
if	O
(	O
qm1	double
<	O
qp	double
&&	O
qp	double
<	O
qp1	double
)	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
[	O
i	long
]	O
=	O
qp	double
;	O
else	O
{	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
[	O
i	long
]	O
+=	O
dsign	int
*	O
(	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
[	O
i	long
+	O
dsign	int
]	O
-	O
qi	double
)	O
/	O
(	O
(	O
double	O
)	O
w	array(long double)
->	O
npos	array(int)
[	O
i	long
+	O
dsign	int
]	O
-	O
ni	double
)	O
;	O
}	O
w	array(long double)
->	O
npos	array(int)
[	O
i	long
]	O
+=	O
dsign	int
;	O
}	O
}	O
}	O
++	O
(	O
w	array(long double)
->	O
n	int
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
double	O
gsl_rstat_quantile_get	(*(struct(double,array(double),array(int),array(double),array(double),long)))->(double)
(	O
gsl_rstat_quantile_workspace	struct(double,array(double),array(int),array(double),array(double),long)
*	O
w	array(long double)
)	O
{	O
if	O
(	O
w	array(long double)
->	O
n	int
>=	O
5	int
)	O
{	O
return	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
[	O
2	int
]	O
;	O
}	O
else	O
{	O
gsl_sort	(*(double),long,long)->(void)
(	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
,	O
1	int
,	O
w	array(long double)
->	O
n	int
)	O
;	O
return	O
gsl_stats_quantile_from_sorted_data	(array(double),long,long,double)->(double)
(	O
w	array(long double)
->	O
q	*(struct(long,*(long)))
,	O
1	int
,	O
w	array(long double)
->	O
n	int
,	O
w	array(long double)
->	O
p	*(struct(long,*(long)))
)	O
;	O
}	O
}	O
static	O
double	O
calc_psq	(double,double,double,double,double,double,double)->(double)
(	O
const	O
double	O
qp1	double
,	O
const	O
double	O
q	*(struct(long,*(long)))
,	O
const	O
double	O
qm1	double
,	O
const	O
double	O
d	double
,	O
const	O
double	O
np1	double
,	O
const	O
double	O
n	int
,	O
const	O
double	O
nm1	double
)	O
{	O
double	O
outer	double
=	O
d	double
/	O
(	O
np1	double
-	O
nm1	double
)	O
;	O
double	O
inner_left	double
=	O
(	O
n	int
-	O
nm1	double
+	O
d	double
)	O
*	O
(	O
qp1	double
-	O
q	*(struct(long,*(long)))
)	O
/	O
(	O
np1	double
-	O
n	int
)	O
;	O
double	O
inner_right	double
=	O
(	O
np1	double
-	O
n	int
-	O
d	double
)	O
*	O
(	O
q	*(struct(long,*(long)))
-	O
qm1	double
)	O
/	O
(	O
n	int
-	O
nm1	double
)	O
;	O
return	O
q	*(struct(long,*(long)))
+	O
outer	double
*	O
(	O
inner_left	double
+	O
inner_right	double
)	O
;	O
}	O
