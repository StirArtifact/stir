error_t	O
diskfs_init_dir	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
node	O
*	O
dp	*(struct)
,	O
struct	O
node	O
*	O
pdp	*(struct)
,	O
struct	O
protid	O
*	O
cred	*(struct)
)	O
{	O
dp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
dir	struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long)))
.	O
dotdot	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long))
=	O
pdp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
;	O
dp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
dir	struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long)))
.	O
entries	*(struct)
=	O
0	int
;	O
pdp	*(struct)
->	O
dn_stat	O
.	O
st_nlink	O
++	O
;	O
dp	*(struct)
->	O
dn_stat	O
.	O
st_nlink	O
++	O
;	O
return	O
0	int
;	O
}	O
error_t	O
diskfs_clear_directory	(*(struct),*(struct),*(struct))->(int)
(	O
struct	O
node	O
*	O
dp	*(struct)
,	O
struct	O
node	O
*	O
pdp	*(struct)
,	O
struct	O
protid	O
*	O
cred	*(struct)
)	O
{	O
if	O
(	O
dp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
dir	struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long)))
.	O
entries	*(struct)
!=	O
0	int
)	O
return	O
ENOTEMPTY	O
;	O
assert	()->(int)
(	O
dp	*(struct)
->	O
dn_stat	O
.	O
st_size	O
==	O
0	int
)	O
;	O
assert	()->(int)
(	O
dp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
dir	struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long)))
.	O
dotdot	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long))
==	O
pdp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
)	O
;	O
pdp	*(struct)
->	O
dn_stat	O
.	O
st_nlink	O
--	O
;	O
dp	*(struct)
->	O
dn_stat	O
.	O
st_nlink	O
--	O
;	O
return	O
0	int
;	O
}	O
int	O
diskfs_dirempty	(*(struct),*(struct))->(int)
(	O
struct	O
node	O
*	O
dp	*(struct)
,	O
struct	O
protid	O
*	O
cred	*(struct)
)	O
{	O
return	O
dp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
dir	struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long)))
.	O
entries	*(struct)
==	O
0	int
;	O
}	O
error_t	O
diskfs_get_directs	(*(struct),int,int,*(*(char)),*(long),int,*(int))->(int)
(	O
struct	O
node	O
*	O
dp	*(struct)
,	O
int	O
entry	int
,	O
int	O
n	int
,	O
char	O
*	O
*	O
data	*(*(char))
,	O
size_t	long
*	O
datacnt	*(long)
,	O
vm_size_t	O
bufsiz	int
,	O
int	O
*	O
amt	*(int)
)	O
{	O
struct	O
tmpfs_dirent	struct(*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct)))),int,array(char))
*	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
;	O
struct	O
dirent	O
*	O
entp	*(struct)
;	O
int	O
i	int
;	O
if	O
(	O
bufsiz	int
==	O
0	int
)	O
bufsiz	int
=	O
dp	*(struct)
->	O
dn_stat	O
.	O
st_size	O
+	O
2	int
*	O
(	O
(	O
offsetof	O
(	O
struct	O
dirent	O
,	O
d_name	O
[	O
3	int
]	O
)	O
+	O
7	int
)	O
&	O
~	O
7	int
)	O
;	O
if	O
(	O
bufsiz	int
>	O
*	O
datacnt	*(long)
)	O
{	O
*	O
data	*(*(char))
=	O
mmap	(*(void),long,int,int,int,long)->(*(void))
(	O
0	int
,	O
bufsiz	int
,	O
PROT_READ	int
|	O
PROT_WRITE	int
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
*	O
data	*(*(char))
==	O
MAP_FAILED	O
)	O
return	O
ENOMEM	O
;	O
}	O
entp	*(struct)
=	O
(	O
struct	O
dirent	O
*	O
)	O
*	O
data	*(*(char))
;	O
i	int
=	O
0	int
;	O
if	O
(	O
i	int
++	O
>=	O
entry	int
)	O
{	O
entp	*(struct)
->	O
d_fileno	O
=	O
dp	*(struct)
->	O
dn_stat	O
.	O
st_ino	O
;	O
entp	*(struct)
->	O
d_type	O
=	O
DT_DIR	O
;	O
entp	*(struct)
->	O
d_namlen	O
=	O
1	int
;	O
entp	*(struct)
->	O
d_name	O
[	O
0	int
]	O
=	O
'.'	O
;	O
entp	*(struct)
->	O
d_name	O
[	O
1	int
]	O
=	O
'\0'	O
;	O
entp	*(struct)
->	O
d_reclen	O
=	O
(	O
&	O
entp	*(struct)
->	O
d_name	O
[	O
2	int
]	O
-	O
(	O
char	O
*	O
)	O
entp	*(struct)
+	O
7	int
)	O
&	O
~	O
7	int
;	O
entp	*(struct)
=	O
(	O
void	O
*	O
)	O
entp	*(struct)
+	O
entp	*(struct)
->	O
d_reclen	O
;	O
}	O
if	O
(	O
i	int
++	O
>=	O
entry	int
)	O
{	O
if	O
(	O
dp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
dir	struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long)))
.	O
dotdot	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long))
==	O
0	int
)	O
{	O
assert	()->(int)
(	O
dp	*(struct)
==	O
diskfs_root_node	O
)	O
;	O
entp	*(struct)
->	O
d_fileno	O
=	O
2	int
;	O
}	O
else	O
entp	*(struct)
->	O
d_fileno	O
=	O
(	O
ino_t	long
)	O
(	O
uintptr_t	O
)	O
dp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
dir	struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long)))
.	O
dotdot	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long))
;	O
entp	*(struct)
->	O
d_type	O
=	O
DT_DIR	O
;	O
entp	*(struct)
->	O
d_namlen	O
=	O
2	int
;	O
entp	*(struct)
->	O
d_name	O
[	O
0	int
]	O
=	O
'.'	O
;	O
entp	*(struct)
->	O
d_name	O
[	O
1	int
]	O
=	O
'.'	O
;	O
entp	*(struct)
->	O
d_name	O
[	O
2	int
]	O
=	O
'\0'	O
;	O
entp	*(struct)
->	O
d_reclen	O
=	O
(	O
&	O
entp	*(struct)
->	O
d_name	O
[	O
3	int
]	O
-	O
(	O
char	O
*	O
)	O
entp	*(struct)
+	O
7	int
)	O
&	O
~	O
7	int
;	O
entp	*(struct)
=	O
(	O
void	O
*	O
)	O
entp	*(struct)
+	O
entp	*(struct)
->	O
d_reclen	O
;	O
}	O
for	O
(	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
=	O
dp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
dir	struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long)))
.	O
entries	*(struct)
;	O
i	int
<	O
entry	int
&&	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
!=	O
0	int
;	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
=	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
)	O
++	O
i	int
;	O
if	O
(	O
i	int
<	O
entry	int
)	O
{	O
assert	()->(int)
(	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
==	O
0	int
)	O
;	O
*	O
datacnt	*(long)
=	O
0	int
;	O
*	O
amt	*(int)
=	O
0	int
;	O
return	O
0	int
;	O
}	O
for	O
(	O
;	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
!=	O
0	int
;	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
=	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
,	O
i	int
++	O
)	O
{	O
size_t	long
rlen	long
=	O
(	O
offsetof	O
(	O
struct	O
dirent	O
,	O
d_name	O
[	O
1	int
]	O
)	O
+	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
namelen	int
+	O
7	int
)	O
&	O
~	O
7	int
;	O
if	O
(	O
rlen	long
+	O
(	O
char	O
*	O
)	O
entp	*(struct)
-	O
*	O
data	*(*(char))
>	O
bufsiz	int
||	O
(	O
n	int
>=	O
0	int
&&	O
i	int
>	O
n	int
)	O
)	O
break	O
;	O
entp	*(struct)
->	O
d_fileno	O
=	O
(	O
ino_t	long
)	O
(	O
uintptr_t	O
)	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
;	O
entp	*(struct)
->	O
d_type	O
=	O
DT_UNKNOWN	O
;	O
entp	*(struct)
->	O
d_namlen	O
=	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
namelen	int
;	O
memcpy	O
(	O
entp	*(struct)
->	O
d_name	O
,	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
name	array(char)
,	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
namelen	int
+	O
1	int
)	O
;	O
entp	*(struct)
->	O
d_reclen	O
=	O
rlen	long
;	O
entp	*(struct)
=	O
(	O
void	O
*	O
)	O
entp	*(struct)
+	O
rlen	long
;	O
}	O
*	O
datacnt	*(long)
=	O
(	O
char	O
*	O
)	O
entp	*(struct)
-	O
*	O
data	*(*(char))
;	O
*	O
amt	*(int)
=	O
i	int
-	O
entry	int
;	O
return	O
0	int
;	O
}	O
struct	O
dirstat	struct(*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char)))),int)
{	O
struct	O
tmpfs_dirent	struct(*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct)))),int,array(char))
*	O
*	O
prevp	*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char))))
;	O
int	O
dotdot	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long))
;	O
}	O
;	O
const	O
size_t	long
diskfs_dirstat_size	long
=	O
sizeof	O
(	O
struct	O
dirstat	struct(*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char)))),int)
)	O
;	O
void	O
diskfs_null_dirstat	(*(struct(*(*(struct`)),int)))->(void)
(	O
struct	O
dirstat	struct(*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char)))),int)
*	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
)	O
{	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
->	O
prevp	*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char))))
=	O
0	int
;	O
}	O
error_t	O
diskfs_drop_dirstat	(*(struct),*(struct(*(*(struct`)),int)))->(int)
(	O
struct	O
node	O
*	O
dp	*(struct)
,	O
struct	O
dirstat	struct(*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char)))),int)
*	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
)	O
{	O
return	O
0	int
;	O
}	O
error_t	O
diskfs_lookup_hard	(*(struct),*(char),enum,*(*(struct)),*(struct(*(*(struct`)),int)),*(struct))->(int)
(	O
struct	O
node	O
*	O
dp	*(struct)
,	O
const	O
char	O
*	O
name	array(char)
,	O
enum	O
lookup_type	O
type	int
,	O
struct	O
node	O
*	O
*	O
np	*(*(struct))
,	O
struct	O
dirstat	struct(*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char)))),int)
*	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
,	O
struct	O
protid	O
*	O
cred	*(struct)
)	O
{	O
const	O
size_t	long
namelen	int
=	O
strlen	O
(	O
name	array(char)
)	O
;	O
struct	O
tmpfs_dirent	struct(*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct)))),int,array(char))
*	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
,	O
*	O
*	O
prevp	*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char))))
;	O
if	O
(	O
type	int
==	O
REMOVE	O
||	O
type	int
==	O
RENAME	O
)	O
assert	()->(int)
(	O
np	*(*(struct))
)	O
;	O
if	O
(	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
)	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
->	O
dotdot	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long))
=	O
type	int
&	O
SPEC_DOTDOT	O
;	O
if	O
(	O
namelen	int
==	O
1	int
&&	O
name	array(char)
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
if	O
(	O
np	*(*(struct))
!=	O
0	int
)	O
{	O
*	O
np	*(*(struct))
=	O
dp	*(struct)
;	O
diskfs_nref	()->(int)
(	O
dp	*(struct)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
namelen	int
==	O
2	int
&&	O
name	array(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
name	array(char)
[	O
1	int
]	O
==	O
'.'	O
)	O
{	O
struct	O
disknode	struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long),*(struct),*(*(struct)))
*	O
dddn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
=	O
dp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
dir	struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long)))
.	O
dotdot	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long))
;	O
error_t	O
err	O
;	O
assert	()->(int)
(	O
np	*(*(struct))
!=	O
0	int
)	O
;	O
if	O
(	O
dddn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
==	O
0	int
)	O
return	O
EAGAIN	O
;	O
if	O
(	O
type	int
==	O
(	O
REMOVE	O
|	O
SPEC_DOTDOT	O
)	O
||	O
type	int
==	O
(	O
RENAME	O
|	O
SPEC_DOTDOT	O
)	O
)	O
{	O
*	O
np	*(*(struct))
=	O
*	O
dddn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hprevp	*(*(struct))
;	O
assert	()->(int)
(	O
*	O
np	*(*(struct))
)	O
;	O
assert	()->(int)
(	O
(	O
*	O
np	*(*(struct))
)	O
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
==	O
dddn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
)	O
;	O
assert	()->(int)
(	O
*	O
dddn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
hprevp	*(*(struct))
==	O
*	O
np	*(*(struct))
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
dp	*(struct)
->	O
lock	O
)	O
;	O
err	O
=	O
diskfs_cached_lookup	()->(int)
(	O
(	O
ino_t	long
)	O
(	O
intptr_t	long
)	O
dddn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
,	O
np	*(*(struct))
)	O
;	O
if	O
(	O
type	int
==	O
(	O
LOOKUP	O
|	O
SPEC_DOTDOT	O
)	O
)	O
diskfs_nrele	()->(int)
(	O
dp	*(struct)
)	O
;	O
else	O
pthread_mutex_lock	()->(int)
(	O
&	O
dp	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
err	O
)	O
*	O
np	*(*(struct))
=	O
0	int
;	O
return	O
err	O
;	O
}	O
}	O
for	O
(	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
=	O
*	O
(	O
prevp	*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char))))
=	O
&	O
dp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
dir	struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long)))
.	O
entries	*(struct)
)	O
;	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
!=	O
0	int
;	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
=	O
*	O
(	O
prevp	*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char))))
=	O
&	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
)	O
)	O
if	O
(	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
namelen	int
==	O
namelen	int
&&	O
!	O
memcmp	O
(	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
name	array(char)
,	O
name	array(char)
,	O
namelen	int
)	O
)	O
{	O
if	O
(	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
)	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
->	O
prevp	*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char))))
=	O
prevp	*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char))))
;	O
if	O
(	O
np	*(*(struct))
)	O
return	O
diskfs_cached_lookup	()->(int)
(	O
(	O
ino_t	long
)	O
(	O
uintptr_t	O
)	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
,	O
np	*(*(struct))
)	O
;	O
else	O
return	O
0	int
;	O
}	O
if	O
(	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
)	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
->	O
prevp	*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char))))
=	O
prevp	*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char))))
;	O
if	O
(	O
np	*(*(struct))
)	O
*	O
np	*(*(struct))
=	O
0	int
;	O
return	O
ENOENT	O
;	O
}	O
error_t	O
diskfs_direnter_hard	(*(struct),*(char),*(struct),*(struct(*(*(struct`)),int)),*(struct))->(int)
(	O
struct	O
node	O
*	O
dp	*(struct)
,	O
const	O
char	O
*	O
name	array(char)
,	O
struct	O
node	O
*	O
np	*(*(struct))
,	O
struct	O
dirstat	struct(*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char)))),int)
*	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
,	O
struct	O
protid	O
*	O
cred	*(struct)
)	O
{	O
const	O
size_t	long
namelen	int
=	O
strlen	O
(	O
name	array(char)
)	O
;	O
const	O
size_t	long
entsize	long
=	O
(	O
offsetof	O
(	O
struct	O
dirent	O
,	O
d_name	O
[	O
1	int
]	O
)	O
+	O
namelen	int
+	O
7	int
)	O
&	O
~	O
7	int
;	O
struct	O
tmpfs_dirent	struct(*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct)))),int,array(char))
*	O
new	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
;	O
if	O
(	O
round_page	()->(int)
(	O
tmpfs_space_used	long
+	O
entsize	long
)	O
/	O
vm_page_size	O
>	O
tmpfs_page_limit	long
)	O
return	O
ENOSPC	O
;	O
new	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
=	O
malloc	O
(	O
offsetof	O
(	O
struct	O
tmpfs_dirent	struct(*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct)))),int,array(char))
,	O
name	array(char)
)	O
+	O
namelen	int
+	O
1	int
)	O
;	O
if	O
(	O
new	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
==	O
0	int
)	O
return	O
ENOSPC	O
;	O
new	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
=	O
0	int
;	O
new	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
=	O
np	*(*(struct))
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
;	O
new	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
namelen	int
=	O
namelen	int
;	O
memcpy	O
(	O
new	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
name	array(char)
,	O
name	array(char)
,	O
namelen	int
+	O
1	int
)	O
;	O
*	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
->	O
prevp	*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char))))
=	O
new	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
;	O
dp	*(struct)
->	O
dn_stat	O
.	O
st_size	O
+=	O
entsize	long
;	O
adjust_used	(long)->(void)
(	O
entsize	long
)	O
;	O
dp	*(struct)
->	O
dn_stat	O
.	O
st_blocks	O
=	O
(	O
(	O
sizeof	O
*	O
dp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
+	O
dp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
translen	long
+	O
dp	*(struct)
->	O
dn_stat	O
.	O
st_size	O
+	O
511	int
)	O
/	O
512	int
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
diskfs_dirrewrite_hard	(*(struct),*(struct),*(struct(*(*(struct`)),int)))->(int)
(	O
struct	O
node	O
*	O
dp	*(struct)
,	O
struct	O
node	O
*	O
np	*(*(struct))
,	O
struct	O
dirstat	struct(*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char)))),int)
*	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
)	O
{	O
if	O
(	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
->	O
dotdot	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long))
)	O
dp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
u	union(*(char),struct(int,int,int),struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`)))),long,long)
.	O
dir	struct(*(struct),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long)))
.	O
dotdot	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long))
=	O
np	*(*(struct))
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
;	O
else	O
(	O
*	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
->	O
prevp	*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char))))
)	O
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
=	O
np	*(*(struct))
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
;	O
return	O
0	int
;	O
}	O
error_t	O
diskfs_dirremove_hard	(*(struct),*(struct(*(*(struct`)),int)))->(int)
(	O
struct	O
node	O
*	O
dp	*(struct)
,	O
struct	O
dirstat	struct(*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char)))),int)
*	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
)	O
{	O
struct	O
tmpfs_dirent	struct(*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct)))),int,array(char))
*	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
=	O
*	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
->	O
prevp	*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char))))
;	O
const	O
size_t	long
entsize	long
=	O
(	O
offsetof	O
(	O
struct	O
dirent	O
,	O
d_name	O
[	O
1	int
]	O
)	O
+	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
namelen	int
+	O
7	int
)	O
&	O
~	O
7	int
;	O
*	O
ds	*(struct(*(*(struct(*`,*`,int,array(char)))),int))
->	O
prevp	*(*(struct(*(struct(*`,*`,int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct`,struct`,struct`,int,*`,long,union`,*`,*`)),int,array(char))))
=	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
;	O
if	O
(	O
dp	*(struct)
->	O
dirmod_reqs	O
!=	O
0	int
)	O
diskfs_notice_dirchange	()->(int)
(	O
dp	*(struct)
,	O
DIR_CHANGED_UNLINK	O
,	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
->	O
name	array(char)
)	O
;	O
free	()->(int)
(	O
d	*(struct(*(struct(*(struct`),*(struct`),int,array(char))),*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*`,struct`,struct`,long,long),*(struct`),*(*`))),int,array(char)))
)	O
;	O
adjust_used	(long)->(void)
(	O
-	O
entsize	long
)	O
;	O
dp	*(struct)
->	O
dn_stat	O
.	O
st_size	O
-=	O
entsize	long
;	O
dp	*(struct)
->	O
dn_stat	O
.	O
st_blocks	O
=	O
(	O
(	O
sizeof	O
*	O
dp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
+	O
dp	*(struct)
->	O
dn	*(struct(int,int,long,int,long,int,int,int,struct(long,long),struct(long,long),struct(long,long),int,*(char),long,union(*(char),struct(int,int,int),struct(*(struct`),*(struct`)),long,long),*(struct),*(*(struct))))
->	O
translen	long
+	O
dp	*(struct)
->	O
dn_stat	O
.	O
st_size	O
+	O
511	int
)	O
/	O
512	int
)	O
;	O
return	O
0	int
;	O
}	O
