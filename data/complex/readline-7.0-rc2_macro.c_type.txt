char	O
*	O
rl_executing_macro	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
int	O
executing_macro_index	int
;	O
static	O
char	O
*	O
current_macro	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
int	O
current_macro_size	int
;	O
static	O
int	O
current_macro_index	int
;	O
struct	O
saved_macro	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
{	O
struct	O
saved_macro	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
next	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
;	O
char	O
*	O
string	*(char)
;	O
int	O
sindex	int
;	O
}	O
;	O
static	O
struct	O
saved_macro	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
macro_list	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
(	O
struct	O
saved_macro	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
)	O
NULL	O
;	O
void	O
_rl_with_macro_input	(*(char))->(void)
(	O
string	*(char)
)	O
char	O
*	O
string	*(char)
;	O
{	O
_rl_push_executing_macro	()->(void)
(	O
)	O
;	O
rl_executing_macro	*(char)
=	O
string	*(char)
;	O
executing_macro_index	int
=	O
0	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MACROINPUT	int
)	O
;	O
}	O
int	O
_rl_next_macro_key	()->(int)
(	O
)	O
{	O
int	O
c	int
;	O
if	O
(	O
rl_executing_macro	*(char)
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
rl_executing_macro	*(char)
[	O
executing_macro_index	int
]	O
==	O
0	int
)	O
{	O
_rl_pop_executing_macro	()->(void)
(	O
)	O
;	O
return	O
(	O
_rl_next_macro_key	()->(int)
(	O
)	O
)	O
;	O
}	O
c	int
=	O
rl_executing_macro	*(char)
[	O
executing_macro_index	int
++	O
]	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
&&	O
RL_ISSTATE	O
(	O
RL_STATE_READCMD	int
|	O
RL_STATE_MOREINPUT	int
)	O
&&	O
rl_executing_macro	*(char)
[	O
executing_macro_index	int
]	O
==	O
0	int
)	O
_rl_pop_executing_macro	()->(void)
(	O
)	O
;	O
return	O
c	int
;	O
}	O
int	O
_rl_prev_macro_key	()->(int)
(	O
)	O
{	O
if	O
(	O
rl_executing_macro	*(char)
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
executing_macro_index	int
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
executing_macro_index	int
--	O
;	O
return	O
(	O
rl_executing_macro	*(char)
[	O
executing_macro_index	int
]	O
)	O
;	O
}	O
void	O
_rl_push_executing_macro	()->(void)
(	O
)	O
{	O
struct	O
saved_macro	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
saver	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
saver	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
(	O
struct	O
saved_macro	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
saved_macro	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
)	O
)	O
;	O
saver	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
=	O
macro_list	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
saver	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
sindex	int
=	O
executing_macro_index	int
;	O
saver	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
string	*(char)
=	O
rl_executing_macro	*(char)
;	O
macro_list	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
saver	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
}	O
void	O
_rl_pop_executing_macro	()->(void)
(	O
)	O
{	O
struct	O
saved_macro	struct(*(struct(*(struct(*(struct`),*(char),int)),*(char),int)),*(char),int)
*	O
macro	*(char)
;	O
FREE	O
(	O
rl_executing_macro	*(char)
)	O
;	O
rl_executing_macro	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
executing_macro_index	int
=	O
0	int
;	O
if	O
(	O
macro_list	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
)	O
{	O
macro	*(char)
=	O
macro_list	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
;	O
rl_executing_macro	*(char)
=	O
macro_list	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
string	*(char)
;	O
executing_macro_index	int
=	O
macro_list	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
sindex	int
;	O
macro_list	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
=	O
macro_list	*(struct(*(struct(*(struct`),*(char),int)),*(char),int))
->	O
next	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
;	O
xfree	(*(void))->(void)
(	O
macro	*(char)
)	O
;	O
}	O
if	O
(	O
rl_executing_macro	*(char)
==	O
0	int
)	O
RL_UNSETSTATE	O
(	O
RL_STATE_MACROINPUT	int
)	O
;	O
}	O
void	O
_rl_add_macro_char	(int)->(void)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
if	O
(	O
current_macro_index	int
+	O
1	int
>=	O
current_macro_size	int
)	O
{	O
if	O
(	O
current_macro	*(char)
==	O
0	int
)	O
current_macro	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
current_macro_size	int
=	O
25	int
)	O
;	O
else	O
current_macro	*(char)
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
current_macro	*(char)
,	O
current_macro_size	int
+=	O
25	int
)	O
;	O
}	O
current_macro	*(char)
[	O
current_macro_index	int
++	O
]	O
=	O
c	int
;	O
current_macro	*(char)
[	O
current_macro_index	int
]	O
=	O
'\0'	O
;	O
}	O
void	O
_rl_kill_kbd_macro	()->(void)
(	O
)	O
{	O
if	O
(	O
current_macro	*(char)
)	O
{	O
xfree	(*(void))->(void)
(	O
current_macro	*(char)
)	O
;	O
current_macro	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
current_macro_size	int
=	O
current_macro_index	int
=	O
0	int
;	O
FREE	O
(	O
rl_executing_macro	*(char)
)	O
;	O
rl_executing_macro	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
executing_macro_index	int
=	O
0	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MACRODEF	int
)	O
;	O
}	O
int	O
rl_start_kbd_macro	(int,int)->(int)
(	O
ignore1	int
,	O
ignore2	int
)	O
int	O
ignore1	int
,	O
ignore2	int
;	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_MACRODEF	int
)	O
)	O
{	O
_rl_abort_internal	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
rl_explicit_arg	int
)	O
{	O
if	O
(	O
current_macro	*(char)
)	O
_rl_with_macro_input	(*(char))->(void)
(	O
savestring	O
(	O
current_macro	*(char)
)	O
)	O
;	O
}	O
else	O
current_macro_index	int
=	O
0	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MACRODEF	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_end_kbd_macro	(int,int)->(int)
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_MACRODEF	int
)	O
==	O
0	int
)	O
{	O
_rl_abort_internal	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
current_macro_index	int
-=	O
rl_key_sequence_length	int
;	O
current_macro	*(char)
[	O
current_macro_index	int
]	O
=	O
'\0'	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MACRODEF	int
)	O
;	O
return	O
(	O
rl_call_last_kbd_macro	(int,int)->(int)
(	O
--	O
count	int
,	O
0	int
)	O
)	O
;	O
}	O
int	O
rl_call_last_kbd_macro	(int,int)->(int)
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
if	O
(	O
current_macro	*(char)
==	O
0	int
)	O
_rl_abort_internal	()->(int)
(	O
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_MACRODEF	int
)	O
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
current_macro	*(char)
[	O
--	O
current_macro_index	int
]	O
=	O
'\0'	O
;	O
return	O
0	int
;	O
}	O
while	O
(	O
count	int
--	O
)	O
_rl_with_macro_input	(*(char))->(void)
(	O
savestring	O
(	O
current_macro	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_print_last_kbd_macro	(int,int)->(int)
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
char	O
*	O
m	*(char)
;	O
if	O
(	O
current_macro	*(char)
==	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
m	*(char)
=	O
_rl_untranslate_macro_value	(*(char),int)->(*(char))
(	O
current_macro	*(char)
,	O
1	int
)	O
;	O
rl_crlf	()->(int)
(	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
m	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
rl_crlf	()->(int)
(	O
)	O
;	O
FREE	O
(	O
m	*(char)
)	O
;	O
rl_forced_update_display	()->(int)
(	O
)	O
;	O
rl_display_fixed	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
rl_push_macro_input	(*(char))->(void)
(	O
macro	*(char)
)	O
char	O
*	O
macro	*(char)
;	O
{	O
_rl_with_macro_input	(*(char))->(void)
(	O
macro	*(char)
)	O
;	O
}	O
